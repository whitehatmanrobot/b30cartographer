emainingBytes : PAGE_SIZE);

                    NtfsUnpinBcb( IrpContext, &Bcb );
                    NtfsPinStream( IrpContext,
                                   Scb,
                                   CurrentFileOffset,
                                   BytesThisPage,
                                   &Bcb,
                                   &Buffer );

                    if (ARGUMENT_PRESENT(ThisScb)) {

                        //
                        //  Set the address range modified so that the data will get
                        //  written to its new "home".
                        //

                        MmSetAddressRangeModified( Buffer, BytesThisPage );

                    } else {

                        RtlCopyMemory( Buffer, CurrentValue, BytesThisPage );
                    }

                    if (LogNonresidentToo) {

                        (VOID)
                        NtfsWriteLog( IrpContext,
                                      Scb,
                                      Bcb,
                                      UpdateNonresidentValue,
                                      Buffer,
                                      BytesThisPage,
                                      Noop,
                                      NULL,
                                      0,
                                      CurrentFileOffset,
                                      0,
                                      0,
                                      BytesThisPage );


                    } else {

                        CcSetDirtyPinnedData( Bcb, NULL );
                    }

                    RemainingBytes -= BytesThisPage;
                    CurrentValue = (PVOID) Add2Ptr( CurrentValue, BytesThisPage );

                    (ULONG)CurrentFileOffset += BytesThisPage;
                }

            } finally {

                NtfsUnpinBcb( IrpContext, &Bcb );
            }

        } else {

            //
            //  We are going to write the old data directly to disk.
            //

            NtfsWriteClusters( IrpContext,
                               Vcb,
                               Scb,
                               (LONGLONG)0,
                               Value,
                               ClustersFromBytes( Vcb, ValueLength ));

            //
            //  Be sure to note that the data is actually on disk.
            //

            AdvanceOnly = TRUE;
        }
    }

    //
    //  We need to maintain the file size and valid data length in the
    //  Scb and attribute record.  For this attribute, the valid data
    //  size and the file size are now the value length.
    //

    Scb->Header.ValidDataLength = Scb->Header.FileSize;
    NtfsVerifySizes( &Scb->Header );

    NtfsWriteFileSizes( IrpContext,
                        Scb,
                        &Scb->Header.ValidDataLength.QuadPart,
                        AdvanceOnly,
                        LogIt,
                        FALSE );

    if (!WriteClusters) {

        //
        //  Let the cache manager know the new size for this attribute.
        //

        CcSetFileSizes( Scb->FileObject, (PCC_FILE_SIZES)&Scb->Header.AllocationSize );
    }

    //
    //  If this is the unnamed data attribute, we need to mark this
    //  change in the Fcb.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

        Fcb->Info.AllocatedLength = Scb->TotalAllocated;
        Fcb->Info.FileSize = Scb->Header.FileSize.QuadPart;

        SetFlag( Fcb->InfoFlags,
                 (FCB_INFO_CHANGED_ALLOC_SIZE | FCB_INFO_CHANGED_FILE_SIZE) );
    }

    DebugTrace( -1, Dbg, ("NtfsCreateNonresidentWithValue -> VOID\n") );
}


VOID
NtfsMapAttributeValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    OUT PVOID *Buffer,
    OUT PULONG Length,
    OUT PBCB *Bcb,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine may be called to map an entire attribute value.  It works
    whether the attribute is resident or nonresident.  It is intended for
    general handling of system-defined attributes which are small to medium
    in size, i.e. 0-64KB.  This routine will not work for attributes larger
    than the Cache Manager's virtual address granularity (currently 256KB),
    and this will be detected by the Cache Manager who will raise an error.

    Note that this routine only maps the data for read-only access.  To modify
    the data, the caller must call NtfsChangeAttributeValue AFTER UNPINNING
    THE BCB (IF THE SIZE IS CHANGING) returned from this routine.

Arguments:

    Fcb - Current file.

    Buffer - returns a pointer to the mapped attribute value.

    Length - returns the attribute value length in bytes.

    Bcb - Returns a Bcb which must be unpinned when done with the data, and
          before modifying the attribute value with a size change.

    Context - Attribute Context positioned at the attribute to change.

Return Value:

    None.

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    PSCB Scb;
    UNICODE_STRING AttributeName;
    BOOLEAN ReturnedExistingScb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsMapAttributeValue\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );

    Attribute = NtfsFoundAttribute(Context);

    //
    //  For the resident case, everything we need is in the
    //  attribute enumeration context.
    //

    if (NtfsIsAttributeResident(Attribute)) {

        *Buffer = NtfsAttributeValue( Attribute );
        *Length = Attribute->Form.Resident.ValueLength;
        *Bcb = NtfsFoundBcb(Context);
        NtfsFoundBcb(Context) = NULL;

        DebugTrace( 0, Dbg, ("Buffer < %08lx\n", *Buffer) );
        DebugTrace( 0, Dbg, ("Length < %08lx\n", *Length) );
        DebugTrace( 0, Dbg, ("Bcb < %08lx\n", *Bcb) );
        DebugTrace( -1, Dbg, ("NtfsMapAttributeValue -> VOID\n") );

        return;
    }

    //
    //  Otherwise, this is a nonresident attribute.  First create
    //  the Scb and stream.  Note we do not use any try-finally
    //  around this because we currently expect cleanup to get
    //  rid of these streams.
    //

    NtfsInitializeStringFromAttribute( &AttributeName, Attribute );

    Scb = NtfsCreateScb( IrpContext,
                         Fcb,
                         Attribute->TypeCode,
                         &AttributeName,
                         FALSE,
                         &ReturnedExistingScb );

    if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {
        NtfsUpdateScbFromAttribute( IrpContext, Scb, Attribute );
    }

    NtfsCreateInternalAttributeStream( IrpContext,
                                       Scb,
                                       FALSE,
                                       &NtfsInternalUseFile[MAPATTRIBUTEVALUE_FILE_NUMBER] );

    //
    //  Now just try to map the whole thing.  Count on the Cache Manager
    //  to complain if the attribute is too big to map all at once.
    //

    NtfsMapStream( IrpContext,
                   Scb,
                   (LONGLONG)0,
                   ((ULONG)Attribute->Form.Nonresident.FileSize),
                   Bcb,
                   Buffer );

    *Length = ((ULONG)Attribute->Form.Nonresident.FileSize);

    DebugTrace( 0, Dbg, ("Buffer < %08lx\n", *Buffer) );
    DebugTrace( 0, Dbg, ("Length < %08lx\n", *Length) );
    DebugTrace( 0, Dbg, ("Bcb < %08lx\n", *Bcb) );
    DebugTrace( -1, Dbg, ("NtfsMapAttributeValue -> VOID\n") );
}


VOID
NtfsChangeAttributeValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG ValueOffset,
    IN PVOID Value OPTIONAL,
    IN ULONG ValueLength,
    IN BOOLEAN SetNewLength,
    IN BOOLEAN LogNonresidentToo,
    IN BOOLEAN CreateSectionUnderway,
    IN BOOLEAN PreserveContext,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine changes the value of the specified attribute, optionally
    changing its size.

    The caller specifies the attribute to be changed via the attribute context,
    and must be prepared to clean up this context no matter how this routine
    returns.

    There are three byte ranges of interest for this routine.  The first is
    existing bytes to be perserved at the beginning of the attribute.  It
    begins a byte 0 and extends to the point where the attribute is being
    changed or the current end of the attribute, which ever is smaller.
    The second is the range of bytes which needs to be zeroed if the modified
    bytes begin past the current end of the file.  This range will be
    of length 0 if the modified range begins within the current range
    of bytes for the attribute.  The final range is the modified byte range.
    This is zeroed if no value pointer was specified.

    Ranges of zero bytes at the end of the attribute can be represented in
    non-resident attributes by a valid data length set to the beginning
    of what would be zero bytes.

    The following pictures illustrates these ranges when we writing data
    beyond the current end of the file.

        Current attribute
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

        Value
                                            VVVVVVVVVVVVVVVVVVVVVVVV

        Byte range to save
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

        Byte range to zero
                                        0000

        Resulting attribute
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ0000VVVVVVVVVVVVVVVVVVVVVVVV

    The following picture illustrates these ranges when we writing data
    which begins at or before the current end of the file.

        Current attribute
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

        Value
                                    VVVVVVVVVVVVVVVVVVVVVVVV

        Byte range to save
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

        Byte range to zero (None)


        Resulting attribute
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZVVVVVVVVVVVVVVVVVVVVVVVV

    The following picture illustrates these ranges when we writing data
    totally within the current range of the file without setting
    a new size.

        Current attribute
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

        Value
            VVVVVVVVVVVVVVVVVVVVVVVV

        Byte range to save (Save the whole range and then write over it)
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

        Byte range to zero (None)

        Resulting attribute
        ZZZZVVVVVVVVVVVVVVVVVVVVVVVVZZZZ

    The following picture illustrates these ranges when we writing data
    totally within the current range of the file while setting
    a new size.

        Current attribute
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

        Value
            VVVVVVVVVVVVVVVVVVVVVVVV

        Byte range to save (Only save the beginning)
        ZZZZ

        Byte range to zero (None)

        Resulting attribute
        ZZZZVVVVVVVVVVVVVVVVVVVVVVVV

    Any of the 'V' values above will be replaced by zeroes if the 'Value'
    parameter is not passed in.

Arguments:

    Fcb - Current file.

    ValueOffset - Byte offset within the attribute at which the value change is
                  to begin.

    Value - Pointer to the buffer containing the new value, if present.  Otherwise
        zeroes are desired.

    ValueLength - Length of the value in the above buffer.

    SetNewLength - FALSE if the size of the value is not changing, or TRUE if
                   the value length should be changed to ValueOffset + ValueLength.

    LogNonresidentToo - supplies TRUE if the update should be logged even if
                        the attribute is nonresident (such as for the
                        SECURITY_DESCRIPTOR).

    CreateSectionUnderway - if supplied as TRUE, then to the best of the caller's
                            knowledge, an MM Create Section could be underway,
                            which means that we cannot initiate caching on
                            this attribute, as that could cause deadlock.  The
                            value buffer in this case must be quad-aligned and
                            a multiple of cluster size in size.

    PreserveContext - Indicates if we need to lookup the attribute in case it
                      might move.

    Context - Attribute Context positioned at the attribute to change.

Return Value:

    None.

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    ATTRIBUTE_TYPE_CODE AttributeTypeCode;
    UNICODE_STRING AttributeName;
    ULONG NewSize;
    PVCB Vcb;
    BOOLEAN ReturnedExistingScb;
    BOOLEAN GoToNonResident = FALSE;
    PVOID Buffer;
    ULONG CurrentLength;
    LONG SizeChange, QuadSizeChange;
    ULONG RecordOffset;
    ULONG ZeroLength = 0;
    ULONG UnchangedSize = 0;
    PBCB Bcb = NULL;
    PSCB Scb = NULL;
    PVOID SaveBuffer = NULL;
    PVOID CopyInputBuffer = NULL;

    WCHAR NameBuffer[8];
    UNICODE_STRING SavedName;
    ATTRIBUTE_TYPE_CODE TypeCode;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    Vcb = Fcb->Vcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsChangeAttributeValue\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("ValueOffset = %08lx\n", ValueOffset) );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );
    DebugTrace( 0, Dbg, ("ValueLength = %08lx\n", ValueLength) );
    DebugTrace( 0, Dbg, ("SetNewLength = %02lx\n", SetNewLength) );
    DebugTrace( 0, Dbg, ("LogNonresidentToo = %02lx\n", LogNonresidentToo) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );

    //
    //  Get the file record and attribute pointers.
    //

    FileRecord = NtfsContainingFileRecord(Context);
    Attribute = NtfsFoundAttribute(Context);
    TypeCode = Attribute->TypeCode;

    //
    //  Set up a pointer to the name buffer in case we have to use it.
    //

    SavedName.Buffer = NameBuffer;

    //
    //  Get the current attribute value length.
    //

    if (NtfsIsAttributeResident(Attribute)) {

        CurrentLength = Attribute->Form.Resident.ValueLength;

    } else {

        if (((PLARGE_INTEGER)&Attribute->Form.Nonresident.AllocatedLength)->HighPart != 0) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        CurrentLength = ((ULONG)Attribute->Form.Nonresident.AllocatedLength);
    }

    ASSERT( SetNewLength || ((ValueOffset + ValueLength) <= CurrentLength) );

    //
    // Calculate how much the file record is changing by, and its new
    // size.  We also compute the size of the range of zero bytes.
    //

    if (SetNewLength) {

        NewSize = ValueOffset + ValueLength;
        SizeChange = NewSize - CurrentLength;
        QuadSizeChange = QuadAlign( NewSize ) - QuadAlign( CurrentLength );

        //
        //  If the new size is large enough, the size change may appear to be negative.
        //  In this case we go directly to the non-resident path.
        //

        if (NewSize > Vcb->BytesPerFileRecordSegment) {

            GoToNonResident = TRUE;
        }

    } else {

        NewSize = CurrentLength;
        SizeChange = 0;
        QuadSizeChange = 0;
    }

    //
    //  If we are zeroing a range in the file and it extends to the
    //  end of the file or beyond then make this a single zeroed run.
    //

    if (!ARGUMENT_PRESENT( Value )
        && ValueOffset >= CurrentLength) {

        ZeroLength = ValueOffset + ValueLength - CurrentLength;

        ValueOffset = ValueOffset + ValueLength;
        ValueLength = 0;

    //
    //  If we are writing data starting beyond the end of the
    //  file then we have a range of bytes to zero.
    //

    } else if (ValueOffset > CurrentLength) {

        ZeroLength = ValueOffset - CurrentLength;
    }

    //
    //  At this point we know the following ranges:
    //
    //      Range to save:  Not needed unless going resident to non-resident
    //
    //      Zero range: From Zero offset for length ZeroLength
    //
    //      Modified range:  From ValueOffset to NewSize, this length may
    //          be zero.
    //

    //
    //  If the attribute is resident, and it will stay resident, then we will
    //  handle that case first, and return.
    //

    if (NtfsIsAttributeResident( Attribute )

            &&

        !GoToNonResident

            &&

        ((QuadSizeChange <= (LONG)(FileRecord->BytesAvailable - FileRecord->FirstFreeByte))
         || ((Attribute->RecordLength + SizeChange) < Vcb->BigEnoughToMove))) {

        PVOID UndoBuffer;
        ULONG UndoLength;
        ULONG AttributeOffset;

        //
        //  If the attribute record is growing, then we have to get the new space
        //  now.
        //

        if (QuadSizeChange > 0) {

            BOOLEAN FirstPass = TRUE;

            ASSERT( !FlagOn(Attribute->Form.Resident.ResidentFlags, RESIDENT_FORM_INDEXED) );

            //
            //  Save a description of the attribute in case we have to look it up
            //  again.
            //

            SavedName.Length =
            SavedName.MaximumLength = (USHORT)(Attribute->NameLength * sizeof(WCHAR));

            if (SavedName.Length > sizeof(NameBuffer)) {

                SavedName.Buffer = NtfsAllocatePool( NonPagedPool, SavedName.Length );
            }

            //
            //  Copy the name into the buffer.
            //

            if (SavedName.Length != 0) {

                RtlCopyMemory( SavedName.Buffer,
                               Add2Ptr( Attribute, Attribute->NameOffset ),
                               SavedName.Length );
            }

            //
            //  Make sure we deallocate the name buffer.
            //

            try {

                do {

                    //
                    //  If not the first pass, we have to lookup the attribute
                    //  again.
                    //

                    if (!FirstPass) {

                        NtfsCleanupAttributeContext( IrpContext, Context );
                        NtfsInitializeAttributeContext( Context );

                        if (!NtfsLookupAttributeByName( IrpContext,
                                                        Fcb,
                                                        &Fcb->FileReference,
                                                        TypeCode,
                                                        &SavedName,
                                                        NULL,
                                                        FALSE,
                                                        Context )) {

                            ASSERT(FALSE);
                            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                        }

                        //
                        //  Now we have to reload our attribute pointer
                        //

                        Attribute = NtfsFoundAttribute( Context );
                    }

                    FirstPass = FALSE;

                //
                //  If FALSE is returned, then the space was not allocated and
                //  we have too loop back and try again.  Second time must work.
                //

                } while (!NtfsChangeAttributeSize( IrpContext,
                                                   Fcb,
                                                   QuadAlign( Attribute->Form.Resident.ValueOffset + NewSize),
                                                   Context ));
            } finally {

                if (SavedName.Buffer != NameBuffer) {

                    NtfsFreePool(SavedName.Buffer);
                }
            }

            //
            //  Now we have to reload our attribute pointer
            //

            FileRecord = NtfsContainingFileRecord(Context);
            Attribute = NtfsFoundAttribute(Context);

        } else {

            //
            //  Make sure the buffer is pinned if we are not changing size, because
            //  we begin to modify it below.
            //

            NtfsPinMappedAttribute( IrpContext, Vcb, Context );

            //
            //  We can eliminate some/all of the value if it has not changed.
            //

            if (ARGUMENT_PRESENT(Value)) {

                UnchangedSize = (ULONG)RtlCompareMemory( Add2Ptr(Attribute,
                                                          Attribute->Form.Resident.ValueOffset +
                                                            ValueOffset),
                                                  Value,
                                                  ValueLength );

                Value = Add2Ptr(Value, UnchangedSize);
                ValueOffset += UnchangedSize;
                ValueLength -= UnchangedSize;
            }
        }

        RecordOffset = PtrOffset(FileRecord, Attribute);

        //
        //  If there is a zero range of bytes, deal with it now.
        //  If we are zeroing data then we must be growing the
        //  file.
        //

        if (ZeroLength != 0) {

            //
            //  We always start zeroing at the zeroing offset.
            //

            AttributeOffset = Attribute->Form.Resident.ValueOffset +
                              CurrentLength;

            //
            //  If we are starting at the end of the file the undo
            //  buffer is NULL and the length is zero.
            //

            FileRecord->Lsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NtfsFoundBcb(Context),
                          UpdateResidentValue,
                          NULL,
                          ZeroLength,
                          UpdateResidentValue,
                          NULL,
                          0,
                          NtfsMftOffset( Context ),
                          RecordOffset,
                          AttributeOffset,
                          Vcb->BytesPerFileRecordSegment );

            //
            //  Now zero this data by calling the same routine as restart.
            //

            NtfsRestartChangeValue( IrpContext,
                                    FileRecord,
                                    RecordOffset,
                                    AttributeOffset,
                                    NULL,
                                    ZeroLength,
                                    TRUE );

#ifdef SYSCACHE_DEBUG
            {
                PSCB TempScb;

                TempScb = CONTAINING_RECORD( Fcb->ScbQueue.Flink, SCB, FcbLinks );
                while (&TempScb->FcbLinks != &Fcb->ScbQueue) {

                    if (ScbIsBeingLogged( TempScb )) {
                        FsRtlLogSyscacheEvent( TempScb, SCE_ZERO_MF, 0, AttributeOffset, ZeroLength, 0 );
                    }
                    TempScb = CONTAINING_RECORD( TempScb->FcbLinks.Flink, SCB, FcbLinks );
                }
            }
#endif
        }

        //
        //  Now log the new data for the file.  This range will always begin
        //  within the current range of bytes for the file.  Because of this
        //  there is an undo action.
        //
        //  Even if there is not a nonzero ValueLength, we still have to
        //  execute this code if the attribute is being truncated.
        //  The only exception is if we logged some zero data and have
        //  nothing left to log.
        //

        if ((ValueLength != 0)
            || (ZeroLength == 0
                && SizeChange != 0)) {

            //
            //  The attribute offset is always at the value offset.
            //

            AttributeOffset = Attribute->Form.Resident.ValueOffset + ValueOffset;

            //
            //  There are 3 possible cases for the undo action to
            //  log.
            //

            //
            //  If we are growing the file starting beyond the end of
            //  the file then undo buffer is NULL and the length is
            //  zero.  This will still allow us to shrink the file
            //  on abort.
            //

            if (ValueOffset >= CurrentLength) {

                UndoBuffer = NULL;
                UndoLength = 0;

            //
            //  For the other cases the undo buffer begins at the
            //  point of the change.
            //

            } else {

                UndoBuffer = Add2Ptr( Attribute,
                                      Attribute->Form.Resident.ValueOffset + ValueOffset );

                //
                //  If the size isn't changing then the undo length is the same as
                //  the redo length.
                //

                if (SizeChange == 0) {

                    UndoLength = ValueLength;

                //
                //  Otherwise the length is the range between the end of the
                //  file and the start of the new data.
                //

                } else {

                    UndoLength = CurrentLength - ValueOffset;
                }
            }

            FileRecord->Lsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NtfsFoundBcb(Context),
                          UpdateResidentValue,
                          Value,
                          ValueLength,
                          UpdateResidentValue,
                          UndoBuffer,
                          UndoLength,
                          NtfsMftOffset( Context ),
                          RecordOffset,
                          AttributeOffset,
                          Vcb->BytesPerFileRecordSegment );

            //
            //  Now update this data by calling the same routine as restart.
            //

            NtfsRestartChangeValue( IrpContext,
                                    FileRecord,
                                    RecordOffset,
                                    AttributeOffset,
                                    Value,
                                    ValueLength,
                                    (BOOLEAN)(SizeChange != 0) );
        }

        DebugTrace( -1, Dbg, ("NtfsChangeAttributeValue -> VOID\n") );

        return;
    }

    //
    //  Nonresident case.  Create the Scb and attributestream.
    //

    NtfsInitializeStringFromAttribute( &AttributeName, Attribute );
    AttributeTypeCode = Attribute->TypeCode;

    Scb = NtfsCreateScb( IrpContext,
                         Fcb,
                         AttributeTypeCode,
                         &AttributeName,
                         FALSE,
                         &ReturnedExistingScb );

    //
    //  Use try-finally for cleanup.
    //

    try {

        BOOLEAN AllocateBufferCopy = FALSE;
        BOOLEAN DeleteAllocation = FALSE;
        BOOLEAN LookupAttribute = FALSE;

        BOOLEAN AdvanceValidData = FALSE;
        LONGLONG NewValidDataLength;
        LONGLONG LargeValueOffset;

        LONGLONG LargeNewSize;

        if (SetNewLength
            && NewSize > Scb->Header.FileSize.LowPart
            && TypeCode == $ATTRIBUTE_LIST) {

            AllocateBufferCopy = TRUE;
        }

        LargeNewSize = NewSize;

        LargeValueOffset = ValueOffset;

        //
        //  Well, the attribute is either changing to nonresident, or it is already
        //  nonresident.  First we will handle the conversion to nonresident case.
        //  We can detect this case by whether or not the attribute is currently
        //  resident.
        //

        if (NtfsIsAttributeResident(Attribute)) {

            NtfsConvertToNonresident( IrpContext,
                                      Fcb,
                                      Attribute,
                                      CreateSectionUnderway,
                                      Context );

            //
            //  Reload the attribute pointer from the context.
            //

            Attribute = NtfsFoundAttribute( Context );

        //
        //  The process of creating a non resident attribute will also create
        //  and initialize a stream file for the Scb.  If the file is already
        //  non-resident we also need a stream file.
        //

        } else {

            NtfsCreateInternalAttributeStream( IrpContext,
                                               Scb,
                                               TRUE,
                                               &NtfsInternalUseFile[CHANGEATTRIBUTEVALUE_FILE_NUMBER] );
        }

        //
        //  If the attribute is already nonresident, make sure the allocation
        //  is the right size.  We grow it before we log the data to be sure
        //  we have the space for the new data.  We shrink it after we log the
        //  new data so we have the old data available for the undo.
        //

        if (((PLARGE_INTEGER)&Attribute->Form.Nonresident.AllocatedLength)->HighPart != 0) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        if (NewSize > ((ULONG)Attribute->Form.Nonresident.AllocatedLength)) {

            LONGLONG NewAllocation;

            if (PreserveContext) {

                //
                //  Save a description of the attribute in case we have to look it up
                //  again.
                //

                SavedName.Length =
                SavedName.MaximumLength = (USHORT)(Attribute->NameLength * sizeof(WCHAR));

                if (SavedName.Length > sizeof(NameBuffer)) {

                    SavedName.Buffer = NtfsAllocatePool( NonPagedPool, SavedName.Length );
                }

                //
                //  Copy the name into the buffer.
                //

                if (SavedName.Length != 0) {

                    RtlCopyMemory( SavedName.Buffer,
                                   Add2Ptr( Attribute, Attribute->NameOffset ),
                                   SavedName.Length );
                }

                LookupAttribute = TRUE;
            }

            //
            //  If this is the attribute list then check if we want to allocate a larger block.
            //  This way the attribute list doesn't get too fragmented.
            //

            NewAllocation = NewSize - ((ULONG)Attribute->Form.Nonresident.AllocatedLength);

            if (Scb->AttributeTypeCode == $ATTRIBUTE_LIST) {

                if ((ULONG) Attribute->Form.Nonresident.AllocatedLength > (4 * PAGE_SIZE)) {

                    NewAllocation += (2 * PAGE_SIZE);

                } else if ((ULONG) Attribute->Form.Nonresident.AllocatedLength > PAGE_SIZE) {

                    NewAllocation += PAGE_SIZE;
                }
            }

            NtfsAddAllocation( IrpContext,
                               Scb->FileObject,
                               Scb,
                               LlClustersFromBytes( Vcb, Attribute->Form.Nonresident.AllocatedLength ),
                               LlClustersFromBytes( Vcb, NewAllocation ),
                               FALSE,
                               NULL );

            //
            //  AddAllocation will adjust the sizes in the Scb and report
            //  the new size to the cache manager.  We need to remember if
            //  we changed the sizes for the unnamed data attribute.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                Fcb->Info.AllocatedLength = Scb->TotalAllocated;

                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
            }

        } else if (Vcb->BytesPerCluster <=
                   ((ULONG)Attribute->Form.Nonresident.AllocatedLength) - NewSize) {

            if ((Scb->AttributeTypeCode != $ATTRIBUTE_LIST) ||
                ((NewSize + Vcb->BytesPerCluster) * 2 < ((ULONG) Attribute->Form.Nonresident.AllocatedLength))) {

                DeleteAllocation = TRUE;
            }
        }

        //
        // Now, write in the data.
        //

        if ((ValueLength != 0
             && ARGUMENT_PRESENT( Value ))

            || (LogNonresidentToo
                && SetNewLength)) {

            BOOLEAN BytesToUndo;

            //
            //  We have to compute the amount of data to zero in a different
            //  way than we did for the resident case.  For the non-resident
            //  case we need to zero the data between the old valid data
            //  length and the offset in the file for the new data.
            //

            if (LargeValueOffset >= Scb->Header.ValidDataLength.QuadPart) {

                ZeroLength = (ULONG)(LargeValueOffset - Scb->Header.ValidDataLength.QuadPart);
                BytesToUndo = FALSE;

            } else {

                ZeroLength = 0;
                BytesToUndo = TRUE;
            }

            //
            //  Update existing nonresident attribute.  (We may have just created it
            //  above.)
            //
            //  If we are supposed to log it, then pin, log and do the update here.
            //

            if (LogNonresidentToo) {

                //
                //  At this point the attribute is non-resident and contains
                //  its previous value.  If the new data lies beyond the
                //  previous valid data, we need to zero this data.  This
                //  action won't require any undo.  Otherwise the new data
                //  lies within the existing data.  In this case we need to
                //  log the previous data for possible undo.  Finally, the
                //  tail of the new data may extend beyond the end of the
                //  previous data.  There is no undo requirement for these
                //  bytes.
                //
                //  We do the logging operation in three steps:
                //
                //      1 - We find the all the pages in the attribute that
                //          we need to zero any bytes for.  There is no
                //          undo for these bytes.
                //
                //      2 - Find all pages where we have to perform undo and
                //          log the changes to those pages.  Note only
                //          step 1 or step 2 will be performed as they
                //          are mutually exclusive.
                //
                //      3 - Finally, we may have pages where the new data
                //          extends beyond the current final page in the
                //          attribute.  We log the new data but there is
                //          no undo.
                //
                //      4 - We may have pages where the old data extends
                //          beyond the new data.  We will log this old
                //          data in the event that we grow and shrink
                //          this attribute several times in the same
                //          transaction (changes to the attribute list).
                //          In this case there is redo but no undo.
                //

                LONGLONG CurrentPage;
                ULONG PageOffset;

                ULONG ByteCountToUndo;
                ULONG NewBytesRemaining;

                //
                //  Find the starting page for this operation.  It is the
                //  ValidDataLength rounded down to a page boundary.
                //

                CurrentPage = Scb->Header.ValidDataLength.QuadPart;
                PageOffset = (ULONG)CurrentPage & (PAGE_SIZE - 1);

                (ULONG)CurrentPage = ((ULONG)CurrentPage & ~(PAGE_SIZE - 1));

                //
                //  Loop until there are no more bytes to zero.
                //

                while (ZeroLength != 0) {

                    ULONG ZeroBytesThisPage;

                    ZeroBytesThisPage = PAGE_SIZE - PageOffset;

                    if (ZeroBytesThisPage > ZeroLength) {

                        ZeroBytesThisPage = ZeroLength;
                    }

                    //
                    //  Pin the desired page and compute a buffer into the
                    //  page.  Also compute how many bytes we we zero on
                    //  this page.
                    //

                    NtfsUnpinBcb( IrpContext, &Bcb );

                    NtfsPinStream( IrpContext,
                                   Scb,
                                   CurrentPage,
                                   ZeroBytesThisPage + PageOffset,
                                   &Bcb,
                                   &Buffer );

                    Buffer = Add2Ptr( Buffer, PageOffset );

                    //
                    //  Now write the zeros into the log.
                    //

                    (VOID)
                    NtfsWriteLog( IrpContext,
                                  Scb,
                                  Bcb,
                                  UpdateNonresidentValue,
                                  NULL,
                                  ZeroBytesThisPage,
                                  Noop,
                                  NULL,
                                  0,
                                  CurrentPage,
                                  PageOffset,
                                  0,
                                  ZeroBytesThisPage + PageOffset );

                    //
                    //  Zero any data necessary.
                    //

                    RtlZeroMemory( Buffer, ZeroBytesThisPage );


#ifdef SYSCACHE_DEBUG
                    if (ScbIsBeingLogged( Scb )) {
                        FsRtlLogSyscacheEvent( Scb, SCE_ZERO_MF, 0, CurrentPage, ZeroBytesThisPage, 1 );
                    }
#endif

                    //
                    //  Now move through the file.
                    //

                    ZeroLength -= ZeroBytesThisPage;

                    CurrentPage = CurrentPage + PAGE_SIZE;
                    PageOffset = 0;
                }

                //
                //  Find the starting page for this operation.  It is the
                //  ValueOffset rounded down to a page boundary.
                //

                CurrentPage = LargeValueOffset;
                (ULONG)CurrentPage = ((ULONG)CurrentPage & ~(PAGE_SIZE - 1));

                PageOffset = (ULONG)LargeValueOffset & (PAGE_SIZE - 1);

                //
                //  Now loop until there are no more pages with undo
                //  bytes to log.
                //

                NewBytesRemaining = ValueLength;

                if (BytesToUndo) {

                    ByteCountToUndo = (ULONG)(Scb->Header.ValidDataLength.QuadPart - LargeValueOffset);

                    //
                    //  If we are spanning pages, growing the file and the
                    //  input buffer points into the cache, we could lose
                    //  data as we cross a page boundary.  In that case
                    //  we need to allocate a separate buffer.
                    //

                    if (AllocateBufferCopy
                        && NewBytesRemaining + PageOffset > PAGE_SIZE) {

                        CopyInputBuffer = NtfsAllocatePool(PagedPool, NewBytesRemaining );
                        RtlCopyMemory( CopyInputBuffer,
                                       Value,
                                       NewBytesRemaining );

                        Value = CopyInputBuffer;

                        AllocateBufferCopy = FALSE;
                    }

                    //
                    //  If we aren't setting a new length then limit the
                    //  undo bytes to those being overwritten.
                    //

                    if (!SetNewLength
                        && ByteCountToUndo > NewBytesRemaining) {

                        ByteCountToUndo = NewBytesRemaining;
                    }

                    while (ByteCountToUndo != 0) {

                        ULONG UndoBytesThisPage;
                        ULONG RedoBytesThisPage;
                        ULONG BytesThisPage;

                        NTFS_LOG_OPERATION RedoOperation;
                        PVOID RedoBuffer;

                        //
                        //  Also compute the number of bytes of undo and
                        //  redo on this page.
                        //

                        RedoBytesThisPage = UndoBytesThisPage = PAGE_SIZE - PageOffset;

                        if (RedoBytesThisPage > NewBytesRemaining) {

                            RedoBytesThisPage = NewBytesRemaining;
                        }

                        if (UndoBytesThisPage >= ByteCountToUndo) {

                            UndoBytesThisPage = ByteCountToUndo;
                        }

                        //
                        //  We pin enough bytes on this page to cover both the
                        //  redo and undo bytes.
                        //

                        if (UndoBytesThisPage > RedoBytesThisPage) {

                            BytesThisPage = PageOffset + UndoBytesThisPage;

                        } else {

                            BytesThisPage = PageOffset + RedoBytesThisPage;
                        }

                        //
                        //  If there is no redo (we are shrinking the data),
                        //  then make the redo a noop.
                        //

                        if (RedoBytesThisPage == 0) {

                            RedoOperation = Noop;
                            RedoBuffer = NULL;

                        } else {

                            RedoOperation = UpdateNonresidentValue;
                            RedoBuffer = Value;
                        }

                        //
                        //  Now we pin the page and calculate the beginning
                        //  buffer in the page.
                        //

                        NtfsUnpinBcb( IrpContext, &Bcb );

                        NtfsPinStream( IrpContext,
                                       Scb,
                                       CurrentPage,
                                       BytesThisPage,
                                       &Bcb,
                                       &Buffer );

                        Buffer = Add2Ptr( Buffer, PageOffset );

                        //
                        //  Now log the changes to this page.
                        //

                        (VOID)
                        NtfsWriteLog( IrpContext,
                                      Scb,
                                      Bcb,
                                      RedoOperation,
                                      RedoBuffer,
                                      RedoBytesThisPage,
                                      UpdateNonresidentValue,
                                      Buffer,
                                      UndoBytesThisPage,
                                      CurrentPage,
                                      PageOffset,
                                      0,
                                      BytesThisPage );

                        //
                        //  Move the data into place if we have new data.
                        //

                        if (RedoBytesThisPage != 0) {

                            RtlMoveMemory( Buffer, Value, RedoBytesThisPage );
                        }

                        //
                        //  Now decrement the counts and move through the
                        //  caller's buffer.
                        //

                        ByteCountToUndo -= UndoBytesThisPage;
                        NewBytesRemaining -= RedoBytesThisPage;

                        CurrentPage = PAGE_SIZE + CurrentPage;
                        PageOffset = 0;

                        Value = Add2Ptr( Value, RedoBytesThisPage );
                    }
                }

                //
                //  Now loop until there are no more pages with new data
                //  to log.
                //

                while (NewBytesRemaining != 0) {

                    ULONG RedoBytesThisPage;

                    //
                    //  Also compute the number of bytes of redo on this page.
                    //

                    RedoBytesThisPage = PAGE_SIZE - PageOffset;

                    if (RedoBytesThisPage > NewBytesRemaining) {

                        RedoBytesThisPage = NewBytesRemaining;
                    }

                    //
                    //  Now we pin the page and calculate the beginning
                    //  buffer in the page.
                    //

                    NtfsUnpinBcb( IrpContext, &Bcb );

                    NtfsPinStream( IrpContext,
                                   Scb,
                                   CurrentPage,
                                   RedoBytesThisPage,
                                   &Bcb,
                                   &Buffer );

                    Buffer = Add2Ptr( Buffer, PageOffset );

                    //
                    //  Now log the changes to this page.
                    //

                    (VOID)
                    NtfsWriteLog( IrpContext,
                                  Scb,
                                  Bcb,
                                  UpdateNonresidentValue,
                                  Value,
                                  RedoBytesThisPage,
                                  Noop,
                                  NULL,
                                  0,
                                  CurrentPage,
                                  PageOffset,
                                  0,
                                  PageOffset + RedoBytesThisPage );

                    //
                    //  Move the data into place.
                    //

                    RtlMoveMemory( Buffer, Value, RedoBytesThisPage );

                    //
                    //  Now decrement the counts and move through the
                    //  caller's buffer.
                    //

                    NewBytesRemaining -= RedoBytesThisPage;

                    CurrentPage = PAGE_SIZE + CurrentPage;
                    PageOffset = 0;

                    Value = Add2Ptr( Value, RedoBytesThisPage );
                }

            //
            //  If we have values to write, we write them to the cache now.
            //

            } else {

                //
                //  If we have data to zero, we do no now.
                //

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    FsRtlLogSyscacheEvent( Scb, SCE_ZERO_MF, 0, Scb->Header.ValidDataLength.QuadPart, ZeroLength, 2 );
                }
#endif

                if (ZeroLength != 0) {

                    if (!NtfsZeroData( IrpContext,
                                       Scb,
                                       Scb->FileObject,
                                       Scb->Header.ValidDataLength.QuadPart,
                                       (LONGLONG)ZeroLength,
                                       NULL )) {

                        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );

                    }
                }

                if (!CcCopyWrite( Scb->FileObject,
                                  (PLARGE_INTEGER)&LargeValueOffset,
                                  ValueLength,
                                  (BOOLEAN) FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ),
                                  Value )) {

                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }
            }

            //
            //  We need to remember the new valid data length in the
            //  Scb if it is greater than the existing.
            //

            NewValidDataLength = LargeValueOffset + ValueLength;

            if (NewValidDataLength > Scb->Header.ValidDataLength.QuadPart) {

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    FsRtlLogSyscacheEvent( Scb, SCE_ZERO_MF, SCE_FLAG_SET_VDL, Scb->Header.ValidDataLength.QuadPart, NewValidDataLength, 0 );
                }
#endif
                Scb->Header.ValidDataLength.QuadPart = NewValidDataLength;

                //
                //  If we took the log non-resident path, then we
                //  want to advance this on the disk as well.
                //

                if (LogNonresidentToo) {

                    AdvanceValidData = TRUE;
                }

                SetFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
            }

            //
            //  We need to maintain the file size in the Scb.  If we grow the
            //  file, we extend the cache file size.  We always set the
            //  valid data length in the Scb to the new file size.  The
            //  'AdvanceValidData' boolean and the current size on the
            //  disk will determine if it changes on disk.
            //

            if (SetNewLength) {

                Scb->Header.ValidDataLength.QuadPart = NewValidDataLength;
            }
        }

        if (SetNewLength) {

            Scb->Header.FileSize.QuadPart = LargeNewSize;

            if (LogNonresidentToo) {
                Scb->Header.ValidDataLength.QuadPart = LargeNewSize;
            }
        }

        //
        //  Note VDD is nonzero only for compressed files
        //

        if (Scb->Header.ValidDataLength.QuadPart < Scb->ValidDataToDisk) {

            Scb->ValidDataToDisk = Scb->Header.ValidDataLength.QuadPart;
        }

        //
        //  If there is allocation to delete, we do so now.
        //

        if (DeleteAllocation) {

            //
            //  If this is an attribute list then leave at least one full cluster at the
            //  end.  We don't want to trim off a cluster and then try to regrow the attribute
            //  list within the same transaction.
            //

            if (Scb->AttributeTypeCode == $ATTRIBUTE_LIST) {

                LargeNewSize += Vcb->BytesPerCluster;

                ASSERT( LargeNewSize <= Scb->Header.AllocationSize.QuadPart );
            }

            NtfsDeleteAllocation( IrpContext,
                                  Scb->FileObject,
                                  Scb,
                                  LlClustersFromBytes( Vcb, LargeNewSize ),
                                  MAXLONGLONG,
                                  TRUE,
                                  FALSE );

            //
            //  DeleteAllocation will adjust the sizes in the Scb and report
            //  the new size to the cache manager.  We need to remember if
            //  we changed the sizes for the unnamed data attribute.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                Fcb->Info.AllocatedLength = Scb->TotalAllocated;
                Fcb->Info.FileSize = Scb->Header.FileSize.QuadPart;

                SetFlag( Fcb->InfoFlags,
                         (FCB_INFO_CHANGED_ALLOC_SIZE | FCB_INFO_CHANGED_FILE_SIZE) );
            }

            if (AdvanceValidData) {

                NtfsWriteFileSizes( IrpContext,
                                    Scb,
                                    &Scb->Header.ValidDataLength.QuadPart,
                                    TRUE,
                                    TRUE,
                                    TRUE );
            }

        } else if (SetNewLength) {

            PFILE_OBJECT CacheFileObject = NULL;

            //
            //  If there is no file object, we will create a stream file
            //  now,
            //

            if (Scb->FileObject != NULL) {

                CacheFileObject = Scb->FileObject;

            } else if (!CreateSectionUnderway) {

                NtfsCreateInternalAttributeStream( IrpContext,
                                                   Scb,
                                                   FALSE,
                                                   &NtfsInternalUseFile[CHANGEATTRIBUTEVALUE2_FILE_NUMBER] );

                CacheFileObject = Scb->FileObject;

            } else {

                PIO_STACK_LOCATION IrpSp;

                IrpSp = IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp );

                if (IrpSp->FileObject->SectionObjectPointer == &Scb->NonpagedScb->SegmentObject) {

                    CacheFileObject = IrpSp->FileObject;
                }
            }

            ASSERT( CacheFileObject != NULL );

            NtfsSetBothCacheSizes( CacheFileObject,
                                   (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                                   Scb );

            //
            //  If this is the unnamed data attribute, we need to mark this
            //  change in the Fcb.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                Fcb->Info.FileSize = Scb->Header.FileSize.QuadPart;
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_SIZE );
            }

            //
            //  Now update the sizes on the disk.
            //  The new sizes will already be in the Scb.
            //

            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &Scb->Header.ValidDataLength.QuadPart,
                                AdvanceValidData,
                                TRUE,
                                TRUE );

        } else if (AdvanceValidData) {

            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &Scb->Header.ValidDataLength.QuadPart,
                                TRUE,
                                TRUE,
                                TRUE );
        }

        //
        //  Look up the attribute again in case it moved.
        //

        if (LookupAttribute) {

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );

            if (!NtfsLookupAttributeByName( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            TypeCode,
                                            &SavedName,
                                            NULL,
                                            FALSE,
                                            Context )) {

                ASSERT( FALSE );
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }
        }

    } finally {

        DebugUnwind( NtfsChangeAttributeValue );

        if (CopyInputBuffer != NULL) {

            NtfsFreePool( CopyInputBuffer );
        }

        if (SaveBuffer != NULL) {

            NtfsFreePool( SaveBuffer );
        }

        NtfsUnpinBcb( IrpContext, &Bcb );

        DebugTrace( -1, Dbg, ("NtfsChangeAttributeValue -> VOID\n") );
    }
}


VOID
NtfsConvertToNonresident (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PATTRIBUTE_RECORD_HEADER Attribute,
    IN BOOLEAN CreateSectionUnderway,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    This routine converts a resident attribute to nonresident.  It does so
    by allocating a buffer and copying the data and attribute name away,
    deleting the attribute, allocating a new attribute of the right size,
    and then copying the data back out again.

Arguments:

    Fcb - Requested file.

    Attribute - Supplies a pointer to the attribute to convert.

    CreateSectionUnderway - if supplied as TRUE, then to the best of the caller's
                            knowledge, an MM Create Section could be underway,
                            which means that we cannot initiate caching on
                            this attribute, as that could cause deadlock.  The
                            value buffer in this case must be quad-aligned and
                            a multiple of cluster size in size.

    Context - An attribute context to look up another attribute in the same
              file record.  If supplied, we insure that the context is valid
              for converted attribute.

Return Value:

    None

--*/

{
    PVOID Buffer;
    PVOID AllocatedBuffer = NULL;
    ULONG AllocatedLength;
    ULONG AttributeNameOffset;

    ATTRIBUTE_ENUMERATION_CONTEXT LocalContext;
    BOOLEAN CleanupLocalContext = FALSE;
    BOOLEAN ReturnedExistingScb;

    ATTRIBUTE_TYPE_CODE AttributeTypeCode = Attribute->TypeCode;
    USHORT AttributeFlags = Attribute->Flags;
    PVOID AttributeValue = NULL;
    ULONG ValueLength;

    UNICODE_STRING AttributeName;
    WCHAR AttributeNameBuffer[16];

    BOOLEAN WriteClusters = CreateSectionUnderway;

    PBCB ResidentBcb = NULL;
    PSCB Scb = NULL;

    PAGED_CODE();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Build a temporary copy of the name out of the attribute.
        //

        AttributeName.MaximumLength =
        AttributeName.Length = Attribute->NameLength * sizeof( WCHAR );
        AttributeName.Buffer = Add2Ptr( Attribute, Attribute->NameOffset );

        //
        //  If we don't have an attribute context for this attribute then look it
        //  up now.
        //

        if (!ARGUMENT_PRESENT( Context )) {

            Context = &LocalContext;
            NtfsInitializeAttributeContext( Context );
            CleanupLocalContext = TRUE;

            //
            //  Lookup the first occurence of this attribute.
            //

            if (!NtfsLookupAttributeByName( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            AttributeTypeCode,
                                            &AttributeName,
                                            NULL,
                                            FALSE,
                                            Context )) {

                DebugTrace( 0, 0, ("Could not find attribute being converted\n") );

                ASSERTMSG("Could not find attribute being converted, About to raise corrupt ", FALSE);
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }
        }

        //
        //  We need to figure out how much pool to allocate.  If there is a mapped
        //  view of this section or a section is being created we will allocate a buffer
        //  and copy the data into the buffer.  Otherwise we will pin the data in
        //  the cache, mark it dirty and use that buffer to perform the conversion.
        //

        AllocatedLength = AttributeName.Length;

        Scb = NtfsCreateScb( IrpContext,
                             Fcb,
                             AttributeTypeCode,
                             &AttributeName,
                             FALSE,
                             &ReturnedExistingScb );

        //
        //  Clear the file size loaded flag for resident attributes non-user data because these
        //  values are not kept current in the scb and must be loaded off the attribute
        //  This situation only occurs when the user has opened the attribute explicitly
        //

        if (ReturnedExistingScb &&
            FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT ) &&
            !NtfsIsTypeCodeUserData( Scb->AttributeTypeCode )) {

            ClearFlag( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED | SCB_STATE_HEADER_INITIALIZED );
        }

        //
        //  Make sure the Scb is up-to-date.
        //

        NtfsUpdateScbFromAttribute( IrpContext,
                                    Scb,
                                    Attribute );

        //
        //  Set the flag in the Scb to indicate that we are converting this to
        //  non resident.
        //

        SetFlag( Scb->ScbState, SCB_STATE_CONVERT_UNDERWAY );
        if (Scb->ScbSnapshot) {
            ASSERT( (NULL == Scb->ScbSnapshot->OwnerIrpContext) || (IrpContext == Scb->ScbSnapshot->OwnerIrpContext) );
            Scb->ScbSnapshot->OwnerIrpContext = IrpContext;
        }

        //
        //  Now check if the file is mapped by a user.
        //

        if (CreateSectionUnderway ||
            !MmCanFileBeTruncated( &Scb->NonpagedScb->SegmentObject, NULL )) {

            AttributeNameOffset = ClusterAlign( Fcb->Vcb,
                                                Attribute->Form.Resident.ValueLength );
            AllocatedLength += AttributeNameOffset;
            ValueLength = Attribute->Form.Resident.ValueLength;
            WriteClusters = TRUE;

            if ((ValueLength != 0) &&
                (IrpContext->MajorFunction == IRP_MJ_WRITE) &&
                !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX ) &&
                (IrpContext->OriginatingIrp != NULL) &&
                !FlagOn( IrpContext->OriginatingIrp->Flags, IRP_PAGING_IO ) &&
                (Scb->Header.PagingIoResource != NULL)) {

                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );

                //
                //  If we fault the data into the section then we better have
                //  the paging io resource exclusive.  Otherwise we could hit
                //  a collided page fault.
                //

                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }

            Scb = NULL;

        } else {

            volatile UCHAR VolatileUchar;

            AttributeNameOffset = 0;
            NtfsCreateInternalAttributeStream( IrpContext,
                                               Scb,
                                               TRUE,
                                               &NtfsInternalUseFile[CONVERTTONONRESIDENT_FILE_NUMBER] );

            //
            //  Make sure the cache is up-to-date.
            //

            NtfsSetBothCacheSizes( Scb->FileObject,
                                   (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                                   Scb );

            ValueLength = Scb->Header.ValidDataLength.LowPart;

            if (ValueLength != 0) {

                ULONG WaitState;

                //
                //  There is a deadlock possibility if there is already a Bcb for
                //  this page.  If the lazy writer has acquire the Bcb to flush the
                //  page then he can be blocked behind the current request which is
                //  trying to perform the convert.  This thread will complete the
                //  deadlock by trying to acquire the Bcb to pin the page.
                //
                //  If there is a possible deadlock then we will pin in two stages:
                //  First map the page (while waiting) to bring the page into memory,
                //  then pin it without waiting.  If we are unable to acquire the
                //  Bcb then mark the Irp Context to acquire the paging io resource
                //  exclusively on the retry.
                //
                //  We only do this for ConvertToNonResident which come from a user
                //  write.  Otherwise the correct synchronization should already be done.
                //
                //  Either the top level already has the paging io resource or there
                //  is no paging io resource.
                //
                //  We might hit this point in the Hotfix path if we need to convert
                //  the bad cluster attribute list to non-resident.  It that case
                //  we won't have an originating Irp.
                //

                if ((IrpContext->MajorFunction == IRP_MJ_WRITE) &&
                    !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX ) &&
                    (IrpContext->OriginatingIrp != NULL) &&
                    !FlagOn( IrpContext->OriginatingIrp->Flags, IRP_PAGING_IO ) &&
                    (Scb->Header.PagingIoResource != NULL)) {

                    LONGLONG FileOffset = 0;

                    //
                    //  Now capture the wait state and set the IrpContext flag
                    //  to handle a failure when mapping or pinning.
                    //

                    WaitState = FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
                    ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );

                    //
                    //  If we fault the data into the section then we better have
                    //  the paging io resource exclusive.  Otherwise we could hit
                    //  a collided page fault.
                    //

                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );

                } else {

                    NtfsPinStream( IrpContext,
                                   Scb,
                                   (LONGLONG)0,
                                   ValueLength,
                                   &ResidentBcb,
                                   &AttributeValue );
                }

                //
                //  Close the window where this page can leave memory before we
                //  have the new attribute initialized.  The result will be that
                //  we may fault in this page again and read uninitialized data
                //  out of the newly allocated sectors.
                //
                //  Make the page dirty so that the cache manager will write it out
                //  and update the valid data length.
                //

                VolatileUchar = *((PUCHAR) AttributeValue);

                *((PUCHAR) AttributeValue) = VolatileUchar;
            }
        }

        if (AllocatedLength > 8) {

            Buffer = AllocatedBuffer = NtfsAllocatePool(PagedPool, AllocatedLength );

        } else {

            Buffer = &AttributeNameBuffer;
        }

        //
        //  Now update the attribute name in the buffer.
        //

        AttributeName.Buffer = Add2Ptr( Buffer, AttributeNameOffset );

        RtlCopyMemory( AttributeName.Buffer,
                       Add2Ptr( Attribute, Attribute->NameOffset ),
                       AttributeName.Length );

        //
        //  If we are going to write the clusters directly to the disk then copy
        //  the bytes into the buffer.
        //

        if (WriteClusters) {

            AttributeValue = Buffer;

            RtlCopyMemory( AttributeValue, NtfsAttributeValue( Attribute ), ValueLength );
        }

        //
        //  Now just delete the current record and create it nonresident.
        //  Create nonresident with attribute does the right thing if we
        //  are being called by MM.  Preserve the file record but release
        //  any and all allocation.
        //

        NtfsDeleteAttributeRecord( IrpContext,
                                   Fcb,
                                   DELETE_LOG_OPERATION | DELETE_RELEASE_ALLOCATION,
                                   Context );

        NtfsCreateNonresidentWithValue( IrpContext,
                                        Fcb,
                                        AttributeTypeCode,
                                        &AttributeName,
                                        AttributeValue,
                                        ValueLength,
                                        AttributeFlags,
                                        WriteClusters,
                                        Scb,
                                        TRUE,
                                        Context );

        //
        //  If we were passed an attribute context, then we want to
        //  reload the context with the new location of the file.
        //

        if (!CleanupLocalContext) {

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );

            if (!NtfsLookupAttributeByName( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            AttributeTypeCode,
                                            &AttributeName,
                                            NULL,
                                            FALSE,
                                            Context )) {

                DebugTrace( 0, 0, ("Could not find attribute being converted\n") );

                ASSERTMSG("Could not find attribute being converted, About to raise corrupt ", FALSE);
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }
        }

    } finally {

        DebugUnwind( NtfsConvertToNonresident );

        if (AllocatedBuffer != NULL) {

            NtfsFreePool( AllocatedBuffer );
        }

        if (CleanupLocalContext) {

            NtfsCleanupAttributeContext( IrpContext, Context );
        }

        NtfsUnpinBcb( IrpContext, &ResidentBcb );
    }
}


VOID
NtfsDeleteAttributeRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG Flags,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine deletes an existing attribute removing it from the file record.

    The caller specifies the attribute to be deleted via the attribute context,
    and must be prepared to clean up this context no matter how this routine
    returns.

    Note that currently this routine does not deallocate any clusters allocated
    to a nonresident attribute; it expects the caller to already have done so.

Arguments:

    Fcb - Current file.

    Flags - Bitmask that modifies behaviour:
        DELETE_LOG_OPERATION        Most callers should specify this, to have the
            change logged.  However, we can omit it if we are deleting an entire
            file record, and will be logging that.
        DELETE_RELEASE_FILE_RECORD  Indicates that we should release the file record.
            Most callers will not specify this.  (Convert to non-resident will omit).
        DELETE_RELEASE_ALLOCATION   Indicates that we should free up any allocation.
            Most callers will specify this.

    Context - Attribute Context positioned at the attribute to delete.

Return Value:

    None.

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PVCB Vcb;
    ATTRIBUTE_TYPE_CODE AttributeTypeCode;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    Vcb = Fcb->Vcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeleteAttribute\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("Context =%08lx\n", Context) );

    //
    //  Get the pointers we need.
    //

    Attribute = NtfsFoundAttribute(Context);
    AttributeTypeCode = Attribute->TypeCode;
    FileRecord = NtfsContainingFileRecord(Context);
    ASSERT( IsQuadAligned( Attribute->RecordLength ) );

    if (!NtfsIsAttributeResident( Attribute ) &&
        FlagOn( Flags, DELETE_RELEASE_ALLOCATION)) {

        ASSERT( (NULL == IrpContext->CleanupStructure) || (Fcb == IrpContext->CleanupStructure) );
        NtfsDeleteAllocationFromRecord( IrpContext, Fcb, Context, TRUE, FALSE );

        //
        //  Reload our local pointers.
        //

        Attribute = NtfsFoundAttribute(Context);
        FileRecord = NtfsContainingFileRecord(Context);
    }

    //
    //  If this is a resident stream then release the quota.  Quota for
    //  non-resident streams is handled by NtfsDeleteAllocaiton.
    //

    if (NtfsIsTypeCodeSubjectToQuota( Attribute->TypeCode) &&
        (NtfsIsAttributeResident( Attribute ) ||
         (Attribute->Form.Nonresident.LowestVcn == 0))) {

        LONGLONG Delta = -NtfsResidentStreamQuota( Vcb );

        NtfsConditionallyUpdateQuota( IrpContext,
                                      Fcb,
                                      &Delta,
                                      FlagOn( Flags, DELETE_LOG_OPERATION ),
                                      FALSE );
    }

    //
    //  Be sure the attribute is pinned.
    //

    NtfsPinMappedAttribute( IrpContext, Vcb, Context );

    //
    //  Log the change.
    //

    if (FlagOn( Flags, DELETE_LOG_OPERATION )) {

        FileRecord->Lsn =
        NtfsWriteLog( IrpContext,
                      Vcb->MftScb,
                      NtfsFoundBcb(Context),
                      DeleteAttribute,
                      NULL,
                      0,
                      CreateAttribute,
                      Attribute,
                      Attribute->RecordLength,
                      NtfsMftOffset( Context ),
                      (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord),
                      0,
                      Vcb->BytesPerFileRecordSegment );
    }

    NtfsRestartRemoveAttribute( IrpContext,
                                FileRecord,
                                (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord) );

    Context->FoundAttribute.AttributeDeleted = TRUE;

    if (FlagOn( Flags, DELETE_LOG_OPERATION ) &&
        (Context->AttributeList.Bcb != NULL)) {

        //
        //  Now delete the attribute list entry, if there is one.  Do it
        //  after freeing space above, because we assume the list has not moved.
        //  Note we only do this if DELETE_LOG_OPERATION was specified, assuming
        //  that otherwise the entire file is going away anyway, so there is no
        //  need to fix up the list.
        //

        NtfsDeleteFromAttributeList( IrpContext, Fcb, Context );
    }

    //
    //  Delete the file record if it happened to go empty.  (Note that
    //  delete file does not call this routine and deletes its own file
    //  records.)
    //

    if (FlagOn( Flags, DELETE_RELEASE_FILE_RECORD ) &&
        FileRecord->FirstFreeByte == ((ULONG)FileRecord->FirstAttributeOffset +
                                      QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE )))) {

        ASSERT( NtfsFullSegmentNumber( &Fcb->FileReference ) ==
                NtfsUnsafeSegmentNumber( &Fcb->FileReference ) );

        NtfsDeallocateMftRecord( IrpContext,
                                 Vcb,
                                 (ULONG) LlFileRecordsFromBytes( Vcb, Context->FoundAttribute.MftFileOffset ));
    }

    DebugTrace( -1, Dbg, ("NtfsDeleteAttributeRecord -> VOID\n") );

    return;
}


VOID
NtfsDeleteAllocationFromRecord (
    PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PATTRIBUTE_ENUMERATION_CONTEXT Context,
    IN BOOLEAN BreakupAllowed,
    IN BOOLEAN LogIt
    )

/*++

Routine Description:

    This routine may be called to delete the allocation of an attribute
    from its attribute record.  It does nothing to the attribute record
    itself - the caller must deal with that.

Arguments:

    Fcb - Current file.

    Context - Attribute enumeration context positioned to the attribute
              whose allocation is to be deleted.

    BreakupAllowed - TRUE if the caller can tolerate breaking up the deletion of
                     allocation into multiple transactions, if there are a large
                     number of runs.

    LogIt - Indicates if we need to log the change to the mapping pairs.

Return Value:

    None

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    PSCB Scb;
    UNICODE_STRING AttributeName;
    PFILE_OBJECT TempFileObject;
    BOOLEAN ScbExisted;
    BOOLEAN ScbAcquired = FALSE;
    BOOLEAN ReinitializeContext = FALSE;
    BOOLEAN FcbHadPaging;

    PAGED_CODE();

    //
    //  Point to the current attribute.
    //

    Attribute = NtfsFoundAttribute( Context );

    //
    //  If the attribute is nonresident, then delete its allocation.
    //

    ASSERT(Attribute->FormCode == NONRESIDENT_FORM);


    NtfsInitializeStringFromAttribute( &AttributeName, Attribute );

    if (Fcb->PagingIoResource != NULL) {
        FcbHadPaging = TRUE;
    } else {
        FcbHadPaging = FALSE;
    }

    //
    //  Decode the file object
    //

    Scb = NtfsCreateScb( IrpContext,
                         Fcb,
                         Attribute->TypeCode,
                         &AttributeName,
                         FALSE,
                         &ScbExisted );

    try {

        //
        //  If the scb is new and that caused a paging resource to be created
        //  E.g. a named data stream in a directory raise because our state is now
        //  incosistent. We need to acquire that paging resource first
        //

        if (!FcbHadPaging && (Fcb->PagingIoResource != NULL)) {
            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
        }

        //
        //  Acquire the Scb Exclusive
        //

        NtfsAcquireExclusiveScb( IrpContext, Scb );
        ScbAcquired = TRUE;

        if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

            NtfsUpdateScbFromAttribute( IrpContext, Scb, Attribute );
        }

        //
        //  If we created the Scb, then this is the only case where
        //  it is legal for us to omit the File Object in the delete
        //  allocation call, because there cannot possibly be a section.
        //
        //  Also if there is not a section and this thread owns everything
        //  for this file then we can neglect the file object.
        //

        if (!ScbExisted ||
            ((Scb->NonpagedScb->SegmentObject.DataSectionObject == NULL) &&
             ((Scb->Header.PagingIoResource == NULL) ||
              (NtfsIsExclusiveScbPagingIo( Scb ))))) {

            TempFileObject = NULL;

        //
        //  Else, if there is already a stream file object, we can just
        //  use it.
        //

        } else if (Scb->FileObject != NULL) {

            TempFileObject = Scb->FileObject;

        //
        //  Else the Scb existed and we did not already have a stream,
        //  so we have to create one and delete it on the way out.
        //

        } else {

            NtfsCreateInternalAttributeStream( IrpContext,
                                               Scb,
                                               TRUE,
                                               &NtfsInternalUseFile[DELETEALLOCATIONFROMRECORD_FILE_NUMBER] );
            TempFileObject = Scb->FileObject;
        }

        //
        //  Before we make this call, we need to check if we will have to
        //  reread the current attribute.  This could be necessary if
        //  we remove any records for this attribute in the delete case.
        //
        //  We only do this under the following conditions.
        //
        //      1 - There is an attribute list present.
        //      2 - There is an entry following the current entry in
        //          the attribute list.
        //      3 - The lowest Vcn for that following entry is non-zero.
        //

        if (Context->AttributeList.Bcb != NULL) {

            PATTRIBUTE_LIST_ENTRY NextEntry;

            NextEntry = (PATTRIBUTE_LIST_ENTRY) NtfsGetNextRecord( Context->AttributeList.Entry );

            if (NextEntry < Context->AttributeList.BeyondFinalEntry) {

                if ( NextEntry->LowestVcn != 0) {

                    ReinitializeContext = TRUE;
                }
            }
        }

        //
        //  Before we delete the allocation and purge the cache - flush any metadata in case
        //  we fail at some point later so we don't lose anything due to the purge. This
        //  is extra i/o when the delete works as expected but the amount of dirty metadata
        //  is limited by both metadata size and the fact its aggressively flushed by cc anyway
        //  the only case when this results in a real flush would be when an attribute like
        //  a reparse point is very quickly created and deleted
        //

        if (TempFileObject && (!NtfsIsTypeCodeUserData( Scb->AttributeTypeCode ) || FlagOn( Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE ))) {

            IO_STATUS_BLOCK Iosb;

            CcFlushCache( TempFileObject->SectionObjectPointer, NULL, 0, &Iosb );
            if (Iosb.Status != STATUS_SUCCESS) {
                NtfsRaiseStatus( IrpContext, Iosb.Status, &Scb->Fcb->FileReference, Scb->Fcb );
            }
        }

        NtfsDeleteAllocation( IrpContext,
                              TempFileObject,
                              Scb,
                              *(PVCN)&Li0,
                              MAXLONGLONG,
                              LogIt,
                              BreakupAllowed );

        //
        //  Purge all the data - if any is left in case the cache manager didn't
        //  due to the attribute being accessed with the pin interface
        // 

        if (TempFileObject) {
            CcPurgeCacheSection( TempFileObject->SectionObjectPointer, NULL, 0, FALSE );
        }

        //
        //  Reread the attribute if we need to.
        //

        if (ReinitializeContext) {

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, Context );
        }

    } finally {

        DebugUnwind( NtfsDeleteAllocationFromRecord );

        if (ScbAcquired) {
            NtfsReleaseScb( IrpContext, Scb );
        }
    }

    return;
}


//
//  This routine is intended for use by allocsup.c.  Other callers should use
//  the routines in allocsup.
//

BOOLEAN
NtfsCreateAttributeWithAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN USHORT AttributeFlags,
    IN BOOLEAN LogIt,
    IN BOOLEAN UseContext,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine creates the specified attribute with allocation, and returns a
    description of it via the attribute context.  If the amount of space being
    created is small enough, we do all of the work here.  Otherwise we create the
    initial attribute and call NtfsAddAttributeAllocation to add the rest (in order
    to keep the more complex logic in one place).

    On successful return, it is up to the caller to clean up the attribute
    context.

Arguments:

    Scb - Current stream.

    AttributeTypeCode - Type code of the attribute to create.

    AttributeName - Optional name for attribute.

    AttributeFlags - Desired flags for the created attribute.

    WhereIndexed - Optionally supplies the file reference to the file where
        this attribute is indexed.

    LogIt - Most callers should specify TRUE, to have the change logged.  However,
        we can specify FALSE if we are creating a new file record, and
        will be logging the entire new file record.

    UseContext - Indicates if the context is pointing at the location for the attribute.

    Context - A handle to the created attribute.  This context is in a indeterminate
        state on return.

Return Value:

    BOOLEAN - TRUE if we created the attribute with all the allocation.  FALSE
        otherwise.  We should only return FALSE if we are creating a file
        and don't want to log any of the changes to the file record.

--*/

{
    UCHAR AttributeBuffer[SIZEOF_FULL_NONRES_ATTR_HEADER];
    UCHAR MappingPairsBuffer[64];
    ULONG RecordOffset;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    ULONG SizeNeeded;
    ULONG AttrSizeNeeded;
    PCHAR MappingPairs;
    ULONG MappingPairsLength;
    LCN Lcn;
    VCN LastVcn;
    VCN HighestVcn;
    PVCB Vcb;
    ULONG Passes = 0;
    PFCB Fcb = Scb->Fcb;
    PNTFS_MCB Mcb = &Scb->Mcb;
    ULONG AttributeHeaderSize = SIZEOF_PARTIAL_NONRES_ATTR_HEADER;
    BOOLEAN AllocateAll = TRUE;
    UCHAR CompressionShift = 0;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    PAGED_CODE();

    ASSERT( (AttributeFlags == 0) ||
            NtfsIsTypeCodeCompressible( AttributeTypeCode ));

    Vcb = Fcb->Vcb;

    //
    //  Clear out the invalid attribute flags for this volume.
    //

    AttributeFlags &= Vcb->AttributeFlagsMask;

    DebugTrace( +1, Dbg, ("NtfsCreateAttributeWithAllocation\n") );
    DebugTrace( 0, Dbg, ("Mcb = %08lx\n", Mcb) );

    //
    //  Calculate the size needed for this attribute.  (We say we have
    //  Vcb->BigEnoughToMove bytes available as a short cut, since we
    //  will extend later as required anyway.  It should be extremely
    //  unusual that we would really have to extend.)
    //

    MappingPairsLength = QuadAlign( NtfsGetSizeForMappingPairs( Mcb,
                                                                Vcb->BigEnoughToMove,
                                                                (LONGLONG)0,
                                                                NULL,
                                                                &LastVcn ));

    //
    //  Extra work for compressed / sparse files
    //

    if (FlagOn( AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

        LONGLONG ClustersInCompressionUnit;

        //
        //  Calculate the compression unit size.
        //

        CompressionShift = NTFS_CLUSTERS_PER_COMPRESSION;

        //
        //  If this generates a compression unit past 64K then we need to shrink
        //  the shift value.  This can only happen for sparse files.
        //

        if (!FlagOn( AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            while (Vcb->SparseFileClusters < (ULONG) (1 << CompressionShift)) {

                CompressionShift -= 1;
            }
        }

        ClustersInCompressionUnit = 1 << CompressionShift;

        //
        //  Round the LastVcn down to a compression unit and recalc the size
        //  needed for the mapping pairs if it was truncated. Note LastVcn = 1 + actual stop pt
        //  if we didn't allocate everything in which case it == maxlonglong
        //

        if (LastVcn != MAXLONGLONG) {

            VCN RoundedLastVcn;

            //
            //  LastVcn is the cluster beyond allocation or the allocation size i.e stop at 0 we have 1 cluster
            //  we want the new allocation to be a compression unit mult so the stop point should be
            //  a compression unit rounded allocation - 1
            //  Note LastVcn will == RoundedLastVcn + 1 on exit from GetSizeForMappingPairs
            //

            RoundedLastVcn = (LastVcn & ~(ClustersInCompressionUnit - 1)) - 1;
            MappingPairsLength = QuadAlign( NtfsGetSizeForMappingPairs( Mcb,
                                                                        Vcb->BigEnoughToMove,
                                                                        (LONGLONG)0,
                                                                        &RoundedLastVcn,
                                                                        &LastVcn ));

            ASSERT( (LastVcn & (ClustersInCompressionUnit - 1)) == 0 );
        }

        //
        //  Remember the size of the attribute header needed for this file.
        //

        AttributeHeaderSize = SIZEOF_FULL_NONRES_ATTR_HEADER;
    }

    SizeNeeded = AttributeHeaderSize +
                 MappingPairsLength +
                 (ARGUMENT_PRESENT(AttributeName) ?
                   QuadAlign( AttributeName->Length ) : 0);

    AttrSizeNeeded = SizeNeeded;

    //
    //  Loop until we find all the space we need.
    //

    do {

        //
        //  Reinitialize context if this is not the first pass.
        //

        if (Passes != 0) {

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );
        }

        Passes += 1;

        ASSERT( Passes < 5 );

        //
        //  If the attribute is not indexed, then we will position to the
        //  insertion point by type code and name.
        //

        if (!UseContext &&
            NtfsLookupAttributeByName( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       AttributeTypeCode,
                                       AttributeName,
                                       NULL,
                                       FALSE,
                                       Context )) {

            DebugTrace( 0, 0,
                        ("Nonresident attribute already exists, TypeCode = %08lx\n",
                        AttributeTypeCode) );

            ASSERTMSG("Nonresident attribute already exists, About to raise corrupt ", FALSE);
            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        //
        //  If this attribute is being positioned in the base file record and
        //  there is an attribute list then we need to ask for enough space
        //  for the attribute list entry now.
        //

        FileRecord = NtfsContainingFileRecord( Context );
        Attribute = NtfsFoundAttribute( Context );

        AttrSizeNeeded = SizeNeeded;

        if (Context->AttributeList.Bcb != NULL
            && (ULONG_PTR) FileRecord <= (ULONG_PTR) Context->AttributeList.AttributeList
            && (ULONG_PTR) Attribute >= (ULONG_PTR) Context->AttributeList.AttributeList) {

            //
            //  If the attribute list is non-resident then add a fudge factor of
            //  16 bytes for any new retrieval information.
            //

            if (NtfsIsAttributeResident( Context->AttributeList.AttributeList )) {

                AttrSizeNeeded += QuadAlign( FIELD_OFFSET( ATTRIBUTE_LIST_ENTRY, AttributeName )
                                             + (ARGUMENT_PRESENT( AttributeName ) ?
                                                (ULONG) AttributeName->Length :
                                                sizeof( WCHAR )));

            } else {

                AttrSizeNeeded += 0x10;
            }
        }

        UseContext = FALSE;

    //
    //  Ask for the space we need.
    //

    } while (!NtfsGetSpaceForAttribute( IrpContext, Fcb, AttrSizeNeeded, Context ));

    //
    //  Now get the attribute pointer and fill it in.
    //

    FileRecord = NtfsContainingFileRecord(Context);
    RecordOffset = (ULONG)((PCHAR)NtfsFoundAttribute(Context) - (PCHAR)FileRecord);
    Attribute = (PATTRIBUTE_RECORD_HEADER)AttributeBuffer;

    RtlZeroMemory( Attribute, SIZEOF_FULL_NONRES_ATTR_HEADER );

    Attribute->TypeCode = AttributeTypeCode;
    Attribute->RecordLength = SizeNeeded;
    Attribute->FormCode = NONRESIDENT_FORM;

    //
    //  Assume no attribute name, and calculate where the Mapping Pairs
    //  will go.  (Update below if we are wrong.)
    //

    MappingPairs = Add2Ptr( Attribute, AttributeHeaderSize );

    //
    //  If the attribute has a name, take care of that now.
    //

    if (ARGUMENT_PRESENT(AttributeName)
        && AttributeName->Length != 0) {

        ASSERT( AttributeName->Length <= 0x1FF );

        Attribute->NameLength = (UCHAR)(AttributeName->Length / sizeof(WCHAR));
        Attribute->NameOffset = (USHORT)AttributeHeaderSize;
        MappingPairs += QuadAlign( AttributeName->Length );
    }

    Attribute->Flags = AttributeFlags;
    Attribute->Instance = FileRecord->NextAttributeInstance;

    //
    //  If someone repeatedly adds and removes attributes from a file record we could
    //  hit a case where the sequence number will overflow.  In this case we
    //  want to scan the file record and find an earlier free instance number.
    //

    if (Attribute->Instance > NTFS_CHECK_INSTANCE_ROLLOVER) {

        Attribute->Instance = NtfsScanForFreeInstance( IrpContext, Vcb, FileRecord );
    }

    //
    //  We always need the mapping pairs offset.
    //

    Attribute->Form.Nonresident.MappingPairsOffset = (USHORT)(MappingPairs -
                                                     (PCHAR)Attribute);

    //
    //  Set up the compression unit size.
    //

    Attribute->Form.Nonresident.CompressionUnit = CompressionShift;

    //
    //  Now we need to point to the real place to build the mapping pairs buffer.
    //  If they will not be too big we can use our internal buffer.
    //

    MappingPairs = MappingPairsBuffer;

    if (MappingPairsLength > 64) {

        MappingPairs = NtfsAllocatePool( NonPagedPool, MappingPairsLength );
    }
    *MappingPairs = 0;

    //
    //  Find how much space is allocated by finding the last Mcb entry and
    //  looking it up.  If there are no entries, all of the subsequent
    //  fields are already zeroed.
    //

    Attribute->Form.Nonresident.HighestVcn =
    HighestVcn = -1;
    if (NtfsLookupLastNtfsMcbEntry( Mcb, &HighestVcn, &Lcn )) {

        ASSERT_LCN_RANGE_CHECKING( Vcb, Lcn );

        //
        //  Now build the mapping pairs in place.
        //

        NtfsBuildMappingPairs( Mcb,
                               0,
                               &LastVcn,
                               MappingPairs );
        Attribute->Form.Nonresident.HighestVcn = LastVcn;

        //
        //  Fill in the nonresident-specific fields.  We set the allocation
        //  size to only include the Vcn's we included in the mapping pairs.
        //

        Attribute->Form.Nonresident.AllocatedLength =
            Int64ShllMod32((LastVcn + 1 ), Vcb->ClusterShift);

        //
        //  The totally allocated field in the Scb will contain the current allocated
        //  value for this stream.
        //

        if (FlagOn( AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

            ASSERT( Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA );
            Attribute->Form.Nonresident.TotalAllocated = Scb->TotalAllocated;

            ASSERT( ((LastVcn + 1) & ((1 << CompressionShift) - 1)) == 0 );
        }

    //
    //  We are creating a attribute with zero allocation.  Make the Vcn sizes match
    //  so we don't make the call below to AddAttributeAllocation.
    //

    } else {

        LastVcn = HighestVcn;
    }

    //
    //  Now we will actually create the attribute in place, so that we
    //  save copying everything twice, and can point to the final image
    //  for the log write below.
    //

    NtfsRestartInsertAttribute( IrpContext,
                                FileRecord,
                                RecordOffset,
                                Attribute,
                                AttributeName,
                                MappingPairs,
                                MappingPairsLength );

    //
    //  Finally, log the creation of this attribute
    //

    if (LogIt) {

        //
        //  We have actually created the attribute above, but the write
        //  log below could fail.  The reason we did the create already
        //  was to avoid having to allocate pool and copy everything
        //  twice (header, name and value).  Our normal error recovery
        //  just recovers from the log file.  But if we fail to write
        //  the log, we have to remove this attribute by hand, and
        //  raise the condition again.
        //

        try {

            FileRecord->Lsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NtfsFoundBcb(Context),
                          CreateAttribute,
                          Add2Ptr(FileRecord, RecordOffset),
                          Attribute->RecordLength,
                          DeleteAttribute,
                          NULL,
                          0,
                          NtfsMftOffset( Context ),
                          RecordOffset,
                          0,
                          Vcb->BytesPerFileRecordSegment );

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            NtfsRestartRemoveAttribute( IrpContext, FileRecord, RecordOffset );

            if (MappingPairs != MappingPairsBuffer) {

                NtfsFreePool( MappingPairs );
            }

            NtfsRaiseStatus( IrpContext, GetExceptionCode(), NULL, NULL );
        }
    }

    //
    //  Free the mapping pairs buffer if we allocated one.
    //

    if (MappingPairs != MappingPairsBuffer) {

        NtfsFreePool( MappingPairs );
    }

    //
    //  Now add it to the attribute list if necessary
    //

    if (Context->AttributeList.Bcb != NULL) {

        MFT_SEGMENT_REFERENCE SegmentReference;

        *(PLONGLONG)&SegmentReference = LlFileRecordsFromBytes( Vcb, NtfsMftOffset( Context ));
        SegmentReference.SequenceNumber = FileRecord->SequenceNumber;

        NtfsAddToAttributeList( IrpContext, Fcb, SegmentReference, Context );
    }

    //
    //  Reflect the current allocation in the scb - in case we take the path below
    //  

    Scb->Header.AllocationSize.QuadPart = Attribute->Form.Nonresident.AllocatedLength;

    //
    //  We couldn't create all of the mapping for the allocation above.  If
    //  this is a create then we want to truncate the allocation to what we
    //  have already allocated.  Otherwise we want to call
    //  NtfsAddAttributeAllocation to map the remaining allocation.
    //

    if (LastVcn != HighestVcn) {

        if (LogIt ||
            !NtfsIsTypeCodeUserData( AttributeTypeCode ) ||
            IrpContext->MajorFunction != IRP_MJ_CREATE) {

            NtfsAddAttributeAllocation( IrpContext, Scb, Context, NULL, NULL );

        } else {

            //
            //  Truncate away the clusters beyond the last Vcn and set the
            //  flag in the IrpContext indicating there is more allocation
            //  to do.
            //

            NtfsDeallocateClusters( IrpContext,
                                    Fcb->Vcb,
                                    Scb,
                                    LastVcn + 1,
                                    MAXLONGLONG,
                                    NULL );

            NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                    LastVcn + 1,
                                    MAXLONGLONG,
                                    TRUE,
                                    FALSE );

            if (FlagOn( Scb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA )) {

                LONGLONG Delta = LlBytesFromClusters( Fcb->Vcb, LastVcn - HighestVcn );
                ASSERT( NtfsIsTypeCodeSubjectToQuota( AttributeTypeCode ));
                ASSERT( NtfsIsTypeCodeSubjectToQuota( Scb->AttributeTypeCode ));

                //
                //  Return any quota charged.
                //

                NtfsConditionallyUpdateQuota( IrpContext,
                                              Fcb,
                                              &Delta,
                                              LogIt,
                                              TRUE );
            }

            AllocateAll = FALSE;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCreateAttributeWithAllocation -> VOID\n") );

    return AllocateAll;
}


//
//  This routine is intended for use by allocsup.c.  Other callers should use
//  the routines in allocsup.
//

VOID
NtfsAddAttributeAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context,
    IN PVCN StartingVcn OPTIONAL,
    IN PVCN ClusterCount OPTIONAL
    )

/*++

Routine Description:

    This routine adds space to an existing nonresident attribute.

    The caller specifies the attribute to be changed via the attribute context,
    and must be prepared to clean up this context no matter how this routine
    returns.

    This routine procedes in the following steps, whose numbers correspond
    to the numbers in comments below:

        1.  Save a description of the current attribute.

        2.  Figure out how big the attribute would have to be to store all
            of the new run information.

        3.  Find the last occurrence of the attribute, to which the new
            allocation is to be appended.

        4.  If the attribute is getting very large and will not fit, then
            move it to its own file record.  In any case grow the attribute
            enough to fit either all of the new allocation, or as much as
            possible.

        5.  Construct the new mapping pairs in place, and log the change.

        6.  If there is still more allocation to describe, then loop to
            create new file records and initialize them to describe additional
            allocation until all of the allocation is described.

Arguments:

    Scb - Current stream.

    Context - Attribute Context positioned at the attribute to change.  Note
              that unlike other routines, this parameter is left in an
              indeterminate state upon return.  The caller should plan on
              doing nothing other than cleaning it up.

    StartingVcn - Supplies Vcn to start on, if not the new highest vcn

    ClusterCount - Supplies count of clusters being added, if not the new highest vcn

Return Value:

    None.

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    ULONG NewSize, MappingPairsSize;
    LONG SizeChange;
    PCHAR MappingPairs;
    ULONG SizeAvailable;
    PVCB Vcb;
    VCN LowestVcnRemapped;
    LONGLONG LocalClusterCount;
    VCN OldHighestVcn;
    VCN NewHighestVcn;
    VCN LastVcn;
    BOOLEAN IsHotFixScb;
    PBCB NewBcb = NULL;
    LONGLONG MftReferenceNumber;
    PFCB Fcb = Scb->Fcb;
    PNTFS_MCB Mcb = &Scb->Mcb;
    ULONG AttributeHeaderSize;
    BOOLEAN SingleHole;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    Vcb = Fcb->Vcb;

    DebugTrace( +1, Dbg, ("NtfsAddAttributeAllocation\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("Mcb = %08lx\n", Mcb) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );

    //
    //  Make a local copy of cluster count, if given.  We will use this local
    //  copy to determine the shrinking range if we move to a previous file
    //  record on a second pass through this loop.
    //

    if (ARGUMENT_PRESENT( ClusterCount )) {

        LocalClusterCount = *ClusterCount;
    }

    while (TRUE) {

        //
        //  Make sure the buffer is pinned.
        //

        NtfsPinMappedAttribute( IrpContext, Vcb, Context );

        //
        //  Make sure we cleanup on the way out
        //

        try {

            //
            //  Step 1.
            //
            //  Save a description of the attribute to help us look it up
            //  again, and to make clones if necessary.
            //

            Attribute = NtfsFoundAttribute(Context);

            //
            //  Do some basic verification of the on disk and in memory filesizes
            //  If they're disjoint - usually due to a failed abort raise corrupt again
            //

            if ((Attribute->FormCode != NONRESIDENT_FORM) ||
                (Attribute->Form.Nonresident.AllocatedLength != Scb->Header.AllocationSize.QuadPart)) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }
            
            
            ASSERT(Attribute->Form.Nonresident.LowestVcn == 0);
            OldHighestVcn = LlClustersFromBytes(Vcb, Attribute->Form.Nonresident.AllocatedLength) - 1;

            //
            //  Get the file record pointer.
            //

            FileRecord = NtfsContainingFileRecord( Context );

            //
            //  Step 2.
            //
            //  Come up with the Vcn we will stop on.  If a StartingVcn and ClusterCount
            //  were specified, then use them to calculate where we will stop.  Otherwise
            //  lookup the largest Vcn in this Mcb, so that we will know when we are done.
            //  We will also write the new allocation size here.
            //

            {
                LCN TempLcn;
                BOOLEAN UpdateFileSizes = FALSE;

                NewHighestVcn = -1;

                //
                //  If a StartingVcn and ClusterCount were specified, then use them.
                //

                if (ARGUMENT_PRESENT(StartingVcn)) {

                    ASSERT(ARGUMENT_PRESENT(ClusterCount));

                    NewHighestVcn = (*StartingVcn + LocalClusterCount) - 1;

                //
                //  If there are no entries in the file record then we have no new
                //  sizes to report.
                //

                } else if (NtfsLookupLastNtfsMcbEntry(Mcb, &NewHighestVcn, &TempLcn)) {

                    //
                    //  For compressed files, make sure we are not shrinking allocation
                    //  size (OldHighestVcn) due to a compression unit that was all zeros
                    //  and has no allocation.  Note, truncates are done in
                    //  NtfsDeleteAttributeAllocation, so we should not be shrinking the
                    //  file here.
                    //
                    //  If this is an attribute being written compressed, then always
                    //  insure that we keep the allocation size on a compression unit
                    //  boundary, by pushing NewHighestVcn to a boundary - 1.
                    //

                    if (Scb->CompressionUnit != 0) {

                        //
                        //  Don't shrink the file on this path.
                        //

                        if (OldHighestVcn > NewHighestVcn) {
                            NewHighestVcn = OldHighestVcn;
                        }

                        ((PLARGE_INTEGER) &NewHighestVcn)->LowPart |= ClustersFromBytes(Vcb, Scb->CompressionUnit) - 1;

                        //
                        //  Make sure we didn't push a hole into the next compression
                        //  unit.  If so then truncate to the current NewHighestVcn.  We
                        //  know this will be on a compression unit boundary.
                        //

                        if (NewHighestVcn < Scb->Mcb.NtfsMcbArray[Scb->Mcb.NtfsMcbArraySizeInUse - 1].EndingVcn) {

                            NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                                    NewHighestVcn + 1,
                                                    MAXLONGLONG,
                                                    TRUE,
                                                    FALSE );
                        }
                    }
                }

                //
                //  Copy the new allocation size into our size structure and
                //  update the attribute.
                //

                ASSERT( Scb->Header.AllocationSize.QuadPart != 0 || NewHighestVcn > OldHighestVcn );

                if (NewHighestVcn > OldHighestVcn) {

                    Scb->Header.AllocationSize.QuadPart = LlBytesFromClusters(Fcb->Vcb, NewHighestVcn + 1);
                    UpdateFileSizes = TRUE;
                }

                //
                //  If we moved the allocation size up or the totally allocated does
                //  not match the value on the disk (only for compressed files,
                //  then update the file sizes.
                //

                if (UpdateFileSizes ||
                    (FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ) &&
                     (Attribute->Form.Nonresident.TotalAllocated != Scb->TotalAllocated))) {

                    NtfsWriteFileSizes( IrpContext,
                                        Scb,
                                        &Scb->Header.ValidDataLength.QuadPart,
                                        FALSE,
                                        TRUE,
                                        TRUE );
                }
            }

            //
            //  Step 3.
            //
            //  Lookup the attribute record at which the change begins, if it is not
            //  the first file record that we are looking at.
            //

            if ((Attribute->Form.Nonresident.HighestVcn != OldHighestVcn) &&
                (NewHighestVcn > Attribute->Form.Nonresident.HighestVcn)) {

                NtfsCleanupAttributeContext( IrpContext, Context );
                NtfsInitializeAttributeContext( Context );

                NtfsLookupAttributeForScb( IrpContext, Scb, &NewHighestVcn, Context );

                Attribute = NtfsFoundAttribute(Context);
                ASSERT( IsQuadAligned( Attribute->RecordLength ) );
                FileRecord = NtfsContainingFileRecord(Context);
            }

            //
            //  Make sure we nuke this range if we get an error, by expanding
            //  the error recovery range.
            //

            if (Scb->Mcb.PoolType == PagedPool) {

                if (Scb->ScbSnapshot != NULL) {

                    if (Attribute->Form.Nonresident.LowestVcn < Scb->ScbSnapshot->LowestModifiedVcn) {
                        Scb->ScbSnapshot->LowestModifiedVcn = Attribute->Form.Nonresident.LowestVcn;
                    }

                    if (NewHighestVcn > Scb->ScbSnapshot->HighestModifiedVcn) {
                        Scb->ScbSnapshot->HighestModifiedVcn = NewHighestVcn;
                    }

                    if (Attribute->Form.Nonresident.HighestVcn > Scb->ScbSnapshot->HighestModifiedVcn) {
                        Scb->ScbSnapshot->HighestModifiedVcn = Attribute->Form.Nonresident.HighestVcn;
                    }
                }
            }

            //
            //  Remember the last Vcn we will need to create mapping pairs
            //  for.  We use either NewHighestVcn or the highest Vcn in this
            //  file record in the case that we are just inserting a run into
            //  an existing record.
            //

            if (ARGUMENT_PRESENT(StartingVcn)) {

                if (Attribute->Form.Nonresident.HighestVcn > NewHighestVcn) {

                    NewHighestVcn = Attribute->Form.Nonresident.HighestVcn;
                }
            }

            //
            //  Remember the lowest Vcn for this attribute.  We will use this to
            //  decide whether to loop back and look for an earlier file record.
            //

            LowestVcnRemapped = Attribute->Form.Nonresident.LowestVcn;

            //
            //  Remember the header size for this attribute.  This will be the
            //  mapping pairs offset except for attributes with names.
            //

            AttributeHeaderSize = Attribute->Form.Nonresident.MappingPairsOffset;

            if (Attribute->NameOffset != 0) {

                AttributeHeaderSize = Attribute->NameOffset;
            }

            //
            //  If we are making space for a totally allocated field then we
            //  want to add space to the non-resident header for these entries.
            //  To detect this we know that a starting Vcn was specified and
            //  we specified exactly the entire file record.  Also the major
            //  and minor Irp codes are exactly that for a compression operation.
            //

            if ((IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
                (IrpContext->MinorFunction == IRP_MN_USER_FS_REQUEST) &&
                (IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp)->Parameters.FileSystemControl.FsControlCode == FSCTL_SET_COMPRESSION) &&
                ARGUMENT_PRESENT( StartingVcn ) &&
                (*StartingVcn == 0) &&
                (LocalClusterCount == Attribute->Form.Nonresident.HighestVcn + 1)) {

                AttributeHeaderSize += sizeof( LONGLONG );
            }

            //
            //  Now we must make sure that we never ask for more than can fit in
            //  one file record with our attribute and a $END record.
            //

            SizeAvailable = NtfsMaximumAttributeSize(Vcb->BytesPerFileRecordSegment) -
                            AttributeHeaderSize -
                            QuadAlign( Scb->AttributeName.Length );

            //
            //  For the Mft, we will leave a "fudge factor" of 1/8th a file record
            //  free to make sure that possible hot fixes do not cause us to
            //  break the bootstrap process to finding the mapping for the Mft.
            //  Only take this action if we already have an attribute list for
            //  the Mft, otherwise we may not detect when we need to move to own
            //  record.
            //

            IsHotFixScb = NtfsIsTopLevelHotFixScb( Scb );

            if ((Scb == Vcb->MftScb) &&
                (Context->AttributeList.Bcb != NULL) &&
                !IsHotFixScb &&
                !ARGUMENT_PRESENT( StartingVcn )) {

                SizeAvailable -= Vcb->MftCushion;
            }

            //
            //  Calculate how much space is actually needed, independent of whether it will
            //  fit.
            //

            MappingPairsSize = QuadAlign( NtfsGetSizeForMappingPairs( Mcb,
                                                                      SizeAvailable,
                                                                      Attribute->Form.Nonresident.LowestVcn,
                                                                      &NewHighestVcn,
                                                                      &LastVcn ));

            NewSize = AttributeHeaderSize + QuadAlign( Scb->AttributeName.Length ) + MappingPairsSize;

            SizeChange = (LONG)NewSize - (LONG)Attribute->RecordLength;

            //
            //  Step 4.
            //
            //  Here we decide if we need to move the attribute to its own record,
            //  or whether there is enough room to grow it in place.
            //

            {
                VCN LowestVcn;
                ULONG Pass = 0;

                //
                //  It is important to note that at this point, if we will need an
                //  attribute list attribute, then we will already have it.  This is
                //  because we calculated the size needed for the attribute, and moved
                //  to a our own record if we were not going to fit and we were not
                //  already in a separate record.  Later on we assume that the attribute
                //  list exists, and just add to it as required.  If we didn't move to
                //  own record because this is the Mft and this is not file record 0,
                //  then we already have an attribute list from a previous split.
                //

                do {

                    //
                    //  If not the first pass, we have to lookup the attribute
                    //  again.  (It looks terrible to have to refind an attribute
                    //  record other than the first one, but this should never
                    //  happen, since subsequent attributes should always be in
                    //  their own record.)
                    //

                    if (Pass != 0) {

                        NtfsCleanupAttributeContext( IrpContext, Context );
                        NtfsInitializeAttributeContext( Context );

                        if (!NtfsLookupAttributeByName( IrpContext,
                                                        Fcb,
                                                        &Fcb->FileReference,
                                                        Scb->AttributeTypeCode,
                                                        &Scb->AttributeName,
                                                        &LowestVcn,
                                                        FALSE,
                                                        Context )) {

                            ASSERT( FALSE );
                            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                        }
                    }

                    Pass += 1;

                    //
                    //  Now we have to reload our pointers
                    //

                    Attribute = NtfsFoundAttribute(Context);
                    FileRecord = NtfsContainingFileRecord(Context);

                    //
                    //  If the attribute doesn't fit, and it is not alone in this file
                    //  record, and the attribute is big enough to move, then we will
                    //  have to take some special action.  Note that if we do not already
                    //  have an attribute list, then we will only do the move if we are
                    //  currently big enough to move, otherwise there may not be enough
                    //  space in MoveAttributeToOwnRecord to create the attribute list,
                    //  and that could cause us to recursively try to create the attribute
                    //  list in Create Attribute With Value.
                    //
                    //  We won't make this move if we are dealing with the Mft and it
                    //  is not file record 0.
                    //
                    //  Also we never move an attribute list to its own record.
                    //

                    if ((Attribute->TypeCode != $ATTRIBUTE_LIST)

                                &&

                        (SizeChange > (LONG)(FileRecord->BytesAvailable - FileRecord->FirstFreeByte))

                                &&

                        ((NtfsFirstAttribute(FileRecord) != Attribute) ||
                        (((PATTRIBUTE_RECORD_HEADER)NtfsGetNextRecord(Attribute))->TypeCode != $END))

                                &&

                        (((NewSize >= Vcb->BigEnoughToMove) && (Context->AttributeList.Bcb != NULL)) ||
                         (Attribute->RecordLength >= Vcb->BigEnoughToMove))

                                &&

                        ((Scb != Vcb->MftScb)

                                ||

                         (*(PLONGLONG)&FileRecord->BaseFileRecordSegment == 0))) {

                        //
                        //  If we are moving the Mft $DATA out of the base file record, the
                        //  attribute context will point to the split portion on return.
                        //  The attribute will only contain previously existing mapping, none
                        //  of the additional clusters which exist in the Mcb.
                        //

                        MftReferenceNumber = MoveAttributeToOwnRecord( IrpContext,
                                                                       Fcb,
                                                                       Attribute,
                                                                       Context,
                                                                       &NewBcb,
                                                                       &FileRecord );

                        Attribute = NtfsFirstAttribute(FileRecord);
                        ASSERT( IsQuadAligned( Attribute->RecordLength ) );
                        FileRecord = NtfsContainingFileRecord(Context);

                        //
                        //  If this is the MftScb then we need to recheck the size needed for the
                        //  mapping pairs.  The test for the Mft above guarantees that we
                        //  were dealing with the base file record.
                        //

                        if (Scb == Vcb->MftScb) {

                            LastVcn = LastVcn - 1;

                            //
                            //  Calculate how much space is now needed given our new LastVcn.
                            //

                            MappingPairsSize = QuadAlign( NtfsGetSizeForMappingPairs( Mcb,
                                                                                      SizeAvailable,
                                                                                      Attribute->Form.Nonresident.LowestVcn,
                                                                                      &LastVcn,
                                                                                      &LastVcn ));
                        }
                    }

                    //
                    //  Remember the lowest Vcn so that we can find this record again
                    //  if we have to.  We capture the value now, after the move attribute
                    //  in case this is the Mft doing a split and the entire attribute
                    //  didn't move.  We depend on MoveAttributeToOwnRecord to return
                    //  the new file record for the Mft split.
                    //

                    LowestVcn = Attribute->Form.Nonresident.LowestVcn;

                //
                //  If FALSE is returned, then the space was not allocated and
                //  we have to loop back and try again.  Second time must work.
                //

                } while (!NtfsChangeAttributeSize( IrpContext,
                                                   Fcb,
                                                   NewSize,
                                                   Context ));

                //
                //  Now we have to reload our pointers
                //

                Attribute = NtfsFoundAttribute(Context);
                FileRecord = NtfsContainingFileRecord(Context);
            }

            //
            //  Step 5.
            //
            //  Get pointer to mapping pairs
            //

            {
                ULONG AttributeOffset;
                ULONG MappingPairsOffset;
                CHAR MappingPairsBuffer[64];
                ULONG RecordOffset = PtrOffset(FileRecord, Attribute);

                //
                //  See if it is the case that all mapping pairs will not fit into
                //  the current file record, as we may wish to split in the middle
                //  rather than at the end as we are currently set up to do.
                //  We don't want to take this path if we are splitting the file record
                //  because of our limit on the range size due to maximum clusters per
                //  range.
                //

                if (LastVcn < NewHighestVcn) {

                    if (ARGUMENT_PRESENT( StartingVcn ) &&
                        (Scb != Vcb->MftScb)) {

                        LONGLONG TempCount;

                        //
                        //  There are two cases to deal with.  If the existing file record
                        //  was a large hole then we may need to limit the size if we
                        //  are adding allocation.  In this case we don't want to simply
                        //  split at the run being inserted.  Otherwise we might end up
                        //  creating a large number of file records containing only one
                        //  run (the case where a user fills a large hole by working
                        //  backwards).  Pad the new file record with a portion of the hole.
                        //

                        if (LastVcn - Attribute->Form.Nonresident.LowestVcn > MAX_CLUSTERS_PER_RANGE) {

                            //
                            //  We don't start within our maximum range from the beginning of the
                            //  range.  If we are within our limit from the end of the range
                            //  then extend the new range backwards to reach our limit.
                            //

                            if ((NewHighestVcn - LastVcn + 1) < MAX_CLUSTERS_PER_RANGE) {

                                LastVcn = NewHighestVcn - MAX_CLUSTERS_PER_RANGE;

                                //
                                //  Calculate how much space is now needed given our new LastVcn.
                                //

                                MappingPairsSize = QuadAlign( NtfsGetSizeForMappingPairs( Mcb,
                                                                                          SizeAvailable,
                                                                                          Attribute->Form.Nonresident.LowestVcn,
                                                                                          &LastVcn,
                                                                                          &LastVcn ));
                            }

                        //
                        //
                        //  In this case we have run out of room for mapping pairs via
                        //  an overwrite somewhere in the middle of the file.  To avoid
                        //  shoving a couple mapping pairs off the end over and over, we
                        //  will arbitrarily split this attribute in the middle.  We do
                        //  so by looking up the lowest and highest Vcns that we are working
                        //  with and get their indices, then split in the middle.
                        //

                        } else if (MappingPairsSize > (SizeAvailable >> 1)) {

                            LCN TempLcn;
                            PVOID RangeLow, RangeHigh;
                            ULONG IndexLow, IndexHigh;

                            //
                            //  Get the low and high Mcb indices for these runs.
                            //

                            if (!NtfsLookupNtfsMcbEntry( Mcb,
                                                         Attribute->Form.Nonresident.LowestVcn,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         &RangeLow,
                                                         &IndexLow )) {

                                ASSERT( FALSE );
                                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                            }

                            //
                            //  Point to the last Vcn we know is actually in the Mcb...
                            //

                            LastVcn = LastVcn - 1;

                            if (!NtfsLookupNtfsMcbEntry( Mcb,
                                                         LastVcn,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         &RangeHigh,
                                                         &IndexHigh )) {

                                ASSERT( FALSE );
                                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                            }
                            ASSERT(RangeLow == RangeHigh);

                            //
                            //  Calculate the index in the middle.
                            //

                            IndexLow += (IndexHigh - IndexLow) /2;

                            //
                            //  If we are inserting past the ValidDataToDisk (SplitMcb case),
                            //  then the allocation behind us may be relatively static, so
                            //  let's just move with our preallocated space to the new buffer.
                            //

                            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
                                (*StartingVcn >= LlClustersFromBytes(Vcb, Scb->ValidDataToDisk))) {

                                //
                                //  Calculate the index at about 7/8 the way.  Hopefully this will
                                //  move over all of the unallocated piece, while still leaving
                                //  some small amount of expansion space behind for overwrites.
                                //

                                IndexLow += (IndexHigh - IndexLow) /2;
                                IndexLow += (IndexHigh - IndexLow) /2;
                            }

                            //
                            //  Lookup the middle run and use the Last Vcn in that run.
                            //

                            if (!NtfsGetNextNtfsMcbEntry( Mcb,
                                                          &RangeLow,
                                                          IndexLow,
                                                          &LastVcn,
                                                          &TempLcn,
                                                          &TempCount )) {

                                ASSERT( FALSE );
                                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                            }

                            LastVcn = (LastVcn + TempCount) - 1;

                            //
                            //  Calculate how much space is now needed given our new LastVcn.
                            //

                            MappingPairsSize = QuadAlign( NtfsGetSizeForMappingPairs( Mcb,
                                                                                      SizeAvailable,
                                                                                      Attribute->Form.Nonresident.LowestVcn,
                                                                                      &LastVcn,
                                                                                      &LastVcn ));
                        }

                    }
                }

                //
                //  If we are growing this range, then we need to make sure we fix
                //  its definition.
                //

                if ((LastVcn - 1) != Attribute->Form.Nonresident.HighestVcn) {

                    NtfsDefineNtfsMcbRange( &Scb->Mcb,
                                            Attribute->Form.Nonresident.LowestVcn,
                                            LastVcn - 1,
                                            FALSE );
                }

                //
                //  Point to our local mapping pairs buffer, or allocate one if it is not
                //  big enough.
                //

                MappingPairs = MappingPairsBuffer;

                if (MappingPairsSize > 64) {

                    MappingPairs = NtfsAllocatePool( NonPagedPool, MappingPairsSize + 8 );
                }

                //
                //  Use try-finally to insure we free any pool on the way out.
                //

                try {

                    DebugDoit(

                        VCN TempVcn;

                        TempVcn = LastVcn - 1;

                        ASSERT(MappingPairsSize >=
                                QuadAlign( NtfsGetSizeForMappingPairs( Mcb, SizeAvailable,
                                                                      Attribute->Form.Nonresident.LowestVcn,
                                                                      &TempVcn, &LastVcn )));
                    );

                    //
                    //  Now add the space in the file record.
                    //

                    *MappingPairs = 0;
                    SingleHole = NtfsBuildMappingPairs( Mcb,
                                                        Attribute->Form.Nonresident.LowestVcn,
                                                        &LastVcn,
                                                        MappingPairs );

                    //
                    //  Now find the first different byte.  (Most of the time the
                    //  cost to do this is probably more than paid for by less
                    //  logging.)
                    //

                    AttributeOffset = Attribute->Form.Nonresident.MappingPairsOffset;
                    MappingPairsOffset = (ULONG)
                      RtlCompareMemory( MappingPairs,
                                        Add2Ptr(Attribute, AttributeOffset),
                                        ((Attribute->RecordLength - AttributeOffset) > MappingPairsSize ?
                                         MappingPairsSize :
                                         (Attribute->RecordLength - AttributeOffset)));

                    AttributeOffset += MappingPairsOffset;

                    //
                    //  Log the change.
                    //

                    {
                        LONGLONG LogOffset;

                        if (NewBcb != NULL) {

                            //
                            //  We know the file record number of the new file
                            //  record.  Convert it to a file offset.
                            //

                            LogOffset = LlBytesFromFileRecords( Vcb, MftReferenceNumber );

                        } else {

                            LogOffset = NtfsMftOffset( Context );
                        }

                        FileRecord->Lsn =
                        NtfsWriteLog( IrpContext,
                                      Vcb->MftScb,
                                      NewBcb != NULL ? NewBcb : NtfsFoundBcb(Context),
                                      UpdateMappingPairs,
                                      Add2Ptr(MappingPairs, MappingPairsOffset),
                                      MappingPairsSize - MappingPairsOffset,
                                      UpdateMappingPairs,
                                      Add2Ptr(Attribute, AttributeOffset),
                                      Attribute->RecordLength - AttributeOffset,
                                      LogOffset,
                                      RecordOffset,
                                      AttributeOffset,
                                      Vcb->BytesPerFileRecordSegment );
                    }

                    //
                    //  Now do the mapping pairs update by calling the same
                    //  routine called at restart.
                    //

                    NtfsRestartChangeMapping( IrpContext,
                                              Vcb,
                                              FileRecord,
                                              RecordOffset,
                                              AttributeOffset,
                                              Add2Ptr(MappingPairs, MappingPairsOffset),
                                              MappingPairsSize - MappingPairsOffset );


                } finally {

                    if (MappingPairs != MappingPairsBuffer) {

                        NtfsFreePool(MappingPairs);
                    }
                }
            }

            ASSERT( Attribute->Form.Nonresident.HighestVcn == LastVcn );

            //
            //  Check if have spilled into the reserved area of an Mft file record.
            //

            if ((Scb == Vcb->MftScb) &&
                (Context->AttributeList.Bcb != NULL)) {

                if (FileRecord->BytesAvailable - FileRecord->FirstFreeByte < Vcb->MftReserved
                    && (*(PLONGLONG)&FileRecord->BaseFileRecordSegment != 0)) {

                    NtfsAcquireCheckpoint( IrpContext, Vcb );

                    SetFlag( Vcb->MftDefragState,
                             VCB_MFT_DEFRAG_EXCESS_MAP | VCB_MFT_DEFRAG_ENABLED );

                    NtfsReleaseCheckpoint( IrpContext, Vcb );
                }
            }

            //
            //  It is possible that we have a file record which contains nothing but a
            //  hole, if that is the case see if we can merge this with either the
            //  preceding or following attribute (merge the holes).  We will then
            //  need to rewrite the mapping for the merged record.
            //

            if (SingleHole &&
                ARGUMENT_PRESENT( StartingVcn ) &&
                (Context->AttributeList.Bcb != NULL) &&
                (Scb != Vcb->MftScb) &&
                ((Attribute->Form.Nonresident.LowestVcn != 0) ||
                 (LlClustersFromBytesTruncate( Vcb, Scb->Header.AllocationSize.QuadPart ) !=
                  (Attribute->Form.Nonresident.HighestVcn + 1)))) {

                //
                //  Call our worker routine to perform the actual work if necessary.
                //

                NtfsMergeFileRecords( IrpContext,
                                      Scb,
                                      (BOOLEAN) (LastVcn < NewHighestVcn),
                                      Context );
            }

            //
            //  Step 6.
            //
            //  Now loop to create new file records if we have more allocation to
            //  describe.  We use the highest Vcn of the file record we began with
            //  as our stopping point or the last Vcn we are adding.
            //
            //  NOTE - The record merge code above uses the same test to see if there is more
            //  work to do.  If this test changes then the body of the IF statement above also
            //  needs to be updated.
            //

            while (LastVcn < NewHighestVcn) {

                MFT_SEGMENT_REFERENCE Reference;
                LONGLONG FileRecordNumber;
                PATTRIBUTE_TYPE_CODE NewEnd;

                //
                //  If we get here as the result of a hot fix in the Mft, bail
                //  out.  We could cause a disconnect in the Mft.
                //

                if (IsHotFixScb && (Scb == Vcb->MftScb)) {
                    ExRaiseStatus( STATUS_INTERNAL_ERROR );
                }

                //
                //  If we have a large sparse range then we may find that the limit
                //  in the base file record is range of clusters in the
                //  attribute not the number of runs.  In that case the base
                //  file record may not have been moved to its own file record
                //  and there is no attribute list.  We need to create the attribute
                //  list before cloning the file record.
                //

                if (Context->AttributeList.Bcb == NULL) {

                    NtfsCleanupAttributeContext( IrpContext, Context );
                    NtfsInitializeAttributeContext( Context );

                    //
                    //  We don't use the second file reference in this case so
                    //  it is safe to pass the value in the Fcb.
                    //

                    CreateAttributeList( IrpContext,
                                         Fcb,
                                         FileRecord,
                                         NULL,
                                         Fcb->FileReference,
                                         NULL,
                                         GetSizeForAttributeList( FileRecord ),
                                         Context );

                    //
                    //  Now look up the previous attribute again.
                    //

                    NtfsCleanupAttributeContext( IrpContext, Context );
                    NtfsInitializeAttributeContext( Context );
                    NtfsLookupAttributeForScb( IrpContext, Scb, &LastVcn, Context );
                }

                //
                //  Clone our current file record, and point to our new attribute.
                //

                NtfsUnpinBcb( IrpContext, &NewBcb );

                FileRecord = NtfsCloneFileRecord( IrpContext,
                                                  Fcb,
                                                  (BOOLEAN)(Scb == Vcb->MftScb),
                                                  &NewBcb,
                                                  &Reference );

                Attribute = Add2Ptr( FileRecord, FileRecord->FirstAttributeOffset );

                //
                //  Next LowestVcn is the LastVcn + 1
                //

                LastVcn = LastVcn + 1;
                Attribute->Form.Nonresident.LowestVcn = LastVcn;

                //
                //  Consistency check for MFT defragging. An mft segment can never
                //  describe itself or any piece of the mft before it
                //

                if (Scb == Vcb->MftScb) {
                    VCN NewFileVcn;

                    if (Vcb->FileRecordsPerCluster == 0) {
                        NewFileVcn = NtfsFullSegmentNumber( &Reference ) << Vcb->MftToClusterShift;
                    } else {
                        NewFileVcn = NtfsFullSegmentNumber( &Reference ) >> Vcb->MftToClusterShift;
                    }

                    if (LastVcn <= NewFileVcn) {
#ifdef BENL_DBG
                        KdPrint(( "NTFS: selfdescribing mft segment vcn: 0x%I64x, Ref: 0x%I64x\n", LastVcn, NtfsFullSegmentNumber( &Reference )  ));
#endif
                        NtfsRaiseStatus( IrpContext, STATUS_MFT_TOO_FRAGMENTED, NULL, NULL );
                    }
                }

                //
                //  Calculate the size of the attribute record we will need.
                //

                NewSize = SIZEOF_PARTIAL_NONRES_ATTR_HEADER
                          + QuadAlign( Scb->AttributeName.Length )
                          + QuadAlign( NtfsGetSizeForMappingPairs( Mcb,
                                                                   SizeAvailable,
                                                                   LastVcn,
                                                                   &NewHighestVcn,
                                                                   &LastVcn ));

                //
                //  Define the new range.
                //

                NtfsDefineNtfsMcbRange( &Scb->Mcb,
                                        Attribute->Form.Nonresident.LowestVcn,
                                        LastVcn - 1,
                                        FALSE );

                //
                //  Initialize the new attribute from the old one.
                //

                Attribute->TypeCode = Scb->AttributeTypeCode;
                Attribute->RecordLength = NewSize;
                Attribute->FormCode = NONRESIDENT_FORM;

                //
                //  Assume no attribute name, and calculate where the Mapping Pairs
                //  will go.  (Update below if we are wrong.)
                //

                MappingPairs = (PCHAR)Attribute + SIZEOF_PARTIAL_NONRES_ATTR_HEADER;

                //
                //  If the attribute has a name, take care of that now.
                //

                if (Scb->AttributeName.Length != 0) {

                    Attribute->NameLength = (UCHAR)(Scb->AttributeName.Length / sizeof(WCHAR));
                    Attribute->NameOffset = (USHORT)PtrOffset(Attribute, MappingPairs);
                    RtlCopyMemory( MappingPairs,
                                   Scb->AttributeName.Buffer,
                                   Scb->AttributeName.Length );
                    MappingPairs += QuadAlign( Scb->AttributeName.Length );
                }

                Attribute->Flags = Scb->AttributeFlags;
                Attribute->Instance = FileRecord->NextAttributeInstance++;

                //
                //  We always need the mapping pairs offset.
                //

                Attribute->Form.Nonresident.MappingPairsOffset = (USHORT)(MappingPairs -
                                                                 (PCHAR)Attribute);
                NewEnd = Add2Ptr( Attribute, Attribute->RecordLength );
                *NewEnd = $END;
                FileRecord->FirstFreeByte = PtrOffset( FileRecord, NewEnd )
                                            + QuadAlign( sizeof(ATTRIBUTE_TYPE_CODE ));

                //
                //  Now add the space in the file record.
                //

                *MappingPairs = 0;

                NtfsBuildMappingPairs( Mcb,
                                       Attribute->Form.Nonresident.LowestVcn,
                                       &LastVcn,
                                       MappingPairs );

                Attribute->Form.Nonresident.HighestVcn = LastVcn;

                //
                //  Now log these changes and fix up the first file record.
                //

                FileRecordNumber = NtfsFullSegmentNumber(&Reference);

                //
                //  Now log these changes and fix up the first file record.
                //

                FileRecord->Lsn =
                NtfsWriteLog( IrpContext,
                              Vcb->MftScb,
                              NewBcb,
                              InitializeFileRecordSegment,
                              FileRecord,
                              FileRecord->FirstFreeByte,
                              Noop,
                              NULL,
                              0,
                              LlBytesFromFileRecords( Vcb, FileRecordNumber ),
                              0,
                              0,
                              Vcb->BytesPerFileRecordSegment );

                //
                //  Finally, we have to add the entry to the attribute list.
                //  The routine we have to do this gets most of its inputs
                //  out of an attribute context.  Our context at this point
                //  does not have quite the right information, so we have to
                //  update it here before calling AddToAttributeList.  (OK
                //  this interface ain't pretty, but any normal person would
                //  have fallen asleep before getting to this comment!)
                //

                Context->FoundAttribute.FileRecord = FileRecord;
                Context->FoundAttribute.Attribute = Attribute;
                Context->AttributeList.Entry =
                  NtfsGetNextRecord(Context->AttributeList.Entry);

                NtfsAddToAttributeList( IrpContext, Fcb, Reference, Context );
            }

        } finally {

            NtfsUnpinBcb( IrpContext, &NewBcb );
        }

        if (!ARGUMENT_PRESENT( StartingVcn) ||
            (LowestVcnRemapped <= *StartingVcn)) {

            break;
        }

        //
        //  Move the range to be remapped down.
        //

        LocalClusterCount = LowestVcnRemapped - *StartingVcn;

        NtfsCleanupAttributeContext( IrpContext, Context );
        NtfsInitializeAttributeContext( Context );

        NtfsLookupAttributeForScb( IrpContext, Scb, NULL, Context );
    }

    DebugTrace( -1, Dbg, ("NtfsAddAttributeAllocation -> VOID\n") );
}


//
//  This routine is intended for use by allocsup.c.  Other callers should use
//  the routines in allocsup.
//

VOID
NtfsDeleteAttributeAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN LogIt,
    IN PVCN StopOnVcn,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context,
    IN BOOLEAN TruncateToVcn
    )

/*++

Routine Description:

    This routine deletes an existing nonresident attribute, removing the
    deleted clusters only from the allocation description in the file
    record.

    The caller specifies the attribute to be changed via the attribute context,
    and must be prepared to clean up this context no matter how this routine
    returns.  The Scb must already have deleted the clusters in question.

Arguments:

    Scb - Current attribute, with the clusters in question already deleted from
          the Mcb.

    LogIt - Most callers should specify TRUE, to have the change logged.  However,
            we can specify FALSE if we are deleting an entire file record, and
            will be logging that.

    StopOnVcn - Vcn to stop on for regerating mapping

    Context - Attribute Context positioned at the attribute to change.

    TruncateToVcn - Truncate file sizes as appropriate to the Vcn

Return Value:

    None.

--*/

{
    ULONG AttributeOffset;
    ULONG MappingPairsOffset, MappingPairsSize;
    CHAR MappingPairsBuffer[64];
    ULONG RecordOffset;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PCHAR MappingPairs;
    VCN LastVcn;
    ULONG NewSize;
    PVCB Vcb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    Vcb = Scb->Vcb;

    //
    //  For now we only support truncation.
    //

    DebugTrace( +1, Dbg, ("NtfsDeleteAttributeAllocation\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );

    //
    //  Make sure the buffer is pinned.
    //

    NtfsPinMappedAttribute( IrpContext, Vcb, Context );

    Attribute = NtfsFoundAttribute(Context);
    ASSERT( IsQuadAligned( Attribute->RecordLength ) );

    //
    //  Get the file record pointer.
    //

    FileRecord = NtfsContainingFileRecord(Context);
    RecordOffset = PtrOffset(FileRecord, Attribute);

    //
    //  Calculate how much space is actually needed.
    //

    MappingPairsSize = QuadAlign(NtfsGetSizeForMappingPairs( &Scb->Mcb,
                                                             MAXULONG,
                                                             Attribute->Form.Nonresident.LowestVcn,
                                                             StopOnVcn,
                                                             &LastVcn ));

    //
    //  Don't assume we understand everything about the size of the current header.
    //  Find the offset of the name or the mapping pairs to use as the size
    //  of the header.
    //


    NewSize = Attribute->Form.Nonresident.MappingPairsOffset;

    if (Attribute->NameLength != 0) {

        NewSize = Attribute->NameOffset + QuadAlign( Attribute->NameLength << 1 );
    }

    NewSize += MappingPairsSize;

    //
    //  If the record could somehow grow by deleting allocation, then
    //  NtfsChangeAttributeSize could fail and we would have to copy the
    //  loop from NtfsAddAttributeAllocation.
    //

    ASSERT( NewSize <= Attribute->RecordLength );

    MappingPairs = MappingPairsBuffer;

    if (MappingPairsSize > 64) {

        MappingPairs = NtfsAllocatePool( NonPagedPool, MappingPairsSize + 8 );
    }

    //
    //  Use try-finally to insure we free any pool on the way out.
    //

    try {

        //
        //  Now build up the mapping pairs in the buffer.
        //

        *MappingPairs = 0;
        NtfsBuildMappingPairs( &Scb->Mcb,
                               Attribute->Form.Nonresident.LowestVcn,
                               &LastVcn,
                               MappingPairs );

        //
        //  Now find the first different byte.  (Most of the time the
        //  cost to do this is probably more than paid for by less
        //  logging.)
        //

        AttributeOffset = Attribute->Form.Nonresident.MappingPairsOffset;
        MappingPairsOffset = (ULONG)
          RtlCompareMemory( MappingPairs,
                            Add2Ptr(Attribute, AttributeOffset),
                            MappingPairsSize );

        AttributeOffset += MappingPairsOffset;

        //
        //  Log the change.
        //

        if (LogIt) {

            FileRecord->Lsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NtfsFoundBcb(Context),
                          UpdateMappingPairs,
                          Add2Ptr(MappingPairs, MappingPairsOffset),
                          MappingPairsSize - MappingPairsOffset,
                          UpdateMappingPairs,
                          Add2Ptr(Attribute, AttributeOffset),
                          Attribute->RecordLength - AttributeOffset,
                          NtfsMftOffset( Context ),
                          RecordOffset,
                          AttributeOffset,
                          Vcb->BytesPerFileRecordSegment );
        }

        //
        //  Now do the mapping pairs update by calling the same
        //  routine called at restart.
        //

        NtfsRestartChangeMapping( IrpContext,
                                  Vcb,
                                  FileRecord,
                                  RecordOffset,
                                  AttributeOffset,
                                  Add2Ptr(MappingPairs, MappingPairsOffset),
                                  MappingPairsSize - MappingPairsOffset );

        //
        //  If we were asked to stop on a Vcn, then the caller does not wish
        //  us to modify the Scb.  (Currently this is only done one time when
        //  the Mft Data attribute no longer fits in the first file record.)
        //

        if (TruncateToVcn) {

            LONGLONG Size;

            //
            //  We add one cluster to calculate the allocation size.
            //

            LastVcn = LastVcn + 1;
            Size = LlBytesFromClusters( Vcb, LastVcn );
            Scb->Header.AllocationSize.QuadPart = Size;

            if (Scb->Header.ValidDataLength.QuadPart > Size) {
                Scb->Header.ValidDataLength.QuadPart = Size;
            }

            if (Scb->Header.FileSize.QuadPart > Size) {
                Scb->Header.FileSize.QuadPart = Size;
            }

            //
            //  Possibly update ValidDataToDisk which is only nonzero for compressed file
            //

            if (Size < Scb->ValidDataToDisk) {
                Scb->ValidDataToDisk = Size;
            }
        }

    } finally {

        if (MappingPairs != MappingPairsBuffer) {

            NtfsFreePool(MappingPairs);
        }
    }

    DebugTrace( -1, Dbg, ("NtfsDeleteAttributeAllocation -> VOID\n") );
}


BOOLEAN
NtfsIsFileDeleteable (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    OUT PBOOLEAN NonEmptyIndex
    )

/*++

Routine Description:

    This look checks if a file may be deleted by examing all of the index
    attributes to check that they have no children.

    Note that once a file is marked for delete, we must insure
    that none of the conditions checked by this routine are allowed to
    change.  For example, once the file is marked for delete, no links
    may be added, and no files may be created in any indices of this
    file.

Arguments:

    Fcb - Fcb for the file.

    NonEmptyIndex - Address to store TRUE if the file is not deleteable because
        it contains an non-empty indexed attribute.

Return Value:

    FALSE - If it is not ok to delete the specified file.
    TRUE - If it is ok to delete the specified file.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PATTRIBUTE_RECORD_HEADER Attribute;
    BOOLEAN MoreToGo;

    PAGED_CODE();

    NtfsInitializeAttributeContext( &Context );

    try {

        //
        //  Enumerate all of the attributes to check whether they may be deleted.
        //

        MoreToGo = NtfsLookupAttributeByCode( IrpContext,
                                              Fcb,
                                              &Fcb->FileReference,
                                              $INDEX_ROOT,
                                              &Context );

        while (MoreToGo) {

            //
            //  Point to the current attribute.
            //

            Attribute = NtfsFoundAttribute( &Context );

            //
            //  If the attribute is an index, then it must be empty.
            //

            if (!NtfsIsIndexEmpty( IrpContext, Attribute )) {

                *NonEmptyIndex = TRUE;
                break;
            }

            //
            //  Go to the next attribute.
            //

            MoreToGo = NtfsLookupNextAttributeByCode( IrpContext,
                                                      Fcb,
                                                      $INDEX_ROOT,
                                                      &Context );
        }

    } finally {

        DebugUnwind( NtfsIsFileDeleteable );

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    //
    //  The File is deleteable if scanned the entire file record
    //  and found no reasons we could not delete the file.
    //

    return (BOOLEAN)(!MoreToGo);
}


VOID
NtfsDeleteFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB ParentScb,
    IN OUT PBOOLEAN AcquiredParentScb,
    IN OUT PNAME_PAIR NamePair OPTIONAL,
    IN OUT PNTFS_TUNNELED_DATA TunneledData OPTIONAL
    )

/*++

Routine Description:

    This routine may be called to see if it is the specified file may
    be deleted from the specified parent (i.e., if the specified parent
    were to be acquired exclusive).  This routine should be called from
    fileinfo, to see whether it is ok to mark an open file for delete.

    NamePair will capture the names of the file being deleted if supplied.

    Note that once a file is marked for delete, none of we must insure
    that none of the conditions checked by this routine are allowed to
    change.  For example, once the file is marked for delete, no links
    may be added, and no files may be created in any indices of this
    file.

    NOTE:   The caller must have the Fcb and ParentScb exclusive to call
            this routine,

Arguments:

    Fcb - Fcb for the file.

    ParentScb - Parent Scb via which the file was opened, and which would
        be acquired exclusive to perform the delete.

    AcquiredParentScb - On input indicates whether the ParentScb has
        already been acquired.  Set to TRUE here if this routine
        acquires the parent.

    TunneledData - Optionally provided to capture the name pair and
        object id of a file so they can be tunneled.

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    LONGLONG Delta;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PVCB Vcb;
    BOOLEAN MoreToGo;
    ULONG RecordNumber;
    NUKEM LocalNuke;
    ULONG Pass;
    ULONG i;
    PNUKEM TempNukem;
    PNUKEM Nukem = &LocalNuke;
    ULONG NukemIndex = 0;
    UCHAR *ObjectId;
    MAP_HANDLE MapHandle;
    BOOLEAN NonresidentAttributeList = FALSE;
    BOOLEAN InitializedMapHandle = FALSE;
    BOOLEAN ReparsePointIsPresent = FALSE;
    BOOLEAN ObjectIdIsPresent = FALSE;
    BOOLEAN LogIt;
    BOOLEAN AcquiredReparseIndex = FALSE;
    BOOLEAN AcquiredObjectIdIndex = FALSE;

    ULONG ForceCheckpointCount;

    ULONG IncomingFileAttributes = 0;                             //  invalid value
    ULONG IncomingReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;  //  invalid value

    PAGED_CODE();

    ASSERT_EXCLUSIVE_FCB( Fcb );

    RtlZeroMemory( &LocalNuke, sizeof(NUKEM) );

    Vcb = Fcb->Vcb;

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_QUOTA_DISABLE );

    //
    //  Remember the values of the file attribute flags and of the reparse tag
    //  for abnormal termination recovery.
    //

    IncomingFileAttributes = Fcb->Info.FileAttributes;
    IncomingReparsePointTag = Fcb->Info.ReparsePointTag;

    try {

        //
        //  We perform the delete in multiple passes.  We need to break this up carefully so that
        //  if the delete aborts for any reason that the file is left in a consistent state.  The
        //  operations are broken up into the following stages.
        //
        //
        //  First stage - free any allocation possible
        //
        //      - Truncate all user streams to length zero
        //
        //  Middle stage - this is required for files with a large number of attributes.  Otherwise
        //      we can't delete the file records and stay within the log file.  Skip this pass
        //      for smaller files.
        //
        //      - Remove data attributes except unnamed
        //
        //  Final stage - no checkpoints allowed until the end of this stage.
        //
        //      -  Acquire the quota resource if needed.
        //      -  Remove filenames from Index (for any filename attributes still present)
        //      -  Remove entry from ObjectId Index
        //      -  Delete allocation for reparse point and 4.0 style security descriptor
        //      -  Remove entry from Reparse Index
        //      -  Delete AttributeList
        //      -  Log deallocate of file records
        //

        for (Pass = 1; Pass <= 3; Pass += 1) {

            ForceCheckpointCount = 0;
            NtfsInitializeAttributeContext( &Context );

            //
            //  Enumerate all of the attributes to check whether they may be deleted.
            //

            MoreToGo = NtfsLookupAttribute( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            &Context );

            //
            //  Log the change to the mapping pairs if there is an attribute list.
            //

            LogIt = FALSE;


            if (Context.AttributeList.Bcb != NULL) {
                LogIt = TRUE;
            }

            //
            //  Remember if we want to log the changes to non-resident attributes.
            //

            while (MoreToGo) {

                //
                //  Point to the current attribute.
                //

                Attribute = NtfsFoundAttribute( &Context );

                //
                //  All indices must be empty.
                //

                ASSERT( (Attribute->TypeCode != $INDEX_ROOT) ||
                        NtfsIsIndexEmpty( IrpContext, Attribute ));

                //
                //  Remember when the $REPARSE_POINT attribute is present.
                //  When it is non-resident we delete it in pass 3.
                //  The entry in the $Reparse index always gets deleted in pass 3.
                //  We have to delete the index entry before deleting the allocation.
                //

                if (Attribute->TypeCode == $REPARSE_POINT) {

                    ReparsePointIsPresent = TRUE;

                    if (Pass == 3) {

                        //
                        //  If this is the $REPARSE_POINT attribute, delete now the appropriate
                        //  entry from the $Reparse index.
                        //

                        NTSTATUS Status = STATUS_SUCCESS;
                        INDEX_KEY IndexKey;
                        INDEX_ROW IndexRow;
                        REPARSE_INDEX_KEY KeyValue;
                        PREPARSE_DATA_BUFFER ReparseBuffer = NULL;
                        PVOID AttributeData = NULL;
                        PBCB Bcb = NULL;
                        ULONG Length = 0;

                        //
                        //  Point to the attribute data.
                        //

                        if (NtfsIsAttributeResident( Attribute )) {

                            //
                            //  Point to the value of the arribute.
                            //

                            AttributeData = NtfsAttributeValue( Attribute );
                            DebugTrace( 0, Dbg, ("Existing attribute is resident.\n") );

                        } else {

                            //
                            //  Map the attribute list if the attribute is non-resident.
                            //  Otherwise the attribute is already mapped and we have a Bcb
                            //  in the attribute context.
                            //

                            DebugTrace( 0, Dbg, ("Existing attribute is non-resident.\n") );

                            if (Attribute->Form.Nonresident.FileSize > MAXIMUM_REPARSE_DATA_BUFFER_SIZE) {
                                NtfsRaiseStatus( IrpContext,STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                            }

                            NtfsMapAttributeValue( IrpContext,
                                                   Fcb,
                                                   &AttributeData,      //  point to the value
                                                   &Length,
                                                   &Bcb,
                                                   &Context );

                            //
                            //  Unpin the Bcb. The unpin routine checks for NULL.
                            //

                            NtfsUnpinBcb( IrpContext, &Bcb );
                        }

                        //
                        //  Set the pointer to extract the reparse point tag.
                        //

                        ReparseBuffer = (PREPARSE_DATA_BUFFER)AttributeData;

                        //
                        //  Verify that this file is in the reparse point index and delete it.
                        //

                        KeyValue.FileReparseTag = ReparseBuffer->ReparseTag;
                        KeyValue.FileId = *(PLARGE_INTEGER)&Fcb->FileReference;

                        IndexKey.Key = (PVOID)&KeyValue;
                        IndexKey.KeyLength = sizeof(KeyValue);

                        NtOfsInitializeMapHandle( &MapHandle );
                        InitializedMapHandle = TRUE;

                        //
                        //  All of the resources should have been acquired.
                        //

                        ASSERT( *AcquiredParentScb );
                        ASSERT( AcquiredReparseIndex );

                        //
                        //  NtOfsFindRecord will return an error status if the key is not found.
                        //

                        Status = NtOfsFindRecord( IrpContext,
                                                  Vcb->ReparsePointTableScb,
                                                  &IndexKey,
                                                  &IndexRow,
                                                  &MapHandle,
                                                  NULL );

                        if (!NT_SUCCESS(Status)) {

                            //
                            //  Should not happen. The reparse point should be in the index.
                            //

                            DebugTrace( 0, Dbg, ("Record not found in the reparse point index.\n") );
                            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                        }

                        //
                        //  Remove the entry from the reparse point index.
                        //

                        NtOfsDeleteRecords( IrpContext,
                                            Vcb->ReparsePointTableScb,
                                            1,            // deleting one record from the index
                                            &IndexKey );
                    }
                }

                //
                //  If the attribute is nonresident, then delete its allocation.
                //  We only need to make the NtfsDeleteAllocation from record for
                //  the attribute with lowest Vcn of zero.  This will deallocate
                //  all of the clusters for the file.
                //

                if (Attribute->FormCode == NONRESIDENT_FORM) {

                    if ((Attribute->Form.Nonresident.LowestVcn == 0) &&
                        (Attribute->Form.Nonresident.AllocatedLength != 0)) {

                        if (Pass == 1) {

                            //
                            //  Postpone till pass 3 the deletion of the non-resident attribute in
                            //  the case of a security descriptor and a reparse point.
                            //

                            if ((Attribute->TypeCode != $SECURITY_DESCRIPTOR) &&
                                (Attribute->TypeCode != $REPARSE_POINT)) {

                                NtfsDeleteAllocationFromRecord( IrpContext, Fcb, &Context, TRUE, LogIt );

                                //
                                //  Make sure we count the number of these calls we make.  Force a
                                //  periodic checkpoint on a file with a lot of streams.  We might have
                                //  thousands of streams whose allocations won't force a checkpoint.  we
                                //  could spin indefinitely trying to delete this file.  Lets force
                                //  a checkpoint on a regular basis.
                                //

                                ForceCheckpointCount += 1;

                                if (ForceCheckpointCount > 10) {

                                    NtfsCheckpointCurrentTransaction( IrpContext );
                                    ForceCheckpointCount = 0;
                                }

                                //
                                //  Reload the attribute pointer in the event it
                                //  was remapped.
                                //

                                Attribute = NtfsFoundAttribute( &Context );
                            }

                        } else if (Pass == 3) {

                            //
                            //  Now, in pass 3, delete the security descriptor and the reparse
                            //  point attributes when they are non-residents.
                            //

                            if ((Attribute->TypeCode == $SECURITY_DESCRIPTOR) ||
                                (Attribute->TypeCode == $REPARSE_POINT)) {

                                NtfsDeleteAllocationFromRecord( IrpContext, Fcb, &Context, FALSE, LogIt );

                                //
                                //  Reload the attribute pointer in the event it
                                //  was remapped.
                                //

                                Attribute = NtfsFoundAttribute( &Context );
                            }
                        }
                    }

                } else {

                    //
                    //  If we are at the start of Pass 3 then make sure we have the parent
                    //  acquired and can perform any necessary quota operations.
                    //

                    if ((Attribute->TypeCode == $STANDARD_INFORMATION) &&
                        (Pass == 3)) {

                        if (!*AcquiredParentScb ||
                            NtfsPerformQuotaOperation( Fcb ) ||
                            ReparsePointIsPresent ||
                            ObjectIdIsPresent) {

                            //
                            //  See if we need to acquire any resources, and if so, get
                            //  them in the right order.  We need to do this carefully.
                            //  If the Mft is acquired by this thread then checkpoint
                            //  the transaction and release the Mft before we go any
                            //  further.
                            //

                            if (Vcb->MftScb->Fcb->ExclusiveFcbLinks.Flink != NULL &&
                                NtfsIsExclusiveScb( Vcb->MftScb )) {

                                NtfsCheckpointCurrentTransaction( IrpContext );
                                NtfsReleaseScb( IrpContext, Vcb->MftScb );
                            }

                            ASSERT(!NtfsIsExclusiveScb( Vcb->MftScb ));

                            //
                            //  Now acquire the parent if not already acquired.
                            //

                            if (!*AcquiredParentScb) {

                                NtfsAcquireExclusiveScb( IrpContext, ParentScb );
                                *AcquiredParentScb = TRUE;
                            }

                            if (ObjectIdIsPresent) {

                                NtfsAcquireExclusiveScb( IrpContext, Vcb->ObjectIdTableScb );
                                AcquiredObjectIdIndex = TRUE;
                            }

                            //
                            //  Also acquire reparse & object id if necessary in
                            //  the correct bottom-up Vcb order.
                            //

                            if (ReparsePointIsPresent && !AcquiredReparseIndex) {

                                NtfsAcquireExclusiveScb( IrpContext, Vcb->ReparsePointTableScb );
                                AcquiredReparseIndex = TRUE;
                            }

                            //
                            //  We may acquire the quota index in here.
                            //

                            if (Attribute->Form.Resident.ValueLength == sizeof( STANDARD_INFORMATION )) {

                                //
                                //  Capture all of the user's quota for this file.
                                //

                                //
                                //  The quota resource cannot be acquired before the streams
                                //  are deleted because we can deadlock with the mapped page
                                //  writer when CcSetFileSizes is called.
                                //

                                if (NtfsPerformQuotaOperation( Fcb )) {

                                    ASSERT(!NtfsIsExclusiveScb( Vcb->MftScb ));

                                    Delta = -(LONGLONG) ((PSTANDARD_INFORMATION)
                                                         NtfsAttributeValue( Attribute ))->QuotaCharged;

                                    NtfsUpdateFileQuota( IrpContext,
                                                         Fcb,
                                                         &Delta,
                                                         TRUE,
                                                         FALSE );
                                }
                            }
                        }
                    }
                }

                //
                //  If we are deleting the object id attribute, we need to
                //  update the object id index as well.
                //

                if (Attribute->TypeCode == $OBJECT_ID) {

                    if (Pass == 1) {

                        //
                        //  On pass 1, it is only necessary to remember we have
                        //  an object id so we remember to acquire the oid index
                        //  on pass 3.
                        //

                        ObjectIdIsPresent = TRUE;

                    } else if (Pass == 3) {

                        //
                        //  We'd better be holding the object id index and parent
                        //  directory already, or else there is a potential for
                        //  deadlock.
                        //

                        ASSERT(NtfsIsExclusiveScb( Vcb->ObjectIdTableScb ));
                        ASSERT(*AcquiredParentScb);

                        if (ARGUMENT_PRESENT(TunneledData)) {

                            //
                            //  We need to lookup the object id so we can tunnel it.
                            //

                            TunneledData->HasObjectId = TRUE;

                            ObjectId = (UCHAR *) NtfsAttributeValue( Attribute );

                            RtlCopyMemory( TunneledData->ObjectIdBuffer.ObjectId,
                                           ObjectId,
                                           sizeof(TunneledData->ObjectIdBuffer.ObjectId) );

                            NtfsGetObjectIdExtendedInfo( IrpContext,
                                                         Fcb->Vcb,
                                                         ObjectId,
                                                         TunneledData->ObjectIdBuffer.ExtendedInfo );
                        }

                        //
                        //  We need to delete the object id from the index
                        //  to keep everything consistent.  The FALSE means
                        //  don't delete the attribute itself, that would
                        //  lead to some ugly recursion.
                        //

                        NtfsDeleteObjectIdInternal( IrpContext,
                                                    Fcb,
                                                    Vcb,
                                                    FALSE );
                    }
                }

                //
                //  If we are in the second pass then remove extra named data streams.
                //

                if (Pass == 2) {

                    //
                    //  The record is large enough to consider.  Only do this for named
                    //  data streams
                    //

                    if ((Attribute->TypeCode == $DATA) &&
                        (Attribute->NameLength != 0)) {

                        PSCB DeleteScb;
                        UNICODE_STRING AttributeName;

                        //
                        //  Get the Scb so we can mark it as deleted.
                        //

                        AttributeName.Buffer = Add2Ptr( Attribute, Attribute->NameOffset );
                        AttributeName.Length = Attribute->NameLength * sizeof( WCHAR );

                        DeleteScb = NtfsCreateScb( IrpContext,
                                                   Fcb,
                                                   Attribute->TypeCode,
                                                   &AttributeName,
                                                   TRUE,
                                                   NULL );

                        NtfsDeleteAttributeRecord( IrpContext,
                                                   Fcb,
                                                   (DELETE_LOG_OPERATION |
                                                    DELETE_RELEASE_FILE_RECORD),
                                                   &Context );

                        if (DeleteScb != NULL) {

                            SetFlag( DeleteScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
                            DeleteScb->AttributeTypeCode = $UNUSED;
                        }

                        //
                        //  Let's checkpoint periodically after each attribute.  Since
                        //  the attribute list is large and we are removing and
                        //  entry from the beginning of the list the log records
                        //  can be very large.
                        //

                        NtfsCheckpointCurrentTransaction( IrpContext );
                    }

                } else if (Pass == 3) {

                    //
                    //  If the attribute is a file name, then it must be from our
                    //  caller's parent directory, or else we cannot delete.
                    //

                    if (Attribute->TypeCode == $FILE_NAME) {

                        PFILE_NAME FileName;

                        FileName = (PFILE_NAME)NtfsAttributeValue( Attribute );

                        ASSERT( ARGUMENT_PRESENT( ParentScb ));

                        ASSERT(NtfsEqualMftRef(&FileName->ParentDirectory,
                                               &ParentScb->Fcb->FileReference));

                        if (ARGUMENT_PRESENT(NamePair)) {

                            //
                            //  Squirrel away names
                            //

                            NtfsCopyNameToNamePair( NamePair,
                                                    FileName->FileName,
                                                    FileName->FileNameLength,
                                                    FileName->Flags );
                        }

                        NtfsDeleteIndexEntry( IrpContext,
                                              ParentScb,
                                              (PVOID)FileName,
                                              &Fcb->FileReference );
                    }

                    //
                    //  If this file record is not already deleted, then do it now.
                    //  Note, we are counting on its contents not to change.
                    //

                    FileRecord = NtfsContainingFileRecord( &Context );

                    //
                    //  See if this is the same as the last one we remembered, else remember it.
                    //

                    if (Context.AttributeList.Bcb != NULL) {

                        RecordNumber = NtfsUnsafeSegmentNumber( &Context.AttributeList.Entry->SegmentReference );
                    } else {
                        RecordNumber = NtfsUnsafeSegmentNumber( &Fcb->FileReference );
                    }

                    //
                    //  Now loop to see if we already remembered this record.
                    //  This reduces our pool allocation and also prevents us
                    //  from deleting file records twice.
                    //

                    TempNukem = Nukem;
                    while (TempNukem != NULL) {

                        for (i = 0; i < 4; i++) {

                            if (TempNukem->RecordNumbers[i] == RecordNumber) {

                                RecordNumber = 0;
                                break;
                            }
                        }

                        TempNukem = TempNukem->Next;
                    }

                    if (RecordNumber != 0) {

                        //
                        //  Is the list full?  If so allocate and initialize a new one.
                        //

                        if (NukemIndex > 3) {

                            TempNukem = (PNUKEM)ExAllocateFromPagedLookasideList( &NtfsNukemLookasideList );
                            RtlZeroMemory( TempNukem, sizeof(NUKEM) );
                            TempNukem->Next = Nukem;
                            Nukem = TempNukem;
                            NukemIndex = 0;
                        }

                        //
                        //  Remember to delete this guy.  (Note we can possibly list someone
                        //  more than once, but NtfsDeleteFileRecord handles that.)
                        //

                        Nukem->RecordNumbers[NukemIndex] = RecordNumber;
                        NukemIndex += 1;
                    }

                //
                //  When we have the first attribute, check for the existance of
                //  a non-resident attribute list.
                //

                } else if ((Attribute->TypeCode == $STANDARD_INFORMATION) &&
                           (Context.AttributeList.Bcb != NULL) &&
                           (!NtfsIsAttributeResident( Context.AttributeList.AttributeList ))) {

                    NonresidentAttributeList = TRUE;
                }


                //
                //  Go to the next attribute.
                //

                MoreToGo = NtfsLookupNextAttribute( IrpContext,
                                                    Fcb,
                                                    &Context );
            }

            NtfsCleanupAttributeContext( IrpContext, &Context );

            //
            //  Skip pass 2 unless there is a large attribute list.
            //

            if (Pass == 1) {

                if (RtlPointerToOffset( Context.AttributeList.FirstEntry,
                                        Context.AttributeList.BeyondFinalEntry ) > 0x1000) {

                    //
                    //  Go ahead and checkpoint now so we will make progress in Pass 2.
                    //

                    NtfsCheckpointCurrentTransaction( IrpContext );

                } else {

                    //
                    //  Skip pass 2.
                    //

                    Pass += 1;
                }
            }
        }

        //
        //  Handle the unusual nonresident attribute list case
        //

        if (NonresidentAttributeList) {

            NtfsInitializeAttributeContext( &Context );

            NtfsLookupAttributeByCode( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       $ATTRIBUTE_LIST,
                                       &Context );

            NtfsDeleteAllocationFromRecord( IrpContext, Fcb, &Context, FALSE, FALSE );
            NtfsCleanupAttributeContext( IrpContext, &Context );
        }

        //
        //  Post the delete to the Usn Journal.
        //

        NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_FILE_DELETE | USN_REASON_CLOSE );

        //
        //  Now loop to delete the file records.
        //

        while (Nukem != NULL) {

            for (i = 0; i < 4; i++) {

                if (Nukem->RecordNumbers[i] != 0) {


                    NtfsDeallocateMftRecord( IrpContext,
                                             Vcb,
                                             Nukem->RecordNumbers[i] );
                }
            }

            TempNukem = Nukem->Next;
            if (Nukem != &LocalNuke) {
                ExFreeToPagedLookasideList( &NtfsNukemLookasideList, Nukem );
            }
            Nukem = TempNukem;
        }

    } finally {

        DebugUnwind( NtfsDeleteFile );

        NtfsCleanupAttributeContext( IrpContext, &Context );

        ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_QUOTA_DISABLE );

        //
        //  Release the reparse point index Scb and the map handle.
        //

        if (AcquiredReparseIndex) {

            NtfsReleaseScb( IrpContext, Vcb->ReparsePointTableScb );
        }

        if (InitializedMapHandle) {

            NtOfsReleaseMap( IrpContext, &MapHandle );
        }

        //
        //  Drop the object id index if necessary.
        //

        if (AcquiredObjectIdIndex) {

            NtfsReleaseScb( IrpContext, Vcb->ObjectIdTableScb );
        }

        //
        //  Need to roll-back the value of the file attributes and the reparse point
        //  flag in case of problems.
        //

        if (AbnormalTermination()) {

            Fcb->Info.FileAttributes = IncomingFileAttributes;
            Fcb->Info.ReparsePointTag = IncomingReparsePointTag;
        }
    }

    return;
}


VOID
NtfsPrepareForUpdateDuplicate (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PLCB *Lcb,
    IN OUT PSCB *ParentScb,
    IN BOOLEAN AcquireShared
    )

/*++

Routine Description:

    This routine is called to prepare for updating the duplicate information.
    At the conclusion of this routine we will have the Lcb and Scb for the
    update along with the Scb acquired.  This routine will look at
    the existing values for the input parameters in deciding what actions
    need to be done.

Arguments:

    Fcb - Fcb for the file.  The file must already be acquired exclusively.

    Lcb - This is the address to store the link to update.  This may already
        have a value.

    ParentScb - This is the address to store the parent Scb for the update.
        This may already point to a valid Scb.

    AcquireShared - Indicates how to acquire the parent Scb.

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;
    PLCB ThisLcb;

    PAGED_CODE();

    //
    //  Start by trying to guarantee we have an Lcb for the update.
    //

    if (*Lcb == NULL) {

        Links = Fcb->LcbQueue.Flink;

        while (Links != &Fcb->LcbQueue) {

            ThisLcb = CONTAINING_RECORD( Links,
                                         LCB,
                                         FcbLinks );

            //
            //  We can use this link if it is still present on the
            //  disk and if we were passed a parent Scb, it matches
            //  the one for this Lcb.
            //

            if (!FlagOn( ThisLcb->LcbState, LCB_STATE_LINK_IS_GONE ) &&
                ((*ParentScb == NULL) ||
                 (*ParentScb == ThisLcb->Scb) ||
                 ((ThisLcb == Fcb->Vcb->RootLcb) &&
                  (*ParentScb == Fcb->Vcb->RootIndexScb)))) {

                *Lcb = ThisLcb;
                break;
            }

            Links = Links->Flink;
        }
    }

    //
    //  If we have an Lcb, try to find the correct Scb.
    //

    if ((*Lcb != NULL) && (*ParentScb == NULL)) {

        if (*Lcb == Fcb->Vcb->RootLcb) {

            *ParentScb = Fcb->Vcb->RootIndexScb;

        } else {

            *ParentScb = (*Lcb)->Scb;
        }
    }

    //
    //  Acquire the parent Scb and put it in the transaction queue in the
    //  IrpContext.
    //

    if (*ParentScb != NULL) {

        if (AcquireShared) {

            NtfsAcquireSharedScbForTransaction( IrpContext, *ParentScb );

        } else {

            NtfsAcquireExclusiveScb( IrpContext, *ParentScb );
        }
    }

    return;
}


VOID
NtfsUpdateDuplicateInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PLCB Lcb OPTIONAL,
    IN PSCB ParentScb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to update the duplicate information for a file
    in the duplicated information of its parent.  If the Lcb is specified
    then this parent is the parent to update.  If the link is either an
    NTFS or DOS only link then we must update the complementary link as
    well.  If no Lcb is specified then this open was by file id or the
    original link has been deleted.  In that case we will try to find a different
    link to update.

Arguments:

    Fcb - Fcb for the file.

    Lcb - This is the link to update.  Specified only if this is not
        an open by Id operation.

    ParentScb - This is the parent directory for the Lcb link if specified.

Return Value:

    None

--*/

{
    PQUICK_INDEX QuickIndex = NULL;

    UCHAR Buffer[sizeof( FILE_NAME ) + 11 * sizeof( WCHAR )];
    PFILE_NAME FileNameAttr;

    BOOLEAN AcquiredFcbTable = FALSE;

    BOOLEAN ReturnedExistingFcb = TRUE;
    BOOLEAN Found;
    UCHAR FileNameFlags;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PVCB Vcb = Fcb->Vcb;

    PFCB ParentFcb = NULL;

    PAGED_CODE();

    ASSERT_EXCLUSIVE_FCB( Fcb );

    //
    //  Return immediately if the volume is locked or
    //  is mounted readonly.
    //

    if (FlagOn( Vcb->VcbState, (VCB_STATE_LOCKED |
                                VCB_STATE_MOUNT_READ_ONLY ))) {

        return;
    }

    NtfsInitializeAttributeContext( &Context );

    try {

        //
        //  If we are updating the entry for the root then we know the
        //  file name attribute to build.
        //

        if (Fcb == Fcb->Vcb->RootIndexScb->Fcb) {

            Lcb = Fcb->Vcb->RootLcb;
            ParentScb = Fcb->Vcb->RootIndexScb;

            QuickIndex = &Fcb->Vcb->RootLcb->QuickIndex;

            FileNameAttr = (PFILE_NAME) &Buffer;

            RtlZeroMemory( FileNameAttr,
                           sizeof( FILE_NAME ));

            NtfsBuildFileNameAttribute( IrpContext,
                                        &Fcb->FileReference,
                                        NtfsRootIndexString,
                                        FILE_NAME_DOS | FILE_NAME_NTFS,
                                        FileNameAttr );

        //
        //  If we have and Lcb then it is either present or we noop this update.
        //

        } else if (ARGUMENT_PRESENT( Lcb )) {

            if (!FlagOn( Lcb->LcbState, LCB_STATE_LINK_IS_GONE )) {

                QuickIndex = &Lcb->QuickIndex;
                FileNameAttr = Lcb->FileNameAttr;

            } else {

                leave;
            }

        //
        //  If there is no Lcb then lookup the first filename attribute
        //  and update its index entry.  If there is a parent Scb then we
        //  must find a file name attribute for the same parent or we could
        //  get into a deadlock situation.
        //

        } else {

            //
            //  We now have a name link to update.  We will now need
            //  an Scb for the parent index.  Remember that we may
            //  have to teardown the Scb.  If we already have a ParentScb
            //  then we must find a link to the same parent or to the root.
            //  Otherwise we could hit a deadlock.
            //

            Found = NtfsLookupAttributeByCode( IrpContext,
                                               Fcb,
                                               &Fcb->FileReference,
                                               $FILE_NAME,
                                               &Context );

            if (!Found) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Loop until we find a suitable link or there are no more on the file.
            //

            do {

                FileNameAttr = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &Context ));

                //
                //  If there is a parent and this attribute has the same parent we are
                //  done.  Our caller will always have acquired the ParentScb.
                //

                if (ARGUMENT_PRESENT( ParentScb )) {

                    if (NtfsEqualMftRef( &FileNameAttr->ParentDirectory,
                                         &ParentScb->Fcb->FileReference )) {

                        ASSERT_SHARED_SCB( ParentScb );
                        break;
                    }

                //
                //  If this is the parent of this link is the root then
                //  acquire the root directory.
                //

                } else if (NtfsEqualMftRef( &FileNameAttr->ParentDirectory,
                                            &Vcb->RootIndexScb->Fcb->FileReference )) {

                    ParentScb = Vcb->RootIndexScb;
                    NtfsAcquireSharedScbForTransaction( IrpContext, ParentScb );
                    break;

                //
                //  We have a link for this file.  If we weren't given a parent
                //  Scb then create one here.
                //

                } else if (!ARGUMENT_PRESENT( ParentScb )) {

                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    AcquiredFcbTable = TRUE;

                    ParentFcb = NtfsCreateFcb( IrpContext,
                                               Vcb,
                                               FileNameAttr->ParentDirectory,
                                               FALSE,
                                               TRUE,
                                               &ReturnedExistingFcb );

                    ParentFcb->ReferenceCount += 1;

                    if (!NtfsAcquireExclusiveFcb( IrpContext, ParentFcb, NULL, ACQUIRE_NO_DELETE_CHECK | ACQUIRE_DONT_WAIT )) {

                        NtfsReleaseFcbTable( IrpContext, Vcb );
                        NtfsAcquireExclusiveFcb( IrpContext, ParentFcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                        NtfsAcquireFcbTable( IrpContext, Vcb );
                    }

                    ParentFcb->ReferenceCount -= 1;

                    NtfsReleaseFcbTable( IrpContext, Vcb );
                    AcquiredFcbTable = FALSE;

                    ParentScb = NtfsCreateScb( IrpContext,
                                               ParentFcb,
                                               $INDEX_ALLOCATION,
                                               &NtfsFileNameIndex,
                                               FALSE,
                                               NULL );

                    NtfsAcquireExclusiveScb( IrpContext, ParentScb );
                    break;
                }

            } while (Found = NtfsLookupNextAttributeByCode( IrpContext,
                                                             Fcb,
                                                             $FILE_NAME,
                                                             &Context ));

            //
            //  If we didn't find anything then return.
            //

            if (!Found) { leave; }
        }

        //
        //  Now update the filename in the parent index.
        //

        NtfsUpdateFileNameInIndex( IrpContext,
                                   ParentScb,
                                   FileNameAttr,
                                   &Fcb->Info,
                                   QuickIndex );

        //
        //  If this filename is either NTFS-ONLY or DOS-ONLY then
        //  we need to find the other link.
        //

        if ((FileNameAttr->Flags == FILE_NAME_NTFS) ||
            (FileNameAttr->Flags == FILE_NAME_DOS)) {

            //
            //  Find out which flag we should be looking for.
            //

            if (FlagOn( FileNameAttr->Flags, FILE_NAME_NTFS )) {

                FileNameFlags = FILE_NAME_DOS;

            } else {

                FileNameFlags = FILE_NAME_NTFS;
            }

            if (!ARGUMENT_PRESENT( Lcb )) {

                NtfsCleanupAttributeContext( IrpContext, &Context );
                NtfsInitializeAttributeContext( &Context );
            }

            //
            //  Now scan for the filename attribute we need.
            //

            Found = NtfsLookupAttributeByCode( IrpContext,
                                               Fcb,
                                               &Fcb->FileReference,
                                               $FILE_NAME,
                                               &Context );

            while (Found) {

                FileNameAttr = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &Context ));

                if (FileNameAttr->Flags == FileNameFlags) {

                    break;
                }

                Found = NtfsLookupNextAttributeByCode( IrpContext,
                                                       Fcb,
                                                       $FILE_NAME,
                                                       &Context );
            }

            //
            //  We should have found the entry.
            //

            if (!Found) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            NtfsUpdateFileNameInIndex( IrpContext,
                                       ParentScb,
                                       FileNameAttr,
                                       &Fcb->Info,
                                       NULL );
        }

    } finally {

        DebugUnwind( NtfsUpdateDuplicateInfo );

        if (AcquiredFcbTable) {

            NtfsReleaseFcbTable( IrpContext, Vcb );
        }

        //
        //  Cleanup the attribute context for this attribute search.
        //

        NtfsCleanupAttributeContext( IrpContext, &Context );

        //
        //  If we created the ParentFcb here then release it and
        //  call teardown on it.
        //

        if (!ReturnedExistingFcb && (ParentFcb != NULL)) {

            NtfsTeardownStructures( IrpContext,
                                    ParentFcb,
                                    NULL,
                                    FALSE,
                                    0,
                                    NULL );
        }
    }

    return;
}


VOID
NtfsUpdateLcbDuplicateInfo (
    IN PFCB Fcb,
    IN PLCB Lcb
    )

/*++

Routine Description:

    This routine is called after updating duplicate information via an Lcb.
    We want to clear the info flags for this Lcb and any complementary Lcb
    it may be part of.  We also want to OR in the Info flags in the Fcb with
    any other Lcb's attached to the Fcb so we will update those in a timely
    fashion as well.

Arguments:

    Fcb - Fcb for the file.

    Lcb - Lcb used to update duplicate information.  It may not be present but
        that would be a rare case and we will perform that test here.

Return Value:

    None

--*/

{
    UCHAR FileNameFlags;
    PLCB NextLcb;
    PLIST_ENTRY Links;

    PAGED_CODE();

    //
    //  No work to do unless we were passed an Lcb.
    //

    if (Lcb != NULL) {

        //
        //  Check if this is an NTFS only or DOS only link.
        //

        if (Lcb->FileNameAttr->Flags == FILE_NAME_NTFS) {

            FileNameFlags = FILE_NAME_DOS;

        } else if (Lcb->FileNameAttr->Flags == FILE_NAME_DOS) {

            FileNameFlags = FILE_NAME_NTFS;

        } else {

            FileNameFlags = (UCHAR) -1;
        }

        Lcb->InfoFlags = 0;

        Links = Fcb->LcbQueue.Flink;

        do {

            NextLcb = CONTAINING_RECORD( Links,
                                         LCB,
                                         FcbLinks );

            if (NextLcb != Lcb) {

                if (NextLcb->FileNameAttr->Flags == FileNameFlags) {

                    NextLcb->InfoFlags = 0;

                } else {

                    SetFlag( NextLcb->InfoFlags, Fcb->InfoFlags );
                }
            }

            Links = Links->Flink;

        } while (Links != &Fcb->LcbQueue);
    }

    return;
}


VOID
NtfsUpdateFcb (
    IN PFCB Fcb,
    IN ULONG ChangeFlags
    )

/*++

Routine Description:

    This routine is called when a timestamp may be updated on an Fcb which
    may have no open handles.  We update the time stamps for the flags passed
    in.

Arguments:

    Fcb - Fcb for the file.

    ChangeFlags - Flags indicating which times to update.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  We need to update the parent directory's time stamps
    //  to reflect this change.
    //

    //
    //  The change flag should always be set.
    //

    ASSERT( FlagOn( ChangeFlags, FCB_INFO_CHANGED_LAST_CHANGE ));
    KeQuerySystemTime( (PLARGE_INTEGER)&Fcb->Info.LastChangeTime );

    SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

    //
    //  Test for the other flags which may be set.
    //

    if (FlagOn( ChangeFlags, FCB_INFO_CHANGED_LAST_MOD )) {

        Fcb->Info.LastModificationTime = Fcb->Info.LastChangeTime;
    }

    if (FlagOn( ChangeFlags, FCB_INFO_UPDATE_LAST_ACCESS )) {

        Fcb->CurrentLastAccess = Fcb->Info.LastChangeTime;
    }

    SetFlag( Fcb->InfoFlags, ChangeFlags );

    return;
}


VOID
NtfsAddLink (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN CreatePrimaryLink,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN PFILE_NAME FileNameAttr,
    IN PBOOLEAN LogIt OPTIONAL,
    OUT PUCHAR FileNameFlags,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    IN PNAME_PAIR NamePair OPTIONAL,
    IN PINDEX_CONTEXT IndexContext OPTIONAL
    )

/*++

Routine Description:

    This routine adds a link to a file by adding the filename attribute
    for the filename to the file and inserting the name in the parent Scb
    index.  If we are creating the primary link for the file and need
    to generate an auxilary name, we will do that here. Use the optional
    NamePair to suggest auxilary names if provided.

Arguments:

    CreatePrimaryLink - Indicates if we are creating the main Ntfs name
        for the file.

    ParentScb - This is the Scb to add the index entry for this link to.

    Fcb - This is the file to add the hard link to.

    FileNameAttr - File name attribute which is guaranteed only to have the
        name in it.

    LogIt - Indicates whether we should log the creation of this name.  If not
        specified then we always log the name creation.  On exit we will
        update this to TRUE if we logged the name creation because it
        might cause a split.

    FileNameFlags - We return the file name flags we use to create the link.

    QuickIndex - If specified, supplies a pointer to a quik lookup structure
        to be updated by this routine.

    NamePair - If specified, supplies names that will be checked first as
        possible auxilary names

    IndexContext - Previous result of doing the lookup for the name in the index.

Return Value:

    None

--*/

{
    BOOLEAN LocalLogIt = TRUE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddLink:  Entered\n") );

    if (!ARGUMENT_PRESENT( LogIt )) {

        LogIt = &LocalLogIt;
    }

    *FileNameFlags = 0;

    //
    //  Next add this entry to parent.  It is possible that this is a link,
    //  an Ntfs name, a DOS name or Ntfs/Dos name.  We use the filename
    //  attribute structure from earlier, but need to add more information.
    //

    FileNameAttr->ParentDirectory = ParentScb->Fcb->FileReference;

    RtlCopyMemory( &FileNameAttr->Info,
                   &Fcb->Info,
                   sizeof( DUPLICATED_INFORMATION ));

    FileNameAttr->Flags = 0;

    //
    //  We will override the CreatePrimaryLink with the value in the
    //  registry.
    //

    NtfsAddNameToParent( IrpContext,
                         ParentScb,
                         Fcb,
                         (BOOLEAN) (FlagOn( NtfsData.Flags,
                                            NTFS_FLAGS_CREATE_8DOT3_NAMES ) &&
                                    CreatePrimaryLink),
                         LogIt,
                         FileNameAttr,
                         FileNameFlags,
                         QuickIndex,
                         NamePair,
                         IndexContext );

    //
    //  If the name is Ntfs only, we need to generate the DOS name.
    //

    if (*FileNameFlags == FILE_NAME_NTFS) {

        UNICODE_STRING NtfsName;

        NtfsName.Length = (USHORT)(FileNameAttr->FileNameLength * sizeof(WCHAR));
        NtfsName.Buffer = FileNameAttr->FileName;

        NtfsAddDosOnlyName( IrpContext,
                            ParentScb,
                            Fcb,
                            NtfsName,
                            *LogIt,
                            (NamePair ? &NamePair->Short : NULL) );
    }

    DebugTrace( -1, Dbg, ("NtfsAddLink:  Exit\n") );

    return;
}


VOID
NtfsRemoveLink (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB ParentScb,
    IN UNICODE_STRING LinkName,
    IN OUT PNAME_PAIR NamePair OPTIONAL,
    IN OUT PNTFS_TUNNELED_DATA TunneledData OPTIONAL
    )

/*++

Routine Description:

    This routine removes a hard link to a file by removing the filename attribute
    for the filename from the file and removing the name from the parent Scb
    index.  It will also remove the other half of a primary link pair.

    A name pair may be used to capture the names.

Arguments:

    Fcb - This is the file to remove the hard link from

    ParentScb - This is the Scb to remove the index entry for this link from

    LinkName - This is the file name to remove.  It will be exact case.

    NamePair - optional name pair for capture

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    ATTRIBUTE_ENUMERATION_CONTEXT OidAttrContext;
    PFILE_NAME FoundFileName;
    UCHAR FileNameFlags;
    UCHAR *ObjectId;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRemoveLink:  Entered\n") );

    NtfsInitializeAttributeContext( &AttrContext );
    NtfsInitializeAttributeContext( &OidAttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Now loop through the filenames and find a match.
        //  We better find at least one.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $FILE_NAME,
                                        &AttrContext )) {

            DebugTrace( 0, Dbg, ("Can't find filename attribute Fcb @ %08lx\n", Fcb) );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        //
        //  Now keep looking until we find a match.
        //

        while (TRUE) {

            FoundFileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

            //
            //  Do an exact memory comparison.
            //

            if ((*(PLONGLONG)&FoundFileName->ParentDirectory ==
                 *(PLONGLONG)&ParentScb->Fcb->FileReference ) &&

                ((FoundFileName->FileNameLength * sizeof( WCHAR )) == (ULONG)LinkName.Length) &&

                (RtlEqualMemory( LinkName.Buffer,
                                 FoundFileName->FileName,
                                 LinkName.Length ))) {

                break;
            }

            //
            //  Get the next filename attribute.
            //

            if (!NtfsLookupNextAttributeByCode( IrpContext,
                                                Fcb,
                                                $FILE_NAME,
                                                &AttrContext )) {

                DebugTrace( 0, Dbg, ("Can't find filename attribute Fcb @ %08lx\n", Fcb) );

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }
        }

        //
        //  Capture the name into caller's area
        //

        if (ARGUMENT_PRESENT(NamePair)) {

            NtfsCopyNameToNamePair( NamePair,
                                    FoundFileName->FileName,
                                    FoundFileName->FileNameLength,
                                    FoundFileName->Flags );
        }

        //
        //  It's important to do any object id operations now, before we
        //  acquire the Mft.  Otherwise we risk a deadlock.
        //

        if (ARGUMENT_PRESENT(TunneledData)) {

            //
            //  Find and store the object id, if any, for this file.
            //

            if (NtfsLookupAttributeByCode( IrpContext,
                                           Fcb,
                                           &Fcb->FileReference,
                                           $OBJECT_ID,
                                           &OidAttrContext )) {

                TunneledData->HasObjectId = TRUE;

                ObjectId = (UCHAR *) NtfsAttributeValue( NtfsFoundAttribute( &OidAttrContext ));

                RtlCopyMemory( TunneledData->ObjectIdBuffer.ObjectId,
                               ObjectId,
                               sizeof(TunneledData->ObjectIdBuffer.ObjectId) );

                NtfsGetObjectIdExtendedInfo( IrpContext,
                                             Fcb->Vcb,
                                             ObjectId,
                                             TunneledData->ObjectIdBuffer.ExtendedInfo );
            }
        }

        //
        //  Now delete the name from the parent Scb.
        //

        NtfsDeleteIndexEntry( IrpContext,
                              ParentScb,
                              FoundFileName,
                              &Fcb->FileReference );

        //
        //  Remember the filename flags for this entry.
        //

        FileNameFlags = FoundFileName->Flags;

        //
        //  Now delete the entry.  Log the operation, discard the file record
        //  if empty, and release any and all allocation.
        //

        NtfsDeleteAttributeRecord( IrpContext,
                                   Fcb,
                                   (DELETE_LOG_OPERATION |
                                    DELETE_RELEASE_FILE_RECORD |
                                    DELETE_RELEASE_ALLOCATION),
                                   &AttrContext );

        //
        //  If the link is a partial link, we need to remove the second
        //  half of the link.
        //

        if (FlagOn( FileNameFlags, (FILE_NAME_NTFS | FILE_NAME_DOS) )
            && (FileNameFlags != (FILE_NAME_NTFS | FILE_NAME_DOS))) {

            NtfsRemoveLinkViaFlags( IrpContext,
                                    Fcb,
                                    ParentScb,
                                    (UCHAR)(FlagOn( FileNameFlags, FILE_NAME_NTFS )
                                     ? FILE_NAME_DOS
                                     : FILE_NAME_NTFS),
                                    NamePair,
                                    NULL );
        }

    } finally {

        DebugUnwind( NtfsRemoveLink );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        NtfsCleanupAttributeContext( IrpContext, &OidAttrContext );

        DebugTrace( -1, Dbg, ("NtfsRemoveLink:  Exit\n") );
    }

    return;
}


VOID
NtfsRemoveLinkViaFlags (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN UCHAR FileNameFlags,
    IN OUT PNAME_PAIR NamePair OPTIONAL,
    OUT PUNICODE_STRING FileName OPTIONAL
    )

/*++

Routine Description:

    This routine is called to remove only a Dos name or only an Ntfs name.  We
    already must know that these will be described by separate filename attributes.

    A name pair may be used to capture the name.

Arguments:

    Fcb - This is the file to remove the hard link from

    ParentScb - This is the Scb to remove the index entry for this link from

    FileNameFlags - This is the single name flag that we must match exactly.

    NamePair - Optional name pair for capture

    FileName - Optional pointer to unicode string.  If specified we allocate a buffer and
        return the name deleted.

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PFILE_NAME FileNameAttr;

    PFILE_NAME FoundFileName;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRemoveLinkViaFlags:  Entered\n") );

    NtfsInitializeAttributeContext( &AttrContext );

    FileNameAttr = NULL;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Now loop through the filenames and find a match.
        //  We better find at least one.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $FILE_NAME,
                                        &AttrContext )) {

            DebugTrace( 0, Dbg, ("Can't find filename attribute Fcb @ %08lx\n", Fcb) );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        //
        //  Now keep looking until we find a match.
        //

        while (TRUE) {

            FoundFileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

            //
            //  Check for an exact flag match.
            //

            if ((*(PLONGLONG)&FoundFileName->ParentDirectory ==
                 *(PLONGLONG)&Scb->Fcb->FileReference) &&

                (FoundFileName->Flags == FileNameFlags)) {


                break;
            }

            //
            //  Get the next filename attribute.
            //

            if (!NtfsLookupNextAttributeByCode( IrpContext,
                                                Fcb,
                                                $FILE_NAME,
                                                &AttrContext )) {

                DebugTrace( 0, Dbg, ("Can't find filename attribute Fcb@ %08lx\n", Fcb) );

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }
        }

        //
        //  Capture the name into caller's area
        //

        if (ARGUMENT_PRESENT(NamePair)) {

            NtfsCopyNameToNamePair( NamePair,
                                    FoundFileName->FileName,
                                    FoundFileName->FileNameLength,
                                    FoundFileName->Flags );

        }

        FileNameAttr = NtfsAllocatePool( PagedPool,
                                         sizeof( FILE_NAME ) + (FoundFileName->FileNameLength << 1) );

        //
        //  We build the file name attribute for the search.
        //

        RtlCopyMemory( FileNameAttr,
                       FoundFileName,
                       NtfsFileNameSize( FoundFileName ));

        //
        //  Now delete the entry.
        //

        NtfsDeleteAttributeRecord( IrpContext,
                                   Fcb,
                                   (DELETE_LOG_OPERATION |
                                    DELETE_RELEASE_FILE_RECORD |
                                    DELETE_RELEASE_ALLOCATION),
                                   &AttrContext );

        //
        //  Now delete the name from the parent Scb.
        //

        NtfsDeleteIndexEntry( IrpContext,
                              Scb,
                              FileNameAttr,
                              &Fcb->FileReference );

    } finally {

        DebugUnwind( NtfsRemoveLinkViaFlags );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        if (FileNameAttr != NULL) {

            //
            //  If the user passed in a unicode string then make this look like the name
            //  and store the buffer into the input pointer.
            //

            if (ARGUMENT_PRESENT( FileName )) {

                ASSERT( FileName->Buffer == NULL );

                FileName->MaximumLength = FileName->Length = FileNameAttr->FileNameLength * sizeof( WCHAR );
                RtlMoveMemory( FileNameAttr,
                               FileNameAttr->FileName,
                               FileName->Length );

                FileName->Buffer = (PVOID) FileNameAttr;

            } else {

                NtfsFreePool( FileNameAttr );
            }
        }

        DebugTrace( -1, Dbg, ("NtfsRemoveLinkViaFlags:  Exit\n") );
    }

    return;
}


VOID
NtfsUpdateFileNameFlags (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB ParentScb,
    IN UCHAR FileNameFlags,
    IN PFILE_NAME FileNameLink
    )

/*++

Routine Description:

    This routine is called to perform the file name flag update on a name
    link.  Nothing else about the name is changing except for the flag
    changes.

Arguments:

    Fcb - This is the file to change the link flags on.

    ParentScb - This is the Scb which contains the link.

    FileNameFlags - This is the single name flag that we want to change to.

    FileNameLink - Pointer to a copy of the link to change.

Return Value:

    None

--*/

{
    PFILE_NAME FoundFileName;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN CleanupContext = FALSE;

    PAGED_CODE();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Look up the correct attribute in the file record.
        //

        NtfsInitializeAttributeContext( &AttrContext );
        CleanupContext = TRUE;

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $FILE_NAME,
                                        &AttrContext )) {

            DebugTrace( 0, Dbg, ("Can't find filename attribute Fcb @ %08lx\n", Fcb) );
            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        //
        //  Now keep looking till we find the one we want.
        //

        while (TRUE) {

            FoundFileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

            //
            //  If the names match exactly and the parent directories match then
            //  we have a match.
            //

            if (NtfsEqualMftRef( &FileNameLink->ParentDirectory,
                                 &FoundFileName->ParentDirectory ) &&
                (FileNameLink->FileNameLength == FoundFileName->FileNameLength) &&
                RtlEqualMemory( FileNameLink->FileName,
                                FoundFileName->FileName,
                                FileNameLink->FileNameLength * sizeof( WCHAR ))) {

                break;
            }

            //
            //  Get the next filename attribute.
            //

            if (!NtfsLookupNextAttributeByCode( IrpContext,
                                                Fcb,
                                                $FILE_NAME,
                                                &AttrContext )) {

                //
                //  This is bad.  We should have found a match.
                //

                DebugTrace( 0, Dbg, ("Can't find filename attribute Fcb @ %08lx\n", Fcb) );
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }
        }

        //
        //  Unfortunately we can't log the change to the file name flags only so we will have to remove
        //  and reinsert the index entry.
        //

        NtfsDeleteIndexEntry( IrpContext,
                              ParentScb,
                              FoundFileName,
                              &Fcb->FileReference );

        //
        //  Update just the flags field.
        //

        NtfsChangeAttributeValue( IrpContext,
                                  Fcb,
                                  FIELD_OFFSET( FILE_NAME, Flags ),
                                  &FileNameFlags,
                                  sizeof( UCHAR ),
                                  FALSE,
                                  TRUE,
                                  FALSE,
                                  TRUE,
                                  &AttrContext );

        //
        //  Now reinsert the name in the index.
        //

        NtfsAddIndexEntry( IrpContext,
                           ParentScb,
                           FoundFileName,
                           NtfsFileNameSize( FoundFileName ),
                           &Fcb->FileReference,
                           NULL,
                           NULL );

    } finally {

        DebugUnwind( NtfsUpdateFileNameFlags );

        if (CleanupContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }
    }

    return;
}


//
//  This routine is intended only for RESTART.
//

VOID
NtfsRestartInsertAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG RecordOffset,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN PVOID ValueOrMappingPairs OPTIONAL,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine performs a simple insert of an attribute record into a
    file record, without worrying about Bcbs or logging.

Arguments:

    FileRecord - File record into which the attribute is to be inserted.

    RecordOffset - ByteOffset within the file record at which insert is to occur.

    Attribute - The attribute record to be inserted.

    AttributeName - May pass an optional attribute name in the running system
                    only.

    ValueOrMappingPairs - May pass a value or mapping pairs pointer in the
                          running system only.

    Length - Length of the value or mapping pairs array in bytes - nonzero in
             the running system only.  If nonzero and the above pointer is NULL,
             then a value is to be zeroed.

Return Value:

    None

--*/

{
    PVOID From, To;
    ULONG MoveLength;
    ULONG AttributeHeaderSize;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT( IsQuadAligned( Attribute->RecordLength ) );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartInsertAttribute\n") );
    DebugTrace( 0, Dbg, ("FileRecord = %08lx\n", FileRecord) );
    DebugTrace( 0, Dbg, ("RecordOffset = %08lx\n", RecordOffset) );
    DebugTrace( 0, Dbg, ("Attribute = %08lx\n", Attribute) );

    //
    //  First make room for the attribute
    //

    From = (PCHAR)FileRecord + RecordOffset;
    To = (PCHAR)From + Attribute->RecordLength;
    MoveLength = FileRecord->FirstFreeByte - RecordOffset;

    RtlMoveMemory( To, From, MoveLength );

    //
    //  If there is either an attribute name or Length is nonzero, then
    //  we are in the running system, and we are to assemble the attribute
    //  in place.
    //

    if ((Length != 0) || ARGUMENT_PRESENT(AttributeName)) {

        //
        //  First move the attribute header in.
        //

        if (Attribute->FormCode == RESIDENT_FORM) {

            AttributeHeaderSize = SIZEOF_RESIDENT_ATTRIBUTE_HEADER;

        } else if (Attribute->NameOffset != 0) {

            AttributeHeaderSize = Attribute->NameOffset;

        } else {

            AttributeHeaderSize = Attribute->Form.Nonresident.MappingPairsOffset;
        }

        RtlCopyMemory( From,
                       Attribute,
                       AttributeHeaderSize );

        if (ARGUMENT_PRESENT(AttributeName)) {

            RtlCopyMemory( (PCHAR)From + Attribute->NameOffset,
                            AttributeName->Buffer,
                            AttributeName->Length );
        }

        //
        //  If a value was specified, move it in.  Else the caller just wants us
        //  to clear for that much.
        //

        if (ARGUMENT_PRESENT(ValueOrMappingPairs)) {

            RtlCopyMemory( (PCHAR)From +
                             ((Attribute->FormCode == RESIDENT_FORM) ?
                                Attribute->Form.Resident.ValueOffset :
                                Attribute->Form.Nonresident.MappingPairsOffset),
                           ValueOrMappingPairs,
                           Length );

        //
        //  Only the resident form will pass a NULL pointer.
        //

        } else {

            RtlZeroMemory( (PCHAR)From + Attribute->Form.Resident.ValueOffset,
                           Length );
        }

    //
    //  For the restart case, we really only have to insert the attribute.
    //  (Note we can also hit this case in the running system when a resident
    //  attribute is being created with no name and a null value.)
    //

    } else {

        //
        //  Now move the attribute in.
        //

        RtlCopyMemory( From, Attribute, Attribute->RecordLength );
    }

    //
    //  Update the file record.
    //

    FileRecord->FirstFreeByte += Attribute->RecordLength;

    //
    //  We only need to do this if we would be incrementing the instance
    //  number.  In the abort or restart case, we don't need to do this.
    //

    if (FileRecord->NextAttributeInstance <= Attribute->Instance) {

        FileRecord->NextAttributeInstance = Attribute->Instance + 1;
    }

    //
    //  Remember to increment the reference count if this attribute is indexed.
    //

    if (FlagOn(Attribute->Form.Resident.ResidentFlags, RESIDENT_FORM_INDEXED)) {
        FileRecord->ReferenceCount += 1;
    }

    DebugTrace( -1, Dbg, ("NtfsRestartInsertAttribute -> VOID\n") );

    return;
}


//
//  This routine is intended only for RESTART.
//

VOID
NtfsRestartRemoveAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG RecordOffset
    )

/*++

Routine Description:

    This routine performs a simple remove of an attribute record from a
    file record, without worrying about Bcbs or logging.

Arguments:

    FileRecord - File record from which the attribute is to be removed.

    RecordOffset - ByteOffset within the file record at which remove is to occur.

Return Value:

    None

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartRemoveAttribute\n") );
    DebugTrace( 0, Dbg, ("FileRecord = %08lx\n", FileRecord) );
    DebugTrace( 0, Dbg, ("RecordOffset = %08lx\n", RecordOffset) );

    //
    //  Calculate the address of the attribute we are removing.
    //

    Attribute = (PATTRIBUTE_RECORD_HEADER)((PCHAR)FileRecord + RecordOffset);
    ASSERT( IsQuadAligned( Attribute->RecordLength ) );

    //
    //  Reduce first free byte by the amount we removed.
    //

    FileRecord->FirstFreeByte -= Attribute->RecordLength;

    //
    //  Remember to decrement the reference count if this attribute is indexed.
    //

    if (FlagOn(Attribute->Form.Resident.ResidentFlags, RESIDENT_FORM_INDEXED)) {
        FileRecord->ReferenceCount -= 1;
    }

    //
    //  Remove the attribute by moving the rest of the record down.
    //

    RtlMoveMemory( Attribute,
                   (PCHAR)Attribute + Attribute->RecordLength,
                   FileRecord->FirstFreeByte - RecordOffset );

    DebugTrace( -1, Dbg, ("NtfsRestartRemoveAttribute -> VOID\n") );

    return;
}


//
//  This routine is intended only for RESTART.
//

VOID
NtfsRestartChangeAttributeSize (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN ULONG NewRecordLength
    )

/*++

Routine Description:

    This routine changes the size of an attribute, and makes the related
    changes in the attribute record.

Arguments:

    FileRecord - Pointer to the file record in which the attribute resides.

    Attribute - Pointer to the attribute whose size is changing.

    NewRecordLength - New attribute record length.

Return Value:

    None.

--*/

{
    LONG SizeChange = NewRecordLength - Attribute->RecordLength;
    PVOID AttributeEnd = Add2Ptr(Attribute, Attribute->RecordLength);

    UNREFERENCED_PARAMETER( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartChangeAttributeSize\n") );
    DebugTrace( 0, Dbg, ("FileRecord = %08lx\n", FileRecord) );
    DebugTrace( 0, Dbg, ("Attribute = %08lx\n", Attribute) );
    DebugTrace( 0, Dbg, ("NewRecordLength = %08lx\n", NewRecordLength) );

    //
    //  First move the end of the file record after the attribute we are changing.
    //

    RtlMoveMemory( Add2Ptr(Attribute, NewRecordLength),
                   AttributeEnd,
                   FileRecord->FirstFreeByte - PtrOffset(FileRecord, AttributeEnd) );

    //
    //  Now update the file and attribute records.
    //

    FileRecord->FirstFreeByte += SizeChange;
    Attribute->RecordLength = NewRecordLength;

    DebugTrace( -1, Dbg, ("NtfsRestartChangeAttributeSize -> VOID\n") );
}


//
//  This routine is intended only for RESTART.
//

VOID
NtfsRestartChangeValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG RecordOffset,
    IN ULONG AttributeOffset,
    IN PVOID Data,
    IN ULONG Length,
    IN BOOLEAN SetNewLength
    )

/*++

Routine Description:

    This routine performs a simple change of an attribute value in a
    file record, without worrying about Bcbs or logging.

Arguments:

    FileRecord - File record in which the attribute is to be changed.

    RecordOffset - ByteOffset within the file record at which the attribute starts.

    AttributeOffset - Offset within the attribute record at which data is to
                   be changed.

    Data - Pointer to the new data.

    Length - Length of the new data.

    SetNewLength - TRUE if the attribute length should be changed.

Return Value:

    None

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    BOOLEAN AlreadyMoved = FALSE;
    BOOLEAN DataInFileRecord = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartChangeValue\n") );
    DebugTrace( 0, Dbg, ("FileRecord = %08lx\n", FileRecord) );
    DebugTrace( 0, Dbg, ("RecordOffset = %08lx\n", RecordOffset) );
    DebugTrace( 0, Dbg, ("AttributeOffset = %08lx\n", AttributeOffset) );
    DebugTrace( 0, Dbg, ("Data = %08lx\n", Data) );
    DebugTrace( 0, Dbg, ("Length = %08lx\n", Length) );
    DebugTrace( 0, Dbg, ("SetNewLength = %02lx\n", SetNewLength) );

    //
    //  Calculate the address of the attribute being changed.
    //

    Attribute = (PATTRIBUTE_RECORD_HEADER)((PCHAR)FileRecord + RecordOffset);
    ASSERT( IsQuadAligned( Attribute->RecordLength ) );
    ASSERT( IsQuadAligned( RecordOffset ) );

    //
    //  First, if we are setting a new length, then move the data after the
    //  attribute record and change FirstFreeByte accordingly.
    //

    if (SetNewLength) {

        ULONG NewLength = QuadAlign( AttributeOffset + Length );

        //
        //  If we are shrinking the attribute, we need to move the data
        //  first to support caller's who are shifting data down in the
        //  attribute value, like DeleteFromAttributeList.  If we were
        //  to shrink the record first in this case, we would clobber some
        //  of the data to be moved down.
        //

        if (NewLength < Attribute->RecordLength) {

            //
            //  Now move the new data in and remember we moved it.
            //

            AlreadyMoved = TRUE;

            //
            //  If there is data to modify do so now.
            //

            if (Length != 0) {

                if (ARGUMENT_PRESENT(Data)) {

                    RtlMoveMemory( (PCHAR)Attribute + AttributeOffset, Data, Length );

                } else {

                    RtlZeroMemory( (PCHAR)Attribute + AttributeOffset, Length );
                }
            }
        }

        //
        //  First move the tail of the file record to make/eliminate room.
        //

        RtlMoveMemory( Add2Ptr( Attribute, NewLength ),
                       Add2Ptr( Attribute, Attribute->RecordLength ),
                       FileRecord->FirstFreeByte - RecordOffset - Attribute->RecordLength );

        //
        //  Now update fields to reflect the change.
        //

        FileRecord->FirstFreeByte += (NewLength - Attribute->RecordLength);

        Attribute->RecordLength = NewLength;
        Attribute->Form.Resident.ValueLength =
          (USHORT)(AttributeOffset + Length -
                   (ULONG)Attribute->Form.Resident.ValueOffset);
    }

    //
    //  Now move the new data in.
    //

    if (!AlreadyMoved) {

        if (ARGUMENT_PRESENT(Data)) {

            RtlMoveMemory( Add2Ptr( Attribute, AttributeOffset ),
                           Data,
                           Length );

        } else {

            RtlZeroMemory( Add2Ptr( Attribute, AttributeOffset ),
                           Length );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsRestartChangeValue -> VOID\n") );

    return;
}


//
//  This routine is intended only for RESTART.
//

VOID
NtfsRestartChangeMapping (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG RecordOffset,
    IN ULONG AttributeOffset,
    IN PVOID Data,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine performs a simple change of an attribute's mapping pairs in a
    file record, without worrying about Bcbs or logging.

Arguments:

    Vcb - Vcb for volume

    FileRecord - File record in which the attribute is to be changed.

    RecordOffset - ByteOffset within the file record at which the attribute starts.

    AttributeOffset - Offset within the attribute record at which mapping is to
                   be changed.

    Data - Pointer to the new mapping.

    Length - Length of the new mapping.

Return Value:

    None

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    VCN HighestVcn;
    PCHAR MappingPairs;
    ULONG NewLength = QuadAlign( AttributeOffset + Length );

    ASSERT_IRP_CONTEXT( IrpContext );

    UNREFERENCED_PARAMETER( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartChangeMapping\n") );
    DebugTrace( 0, Dbg, ("FileRecord = %08lx\n", FileRecord) );
    DebugTrace( 0, Dbg, ("RecordOffset = %08lx\n", RecordOffset) );
    DebugTrace( 0, Dbg, ("AttributeOffset = %08lx\n", AttributeOffset) );
    DebugTrace( 0, Dbg, ("Data = %08lx\n", Data) );
    DebugTrace( 0, Dbg, ("Length = %08lx\n", Length) );

    //
    //  Calculate the address of the attribute being changed.
    //

    Attribute = (PATTRIBUTE_RECORD_HEADER)((PCHAR)FileRecord + RecordOffset);
    ASSERT( IsQuadAligned( Attribute->RecordLength ) );
    ASSERT( IsQuadAligned( RecordOffset ) );

    //
    //  First, if we are setting a new length, then move the data after the
    //  attribute record and change FirstFreeByte accordingly.
    //

    //
    //  First move the tail of the file record to make/eliminate room.
    //

    RtlMoveMemory( (PCHAR)Attribute + NewLength,
                   (PCHAR)Attribute + Attribute->RecordLength,
                   FileRecord->FirstFreeByte - RecordOffset -
                     Attribute->RecordLength );

    //
    //  Now update fields to reflect the change.
    //

    FileRecord->FirstFreeByte += NewLength -
                                   Attribute->RecordLength;

    Attribute->RecordLength = NewLength;

    //
    //  Now move the new data in.
    //

    RtlCopyMemory( (PCHAR)Attribute + AttributeOffset, Data, Length );


    //
    //  Finally update HighestVcn and (optionally) AllocatedLength fields.
    //

    MappingPairs = (PCHAR)Attribute + (ULONG)Attribute->Form.Nonresident.MappingPairsOffset;
    HighestVcn = NtfsGetHighestVcn( IrpContext,
                                    Attribute->Form.Nonresident.LowestVcn,
                                    MappingPairs );

    ASSERT( IsCharZero( *MappingPairs ) || HighestVcn != -1 );

    Attribute->Form.Nonresident.HighestVcn = HighestVcn;

    DebugTrace( -1, Dbg, ("NtfsRestartChangeMapping -> VOID\n") );

    return;
}


VOID
NtfsAddToAttributeList (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN MFT_SEGMENT_REFERENCE SegmentReference,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine adds an attribute list entry for a newly inserted attribute.
    It is assumed that the context variable is pointing to the attribute
    record in the file record where it has been inserted, and also to the place
    in the attribute list where the new attribute list entry is to be inserted.

Arguments:

    Fcb - Requested file.

    SegmentReference - Segment reference of the file record the new attribute
                       is in.

    Context - Describes the current attribute.

Return Value:

    None

--*/

{
    //
    //  Allocate an attribute list entry which hopefully has enough space
    //  for the name.
    //

    struct {

        ATTRIBUTE_LIST_ENTRY EntryBuffer;

        WCHAR Name[10];

    } NewEntry;

    ATTRIBUTE_ENUMERATION_CONTEXT ListContext;

    ULONG EntrySize;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PATTRIBUTE_LIST_ENTRY ListEntry = &NewEntry.EntryBuffer;
    BOOLEAN SetNewLength = TRUE;

    ULONG EntryOffset;
    ULONG BeyondEntryOffset;

    PAGED_CODE();

    //
    //  First construct the attribute list entry.
    //

    FileRecord = NtfsContainingFileRecord( Context );
    Attribute = NtfsFoundAttribute( Context );
    EntrySize = QuadAlign( FIELD_OFFSET( ATTRIBUTE_LIST_ENTRY, AttributeName )
                           + ((ULONG) Attribute->NameLength << 1));

    //
    //  Allocate the list entry if the one we have is not big enough.
    //

    if (EntrySize > sizeof(NewEntry)) {

        ListEntry = (PATTRIBUTE_LIST_ENTRY)NtfsAllocatePool( NonPagedPool,
                                                              EntrySize );
    }

    RtlZeroMemory( ListEntry, EntrySize );

    NtfsInitializeAttributeContext( &ListContext );

    //
    //  Use try-finally to insure cleanup.
    //

    try {

        ULONG OldQuadAttrListSize;
        PATTRIBUTE_RECORD_HEADER ListAttribute;
        PFILE_RECORD_SEGMENT_HEADER ListFileRecord;

        //
        //  Now fill in the list entry.
        //

        ListEntry->AttributeTypeCode = Attribute->TypeCode;
        ListEntry->RecordLength = (USHORT)EntrySize;
        ListEntry->AttributeNameLength = Attribute->NameLength;
        ListEntry->Instance = Attribute->Instance;
        ListEntry->AttributeNameOffset =
          (UCHAR)PtrOffset( ListEntry, &ListEntry->AttributeName[0] );

        if (Attribute->FormCode == NONRESIDENT_FORM) {

            ListEntry->LowestVcn = Attribute->Form.Nonresident.LowestVcn;
        }

        ASSERT( (Fcb != Fcb->Vcb->MftScb->Fcb) ||
                (Attribute->TypeCode != $DATA) ||
                ((ULONGLONG)(ListEntry->LowestVcn) > (NtfsFullSegmentNumber( &SegmentReference ) >> Fcb->Vcb->MftToClusterShift)) );

        ListEntry->SegmentReference = SegmentReference;

        if (Attribute->NameLength != 0) {

            RtlCopyMemory( &ListEntry->AttributeName[0],
                           Add2Ptr(Attribute, Attribute->NameOffset),
                           Attribute->NameLength << 1 );
        }

        //
        //  Lookup the list context so that we can modify the attribute list.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $ATTRIBUTE_LIST,
                                        &ListContext )) {

            ASSERT( FALSE );
            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        ListAttribute = NtfsFoundAttribute( &ListContext );
        ListFileRecord = NtfsContainingFileRecord( &ListContext );

        OldQuadAttrListSize = ListAttribute->RecordLength;

        //
        //  Remember the relative offsets of list entries.
        //

        EntryOffset = (ULONG) PtrOffset( Context->AttributeList.FirstEntry,
                                         Context->AttributeList.Entry );

        BeyondEntryOffset = (ULONG) PtrOffset( Context->AttributeList.FirstEntry,
                                               Context->AttributeList.BeyondFinalEntry );

        //
        //  If this operation is possibly going to make the attribute list go
        //  non-resident, or else move other attributes around, then we will
        //  reserve the space first in the attribute list and then map the
        //  value.  Note that some of the entries we need to shift up may
        //  be modified as a side effect of making space!
        //

        if (NtfsIsAttributeResident( ListAttribute ) &&
            (ListFileRecord->BytesAvailable - ListFileRecord->FirstFreeByte) < EntrySize) {

            ULONG Length;

            //
            //  Add enough zeros to the end of the attribute to accommodate
            //  the new attribute list entry.
            //

            NtfsChangeAttributeValue( IrpContext,
                                      Fcb,
                                      BeyondEntryOffset,
                                      NULL,
                                      EntrySize,
                                      TRUE,
                                      TRUE,
                                      FALSE,
                                      TRUE,
                                      &ListContext );

            //
            //  We now don't have to set the new length.
            //

            SetNewLength = FALSE;

            //
            //  In case the attribute list went non-resident on this call, then we
            //  need to update both list entry pointers in the found attribute.
            //  (We do this "just in case" all the time to avoid a rare code path.)
            //

            //
            //  Map the non-resident attribute list.
            //

            NtfsMapAttributeValue( IrpContext,
                                   Fcb,
                                   (PVOID *) &Context->AttributeList.FirstEntry,
                                   &Length,
                                   &Context->AttributeList.NonresidentListBcb,
                                   &ListContext );

            //
            //  If the list is still resident then unpin the current Bcb in
            //  the original context to keep our pin counts in sync.
            //

            if (Context->AttributeList.Bcb == Context->AttributeList.NonresidentListBcb) {

                NtfsUnpinBcb( IrpContext, &Context->AttributeList.NonresidentListBcb );
            }

            Context->AttributeList.Entry = Add2Ptr( Context->AttributeList.FirstEntry,
                                                    EntryOffset );

            Context->AttributeList.BeyondFinalEntry = Add2Ptr( Context->AttributeList.FirstEntry,
                                                               BeyondEntryOffset );
        }

        //
        //  Check for adding duplicate entries...
        //

        ASSERT(
                //  Not enough room for previous entry to = inserted entry
                ((EntryOffset < EntrySize) ||
                //  Previous entry doesn't equal inserted entry
                 (!RtlEqualMemory((PVOID)((PCHAR)Context->AttributeList.Entry - EntrySize),
                                  ListEntry,
                                  EntrySize)))

                    &&

                //  At end of attribute list
                ((BeyondEntryOffset == EntryOffset) ||
                //  This entry doesn't equal inserted entry
                 (!RtlEqualMemory(Context->AttributeList.Entry,
                                  ListEntry,
                                  EntrySize))) );

        //
        //  Now shift the old contents up to make room for our new entry.  We don't let
        //  the attribute list grow larger than a cache view however.
        //

        if (EntrySize + BeyondEntryOffset > VACB_MAPPING_GRANULARITY) {

            NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
        }

        NtfsChangeAttributeValue( IrpContext,
                                  Fcb,
                                  EntryOffset + EntrySize,
                                  Context->AttributeList.Entry,
                                  BeyondEntryOffset - EntryOffset,
                                  SetNewLength,
                                  TRUE,
                                  FALSE,
                                  TRUE,
                                  &ListContext );
        //
        //  Now write in the new entry.
        //

        NtfsChangeAttributeValue( IrpContext,
                                  Fcb,
                                  EntryOffset,
                                  (PVOID)ListEntry,
                                  EntrySize,
                                  FALSE,
                                  TRUE,
                                  FALSE,
                                  FALSE,
                                  &ListContext );

        //
        //  Reload the attribute list values from the list context.
        //

        ListAttribute = NtfsFoundAttribute( &ListContext );

        //
        //  Now fix up the context for return
        //

        if (*(PLONGLONG)&FileRecord->BaseFileRecordSegment == 0) {

            //
            //  We need to update the attribute pointer for the target attribute
            //  by the amount of the change in the attribute list attribute.
            //

            Context->FoundAttribute.Attribute =
              Add2Ptr( Context->FoundAttribute.Attribute,
                       ListAttribute->RecordLength - OldQuadAttrListSize );
        }

        Context->AttributeList.BeyondFinalEntry =
          Add2Ptr( Context->AttributeList.BeyondFinalEntry, EntrySize );

#if DBG
{
    PATTRIBUTE_LIST_ENTRY LastEntry, Entry;

    for (LastEntry = Context->AttributeList.FirstEntry, Entry = NtfsGetNextRecord(LastEntry);
         Entry < Context->AttributeList.BeyondFinalEntry;
         LastEntry = Entry, Entry = NtfsGetNextRecord(LastEntry)) {

        ASSERT( (LastEntry->RecordLength != Entry->RecordLength) ||
                (!RtlEqualMemory(LastEntry, Entry, Entry->RecordLength)) );
    }
}
#endif

    } finally {

        //
        //  If we had to allocate a list entry buffer, deallocate it.
        //

        if (ListEntry != &NewEntry.EntryBuffer) {

            NtfsFreePool(ListEntry);
        }

        //
        //  Cleanup the enumeration context for the list entry.
        //

        NtfsCleanupAttributeContext( IrpContext, &ListContext);
    }
}


VOID
NtfsDeleteFromAttributeList (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine deletes an attribute list entry for a recently deleted attribute.
    It is assumed that the context variable is pointing to the place in
    the attribute list where the attribute list entry is to be deleted.

Arguments:

    Fcb - Requested file.

    Context - Describes the current attribute.

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT ListContext;

    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PATTRIBUTE_LIST_ENTRY ListEntry, NextListEntry;
    ULONG EntrySize;

    ULONG SavedListSize;

    PAGED_CODE();

    FileRecord = NtfsContainingFileRecord( Context );

    //
    //  Lookup the list context so that we can modify the attribute list.
    //

    NtfsInitializeAttributeContext( &ListContext );

    if (!NtfsLookupAttributeByCode( IrpContext,
                                    Fcb,
                                    &Fcb->FileReference,
                                    $ATTRIBUTE_LIST,
                                    &ListContext )) {

        ASSERT( FALSE );
        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
    }

    //
    //  Use try-finally to insure cleanup.
    //

    try {

        SavedListSize = NtfsFoundAttribute(&ListContext)->RecordLength;

        //
        //  Now shift the old contents down to make room for our new entry.
        //

        ListEntry = Context->AttributeList.Entry;
        EntrySize = ListEntry->RecordLength;
        NextListEntry = Add2Ptr(ListEntry, EntrySize);
        NtfsChangeAttributeValue( IrpContext,
                                  Fcb,
                                  PtrOffset( Context->AttributeList.FirstEntry,
                                             Context->AttributeList.Entry ),
                                  NextListEntry,
                                  PtrOffset( NextListEntry,
                                             Context->AttributeList.BeyondFinalEntry ),
                                  TRUE,
                                  TRUE,
                                  FALSE,
                                  TRUE,
                                  &ListContext );

        //
        //  Now fix up the context for return
        //

        if (*(PLONGLONG)&FileRecord->BaseFileRecordSegment == 0) {

            SavedListSize -= NtfsFoundAttribute(&ListContext)->RecordLength;
            Context->FoundAttribute.Attribute =
              Add2Ptr( Context->FoundAttribute.Attribute, -(LONG)SavedListSize );
        }

        Context->AttributeList.BeyondFinalEntry =
          Add2Ptr( Context->AttributeList.BeyondFinalEntry, -(LONG)EntrySize );

    } finally {

        //
        //  Cleanup the enumeration context for the list entry.
        //

        NtfsCleanupAttributeContext( IrpContext, &ListContext );
    }
}


BOOLEAN
NtfsRewriteMftMapping (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to rewrite the mapping for the Mft file.  This is done
    in the case where either hot-fixing or Mft defragging has caused us to spill
    into the reserved area of a file record.  This routine will rewrite the
    mapping from the beginning, using the reserved record if necessary.  On return
    it will indicate whether any work was done and if there is more work to do.

Arguments:

    Vcb - This is the Vcb for the volume to defrag.

    ExcessMapping - Address to store whether there is still excess mapping in
        the file.

Return Value:

    BOOLEAN - TRUE if we made any changes to the file.  FALSE if we found no
        work to do.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PUCHAR MappingPairs = NULL;
    PBCB FileRecordBcb = NULL;

    BOOLEAN MadeChanges = FALSE;
    BOOLEAN ExcessMapping = FALSE;
    BOOLEAN LastFileRecord = FALSE;
    BOOLEAN SkipLookup = FALSE;

    PAGED_CODE();

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        VCN CurrentVcn;             //  Starting Vcn for the next file record
        VCN MinimumVcn;             //  This Vcn must be in the current mapping
        VCN LastVcn;                //  Last Vcn in the current mapping
        VCN LastMftVcn;             //  Last Vcn in the file
        VCN NextVcn;                //  First Vcn past the end of the mapping

        ULONG ReservedIndex;        //  Reserved index in Mft
        ULONG NextIndex;            //  Next file record available for Mft mapping

        PFILE_RECORD_SEGMENT_HEADER FileRecord;
        MFT_SEGMENT_REFERENCE FileRecordReference;
        ULONG RecordOffset;

        PATTRIBUTE_RECORD_HEADER Attribute;
        ULONG AttributeOffset;

        ULONG MappingSizeAvailable;
        ULONG MappingPairsSize;

        //
        //  Find the initial file record for the Mft.
        //

        NtfsLookupAttributeForScb( IrpContext, Vcb->MftScb, NULL, &AttrContext );

        //
        //  Compute some initial values.  If this is the only file record
        //  for the file then we are done.
        //

        ReservedIndex = Vcb->MftScb->ScbType.Mft.ReservedIndex;

        Attribute = NtfsFoundAttribute( &AttrContext );

        LastMftVcn = Int64ShraMod32(Vcb->MftScb->Header.AllocationSize.QuadPart, Vcb->ClusterShift) - 1;

        CurrentVcn = Attribute->Form.Nonresident.HighestVcn + 1;

        if (CurrentVcn >= LastMftVcn) {

            try_return( NOTHING );
        }

        //
        //  Loop while there are more file records.  We will insert any
        //  additional file records needed within the loop so that this
        //  call should succeed until the remapping is done.
        //

        while (SkipLookup ||
               NtfsLookupNextAttributeForScb( IrpContext,
                                              Vcb->MftScb,
                                              &AttrContext )) {

            BOOLEAN ReplaceFileRecord;
            BOOLEAN ReplaceAttributeListEntry;

            ReplaceAttributeListEntry = FALSE;

            //
            //  If we just looked up this entry then pin the current
            //  attribute.
            //

            if (!SkipLookup) {

                //
                //  Always pin the current attribute.
                //

                NtfsPinMappedAttribute( IrpContext,
                                        Vcb,
                                        &AttrContext );
            }

            //
            //  Extract some pointers from the current file record.
            //  Remember if this was the last record.
            //

            ReplaceFileRecord = FALSE;

            FileRecord = NtfsContainingFileRecord( &AttrContext );
            FileRecordReference = AttrContext.AttributeList.Entry->SegmentReference;

            Attribute = NtfsFoundAttribute( &AttrContext );
            AttributeOffset = Attribute->Form.Nonresident.MappingPairsOffset;

            RecordOffset = PtrOffset( FileRecord, Attribute );

            //
            //  Remember if we are at the last attribute.
            //

            if (Attribute->Form.Nonresident.HighestVcn == LastMftVcn) {

                LastFileRecord = TRUE;
            }

            //
            //  If we have already remapped this entire file record then
            //  remove the attribute and it list entry.
            //

            if (!SkipLookup &&
                (CurrentVcn > LastMftVcn)) {

                PATTRIBUTE_LIST_ENTRY ListEntry;
                ULONG Count;

                Count = 0;

                //
                //  We want to remove this entry and all subsequent entries.
                //

                ListEntry = AttrContext.AttributeList.Entry;

                while ((ListEntry != AttrContext.AttributeList.BeyondFinalEntry) &&
                       (ListEntry->AttributeTypeCode == $DATA) &&
                       (ListEntry->AttributeNameLength == 0)) {

                    Count += 1;

                    NtfsDeallocateMftRecord( IrpContext,
                                             Vcb,
                                             NtfsUnsafeSegmentNumber( &ListEntry->SegmentReference ) );

                    NtfsDeleteFromAttributeList( IrpContext,
                                                 Vcb->MftScb->Fcb,
                                                 &AttrContext );

                    ListEntry = AttrContext.AttributeList.Entry;
                }

                //
                //  Clear out the reserved index in case one of these
                //  will do.
                //

                NtfsAcquireCheckpoint( IrpContext, Vcb );

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MFT_REC_RESERVED );
                ClearFlag( Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED );

                NtfsReleaseCheckpoint( IrpContext, Vcb );

                Vcb->MftScb->ScbType.Mft.ReservedIndex = 0;
                try_return( NOTHING );
            }

            //
            //  Check if we are going to replace this file record with
            //  the reserved record.
            //

            if (ReservedIndex < NtfsSegmentNumber( &FileRecordReference )) {

                PATTRIBUTE_RECORD_HEADER NewAttribute;
                PATTRIBUTE_TYPE_CODE NewEnd;

                //
                //  Remember this index for our computation for the Minimum mapped
                //  Vcn.
                //

                NextIndex = NtfsUnsafeSegmentNumber( &FileRecordReference );

                FileRecord = NtfsCloneFileRecord( IrpContext,
                                                  Vcb->MftScb->Fcb,
                                                  TRUE,
                                                  &FileRecordBcb,
                                                  &FileRecordReference );

                ReservedIndex = MAXULONG;

                //
                //  Now lets create an attribute in the new file record.
                //

                NewAttribute = Add2Ptr( FileRecord,
                                        FileRecord->FirstFreeByte
                                        - QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE )));

                NewAttribute->TypeCode = Attribute->TypeCode;
                NewAttribute->RecordLength = SIZEOF_PARTIAL_NONRES_ATTR_HEADER;
                NewAttribute->FormCode = NONRESIDENT_FORM;
                NewAttribute->Flags = Attribute->Flags;
                NewAttribute->Instance = FileRecord->NextAttributeInstance++;

                NewAttribute->Form.Nonresident.LowestVcn = CurrentVcn;
                NewAttribute->Form.Nonresident.HighestVcn = 0;
                NewAttribute->Form.Nonresident.MappingPairsOffset = (USHORT) NewAttribute->RecordLength;

                NewEnd = Add2Ptr( NewAttribute, NewAttribute->RecordLength );
                *NewEnd = $END;

                //
                //  Now fix up the file record with this new data.
                //

                FileRecord->FirstFreeByte = PtrOffset( FileRecord, NewEnd )
                                            + QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE ));

                FileRecord->SequenceNumber += 1;

                if (FileRecord->SequenceNumber == 0) {

                    FileRecord->SequenceNumber = 1;
                }

                FileRecordReference.SequenceNumber = FileRecord->SequenceNumber;

                //
                //  Now switch this new file record into the attribute context.
                //

                NtfsUnpinBcb( IrpContext, &NtfsFoundBcb( &AttrContext ));

                NtfsFoundBcb( &AttrContext ) = FileRecordBcb;
                AttrContext.FoundAttribute.MftFileOffset = LlBytesFromFileRecords( Vcb, NextIndex );
                AttrContext.FoundAttribute.Attribute = NewAttribute;
                AttrContext.FoundAttribute.FileRecord = FileRecord;

                FileRecordBcb = NULL;

                //
                //  Now add an attribute list entry for this entry.
                //

                NtfsAddToAttributeList( IrpContext,
                                        Vcb->MftScb->Fcb,
                                        FileRecordReference,
                                        &AttrContext );

                //
                //  Reload our pointers for this file record.
                //

                Attribute = NewAttribute;
                AttributeOffset = SIZEOF_PARTIAL_NONRES_ATTR_HEADER;

                RecordOffset = PtrOffset( FileRecord, Attribute );

                //
                //  We must include either the last Vcn of the file or
                //  the Vcn for the next file record to use for the Mft.
                //  At this point MinimumVcn is the first Vcn that doesn't
                //  have to be in the current mapping.
                //

                if (Vcb->FileRecordsPerCluster == 0) {

                    MinimumVcn = (NextIndex + 1) << Vcb->MftToClusterShift;

                } else {

                    MinimumVcn = (NextIndex + Vcb->FileRecordsPerCluster - 1) << Vcb->MftToClusterShift;
                }

                ReplaceFileRecord = TRUE;

            //
            //  We will be using the current attribute.
            //

            } else {

                //
                //  The mapping we write into this page must go
                //  to the current end of the page or to the reserved
                //  or spare file record, whichever is earlier.
                //  If we are adding the reserved record to the end then
                //  we know the final Vcn already.
                //

                if (SkipLookup) {

                    NextVcn = LastMftVcn;

                } else {

                    NextVcn = Attribute->Form.Nonresident.HighestVcn;
                }

                if (Vcb->FileRecordsPerCluster == 0) {

                    NextIndex = (ULONG)Int64ShraMod32((NextVcn + 1), Vcb->MftToClusterShift);

                } else {

                    NextIndex = (ULONG)Int64ShllMod32((NextVcn + 1), Vcb->MftToClusterShift);
                }

                if (ReservedIndex < NextIndex) {

                    NextIndex = ReservedIndex + 1;
                    ReplaceFileRecord = TRUE;
                }

                //
                //  If we can use this file record unchanged then continue on.
                //  Start by checking that it starts on the same Vcn boundary.
                //

                if (!SkipLookup) {

                    //
                    //  If it starts on the same boundary then we check if we
                    //  can do any work with this.
                    //

                    if (CurrentVcn == Attribute->Form.Nonresident.LowestVcn) {

                        ULONG RemainingFileRecordBytes;

                        RemainingFileRecordBytes = FileRecord->BytesAvailable - FileRecord->FirstFreeByte;

                        //
                        //  Check if we have less than the desired cushion
                        //  left.
                        //

                        if (RemainingFileRecordBytes < Vcb->MftCushion) {

                            //
                            //  If we have no more file records there is no
                            //  remapping we can do.
                            //

                            if (!ReplaceFileRecord) {

                                //
                                //  Remember if we used part of the reserved
                                //  portion of the file record.
                                //

                                if (RemainingFileRecordBytes < Vcb->MftReserved) {

                                    ExcessMapping = TRUE;
                                }

                                CurrentVcn = Attribute->Form.Nonresident.HighestVcn + 1;
                                continue;
                            }
                        //
                        //  We have more than our cushion left.  If this
                        //  is the last file record we will skip this.
                        //

                        } else if (Attribute->Form.Nonresident.HighestVcn == LastMftVcn) {

                            CurrentVcn = Attribute->Form.Nonresident.HighestVcn + 1;
                            continue;
                        }

                    //
                    //  If it doesn't start on the same boundary then we have to
                    //  delete and reinsert the attribute list entry.
                    //

                    } else {

                        ReplaceAttributeListEntry = TRUE;
                    }
                }

                ReplaceFileRecord = FALSE;

                //
                //  Log the beginning state of this file record.
                //

                NtfsLogMftFileRecord( IrpContext,
                                      Vcb,
                                      FileRecord,
                                      LlBytesFromFileRecords( Vcb, NtfsSegmentNumber( &FileRecordReference ) ),
                                      NtfsFoundBcb( &AttrContext ),
                                      FALSE );

                //
                //  Compute the Vcn for the file record past the one we will use
                //  next.  At this point this is the first Vcn that doesn't have
                //  to be in the current mapping.
                //

                if (Vcb->FileRecordsPerCluster == 0) {

                    MinimumVcn = NextIndex << Vcb->MftToClusterShift;

                } else {

                    MinimumVcn = (NextIndex + Vcb->FileRecordsPerCluster - 1) << Vcb->MftToClusterShift;
                }
            }

            //
            //  Move back one vcn to adhere to the mapping pairs interface.
            //  This is now the last Vcn which MUST appear in the current
            //  mapping.
            //

            MinimumVcn = MinimumVcn - 1;

            //
            //  Get the available size for the mapping pairs.  We won't
            //  include the cushion here.
            //

            MappingSizeAvailable = FileRecord->BytesAvailable + Attribute->RecordLength - FileRecord->FirstFreeByte - SIZEOF_PARTIAL_NONRES_ATTR_HEADER;

            //
            //  We know the range of Vcn's the mapping must cover.
            //  Compute the mapping pair size.  If they won't fit and
            //  leave our desired cushion then use whatever space is
            //  needed.  The NextVcn value is the first Vcn (or xxMax)
            //  for the run after the last run in the current mapping.
            //

            MappingPairsSize = NtfsGetSizeForMappingPairs( &Vcb->MftScb->Mcb,
                                                           MappingSizeAvailable - Vcb->MftCushion,
                                                           CurrentVcn,
                                                           NULL,
                                                           &NextVcn );

            //
            //  If this mapping doesn't include the file record we will
            //  be using next then extend the mapping to include it.
            //

            if (NextVcn <= MinimumVcn) {

                //
                //  Compute the mapping pairs again.  This must fit
                //  since it already fits.
                //

                MappingPairsSize = NtfsGetSizeForMappingPairs( &Vcb->MftScb->Mcb,
                                                               MappingSizeAvailable,
                                                               CurrentVcn,
                                                               &MinimumVcn,
                                                               &NextVcn );

                //
                //  Remember if we still have excess mapping.
                //

                if (MappingSizeAvailable - MappingPairsSize < Vcb->MftReserved) {

                    ExcessMapping = TRUE;
                }
            }

            //
            //  Remember the last Vcn for the current run.  If the NextVcn
            //  is xxMax then we are at the end of the file.
            //

            if (NextVcn == MAXLONGLONG) {

                LastVcn = LastMftVcn;

            //
            //  Otherwise it is one less than the next vcn value.
            //

            } else {

                LastVcn = NextVcn - 1;
            }

            //
            //  Check if we have to rewrite this attribute.  We will write the
            //  new mapping if any of the following are true.
            //
            //      We are replacing a file record
            //      The attribute's LowestVcn doesn't match
            //      The attributes's HighestVcn doesn't match.
            //

            if (ReplaceFileRecord ||
                (CurrentVcn != Attribute->Form.Nonresident.LowestVcn) ||
                (LastVcn != Attribute->Form.Nonresident.HighestVcn )) {

                Attribute->Form.Nonresident.LowestVcn = CurrentVcn;

                //
                //  Replace the attribute list entry at this point if needed.
                //

                if (ReplaceAttributeListEntry) {

                    NtfsDeleteFromAttributeList( IrpContext,
                                                 Vcb->MftScb->Fcb,
                                                 &AttrContext );

                    NtfsAddToAttributeList( IrpContext,
                                            Vcb->MftScb->Fcb,
                                            FileRecordReference,
                                            &AttrContext );
                }

                //
                //  Allocate a buffer for the mapping pairs if we haven't
                //  done so.
                //

                if (MappingPairs == NULL) {

                    MappingPairs = NtfsAllocatePool(PagedPool, NtfsMaximumAttributeSize( Vcb->BytesPerFileRecordSegment ));
                }

                NtfsBuildMappingPairs( &Vcb->MftScb->Mcb,
                                       CurrentVcn,
                                       &NextVcn,
                                       MappingPairs );

                Attribute->Form.Nonresident.HighestVcn = NextVcn;

                NtfsRestartChangeMapping( IrpContext,
                                          Vcb,
                                          FileRecord,
                                          RecordOffset,
                                          AttributeOffset,
                                          MappingPairs,
                                          MappingPairsSize );

                //
                //  Log the changes to this page.
                //

                NtfsLogMftFileRecord( IrpContext,
                                      Vcb,
                                      FileRecord,
                                      LlBytesFromFileRecords( Vcb, NtfsSegmentNumber( &FileRecordReference ) ),
                                      NtfsFoundBcb( &AttrContext ),
                                      TRUE );

                MadeChanges = TRUE;
            }

            //
            //  Move to the first Vcn of the following record.
            //

            CurrentVcn = Attribute->Form.Nonresident.HighestVcn + 1;

            //
            //  If we reached the last file record and have more mapping to do
            //  then use the reserved record.  It must be available or we would
            //  have written out the entire mapping.
            //

            if (LastFileRecord && (CurrentVcn < LastMftVcn)) {

                PATTRIBUTE_RECORD_HEADER NewAttribute;
                PATTRIBUTE_TYPE_CODE NewEnd;

                //
                //  Start by moving to the next file record.  It better not be
                //  there or the file is corrupt.  This will position us to
                //  insert the new record.
                //

                if (NtfsLookupNextAttributeForScb( IrpContext,
                                                   Vcb->MftScb,
                                                   &AttrContext )) {

                    NtfsAcquireCheckpoint( IrpContext, Vcb );
                    ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
                    NtfsReleaseCheckpoint( IrpContext, Vcb );

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Vcb->MftScb->Fcb );
                }

                FileRecord = NtfsCloneFileRecord( IrpContext,
                                                  Vcb->MftScb->Fcb,
                                                  TRUE,
                                                  &FileRecordBcb,
                                                  &FileRecordReference );

                ReservedIndex = MAXULONG;

                //
                //  Now lets create an attribute in the new file record.
                //

                NewAttribute = Add2Ptr( FileRecord,
                                        FileRecord->FirstFreeByte
                                        - QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE )));

                NewAttribute->TypeCode = Attribute->TypeCode;
                NewAttribute->RecordLength = SIZEOF_PARTIAL_NONRES_ATTR_HEADER;
                NewAttribute->FormCode = NONRESIDENT_FORM;
                NewAttribute->Flags = Attribute->Flags;
                NewAttribute->Instance = FileRecord->NextAttributeInstance++;

                NewAttribute->Form.Nonresident.LowestVcn = CurrentVcn;
                NewAttribute->Form.Nonresident.HighestVcn = 0;
                NewAttribute->Form.Nonresident.MappingPairsOffset = (USHORT) NewAttribute->RecordLength;

                NewEnd = Add2Ptr( NewAttribute, NewAttribute->RecordLength );
                *NewEnd = $END;

                //
                //  Now fix up the file record with this new data.
                //

                FileRecord->FirstFreeByte = PtrOffset( FileRecord, NewEnd )
                                            + QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE ));

                FileRecord->SequenceNumber += 1;

                if (FileRecord->SequenceNumber == 0) {

                    FileRecord->SequenceNumber = 1;
                }

                FileRecordReference.SequenceNumber = FileRecord->SequenceNumber;

                //
                //  Now switch this new file record into the attribute context.
                //

                NtfsUnpinBcb( IrpContext, &NtfsFoundBcb( &AttrContext ));

                NtfsFoundBcb( &AttrContext ) = FileRecordBcb;
                AttrContext.FoundAttribute.MftFileOffset =
                    LlBytesFromFileRecords( Vcb, NtfsSegmentNumber( &FileRecordReference ) );
                AttrContext.FoundAttribute.Attribute = NewAttribute;
                AttrContext.FoundAttribute.FileRecord = FileRecord;

                FileRecordBcb = NULL;

                //
                //  Now add an attribute list entry for this entry.
                //

                NtfsAddToAttributeList( IrpContext,
                                        Vcb->MftScb->Fcb,
                                        FileRecordReference,
                                        &AttrContext );

                SkipLookup = TRUE;
                LastFileRecord = FALSE;

            } else {

                SkipLookup = FALSE;
            }

        } // End while more file records

        //
        //  If we didn't rewrite all of the mapping then there is some error.
        //

        if (CurrentVcn <= LastMftVcn) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
            NtfsReleaseCheckpoint( IrpContext, Vcb );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Vcb->MftScb->Fcb );
        }

    try_exit:  NOTHING;

        //
        //  Clear the excess mapping flag if no changes were made.
        //

        if (!ExcessMapping) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_EXCESS_MAP );
            NtfsReleaseCheckpoint( IrpContext, Vcb );
        }

    } finally {

        DebugUnwind( NtfsRewriteMftMapping );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        NtfsUnpinBcb( IrpContext, &FileRecordBcb );

        if (MappingPairs != NULL) {

            NtfsFreePool( MappingPairs );
        }
    }

    return MadeChanges;
}


VOID
NtfsSetTotalAllocatedField (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN USHORT TotalAllocatedNeeded
    )

/*++

Routine Description:

    This routine is called to insure that first attribute of a stream has
    the correct size attribute header based on the compression state of the
    file.  Compressed streams will have a field for the total allocated space
    in the file in the nonresident header.

    This routine will see if the header is in a valid state and make space
    if necessary.  Then it will rewrite any of the attribute data after
    the header.

Arguments:

    Scb - Scb for affected stream

    TotalAllocatedPresent - 0 if the TotalAllocated field not needed (this would
        be an uncompressed, non-sparse file), nonzero if the TotalAllocated field
        is needed.

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PATTRIBUTE_RECORD_HEADER NewAttribute = NULL;
    PUNICODE_STRING NewAttributeName = NULL;

    ULONG OldHeaderSize;
    ULONG NewHeaderSize;

    LONG SizeChange;

    PAGED_CODE();

    //
    //  This must be a non-resident user data file.
    //

    if (!NtfsIsTypeCodeUserData( Scb->AttributeTypeCode ) ||
        FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

        return;
    }

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        while (TRUE) {

            //
            //  Find the current and the new size for the attribute.
            //

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );

            FileRecord = NtfsContainingFileRecord( &AttrContext );
            Attribute = NtfsFoundAttribute( &AttrContext );

            OldHeaderSize = Attribute->Form.Nonresident.MappingPairsOffset;

            if (Attribute->NameOffset != 0) {

                OldHeaderSize = Attribute->NameOffset;
            }

            if (TotalAllocatedNeeded) {

                NewHeaderSize = SIZEOF_FULL_NONRES_ATTR_HEADER;

            } else {

                NewHeaderSize = SIZEOF_PARTIAL_NONRES_ATTR_HEADER;
            }

            SizeChange = NewHeaderSize - OldHeaderSize;

            //
            //  Make space if we need to do so.  Lookup the attribute again
            //  if necessary.
            //

            if (SizeChange > 0) {

                VCN StartingVcn;
                VCN ClusterCount;

                //
                //  If the attribute is alone in the file record and there isn't
                //  enough space available then the call to ChangeAttributeSize
                //  can't make any space available.  In that case we call
                //  NtfsChangeAttributeAllocation and let that routine rewrite
                //  the mapping to make space available.
                //

                if ((FileRecord->BytesAvailable - FileRecord->FirstFreeByte < (ULONG) SizeChange) &&
                    (NtfsFirstAttribute( FileRecord ) == Attribute) &&
                    (((PATTRIBUTE_RECORD_HEADER) NtfsGetNextRecord( Attribute ))->TypeCode == $END)) {

                    NtfsLookupAllocation( IrpContext,
                                          Scb,
                                          Attribute->Form.Nonresident.HighestVcn,
                                          &StartingVcn,
                                          &ClusterCount,
                                          NULL,
                                          NULL );

                    StartingVcn = 0;
                    ClusterCount = Attribute->Form.Nonresident.HighestVcn + 1;

                    NtfsAddAttributeAllocation( IrpContext,
                                                Scb,
                                                &AttrContext,
                                                &StartingVcn,
                                                &ClusterCount );

                } else if (NtfsChangeAttributeSize( IrpContext,
                                                    Scb->Fcb,
                                                    Attribute->RecordLength + SizeChange,
                                                    &AttrContext)) {

                    break;
                }

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                NtfsInitializeAttributeContext( &AttrContext );
                continue;
            }

            break;
        }

        NtfsPinMappedAttribute( IrpContext, Scb->Vcb, &AttrContext );

        //
        //  Make a copy of the existing attribute and modify the total allocated field
        //  if necessary.
        //

        NewAttribute = NtfsAllocatePool( PagedPool, Attribute->RecordLength + SizeChange );

        RtlCopyMemory( NewAttribute,
                       Attribute,
                       SIZEOF_PARTIAL_NONRES_ATTR_HEADER );

        if (Attribute->NameOffset != 0) {

            NewAttribute->NameOffset += (USHORT) SizeChange;
            NewAttributeName = &Scb->AttributeName;

            RtlCopyMemory( Add2Ptr( NewAttribute, NewAttribute->NameOffset ),
                           NewAttributeName->Buffer,
                           NewAttributeName->Length );
        }

        NewAttribute->Form.Nonresident.MappingPairsOffset += (USHORT) SizeChange;
        NewAttribute->RecordLength += SizeChange;

        RtlCopyMemory( Add2Ptr( NewAttribute, NewAttribute->Form.Nonresident.MappingPairsOffset ),
                       Add2Ptr( Attribute, Attribute->Form.Nonresident.MappingPairsOffset ),
                       Attribute->RecordLength - Attribute->Form.Nonresident.MappingPairsOffset );

        if (TotalAllocatedNeeded) {

            NewAttribute->Form.Nonresident.TotalAllocated = Scb->TotalAllocated;
        }

        //
        //  We now have the before and after image to log.
        //

        FileRecord->Lsn =
        NtfsWriteLog( IrpContext,
                      Scb->Vcb->MftScb,
                      NtfsFoundBcb( &AttrContext ),
                      DeleteAttribute,
                      NULL,
                      0,
                      CreateAttribute,
                      Attribute,
                      Attribute->RecordLength,
                      NtfsMftOffset( &AttrContext ),
                      PtrOffset( FileRecord, Attribute ),
                      0,
                      Scb->Vcb->BytesPerFileRecordSegment );

        NtfsRestartRemoveAttribute( IrpContext, FileRecord, PtrOffset( FileRecord, Attribute ));

        FileRecord->Lsn =
        NtfsWriteLog( IrpContext,
                      Scb->Vcb->MftScb,
                      NtfsFoundBcb( &AttrContext ),
                      CreateAttribute,
                      NewAttribute,
                      NewAttribute->RecordLength,
                      DeleteAttribute,
                      NULL,
                      0,
                      NtfsMftOffset( &AttrContext ),
                      PtrOffset( FileRecord, Attribute ),
                      0,
                      Scb->Vcb->BytesPerFileRecordSegment );

        NtfsRestartInsertAttribute( IrpContext,
                                    FileRecord,
                                    PtrOffset( FileRecord, Attribute ),
                                    NewAttribute,
                                    NewAttributeName,
                                    Add2Ptr( NewAttribute, NewAttribute->Form.Nonresident.MappingPairsOffset ),
                                    NewAttribute->RecordLength - NewAttribute->Form.Nonresident.MappingPairsOffset );

    } finally {

        DebugUnwind( NtfsSetTotalAllocatedField );

        if (NewAttribute != NULL) {

            NtfsFreePool( NewAttribute );
        }

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
    }

    return;
}


VOID
NtfsSetSparseStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb OPTIONAL,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine is called change the state of a stream to sparse.  It may be
    called on behalf of a user or internally to Ntfs (i.e. for the USN
    journal).  Our caller may already have begun a transaction but in any
    case will have acquired the main resource and paging resource for the
    stream exclusively.

    This routine will add the TotalAllocated field to the non-resident attribute
    header and fully allocate (or deallocate) the final compression unit of
    the stream.  It will set the SPARSE flag in the attribute header as well as
    in standard information and the directory entry for this stream.

    NOTE - This routine will checkpoint the current transaction in order
    to safely change the compression unit size and shift value in the Scb.
    We also will update the Fcb duplicate information which is not protected
    under transaction control.

Arguments:

    ParentScb - Scb for the parent.  If present we will update the directory
        entry for the parent.  Otherwise we simply set the FcbInfo flags and
        let the update happen when the handle is closed.

    Scb - Scb for the stream.  Caller should have acquired this already.

Return Value:

    None.

--*/

{
    PFCB Fcb = Scb->Fcb;
    PVCB Vcb = Scb->Vcb;
    PLCB Lcb;

    ULONG OriginalFileAttributes;
    USHORT OriginalStreamAttributes;
    UCHAR OriginalCompressionUnitShift;
    ULONG OriginalCompressionUnit;
    LONGLONG OriginalFileAllocatedLength;

    UCHAR NewCompressionUnitShift;
    ULONG NewCompressionUnit;

    LONGLONG StartVcn;
    LONGLONG FinalVcn;

    ULONG AttributeSizeChange;
    PATTRIBUTE_RECORD_HEADER Attribute;
    ATTRIBUTE_RECORD_HEADER NewAttribute;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    ASSERT( (Scb->Header.PagingIoResource == NULL) ||
            ExIsResourceAcquiredExclusiveLite( Scb->Header.PagingIoResource ));
    ASSERT_EXCLUSIVE_SCB( Scb );
    ASSERT( NtfsIsTypeCodeCompressible( Scb->AttributeTypeCode ));

    PAGED_CODE();

    //
    //  Return immediately if the stream is already sparse.
    //

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

        return;
    }

    //
    //  Remember the current compression unit and flags.
    //

    OriginalFileAttributes = Fcb->Info.FileAttributes;
    OriginalStreamAttributes = Scb->AttributeFlags;
    OriginalCompressionUnitShift = Scb->CompressionUnitShift;
    OriginalCompressionUnit = Scb->CompressionUnit;
    OriginalFileAllocatedLength = Fcb->Info.AllocatedLength;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    NtfsInitializeAttributeContext( &AttrContext );

    try {

        //
        //  Post the change to the Usn Journal
        //

        NtfsPostUsnChange( IrpContext, Scb, USN_REASON_BASIC_INFO_CHANGE );

        //
        //  Acquire the parent now for the update duplicate call.
        //

        if (ARGUMENT_PRESENT( ParentScb )) {

            NtfsPrepareForUpdateDuplicate( IrpContext, Fcb, &Lcb, &ParentScb, TRUE );
        }

        //
        //  If the file is not already compressed then we need to add a total allocated
        //  field and adjust the allocation length.
        //

        NewCompressionUnitShift = Scb->CompressionUnitShift;
        NewCompressionUnit = Scb->CompressionUnit;

        if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            //
            //  Compute the new compression unit and shift.
            //

            NewCompressionUnitShift = NTFS_CLUSTERS_PER_COMPRESSION;
            NewCompressionUnit = BytesFromClusters( Vcb,
                                                    1 << NTFS_CLUSTERS_PER_COMPRESSION );

            //
            //  If the compression unit is larger than 64K then find the correct
            //  compression unit to reach exactly 64k.
            //

            while (NewCompressionUnit > Vcb->SparseFileUnit) {

                NewCompressionUnitShift -= 1;
                NewCompressionUnit /= 2;
            }

            if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                //
                //  Fully allocate the final compression unit.
                //

                if (Scb->Header.AllocationSize.LowPart & (NewCompressionUnit - 1)) {

                    StartVcn = LlClustersFromBytesTruncate( Vcb, Scb->Header.AllocationSize.QuadPart );
                    FinalVcn = Scb->Header.AllocationSize.QuadPart + NewCompressionUnit - 1;
                    ((PLARGE_INTEGER) &FinalVcn)->LowPart &= ~(NewCompressionUnit - 1);
                    FinalVcn = LlClustersFromBytesTruncate( Vcb, FinalVcn );

                    NtfsAddAllocation( IrpContext,
                                       NULL,
                                       Scb,
                                       StartVcn,
                                       FinalVcn - StartVcn,
                                       FALSE,
                                       NULL );

                    if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                        Fcb->Info.AllocatedLength = Scb->TotalAllocated;
                        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
                    }
                }

                //
                //  Add a total allocated field to the attribute record header.
                //

                NtfsSetTotalAllocatedField( IrpContext, Scb, ATTRIBUTE_FLAG_SPARSE );
            }
        }

        //
        //  Look up the existing attribute.
        //

        NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );
        NtfsPinMappedAttribute( IrpContext, Vcb, &AttrContext );
        Attribute = NtfsFoundAttribute( &AttrContext );

        //
        //  Now we need to set the bits in the attribute flag field.
        //

        if (NtfsIsAttributeResident( Attribute )) {

            RtlCopyMemory( &NewAttribute, Attribute, SIZEOF_RESIDENT_ATTRIBUTE_HEADER );

            AttributeSizeChange = SIZEOF_RESIDENT_ATTRIBUTE_HEADER;

        //
        //  Else if it is nonresident, copy it here, set the compression parameter,
        //  and remember its size.
        //

        } else {

            AttributeSizeChange = Attribute->Form.Nonresident.MappingPairsOffset;

            if (Attribute->NameOffset != 0) {

                AttributeSizeChange = Attribute->NameOffset;
            }

            ASSERT( AttributeSizeChange <= sizeof( NewAttribute ));
            RtlCopyMemory( &NewAttribute, Attribute, AttributeSizeChange );
            NewAttribute.Form.Nonresident.CompressionUnit = NewCompressionUnitShift;
        }

        SetFlag( NewAttribute.Flags, ATTRIBUTE_FLAG_SPARSE );

        //
        //  Now, log the changed attribute.
        //

        (VOID)NtfsWriteLog( IrpContext,
                            Vcb->MftScb,
                            NtfsFoundBcb( &AttrContext ),
                            UpdateResidentValue,
                            &NewAttribute,
                            AttributeSizeChange,
                            UpdateResidentValue,
                            Attribute,
                            AttributeSizeChange,
                            NtfsMftOffset( &AttrContext ),
                            PtrOffset(NtfsContainingFileRecord( &AttrContext ), Attribute),
                            0,
                            Vcb->BytesPerFileRecordSegment );

        //
        //  Change the attribute by calling the same routine called at restart.
        //

        NtfsRestartChangeValue( IrpContext,
                                NtfsContainingFileRecord( &AttrContext ),
                                PtrOffset( NtfsContainingFileRecord( &AttrContext ), Attribute ),
                                0,
                                &NewAttribute,
                                AttributeSizeChange,
                                FALSE );

        //
        //  If the file is not already marked sparse then update the standard information
        //  and the parent directory (if specified).  Also report the change via
        //  dirnotify if there is a Ccb with a name.
        //

        ASSERTMSG( "conflict with flush",
                   ExIsResourceAcquiredSharedLite( Fcb->Resource ) ||
                   (Fcb->PagingIoResource != NULL &&
                    ExIsResourceAcquiredSharedLite( Fcb->PagingIoResource )));

        SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE );
        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

        //
        //  Update the attributes in standard information.
        //

        NtfsUpdateStandardInformation( IrpContext, Fcb );

        if (ARGUMENT_PRESENT( ParentScb )) {

            //
            //  Update the directory entry for this file.
            //

            NtfsUpdateDuplicateInfo( IrpContext, Fcb, NULL, NULL );
            NtfsUpdateLcbDuplicateInfo( Fcb, Lcb );
            Fcb->InfoFlags = 0;
        }

        //
        //  Update the compression values and the sparse flag in the Scb.
        //

        Scb->CompressionUnit = NewCompressionUnit;
        Scb->CompressionUnitShift = NewCompressionUnitShift;

        SetFlag( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE );

        //
        //  Set the FastIo state.
        //

        NtfsAcquireFsrtlHeader( Scb );
        Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
        SetFlag( Scb->Header.Flags2, FSRTL_FLAG2_PURGE_WHEN_MAPPED );
        NtfsReleaseFsrtlHeader( Scb );

        //
        //  Commit this change.
        //

        NtfsCheckpointCurrentTransaction( IrpContext );

    } finally {

        DebugUnwind( NtfsSetSparseStream );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        //
        //  Backout the changes to the non-logged structures on abort.
        //

        if (AbnormalTermination()) {

            Fcb->Info.FileAttributes = OriginalFileAttributes;
            Scb->AttributeFlags = OriginalStreamAttributes;
            if (!FlagOn( OriginalStreamAttributes, ATTRIBUTE_FLAG_SPARSE )) {
                NtfsAcquireFsrtlHeader( Scb );
                ClearFlag( Scb->Header.Flags2, FSRTL_FLAG2_PURGE_WHEN_MAPPED );
                NtfsReleaseFsrtlHeader( Scb );
            }
            Scb->CompressionUnitShift = OriginalCompressionUnitShift;
            Scb->CompressionUnit = OriginalCompressionUnit;
            Fcb->Info.AllocatedLength = OriginalFileAllocatedLength;
        }
    }

    return;
}


NTSTATUS
NtfsZeroRangeInStream (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PSCB Scb,
    IN PLONGLONG StartingOffset,
    IN LONGLONG FinalZero
    )

/*++

Routine Description:

    This routine is the worker routine which will zero a range of a stream and
    (if sparse) deallocate any space in the stream that is convenient.  We only
    perform this operation on $DATA streams where there are no user maps.  We
    will zero, flush and purge any partial pages.  We will zero full pages except
    for sparse streams where we will purge the data and deallocate the
    disk backing for this range.

    This routine will fail if the stream has a user map.  Note that if the user
    is zeroing the end of the stream we can choose to simply move valid data length
    and purge the existing data instead of performing extensive flush operations.

Arguments:

    FileObject - A file object for the stream.  We can use this to follow the
        caller's preference for write through.

    Scb - This is the Scb for the stream we are to zero.  The user may have acquired
        the paging io resource prior to this call but the main resource should
        not be acquired.

    StartingOffset - Offset in the file to start the zero operation.  This may
        lie outside of the file size.  We update this to reflect the current
        position through the file.  That way if this routine should raise log
        file full our caller can resume from the point where we left off.

    FinalZero - Offset of last byte in the file to zero.

Return Value:

    NTSTATUS - Result of this operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    BOOLEAN ReleaseScb = FALSE;
    BOOLEAN UnlockHeader = FALSE;

    LONGLONG LastOffset = -1;
    LONGLONG CurrentBytes;
    LONGLONG CurrentOffset;
    LONGLONG CurrentFinalByte;
    LONGLONG ClusterCount;

    ULONG ClustersPerCompressionUnit;

    BOOLEAN ThrottleWrites;

    VCN NextVcn;
    VCN CurrentVcn;
    LCN Lcn;

    PBCB ZeroBufferBcb = NULL;
    PVOID ZeroBuffer;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN CleanupAttrContext = FALSE;

    PAGED_CODE();

    //
    //  We better not be holding the main resource without also holding
    //  the paging resource, if any.
    //

    ASSERT( !NtfsIsSharedScb( Scb ) ||
            (Scb->Header.PagingIoResource == NULL) ||
            NtfsIsExclusiveScbPagingIo( Scb ) );

    //
    //  We will loop through the requested zero range.  We will checkpoint
    //  periodically and drop all resources so we don't become a bottle neck
    //  in the system.
    //

    try {

        while (TRUE) {

            //
            //  Acquire either the paging Io resource if present and lock the header
            //  or simply acquire the main resource.
            //

            if (Scb->Header.PagingIoResource != NULL) {

                if (IrpContext->CleanupStructure != NULL) {
                    ASSERT( (PFCB)IrpContext->CleanupStructure == Scb->Fcb );
                } else {
                    ExAcquireResourceExclusiveLite( Scb->Header.PagingIoResource, TRUE );

                    FsRtlLockFsRtlHeader( &Scb->Header );
                    IrpContext->CleanupStructure = Scb;
                    UnlockHeader = TRUE;
                }
            } else {

                NtfsAcquireExclusiveScb( IrpContext, Scb );
                ReleaseScb = TRUE;
            }

            //
            //  Verify that the file and volume are still present.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED | SCB_STATE_VOLUME_DISMOUNTED)) {

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

                    Status = STATUS_FILE_DELETED;

                } else {

                    Status = STATUS_VOLUME_DISMOUNTED;
                }

                leave;
            }

            if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
            }

            //
            //  If we are past the end of the file or the length is zero we can break out.
            //

            if ((*StartingOffset >= Scb->Header.FileSize.QuadPart) ||
                (*StartingOffset >= FinalZero)) {

                try_return( NOTHING );
            }

            ThrottleWrites = FALSE;

            //
            //  Check for the oplock and file state.
            //

            if (ARGUMENT_PRESENT( FileObject )) {

                CurrentBytes = FinalZero - *StartingOffset;

                if (FinalZero > Scb->Header.FileSize.QuadPart) {

                    CurrentBytes = Scb->Header.FileSize.QuadPart - *StartingOffset;
                }

                if (CurrentBytes > NTFS_MAX_ZERO_RANGE) {

                    CurrentBytes = NTFS_MAX_ZERO_RANGE;
                }

                Status = NtfsCheckLocksInZeroRange( IrpContext,
                                                    IrpContext->OriginatingIrp,
                                                    Scb,
                                                    FileObject,
                                                    StartingOffset,
                                                    (ULONG) CurrentBytes );

                if (Status != STATUS_SUCCESS) {

                    leave;
                }
            }

            //
            //  Post the change to the Usn Journal
            //

            NtfsPostUsnChange( IrpContext, Scb, USN_REASON_DATA_OVERWRITE );

            //
            //  We are going to make the changes.  Make sure we set the file object
            //  flag to indicate we are making changes.
            //

            if (ARGUMENT_PRESENT( FileObject )) {

                SetFlag( FileObject->Flags, FO_FILE_MODIFIED );
            }

            //
            //  If the file is resident then flush and purge the stream and
            //  then change the attribute itself.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                //
                //  Trim the remaining bytes to file size.
                //

                CurrentBytes = FinalZero - *StartingOffset;

                if (FinalZero > Scb->Header.FileSize.QuadPart) {

                    CurrentBytes = Scb->Header.FileSize.QuadPart - *StartingOffset;
                }

                Status = NtfsFlushUserStream( IrpContext, Scb, NULL, 0 );

                NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                    &Status,
                                                    TRUE,
                                                    STATUS_UNEXPECTED_IO_ERROR );

                //
                //  Proceed if there is nothing to purge or the purge succeeds.
                //

                if ((Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL) &&
                    !CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                          NULL,
                                          0,
                                          FALSE )) {

                    Status = STATUS_UNABLE_TO_DELETE_SECTION;
                    leave;
                }

                //
                //  Acquire the main resource to change the attribute.
                //

                if (!ReleaseScb) {

                    NtfsAcquireExclusiveScb( IrpContext, Scb );
                    ReleaseScb = TRUE;
                }

                //
                //  Now look up the attribute and zero the requested range.
                //

                NtfsInitializeAttributeContext( &AttrContext );
                CleanupAttrContext = TRUE;

                NtfsLookupAttributeForScb( IrpContext,
                                           Scb,
                                           NULL,
                                           &AttrContext );

                NtfsChangeAttributeValue( IrpContext,
                                          Scb->Fcb,
                                          (ULONG) *StartingOffset,
                                          NULL,
                                          (ULONG) CurrentBytes,
                                          FALSE,
                                          TRUE,
                                          FALSE,
                                          FALSE,
                                          &AttrContext );

                NtfsCheckpointCurrentTransaction( IrpContext );

                *StartingOffset += CurrentBytes;
                try_return( NOTHING );
            }

            //
            //  Make sure there are no mapped sections in the range we are trying to
            //  zero.
            //

            if (!MmCanFileBeTruncated( &Scb->NonpagedScb->SegmentObject,
                                       (PLARGE_INTEGER) StartingOffset )) {

                Status = STATUS_USER_MAPPED_FILE;
                try_return( NOTHING );
            }

            //
            //  If the file is either sparse or compressed then we look for ranges
            //  we need to flush, purge or deallocate.
            //

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                ClustersPerCompressionUnit = 1 << Scb->CompressionUnitShift;

                //
                //  Move our starting point back to a compression unit boundary.  If our
                //  ending point is past the end of the file then set it to the compression
                //  unit past the EOF.
                //

                CurrentOffset = *StartingOffset & ~((LONGLONG) (Scb->CompressionUnit - 1));

                CurrentFinalByte = FinalZero;

                if (CurrentFinalByte > Scb->Header.FileSize.QuadPart) {

                    CurrentFinalByte = Scb->Header.FileSize.QuadPart + Scb->CompressionUnit - 1;

                    ((PLARGE_INTEGER) &CurrentFinalByte)->LowPart &= ~(Scb->CompressionUnit - 1);
                }

                //
                //  Then look forward for either an allocated range or a reserved compression
                //  unit.  We may have to flush and/or purge data at that offset.
                //

                NextVcn =
                CurrentVcn = LlClustersFromBytesTruncate( Scb->Vcb, CurrentOffset );

                while (!NtfsLookupAllocation( IrpContext,
                                              Scb,
                                              NextVcn,
                                              &Lcn,
                                              &ClusterCount,
                                              NULL,
                                              NULL )) {

                    //
                    //  Move the current Vcn forward by the size of the hole.
                    //  Break out if we are beyond the final byte.
                    //

                    NextVcn += ClusterCount;

                    if ((LONGLONG) LlBytesFromClusters( Scb->Vcb, NextVcn ) >= CurrentFinalByte) {

                        //
                        //  Trim the final Vcn to the beginning of the last compression unit.
                        //

                        NextVcn = LlClustersFromBytesTruncate( Scb->Vcb, CurrentFinalByte );
                        break;
                    }
                }

                //
                //  Back up to a compression unit.
                //

                ((PLARGE_INTEGER) &NextVcn)->LowPart &= ~(ClustersPerCompressionUnit - 1);

                //
                //  If we found a hole then we need to look for reserved clusters within
                //  the range.
                //

                if (NextVcn != CurrentVcn) {

                    ClusterCount = NextVcn - CurrentVcn;

                    if (Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL) {

                        NtfsCheckForReservedClusters( Scb, CurrentVcn, &ClusterCount );
                    }

                    CurrentVcn += ClusterCount;
                }

                //
                //  CurrentVcn - points to the first range we might have to zero in memory.
                //  NextVcn - points to the first range we might choose to deallocate.
                //
                //  Proceed if we aren't beyond the final byte to zero.
                //

                CurrentOffset = LlBytesFromClusters( Scb->Vcb, CurrentVcn );

                if (CurrentOffset >= CurrentFinalByte) {

                    ASSERT( IrpContext->TransactionId == 0 );

                    *StartingOffset = CurrentFinalByte;
                    try_return( NOTHING );
                }

                //
                //  If we find a range which is less than our starting offset then we will
                //  have to zero this range in the data section.
                //

                ASSERT( ((ULONG) CurrentOffset & (Scb->CompressionUnit - 1)) == 0 );

                if (CurrentOffset < *StartingOffset) {

                    //
                    //  Reserve a cluster to perform the write.
                    //

                    if (!NtfsReserveClusters( IrpContext, Scb, CurrentOffset, Scb->CompressionUnit )) {

                        Status = STATUS_DISK_FULL;
                        try_return( NOTHING );
                    }

                    //
                    //  Limit the zero range.
                    //

                    CurrentBytes = Scb->CompressionUnit - (*StartingOffset - CurrentOffset);

                    if (CurrentOffset + Scb->CompressionUnit > CurrentFinalByte) {

                        CurrentBytes = CurrentFinalByte - *StartingOffset;
                    }

                    //
                    //  See if we have to create an internal attribute stream.
                    //

                    if (Scb->FileObject == NULL) {
                        NtfsCreateInternalAttributeStream( IrpContext,
                                                           Scb,
                                                           FALSE,
                                                           &NtfsInternalUseFile[ZERORANGEINSTREAM_FILE_NUMBER] );
                    }

                    //
                    //  Zero the data in the cache.
                    //

                    CcPinRead( Scb->FileObject,
                               (PLARGE_INTEGER) &CurrentOffset,
                               Scb->CompressionUnit,
                               TRUE,
                               &ZeroBufferBcb,
                               &ZeroBuffer );
#ifdef MAPCOUNT_DBG
                    IrpContext->MapCount++;
#endif

                    RtlZeroMemory( Add2Ptr( ZeroBuffer,
                                            ((ULONG) *StartingOffset) & (Scb->CompressionUnit - 1)),
                                   (ULONG) CurrentBytes );
                    CcSetDirtyPinnedData( ZeroBufferBcb, NULL );
                    NtfsUnpinBcb( IrpContext, &ZeroBufferBcb );

                    //
                    //  Update the current offset to our position within the compression unit.
                    //

                    CurrentOffset += ((ULONG) *StartingOffset) & (Scb->CompressionUnit - 1);

                //
                //  If the current compression unit includes the last byte to zero
                //  then we need flush and/or purge this compression unit.
                //

                } else if (CurrentOffset + Scb->CompressionUnit > CurrentFinalByte) {

                    //
                    //  Reserve a cluster to perform the write.
                    //

                    if (!NtfsReserveClusters( IrpContext, Scb, CurrentOffset, Scb->CompressionUnit )) {

                        Status = STATUS_DISK_FULL;
                        try_return( NOTHING );
                    }

                    //
                    //  Limit the zero range.
                    //

                    CurrentBytes = (ULONG) CurrentFinalByte & (Scb->CompressionUnit - 1);

                    //
                    //  See if we have to create an internal attribute stream.
                    //

                    if (Scb->FileObject == NULL) {
                        NtfsCreateInternalAttributeStream( IrpContext,
                                                           Scb,
                                                           FALSE,
                                                           &NtfsInternalUseFile[ZERORANGEINSTREAM2_FILE_NUMBER] );
                    }

                    //
                    //  Zero the data in the cache.
                    //

                    CcPinRead( Scb->FileObject,
                               (PLARGE_INTEGER) &CurrentOffset,
                               (ULONG) CurrentBytes,
                               TRUE,
                               &ZeroBufferBcb,
                               &ZeroBuffer );
#ifdef MAPCOUNT_DBG
                    IrpContext->MapCount++;
#endif


                    RtlZeroMemory( ZeroBuffer, (ULONG) CurrentBytes );
                    CcSetDirtyPinnedData( ZeroBufferBcb, NULL );
                    NtfsUnpinBcb( IrpContext, &ZeroBufferBcb );

                } else {

                    //
                    //  Compute the range we want to purge.  We will process a maximum of 2Gig
                    //  at a time.
                    //

                    CurrentBytes = CurrentFinalByte - CurrentOffset;

                    if (CurrentBytes > NTFS_MAX_ZERO_RANGE) {

                        CurrentBytes = NTFS_MAX_ZERO_RANGE;
                    }

                    //
                    //  Round the size to a compression unit.
                    //

                    ((PLARGE_INTEGER) &CurrentBytes)->LowPart &= ~(Scb->CompressionUnit - 1);

                    //
                    //  If this is the retry case then let's reduce the amount to
                    //  zero.
                    //

                    if ((*StartingOffset == LastOffset) &&
                        (CurrentBytes > Scb->CompressionUnit)) {

                        CurrentBytes = Scb->CompressionUnit;
                        CurrentFinalByte = CurrentOffset + CurrentBytes;
                    }

                    //
                    //  Purge the data in this range.
                    //

                    if ((Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL) &&
                        !CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                              (PLARGE_INTEGER) &CurrentOffset,
                                              (ULONG) CurrentBytes,
                                              FALSE )) {

                        //
                        //  There may be a section in the cache manager which is being
                        //  flushed.  Go ahead and see if we can force the data out
                        //  so the purge will succeed.
                        //

                        Status = NtfsFlushUserStream( IrpContext,
                                                      Scb,
                                                      &CurrentOffset,
                                                      (ULONG) CurrentBytes );

                        NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                            &Status,
                                                            TRUE,
                                                            STATUS_UNEXPECTED_IO_ERROR );

                        //
                        //  If this is the retry case then let's reduce the amount to
                        //  zero.
                        //

                        if (CurrentBytes > Scb->CompressionUnit) {

                            CurrentBytes = Scb->CompressionUnit;
                            CurrentFinalByte = CurrentOffset + CurrentBytes;
                        }

                        //
                        //  Now try the purge again.
                        //

                        if (!CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                                  (PLARGE_INTEGER) &CurrentOffset,
                                                  (ULONG) CurrentBytes,
                                                  FALSE )) {

                            //
                            //  If our retry failed then give up.
                            //

                            if (*StartingOffset == LastOffset) {

                                Status = STATUS_UNABLE_TO_DELETE_SECTION;
                                leave;
                            }

                            //
                            //  Otherwise show that we haven't advanced, but we
                            //  will take one more crack at this.
                            //

                            CurrentBytes = 0;
                        }
                    }

                    //
                    //  Delete the allocation if we have any bytes to work with.
                    //

                    if (CurrentBytes != 0) {

                        //
                        //  Acquire the main resource to change the allocation.
                        //

                        if (!ReleaseScb) {

                            NtfsAcquireExclusiveScb( IrpContext, Scb );
                            ReleaseScb = TRUE;
                        }

                        //
                        //  Now deallocate the clusters in this range if we have some to delete.
                        //  Use ClusterCount to indicate the last Vcn to deallocate.
                        //

                        ClusterCount = CurrentVcn + LlClustersFromBytesTruncate( Scb->Vcb, CurrentBytes ) - 1;

                        if (NextVcn <= ClusterCount) {

                            NtfsDeleteAllocation( IrpContext,
                                                  FileObject,
                                                  Scb,
                                                  NextVcn,
                                                  ClusterCount,
                                                  TRUE,
                                                  TRUE );

                            //
                            //  Move VDD fwd to protect this hole for compressed files
                            //

                            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {
                                if ((ULONGLONG)Scb->ValidDataToDisk < LlBytesFromClusters( Scb->Vcb, ClusterCount )) {
                                    Scb->ValidDataToDisk = LlBytesFromClusters( Scb->Vcb, ClusterCount );
                                }
                            }
                        }

                        //
                        //  Free up the reserved bitmap if there are any bits to clear.
                        //

                        NtfsFreeReservedClusters( Scb, CurrentOffset, (ULONG) CurrentBytes );
                    }
                }

            //
            //  Otherwise the file is uncompressed/non-sparse, we need to zero partial
            //  cluster and then we need to flush and/or purge the existing pages.
            //

            } else {

                //
                //  Remember the current offset within the stream and
                //  the length to zero now.
                //

                CurrentOffset = *StartingOffset;
                CurrentFinalByte = (CurrentOffset + 0x40000) & ~((LONGLONG) (0x40000 - 1));

                if (CurrentFinalByte > Scb->Header.FileSize.QuadPart) {

                    CurrentFinalByte = Scb->Header.FileSize.QuadPart;
                }

                if (CurrentFinalByte > FinalZero) {

                    CurrentFinalByte = FinalZero;
                }

                //
                //  Determine the number of bytes remaining in the current cache view.
                //

                CurrentBytes = CurrentFinalByte - CurrentOffset;

                //
                //  If this is the retry case then let's reduce the amount to
                //  zero.
                //

                if ((*StartingOffset == LastOffset) &&
                    (CurrentBytes > PAGE_SIZE)) {

                    CurrentBytes = PAGE_SIZE;
                    CurrentFinalByte = CurrentOffset + CurrentBytes;
                }

                //
                //  Purge the data in this range.
                //

                if (Scb->NonpagedScb->SegmentObject.DataSectionObject &&
                    !CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                          (PLARGE_INTEGER) &CurrentOffset,
                                          (ULONG) CurrentBytes,
                                          FALSE )) {

                    //
                    //  There may be a section in the cache manager which is being
                    //  flushed.  Go ahead and see if we can force the data out
                    //  so the purge will succeed.
                    //

                    Status = NtfsFlushUserStream( IrpContext,
                                                  Scb,
                                                  &CurrentOffset,
                                                  (ULONG) CurrentBytes );

                    NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                        &Status,
                                                        TRUE,
                                                        STATUS_UNEXPECTED_IO_ERROR );

                    //
                    //  Let's trim back the amount of data to purge at once.
                    //

                    if (CurrentBytes > PAGE_SIZE) {

                        CurrentBytes = PAGE_SIZE;
                        CurrentFinalByte = CurrentOffset + CurrentBytes;
                    }

                    //
                    //  Now try the purge again.
                    //

                    if (!CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                              (PLARGE_INTEGER) &CurrentOffset,
                                              (ULONG) CurrentBytes,
                                              FALSE )) {

                        //
                        //  If our retry failed then give up.
                        //

                        if (*StartingOffset == LastOffset) {

                            Status = STATUS_UNABLE_TO_DELETE_SECTION;
                            leave;
                        }

                        //
                        //  Otherwise show that we haven't advanced, but we
                        //  will take one more crack at this.
                        //

                        CurrentBytes = 0;
                    }
                }

                //
                //  Continue if we have bytes to zero.
                //

                if (CurrentBytes != 0) {

                    //
                    //  If we are within valid data length then zero the data.
                    //

                    if (CurrentOffset < Scb->Header.ValidDataLength.QuadPart) {

                        //
                        //  See if we have to create an internal attribute stream.
                        //

                        if (Scb->FileObject == NULL) {
                            NtfsCreateInternalAttributeStream( IrpContext,
                                                               Scb,
                                                               FALSE,
                                                               &NtfsInternalUseFile[ZERORANGEINSTREAM3_FILE_NUMBER] );
                        }

                        //
                        //  Zero the data in the cache.
                        //

                        CcPinRead( Scb->FileObject,
                                   (PLARGE_INTEGER) &CurrentOffset,
                                   (ULONG) CurrentBytes,
                                   TRUE,
                                   &ZeroBufferBcb,
                                   &ZeroBuffer );
#ifdef MAPCOUNT_DBG
                        IrpContext->MapCount++;
#endif

                        RtlZeroMemory( ZeroBuffer, (ULONG) CurrentBytes );
                        CcSetDirtyPinnedData( ZeroBufferBcb, NULL );
                        NtfsUnpinBcb( IrpContext, &ZeroBufferBcb );
                    }

                    //
                    //  We want to throttle the writes if there is more to do.
                    //

                    if (CurrentFinalByte < FinalZero) {

                        ThrottleWrites = TRUE;
                    }
                }
            }

            //
            //  Check and see if we can advance valid data length.
            //

            if ((CurrentOffset + CurrentBytes > Scb->Header.ValidDataLength.QuadPart) &&
                (*StartingOffset <= Scb->Header.ValidDataLength.QuadPart)) {

                NtfsAcquireFsrtlHeader( Scb );
                Scb->Header.ValidDataLength.QuadPart = CurrentOffset + CurrentBytes;

                if (Scb->Header.ValidDataLength.QuadPart > Scb->Header.FileSize.QuadPart) {
                    Scb->Header.ValidDataLength.QuadPart = Scb->Header.FileSize.QuadPart;
                }

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {

                    FsRtlLogSyscacheEvent( Scb, SCE_ZERO_STREAM, SCE_FLAG_SET_VDL, Scb->Header.ValidDataLength.QuadPart, 0, 0 );
                }
#endif

                NtfsReleaseFsrtlHeader( Scb );
            }

            //
            //  Checkpoint and past the current bytes.
            //

            if (NtfsIsExclusiveScb( Scb->Vcb->MftScb )) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_MFT );
            }

            NtfsCheckpointCurrentTransaction( IrpContext );

            LastOffset = *StartingOffset;
            if (CurrentBytes != 0) {

                *StartingOffset = CurrentOffset + CurrentBytes;
            }

            //
            //  Release all of the resources so we don't create a bottleneck.
            //

            if (UnlockHeader) {

                FsRtlUnlockFsRtlHeader( &Scb->Header );
                IrpContext->CleanupStructure = NULL;
                ExReleaseResourceLite( Scb->Header.PagingIoResource );
                UnlockHeader = FALSE;
            }

            if (ReleaseScb) {

                NtfsReleaseScb( IrpContext, Scb );
                ReleaseScb = FALSE;
            }

            //
            //  Now throttle the writes if we are accessing an uncompressed/non-sparse file.
            //

            if (ARGUMENT_PRESENT( FileObject ) && ThrottleWrites) {

                CcCanIWrite( FileObject, 0x40000, TRUE, FALSE );
            }
        }

    try_exit: NOTHING;

        //
        //  If we have a user file object then check if we need to write any
        //  data to disk.
        //

        if ((Status == STATUS_SUCCESS) && ARGUMENT_PRESENT( FileObject )) {

            if ((FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) ||
                 IsFileWriteThrough( FileObject, Scb->Vcb ))) {

                //
                //  We either want to flush the Scb or flush and purge the Scb.
                //

                if ((Scb->CleanupCount == Scb->NonCachedCleanupCount) &&
                    !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                    //
                    //  Flush and purge will alter filesizes on disk so preacquire the file exclusive
                    //

                    if (!ReleaseScb) {
                        NtfsAcquireExclusiveScb( IrpContext, Scb );
                        ReleaseScb = TRUE;
                    }
                    NtfsFlushAndPurgeScb( IrpContext, Scb, NULL );

                } else {

                    Status = NtfsFlushUserStream( IrpContext, Scb, NULL, 0 );
                    NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                        &Status,
                                                        TRUE,
                                                        STATUS_UNEXPECTED_IO_ERROR );
                }
            }

            //
            //  If this is write through or non-cached then flush the log file as well.
            //

            if (IsFileWriteThrough( FileObject, Scb->Vcb ) ||
                FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING )) {

                LfsFlushToLsn( Scb->Vcb->LogHandle, LiMax );
            }
        }

    } finally {

        DebugUnwind( NtfsZeroRangeInStream );

        if (Status != STATUS_PENDING) {

            //
            //  Release any held resources.
            //

            if (UnlockHeader) {

                FsRtlUnlockFsRtlHeader( &Scb->Header );
                IrpContext->CleanupStructure = NULL;
                ExReleaseResourceLite( Scb->Header.PagingIoResource );

            }

            if (ReleaseScb) {

                NtfsReleaseScb( IrpContext, Scb );
            }

        //
        //  Even if STATUS_PENDING is returned we need to release the paging io
        //  resource.  PrePostIrp will clear the IoAtEOF bit.
        //

        } else if (UnlockHeader) {

            ExReleaseResourceLite( Scb->Header.PagingIoResource );
        }

        //
        //  Cleanup the attribute context if used.
        //

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        NtfsUnpinBcb( IrpContext, &ZeroBufferBcb );
    }

    return Status;
}


BOOLEAN
NtfsModifyAttributeFlags (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN USHORT NewAttributeFlags
    )

/*++

Routine Description:

    This routine is called to change the attribute for an Scb.  It changes the values
    associated with the AttributeFlags (Encryption, Sparse, Compressed).

    This routine does not commit so our caller must know how to unwind changes to the Scb and
    Fcb (compression fields and Fcb Info).

    NOTE - This routine will update the Fcb duplicate info and flags as well as the compression unit
        fields in the Scb.  The caller is responsible for cleaning these up on error.

Arguments:

    Scb - Scb for the stream being modified.

    NewAttributeFlags - New flags to associate with the stream.

    FcbInfoFlags - Pointer to store changes to apply to the Fcb Info flags.

Return Value:

    BOOLEAN - TRUE if our caller needs to update duplicate info.  FALSE otherwise.

--*/

{
    PFCB Fcb = Scb->Fcb;
    PVCB Vcb = Scb->Vcb;

    ATTRIBUTE_RECORD_HEADER NewAttribute;
    PATTRIBUTE_RECORD_HEADER Attribute;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    ULONG AttributeSizeChange;
    BOOLEAN ChangeTotalAllocated = FALSE;
    BOOLEAN ChangeCompression = FALSE;
    BOOLEAN ChangeSparse = FALSE;
    BOOLEAN ChangeEncryption = FALSE;
    ULONG NewCompressionUnit;
    UCHAR NewCompressionUnitShift;

    BOOLEAN UpdateDuplicate = FALSE;

    PAGED_CODE();

    ASSERT( Scb->AttributeFlags != NewAttributeFlags );

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Lookup the attribute and pin it so that we can modify it.
        //

        if ((Scb->Header.NodeTypeCode == NTFS_NTC_SCB_INDEX) ||
            (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_ROOT_INDEX)) {

            //
            //  Lookup the attribute record from the Scb.
            //

            if (!NtfsLookupAttributeByName( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            $INDEX_ROOT,
                                            &Scb->AttributeName,
                                            NULL,
                                            FALSE,
                                            &AttrContext )) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, NULL );
            }

            Attribute = NtfsFoundAttribute( &AttrContext );

        } else {

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );
            Attribute = NtfsFoundAttribute( &AttrContext );

            //
            //  If the new state is encrypted and the file is not currently encrypted then convert to
            //  non-resident.
            //

            if (FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED ) &&
                NtfsIsAttributeResident( Attribute )) {

                NtfsConvertToNonresident( IrpContext,
                                          Fcb,
                                          Attribute,
                                          FALSE,
                                          &AttrContext );
            }
        }

        //
        //  Remember which flags are changing.
        //

        if (FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) !=
            FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            ChangeCompression = TRUE;
        }

        if (FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_SPARSE ) !=
            FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_SPARSE )) {

            ChangeSparse = TRUE;
        }

        if (FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED ) !=
            FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_ENCRYPTED )) {

            ChangeEncryption = TRUE;
        }

        //
        //  Point to the current attribute and save the current flags.
        //

        NtfsPinMappedAttribute( IrpContext, Vcb, &AttrContext );

        Attribute = NtfsFoundAttribute( &AttrContext );

        //
        //  Compute the new compression size.  Use the following to determine this
        //
        //      - New state is not compressed/sparse - Unit/UnitShift = 0
        //      - New state includes compressed/sparse
        //          - Current state includes compressed/sparse - No change
        //          - Stream is compressible - Default values (64K max)
        //          - Stream is not compressible - Unit/UnitShift = 0
        //

        NewCompressionUnit = Scb->CompressionUnit;
        NewCompressionUnitShift = Scb->CompressionUnitShift;

        //
        //  Set the correct compression unit but only for data streams.  We
        //  don't want to change this value for the Index Root.
        //

        if (NtfsIsTypeCodeCompressible( Attribute->TypeCode )) {

            //
            //  We need a compression unit for the attribute now.
            //

            if (FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                if (!FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                    ChangeTotalAllocated = TRUE;
                    NewCompressionUnit = BytesFromClusters( Scb->Vcb, 1 << NTFS_CLUSTERS_PER_COMPRESSION );
                    NewCompressionUnitShift = NTFS_CLUSTERS_PER_COMPRESSION;

                    //
                    //  If the compression unit is larger than 64K then find the correct
                    //  compression unit to reach exactly 64k.
                    //

                    while (NewCompressionUnit > Vcb->SparseFileUnit) {

                        NewCompressionUnitShift -= 1;
                        NewCompressionUnit /= 2;
                    }
                }

            } else {

                //
                //  Check if we to remove the extra total allocated field.
                //

                if (FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                    ChangeTotalAllocated = TRUE;
                }

                NewCompressionUnit = 0;
                NewCompressionUnitShift = 0;
            }
        }

        //
        //  If the attribute is resident, copy it here and remember its
        //  header size.
        //

        if (NtfsIsAttributeResident( Attribute )) {

            RtlCopyMemory( &NewAttribute, Attribute, SIZEOF_RESIDENT_ATTRIBUTE_HEADER );

            AttributeSizeChange = SIZEOF_RESIDENT_ATTRIBUTE_HEADER;

        //
        //  Else if it is nonresident, copy it here, set the compression parameter,
        //  and remember its size.
        //

        } else {

            ASSERT( NtfsIsTypeCodeCompressible( Attribute->TypeCode ));

            //
            //  Pad the allocation if the new type includes sparse or compressed and file is
            //  not sparse or compressed (non-resident only).
            //

            if (FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ) &&
                !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                LONGLONG Temp;
                ULONG CompressionUnitInClusters;

                //
                //  If we are turning compression on, then we need to fill out the
                //  allocation of the compression unit containing file size, or else
                //  it will be interpreted as compressed when we fault it in.  This
                //  is peanuts compared to the dual copies of clusters we keep around
                //  in the loop below when we rewrite the file.  We don't do this
                //  work if the file is sparse because the allocation has already
                //  been rounded up.
                //

                CompressionUnitInClusters = 1 << NewCompressionUnitShift;

                Temp = LlClustersFromBytesTruncate( Vcb, Scb->Header.AllocationSize.QuadPart );

                //
                //  If FileSize is not already at a cluster boundary, then add
                //  allocation.
                //

                if ((ULONG) Temp & (CompressionUnitInClusters - 1)) {

                    NtfsAddAllocation( IrpContext,
                                       NULL,
                                       Scb,
                                       Temp,
                                       CompressionUnitInClusters - ((ULONG)Temp & (CompressionUnitInClusters - 1)),
                                       FALSE,
                                       NULL );

                    //
                    //  Update the duplicate info.
                    //

                    if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                        Scb->Fcb->Info.AllocatedLength = Scb->TotalAllocated;
                        SetFlag( Scb->Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );

                        UpdateDuplicate = TRUE;
                    }

                    NtfsWriteFileSizes( IrpContext,
                                        Scb,
                                        &Scb->Header.ValidDataLength.QuadPart,
                                        FALSE,
                                        TRUE,
                                        TRUE );

                    //
                    //  The attribute may have moved.  We will cleanup the attribute
                    //  context and look it up again.
                    //

                    NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                    NtfsInitializeAttributeContext( &AttrContext );

                    NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );
                    NtfsPinMappedAttribute( IrpContext, Vcb, &AttrContext );
                    Attribute = NtfsFoundAttribute( &AttrContext );
                }
            }

            AttributeSizeChange = Attribute->Form.Nonresident.MappingPairsOffset;

            if (Attribute->NameOffset != 0) {

                AttributeSizeChange = Attribute->NameOffset;
            }

            RtlCopyMemory( &NewAttribute, Attribute, AttributeSizeChange );
        }

        //
        //  Set the new attribute flags.
        //

        NewAttribute.Flags = NewAttributeFlags;

        //
        //  Now, log the changed attribute.
        //

        (VOID)NtfsWriteLog( IrpContext,
                            Vcb->MftScb,
                            NtfsFoundBcb( &AttrContext ),
                            UpdateResidentValue,
                            &NewAttribute,
                            AttributeSizeChange,
                            UpdateResidentValue,
                            Attribute,
                            AttributeSizeChange,
                            NtfsMftOffset( &AttrContext ),
                            PtrOffset( NtfsContainingFileRecord( &AttrContext ), Attribute),
                            0,
                            Vcb->BytesPerFileRecordSegment );

        //
        //  Change the attribute by calling the same routine called at restart.
        //

        NtfsRestartChangeValue( IrpContext,
                                NtfsContainingFileRecord( &AttrContext ),
                                PtrOffset( NtfsContainingFileRecord( &AttrContext ), Attribute ),
                                0,
                                &NewAttribute,
                                AttributeSizeChange,
                                FALSE );

        //
        //  See if we need to either add or remove a total allocated field.
        //

        if (ChangeTotalAllocated) {

            NtfsSetTotalAllocatedField( IrpContext,
                                        Scb,
                                        (USHORT) FlagOn( NewAttributeFlags,
                                                         ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ));
        }

        //
        //  If this is the main stream for a file we want to change the file attribute
        //  for this stream in both the standard information and duplicate
        //  information structure.
        //

        if (ChangeCompression &&
            (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA ) ||
             (Attribute->TypeCode == $INDEX_ALLOCATION))) {

            if (FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_COMPRESSED );

            } else {

                ClearFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
            }

            ASSERTMSG( "conflict with flush",
                        NtfsIsSharedFcb( Fcb ) ||
                        (Fcb->PagingIoResource != NULL &&
                        NtfsIsSharedFcbPagingIo( Fcb )) );

            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
            SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

            UpdateDuplicate = TRUE;
        }

        if (ChangeSparse &&
            FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_SPARSE ) &&
            !FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE )) {

            ASSERTMSG( "conflict with flush",
                       NtfsIsSharedFcb( Fcb ) ||
                       (Fcb->PagingIoResource != NULL &&
                       NtfsIsSharedFcbPagingIo( Fcb )) );

            SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE );
            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
            SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

            UpdateDuplicate = TRUE;
        }

        if (ChangeEncryption &&
            FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED ) &&
            !FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_ENCRYPTED )) {

            ASSERTMSG( "conflict with flush",
                       NtfsIsSharedFcb( Fcb ) ||
                       (Fcb->PagingIoResource != NULL &&
                       NtfsIsSharedFcbPagingIo( Fcb )) );

            SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
            SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

            UpdateDuplicate = TRUE;
        }

        //
        //  Now put the new compression values in the Scb.
        //

        Scb->CompressionUnit = NewCompressionUnit;
        Scb->CompressionUnitShift = NewCompressionUnitShift;
        Scb->AttributeFlags = NewAttributeFlags;

    } finally {

        DebugUnwind( NtfsModifyAttributeFlags );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
    }

    return UpdateDuplicate;
}


PFCB
NtfsInitializeFileInExtendDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PCUNICODE_STRING FileName,
    IN BOOLEAN ViewIndex,
    IN ULONG CreateIfNotExist
    )

/*++

Routine Description:

    This routine creates/opens a file in the $Extend directory, by file name,
    and returns an Fcb for the file.

Arguments:

    Vcb - Pointer to the Vcb for the volume

    FileName - Name of file to create in extend directory

    ViewIndex - Indicates that the file is a view index.

    CreateIfNotExist - Supplies TRUE if file should be created if it does not
                       already exist, or FALSE if file should not be created.

Return Value:

    Fcb file existed or was created, NULL if file did not exist and was not created.

--*/

{
    struct {
        FILE_NAME FileName;
        WCHAR FileNameChars[10];
    } FileNameAttr;
    FILE_REFERENCE FileReference;
    LONGLONG FileRecordOffset;
    PINDEX_ENTRY IndexEntry;
    PBCB FileRecordBcb = NULL;
    PBCB IndexEntryBcb = NULL;
    PBCB ParentSecurityBcb = NULL;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    UCHAR FileNameFlags;
    BOOLEAN FoundEntry;
    PFCB ExtendFcb = Vcb->ExtendDirectory->Fcb;
    PFCB Fcb = NULL;
    BOOLEAN AcquiredFcbTable = FALSE;
    BOOLEAN ReturnedExistingFcb = TRUE;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;

    PAGED_CODE();

    ASSERT( NtfsIsExclusiveScb( Vcb->ExtendDirectory ) );

    //
    //  Initialize the FileName.
    //

    ASSERT((FileName->Length / sizeof( WCHAR )) <= 10);
    RtlZeroMemory( &FileNameAttr, sizeof(FileNameAttr) );
    FileNameAttr.FileName.ParentDirectory = ExtendFcb->FileReference;
    FileNameAttr.FileName.FileNameLength = (UCHAR)(FileName->Length / sizeof( WCHAR ));
    RtlCopyMemory( FileNameAttr.FileName.FileName, FileName->Buffer, FileName->Length );

    NtfsInitializeAttributeContext( &Context );

    try {

        //
        //  Does the file already exist?
        //

        FoundEntry = NtfsFindIndexEntry( IrpContext,
                                         Vcb->ExtendDirectory,
                                         &FileNameAttr,
                                         FALSE,
                                         NULL,
                                         &IndexEntryBcb,
                                         &IndexEntry,
                                         NULL );

        //
        //  Only procede if we either found the file or are supposed to create it.
        //

        if (FoundEntry || CreateIfNotExist) {

            //
            //  If we did not find it, then start creating the file.
            //

            if (!FoundEntry) {

                //
                //  We will now try to do all of the on-disk operations.  This means first
                //  allocating and initializing an Mft record.  After that we create
                //  an Fcb to use to access this record.
                //

                FileReference = NtfsAllocateMftRecord( IrpContext, Vcb, FALSE );

                //
                //  Pin the file record we need.
                //

                NtfsPinMftRecord( IrpContext,
                                  Vcb,
                                  &FileReference,
                                  TRUE,
                                  &FileRecordBcb,
                                  &FileRecord,
                                  &FileRecordOffset );

                //
                //  Initialize the file record header.
                //

                NtfsInitializeMftRecord( IrpContext,
                                         Vcb,
                                         &FileReference,
                                         FileRecord,
                                         FileRecordBcb,
                                         FALSE );

            //
            //  If we found the file, then just get its FileReference out of the
            //  IndexEntry.
            //

            } else {

                FileReference = IndexEntry->FileReference;
            }

            //
            //  Now that we know the FileReference, we can create the Fcb.
            //

            NtfsAcquireFcbTable( IrpContext, Vcb );
            AcquiredFcbTable = TRUE;

            Fcb = NtfsCreateFcb( IrpContext,
                                 Vcb,
                                 FileReference,
                                 FALSE,
                                 ViewIndex,
                                 &ReturnedExistingFcb );

            //
            //  Reference the Fcb so it doesn't go away.
            //

            Fcb->ReferenceCount += 1;
            NtfsReleaseFcbTable( IrpContext, Vcb );
            AcquiredFcbTable = FALSE;

            //
            //  Try to do a fast acquire, otherwise we need to release
            //  the parent extend directory and acquire in the canonical order
            //  child and then parent.
            //  Use AcquireWithPaging for don't wait functionality. Since the flag
            //  isn't set despite its name this will only acquire main
            //

            if (!NtfsAcquireFcbWithPaging( IrpContext, Fcb, ACQUIRE_DONT_WAIT )) {

                NtfsReleaseScb( IrpContext, Vcb->ExtendDirectory );
                NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );
                NtfsAcquireExclusiveScb( IrpContext, Vcb->ExtendDirectory );
            }

            NtfsAcquireFcbTable( IrpContext, Vcb );
            Fcb->ReferenceCount -= 1;
            NtfsReleaseFcbTable( IrpContext, Vcb );

            //
            //  If we are creating this file, then carry on.
            //

            if (!FoundEntry) {

                BOOLEAN LogIt = FALSE;

                //
                //  Just copy the Security Id from the parent.
                //

                NtfsAcquireFcbSecurity( Fcb->Vcb );
                Fcb->SecurityId = ExtendFcb->SecurityId;
                ASSERT( Fcb->SharedSecurity == NULL );
                Fcb->SharedSecurity = ExtendFcb->SharedSecurity;
                Fcb->SharedSecurity->ReferenceCount++;
                NtfsReleaseFcbSecurity( Fcb->Vcb );

                //
                //  The changes to make on disk are first to create a standard information
                //  attribute.  We start by filling the Fcb with the information we
                //  know and creating the attribute on disk.
                //

                NtfsInitializeFcbAndStdInfo( IrpContext,
                                             Fcb,
                                             FALSE,
                                             ViewIndex,
                                             FALSE,
                                             FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                                             NULL );

                //
                //  Now link the file into the $Extend directory.
                //

                NtfsAddLink( IrpContext,
                             TRUE,
                             Vcb->ExtendDirectory,
                             Fcb,
                             (PFILE_NAME)&FileNameAttr,
                             &LogIt,
                             &FileNameFlags,
                             NULL,
                             NULL,
                             NULL );

                //
                //  Set this flag to indicate that the file is to be locked via the Scb
                //  pointers in the Vcb.
                //

                SetFlag( FileRecord->Flags, FILE_SYSTEM_FILE );

                //
                //  Log the file record.
                //

                FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                                Vcb->MftScb,
                                                FileRecordBcb,
                                                InitializeFileRecordSegment,
                                                FileRecord,
                                                FileRecord->FirstFreeByte,
                                                Noop,
                                                NULL,
                                                0,
                                                FileRecordOffset,
                                                0,
                                                0,
                                                Vcb->BytesPerFileRecordSegment );

            //
            //  Verify that the file record for this file is valid.
            //

            } else {

                ULONG CorruptHint;

                if (!NtfsLookupAttributeByCode( IrpContext,
                                                Fcb,
                                                &Fcb->FileReference,
                                                $STANDARD_INFORMATION,
                                                &Context ) ||

                    !NtfsCheckFileRecord( Vcb, NtfsContainingFileRecord( &Context ), &Fcb->FileReference, &CorruptHint )) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, &Fcb->FileReference, NULL );
                }
            }

            //
            //  Update Fcb fields from disk.
            //

            SetFlag( Fcb->FcbState, FCB_STATE_SYSTEM_FILE );
            NtfsUpdateFcbInfoFromDisk( IrpContext, TRUE, Fcb, NULL );
        }

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &Context );
        NtfsUnpinBcb( IrpContext, &FileRecordBcb );
        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );
        NtfsUnpinBcb( IrpContext, &ParentSecurityBcb );

        //
        //  On any kind of error, nuke the Fcb.
        //

        if (AbnormalTermination()) {

            //
            //  If some error caused us to abort, then delete
            //  the Fcb, because we are the only ones who will.
            //

            if (!ReturnedExistingFcb && Fcb) {

                if (!AcquiredFcbTable) {

                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    AcquiredFcbTable = TRUE;
                }
                NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

                ASSERT(!AcquiredFcbTable);
            }

            if (AcquiredFcbTable) {

                NtfsReleaseFcbTable( IrpContext, Vcb );
            }
        }
    }

    return Fcb;
}


VOID
NtfsFillBasicInfo (
    OUT PFILE_BASIC_INFORMATION Buffer,
    IN PSCB Scb
    )

/*++

Routine Description:

    This is the common routine which transfers data from the Scb/Fcb to the BasicInfo structure.

Arguments:

    Buffer - Pointer to structure to fill in.  Our caller has already validated it.

    Scb - Stream the caller has a handle to.

Return Value:

    None

--*/

{
    PFCB Fcb = Scb->Fcb;

    PAGED_CODE();

    //
    //  Zero the output buffer.
    //

    RtlZeroMemory( Buffer, sizeof( FILE_BASIC_INFORMATION ));

    //
    //  Fill in the basic information fields
    //

    Buffer->CreationTime.QuadPart = Fcb->Info.CreationTime;
    Buffer->LastWriteTime.QuadPart = Fcb->Info.LastModificationTime;
    Buffer->ChangeTime.QuadPart = Fcb->Info.LastChangeTime;
    Buffer->LastAccessTime.QuadPart = Fcb->CurrentLastAccess;

    //
    //  Capture the attributes from the Fcb except for the stream specific values.
    //  Also mask out any private Ntfs attribute flags.
    //

    Buffer->FileAttributes = Fcb->Info.FileAttributes;

    ClearFlag( Buffer->FileAttributes,
               (~FILE_ATTRIBUTE_VALID_FLAGS |
                FILE_ATTRIBUTE_COMPRESSED |
                FILE_ATTRIBUTE_TEMPORARY |
                FILE_ATTRIBUTE_SPARSE_FILE |
                FILE_ATTRIBUTE_ENCRYPTED) );

    //
    //  Pick up the sparse, encrypted and temp bits for this stream from the Scb.
    //

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE );
    }

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
    }

    if (FlagOn( Scb->ScbState, SCB_STATE_TEMPORARY )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY );
    }

    //
    //  If this is an index stream then mark it as a directory.  Capture the compressed
    //  state from either the Fcb or Scb.
    //

    if (Scb->AttributeTypeCode == $INDEX_ALLOCATION) {

        if (IsDirectory( &Fcb->Info ) || IsViewIndex( &Fcb->Info )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_DIRECTORY );

            //
            //  Capture the compression state from the Fcb.
            //

            SetFlag( Buffer->FileAttributes,
                     FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_COMPRESSED ));

        //
        //  Otherwise capture the value in the Scb itself.
        //

        } else if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
        }

    //
    //  In all other cases we can use the value in the Scb.
    //

    } else {

        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
        }
    }

    //
    //  If there are no flags set then explicitly set the NORMAL flag.
    //

    if (Buffer->FileAttributes == 0) {

        Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;
    }

    return;
}


VOID
NtfsFillStandardInfo (
    OUT PFILE_STANDARD_INFORMATION Buffer,
    IN PSCB Scb,
    IN PCCB Ccb OPTIONAL
    )

/*++

Routine Description:

    This is the common routine which transfers data from the Scb/Fcb to the StandardInfo structure.

Arguments:

    Buffer - Pointer to structure to fill in.  Our caller has already validated it.

    Scb - Stream the caller has a handle to.

    Ccb - Ccb for the user's open.

Return Value:

    None

--*/

{
    PFCB Fcb = Scb->Fcb;
    PAGED_CODE();

    //
    //  Zero out the output buffer.
    //

    RtlZeroMemory( Buffer, sizeof( FILE_STANDARD_INFORMATION ));

    //
    //  Fill in the buffer from the Scb, Fcb and Ccb.
    //

    //
    //  Return sizes only for non-index streams.
    //

    if ((Scb->AttributeTypeCode != $INDEX_ALLOCATION) ||
        (!IsDirectory( &Fcb->Info ) && !IsViewIndex( &Fcb->Info ))) {

        Buffer->AllocationSize.QuadPart = Scb->TotalAllocated;
        Buffer->EndOfFile = Scb->Header.FileSize;
    }

    Buffer->NumberOfLinks = Fcb->LinkCount;

    //
    //  Let's initialize these boolean fields.
    //

    Buffer->DeletePending = Buffer->Directory = FALSE;

    //
    //  Get the delete and directory flags from the Fcb/Scb state.  Note that
    //  the sense of the delete pending bit refers to the file if opened as
    //  file.  Otherwise it refers to the attribute only.
    //
    //  But only do the test if the Ccb has been supplied.
    //

    if (ARGUMENT_PRESENT( Ccb )) {

        if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

            if ((Scb->Fcb->LinkCount == 0) ||
                ((Ccb->Lcb != NULL) && FlagOn( Ccb->Lcb->LcbState, LCB_STATE_DELETE_ON_CLOSE ))) {

                Buffer->DeletePending = TRUE;
            }

            Buffer->Directory = BooleanIsDirectory( &Scb->Fcb->Info );

        } else {

            Buffer->DeletePending = BooleanFlagOn( Scb->ScbState, SCB_STATE_DELETE_ON_CLOSE );
        }

    } else {

        Buffer->Directory = BooleanIsDirectory( &Scb->Fcb->Info );
    }

    return;
}


VOID
NtfsFillNetworkOpenInfo (
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN PSCB Scb
    )

/*++

Routine Description:

    This is the common routine which transfers data from the Scb/Fcb to the NetworkOpenInfo structure.

Arguments:

    Buffer - Pointer to structure to fill in.  Our caller has already validated it.

    Scb - Stream the caller has a handle to.

Return Value:

    None

--*/

{
    PFCB Fcb = Scb->Fcb;

    PAGED_CODE();

    //
    //  Zero the output buffer.
    //

    RtlZeroMemory( Buffer, sizeof( FILE_NETWORK_OPEN_INFORMATION ));

    //
    //  Fill in the basic information fields
    //

    Buffer->CreationTime.QuadPart = Fcb->Info.CreationTime;
    Buffer->LastWriteTime.QuadPart = Fcb->Info.LastModificationTime;
    Buffer->ChangeTime.QuadPart = Fcb->Info.LastChangeTime;
    Buffer->LastAccessTime.QuadPart = Fcb->CurrentLastAccess;

    //
    //  Capture the attributes from the Fcb except for the stream specific values.
    //  Also mask out any private Ntfs attribute flags.
    //

    Buffer->FileAttributes = Fcb->Info.FileAttributes;

    ClearFlag( Buffer->FileAttributes,
               (~FILE_ATTRIBUTE_VALID_FLAGS |
                FILE_ATTRIBUTE_COMPRESSED |
                FILE_ATTRIBUTE_TEMPORARY |
                FILE_ATTRIBUTE_SPARSE_FILE |
                FILE_ATTRIBUTE_ENCRYPTED) );

    //
    //  Pick up the sparse, encrypted and temp bits for this stream from the Scb.
    //

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE );
    }

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
    }

    if (FlagOn( Scb->ScbState, SCB_STATE_TEMPORARY )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY );
    }

    //
    //  If this is an index stream then mark it as a directory.  Capture the compressed
    //  state from either the Fcb or Scb.
    //

    if (Scb->AttributeTypeCode == $INDEX_ALLOCATION) {

        if (IsDirectory( &Fcb->Info ) || IsViewIndex( &Fcb->Info )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_DIRECTORY );

            //
            //  Capture the compression state from the Fcb.
            //

            SetFlag( Buffer->FileAttributes,
                     FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_COMPRESSED ));

        //
        //  Otherwise capture the value in the Scb itself.
        //

        } else if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
        }

    //
    //  In all other cases we can use the value in the Scb.
    //

    } else {

        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
        }

        //
        //  In the non-index case we use the sizes from the Scb.
        //

        Buffer->AllocationSize.QuadPart = Scb->TotalAllocated;
        Buffer->EndOfFile = Scb->Header.FileSize;
    }

    //
    //  If there are no flags set then explicitly set the NORMAL flag.
    //

    if (Buffer->FileAttributes == 0) {

        Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;
    }

    return;
}


//
//  Internal support routine
//

BOOLEAN
NtfsLookupInFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFILE_REFERENCE BaseFileReference OPTIONAL,
    IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
    IN PCUNICODE_STRING QueriedName OPTIONAL,
    IN PVCN Vcn OPTIONAL,
    IN BOOLEAN IgnoreCase,
    IN PVOID QueriedValue OPTIONAL,
    IN ULONG QueriedValueLength,
    OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine attempts to find the fist occurrence of an attribute with
    the specified AttributeTypeCode and the specified QueriedName in the
    specified BaseFileReference.  If we find one, its attribute record is
    pinned and returned.

Arguments:

    Fcb - Requested file.

    BaseFileReference - The base entry for this file in the MFT.  Only needed
        on initial invocation.

    QueriedTypeCode - The attribute code to search for, if present.

    QueriedName - The attribute name to search for, if present.

    Vcn - Search for the nonresident attribute instance that has this Vcn

    IgnoreCase - Ignore case while comparing names.  Ignored if QueriedName
        not present.

    QueriedValue - The actual attribute value to search for, if present.

    QueriedValueLength - The length of the attribute value to search for.
        Ignored if QueriedValue is not present.

    Context - Describes the prior found attribute on invocation (if
        this was not the initial enumeration), and contains the next found
        attribute on return.

Return Value:

    BOOLEAN - True if we found an attribute, false otherwise.

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    BOOLEAN Result = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsLookupInFileRecord\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("BaseFileReference = %08I64x\n",
                        ARGUMENT_PRESENT(BaseFileReference) ?
                        NtfsFullSegmentNumber( BaseFileReference ) :
                        0xFFFFFFFFFFFF) );
    DebugTrace( 0, Dbg, ("QueriedTypeCode = %08lx\n", QueriedTypeCode) );
    DebugTrace( 0, Dbg, ("QueriedName = %08lx\n", QueriedName) );
    DebugTrace( 0, Dbg, ("IgnoreCase = %02lx\n", IgnoreCase) );
    DebugTrace( 0, Dbg, ("QueriedValue = %08lx\n", QueriedValue) );
    DebugTrace( 0, Dbg, ("QueriedValueLength = %08lx\n", QueriedValueLength) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );

    //
    //  Is this the initial enumeration?  If so start at the beginning.
    //

    if (Context->FoundAttribute.Bcb == NULL) {

        PBCB Bcb;
        PFILE_RECORD_SEGMENT_HEADER FileRecord;
        PATTRIBUTE_RECORD_HEADER TempAttribute;

        ASSERT(!ARGUMENT_PRESENT(QueriedName) || !ARGUMENT_PRESENT(QueriedValue));

        NtfsReadFileRecord( IrpContext,
                            Fcb->Vcb,
                            BaseFileReference,
                            &Bcb,
                            &FileRecord,
                            &TempAttribute,
                            &Context->FoundAttribute.MftFileOffset );

        Attribute = TempAttribute;

        //
        //  Initialize the found attribute context
        //

        Context->FoundAttribute.Bcb = Bcb;
        Context->FoundAttribute.FileRecord = FileRecord;

        //
        //  And show that we have neither found nor used the External
        //  Attributes List attribute.
        //

        Context->AttributeList.Bcb = NULL;
        Context->AttributeList.AttributeList = NULL;

        //
        //  The Usn Journal support uses the Usn Journal Fcb to look up $STANDARD_INFORMATION
        //  in an arbitrary file.  We will detect the case of $STANDARD_INFORMATION and the
        //  "wrong" Fcb and get out.
        //

        if (ARGUMENT_PRESENT( BaseFileReference ) &&
            !NtfsEqualMftRef( BaseFileReference, &Fcb->FileReference ) &&
            (QueriedTypeCode == $STANDARD_INFORMATION) &&
            (Attribute->TypeCode == $STANDARD_INFORMATION)) {

            //
            //  We found it.  Return it in the enumeration context.
            //

            Context->FoundAttribute.Attribute = Attribute;

            DebugTrace( 0, Dbg, ("Context->FoundAttribute.Attribute < %08lx\n",
                               Attribute ));
            DebugTrace( -1, Dbg, ("NtfsLookupInFileRecord -> TRUE (No code or SI)\n") );

            try_return( Result = TRUE );
        }

        //
        //  Scan to see if there is an attribute list, and if so, defer
        //  immediately to NtfsLookupExternalAttribute - we must guide the
        //  enumeration by the attribute list.
        //

        while (TempAttribute->TypeCode <= $ATTRIBUTE_LIST) {

            if (TempAttribute->RecordLength == 0) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            if (TempAttribute->TypeCode == $ATTRIBUTE_LIST) {

                ULONG AttributeListLength;
                PATTRIBUTE_LIST_CONTEXT Ex = &Context->AttributeList;

                Context->FoundAttribute.Attribute = TempAttribute;

                if ((QueriedTypeCode != $UNUSED) &&
                    (QueriedTypeCode == $ATTRIBUTE_LIST)) {

                    //
                    //  We found it.  Return it in the enumeration context.
                    //

                    DebugTrace( 0, Dbg, ("Context->FoundAttribute.Attribute < %08lx\n",
                                        TempAttribute) );
                    DebugTrace( -1, Dbg, ("NtfsLookupInFileRecord -> TRUE (attribute list)\n") );

                    try_return( Result = TRUE );
                }

                //
                //  Build up the context for the attribute list by hand here
                //  for efficiency, so that we can call NtfsMapAttributeValue.
                //

                Ex->AttributeList = TempAttribute;

                NtfsMapAttributeValue( IrpContext,
                                       Fcb,
                                       (PVOID *)&Ex->FirstEntry,
                                       &AttributeListLength,
                                       &Ex->Bcb,
                                       Context );

                Ex->Entry = Ex->FirstEntry;
                Ex->BeyondFinalEntry = Add2Ptr( Ex->FirstEntry, AttributeListLength );

                //
                //  If the list is non-resident then remember the correct Bcb for
                //  the list.
                //

                if (!NtfsIsAttributeResident( TempAttribute )) {

                    Ex->NonresidentListBcb = Ex->Bcb;
                    Ex->Bcb = Context->FoundAttribute.Bcb;
                    Context->FoundAttribute.Bcb = NULL;

                //
                //  Otherwise unpin the Bcb for the current attribute.
                //

                } else {

                    NtfsUnpinBcb( IrpContext, &Context->FoundAttribute.Bcb );
                }

                //
                //  We are now ready to iterate through the external attributes.
                //  The Context->FoundAttribute.Bcb being NULL signals
                //  NtfsLookupExternalAttribute that is should start at
                //  Context->External.Entry instead of the entry immediately following.
                //

                Result = NtfsLookupExternalAttribute( IrpContext,
                                                    Fcb,
                                                    QueriedTypeCode,
                                                    QueriedName,
                                                    Vcn,
                                                    IgnoreCase,
                                                    QueriedValue,
                                                    QueriedValueLength,
                                                    Context );

                try_return( NOTHING );
            }

            TempAttribute = NtfsGetNextRecord( TempAttribute );
            NtfsCheckRecordBound( TempAttribute, FileRecord, Fcb->Vcb->BytesPerFileRecordSegment );
        }

        if ((QueriedTypeCode == $UNUSED) ||
            ((QueriedTypeCode == $STANDARD_INFORMATION) &&
             (Attribute->TypeCode == $STANDARD_INFORMATION))) {

            //
            //  We found it.  Return it in the enumeration context.
            //

            Context->FoundAttribute.Attribute = Attribute;

            DebugTrace( 0, Dbg, ("Context->FoundAttribute.Attribute < %08lx\n",
                               Attribute ));
            DebugTrace( -1, Dbg, ("NtfsLookupInFileRecord -> TRUE (No code or SI)\n") );

            try_return( Result = TRUE );
        }

    } else {

        //
        //  Special case if the prior found attribute was $END, this is
        //  because we cannot search for the next entry after $END.
        //

        Attribute = Context->FoundAttribute.Attribute;

        if (!Context->FoundAttribute.AttributeDeleted) {
            Attribute = NtfsGetNextRecord( Attribute );
        }

        NtfsCheckRecordBound( Attribute, Context->FoundAttribute.FileRecord, Fcb->Vcb->BytesPerFileRecordSegment );
        Context->FoundAttribute.AttributeDeleted = FALSE;

        if (Attribute->TypeCode == $END) {

            DebugTrace( -1, Dbg, ("NtfsLookupInFileRecord -> FALSE ($END)\n") );

            try_return( Result = FALSE );
        }

        if (Attribute->RecordLength == 0) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        if (QueriedTypeCode == $UNUSED) {

            //
            //  We found it.  Return it in the enumeration context.
            //

            Context->FoundAttribute.Attribute = Attribute;

            DebugTrace( 0, Dbg, ("Context->FoundAttribute.Attribute < %08lx\n",
                                Attribute) );
            DebugTrace( -1, Dbg, ("NtfsLookupInFileRecord -> TRUE (No code)\n") );

            try_return( Result = TRUE );
        }
    }

    Result = NtfsFindInFileRecord( IrpContext,
                                   Attribute,
                                   &Context->FoundAttribute.Attribute,
                                   QueriedTypeCode,
                                   QueriedName,
                                   IgnoreCase,
                                   QueriedValue,
                                   QueriedValueLength );

    try_exit: NOTHING;

    DebugTrace( -1, Dbg, ("NtfsLookupInFileRecord ->\n") );
    return Result;
}


//
//  Internal support routine
//

BOOLEAN
NtfsFindInFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    OUT PATTRIBUTE_RECORD_HEADER *ReturnAttribute,
    IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
    IN PCUNICODE_STRING QueriedName OPTIONAL,
    IN BOOLEAN IgnoreCase,
    IN PVOID QueriedValue OPTIONAL,
    IN ULONG QueriedValueLength
    )

/*++

Routine Description:

    This routine looks up an attribute in a file record.  It returns
    TRUE if the attribute was found, or FALSE if not found.  If FALSE
    is returned, the return attribute pointer points to the spot where
    the described attribute should be inserted.  Thus this routine
    determines how attributes are collated within file records.

Arguments:

    Attribute - The attribute within the file record at which the search
                should begin.

    ReturnAttribute - Pointer to the found attribute if returning TRUE,
                      or to the position to insert the attribute if returning
                      FALSE.

    QueriedTypeCode - The attribute code to search for, if present.

    QueriedName - The attribute name to search for, if present.

    IgnoreCase - Ignore case while comparing names.  Ignored if QueriedName
        not present.

    QueriedValue - The actual attribute value to search for, if present.

    QueriedValueLength - The length of the attribute value to search for.
        Ignored if QueriedValue is not present.

Return Value:

    BOOLEAN - True if we found an attribute, false otherwise.

--*/

{
    PWCH UpcaseTable = IrpContext->Vcb->UpcaseTable;
    ULONG UpcaseTableSize = IrpContext->Vcb->UpcaseTableSize;

    PAGED_CODE();

    //
    //  Now walk through the base file record looking for the atttribute.  If
    //  the query is "exhausted", i.e., if a type code, attribute name, or
    //  value is encountered which is greater than the one we are querying for,
    //  then we return FALSE immediately out of this loop.  If an exact match
    //  is seen, we break, and return the match at the end of this routine.
    //  Otherwise we keep looping while the query is not exhausted.
    //
    //  IMPORTANT NOTE:
    //
    //  The exact semantics of this loop are important, as they determine the
    //  exact details of attribute ordering within the file record.  A change
    //  in the order of the tests within this loop CHANGES THE FILE STRUCTURE,
    //  and possibly makes older NTFS volumes unreadable.
    //

    while ( TRUE ) {

        //
        //  Mark this attribute position, since we may be returning TRUE
        //  or FALSE below.
        //

        *ReturnAttribute = Attribute;

        //
        //  Leave with the correct current position intact, if we hit the
        //  end or a greater attribute type code.
        //
        //  COLLATION RULE:
        //
        //      Attributes are ordered by increasing attribute type code.
        //

        if (QueriedTypeCode < Attribute->TypeCode) {

            DebugTrace( -1, Dbg, ("NtfsLookupInFileRecord->FALSE (Type Code)\n") );

            return FALSE;

        }

        if (Attribute->RecordLength == 0) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, NULL );
        }

        //
        //  If the attribute type code is a match, then need to check either
        //  the name or the value or return a match.
        //
        //  COLLATION RULE:
        //
        //      Within equal attribute type codes, attribute names are ordered
        //      by increasing lexigraphical order ignoring case.  If two names
        //      exist which are equal when case is ignored, they must not be
        //      equal when compared with exact case, and within such equal
        //      names they are ordered by increasing lexical value with exact
        //      case.
        //

        if (QueriedTypeCode == Attribute->TypeCode) {

            //
            //  Handle name-match case
            //

            if (ARGUMENT_PRESENT(QueriedName)) {

                UNICODE_STRING AttributeName;
                FSRTL_COMPARISON_RESULT Result;

                NtfsInitializeStringFromAttribute( &AttributeName, Attribute );

                //
                //  See if we have a name match.
                //

                if (NtfsAreNamesEqual( UpcaseTable,
                                       &AttributeName,
                                       QueriedName,
                                       IgnoreCase )) {

                    break;
                }

                //
                //  Compare the names ignoring case.
                //

                Result = NtfsCollateNames( UpcaseTable,
                                           UpcaseTableSize,
                                           QueriedName,
                                           &AttributeName,
                                           GreaterThan,
                                           TRUE);

                //
                //  Break out if the result is LessThan, or if the result
                //  is Equal to *and* the exact case compare yields LessThan.
                //

                if ((Result == LessThan) || ((Result == EqualTo) &&
                    (NtfsCollateNames( UpcaseTable,
                                       UpcaseTableSize,
                                       QueriedName,
                                       &AttributeName,
                                       GreaterThan,
                                       FALSE) == LessThan))) {

                    return FALSE;
                }

            //
            //  Handle value-match case
            //
            //  COLLATION RULE:
            //
            //      Values are collated by increasing values with unsigned-byte
            //      compares.  I.e., the first different byte is compared unsigned,
            //      and the value with the highest byte comes second.  If a shorter
            //      value is exactly equal to the first part of a longer value, then
            //      the shorter value comes first.
            //
            //      Note that for values which are actually Unicode strings, the
            //      collation is different from attribute name ordering above.  However,
            //      attribute ordering is visible outside the file system (you can
            //      query "openable" attributes), whereas the ordering of indexed values
            //      is not visible (for example you cannot query links).  In any event,
            //      the ordering of values must be considered up to the system, and
            //      *must* be considered nondetermistic from the standpoint of a user.
            //

            } else if (ARGUMENT_PRESENT( QueriedValue )) {

                ULONG Diff, MinLength;

                //
                //  Form the minimum of the ValueLength and the Attribute Value.
                //

                MinLength = Attribute->Form.Resident.ValueLength;

                if (QueriedValueLength < MinLength) {

                    MinLength = QueriedValueLength;
                }

                //
                //  Find the first different byte.
                //

                Diff = (ULONG)RtlCompareMemory( QueriedValue,
                                                NtfsGetValue(Attribute),
                                                MinLength );

                //
                //  The first substring was equal.
                //

                if (Diff == MinLength) {

                    //
                    //  If the two lengths are equal, then we have an exact
                    //  match.
                    //

                    if (QueriedValueLength == Attribute->Form.Resident.ValueLength) {

                        break;
                    }

                    //
                    //  Otherwise the shorter guy comes first; we can return
                    //  FALSE if the queried value is shorter.
                    //

                    if (QueriedValueLength < Attribute->Form.Resident.ValueLength) {

                        return FALSE;
                    }

                //
                //  Otherwise some byte was different.  Do an unsigned compare
                //  of that byte to determine the ordering.  Time to leave if
                //  the queried value byte is less.
                //

                } else if (*((PUCHAR)QueriedValue + Diff) <
                           *((PUCHAR)NtfsGetValue(Attribute) + Diff)) {

                    return FALSE;
                }

            //
            //  Otherwise we have a simple match on code
            //

            } else {

                break;
            }
        }

        Attribute = NtfsGetNextRecord( Attribute );
        NtfsCheckRecordBound( Attribute,
                              (ULONG_PTR)*ReturnAttribute & ~((ULONG_PTR)IrpContext->Vcb->BytesPerFileRecordSegment - 1),
                              IrpContext->Vcb->BytesPerFileRecordSegment );
    }



    return TRUE;
}


//
//  Internal support routine
//

BOOLEAN
NtfsLookupExternalAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
    IN PCUNICODE_STRING QueriedName OPTIONAL,
    IN PVCN Vcn OPTIONAL,
    IN BOOLEAN IgnoreCase,
    IN PVOID QueriedValue OPTIONAL,
    IN ULONG QueriedValueLength,
    OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine attempts to find the first occurrence of an attribute with
    the specified AttributeTypeCode and the specified QueriedName and Value
    among the external attributes described by the Context.  If we find one,
    its attribute record is pinned and returned.

Arguments:

    Fcb - Requested file.

    QueriedTypeCode - The attribute code to search for, if present.

    QueriedName - The attribute name to search for, if present.

    Vcn - Lookup nonresident attribute instance with this Vcn

    IgnoreCase - Ignore case while comparing names.  Ignored if QueriedName
        not present.

    QueriedValue - The actual attribute value to search for, if present.

    QueriedValueLength - The length of the attribute value to search for.
        Ignored if QueriedValue is not present.

    Context - Describes the prior found attribute on invocation (if
        this was not the initial enumeration), and contains the next found
        attribute on return.

Return Value:

    BOOLEAN - True if we found an attribute, false otherwise.

--*/

{
    PATTRIBUTE_LIST_ENTRY Entry, LastEntry;
    PWCH UpcaseTable = IrpContext->Vcb->UpcaseTable;
    ULONG UpcaseTableSize = IrpContext->Vcb->UpcaseTableSize;
    BOOLEAN Terminating = FALSE;
    BOOLEAN TerminateOnNext = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsLookupExternalAttribute\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("QueriedTypeCode = %08lx\n", QueriedTypeCode) );
    DebugTrace( 0, Dbg, ("QueriedName = %08lx\n", QueriedName) );
    DebugTrace( 0, Dbg, ("IgnoreCase = %02lx\n", IgnoreCase) );
    DebugTrace( 0, Dbg, ("QueriedValue = %08lx\n", QueriedValue) );
    DebugTrace( 0, Dbg, ("QueriedValueLength = %08lx\n", QueriedValueLength) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );

    //
    //  Check that our list is kosher.
    //

    if ((Context->AttributeList.Entry >= Context->AttributeList.BeyondFinalEntry) &&
        !Context->FoundAttribute.AttributeDeleted) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
    }

    //
    //  Is this the initial enumeration?  If so start at the beginning.
    //

    LastEntry = NULL;
    if (Context->FoundAttribute.Bcb == NULL) {

        Entry = Context->AttributeList.Entry;

    //
    //  Else set Entry and LastEntry appropriately.
    //

    } else if (!Context->FoundAttribute.AttributeDeleted) {

        LastEntry = Context->AttributeList.Entry;
        Entry = NtfsGetNextRecord( LastEntry );

    } else {

        Entry = Context->AttributeList.Entry;
        Context->FoundAttribute.AttributeDeleted = FALSE;

        //
        //  If we are beyond the attribute list, we return false.  This will
        //  happen in the case where have removed an attribute record and
        //  there are no entries left in the attribute list.
        //

        if (Context->AttributeList.Entry >= Context->AttributeList.BeyondFinalEntry) {

            //
            //  In case the caller is doing an insert, we will position him at the end
            //  of the first file record, an always try to insert new attributes there.
            //

            NtfsUnpinBcb( IrpContext, &Context->FoundAttribute.Bcb );

            if (QueriedTypeCode != $UNUSED) {

                NtfsReadFileRecord( IrpContext,
                                    Fcb->Vcb,
                                    &Fcb->FileReference,
                                    &Context->FoundAttribute.Bcb,
                                    &Context->FoundAttribute.FileRecord,
                                    &Context->FoundAttribute.Attribute,
                                    &Context->FoundAttribute.MftFileOffset );

                //
                //  If returning FALSE, then take the time to really find the
                //  correct position in the file record for a subsequent insert.
                //

                NtfsFindInFileRecord( IrpContext,
                                      Context->FoundAttribute.Attribute,
                                      &Context->FoundAttribute.Attribute,
                                      QueriedTypeCode,
                                      QueriedName,
                                      IgnoreCase,
                                      QueriedValue,
                                      QueriedValueLength );
            }

            DebugTrace( -1, Dbg, ("NtfsLookupExternalAttribute -> FALSE\n") );

            return FALSE;
        }
    }

    //
    //  Now walk through the entries looking for an atttribute.
    //

    while (TRUE) {

        PATTRIBUTE_RECORD_HEADER Attribute;

        UNICODE_STRING EntryName;
        UNICODE_STRING AttributeName;

        PATTRIBUTE_LIST_ENTRY NextEntry;

        BOOLEAN CorrespondingAttributeFound;

        //
        //  Check to see if we are now pointing beyond the final entry
        //  and if so fall in to the loop to terminate pointing just
        //  after the last entry.
        //

        if (Entry >= Context->AttributeList.BeyondFinalEntry) {

            Terminating = TRUE;
            TerminateOnNext = TRUE;
            Entry = Context->AttributeList.Entry;

        } else {

            NtfsCheckRecordBound( Entry,
                                  Context->AttributeList.FirstEntry,
                                  PtrOffset( Context->AttributeList.FirstEntry,
                                             Context->AttributeList.BeyondFinalEntry ));

            if (Entry->RecordLength == 0) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            NextEntry = NtfsGetNextRecord( Entry );
        }

        Context->AttributeList.Entry = Entry;

        //
        //  Compare the type codes.  The external attribute entry list is
        //  ordered by type code, so if the queried type code is less than
        //  the entry type code we continue the while(), if it is
        //  greater than we break out of the while() and return failure.
        //  If equal, we move on to compare names.
        //

        if ((QueriedTypeCode != $UNUSED) &&
            !Terminating &&
            (QueriedTypeCode != Entry->AttributeTypeCode)) {

            if (QueriedTypeCode > Entry->AttributeTypeCode) {

                Entry = NextEntry;
                continue;

            //
            //  Set up to terminate on seeing a higher type code.
            //

            } else {

                Terminating = TRUE;
            }
        }

        //
        //  At this point we are OK by TypeCode, compare names.
        //

        EntryName.Length = EntryName.MaximumLength = Entry->AttributeNameLength * sizeof( WCHAR );
        EntryName.Buffer = Add2Ptr( Entry, Entry->AttributeNameOffset );

        if (ARGUMENT_PRESENT( QueriedName ) && !Terminating) {

            FSRTL_COMPARISON_RESULT Result;

            //
            //  See if we have a name match.
            //

            if (!NtfsAreNamesEqual( UpcaseTable,
                                    &EntryName,
                                    QueriedName,
                                    IgnoreCase )) {

                //
                //  Compare the names ignoring case.
                //

                Result = NtfsCollateNames( UpcaseTable,
                                           UpcaseTableSize,
                                           QueriedName,
                                           &EntryName,
                                           GreaterThan,
                                           TRUE);

                //
                //  Break out if the result is LessThan, or if the result
                //  is Equal to *and* the exact case compare yields LessThan.
                //

                if ((Result == LessThan) || ((Result == EqualTo) &&
                    (NtfsCollateNames( UpcaseTable,
                                       UpcaseTableSize,
                                       QueriedName,
                                       &EntryName,
                                       GreaterThan,
                                       FALSE) == LessThan))) {

                    Terminating = TRUE;

                } else {

                    Entry = NextEntry;
                    continue;
                }
            }
        }

        //
        //  Now search for the right Vcn range, if specified.  If we were passed a
        //  Vcn then look for the matching range in the current attribute.  In some
        //  cases we may be looking for the lowest range in the following complete
        //  attribute.  In those cases skip forward.
        //

        if (ARGUMENT_PRESENT( Vcn ) && !Terminating) {

            //
            //  Skip to the next attribute record under the following conditions.
            //
            //      1 - We are already past the Vcn point we are looking for in the current
            //          attribute.  Typically this happens when the caller is looking for
            //          the first attribute record for each of the attributes in the file.
            //
            //      2 - The desired Vcn for the current attribute falls in one of the
            //          subsequent attribute records.
            //

            if ((Entry->LowestVcn > *Vcn) ||

                ((NextEntry < Context->AttributeList.BeyondFinalEntry) &&
                 (NextEntry->LowestVcn <= *Vcn) &&
                 (NextEntry->AttributeTypeCode == Entry->AttributeTypeCode) &&
                 (NextEntry->AttributeNameLength == Entry->AttributeNameLength) &&
                 (RtlEqualMemory( Add2Ptr( NextEntry, NextEntry->AttributeNameOffset ),
                                  Add2Ptr( Entry, Entry->AttributeNameOffset ),
                                  Entry->AttributeNameLength * sizeof( WCHAR ))))) {

                Entry = NextEntry;
                continue;
            }
        }

        //
        //  Now we are also OK by name and Vcn, so now go find the attribute and
        //  compare against value, if specified.
        //

        if ((LastEntry == NULL) ||
            !NtfsEqualMftRef( &LastEntry->SegmentReference, &Entry->SegmentReference )) {

            PFILE_RECORD_SEGMENT_HEADER FileRecord;

            NtfsUnpinBcb( IrpContext, &Context->FoundAttribute.Bcb );

            NtfsReadFileRecord( IrpContext,
                                Fcb->Vcb,
                                &Entry->SegmentReference,
                                &Context->FoundAttribute.Bcb,
                                &FileRecord,
                                &Attribute,
                                &Context->FoundAttribute.MftFileOffset );

            Context->FoundAttribute.FileRecord = FileRecord;

        //
        //  If we already have the right record pinned, reload this pointer.
        //

        } else {

            Attribute = NtfsFirstAttribute( Context->FoundAttribute.FileRecord );
        }

        //
        //  Now quickly loop through looking for the correct attribute
        //  instance.
        //

        CorrespondingAttributeFound = FALSE;

        while (TRUE) {

            //
            //  Check that we can safely access this attribute.
            //

            NtfsCheckRecordBound( Attribute,
                                  Context->FoundAttribute.FileRecord,
                                  Fcb->Vcb->BytesPerFileRecordSegment );

            //
            //  Exit the loop if we have reached the $END record.
            //

            if (Attribute->TypeCode == $END) {

                break;
            }

            //
            //  Check that the attribute has a non-zero length.
            //

            if (Attribute->RecordLength == 0) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            if (Entry->Instance == Attribute->Instance) {

                //
                //  Well, the attribute list saved us from having to compare
                //  type code and name as we went through this file record,
                //  however now that we have found our attribute by its
                //  instance number, we will do a quick check to see that
                //  we got the right one.  Else the file is corrupt.
                //

                if (Entry->AttributeTypeCode != Attribute->TypeCode) {
                    break;
                }

                if (ARGUMENT_PRESENT( QueriedName )) {

                    NtfsInitializeStringFromAttribute( &AttributeName, Attribute );

                    if (!NtfsAreNamesEqual( UpcaseTable, &AttributeName, &EntryName, FALSE )) {
                        break;
                    }
                }

                //
                //  Show that we correctly found the attribute described in
                //  the attribute list.
                //

                CorrespondingAttributeFound = TRUE;

                Context->FoundAttribute.Attribute = Attribute;

                //
                //  Now we may just be here because we are terminating the
                //  scan on seeing the end, a higher attribute code, or a
                //  higher name.  If so, return FALSE here.
                //

                if (Terminating) {

                    //
                    //  If we hit the end of the attribute list, then we
                    //  are supposed to terminate after advancing the
                    //  attribute list entry.
                    //

                    if (TerminateOnNext) {

                        Context->AttributeList.Entry = NtfsGetNextRecord(Entry);
                    }

                    //
                    //  In case the caller is doing an insert, we will position him at the end
                    //  of the first file record, an always try to insert new attributes there.
                    //

                    NtfsUnpinBcb( IrpContext, &Context->FoundAttribute.Bcb );

                    if (QueriedTypeCode != $UNUSED) {

                        NtfsReadFileRecord( IrpContext,
                                            Fcb->Vcb,
                                            &Fcb->FileReference,
                                            &Context->FoundAttribute.Bcb,
                                            &Context->FoundAttribute.FileRecord,
                                            &Context->FoundAttribute.Attribute,
                                            &Context->FoundAttribute.MftFileOffset );

                        //
                        //  If returning FALSE, then take the time to really find the
                        //  correct position in the file record for a subsequent insert.
                        //

                        NtfsFindInFileRecord( IrpContext,
                                              Context->FoundAttribute.Attribute,
                                              &Context->FoundAttribute.Attribute,
                                              QueriedTypeCode,
                                              QueriedName,
                                              IgnoreCase,
                                              QueriedValue,
                                              QueriedValueLength );
                    }

                    DebugTrace( 0, Dbg, ("Context->FoundAttribute.Attribute < %08lx\n",
                                        Attribute) );
                    DebugTrace( -1, Dbg, ("NtfsLookupExternalAttribute -> FALSE\n") );

                    return FALSE;
                }

                //
                //  Now compare the value, if so queried.
                //

                if (!ARGUMENT_PRESENT( QueriedValue ) ||
                    NtfsEqualAttributeValue( Attribute,
                                             QueriedValue,
                                             QueriedValueLength ) ) {

                    //
                    //  It matches.  Return it in the enumeration context.
                    //

                    DebugTrace( 0, Dbg, ("Context->FoundAttribute.Attribute < %08lx\n",
                                        Attribute ));
                    DebugTrace( -1, Dbg, ("NtfsLookupExternalAttribute -> TRUE\n") );


                    //
                    //  Do basic attribute consistency check
                    //

                    if ((NtfsIsAttributeResident( Attribute )) &&
                        (Attribute->Form.Resident.ValueOffset + Attribute->Form.Resident.ValueLength > Attribute->RecordLength)) {
                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                    }

                    return TRUE;
                }
            }

            //
            //  Get the next attribute, and continue.
            //

            Attribute = NtfsGetNextRecord( Attribute );
        }

        //
        //  Did we even find the attribute corresponding to the entry?
        //  If not, something is messed up.  Raise file corrupt error.
        //

        if (!CorrespondingAttributeFound) {

            //
            //  For the moment, ASSERT this falsehood so that we may have
            //  a chance to peek before raising.
            //

            ASSERT( CorrespondingAttributeFound );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        Entry = NtfsGetNextRecord( Entry );
    }
}


//
//  Internal support routine
//

BOOLEAN
NtfsGetSpaceForAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG Length,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine gets space for a new attribute record at the position indicated
    in the Context structure.  As required, it will move attributes around,
    allocate an additional record in the Mft, or convert some other existing
    attribute to nonresident form.  The caller should already have checked if
    the new attribute he is inserting should be stored resident or nonresident.

    On return, it is invalid to continue to use any previously-retrieved pointers,
    Bcbs, or other position-dependent information retrieved from the Context
    structure, as any of these values are liable to change.  The file record in
    which the space has been found will already be pinned.

    Note, this routine DOES NOT actually make space for the attribute, it only
    verifies that sufficient space is there.  The caller may call
    NtfsRestartInsertAttribute to actually insert the attribute in place.

Arguments:

    Fcb - Requested file.

    Length - Quad-aligned length required in bytes.

    Context - Describes the position for the new attribute, as returned from
              the enumeration which failed to find an existing occurrence of
              the attribute.  This pointer will either be pointing to some
              other attribute in the record, or to the first free quad-aligned
              byte if the new attribute is to go at the end.

Return Value:

    FALSE - if a major move was necessary, and the caller should look up
            its desired position again and call back.
    TRUE - if the space was created

--*/

{
    PATTRIBUTE_RECORD_HEADER NextAttribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGetSpaceForAttribute\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("Length = %08lx\n", Length) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );

    ASSERT( IsQuadAligned( Length ) );

    NextAttribute = NtfsFoundAttribute( Context );
    FileRecord = NtfsContainingFileRecord( Context );

    //
    //  Make sure the buffer is pinned.
    //

    NtfsPinMappedAttribute( IrpContext, Fcb->Vcb, Context );

    //
    //  If the space is not there now, then make room and return with FALSE
    //

    if ((FileRecord->BytesAvailable - FileRecord->FirstFreeByte) < Length ) {

        MakeRoomForAttribute( IrpContext, Fcb, Length, Context );

        DebugTrace( -1, Dbg, ("NtfsGetSpaceForAttribute -> FALSE\n") );
        return FALSE;
    }

    DebugTrace( -1, Dbg, ("NtfsGetSpaceForAttribute -> TRUE\n") );
    return TRUE;
}


//
//  Internal support routine
//

BOOLEAN
NtfsChangeAttributeSize (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG Length,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine adjustss the space occupied by the current attribute record
    in the Context structure.  As required, it will move attributes around,
    allocate an additional record in the Mft, or convert some other existing
    attribute to nonresident form.  The caller should already have checked if
    the current attribute he is inserting should rather be converted to
    nonresident.

    When done, this routine has updated any file records whose allocation was
    changed, and also the RecordLength field in the adjusted attribute.  No
    other attribute fields are updated.

    On return, it is invalid to continue to use any previously-retrieved pointers,
    Bcbs, or other position-dependent information retrieved from the Context
    structure, as any of these values are liable to change.  The file record in
    which the space has been found will already be pinned.

Arguments:

    Fcb - Requested file.

    Length - New quad-aligned length of attribute record in bytes

    Context - Describes the current attribute.

Return Value:

    FALSE - if a major move was necessary, and the caller should look up
            its desired position again and call back.
    TRUE - if the space was created

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    LONG SizeChange;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsChangeAttributeSize\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("Length = %08lx\n", Length) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );

    ASSERT( IsQuadAligned( Length ) );

    Attribute = NtfsFoundAttribute( Context );
    FileRecord = NtfsContainingFileRecord( Context );

    //
    //  Make sure the buffer is pinned.
    //

    NtfsPinMappedAttribute( IrpContext, Fcb->Vcb, Context );

    //
    //  Calculate the change in attribute record size.
    //

    ASSERT( IsQuadAligned( Attribute->RecordLength ) );
    SizeChange = Length - Attribute->RecordLength;

    //
    //  If there is not currently enough space, then we have to make room
    //  and return FALSE to our caller.
    //

    if ( (LONG)(FileRecord->BytesAvailable - FileRecord->FirstFreeByte) < SizeChange ) {

        MakeRoomForAttribute( IrpContext, Fcb, SizeChange, Context );

        DebugTrace( -1, Dbg, ("NtfsChangeAttributeSize -> FALSE\n") );

        return FALSE;
    }

    DebugTrace( -1, Dbg, ("NtfsChangeAttributeSize -> TRUE\n") );

    return TRUE;
}


//
//  Internal support routine
//

VOID
MakeRoomForAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG SizeNeeded,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine attempts to make additional room for a new attribute or
    a growing attribute in a file record.  The algorithm is as follows.

    First continuously loop through the record looking at the largest n
    attributes, from the largest down, to see which one of these attributes
    is big enough to move, and which one qualifies for one of the following
    actions:

        1.  For an index root attribute, the indexing package may be called
            to "push" the index root, i.e., add another level to the BTree
            leaving only an end index record in the root.

        2.  For a resident attribute which is allowed to be made nonresident,
            the attribute is made nonresident, leaving only run information
            in the root.

        3.  If the attribute is already nonresident, then it can be moved to
            a separate file record.

    If none of the above operations can be performed, or not enough free space
    is recovered, then as a last resort the file record is split in two.  This
    would typically indicate that the file record is populated with a large
    number of small attributes.

    The first time step 3 above or a split of the file record occurs, the
    attribute list must be created for the file.

Arguments:

    Fcb - Requested file.

    SizeNeeded - Supplies the total amount of free space needed, in bytes.

    Context - Describes the insertion point for the attribute which does
              not fit.  NOTE -- This context is not valid on return.

Return Value:

    None

--*/

{
    PATTRIBUTE_RECORD_HEADER LargestAttributes[MAX_MOVEABLE_ATTRIBUTES];
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    ULONG i;
    PVCB Vcb = Fcb->Vcb;

    PAGED_CODE();

    //
    //  Here is the current threshhold at which a move of an attribute will
    //  be considered.
    //

    FileRecord = NtfsContainingFileRecord( Context );

    //
    //  Find the largest attributes for this file record.
    //

    FindLargestAttributes( FileRecord, MAX_MOVEABLE_ATTRIBUTES, LargestAttributes );

    //
    //  Now loop from largest to smallest of the largest attributes,
    //  and see if there is something we can do.
    //

    for (i = 0; i < MAX_MOVEABLE_ATTRIBUTES; i += 1) {

        Attribute = LargestAttributes[i];

        //
        //  Look to the next attribute if there is no attribute at this array
        //  position.
        //

        if (Attribute == NULL) {

            continue;

        //
        //  If this is the Mft then any attribute that is 'BigEnoughToMove'
        //  except $DATA attributes outside the base file record.
        //  We need to keep those where they are in order to enforce the
        //  boot-strap mapping.
        //

        } else if (Fcb == Vcb->MftScb->Fcb) {

            if (Attribute->TypeCode == $DATA &&
                ((*(PLONGLONG) &FileRecord->BaseFileRecordSegment != 0) ||
                 (Attribute->RecordLength < Vcb->BigEnoughToMove))) {

                continue;
            }

        //
        //  Any attribute in a non-Mft file which is 'BigEnoughToMove' can
        //  be considered.  We also accept an $ATTRIBUTE_LIST attribute
        //  in a non-Mft file which must go non-resident in order for
        //  the attribute name to fit.  Otherwise we could be trying to
        //  add an attribute with a large name into the base file record.
        //  We will need space to store the name twice, once for the
        //  attribute list entry and once in the attribute.  This can take
        //  up 1024 bytes by itself.  We want to force the attribute list
        //  non-resident first so that the new attribute will fit.  We
        //  look at whether the attribute list followed by just the new data
        //  will fit in the file record.
        //

        } else if (Attribute->RecordLength < Vcb->BigEnoughToMove) {

            if ((Attribute->TypeCode != $ATTRIBUTE_LIST) ||
                ((PtrOffset( FileRecord, Attribute ) + Attribute->RecordLength + SizeNeeded + sizeof( LONGLONG)) <= FileRecord->BytesAvailable)) {

                continue;
            }
        }

        //
        //  If this attribute is an index root, then we can just call the
        //  indexing support to allocate a new index buffer and push the
        //  current resident contents down.
        //

        if (Attribute->TypeCode == $INDEX_ROOT) {

            PSCB IndexScb;
            UNICODE_STRING IndexName;

            //
            //  Don't push the root now if we previously deferred pushing the root.
            //  Set the IrpContext flag to indicate we should do the push
            //  and raise CANT_WAIT.
            //

            if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_PUSH )) {

                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_FORCE_PUSH );
                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }

            IndexName.Length =
            IndexName.MaximumLength = (USHORT)Attribute->NameLength << 1;
            IndexName.Buffer = Add2Ptr( Attribute, Attribute->NameOffset );

            IndexScb = NtfsCreateScb( IrpContext,
                                      Fcb,
                                      $INDEX_ALLOCATION,
                                      &IndexName,
                                      FALSE,
                                      NULL );

            NtfsPushIndexRoot( IrpContext, IndexScb );

            return;

        //
        //  Otherwise, if this is a resident attribute which can go nonresident,
        //  then make it nonresident now.
        //

        } else if ((Attribute->FormCode == RESIDENT_FORM) &&
                   !FlagOn(NtfsGetAttributeDefinition(Vcb,
                                                      Attribute->TypeCode)->Flags,
                           ATTRIBUTE_DEF_MUST_BE_RESIDENT)) {

            NtfsConvertToNonresident( IrpContext, Fcb, Attribute, FALSE, NULL );

            return;

        //
        //  Finally, if the attribute is nonresident already, move it to its
        //  own record unless it is an attribute list.
        //

        } else if ((Attribute->FormCode == NONRESIDENT_FORM)
                   && (Attribute->TypeCode != $ATTRIBUTE_LIST)) {

            LONGLONG MftFileOffset;

            MftFileOffset = Context->FoundAttribute.MftFileOffset;

            MoveAttributeToOwnRecord( IrpContext,
                                      Fcb,
                                      Attribute,
                                      Context,
                                      NULL,
                                      NULL );

            return;
        }
    }

    //
    //  If we get here, it is because we failed to find enough space above.
    //  Our last resort is to split into two file records, and this has
    //  to work.  We should never reach this point for the Mft.
    //

    if (Fcb == Vcb->MftScb->Fcb) {

        NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
    }

    SplitFileRecord( IrpContext, Fcb, SizeNeeded, Context );
}


//
//  Internal support routine
//

VOID
FindLargestAttributes (
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG Number,
    OUT PATTRIBUTE_RECORD_HEADER *AttributeArray
    )

/*++

Routine Description:

    This routine returns the n largest attributes from a file record in an
    array, ordered from largest to smallest.

Arguments:

    FileRecord - Supplies file record to scan for largest attributes.

    Number - Supplies the number of entries in the array.

    AttributeArray - Supplies the array which is to receive pointers to the
                     largest attributes.  This array must be zeroed prior
                     to calling this routine.

Return Value:

    None

--*/

{
    ULONG i, j;
    PATTRIBUTE_RECORD_HEADER Attribute;

    PAGED_CODE();

    RtlZeroMemory( AttributeArray, Number * sizeof(PATTRIBUTE_RECORD_HEADER) );

    Attribute = Add2Ptr( FileRecord, FileRecord->FirstAttributeOffset );

    while (Attribute->TypeCode != $END) {

        for (i = 0; i < Number; i++) {

            if ((AttributeArray[i] == NULL)

                    ||

                (AttributeArray[i]->RecordLength < Attribute->RecordLength)) {

                for (j = Number - 1; j != i; j--) {

                    AttributeArray[j] = AttributeArray[j-1];
                }

                AttributeArray[i] = Attribute;
                break;
            }
        }

        Attribute = Add2Ptr( Attribute, Attribute->RecordLength );
    }
}


//
//  Internal support routine
//

LONGLONG
MoveAttributeToOwnRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context,
    OUT PBCB *NewBcb OPTIONAL,
    OUT PFILE_RECORD_SEGMENT_HEADER *NewFileRecord OPTIONAL
    )

/*++

Routine Description:

    This routine may be called to move a particular attribute to a separate
    file record.  If the file does not already have an attribute list, then
    one is created (else it is updated).

Arguments:

    Fcb - Requested file.

    Attribute - Supplies a pointer to the attribute which is to be moved.

    Context - Supplies a pointer to a context which was used to look up
              another attribute in the same file record.  If this is an Mft
              $DATA split we will point to the part that was split out of the
              first file record on return.  The call from NtfsAddAttributeAllocation
              depends on this.

    NewBcb - If supplied, returns the Bcb address for the file record
             that the attribute was moved to.  NewBcb and NewFileRecord must
             either both be specified or neither specified.

    NewFileRecord - If supplied, returns a pointer to the file record
                    that the attribute was moved to.  The caller may assume
                    that the moved attribute is the first one in the file
                    record.  NewBcb and NewFileRecord must either both be
                    specified or neither specified.

Return Value:

    LONGLONG - Segment reference number of new record without a sequence number.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT ListContext;
    ATTRIBUTE_ENUMERATION_CONTEXT MoveContext;
    PFILE_RECORD_SEGMENT_HEADER FileRecord1, FileRecord2;
    PATTRIBUTE_RECORD_HEADER Attribute2;
    BOOLEAN FoundListContext;
    MFT_SEGMENT_REFERENCE Reference2;
    LONGLONG MftRecordNumber2;
    WCHAR NameBuffer[8];
    UNICODE_STRING AttributeName;
    ATTRIBUTE_TYPE_CODE AttributeTypeCode;
    VCN LowestVcn;
    BOOLEAN IsNonresident = FALSE;
    PBCB Bcb = NULL;
    PATTRIBUTE_TYPE_CODE NewEnd;
    PVCB Vcb = Fcb->Vcb;
    ULONG NewListSize = 0;
    BOOLEAN MftData = FALSE;
    PATTRIBUTE_RECORD_HEADER OldPosition = NULL;

    PAGED_CODE();

    //
    //  Make sure the attribute is pinned.
    //

    NtfsPinMappedAttribute( IrpContext,
                            Vcb,
                            Context );

    //
    //  See if we are being asked to move the Mft Data.
    //

    if ((Fcb == Vcb->MftScb->Fcb) && (Attribute->TypeCode == $DATA)) {

        MftData = TRUE;
    }

    NtfsInitializeAttributeContext( &ListContext );
    NtfsInitializeAttributeContext( &MoveContext );
    FileRecord1 = NtfsContainingFileRecord(Context);

    //
    //  Save a description of the attribute to help us look it up
    //  again, and to make clones if necessary.
    //

    ASSERT( IsQuadAligned( Attribute->RecordLength ) );
    AttributeTypeCode = Attribute->TypeCode;
    AttributeName.Length =
    AttributeName.MaximumLength = (USHORT)Attribute->NameLength << 1;
    AttributeName.Buffer = NameBuffer;

    if (AttributeName.Length > sizeof(NameBuffer)) {

        AttributeName.Buffer = NtfsAllocatePool( NonPagedPool, AttributeName.Length );
    }

    RtlCopyMemory( AttributeName.Buffer,
                   Add2Ptr(Attribute, Attribute->NameOffset),
                   AttributeName.Length );

    if (Attribute->FormCode == NONRESIDENT_FORM) {

        IsNonresident = TRUE;
        LowestVcn = Attribute->Form.Nonresident.LowestVcn;
    }

    try {

        //
        //  Lookup the list context so that we know where it is at.
        //

        FoundListContext =
          NtfsLookupAttributeByCode( IrpContext,
                                     Fcb,
                                     &Fcb->FileReference,
                                     $ATTRIBUTE_LIST,
                                     &ListContext );

        //
        //  If we do not already have an attribute list, then calculate
        //  how big it must be.  Note, there must only be one file record
        //  at this point.
        //

        if (!FoundListContext) {

            ASSERT( FileRecord1 == NtfsContainingFileRecord(&ListContext) );

            NewListSize = GetSizeForAttributeList( FileRecord1 );

        //
        //  Now if the attribute list already exists, we have to look up
        //  the first one we are going to move in order to update the
        //  attribute list later.
        //

        } else {

            if (!NtfsLookupAttributeByName( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            Attribute->TypeCode,
                                            &AttributeName,
                                            IsNonresident ?
                                              &LowestVcn :
                                              NULL,
                                            FALSE,
                                            &MoveContext )) {

                ASSERT( FALSE );
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            ASSERT(Attribute == NtfsFoundAttribute(&MoveContext));
        }

        //
        //  Allocate a new file record and move the attribute over.
        //

        FileRecord2 = NtfsCloneFileRecord( IrpContext, Fcb, MftData, &Bcb, &Reference2 );

        //
        //  Remember the file record number for the new file record.
        //

        MftRecordNumber2 = NtfsFullSegmentNumber( &Reference2 );

        Attribute2 = Add2Ptr( FileRecord2, FileRecord2->FirstAttributeOffset );
        RtlCopyMemory( Attribute2, Attribute, (ULONG)Attribute->RecordLength );
        Attribute2->Instance = FileRecord2->NextAttributeInstance++;
        NewEnd = Add2Ptr( Attribute2, Attribute2->RecordLength );
        *NewEnd = $END;
        FileRecord2->FirstFreeByte = PtrOffset(FileRecord2, NewEnd)
                                     + QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE ));

        //
        //  If this is the Mft Data attribute, we cannot really move it, we
        //  have to move all but the first part of it.
        //

        if (MftData) {

            PCHAR MappingPairs;
            ULONG NewSize;
            VCN OriginalLastVcn;
            VCN LastVcn;
            LONGLONG SavedFileSize = Attribute->Form.Nonresident.FileSize;
            LONGLONG SavedValidDataLength = Attribute->Form.Nonresident.ValidDataLength;
            PNTFS_MCB Mcb = &Vcb->MftScb->Mcb;

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );

            if (!NtfsLookupAttributeByCode( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            $DATA,
                                            Context )) {

                ASSERT( FALSE );
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Calculate the number of clusters in the Mft up to (possibly past) the
            //  first user file record, and decrement to get LastVcn to stay in first
            //  file record.
            //

            LastVcn = LlClustersFromBytes( Vcb,
                                           FIRST_USER_FILE_NUMBER *
                                           Vcb->BytesPerFileRecordSegment ) - 1;
            OriginalLastVcn = Attribute->Form.Nonresident.HighestVcn;

            //
            //  Now truncate the first Mft record.
            //

            NtfsDeleteAttributeAllocation( IrpContext,
                                           Vcb->MftScb,
                                           TRUE,
                                           &LastVcn,
                                           Context,
                                           FALSE );

            //
            //  Now get the first Lcn for the new file record.
            //

            LastVcn = Attribute->Form.Nonresident.HighestVcn + 1;
            Attribute2->Form.Nonresident.LowestVcn = LastVcn;

            //
            //  Calculate the size of the attribute record we will need.
            //  We only create mapping pairs through the highest Vcn on the
            //  disk.  We don't include any that are being added through the
            //  Mcb yet.
            //

            NewSize = SIZEOF_PARTIAL_NONRES_ATTR_HEADER
                      + QuadAlign( AttributeName.Length )
                      + QuadAlign( NtfsGetSizeForMappingPairs( Mcb,
                                                               MAXULONG,
                                                               LastVcn,
                                                               &OriginalLastVcn,
                                                               &LastVcn ));

            Attribute2->RecordLength = NewSize;

            //
            //  Assume no attribute name, and calculate where the Mapping Pairs
            //  will go.  (Update below if we are wrong.)
            //

            MappingPairs = (PCHAR)Attribute2 + SIZEOF_PARTIAL_NONRES_ATTR_HEADER;

            //
            //  If the attribute has a name, take care of that now.
            //

            if (AttributeName.Length != 0) {

                Attribute2->NameLength = (UCHAR)(AttributeName.Length / sizeof(WCHAR));
                Attribute2->NameOffset = (USHORT)PtrOffset(Attribute2, MappingPairs);
                RtlCopyMemory( MappingPairs,
                               AttributeName.Buffer,
                               AttributeName.Length );
                MappingPairs += QuadAlign( AttributeName.Length );
            }

            //
            //  We always need the mapping pairs offset.
            //

            Attribute2->Form.Nonresident.MappingPairsOffset =
              (USHORT)PtrOffset(Attribute2, MappingPairs);
            NewEnd = Add2Ptr( Attribute2, Attribute2->RecordLength );
            *NewEnd = $END;
            FileRecord2->FirstFreeByte = PtrOffset(FileRecord2, NewEnd)
                                         + QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE ));

            //
            //  Now add the space in the file record.
            //

            *MappingPairs = 0;
            NtfsBuildMappingPairs( Mcb,
                                   Attribute2->Form.Nonresident.LowestVcn,
                                   &LastVcn,
                                   MappingPairs );

            Attribute2->Form.Nonresident.HighestVcn = LastVcn;

        } else {

            //
            //  Now log these changes and fix up the first file record.
            //

            FileRecord1->Lsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NtfsFoundBcb(Context),
                          DeleteAttribute,
                          NULL,
                          0,
                          CreateAttribute,
                          Attribute,
                          Attribute->RecordLength,
                          NtfsMftOffset( Context ),
                          (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord1),
                          0,
                          Vcb->BytesPerFileRecordSegment );

            //
            //  Remember the old position for the CreateAttributeList
            //

            OldPosition = Attribute;

            NtfsRestartRemoveAttribute( IrpContext,
                                        FileRecord1,
                                        (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord1) );
        }

        FileRecord2->Lsn =
        NtfsWriteLog( IrpContext,
                      Vcb->MftScb,
                      Bcb,
                      InitializeFileRecordSegment,
                      FileRecord2,
                      FileRecord2->FirstFreeByte,
                      Noop,
                      NULL,
                      0,
                      LlBytesFromFileRecords( Vcb, MftRecordNumber2 ),
                      0,
                      0,
                      Vcb->BytesPerFileRecordSegment );

        //
        //  Finally, create the attribute list attribute if needed.
        //

        if (!FoundListContext) {

            NtfsCleanupAttributeContext( IrpContext, &ListContext );
            NtfsInitializeAttributeContext( &ListContext );
            CreateAttributeList( IrpContext,
                                 Fcb,
                                 FileRecord1,
                                 MftData ? NULL : FileRecord2,
                                 Reference2,
                                 OldPosition,
                                 NewListSize,
                                 &ListContext );
        //
        //  Otherwise we have to update the existing attribute list, but only
        //  if this is not the Mft data.  In that case the attribute list is
        //  still correct since we haven't moved the attribute entirely.
        //

        } else if (!MftData) {

            UpdateAttributeListEntry( IrpContext,
                                      Fcb,
                                      &MoveContext.AttributeList.Entry->SegmentReference,
                                      MoveContext.AttributeList.Entry->Instance,
                                      &Reference2,
                                      Attribute2->Instance,
                                      &ListContext );
        }

        NtfsCleanupAttributeContext( IrpContext, Context );
        NtfsInitializeAttributeContext( Context );

        if (!NtfsLookupAttributeByName( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        AttributeTypeCode,
                                        &AttributeName,
                                        IsNonresident ? &LowestVcn : NULL,
                                        FALSE,
                                        Context )) {

            ASSERT( FALSE );
            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        ASSERT(!IsNonresident || (LowestVcn == NtfsFoundAttribute(Context)->Form.Nonresident.LowestVcn));

        //
        //  For the case of the Mft split, we now add the final entry.
        //

        if (MftData) {

            //
            //  Finally, we have to add the entry to the attribute list.
            //  The routine we have to do this gets most of its inputs
            //  out of an attribute context.  Our context at this point
            //  does not have quite the right information, so we have to
            //  update it here before calling AddToAttributeList.
            //

            Context->FoundAttribute.FileRecord = FileRecord2;
            Context->FoundAttribute.Attribute = Attribute2;
            Context->AttributeList.Entry =
              NtfsGetNextRecord(Context->AttributeList.Entry);

            NtfsAddToAttributeList( IrpContext, Fcb, Reference2, Context );

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );

            if (!NtfsLookupAttributeByCode( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            $DATA,
                                            Context )) {

                ASSERT( FALSE );
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            while (IsNonresident &&
                   (Attribute2->Form.Nonresident.LowestVcn !=
                    NtfsFoundAttribute(Context)->Form.Nonresident.LowestVcn)) {

                if (!NtfsLookupNextAttributeByCode( IrpContext,
                                                    Fcb,
                                                    $DATA,
                                                    Context )) {

                    ASSERT( FALSE );
                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                }
            }
        }

    } finally {

        if (AttributeName.Buffer != NameBuffer) {
            NtfsFreePool(AttributeName.Buffer);
        }

        if (ARGUMENT_PRESENT(NewBcb)) {

            ASSERT(ARGUMENT_PRESENT(NewFileRecord));

            *NewBcb = Bcb;
            *NewFileRecord = FileRecord2;

        } else {

            ASSERT(!ARGUMENT_PRESENT(NewFileRecord));

            NtfsUnpinBcb( IrpContext, &Bcb );
        }

        NtfsCleanupAttributeContext( IrpContext, &ListContext );
        NtfsCleanupAttributeContext( IrpContext, &MoveContext );
    }

    return MftRecordNumber2;
}


//
//  Internal support routine
//

VOID
SplitFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG SizeNeeded,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine splits a file record in two, when it has been found that
    there is no room for a new attribute.  If the file does not already have
    an attribute list attribute then one is created.

    Essentially this routine finds the midpoint in the current file record
    (accounting for a potential new attribute list and also the space needed).
    Then it copies the second half of the file record over and fixes up the
    first record.  The attribute list is created at the end if required.

Arguments:

    Fcb - Requested file.

    SizeNeeded - Supplies the additional size needed, which is causing the split
                 to occur.

    Context - Supplies the attribute enumeration context pointing to the spot
              where the new attribute is to be inserted or grown.

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT ListContext;
    ATTRIBUTE_ENUMERATION_CONTEXT MoveContext;
    PFILE_RECORD_SEGMENT_HEADER FileRecord1, FileRecord2;
    PATTRIBUTE_RECORD_HEADER Attribute1, Attribute2, Attribute;
    ULONG NewListOffset = 0;
    ULONG NewListSize = 0;
    ULONG NewAttributeOffset;
    ULONG SizeToStay;
    ULONG CurrentOffset, FutureOffset;
    ULONG SizeToMove;
    BOOLEAN FoundListContext;
    MFT_SEGMENT_REFERENCE Reference1, Reference2;
    LONGLONG MftFileRecord2;
    PBCB Bcb = NULL;
    ATTRIBUTE_TYPE_CODE EndCode = $END;
    PVCB Vcb = Fcb->Vcb;
    ULONG AdjustedAvailBytes;

    PAGED_CODE();

    //
    //  Make sure the attribute is pinned.
    //

    NtfsPinMappedAttribute( IrpContext,
                            Vcb,
                            Context );

    //
    //  Something is broken if we decide to split an Mft record.
    //

    ASSERT(Fcb != Vcb->MftScb->Fcb);

    NtfsInitializeAttributeContext( &ListContext );
    NtfsInitializeAttributeContext( &MoveContext );
    FileRecord1 = NtfsContainingFileRecord(Context);
    Attribute1 = NtfsFoundAttribute(Context);

    try {

        //
        //  Lookup the list context so that we know where it is at.
        //

        FoundListContext =
          NtfsLookupAttributeByCode( IrpContext,
                                     Fcb,
                                     &Fcb->FileReference,
                                     $ATTRIBUTE_LIST,
                                     &ListContext );

        //
        //  If we do not already have an attribute list, then calculate
        //  where it will go and how big it must be.  Note, there must
        //  only be one file record at this point.
        //

        if (!FoundListContext) {

            ASSERT( FileRecord1 == NtfsContainingFileRecord(&ListContext) );

            NewListOffset = PtrOffset( FileRecord1,
                                       NtfsFoundAttribute(&ListContext) );

            NewListSize = GetSizeForAttributeList( FileRecord1 ) +
                          SIZEOF_RESIDENT_ATTRIBUTE_HEADER;
        }

        //
        //  Similarly describe where the new attribute is to go, and how
        //  big it is (already in SizeNeeded).
        //

        NewAttributeOffset = PtrOffset( FileRecord1, Attribute1 );

        //
        //  Now calculate the approximate number of bytes that is to be split
        //  across two file records, and divide it in two, and that should give
        //  the amount that is to stay in the first record.
        //

        SizeToStay = (FileRecord1->FirstFreeByte + NewListSize +
                      SizeNeeded + sizeof(FILE_RECORD_SEGMENT_HEADER)) / 2;

        //
        //  We know that since we called this routine we need to split at
        //  least one entry from this file record.  We also base our
        //  split logic by finding the first attribute which WILL lie beyond
        //  the split point (after adding an attribute list and possibly
        //  an intermediate attribute).  We shrink the split point to the
        //  position at the end of where the current last attribute will be
        //  after adding the attribute list.  If we also add space before
        //  the last attribute then we know the last attribute will surely
        //  be split out.
        //

        if (SizeToStay > (FileRecord1->FirstFreeByte - sizeof( LONGLONG ) + NewListSize)) {

            SizeToStay = FileRecord1->FirstFreeByte - sizeof( LONGLONG ) + NewListSize;
        }

        //
        //  Now begin the loop through the attributes to find the splitting
        //  point.  We stop when we reach the end record or are past the attribute
        //  which contains the split point.  We will split at the current attribute
        //  if the remaining bytes after this attribute won't allow us to add
        //  the bytes we need for the caller or create an attribute list if
        //  it doesn't exist.
        //
        //  At this point the following variables indicate the following:
        //
        //      FutureOffset - This the offset of the current attribute
        //          after adding an attribute list and the attribute we
        //          are making space for.
        //
        //      CurrentOffset - Current position in the file record of
        //          of attribute being examined now.
        //
        //      NewListOffset - Offset to insert new attribute list into
        //          file record (0 indicates the list already exists).
        //
        //      NewAttributeOffset - Offset in the file record of the new
        //          attribute.  This refers to the file record as it exists
        //          when this routine is called.
        //

        FutureOffset =
        CurrentOffset = (ULONG)FileRecord1->FirstAttributeOffset;
        Attribute1 = Add2Ptr( FileRecord1, CurrentOffset );
        AdjustedAvailBytes = FileRecord1->BytesAvailable
                             - QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE ));

        while (Attribute1->TypeCode != $END) {

            //
            //  See if the attribute list goes here.
            //

            if (CurrentOffset == NewListOffset) {

                //
                //  This attribute and all later attributes will be moved
                //  by the size of attribute list.
                //

                FutureOffset += NewListSize;
            }

            //
            //  See if the new attribute goes here.
            //

            if (CurrentOffset == NewAttributeOffset) {

                //
                //  This attribute and all later attributes will be moved
                //  by the size of new attribute.
                //

                FutureOffset += SizeNeeded;
            }

            FutureOffset += Attribute1->RecordLength;

            //
            //  Check if we are at the split point.  We split at this point
            //  if the end of the current attribute will be at or beyond the
            //  split point after adjusting for adding either an attribute list
            //  or new attribute.  We make this test >= since these two values
            //  will be equal if we reach the last attribute without finding
            //  the split point.  This way we guarantee a split will happen.
            //
            //  Note that we will go to the next attribute if the current attribute
            //  is the first attribute in the file record.  This can happen if the
            //  first attribute is resident and must stay resident but takes up
            //  half the file record or more (i.e. large filename attribute).
            //  We must make sure to split at least one attribute out of this
            //  record.
            //
            //  Never split when pointing at $STANDARD_INFORMATION or $ATTRIBUTE_LIST.
            //

            if ((Attribute1->TypeCode > $ATTRIBUTE_LIST) &&
                (FutureOffset >= SizeToStay) &&
                (CurrentOffset != FileRecord1->FirstAttributeOffset)) {

                break;
            }

            CurrentOffset += Attribute1->RecordLength;

            Attribute1 = Add2Ptr( Attribute1, Attribute1->RecordLength );
        }

        SizeToMove = FileRecord1->FirstFreeByte - CurrentOffset;

        //
        //  If we are pointing at the attribute list or at the end record
        //  we don't do the split.  Raise INSUFFICIENT_RESOURCES so our caller
        //  knows that we can't do the split.
        //

        if ((Attribute1->TypeCode == $END) || (Attribute1->TypeCode <= $ATTRIBUTE_LIST)) {

            NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
        }

        //
        //  Now if the attribute list already exists, we have to look up
        //  the first one we are going to move in order to update the
        //  attribute list later.
        //

        if (FoundListContext) {

            UNICODE_STRING AttributeName;
            BOOLEAN FoundIt;

            AttributeName.Length =
            AttributeName.MaximumLength = (USHORT)Attribute1->NameLength << 1;
            AttributeName.Buffer = Add2Ptr( Attribute1, Attribute1->NameOffset );

            FoundIt = NtfsLookupAttributeByName( IrpContext,
                                                 Fcb,
                                                 &Fcb->FileReference,
                                                 Attribute1->TypeCode,
                                                 &AttributeName,
                                                 (Attribute1->FormCode == NONRESIDENT_FORM) ?
                                                   &Attribute1->Form.Nonresident.LowestVcn :
                                                   NULL,
                                                 FALSE,
                                                 &MoveContext );

            //
            //  If we are splitting the file record between multiple attributes with
            //  the same name (i.e.  FILE_NAME attributes) then we need to find the
            //  correct attribute.  Since this is an unusual case we will just scan
            //  forwards from the current attribute until we find the correct attribute.
            //

            while (FoundIt && (Attribute1 != NtfsFoundAttribute( &MoveContext ))) {

                FoundIt = NtfsLookupNextAttributeByName( IrpContext,
                                                         Fcb,
                                                         Attribute1->TypeCode,
                                                         &AttributeName,
                                                         FALSE,
                                                         &MoveContext );
            }

            if (!FoundIt) {

                ASSERT( FALSE );
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );

            }

            ASSERT(Attribute1 == NtfsFoundAttribute(&MoveContext));
        }

        //
        //  Now Attribute1 is pointing to the first attribute to move.
        //  Allocate a new file record and move the rest of our attributes
        //  over.
        //

        if (FoundListContext) {
            Reference1 = MoveContext.AttributeList.Entry->SegmentReference;
        }

        FileRecord2 = NtfsCloneFileRecord( IrpContext, Fcb, FALSE, &Bcb, &Reference2 );

        //
        //  Capture the file record number of the new file record.
        //

        MftFileRecord2 = NtfsFullSegmentNumber( &Reference2 );

        Attribute2 = Add2Ptr( FileRecord2, FileRecord2->FirstAttributeOffset );
        RtlCopyMemory( Attribute2, Attribute1, SizeToMove );
        FileRecord2->FirstFreeByte = (ULONG)FileRecord2->FirstAttributeOffset +
                                     SizeToMove;

        //
        //  Loop to update all of the attribute instance codes
        //

        for (Attribute = Attribute2;
             Attribute < (PATTRIBUTE_RECORD_HEADER)Add2Ptr(FileRecord2, FileRecord2->FirstFreeByte)
             && Attribute->TypeCode != $END;
             Attribute = NtfsGetNextRecord(Attribute)) {

            NtfsCheckRecordBound( Attribute, FileRecord2, Vcb->BytesPerFileRecordSegment );

            if (FoundListContext) {

                UpdateAttributeListEntry( IrpContext,
                                          Fcb,
                                          &Reference1,
                                          Attribute->Instance,
                                          &Reference2,
                                          FileRecord2->NextAttributeInstance,
                                          &ListContext );
            }

            Attribute->Instance = FileRecord2->NextAttributeInstance++;
        }

        //
        //  Now log these changes and fix up the first file record.
        //

        FileRecord2->Lsn = NtfsWriteLog( IrpContext,
                                         Vcb->MftScb,
                                         Bcb,
                                         InitializeFileRecordSegment,
                                         FileRecord2,
                                         FileRecord2->FirstFreeByte,
                                         Noop,
                                         NULL,
                                         0,
                                         LlBytesFromFileRecords( Vcb, MftFileRecord2 ),
                                         0,
                                         0,
                                         Vcb->BytesPerFileRecordSegment );

        FileRecord1->Lsn = NtfsWriteLog( IrpContext,
                                         Vcb->MftScb,
                                         NtfsFoundBcb(Context),
                                         WriteEndOfFileRecordSegment,
                                         &EndCode,
                                         sizeof(ATTRIBUTE_TYPE_CODE),
                                         WriteEndOfFileRecordSegment,
                                         Attribute1,
                                         SizeToMove,
                                         NtfsMftOffset( Context ),
                                         CurrentOffset,
                                         0,
                                         Vcb->BytesPerFileRecordSegment );

        NtfsRestartWriteEndOfFileRecord( FileRecord1,
                                         Attribute1,
                                         (PATTRIBUTE_RECORD_HEADER)&EndCode,
                                         sizeof(ATTRIBUTE_TYPE_CODE) );

        //
        //  Finally, create the attribute list attribute if needed.
        //

        if (!FoundListContext) {

            NtfsCleanupAttributeContext( IrpContext, &ListContext );
            NtfsInitializeAttributeContext( &ListContext );
            CreateAttributeList( IrpContext,
                                 Fcb,
                                 FileRecord1,
                                 FileRecord2,
                                 Reference2,
                                 NULL,
                                 NewListSize - SIZEOF_RESIDENT_ATTRIBUTE_HEADER,
                                 &ListContext );
        }

    } finally {

        NtfsUnpinBcb( IrpContext, &Bcb );

        NtfsCleanupAttributeContext( IrpContext, &ListContext );
        NtfsCleanupAttributeContext( IrpContext, &MoveContext );
    }
}


VOID
NtfsRestartWriteEndOfFileRecord (
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER OldAttribute,
    IN PATTRIBUTE_RECORD_HEADER NewAttributes,
    IN ULONG SizeOfNewAttributes
    )

/*++

Routine Description:

    This routine is called both in the running system and at restart to
    modify the end of a file record, such as after it was split in two.

Arguments:

    FileRecord - Supplies the pointer to the file record.

    OldAttribute - Supplies a pointer to the first attribute to be overwritten.

    NewAttributes - Supplies a pointer to the new attribute(s) to be copied to
                    the spot above.

    SizeOfNewAttributes - Supplies the size to be copied in bytes.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    RtlMoveMemory( OldAttribute, NewAttributes, SizeOfNewAttributes );

    FileRecord->FirstFreeByte = PtrOffset(FileRecord, OldAttribute) +
                                SizeOfNewAttributes;

    //
    //  The size coming in may not be quad aligned.
    //

    FileRecord->FirstFreeByte = QuadAlign( FileRecord->FirstFreeByte );
}


//
//  Internal support routine
//

PFILE_RECORD_SEGMENT_HEADER
NtfsCloneFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN BOOLEAN MftData,
    OUT PBCB *Bcb,
    OUT PMFT_SEGMENT_REFERENCE FileReference
    )

/*++

Routine Description:

    This routine allocates an additional file record for an already existing
    and open file, for the purpose of overflowing attributes to this record.

Arguments:

    Fcb - Requested file.

    MftData - TRUE if the file record is being cloned to describe the
              $DATA attribute for the Mft.

    Bcb - Returns a pointer to the Bcb for the new file record.

    FileReference - returns the file reference for the new file record.

Return Value:

    Pointer to the allocated file record.

--*/

{
    LONGLONG FileRecordOffset;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PVCB Vcb = Fcb->Vcb;

    PAGED_CODE();

    //
    //  First allocate the record.
    //

    *FileReference = NtfsAllocateMftRecord( IrpContext,
                                            Vcb,
                                            MftData );

    //
    //  Read it in and pin it.
    //

    NtfsPinMftRecord( IrpContext,
                      Vcb,
                      FileReference,
                      TRUE,
                      Bcb,
                      &FileRecord,
                      &FileRecordOffset );

    //
    //  Initialize it.
    //

    NtfsInitializeMftRecord( IrpContext,
                             Vcb,
                             FileReference,
                             FileRecord,
                             *Bcb,
                             BooleanIsDirectory( &Fcb->Info ));

    FileRecord->BaseFileRecordSegment = Fcb->FileReference;
    FileRecord->ReferenceCount = 0;
    FileReference->SequenceNumber = FileRecord->SequenceNumber;

    return FileRecord;
}


//
//  Internal support routine
//

ULONG
GetSizeForAttributeList (
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord
    )

/*++

Routine Description:

    This routine is designed to calculate the size that will be required for
    an attribute list attribute, for a base file record which is just about
    to split into two file record segments.

Arguments:

    FileRecord - Pointer to the file record which is just about to split.

Return Value:

    Size in bytes of the attribute list attribute that will be required,
    not including the attribute header size.

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    ULONG Size = 0;

    PAGED_CODE();

    //
    //  Point to first attribute.
    //

    Attribute = Add2Ptr(FileRecord, FileRecord->FirstAttributeOffset);

    //
    //  Loop to add up size of required attribute list entries.
    //

    while (Attribute->TypeCode != $END) {

        Size += QuadAlign( FIELD_OFFSET( ATTRIBUTE_LIST_ENTRY, AttributeName )
                           + ((ULONG) Attribute->NameLength << 1));

        Attribute = Add2Ptr( Attribute, Attribute->RecordLength );
    }

    return Size;
}


//
//  Internal support routine
//

VOID
CreateAttributeList (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord1,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord2 OPTIONAL,
    IN MFT_SEGMENT_REFERENCE SegmentReference2,
    IN PATTRIBUTE_RECORD_HEADER OldPosition OPTIONAL,
    IN ULONG SizeOfList,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT ListContext
    )

/*++

Routine Description:

    This routine is intended to be called to create the attribute list attribute
    the first time.  The caller must have already calculated the size required
    for the list to pass into this routine.  The caller must have already
    removed any attributes from the base file record (FileRecord1) which are
    not to remain there.  He must then pass in a pointer to the base file record
    and optionally a pointer to a second file record from which the new
    attribute list is to be created.

Arguments:

    Fcb - Requested file.

    FileRecord1 - Pointer to the base file record, currently holding only those
                  attributes to be described there.

    FileRecord2 - Optionally points to a second file record from which the
                  second half of the attribute list is to be constructed.

    SegmentReference2 - The Mft segment reference of the second file record,
                        if one was supplied.

    OldPosition - Should only be specified if FileRecord2 is specified.  In this
                  case it must point to an attribute position in FileRecord1 from
                  which a single attribute was moved to file record 2.  It will be
                  used as an indication of where the attribute list entry should
                  be inserted.

    SizeOfList - Exact size of the attribute list which will be required.

    ListContext - Context resulting from an attempt to look up the attribute
                  list attribute, which failed.

Return Value:

    None

--*/

{
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PATTRIBUTE_LIST_ENTRY AttributeList, ListEntry;
    MFT_SEGMENT_REFERENCE SegmentReference;

    PAGED_CODE();

    //
    //  Allocate space to construct the attribute list.  (The list
    //  cannot be constructed in place, because that would destroy error
    //  recovery.)
    //

    ListEntry =
    AttributeList = (PATTRIBUTE_LIST_ENTRY) NtfsAllocatePool(PagedPool, SizeOfList );

    //
    //  Use try-finally to deallocate on the way out.
    //

    try {

        //
        //  Loop to fill in the attribute list from the two file records
        //

        for (FileRecord = FileRecord1, SegmentReference = Fcb->FileReference;
             FileRecord != NULL;
             FileRecord = ((FileRecord == FileRecord1) ? FileRecord2 : NULL),
             SegmentReference = SegmentReference2) {

            //
            //  Point to first attribute.
            //

            Attribute = Add2Ptr( FileRecord, FileRecord->FirstAttributeOffset );

            //
            //  Loop to add up size of required attribute list entries.
            //

            while (Attribute->TypeCode != $END) {

                PATTRIBUTE_RECORD_HEADER NextAttribute;

                //
                //  See if we are at the remembered position.  If so:
                //
                //      Save this attribute to be the next one.
                //      Point to the single attribute in FileRecord2 instead
                //      Clear FileRecord2, as we will "consume" it here.
                //      Set the Segment reference in the ListEntry
                //

                if ((Attribute == OldPosition) && (FileRecord2 != NULL)) {

                    NextAttribute = Attribute;
                    Attribute = Add2Ptr(FileRecord2, FileRecord2->FirstAttributeOffset);
                    FileRecord2 = NULL;
                    ListEntry->SegmentReference = SegmentReference2;

                //
                //  Otherwise, this is the normal loop case.  So:
                //
                //      Set the next attribute pointer accordingly.
                //      Set the Segment reference from the loop control
                //

                } else {

                    NextAttribute = Add2Ptr(Attribute, Attribute->RecordLength);
                    ListEntry->SegmentReference = SegmentReference;
                }

                //
                //  Now fill in the list entry.
                //

                ListEntry->AttributeTypeCode = Attribute->TypeCode;
                ListEntry->RecordLength = (USHORT) QuadAlign( FIELD_OFFSET( ATTRIBUTE_LIST_ENTRY, AttributeName )
                                                              + ((ULONG) Attribute->NameLength << 1));
                ListEntry->AttributeNameLength = Attribute->NameLength;
                ListEntry->AttributeNameOffset =
                  (UCHAR)PtrOffset( ListEntry, &ListEntry->AttributeName[0] );

                ListEntry->Instance = Attribute->Instance;

                ListEntry->LowestVcn = 0;

                if (Attribute->FormCode == NONRESIDENT_FORM) {

                    ListEntry->LowestVcn = Attribute->Form.Nonresident.LowestVcn;
                }

                if (Attribute->NameLength != 0) {

                    RtlCopyMemory( &ListEntry->AttributeName[0],
                                   Add2Ptr(Attribute, Attribute->NameOffset),
                                   Attribute->NameLength << 1 );
                }

                ListEntry = Add2Ptr(ListEntry, ListEntry->RecordLength);
                Attribute = NextAttribute;
            }
        }

        //
        //  Now create the attribute list attribute.
        //

        NtfsCreateAttributeWithValue( IrpContext,
                                      Fcb,
                                      $ATTRIBUTE_LIST,
                                      NULL,
                                      AttributeList,
                                      SizeOfList,
                                      0,
                                      NULL,
                                      TRUE,
                                      ListContext );

    } finally {

        NtfsFreePool( AttributeList );
    }
}


//
//  Internal support routine
//

VOID
UpdateAttributeListEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PMFT_SEGMENT_REFERENCE OldFileReference,
    IN USHORT OldInstance,
    IN PMFT_SEGMENT_REFERENCE NewFileReference,
    IN USHORT NewInstance,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT ListContext
    )

/*++

Routine Description:

    This routine may be called to update a range of the attribute list
    as required by the movement of a range of attributes to a second record.
    The caller must supply a pointer to the file record to which the attributes
    have moved, along with the segment reference of that record.

Arguments:

    Fcb - Requested file.

    OldFileReference - Old File Reference for attribute

    OldInstance - Old Instance number for attribute

    NewFileReference - New File Reference for attribute

    NewInstance - New Instance number for attribute

    ListContext - The attribute enumeration context which was used to locate
                  the attribute list.

Return Value:

    None

--*/

{
    PATTRIBUTE_LIST_ENTRY AttributeList, ListEntry, BeyondList;
    PBCB Bcb = NULL;
    ULONG SizeOfList;
    ATTRIBUTE_LIST_ENTRY NewEntry;
    PATTRIBUTE_RECORD_HEADER Attribute;

    PAGED_CODE();

    //
    //  Map the attribute list if the attribute is non-resident.  Otherwise the
    //  attribute is already mapped and we have a Bcb in the attribute context.
    //

    Attribute = NtfsFoundAttribute( ListContext );

    if (!NtfsIsAttributeResident( Attribute )) {

        NtfsMapAttributeValue( IrpContext,
                               Fcb,
                               (PVOID *) &AttributeList,
                               &SizeOfList,
                               &Bcb,
                               ListContext );

    //
    //  Don't call the Map attribute routine because it NULLs the Bcb in the
    //  attribute list.  This Bcb is needed for ChangeAttributeValue to mark
    //  the page dirty.
    //

    } else {

        AttributeList = (PATTRIBUTE_LIST_ENTRY) NtfsAttributeValue( Attribute );
        SizeOfList = Attribute->Form.Resident.ValueLength;
    }

    //
    //  Make sure we unpin the list.
    //

    try {

        //
        //  Point beyond the end of the list.
        //

        BeyondList = (PATTRIBUTE_LIST_ENTRY)Add2Ptr( AttributeList, SizeOfList );

        //
        //  Loop through all of the attribute list entries until we find the one
        //  we need to change.
        //

        for (ListEntry = AttributeList;
             ListEntry < BeyondList;
             ListEntry = NtfsGetNextRecord(ListEntry)) {

            if ((ListEntry->Instance == OldInstance) &&
                NtfsEqualMftRef(&ListEntry->SegmentReference, OldFileReference)) {

                break;
            }
        }

        ASSERT( (Fcb != Fcb->Vcb->MftScb->Fcb) ||
                ((ULONGLONG)(ListEntry->LowestVcn) > (NtfsFullSegmentNumber( NewFileReference ) >> Fcb->Vcb->MftToClusterShift)) );

        //
        //  We better have found it!
        //

        ASSERT(ListEntry < BeyondList);

        if (ListEntry >= BeyondList) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        //
        //  Make a copy of the fixed portion of the attribute list entry,
        //  and update to describe the new attribute location.
        //

        RtlCopyMemory( &NewEntry, ListEntry, sizeof(ATTRIBUTE_LIST_ENTRY) );

        NewEntry.SegmentReference = *NewFileReference;
        NewEntry.Instance = NewInstance;

        //
        //  Update the attribute list entry.
        //

        NtfsChangeAttributeValue( IrpContext,
                                  Fcb,
                                  PtrOffset(AttributeList, ListEntry),
                                  &NewEntry,
                                  sizeof(ATTRIBUTE_LIST_ENTRY),
                                  FALSE,
                                  TRUE,
                                  FALSE,
                                  TRUE,
                                  ListContext );

    } finally {

        NtfsUnpinBcb( IrpContext, &Bcb );
    }
}


//
//  Local support routine
//

VOID
NtfsAddNameToParent (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB ThisFcb,
    IN BOOLEAN IgnoreCase,
    IN PBOOLEAN LogIt,
    IN PFILE_NAME FileNameAttr,
    OUT PUCHAR FileNameFlags,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    IN PNAME_PAIR NamePair OPTIONAL,
    IN PINDEX_CONTEXT IndexContext OPTIONAL
    )

/*++

Routine Description:

    This routine will create the filename attribute with the given name.
    Depending on the IgnoreCase flag, this is either a link or an Ntfs
    name.  If it is an Ntfs name, we check if it is also the Dos name.

    We build a file name attribute and then add it via ThisFcb, we then
    add this entry to the parent.

    If the name is a Dos name and we are given tunneling information on
    the long name, we will add the long name attribute as well.

Arguments:

    ParentScb - This is the parent directory for the file.

    ThisFcb - This is the file to add the filename to.

    IgnoreCase - Indicates if this name is case insensitive.  Only for Posix
        will this be FALSE.

    LogIt - Indicates if we should log this operation.  If FALSE and this is a large
        name then log the file record and begin logging.

    FileNameAttr - This contains a file name attribute structure to use.

    FileNameFlags - We store a copy of the File name flags used in the file
        name attribute.

    QuickIndex - If specified, we store the information about the location of the
        index entry added.

    NamePair - If specified, we add the tunneled NTFS-only name if the name we are
        directly adding is DOS-only.

    IndexContext - Previous result of doing the lookup for the name in the index.

Return Value:

    None - This routine will raise on error.

--*/

{
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddNameToParent:  Entered\n") );

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Decide whether the name is a link, Ntfs-Only or Ntfs/8.3 combined name.
        //  Update the filename attribute to reflect this.
        //

        if (!IgnoreCase) {

            *FileNameFlags = 0;

        } else {

            UNICODE_STRING FileName;

            FileName.Length = FileName.MaximumLength = (USHORT)(FileNameAttr->FileNameLength * sizeof(WCHAR));
            FileName.Buffer = FileNameAttr->FileName;

            *FileNameFlags = FILE_NAME_NTFS;

            if (NtfsIsFatNameValid( &FileName, FALSE )) {

                *FileNameFlags |= FILE_NAME_DOS;
            }

            //
            //  If the name is DOS and there was a tunneled NTFS name, add it first if both names
            //  exist in the pair (there may only be one in the long side). Note that we
            //  really need to do this first so we lay down the correct filename flags.
            //

            if (NamePair &&
                (NamePair->Long.Length > 0) &&
                (NamePair->Short.Length > 0) &&
                (*FileNameFlags == (FILE_NAME_NTFS | FILE_NAME_DOS))) {

                if (NtfsAddTunneledNtfsOnlyName(IrpContext,
                                                ParentScb,
                                                ThisFcb,
                                                &NamePair->Long,
                                                LogIt )) {

                    //
                    //  Name didn't conflict and was added, so fix up the FileNameFlags
                    //

                    *FileNameFlags = FILE_NAME_DOS;

                    //
                    //  Make sure we reposition in the index for the actual insertion.
                    //

                    IndexContext = NULL;

                    //
                    //  We also need to upcase the short DOS name since we don't know the
                    //  case of what the user handed us and all DOS names are upcase. Note
                    //  that prior to tunneling being supported it was not possible for a user
                    //  to specify a short name, so this is a new situation.
                    //

                    RtlUpcaseUnicodeString(&FileName, &FileName, FALSE);
                }
            }
        }

        //
        //  Now update the file name attribute.
        //

        FileNameAttr->Flags = *FileNameFlags;

        //
        //  If we haven't been logging and this is a large name then begin logging.
        //

        if (!(*LogIt) &&
            (FileNameAttr->FileNameLength > 100)) {

            //
            //  Look up the file record and log its current state.
            //

            if (!NtfsLookupAttributeByCode( IrpContext,
                                            ThisFcb,
                                            &ThisFcb->FileReference,
                                            $STANDARD_INFORMATION,
                                            &AttrContext )) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, ThisFcb );
            }

            NtfsPinMappedAttribute( IrpContext, ThisFcb->Vcb, &AttrContext );
            FileRecord = NtfsContainingFileRecord( &AttrContext );

            //
            //  Log the current state of the file record.
            //

            FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                            ThisFcb->Vcb->MftScb,
                                            NtfsFoundBcb( &AttrContext ),
                                            InitializeFileRecordSegment,
                                            FileRecord,
                                            FileRecord->FirstFreeByte,
                                            Noop,
                                            NULL,
                                            0,
                                            NtfsMftOffset( &AttrContext ),
                                            0,
                                            0,
                                            ThisFcb->Vcb->BytesPerFileRecordSegment );

            *LogIt = TRUE;
            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            NtfsInitializeAttributeContext( &AttrContext );
        }

        //
        //  Put it in the file record.
        //

        NtfsCreateAttributeWithValue( IrpContext,
                                      ThisFcb,
                                      $FILE_NAME,
                                      NULL,
                                      FileNameAttr,
                                      NtfsFileNameSize( FileNameAttr ),
                                      0,
                                      &FileNameAttr->ParentDirectory,
                                      *LogIt,
                                      &AttrContext );

        //
        //  Now put it in the index entry.
        //

        NtfsAddIndexEntry( IrpContext,
                           ParentScb,
                           FileNameAttr,
                           NtfsFileNameSize( FileNameAttr ),
                           &ThisFcb->FileReference,
                           IndexContext,
                           QuickIndex );

    } finally {

        DebugUnwind( NtfsAddNameToParent );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsAddNameToParent:  Exit\n") );
    }

    return;
}


//
//  Local support routine
//

VOID
NtfsAddDosOnlyName (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB ThisFcb,
    IN UNICODE_STRING FileName,
    IN BOOLEAN LogIt,
    IN PUNICODE_STRING SuggestedDosName OPTIONAL
    )

/*++

Routine Description:

    This routine is called to build a Dos only name attribute an put it in
    the file record and the parent index.  We need to allocate pool large
    enough to hold the name (easy for 8.3) and then check that the generated
    names don't already exist in the parent. Use the suggested name first if
    possible.

Arguments:

    ParentScb - This is the parent directory for the file.

    ThisFcb - This is the file to add the filename to.

    FileName - This is the file name to add.

    LogIt - Indicates if we should log this operation.

    SuggestedDosName - If supplied, a name to try to use before auto-generation

Return Value:

    None - This routine will raise on error.

--*/

{
    GENERATE_NAME_CONTEXT NameContext;
    PFILE_NAME FileNameAttr;
    UNICODE_STRING Name8dot3;

    PINDEX_ENTRY IndexEntry;
    PBCB IndexEntryBcb;
    UCHAR TrailingDotAdj;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    BOOLEAN TrySuggestedDosName = TRUE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddDosOnlyName:  Entered\n") );

    IndexEntryBcb = NULL;

    RtlZeroMemory( &NameContext, sizeof( GENERATE_NAME_CONTEXT ));

    if (SuggestedDosName == NULL || SuggestedDosName->Length == 0) {

        //
        //  The SuggestedDosName can be zero length if we have a tunneled
        //  link or a tunneled file which was created whilst short name
        //  generation was disabled. It is a bad thing to drop down null
        //  filenames ...
        //

        TrySuggestedDosName = FALSE;
    }

    //
    //  The maximum length is 24 bytes, but 2 are already defined with the
    //  FILE_NAME structure.
    //

    FileNameAttr = NtfsAllocatePool(PagedPool, sizeof( FILE_NAME ) + 22 );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        NtfsInitializeAttributeContext( &AttrContext );

        //
        //  Set up the string to hold the generated name.  It will be part
        //  of the file name attribute structure.
        //

        Name8dot3.Buffer = FileNameAttr->FileName;
        Name8dot3.MaximumLength = 24;

        FileNameAttr->ParentDirectory = ParentScb->Fcb->FileReference;
        FileNameAttr->Flags = FILE_NAME_DOS;

        //
        //  Copy the info values into the filename attribute.
        //

        RtlCopyMemory( &FileNameAttr->Info,
                       &ThisFcb->Info,
                       sizeof( DUPLICATED_INFORMATION ));

        //
        //  We will loop indefinitely.  We generate a name, look in the parent
        //  for it.  If found we continue generating.  If not then we have the
        //  name we need.  Attempt to use the suggested name first.
        //

        while( TRUE ) {

            TrailingDotAdj = 0;

            if (TrySuggestedDosName) {

                Name8dot3.Length = SuggestedDosName->Length;
                RtlCopyMemory(Name8dot3.Buffer, SuggestedDosName->Buffer, SuggestedDosName->Length);
                Name8dot3.MaximumLength = SuggestedDosName->MaximumLength;

            } else {

                RtlGenerate8dot3Name( &FileName,
                                      BooleanFlagOn(NtfsData.Flags,NTFS_FLAGS_ALLOW_EXTENDED_CHAR),
                                      &NameContext,
                                      &Name8dot3 );

                if ((Name8dot3.Buffer[(Name8dot3.Length / sizeof( WCHAR )) - 1] == L'.') &&
                    (Name8dot3.Length > sizeof( WCHAR ))) {

                    TrailingDotAdj = 1;
                }
            }

            FileNameAttr->FileNameLength = (UCHAR)(Name8dot3.Length / sizeof( WCHAR )) - TrailingDotAdj;

            if (!NtfsFindIndexEntry( IrpContext,
                                     ParentScb,
                                     FileNameAttr,
                                     TRUE,
                                     NULL,
                                     &IndexEntryBcb,
                                     &IndexEntry,
                                     NULL )) {

                break;
            }

            NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

            if (TrySuggestedDosName) {

                //
                //  Failed to use the suggested name, so fix up the 8.3 space
                //

                Name8dot3.Buffer = FileNameAttr->FileName;
                Name8dot3.MaximumLength = 24;

                TrySuggestedDosName = FALSE;
            }
        }

        //
        //  We add this entry to the file record.
        //

        NtfsCreateAttributeWithValue( IrpContext,
                                      ThisFcb,
                                      $FILE_NAME,
                                      NULL,
                                      FileNameAttr,
                                      NtfsFileNameSize( FileNameAttr ),
                                      0,
                                      &FileNameAttr->ParentDirectory,
                                      LogIt,
                                      &AttrContext );

        //
        //  We add this entry to the parent.
        //

        NtfsAddIndexEntry( IrpContext,
                           ParentScb,
                           FileNameAttr,
                           NtfsFileNameSize( FileNameAttr ),
                           &ThisFcb->FileReference,
                           NULL,
                           NULL );

    } finally {

        DebugUnwind( NtfsAddDosOnlyName );

        NtfsFreePool( FileNameAttr );

        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsAddDosOnlyName:  Exit  ->  %08lx\n") );
    }

    return;
}


//
//  Local support routine
//

BOOLEAN
NtfsAddTunneledNtfsOnlyName (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB ThisFcb,
    IN PUNICODE_STRING FileName,
    IN PBOOLEAN LogIt
    )

/*++

Routine Description:

    This routine is called to attempt to insert a tunneled NTFS-only name
    attribute and put it in the file record and the parent index. If the
    name collides with an existing name nothing occurs.

Arguments:

    ParentScb - This is the parent directory for the file.

    ThisFcb - This is the file to add the filename to.

    FileName - This is the file name to add.

    LogIt - Indicates if we should log this operation.  If FALSE and this is a large
        name then log the file record and begin logging.

Return Value:

    Boolean true if the name is added, false otherwise

--*/

{
    PFILE_NAME FileNameAttr;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;

    PINDEX_ENTRY IndexEntry;
    PBCB IndexEntryBcb;

    BOOLEAN Added = FALSE;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddTunneledNtfsOnlyName:  Entered\n") );

    IndexEntryBcb = NULL;

    //
    //  One WCHAR is already defined with the FILE_NAME structure. It is unfortunate
    //  that we need to go to pool to do this ...
    //

    FileNameAttr = NtfsAllocatePool(PagedPool, sizeof( FILE_NAME ) + FileName->Length - sizeof(WCHAR) );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        NtfsInitializeAttributeContext( &AttrContext );

        RtlCopyMemory( FileNameAttr->FileName,
                       FileName->Buffer,
                       FileName->Length );

        FileNameAttr->FileNameLength = (UCHAR)(FileName->Length / sizeof(WCHAR));

        FileNameAttr->ParentDirectory = ParentScb->Fcb->FileReference;
        FileNameAttr->Flags = FILE_NAME_NTFS;

        //
        //  Copy the info values into the filename attribute.
        //

        RtlCopyMemory( &FileNameAttr->Info,
                       &ThisFcb->Info,
                       sizeof( DUPLICATED_INFORMATION ));

        //
        //  Try out the name
        //

        if (!NtfsFindIndexEntry( IrpContext,
                                ParentScb,
                                FileNameAttr,
                                TRUE,
                                NULL,
                                &IndexEntryBcb,
                                &IndexEntry,
                                NULL )) {

            //
            //  Restore the case of the tunneled name
            //

            RtlCopyMemory( FileNameAttr->FileName,
                           FileName->Buffer,
                           FileName->Length );

            //
            //  If we haven't been logging and this is a large name then begin logging.
            //

            if (!(*LogIt) &&
                (FileName->Length > 200)) {

                //
                //  Look up the file record and log its current state.
                //

                if (!NtfsLookupAttributeByCode( IrpContext,
                                                ThisFcb,
                                                &ThisFcb->FileReference,
                                                $STANDARD_INFORMATION,
                                                &AttrContext )) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, ThisFcb );
                }

                NtfsPinMappedAttribute( IrpContext, ThisFcb->Vcb, &AttrContext );

                FileRecord = NtfsContainingFileRecord( &AttrContext );

                //
                //  Log the current state of the file record.
                //

                FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                                ThisFcb->Vcb->MftScb,
                                                NtfsFoundBcb( &AttrContext ),
                                                InitializeFileRecordSegment,
                                                FileRecord,
                                                FileRecord->FirstFreeByte,
                                                Noop,
                                                NULL,
                                                0,
                                                NtfsMftOffset( &AttrContext ),
                                                0,
                                                0,
                                                ThisFcb->Vcb->BytesPerFileRecordSegment );

                *LogIt = TRUE;
                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                NtfsInitializeAttributeContext( &AttrContext );
            }

            //
            //  We add this entry to the file record.
            //

            NtfsCreateAttributeWithValue( IrpContext,
                                          ThisFcb,
                                          $FILE_NAME,
                                          NULL,
                                          FileNameAttr,
                                          NtfsFileNameSize( FileNameAttr ),
                                          0,
                                          &FileNameAttr->ParentDirectory,
                                          *LogIt,
                                          &AttrContext );

            //
            //  We add this entry to the parent.
            //

            NtfsAddIndexEntry( IrpContext,
                               ParentScb,
                               FileNameAttr,
                               NtfsFileNameSize( FileNameAttr ),
                               &ThisFcb->FileReference,
                               NULL,
                               NULL );

            //
            //  Flag the addition
            //

            Added = TRUE;
         }

    } finally {

        DebugUnwind( NtfsAddTunneledNtfsOnlyName );

        NtfsFreePool( FileNameAttr );

        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsAddTunneledNtfsOnlyName:  Exit  ->  %08lx\n", Added) );
    }

    return Added;
}


//
//  Local support routine
//

USHORT
NtfsScanForFreeInstance (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord
    )

/*++

Routine Description:

    This routine is called when we are adding a new attribute to this file record
    but the instance number is significant.  We don't want the instance numbers
    to roll over so we will scan for a free instance number.

Arguments:

    Vcb - Vcb for this volume.

    FileRecord - This is the file record to look at.

Return Value:

    USHORT - Return the lowest free instance in the file record.

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    ULONG AttributeCount = 0;
    ULONG CurrentIndex;
    ULONG MinIndex;
    ULONG LowIndex;
    USHORT CurrentMinInstance;
    USHORT CurrentInstances[0x80];
    USHORT LastInstance = 0xffff;

    PAGED_CODE();

    //
    //  Insert the existing attributes into our array.
    //

    Attribute = NtfsFirstAttribute( FileRecord );

    while (Attribute->TypeCode != $END) {

        //
        //  Store this instance in the current position in the array.
        //

        CurrentInstances[AttributeCount] = Attribute->Instance;
        AttributeCount += 1;

        Attribute = NtfsGetNextRecord( Attribute );
        NtfsCheckRecordBound( Attribute, FileRecord, Vcb->BytesPerFileRecordSegment );
    }

    //
    //  If there are no entries then return 0 as the instance to use.
    //

    if (AttributeCount == 0) {

        return 0;

    //
    //  If there is only one entry then either return 0 or 1.
    //

    } else if (AttributeCount == 1) {

        if (CurrentInstances[0] == 0) {

            return 1;

        } else {

            return 0;
        }
    }

    //
    //  We will start sorting the array.  We can stop as soon as we find a gap.
    //

    LowIndex = 0;

    while (LowIndex < AttributeCount) {

        //
        //  Walk through from our current position and find the lowest value.
        //

        MinIndex = LowIndex;
        CurrentMinInstance = CurrentInstances[MinIndex];
        CurrentIndex = LowIndex + 1;

        while (CurrentIndex < AttributeCount) {

            if (CurrentInstances[CurrentIndex] < CurrentMinInstance) {

                CurrentMinInstance = CurrentInstances[CurrentIndex];
                MinIndex = CurrentIndex;
            }

            CurrentIndex += 1;
        }

        //
        //  If there is a gap between the previous value and the current instance then
        //  we are done.
        //

        if ((USHORT) (LastInstance + 1) != CurrentMinInstance) {

            return LastInstance + 1;
        }

        //
        //  Otherwise move to the next index.
        //

        CurrentInstances[MinIndex] = CurrentInstances[LowIndex];
        CurrentInstances[LowIndex] = CurrentMinInstance;
        LastInstance = CurrentMinInstance;
        LowIndex += 1;
    }

    //
    //  We walked through all of the existing without finding a free entry.  Go ahead and
    //  return the next known instance.
    //

    return (USHORT) AttributeCount;
}


//
//  Local support routine
//

VOID
NtfsMergeFileRecords (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN RestoreContext,
    IN PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine is called to possibly merge two file records which each consist of a single hole.
    We are given a context which points to either the first of second record.  We always
    remove the second and update the first if we can find the holes.

    NOTE - We always want to remove the second attribute not the first.  The first may have a
    TotalAllocated field which we can't lose.

Arguments:

    Scb - Scb for the stream being modified.

    RestoreContext - Indicates if we should be pointing at the merged record on exit.

    Context - This points to either the first or second record of the merge.  On return it will
        be in an indeterminant state unless our caller has specified that we should be pointing
        to the combined record.

Return Value:

    None

--*/

{
    PATTRIBUTE_RECORD_HEADER NewAttribute = NULL;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;

    ULONG MappingPairsSize;
    VCN LastVcn;
    VCN RestoreVcn;

    ULONG PassCount = 0;

    VCN NewFinalVcn;
    VCN NewStartVcn;

    PUCHAR NextMappingPairs;
    UCHAR VLength;
    UCHAR LLength;
    ULONG BytesAvail;

    BOOLEAN TryPrior = TRUE;

    PAGED_CODE();

    //
    //  Use a try finally to facilitate cleanup.
    //

    try {

        //
        //  Capture the file record and attribute.
        //

        Attribute = NtfsFoundAttribute( Context );
        FileRecord = NtfsContainingFileRecord( Context );

        //
        //  Remember the end of the current file record and the space available.
        //

        NewFinalVcn = Attribute->Form.Nonresident.HighestVcn;
        RestoreVcn = NewStartVcn = Attribute->Form.Nonresident.LowestVcn;
        BytesAvail = FileRecord->BytesAvailable - FileRecord->FirstFreeByte;

        //
        //  Start by checking if we can merge with the following file record.
        //

        if (NtfsLookupNextAttributeForScb( IrpContext, Scb, Context )) {

            Attribute = NtfsFoundAttribute( Context );

            //
            //  If this attribute also consists entirely of a hole then merge the
            //  previous hole.
            //

            NextMappingPairs = Add2Ptr( Attribute, Attribute->Form.Nonresident.MappingPairsOffset );
            LLength = *NextMappingPairs >> 4;
            VLength = *NextMappingPairs & 0x0f;
            NextMappingPairs = Add2Ptr( NextMappingPairs, LLength + VLength + 1);

            //
            //  Perform the merge if the current file record is a hole and
            //  there is space in the previous record.  There is space if the
            //  prior record has at least 8 available bytes or we know that
            //  the mapping pairs will only take 8 bytes (6 bytes for the Vcn).
            //  We don't want to deal with the rare (if not nonexistent) case
            //  where we need to grow the attribute in a full file record.
            //  Also check that the next range is contiguous.  In some cases we
            //  may split an existing filerecord into a hole and an allocated
            //  range.  We don't want to look ahead if we haven't written the
            //  next range.
            //

            if ((Attribute->Form.Nonresident.LowestVcn == NewFinalVcn + 1) &&
                (LLength == 0) &&
                (*NextMappingPairs == 0) &&
                ((BytesAvail >= 8) ||
                 (Attribute->Form.Nonresident.HighestVcn - NewStartVcn <= 0x7fffffffffff))) {

                TryPrior = FALSE;

                //
                //  Update the new highest vcn value.
                //

                NewFinalVcn = Attribute->Form.Nonresident.HighestVcn;
            }
        }

        //
        //  If we couldn't find a following file record then check for a
        //  previous file record.
        //

        if (TryPrior) {

            //
            //  Reinitialize the context and look up the attribute again if there
            //  is no previous or look up the previous attribute.
            //

            if (NewStartVcn != 0) {

                //
                //  Back up to the previous file record.
                //

                NewStartVcn -= 1;

            //
            //  If we were already at the first file record then there is
            //  nothing more to try.
            //

            } else {

                try_return( NOTHING );
            }

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );

            NtfsLookupAttributeForScb( IrpContext, Scb, &NewStartVcn, Context );

            Attribute = NtfsFoundAttribute( Context );
            FileRecord = NtfsContainingFileRecord( Context );

            NextMappingPairs = Add2Ptr( Attribute, Attribute->Form.Nonresident.MappingPairsOffset );
            LLength = *NextMappingPairs >> 4;
            VLength = *NextMappingPairs & 0x0f;
            NextMappingPairs = Add2Ptr( NextMappingPairs, LLength + VLength + 1);
            BytesAvail = FileRecord->BytesAvailable - FileRecord->FirstFreeByte;

            //
            //  Update the new lowest vcn value.
            //

            NewStartVcn = Attribute->Form.Nonresident.LowestVcn;

            //
            //  Perform the merge if the current file record is a hole and
            //  there is space in the current record.  There is space if the
            //  current record has at least 8 available bytes or we know that
            //  the mapping pairs will only take 8 bytes (6 bytes for the Vcn).
            //

            if ((LLength != 0) ||
                (*NextMappingPairs != 0) ||
                ((BytesAvail < 8) &&
                 (NewFinalVcn - NewStartVcn > 0x7fffffffffff))) {

                try_return( NOTHING );
            }
        }

        //
        //  Now update the NtfsMcb to reflect the merge.  Start by unloading the existing
        //  ranges and then define a new range.
        //

        NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                NewStartVcn,
                                NewFinalVcn,
                                FALSE,
                                FALSE );

        NtfsDefineNtfsMcbRange( &Scb->Mcb,
                                NewStartVcn,
                                NewFinalVcn,
                                FALSE );

        NtfsAddNtfsMcbEntry( &Scb->Mcb,
                             NewStartVcn,
                             UNUSED_LCN,
                             NewFinalVcn - NewStartVcn + 1,
                             FALSE );

        //
        //  We need two passes through this loop, one for each record.
        //

        while (TRUE) {

            //
            //  Update our pointers to point to the attribute and file record.
            //

            Attribute = NtfsFoundAttribute( Context );

            //
            //  If we are at the first record then update the entry.
            //

            if (Attribute->Form.Nonresident.LowestVcn == NewStartVcn) {

                FileRecord = NtfsContainingFileRecord( Context );

                //
                //  Allocate a buffer to hold the new attribute.  Copy the existing attribute
                //  into this buffer and update the final vcn field.
                //

                NewAttribute = NtfsAllocatePool( PagedPool, Attribute->RecordLength + 8 );

                RtlCopyMemory( NewAttribute, Attribute, Attribute->RecordLength );
                LastVcn = NewAttribute->Form.Nonresident.HighestVcn = NewFinalVcn;

                //
                //  Now get the new mapping pairs size and build the mapping pairs.
                //  We could easily do it by hand but we want to always use the same
                //  routines to build these.
                //

                MappingPairsSize = NtfsGetSizeForMappingPairs( &Scb->Mcb,
                                                               0x10,
                                                               NewStartVcn,
                                                               &LastVcn,
                                                               &LastVcn );

                ASSERT( LastVcn > NewFinalVcn );

                NtfsBuildMappingPairs( &Scb->Mcb,
                                       NewStartVcn,
                                       &LastVcn,
                                       Add2Ptr( NewAttribute,
                                                NewAttribute->Form.Nonresident.MappingPairsOffset ));

                NewAttribute->RecordLength = QuadAlign( NewAttribute->Form.Nonresident.MappingPairsOffset + MappingPairsSize );

                //
                //  Make sure the current attribute is pinned.
                //

                NtfsPinMappedAttribute( IrpContext, Scb->Vcb, Context );

                //
                //  Now log the old and new attribute.
                //

                FileRecord->Lsn =
                NtfsWriteLog( IrpContext,
                              Scb->Vcb->MftScb,
                              NtfsFoundBcb( Context ),
                              DeleteAttribute,
                              NULL,
                              0,
                              CreateAttribute,
                              Attribute,
                              Attribute->RecordLength,
                              NtfsMftOffset( Context ),
                              PtrOffset( FileRecord, Attribute ),
                              0,
                              Scb->Vcb->BytesPerFileRecordSegment );

                //
                //  Now update the file record.
                //

                NtfsRestartRemoveAttribute( IrpContext, FileRecord, PtrOffset( FileRecord, Attribute ));

                FileRecord->Lsn =
                NtfsWriteLog( IrpContext,
                              Scb->Vcb->MftScb,
                              NtfsFoundBcb( Context ),
                              CreateAttribute,
                              NewAttribute,
                              NewAttribute->RecordLength,
                              DeleteAttribute,
                              NULL,
                              0,
                              NtfsMftOffset( Context ),
                              PtrOffset( FileRecord, Attribute ),
                              0,
                              Scb->Vcb->BytesPerFileRecordSegment );

                NtfsRestartInsertAttribute( IrpContext,
                                            FileRecord,
                                            PtrOffset( FileRecord, Attribute ),
                                            NewAttribute,
                                            NULL,
                                            NULL,
                                            0 );

                //
                //  Now we want to move to the next attribute and remove it if we
                //  haven't already.
                //

                if (PassCount == 0) {

                    if (!NtfsLookupNextAttributeForScb( IrpContext, Scb, Context )) {

                        ASSERTMSG( "Could not find next attribute for Scb\n", FALSE );
                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                    }

                //
                //  We are pointing to the correct file record in this case.
                //

                } else {

                    RestoreContext = FALSE;
                }

            } else {

                //
                //  Tell the delete routine to log the data and free the file record if
                //  possible but not to deallocate any clusters.  Since there are no
                //  clusters we can save the overhead of calling DeleteAllocation.
                //

                NtfsDeleteAttributeRecord( IrpContext,
                                           Scb->Fcb,
                                           DELETE_LOG_OPERATION | DELETE_RELEASE_FILE_RECORD,
                                           Context );

                //
                //  If this is our first pass then move to the previous file record
                //

                if (PassCount == 0) {

                    NtfsCleanupAttributeContext( IrpContext, Context );
                    NtfsInitializeAttributeContext( Context );

                    NtfsLookupAttributeForScb( IrpContext, Scb, &NewStartVcn, Context );
                }
            }

            if (PassCount == 1) { break; }

            PassCount += 1;
        }

    try_exit: NOTHING;

        //
        //  Restore the context if required.
        //

        if (RestoreContext) {

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );

            NtfsLookupAttributeForScb( IrpContext, Scb, &RestoreVcn, Context );
        }

    } finally {

        DebugUnwind( NtfsMergeFileRecords );

        if (NewAttribute != NULL) {

            NtfsFreePool( NewAttribute );
        }
    }

    return;
}


//
//  Local support routine
//

NTSTATUS
NtfsCheckLocksInZeroRange (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PFILE_OBJECT FileObject,
    IN PLONGLONG StartingOffset,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine is called from ZeroRangeInStream to verify that we can modify the data
    in the specified range.  We check both oplocks and filelocks here.

Arguments:

    Irp - This is the Irp for the request.  We set the next stack location to look like
        a write so that the file lock package has some context to use.

    Scb - Scb for the stream being modified.

    FileObject - File object used to originate the request.

    StartingOffset - This is the offset for the start of the request.

    ByteCount - This is the length of the current request.

Return Value:

    NTSTATUS - STATUS_PENDING if the request is posted for an oplock operation, STATUS_SUCCESS
        if the operation can proceed.  Otherwise this is the status to fail the request with.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;
    PAGED_CODE();

    Status = FsRtlCheckOplock( &Scb->ScbType.Data.Oplock,
                               Irp,
                               IrpContext,
                               NtfsOplockComplete,
                               NtfsPrePostIrp );

    //
    //  Proceed if we have SUCCESS.
    //

    if (Status == STATUS_SUCCESS) {

        //
        //  This oplock call can affect whether fast IO is possible.
        //  We may have broken an oplock to no oplock held.  If the
        //  current state of the file is FastIoIsNotPossible then
        //  recheck the fast IO state.
        //

        if (Scb->Header.IsFastIoPossible == FastIoIsNotPossible) {

            NtfsAcquireFsrtlHeader( Scb );
            Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
            NtfsReleaseFsrtlHeader( Scb );
        }

        //
        // We have to check for write access according to the current
        // state of the file locks.
        //

        if (Scb->ScbType.Data.FileLock != NULL) {

            //
            //  Update the Irp to point to the next stack location.
            //

            try {

                IoSetNextIrpStackLocation( Irp );
                IrpSp = IoGetCurrentIrpStackLocation( Irp );

                IrpSp->MajorFunction = IRP_MJ_WRITE;
                IrpSp->MinorFunction = 0;
                IrpSp->Flags = 0;
                IrpSp->Control = 0;

                IrpSp->Parameters.Write.Length = ByteCount;
                IrpSp->Parameters.Write.Key = 0;
                IrpSp->Parameters.Write.ByteOffset.QuadPart = *StartingOffset;

                IrpSp->DeviceObject = Scb->Vcb->Vpb->DeviceObject;
                IrpSp->FileObject = FileObject;

                if (!FsRtlCheckLockForWriteAccess( Scb->ScbType.Data.FileLock, Irp )) {

                    Status = STATUS_FILE_LOCK_CONFLICT;
                }

            //
            //  Always handle the exception initially in order to restore the Irp.
            //

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                //
                //  Zero out the current stack location and back up one position.
                //

                Status = GetExceptionCode();
            }

            //
            //  Restore the Irp to its previous state.
            //

            IoSkipCurrentIrpStackLocation( Irp );

            //
            //  Raise any non-success status.
            //

            if (Status != STATUS_SUCCESS) {

                NtfsRaiseStatus( IrpContext, Status, NULL, Scb->Fcb );
            }
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\checksup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    CheckSup.c

Abstract:

    This module implements check routines for Ntfs structures.

Author:

    Tom Miller      [TomM]          14-4-92

Revision History:

--*/

#include "NtfsProc.h"

//
//  Array for log records which require a target attribute.
//  A TRUE indicates that the corresponding restart operation
//  requires a target attribute.
//

BOOLEAN TargetAttributeRequired[] = {FALSE, FALSE, TRUE, TRUE,
                                     TRUE, TRUE, TRUE, TRUE,
                                     TRUE, TRUE, FALSE, TRUE,
                                     TRUE, TRUE, TRUE, TRUE,
                                     TRUE, TRUE, TRUE, TRUE,
                                     TRUE, TRUE, TRUE, TRUE,
                                     FALSE, FALSE, FALSE, FALSE,
                                     TRUE, FALSE, FALSE, FALSE,
                                     FALSE, TRUE, TRUE };

//
//  Local procedure prototypes
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCheckAttributeRecord)
#pragma alloc_text(PAGE, NtfsCheckFileRecord)
#pragma alloc_text(PAGE, NtfsCheckIndexBuffer)
#pragma alloc_text(PAGE, NtfsCheckIndexHeader)
#pragma alloc_text(PAGE, NtfsCheckIndexRoot)
#pragma alloc_text(PAGE, NtfsCheckLogRecord)
#pragma alloc_text(PAGE, NtfsCheckRestartTable)
#endif


BOOLEAN
NtfsCheckFileRecord (
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PFILE_REFERENCE FileReference OPTIONAL,
    OUT PULONG CorruptionHint
    )

/*++

Routine Description:

    Consistency check for file records.

Arguments:

    Vcb - the vcb it belongs to

    FileRecord - the filerecord to check

    FileReference - if specified double check the sequence number and self ref.
        fileref against it

    CorruptionHint - hint for debugging on where corruption occured;

Return Value:

    FALSE - if the file record is not valid
    TRUE - if it is

--*/
{
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER EndOfFileRecord;
    ULONG BytesPerFileRecordSegment = Vcb->BytesPerFileRecordSegment;
    BOOLEAN StandardInformationSeen = FALSE;
    ULONG BytesInOldHeader;

    PAGED_CODE();

    *CorruptionHint = 0;

    EndOfFileRecord = Add2Ptr( FileRecord, BytesPerFileRecordSegment );

    //
    //  Check the file record header for consistency.
    //

    if ((*(PULONG)FileRecord->MultiSectorHeader.Signature != *(PULONG)FileSignature)

            ||

        ((ULONG)FileRecord->MultiSectorHeader.UpdateSequenceArrayOffset >
         (SEQUENCE_NUMBER_STRIDE -
          (PAGE_SIZE / SEQUENCE_NUMBER_STRIDE + 1) * sizeof(USHORT)))

            ||

        ((ULONG)((FileRecord->MultiSectorHeader.UpdateSequenceArraySize - 1) * SEQUENCE_NUMBER_STRIDE) !=
         BytesPerFileRecordSegment)

            ||

        !FlagOn(FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE)) {

        DebugTrace( 0, 0, ("Invalid file record: %08lx\n", FileRecord) );

        *CorruptionHint = 1;
        ASSERTMSG( "Invalid resident file record\n", FALSE );
        return FALSE;
    }

    BytesInOldHeader = QuadAlign( sizeof( FILE_RECORD_SEGMENT_HEADER_V0 ) + (UpdateSequenceArraySize( BytesPerFileRecordSegment ) - 1) * sizeof( USHORT ));

    //
    //  Offset bounds checks
    //

    if ((FileRecord->FirstFreeByte > BytesPerFileRecordSegment) ||
        (FileRecord->FirstFreeByte < BytesInOldHeader) ||

        (FileRecord->BytesAvailable != BytesPerFileRecordSegment) ||

        (((ULONG)FileRecord->FirstAttributeOffset < BytesInOldHeader)   ||
         ((ULONG)FileRecord->FirstAttributeOffset >
                 BytesPerFileRecordSegment - SIZEOF_RESIDENT_ATTRIBUTE_HEADER)) ||

        (!IsQuadAligned( FileRecord->FirstAttributeOffset ))) {

        *CorruptionHint = 2;
        ASSERTMSG( "Out of bound offset in frs\n", FALSE );
        return FALSE;
    }

    //
    //  Optional fileref number check
    //

    if (ARGUMENT_PRESENT( FileReference )) {

        if ((FileReference->SequenceNumber != FileRecord->SequenceNumber) ||
            ((FileRecord->FirstAttributeOffset > BytesInOldHeader) &&
             ((FileRecord->SegmentNumberHighPart != FileReference->SegmentNumberHighPart) ||
              (FileRecord->SegmentNumberLowPart != FileReference->SegmentNumberLowPart)))) {

            *CorruptionHint = 3;
            ASSERTMSG( "Filerecord fileref doesn't match expected value\n", FALSE );
            return FALSE;
        }
    }

    //
    //  Loop to check all of the attributes.
    //

    for (Attribute = NtfsFirstAttribute(FileRecord);
         Attribute->TypeCode != $END;
         Attribute = NtfsGetNextRecord(Attribute)) {

//      if (!StandardInformationSeen &&
//          (Attribute->TypeCode != $STANDARD_INFORMATION) &&
//          XxEqlZero(FileRecord->BaseFileRecordSegment)) {
//
//          DebugTrace( 0, 0, ("Standard Information missing: %08lx\n", Attribute) );
//
//          ASSERTMSG( "Standard Information missing\n", FALSE );
//          return FALSE;
//      }

        StandardInformationSeen = TRUE;

        if (!NtfsCheckAttributeRecord( Vcb,
                                       FileRecord,
                                       Attribute,
                                       FALSE,
                                       CorruptionHint )) {

            return FALSE;
        }
    }
    return TRUE;
}


BOOLEAN
NtfsCheckAttributeRecord (
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN ULONG CheckHeaderOnly,
    IN PULONG CorruptionHint
    )

{
    PVOID NextAttribute;
    PVOID EndOfFileRecord;
    PVOID FirstFreeByte;
    PVOID Data;
    ULONG Length;
    ULONG BytesPerFileRecordSegment = Vcb->BytesPerFileRecordSegment;

    PAGED_CODE();

    EndOfFileRecord = Add2Ptr( FileRecord, BytesPerFileRecordSegment );
    FirstFreeByte = Add2Ptr( FileRecord, FileRecord->FirstFreeByte );

    //
    //  Do an alignment check before creating a ptr based on this value
    //

    if (!IsQuadAligned( Attribute->RecordLength )) {

        *CorruptionHint = Attribute->TypeCode + 0xc;
        ASSERTMSG( "Misaligned attribute length\n", FALSE );
        return FALSE;
    }

    NextAttribute = NtfsGetNextRecord(Attribute);

    //
    //  Check the fixed part of the attribute record header.
    //

    if ((Attribute->RecordLength >= BytesPerFileRecordSegment)

            ||

        (NextAttribute >= EndOfFileRecord)

            ||

        (FlagOn(Attribute->NameOffset, 1) != 0)

            ||

        ((Attribute->NameLength != 0) &&
         (((ULONG)Attribute->NameOffset + (ULONG)Attribute->NameLength) >
           Attribute->RecordLength))) {

        DebugTrace( 0, 0, ("Invalid attribute record header: %08lx\n", Attribute) );

        *CorruptionHint = Attribute->TypeCode + 1;
        ASSERTMSG( "Invalid attribute record header\n", FALSE );
        return FALSE;
    }

    if (NextAttribute > FirstFreeByte) {
        *CorruptionHint = Attribute->TypeCode + 2;
        ASSERTMSG( "Attributes beyond first free byte\n", FALSE );
        return FALSE;
    }

    //
    //  Check the resident attribute fields.
    //

    if (Attribute->FormCode == RESIDENT_FORM) {

        if ((Attribute->Form.Resident.ValueLength >= Attribute->RecordLength) ||

            (((ULONG)Attribute->Form.Resident.ValueOffset +
              Attribute->Form.Resident.ValueLength) > Attribute->RecordLength) ||

            (!IsQuadAligned( Attribute->Form.Resident.ValueOffset ))) {

            DebugTrace( 0, 0, ("Invalid resident attribute record header: %08lx\n", Attribute) );

            *CorruptionHint = Attribute->TypeCode + 3;
            ASSERTMSG( "Invalid resident attribute record header\n", FALSE );
            return FALSE;
        }

    //
    //  Check the nonresident attribute fields
    //

    } else if (Attribute->FormCode == NONRESIDENT_FORM) {

        VCN CurrentVcn, NextVcn;
        LCN CurrentLcn;
        LONGLONG Change;
        PCHAR ch;
        ULONG VcnBytes;
        ULONG LcnBytes;

        if ((Attribute->Form.Nonresident.LowestVcn >
                (Attribute->Form.Nonresident.HighestVcn + 1))

                ||

            ((ULONG)Attribute->Form.Nonresident.MappingPairsOffset >=
                Attribute->RecordLength)

                ||

            (Attribute->Form.Nonresident.ValidDataLength < 0) ||
            (Attribute->Form.Nonresident.FileSize < 0) ||
            (Attribute->Form.Nonresident.AllocatedLength < 0)

                ||

            (Attribute->Form.Nonresident.ValidDataLength >
                Attribute->Form.Nonresident.FileSize)

                ||

            (Attribute->Form.Nonresident.FileSize >
                Attribute->Form.Nonresident.AllocatedLength)) {

            DebugTrace( 0, 0, ("Invalid nonresident attribute record header: %08lx\n", Attribute) );

            *CorruptionHint = Attribute->TypeCode + 4;
            ASSERTMSG( "Invalid nonresident attribute record header\n", FALSE );
            return FALSE;
        }

        if (CheckHeaderOnly) { return TRUE; }

        //
        //  Implement the decompression algorithm, as defined in ntfs.h.
        //  (This code should look remarkably similar to what goes on in
        //  NtfsLookupAllocation!)
        //

        NextVcn = Attribute->Form.Nonresident.LowestVcn;
        CurrentLcn = 0;
        ch = (PCHAR)Attribute + Attribute->Form.Nonresident.MappingPairsOffset;

        //
        //  Loop to process mapping pairs, insuring we do not run off the end
        //  of the attribute, and that we do not map to nonexistant Lcns.
        //

        while (!IsCharZero(*ch)) {

            //
            // Set Current Vcn from initial value or last pass through loop.
            //

            CurrentVcn = NextVcn;

            //
            //  Extract the counts from the two nibbles of this byte.
            //

            VcnBytes = *ch & 0xF;
            LcnBytes = *ch++ >> 4;

            //
            //  Neither of these should be larger than a VCN.
            //

            if ((VcnBytes > sizeof( VCN )) ||
                (LcnBytes > sizeof( VCN ))) {

                DebugTrace( 0, 0, ("Invalid maping pair byte count: %08lx\n", Attribute) );

                *CorruptionHint = Attribute->TypeCode + 5;
                ASSERTMSG( "Invalid maping pair byte count\n", FALSE );
                return FALSE;
            }

            //
            //  Extract the Vcn change (use of RtlCopyMemory works for little-Endian)
            //  and update NextVcn.
            //

            Change = 0;

            //
            //  Make sure we are not going beyond the end of the attribute
            //  record, and that the Vcn change is not negative or zero.
            //

            if (((ULONG_PTR)(ch + VcnBytes + LcnBytes + 1) > (ULONG_PTR)NextAttribute)

                    ||

                IsCharLtrZero(*(ch + VcnBytes - 1))) {

                DebugTrace( 0, 0, ("Invalid maping pairs array: %08lx\n", Attribute) );

                *CorruptionHint = Attribute->TypeCode + 6;
                ASSERTMSG( "Invalid maping pairs array\n", FALSE );
                return FALSE;
            }

            RtlCopyMemory( &Change, ch, VcnBytes );
            ch += VcnBytes;
            NextVcn = NextVcn + Change;

            //
            //  Extract the Lcn change and update CurrentLcn.
            //

            Change = 0;
            if (IsCharLtrZero(*(ch + LcnBytes - 1))) {
                Change = Change - 1;
            }
            RtlCopyMemory( &Change, ch, LcnBytes );
            ch += LcnBytes;
            CurrentLcn = CurrentLcn + Change;

            if ((LcnBytes != 0) &&
                ((CurrentLcn + (NextVcn - CurrentVcn) - 1) > Vcb->TotalClusters)) {

                DebugTrace( 0, 0, ("Invalid Lcn: %08lx\n", Attribute) );

                *CorruptionHint = Attribute->TypeCode + 7;
                ASSERTMSG( "Invalid Lcn\n", FALSE );
                return FALSE;
            }
        }

        //
        //  Finally, check HighestVcn.
        //

        if (NextVcn != (Attribute->Form.Nonresident.HighestVcn + 1)) {

            DebugTrace( 0, 0, ("Disagreement with mapping pairs: %08lx\n", Attribute) );

            *CorruptionHint = Attribute->TypeCode + 8;
            ASSERTMSG( "Disagreement with mapping pairs\n", FALSE );
            return FALSE;
        }

    } else {

        DebugTrace( 0, 0, ("Invalid attribute form code: %08lx\n", Attribute) );

        ASSERTMSG( "Invalid attribute form code\n", FALSE );
        return FALSE;
    }

    //
    //  Now check the attributes by type code, if they are resident.  Not all
    //  attributes require specific checks (such as $STANDARD_INFORMATION and $DATA).
    //

    if (CheckHeaderOnly || !NtfsIsAttributeResident( Attribute )) {

        return TRUE;
    }

    Data = NtfsAttributeValue(Attribute);
    Length = Attribute->Form.Resident.ValueLength;

    switch (Attribute->TypeCode) {

    case $FILE_NAME:

        {
            if ((ULONG)((PFILE_NAME)Data)->FileNameLength * sizeof( WCHAR ) >
                (Length - (ULONG)sizeof(FILE_NAME) + sizeof( WCHAR ))) {

                DebugTrace( 0, 0, ("Invalid File Name attribute: %08lx\n", Attribute) );

                *CorruptionHint = Attribute->TypeCode + 9;
                ASSERTMSG( "Invalid File Name attribute\n", FALSE );
                return FALSE;
            }
            break;
        }

    case $INDEX_ROOT:

        {
            return NtfsCheckIndexRoot( Vcb, (PINDEX_ROOT)Data, Length );
        }

    case $STANDARD_INFORMATION:

        {
            if (Length < sizeof( STANDARD_INFORMATION ) &&
                Length != SIZEOF_OLD_STANDARD_INFORMATION)
            {
                DebugTrace( 0, 0, ("Invalid Standard Information attribute: %08lx\n", Attribute) );

                *CorruptionHint = Attribute->TypeCode + 0xa;
                ASSERTMSG( "Invalid Standard Information attribute size\n", FALSE );
                return FALSE;
            }

            break;
        }

    case $ATTRIBUTE_LIST:
    case $OBJECT_ID:
    case $SECURITY_DESCRIPTOR:
    case $VOLUME_NAME:
    case $VOLUME_INFORMATION:
    case $DATA:
    case $INDEX_ALLOCATION:
    case $BITMAP:
    case $REPARSE_POINT:
    case $EA_INFORMATION:
    case $EA:
    case $LOGGED_UTILITY_STREAM:

        break;

    default:

        {
            DebugTrace( 0, 0, ("Bad Attribute type code: %08lx\n", Attribute) );

            *CorruptionHint = Attribute->TypeCode + 0xb;
            ASSERTMSG( "Bad Attribute type code\n", FALSE );
            return FALSE;
        }
    }
    return TRUE;
}


BOOLEAN
NtfsCheckIndexRoot (
    IN PVCB Vcb,
    IN PINDEX_ROOT IndexRoot,
    IN ULONG AttributeSize
    )

{
    UCHAR ShiftValue;
    PAGED_CODE();

    //
    //  Check whether this index root uses clusters or if the cluster size is larger than
    //  the index block.
    //

    if (IndexRoot->BytesPerIndexBuffer >= Vcb->BytesPerCluster) {

        ShiftValue = (UCHAR) Vcb->ClusterShift;

    } else {

        ShiftValue = DEFAULT_INDEX_BLOCK_BYTE_SHIFT;
    }

    if ((AttributeSize < sizeof(INDEX_ROOT))

            ||

        ((IndexRoot->IndexedAttributeType != $FILE_NAME) && (IndexRoot->IndexedAttributeType != $UNUSED))

            ||

        ((IndexRoot->IndexedAttributeType == $FILE_NAME) && (IndexRoot->CollationRule != COLLATION_FILE_NAME))

            ||


        (IndexRoot->BytesPerIndexBuffer !=
         BytesFromIndexBlocks( IndexRoot->BlocksPerIndexBuffer, ShiftValue ))

            ||

        ((IndexRoot->BlocksPerIndexBuffer != 1) &&
         (IndexRoot->BlocksPerIndexBuffer != 2) &&
         (IndexRoot->BlocksPerIndexBuffer != 4) &&
         (IndexRoot->BlocksPerIndexBuffer != 8) &&
         (IndexRoot->BlocksPerIndexBuffer != 16) &&
         (IndexRoot->BlocksPerIndexBuffer != 32) &&
         (IndexRoot->BlocksPerIndexBuffer != 64) &&
         (IndexRoot->BlocksPerIndexBuffer != 128))) {

        DebugTrace( 0, 0, ("Bad Index Root: %08lx\n", IndexRoot) );

        ASSERTMSG( "Bad Index Root\n", FALSE );
        return FALSE;
    }

    return NtfsCheckIndexHeader( &IndexRoot->IndexHeader,
                                 AttributeSize - sizeof(INDEX_ROOT) + sizeof(INDEX_HEADER) );
}


BOOLEAN
NtfsCheckIndexBuffer (
    IN PSCB Scb,
    IN PINDEX_ALLOCATION_BUFFER IndexBuffer
    )

{
    ULONG BytesPerIndexBuffer = Scb->ScbType.Index.BytesPerIndexBuffer;

    PAGED_CODE();

    //
    //  Check the index buffer for consistency.
    //

    if ((*(PULONG)IndexBuffer->MultiSectorHeader.Signature != *(PULONG)IndexSignature)

            ||

        ((ULONG)IndexBuffer->MultiSectorHeader.UpdateSequenceArrayOffset >
         (SEQUENCE_NUMBER_STRIDE - (PAGE_SIZE / SEQUENCE_NUMBER_STRIDE + 1) * sizeof(USHORT)))

            ||

        ((ULONG)((IndexBuffer->MultiSectorHeader.UpdateSequenceArraySize - 1) * SEQUENCE_NUMBER_STRIDE) !=
         BytesPerIndexBuffer)) {

        DebugTrace( 0, 0, ("Invalid Index Buffer: %08lx\n", IndexBuffer) );

        ASSERTMSG( "Invalid resident Index Buffer\n", FALSE );
        return FALSE;
    }

    return NtfsCheckIndexHeader( &IndexBuffer->IndexHeader,
                                 BytesPerIndexBuffer -
                                  FIELD_OFFSET(INDEX_ALLOCATION_BUFFER, IndexHeader) );
}


BOOLEAN
NtfsCheckIndexHeader (
    IN PINDEX_HEADER IndexHeader,
    IN ULONG BytesAvailable
    )

{
    PINDEX_ENTRY IndexEntry, NextIndexEntry;
    PINDEX_ENTRY EndOfIndex;
    ULONG MinIndexEntry = sizeof(INDEX_ENTRY);

    PAGED_CODE();

    if (FlagOn(IndexHeader->Flags, INDEX_NODE)) {

        MinIndexEntry += sizeof(VCN);
    }

    if ((IndexHeader->FirstIndexEntry > (BytesAvailable - MinIndexEntry))

            ||

        (IndexHeader->FirstFreeByte > BytesAvailable)

            ||

        (IndexHeader->BytesAvailable > BytesAvailable)

            ||

        ((IndexHeader->FirstIndexEntry + MinIndexEntry) > IndexHeader->FirstFreeByte)

            ||

        (IndexHeader->FirstFreeByte > IndexHeader->BytesAvailable)) {

        DebugTrace( 0, 0, ("Bad Index Header: %08lx\n", IndexHeader) );

        ASSERTMSG( "Bad Index Header\n", FALSE );
        return FALSE;
    }

    IndexEntry = NtfsFirstIndexEntry(IndexHeader);

    EndOfIndex = Add2Ptr(IndexHeader, IndexHeader->FirstFreeByte);

    while (TRUE) {

        NextIndexEntry = NtfsNextIndexEntry(IndexEntry);

        if (((ULONG)IndexEntry->Length < MinIndexEntry)

                ||

            (NextIndexEntry > EndOfIndex)

                ||

//          ((ULONG)IndexEntry->AttributeLength >
//           ((ULONG)IndexEntry->Length - MinIndexEntry))
//
//              ||

            (BooleanFlagOn(IndexEntry->Flags, INDEX_ENTRY_NODE) !=
             BooleanFlagOn(IndexHeader->Flags, INDEX_NODE))) {

            DebugTrace( 0, 0, ("Bad Index Entry: %08lx\n", IndexEntry) );

            ASSERTMSG( "Bad Index Entry\n", FALSE );
            return FALSE;
        }

        if (FlagOn(IndexEntry->Flags, INDEX_ENTRY_END)) {
            break;
        }
        IndexEntry = NextIndexEntry;
    }
    return TRUE;
}


BOOLEAN
NtfsCheckLogRecord (
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    IN ULONG LogRecordLength,
    IN TRANSACTION_ID TransactionId,
    IN ULONG AttributeEntrySize
    )

{
    BOOLEAN ValidLogRecord = FALSE;
    PAGED_CODE();

    //
    //  We make the following checks on the log record.
    //
    //      - Minimum length must contain an NTFS_LOG_RECORD_HEADER
    //      - Transaction Id must be a valid value (a valid index offset)
    //
    //  The following are values in the log record.
    //
    //      - Redo/Undo offset must be quadaligned
    //      - Redo/Undo offset + length must be contained in the log record
    //      - Target attribute must be a valid value (either 0 or valid index offset)
    //      - Record offset must be quad-aligned and less than the file record size.
    //      - Log record size must be sufficient for Lcn's to follow.
    //
    //  Use the separate assert messages in order to identify the error (used the same text so
    //  the compiler can still optimize).
    //

    if (LogRecordLength < sizeof( NTFS_LOG_RECORD_HEADER )) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    } else if (TransactionId == 0) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    } else if ((TransactionId - sizeof( RESTART_TABLE )) % sizeof( TRANSACTION_ENTRY )) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    } else if (FlagOn( LogRecord->RedoOffset, 7 )) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    } else if (FlagOn( LogRecord->UndoOffset, 7 )) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    } else if ((ULONG) LogRecord->RedoOffset + LogRecord->RedoLength > LogRecordLength) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    } else if ((LogRecord->UndoOperation != CompensationLogRecord) &&
               ((ULONG) LogRecord->UndoOffset + LogRecord->UndoLength > LogRecordLength)) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    } else if (LogRecordLength < (sizeof( NTFS_LOG_RECORD_HEADER ) +
                                  ((LogRecord->LcnsToFollow != 0) ?
                                   (sizeof( LCN ) * (LogRecord->LcnsToFollow - 1)) :
                                   0))) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    //
    //  NOTE: The next two clauses test different cases for the TargetAttribute in
    //  the log record.  Don't add any tests after this point as the ValidLogRecord
    //  value is set to TRUE internally and no other checks take place.
    //

    } else if (LogRecord->TargetAttribute == 0) {

        if (((LogRecord->RedoOperation <= UpdateRecordDataAllocation) &&
                 TargetAttributeRequired[LogRecord->RedoOperation]) ||
                ((LogRecord->UndoOperation <= UpdateRecordDataAllocation) &&
                 TargetAttributeRequired[LogRecord->UndoOperation])) {

            ASSERTMSG( "Invalid log record\n", FALSE );

        } else {

            ValidLogRecord = TRUE;
        }

    //
    //  Read the note above if changing this.
    //

    } else if ((LogRecord->RedoOperation != ForgetTransaction) &&
               ((LogRecord->TargetAttribute - sizeof( RESTART_TABLE )) % AttributeEntrySize)) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    //
    //  Read the note above if changing this.
    //

    } else {

        ValidLogRecord = TRUE;
    }

    return ValidLogRecord;
}


BOOLEAN
NtfsCheckRestartTable (
    IN PRESTART_TABLE RestartTable,
    IN ULONG TableSize
    )
{
    ULONG ActualTableSize;
    ULONG Index;
    PDIRTY_PAGE_ENTRY_V0 NextEntry;

    PAGED_CODE();

    //
    //  We want to make the following checks.
    //
    //      EntrySize - Must be less than table size and non-zero.
    //
    //      NumberEntries - The table size must contain at least this many entries
    //                      plus the table header.
    //
    //      NumberAllocated - Must be less than/equal to NumberEntries
    //
    //      FreeGoal - Must lie in the table.
    //
    //      FirstFree
    //      LastFree - Must either be 0 or be on a restart entry boundary.
    //

    if ((RestartTable->EntrySize == 0) ||
        (RestartTable->EntrySize > TableSize) ||
        ((RestartTable->EntrySize + sizeof( RESTART_TABLE )) > TableSize) ||
        (((TableSize - sizeof( RESTART_TABLE )) / RestartTable->EntrySize) < RestartTable->NumberEntries) ||
        (RestartTable->NumberAllocated > RestartTable->NumberEntries)) {

        ASSERTMSG( "Invalid Restart Table sizes\n", FALSE );
        return FALSE;
    }

    ActualTableSize = (RestartTable->EntrySize * RestartTable->NumberEntries) +
                      sizeof( RESTART_TABLE );

    if ((RestartTable->FirstFree > ActualTableSize) ||
        (RestartTable->LastFree > ActualTableSize) ||
        ((RestartTable->FirstFree != 0) && (RestartTable->FirstFree < sizeof( RESTART_TABLE ))) ||
        ((RestartTable->LastFree != 0) && (RestartTable->LastFree < sizeof( RESTART_TABLE )))) {

        ASSERTMSG( "Invalid Restart Table List Head\n", FALSE );
        return FALSE;
    }

    //
    //  Make a pass through the table verifying that each entry
    //  is either allocated or points to a valid offset in the
    //  table.
    //

    for (Index = 0;Index < RestartTable->NumberEntries; Index++) {

        NextEntry = Add2Ptr( RestartTable,
                             ((Index * RestartTable->EntrySize) +
                              sizeof( RESTART_TABLE )));

        if ((NextEntry->AllocatedOrNextFree != RESTART_ENTRY_ALLOCATED) &&
            (NextEntry->AllocatedOrNextFree != 0) &&
            ((NextEntry->AllocatedOrNextFree < sizeof( RESTART_TABLE )) ||
             (((NextEntry->AllocatedOrNextFree - sizeof( RESTART_TABLE )) % RestartTable->EntrySize) != 0))) {

            ASSERTMSG( "Invalid Restart Table Entry\n", FALSE );
            return FALSE;
        }
    }

    //
    //  Walk through the list headed by the first entry to make sure none
    //  of the entries are currently being used.
    //

    for (Index = RestartTable->FirstFree; Index != 0; Index = NextEntry->AllocatedOrNextFree) {

        if (Index == RESTART_ENTRY_ALLOCATED) {

            ASSERTMSG( "Invalid Restart Table Free List\n", FALSE );
            return FALSE;
        }

        NextEntry = Add2Ptr( RestartTable, Index );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\bitmpsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    BitmpSup.c

Abstract:

    This module implements the general bitmap allocation & deallocation
    routines for Ntfs.  It is defined into two main parts the first
    section handles the bitmap file for clusters on the disk.  The
    second part is for bitmap attribute allocation (e.g., the mft bitmap).

    So unlike other modules this one has local procedure prototypes and
    definitions followed by the exported bitmap file routines, followed
    by the local bitmap file routines, and then followed by the bitmap
    attribute routines, followed by the local bitmap attribute allocation
    routines.

Author:

    Gary Kimura     [GaryKi]        23-Nov-1991

Revision History:

--*/

#include "NtfsProc.h"

#ifdef NTFS_FRAGMENT_DISK
BOOLEAN NtfsFragmentDisk = FALSE;
ULONG NtfsFragmentLength = 2;
BOOLEAN NtfsFragmentMft = FALSE;
#endif

#ifdef NTFS_CHECK_CACHED_RUNS
BOOLEAN NtfsDoVerifyCachedRuns = FALSE;
#endif

#define NTFS_MFT_ZONE_DEFAULT_SHIFT         (3)
#define BITMAP_VOLATILE_FREE_COUNT          (0x400)

//
//  Define stack overflow threshhold.
//

#define OVERFLOW_RECORD_THRESHHOLD         (0xF00)

//
//  A mask of single bits used to clear and set bits in a byte
//

static UCHAR BitMask[] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_BITMPSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('BFtN')

#define MIN3(A,B,C) ((((A) < (B)) && ((A) < (C))) ? (A) : ((((B) < (A)) && ((B) < (C))) ? (B) : (C)))

#define CollectAllocateClusterStats(VCB,SIZE,HINT) {            \
    (VCB)->Statistics->Ntfs.Allocate.Calls += 1;                \
    (VCB)->Statistics->Ntfs.Allocate.Clusters += (ULONG)(SIZE); \
    if (HINT) { (VCB)->Statistics->Ntfs.Allocate.Hints += 1; }  \
}

#define IncrementAllocateClusterStats(VCB) {            \
    (VCB)->Statistics->Ntfs.Allocate.RunsReturned += 1; \
}

#define IncrementHintHonoredStats(VCB,SIZE) {                        \
    (VCB)->Statistics->Ntfs.Allocate.HintsHonored += 1;              \
    (VCB)->Statistics->Ntfs.Allocate.HintsClusters += (ULONG)(SIZE); \
}

#define IncrementCacheHitStats(VCB,SIZE) {                           \
    (VCB)->Statistics->Ntfs.Allocate.Cache += 1;                     \
    (VCB)->Statistics->Ntfs.Allocate.CacheClusters += (ULONG)(SIZE); \
}

#define IncrementCacheMissStats(VCB,SIZE) {                              \
    (VCB)->Statistics->Ntfs.Allocate.CacheMiss += 1;                     \
    (VCB)->Statistics->Ntfs.Allocate.CacheMissClusters += (ULONG)(SIZE); \
}


//
//  Local routines to manage the cached free clusters.
//

BOOLEAN
NtfsLookupCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    OUT PLCN StartingLcn,
    OUT PLONGLONG RunLength,
    OUT PUSHORT Index OPTIONAL
    );

BOOLEAN
NtfsGetNextCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT Index,
    OUT PLCN StartingLcn,
    OUT PLONGLONG RunLength
    );

BOOLEAN
NtfsLookupCachedLcnByLength (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LONGLONG Length,
    IN BOOLEAN AllowShorter,
    IN LCN Lcn,
    OUT PLCN StartingLcn,
    OUT PLONGLONG RunLength,
    OUT PUSHORT Index OPTIONAL
    );

VOID
NtfsInsertCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    IN LONGLONG Length
    );

VOID
NtfsRemoveCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    IN LONGLONG Length
    );

//
//  The following are the internal routines we use to manage this.
//

BOOLEAN
NtfsGrowCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns
    );

VOID
NtfsCompactCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN LcnSortedList
    );

VOID
NtfsAddCachedRunMult (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN RTL_BITMAP_RUN *RunArray,
    IN ULONG RunCount
    );

VOID
NtfsDeleteCachedRun (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT LcnIndex,
    IN USHORT LenIndex
    );

VOID
NtfsGrowLengthInCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN PNTFS_LCN_CLUSTER_RUN ThisEntry,
    IN USHORT LcnIndex
    );

VOID
NtfsShrinkLengthInCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN PNTFS_LCN_CLUSTER_RUN ThisEntry,
    IN USHORT LcnIndex
    );

USHORT
NtfsGetCachedLengthInsertionPoint (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    IN LONGLONG Length
    );

VOID
NtfsInsertCachedRun (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    IN LONGLONG Length,
    IN USHORT LcnIndex
    );

BOOLEAN
NtfsPositionCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    OUT PUSHORT Index
    );

BOOLEAN
NtfsPositionCachedLcnByLength (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LONGLONG RunLength,
    IN PLCN Lcn OPTIONAL,
    IN PUSHORT StartIndex OPTIONAL,
    IN BOOLEAN SearchForward,
    OUT PUSHORT RunIndex
    );

#ifdef NTFS_CHECK_CACHED_RUNS
VOID
NtfsVerifyCachedLcnRuns (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN SkipSortCheck,
    IN BOOLEAN SkipBinCheck
    );

VOID
NtfsVerifyCachedLenRuns (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN SkipSortCheck
    );

VOID
NtfsVerifyCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN BOOLEAN SkipSortCheck,
    IN BOOLEAN SkipBinCheck
    );
#endif

//
//  Macros to manipulate the cached run structures.
//

//
//  VOID
//  NtfsModifyCachedBinArray (
//      IN PNTFS_CACHED_RUNS CachedRuns,
//      IN LONGLONG OldLength
//      IN LONGLONG NewLength
//      );
//

#define NtfsModifyCachedBinArray(C,OL,NL) {         \
    ASSERT( (NL) != 0 );                            \
    ASSERT( (OL) != 0 );                            \
    if ((OL) <= (C)->Bins) {                        \
        (C)->BinArray[ (OL) - 1 ] -= 1;             \
    }                                               \
    if ((NL) <= (C)->Bins) {                        \
        (C)->BinArray[ (NL) - 1 ] += 1;             \
    }                                               \
}



//
//  Some local manifest constants
//

#define BYTES_PER_PAGE                   (PAGE_SIZE)
#define BITS_PER_PAGE                    (BYTES_PER_PAGE * 8)

//
//  Local procedure prototypes for direct bitmap manipulation
//

VOID
NtfsAllocateBitmapRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN LONGLONG ClusterCount,
    IN BOOLEAN FromCachedRuns
    );

VOID
NtfsFreeBitmapRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN OUT PLONGLONG ClusterCount
    );

BOOLEAN
NtfsFindFreeBitmapRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LONGLONG NumberToFind,
    IN LCN StartingSearchHint,
    IN BOOLEAN ReturnAnyLength,
    IN BOOLEAN IgnoreMftZone,
    OUT PLCN ReturnedLcn,
    OUT PLONGLONG ClusterCountFound
    );

BOOLEAN
NtfsScanBitmapRange (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartLcn,
    IN LCN BeyondLcn,
    IN LONGLONG NumberToFind,
    OUT PLCN ReturnedLcn,
    OUT PLONGLONG ClusterCountFound
    );

BOOLEAN
NtfsAddRecentlyDeallocated (
    IN PVCB Vcb,
    IN LCN Lcn,
    IN OUT PRTL_BITMAP Bitmap
    );

//
//  The following two prototype are macros for calling map or pin data
//
//  VOID
//  NtfsMapPageInBitmap (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN LCN Lcn,
//      OUT PLCN StartingLcn,
//      IN OUT PRTL_BITMAP Bitmap,
//      OUT PBCB *BitmapBcb,
//      );
//
//  VOID
//  NtfsPinPageInBitmap (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN LCN Lcn,
//      OUT PLCN StartingLcn,
//      IN OUT PRTL_BITMAP Bitmap,
//      OUT PBCB *BitmapBcb,
//      );
//

#define NtfsMapPageInBitmap(A,B,C,D,E,F) NtfsMapOrPinPageInBitmap(A,B,C,D,E,F,FALSE)

#define NtfsPinPageInBitmap(A,B,C,D,E,F) NtfsMapOrPinPageInBitmap(A,B,C,D,E,F,TRUE)

VOID
NtfsMapOrPinPageInBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN Lcn,
    OUT PLCN StartingLcn,
    IN OUT PRTL_BITMAP Bitmap,
    OUT PBCB *BitmapBcb,
    IN BOOLEAN AlsoPinData
    );

//
//  Local procedure prototype for doing read ahead on our cached
//  run information
//

VOID
NtfsReadAheadCachedBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn
    );

//
//  Local procedure prototypes for routines that help us find holes
//  that need to be filled with MCBs
//

BOOLEAN
NtfsGetNextHoleToFill (
    IN PIRP_CONTEXT IrpContext,
    IN PNTFS_MCB Mcb,
    IN VCN StartingVcn,
    IN VCN EndingVcn,
    OUT PVCN VcnToFill,
    OUT PLONGLONG ClusterCountToFill,
    OUT PLCN PrecedingLcn
    );

LONGLONG
NtfsScanMcbForRealClusterCount (
    IN PIRP_CONTEXT IrpContext,
    IN PNTFS_MCB Mcb,
    IN VCN StartingVcn,
    IN VCN EndingVcn
    );

//
//  A local procedure prototype for masking out recently deallocated records
//

BOOLEAN
NtfsAddDeallocatedRecords (
    IN PVCB Vcb,
    IN PSCB Scb,
    IN ULONG StartingIndexOfBitmap,
    IN OUT PRTL_BITMAP Bitmap
    );

//
//  Local procedure prototypes for managing the Mft zone.
//

LCN
NtfsInitializeMftZone (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

BOOLEAN
NtfsReduceMftZone (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

//
//  Local procedure prototype to check the stack usage in the record
//  package.
//

VOID
NtfsCheckRecordStackUsage (
    IN PIRP_CONTEXT IrpContext
    );

//
//  Local procedure prototype to check for a continuos volume bitmap run
//

VOID
NtfsRunIsClear (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN LONGLONG RunLength
    );

//
//  Local procedure prototypes for managing windows of deleted entries.
//

VOID
NtfsAddDelWindow (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN LcnList
    );

PNTFS_DELETED_RUNS
NtfsGetDelWindow (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN LcnList,
    OUT PUSHORT WindowIndex OPTIONAL
    );

VOID
NtfsShrinkDelWindow (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN BOOLEAN ShrinkFromStart,
    IN BOOLEAN LcnWindow,
    IN USHORT WindowIndex
    );

VOID
NtfsDeleteDelWindow (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN BOOLEAN LcnWindow,
    IN USHORT WindowIndex
    );

VOID
NtfsMakeSpaceCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN StartingLcn,
    IN RTL_BITMAP_RUN *RunArray,
    IN ULONG RunCount,
    IN PUSHORT LcnSorted OPTIONAL
    );

//
//  Local procedure prototype for dumping cached bitmap information
//

#ifdef NTFSDBG
ULONG
NtfsDumpCachedMcbInformation (
    IN PVCB Vcb
    );

#else

#define NtfsDumpCachedMcbInformation(V) (0)

#endif // NTFSDBG

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAddBadCluster)
#pragma alloc_text(PAGE, NtfsAddCachedRun)
#pragma alloc_text(PAGE, NtfsAddCachedRunMult)
#pragma alloc_text(PAGE, NtfsAddDeallocatedRecords)
#pragma alloc_text(PAGE, NtfsAddDelWindow)
#pragma alloc_text(PAGE, NtfsAddRecentlyDeallocated)
#pragma alloc_text(PAGE, NtfsAllocateBitmapRun)
#pragma alloc_text(PAGE, NtfsAllocateClusters)
#pragma alloc_text(PAGE, NtfsAllocateMftReservedRecord)
#pragma alloc_text(PAGE, NtfsAllocateRecord)
#pragma alloc_text(PAGE, NtfsGrowLengthInCachedLcn)
#pragma alloc_text(PAGE, NtfsShrinkLengthInCachedLcn)
#pragma alloc_text(PAGE, NtfsCheckRecordStackUsage)
#pragma alloc_text(PAGE, NtfsCleanupClusterAllocationHints)
#pragma alloc_text(PAGE, NtfsCompactCachedRuns)
#pragma alloc_text(PAGE, NtfsCreateMftHole)
#pragma alloc_text(PAGE, NtfsDeallocateClusters)
#pragma alloc_text(PAGE, NtfsDeallocateRecord)
#pragma alloc_text(PAGE, NtfsDeallocateRecordsComplete)
#pragma alloc_text(PAGE, NtfsDeleteCachedRun)
#pragma alloc_text(PAGE, NtfsDeleteDelWindow)
#pragma alloc_text(PAGE, NtfsFindFreeBitmapRun)
#pragma alloc_text(PAGE, NtfsFindMftFreeTail)
#pragma alloc_text(PAGE, NtfsFreeBitmapRun)
#pragma alloc_text(PAGE, NtfsGetCachedLengthInsertionPoint)
#pragma alloc_text(PAGE, NtfsGetDelWindow)
#pragma alloc_text(PAGE, NtfsGetNextCachedLcn)
#pragma alloc_text(PAGE, NtfsGetNextHoleToFill)
#pragma alloc_text(PAGE, NtfsGrowCachedRuns)
#pragma alloc_text(PAGE, NtfsInitializeCachedRuns)
#pragma alloc_text(PAGE, NtfsInitializeClusterAllocation)
#pragma alloc_text(PAGE, NtfsInitializeMftZone)
#pragma alloc_text(PAGE, NtfsInitializeRecordAllocation)
#pragma alloc_text(PAGE, NtfsInsertCachedLcn)
#pragma alloc_text(PAGE, NtfsInsertCachedRun)
#pragma alloc_text(PAGE, NtfsIsRecordAllocated)
#pragma alloc_text(PAGE, NtfsLookupCachedLcn)
#pragma alloc_text(PAGE, NtfsLookupCachedLcnByLength)
#pragma alloc_text(PAGE, NtfsMakeSpaceCachedLcn)
#pragma alloc_text(PAGE, NtfsMapOrPinPageInBitmap)
#pragma alloc_text(PAGE, NtfsModifyBitsInBitmap)
#pragma alloc_text(PAGE, NtfsPositionCachedLcn)
#pragma alloc_text(PAGE, NtfsPositionCachedLcnByLength)
#pragma alloc_text(PAGE, NtfsPreAllocateClusters)
#pragma alloc_text(PAGE, NtfsReadAheadCachedBitmap)
#pragma alloc_text(PAGE, NtfsReduceMftZone)
#pragma alloc_text(PAGE, NtfsReinitializeCachedRuns)
#pragma alloc_text(PAGE, NtfsRemoveCachedLcn)
#pragma alloc_text(PAGE, NtfsReserveMftRecord)
#pragma alloc_text(PAGE, NtfsRestartClearBitsInBitMap)
#pragma alloc_text(PAGE, NtfsRestartSetBitsInBitMap)
#pragma alloc_text(PAGE, NtfsRunIsClear)
#pragma alloc_text(PAGE, NtfsScanBitmapRange)
#pragma alloc_text(PAGE, NtfsScanEntireBitmap)
#pragma alloc_text(PAGE, NtfsScanMcbForRealClusterCount)
#pragma alloc_text(PAGE, NtfsScanMftBitmap)
#pragma alloc_text(PAGE, NtfsShrinkDelWindow)
#pragma alloc_text(PAGE, NtfsUninitializeCachedRuns)
#pragma alloc_text(PAGE, NtfsUninitializeRecordAllocation)

#ifdef NTFS_CHECK_CACHED_RUNS
#pragma alloc_text(PAGE, NtfsVerifyCachedLcnRuns)
#pragma alloc_text(PAGE, NtfsVerifyCachedLenRuns)
#pragma alloc_text(PAGE, NtfsVerifyCachedRuns)
#endif

#endif


VOID
NtfsInitializeClusterAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine initializes the cluster allocation structures within the
    specified Vcb.  It reads in as necessary the bitmap and scans it for
    free space and builds the free space mcb based on this scan.

    This procedure is multi-call save.  That is, it can be used to
    reinitialize the cluster allocation without first calling the
    uninitialize cluster allocation routine.

Arguments:

    Vcb - Supplies the Vcb being initialized

Return Value:

    None.

--*/

{
    LONGLONG ClusterCount;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInitializeClusterAllocation\n") );

    NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );

    try {

        //
        //  The bitmap file currently doesn't have a paging IO resource.
        //  Create one here so that we won't serialize synchronization
        //  of the bitmap package with the lazy writer.
        //

        Vcb->BitmapScb->Header.PagingIoResource =
        Vcb->BitmapScb->Fcb->PagingIoResource = NtfsAllocateEresource();

        //
        //  We didn't mark the Scb for the volume bitmap as MODIFIED_NO_WRITE
        //  when creating it.  Do so now.
        //

        SetFlag( Vcb->BitmapScb->ScbState, SCB_STATE_MODIFIED_NO_WRITE );

        //
        //  Now call a bitmap routine to scan the entire bitmap.  This
        //  routine will compute the number of free clusters in the
        //  bitmap and set the largest free runs that we find into the
        //  cached bitmap structures.
        //

        NtfsScanEntireBitmap( IrpContext, Vcb, FALSE );

        //
        //  Our last operation is to set the hint lcn which is used by
        //  our allocation routine as a hint on where to find free space.
        //  In the running system it is the last lcn that we've allocated.
        //  But for startup we'll put it to be the first free run that
        //  is stored in the free space mcb.
        //

        NtfsGetNextCachedLcn( &Vcb->CachedRuns,
                              0,
                              &Vcb->LastBitmapHint,
                              &ClusterCount );
        NtfsInitializeMftZone( IrpContext, Vcb );

    } finally {

        DebugUnwind( NtfsInitializeClusterAllocation );

        NtfsReleaseScb( IrpContext, Vcb->BitmapScb );
    }

    DebugTrace( -1, Dbg, ("NtfsInitializeClusterAllocation -> VOID\n") );

    return;
}


BOOLEAN
NtfsAllocateClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PSCB Scb,
    IN VCN OriginalStartingVcn,
    IN BOOLEAN AllocateAll,
    IN LONGLONG ClusterCount,
    IN PLCN TargetLcn OPTIONAL,
    IN OUT PLONGLONG DesiredClusterCount
    )

/*++

Routine Description:

    This routine allocates disk space.  It fills in the unallocated holes in
    input mcb with allocated clusters from starting Vcn to the cluster count.

    The basic algorithm used by this procedure is as follows:

    1. Compute the EndingVcn from the StartingVcn and cluster count

    2. Compute the real number of clusters needed to allocate by scanning
       the mcb from starting to ending vcn seeing where the real holes are

    3. If the real cluster count is greater than the known free cluster count
       then the disk is full

    4. Call a routine that takes a starting Vcn, ending Vcn, and the Mcb and
       returns the first hole that needs to be filled and while there is a hole
       to be filled...

       5. Check if the run preceding the hole that we are trying to fill
          has an ending Lcn and if it does then with that Lcn see if we
          get a cache hit, if we do then allocate the cluster

       6. If we are still looking then enumerate through the cached free runs
          and if we find a suitable one.  Allocate the first suitable run we find that
          satisfies our request.  Also in the loop remember the largest
          suitable run we find.

       8. If we are still looking then bite the bullet and scan the bitmap on
          the disk for a free run using either the preceding Lcn as a hint if
          available or the stored last bitmap hint in the Vcb.

       9. At this point we've located a run of clusters to allocate.  To do the
          actual allocation we allocate the space from the bitmap, decrement
          the number of free clusters left, and update the hint.

       10. Before going back to step 4 we move the starting Vcn to be the point
           one after the run we've just allocated.

    11. With the allocation complete we update the last bitmap hint stored in
        the Vcb to be the last Lcn we've allocated, and we call a routine
        to do the read ahead in the cached bitmap at the ending lcn.

Arguments:

    Vcb - Supplies the Vcb used in this operation

    Scb - Supplies an Scb whose Mcb contains the current retrieval information
        for the file and on exit will contain the updated retrieval
        information

    StartingVcn - Supplies a starting cluster for us to begin allocation

    AllocateAll - If TRUE, allocate all the clusters here.  Don't break
        up request.

    ClusterCount - Supplies the number of clusters to allocate

    TargetLcn - If supplied allocate at this lcn rather than searching for free space
                used by the movefile defragging code

    DesiredClusterCount - Supplies the number of clusters we would like allocated
        and will allocate if it doesn't require additional runs.  On return
        this value is the number of clusters allocated.

Return Value:

    FALSE - if no clusters were allocated (they were already allocated)
    TRUE - if clusters were allocated

Important Note:

    This routine will stop after allocating MAXIMUM_RUNS_AT_ONCE runs, in order
    to limit the size of allocating transactions.  The caller must be aware that
    he may not get all of the space he asked for if the disk is real fragmented.

--*/

{
    VCN StartingVcn = OriginalStartingVcn;
    VCN EndingVcn;
    VCN DesiredEndingVcn;

    PNTFS_MCB Mcb = &Scb->Mcb;

    LONGLONG RemainingDesiredClusterCount;

    VCN VcnToFill;
    LONGLONG ClusterCountToFill;
    LCN PrecedingLcn;

    BOOLEAN FoundClustersToAllocate;
    LCN FoundLcn;
    LONGLONG FoundClusterCount;
    LONGLONG LargestBitmapClusterCount = 0;
    BOOLEAN FromCachedRuns;

    USHORT RunIndex;

    LCN HintLcn;

    ULONG LoopCount = 0;
    ULONG RunCount = 0;

    BOOLEAN ClustersAllocated = FALSE;
    BOOLEAN GotAHoleToFill = TRUE;
    BOOLEAN FoundRun = FALSE;
    BOOLEAN ExtendingMft = FALSE;
    BOOLEAN AllocateFromBitmap = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAllocateClusters\n") );
    DebugTrace( 0, Dbg, ("StartVcn            = %0I64x\n", StartingVcn) );
    DebugTrace( 0, Dbg, ("ClusterCount        = %0I64x\n", ClusterCount) );
    DebugTrace( 0, Dbg, ("DesiredClusterCount = %0I64x\n", *DesiredClusterCount) );

    NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );

    try {

        if (FlagOn( Vcb->VcbState, VCB_STATE_RELOAD_FREE_CLUSTERS )) {

            NtfsScanEntireBitmap( IrpContext, Vcb, FALSE );
        }

        //
        //  Check to see if we are defragmenting
        //

        if (ARGUMENT_PRESENT( TargetLcn )) {

            FoundLcn = *TargetLcn;

            //
            //  Ensure that the run is NOT already allocated
            //

            NtfsRunIsClear( IrpContext, Vcb, FoundLcn, ClusterCount );

            //
            //  Get the allocation data from the Scb
            //

            VcnToFill = OriginalStartingVcn;
            FoundClusterCount = ClusterCount;
            *DesiredClusterCount = ClusterCount;

            GotAHoleToFill = FALSE;
            ClustersAllocated = TRUE;
            FoundRun = TRUE;
            FromCachedRuns = FALSE;

            //
            //  We already have the allocation so skip over the allocation section
            //

            goto Defragment;
        }

        //
        //  Compute the ending vcn, and the cluster count of how much we really
        //  need to allocate (based on what is already allocated).  Then check if we
        //  have space on the disk.
        //

        EndingVcn = (StartingVcn + ClusterCount) - 1;

        ClusterCount = NtfsScanMcbForRealClusterCount( IrpContext, Mcb, StartingVcn, EndingVcn );

        if ((ClusterCount + IrpContext->DeallocatedClusters) > Vcb->FreeClusters) {

            NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
        }

        //
        //  Let's see if it is ok to allocate clusters for this Scb now,
        //  in case compressed files have over-reserved the space.  This
        //  calculation is done in such a way as to guarantee we do not
        //  have either of the terms subtracting through zero, even if
        //  we were to over-reserve the free space on the disk due to a
        //  hot fix or something.  Always satisfy this request if we are
        //  in the paging IO write path because we know we are using clusters
        //  already reserved for this stream.
        //

        NtfsAcquireReservedClusters( Vcb );

        //
        //  Do the fast test to see if there is even a chance of failing the reservation test
        //  or if we will allocate this space anyway.
        //  If there is no Irp or this is the Usn journal then allocate the space anyway.
        //

        if ((ClusterCount + Vcb->TotalReserved > Vcb->FreeClusters) &&
#ifdef BRIANDBG
            !NtfsIgnoreReserved &&
#endif
            (IrpContext->OriginatingIrp != NULL) &&
            !FlagOn( Scb->Fcb->FcbState, FCB_STATE_USN_JOURNAL )) {

            //
            //  If this is not a write then fail this unless this is an fsctl which
            //  may have reserved space.
            //

            if (IrpContext->MajorFunction != IRP_MJ_WRITE) {

                //
                //  If this is an Fsctl for a data file then account for the reservation.
                //  All other non-writes will fail because we already checked whether
                //  they conflicted with the volume reservation.
                //

                if ((IrpContext->MajorFunction != IRP_MJ_FILE_SYSTEM_CONTROL) ||
                    (Scb->Header.NodeTypeCode != NTFS_NTC_SCB_DATA) ||
                    (ClusterCount + Vcb->TotalReserved - LlClustersFromBytesTruncate( Vcb, Scb->ScbType.Data.TotalReserved ) > Vcb->FreeClusters)) {

                    NtfsReleaseReservedClusters( Vcb );
                    NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                }

            //
            //  If we are in user write path then check the reservation.  Otherwise
            //  satisfy the request.  It will be some other stream which supports the
            //  write (i.e. Mft record for a secondary file record).
            //

            } else if ((Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA) &&
                       !FlagOn( IrpContext->OriginatingIrp->Flags, IRP_PAGING_IO ) &&
                       (ClusterCount + Vcb->TotalReserved - LlClustersFromBytesTruncate( Vcb, Scb->ScbType.Data.TotalReserved ) > Vcb->FreeClusters)) {

                NtfsReleaseReservedClusters( Vcb );
                NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
            }
        }

        NtfsReleaseReservedClusters( Vcb );

        //
        //  We need to check that the request won't fail because of clusters
        //  in the recently deallocated lists.
        //

        if (Vcb->FreeClusters < (Vcb->DeallocatedClusters + ClusterCount)) {

            NtfsRaiseStatus( IrpContext, STATUS_LOG_FILE_FULL, NULL, NULL );
        }

        //
        //  Remember if we are extending the Mft.
        //

        if ((Scb == Vcb->MftScb) &&
            (LlBytesFromClusters( Vcb, StartingVcn ) == (ULONGLONG) Scb->Header.AllocationSize.QuadPart)) {

            ExtendingMft = TRUE;
        }

        //
        //  Now compute the desired ending vcn and the real desired cluster count
        //

        DesiredEndingVcn = (StartingVcn + *DesiredClusterCount) - 1;
        RemainingDesiredClusterCount = NtfsScanMcbForRealClusterCount( IrpContext, Mcb, StartingVcn, DesiredEndingVcn );

        //
        //  While there are holes to fill we will do the following loop
        //

        while ((AllocateAll || (LoopCount < MAXIMUM_RUNS_AT_ONCE))

                &&

               (GotAHoleToFill = NtfsGetNextHoleToFill( IrpContext,
                                                        Mcb,
                                                        StartingVcn,
                                                        DesiredEndingVcn,
                                                        &VcnToFill,
                                                        &ClusterCountToFill,
                                                        &PrecedingLcn))) {

            //
            //  Assume we will find this in the cached runs array.
            //

            FromCachedRuns = TRUE;

            //
            //  If this is our first time through the loop then record out bitmap stats
            //  then always bump up the run count stat.
            //

            if (!ClustersAllocated) {

                CollectAllocateClusterStats( Vcb,
                                             RemainingDesiredClusterCount,
                                             PrecedingLcn != UNUSED_LCN );
            }

            IncrementAllocateClusterStats( Vcb );

            //
            //  First indicate that we haven't found anything suitable yet
            //

            FoundClustersToAllocate = FALSE;

            //
            //  Remember that we are will be allocating clusters.
            //

            ClustersAllocated = TRUE;

            //
            //  Initialize HintLcn to a value that sorts lower than any other
            //  Lcn.  If we have no PrecedingLcn to use as a hint, the
            //  allocation will preferentially use an Lcn that is as small
            //  as possible for the desired cluster count.  This will left
            //  pack things as much as possible.
            //

            HintLcn = UNUSED_LCN;

            //
            //  Check if the preceding lcn is anything other than -1 then with
            //  that as a hint check if we have a cache hit on a free run
            //

            if (PrecedingLcn != UNUSED_LCN) {

                if (NtfsLookupCachedLcn( &Vcb->CachedRuns,
                                         PrecedingLcn + 1,
                                         &FoundLcn,
                                         &FoundClusterCount,
                                         NULL )) {

                    //
                    //  Increment the stats and say we've found something to allocate
                    //

                    IncrementHintHonoredStats( Vcb, MIN3(FoundClusterCount, RemainingDesiredClusterCount, ClusterCountToFill));

#ifdef NTFS_FRAGMENT_DISK
                    if (NtfsFragmentMft &&
                        (Scb == Vcb->MftScb) &&
                        (FoundClusterCount > 1)) {

                        FoundLcn += 1;
                        FoundClusterCount -= 1;
                    }
#endif

                    if ((Scb->AttributeTypeCode == $INDEX_ALLOCATION) &&
                        (FoundClusterCount * Vcb->BytesPerCluster < Scb->ScbType.Index.BytesPerIndexBuffer)) {
                    } else {
                        FoundClustersToAllocate = TRUE;
                    }
                }

                if (!FoundClustersToAllocate && !ExtendingMft ) {

                    //
                    //  Set up the hint LCN for the lookup by length
                    //  call below.
                    //

                    HintLcn = PrecedingLcn + 1;
                }
            }

            //
            //  If we are still looking to allocate something then hit the cache.
            //  Skip this for the Mft zone as we are willing to go to disk for it.
            //

            while (!FoundClustersToAllocate &&
                   !ExtendingMft &&
                    NtfsLookupCachedLcnByLength( &Vcb->CachedRuns,
                                                 RemainingDesiredClusterCount,
                                                 (BOOLEAN)(Scb->AttributeTypeCode != $INDEX_ALLOCATION),
                                                 HintLcn,
                                                 &FoundLcn,
                                                 &FoundClusterCount,
                                                 &RunIndex )) {

                if ((FoundLcn < Vcb->MftZoneEnd) &&
                    ((FoundLcn + FoundClusterCount) > Vcb->MftZoneStart)) {

                    //
                    //  This run overlaps the Mft zone.  Remove the zone from
                    //  the cache.
                    //

                    NtfsRemoveCachedLcn( &Vcb->CachedRuns,
                                         Vcb->MftZoneStart,
                                         Vcb->MftZoneEnd - Vcb->MftZoneStart );
                    //
                    //  Retry the lookup.
                    //

                    continue;
                }

                //
                //  This run will do.
                //

                FoundClustersToAllocate = TRUE;
            }

            //
            //  this code tries to prevent the paging file allocations
            //  from becoming fragmented.
            //
            //  if the clusters we just found are smaller than half
            //  the of the remaining cluster to allocate then we force
            //  a look at the bitmap.
            //

            if (FlagOn( Scb->Fcb->FcbState, FCB_STATE_PAGING_FILE ) &&
                FoundClustersToAllocate &&
                FoundClusterCount < (RemainingDesiredClusterCount >> 1)) {

                if (LargestBitmapClusterCount > 0) {
                    if (LargestBitmapClusterCount >= RemainingDesiredClusterCount) {
                        FoundClustersToAllocate = FALSE;
                    }
                } else {
                    FoundClustersToAllocate = FALSE;
                }
            }

            //
            //  Check if we've allocated from our cache and increment the stats
            //

            if (FoundClustersToAllocate) {

                IncrementCacheHitStats( Vcb,
                                        MIN3( FoundClusterCount,
                                              RemainingDesiredClusterCount,
                                              ClusterCountToFill ));

            //
            //  We've done everything we can with the cached bitmap information so
            //  now bite the bullet and scan the bitmap for a free cluster.  If
            //  we have an hint lcn then use it otherwise use the hint stored in the
            //  vcb.  But never use a hint that is part of the mft zone, and because
            //  the mft always has a preceding lcn we know we'll hint in the zone
            //  for the mft.
            //

            } else {

                BOOLEAN AllocatedFromZone;
                BOOLEAN ReturnAnyLength;

                //
                //  The clusters aren't coming from the cached runs array.
                //

                FromCachedRuns = FALSE;

                //
                //  First check if we have already satisfied the core requirements
                //  and are now just going for the desired ending vcn.  If so then
                //  we will not waste time hitting the disk
                //

                if (StartingVcn > EndingVcn) {

                    //
                    //  Set the loop count to MAXIMUM_RUNS_AT_ONCE to indicate we bailed early
                    //  without finding all of the requested clusters.
                    //

                    LoopCount = MAXIMUM_RUNS_AT_ONCE;
                    break;
                }

                if (PrecedingLcn != UNUSED_LCN) {

                    HintLcn = PrecedingLcn + 1;
                    ReturnAnyLength = TRUE;

                } else {

                    //
                    //  We shouldn't be here if we are extending the Mft.
                    //

                    ASSERT( !ExtendingMft );

                    HintLcn = Vcb->LastBitmapHint;
                    ReturnAnyLength = FALSE;

                    if ((HintLcn >= Vcb->MftZoneStart) &&
                        (HintLcn < Vcb->MftZoneEnd)) {

                        HintLcn = Vcb->MftZoneEnd;
                    }
                }

                AllocatedFromZone = NtfsFindFreeBitmapRun( IrpContext,
                                                           Vcb,
                                                           ClusterCountToFill,
                                                           HintLcn,
                                                           ReturnAnyLength,
                                                           ExtendingMft,
                                                           &FoundLcn,
                                                           &FoundClusterCount );

                if (LargestBitmapClusterCount == 0) {

                    //
                    //  remember the first cluster count that we get from
                    //  the bitmap as this will be the largest.  this is used
                    //  to optimize the pagefile case.
                    //

                    LargestBitmapClusterCount = FoundClusterCount;
                }

                AllocateFromBitmap = TRUE;

                IncrementCacheMissStats(Vcb, MIN3(FoundClusterCount, RemainingDesiredClusterCount, ClusterCountToFill));

                if (FoundClusterCount == 0) {

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                }

                //
                //  Check if we need to reduce the zone.
                //

                if (!ExtendingMft) {

                    if (AllocatedFromZone) {

                        //
                        //  If there is space to reduce the zone then do so now
                        //  and rescan the bitmap.
                        //

                        if (NtfsReduceMftZone( IrpContext, Vcb )) {

                            FoundClusterCount = 0;

                            NtfsFindFreeBitmapRun( IrpContext,
                                                   Vcb,
                                                   ClusterCountToFill,
                                                   Vcb->MftZoneEnd,
                                                   FALSE,
                                                   FALSE,
                                                   &FoundLcn,
                                                   &FoundClusterCount );

                            if (FoundClusterCount == 0) {

                                NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                            }
                        }
                    }

                //
                //  We are extending the Mft.  If we didn't get a contiguous run then
                //  set up a new zone.
                //

                } else if (PrecedingLcn + 1 != FoundLcn) {

                    NtfsScanEntireBitmap( IrpContext, Vcb, TRUE );

                    ASSERT( Vcb->CachedRuns.Used != 0 );

                    FoundLcn = NtfsInitializeMftZone( IrpContext, Vcb );

                    NtfsFindFreeBitmapRun( IrpContext,
                                           Vcb,
                                           ClusterCountToFill,
                                           FoundLcn,
                                           TRUE,
                                           TRUE,
                                           &FoundLcn,
                                           &FoundClusterCount );
                }
            }

            //
            //  At this point we have found a run to allocate denoted by the
            //  values in FoundLcn and FoundClusterCount.  We need to trim back
            //  the cluster count to be the amount we really need and then
            //  do the allocation.  To do the allocation we zap the bitmap,
            //  decrement the free count, and add the run to the mcb we're
            //  using
            //

#ifdef NTFS_FRAGMENT_DISK
            if (NtfsFragmentDisk && ((ULONG) FoundClusterCount > NtfsFragmentLength)) {

                FoundLcn += 1;
                FoundClusterCount = NtfsFragmentLength;

            } else if (NtfsFragmentMft &&
                       (Scb == Vcb->MftScb) &&
                       (FoundClusterCount > NtfsFragmentLength)) {

                FoundLcn += 1;
                FoundClusterCount = NtfsFragmentLength;
            }
#endif

            if (FoundClusterCount > RemainingDesiredClusterCount) {

                FoundClusterCount = RemainingDesiredClusterCount;
            }

            if (FoundClusterCount > ClusterCountToFill) {

                FoundClusterCount = ClusterCountToFill;
            }

            ASSERT( Vcb->FreeClusters >= FoundClusterCount );

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MODIFIED_BITMAP );

Defragment:

            NtfsAllocateBitmapRun( IrpContext, Vcb, FoundLcn, FoundClusterCount, FromCachedRuns );

            //
            //  Modify the total allocated for this file.
            //

            NtfsAcquireReservedClusters( Vcb );
            Scb->TotalAllocated += (LlBytesFromClusters( Vcb, FoundClusterCount ));
            NtfsReleaseReservedClusters( Vcb );

            //
            //  Adjust the count of free clusters.  Only store the change in
            //  the top level irp context in case of aborts.
            //

            Vcb->FreeClusters -= FoundClusterCount;

            IrpContext->FreeClusterChange -= FoundClusterCount;

            ASSERT_LCN_RANGE_CHECKING( Vcb, (FoundLcn + FoundClusterCount) );

            ASSERT( FoundClusterCount != 0 );

            NtfsAddNtfsMcbEntry( Mcb, VcnToFill, FoundLcn, FoundClusterCount, FALSE );

            //
            //  If this is the Mft file then put these into our AddedClusters Mcb
            //  as well.
            //

            if (Mcb == &Vcb->MftScb->Mcb) {

                FsRtlAddLargeMcbEntry( &Vcb->MftScb->ScbType.Mft.AddedClusters,
                                       VcnToFill,
                                       FoundLcn,
                                       FoundClusterCount );
            }

            //
            //  And update the last bitmap hint, but only if we used the hint to begin with
            //

            if (PrecedingLcn == UNUSED_LCN) {

                Vcb->LastBitmapHint = FoundLcn;
            }

            //
            //  Now move the starting Vcn to the Vcn that we've just filled plus the
            //  found cluster count
            //

            StartingVcn = VcnToFill + FoundClusterCount;

            //
            //  Decrement the remaining desired cluster count by the amount we just allocated
            //

            RemainingDesiredClusterCount = RemainingDesiredClusterCount - FoundClusterCount;

            LoopCount += 1;

            RunCount += 1;

            if (FoundRun == TRUE) {

                break;
            }
        }

        //
        //  Now we need to compute the total cluster that we've just allocated
        //  We'll call get next hole to fill.  If the result is false then we
        //  allocated everything.  If the result is true then we do some quick
        //  math to get the size allocated
        //

        if (GotAHoleToFill && NtfsGetNextHoleToFill( IrpContext,
                                                     Mcb,
                                                     OriginalStartingVcn,
                                                     DesiredEndingVcn,
                                                     &VcnToFill,
                                                     &ClusterCountToFill,
                                                     &PrecedingLcn)) {

            //
            //  If this is a sparse file and we didn't get all that we asked for
            //  then trim the allocation back to a compression boundary.
            //

            if ((LoopCount >= MAXIMUM_RUNS_AT_ONCE) &&
                !AllocateAll &&
                (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ) == ATTRIBUTE_FLAG_SPARSE )) {

                ULONG ClustersPerCompressionMask;

                ClustersPerCompressionMask = (1 << Scb->CompressionUnitShift) - 1;

                //
                //  We should end on a compression unit boundary.
                //

                if ((ULONG) VcnToFill & ClustersPerCompressionMask) {

                    //
                    //  Back up to a compression unit boundary.
                    //

                    StartingVcn = VcnToFill & ~((LONGLONG) ClustersPerCompressionMask);

                    ASSERT( StartingVcn > OriginalStartingVcn );

                    NtfsDeallocateClusters( IrpContext,
                                            Vcb,
                                            Scb,
                                            StartingVcn,
                                            VcnToFill - 1,
                                            &Scb->TotalAllocated );

                    //
                    //  We don't want these clusters to be reflected in the clusters
                    //  deallocated for this transaction.  Otherwise our caller may
                    //  assume he can get them with a log file full.
                    //

                    IrpContext->DeallocatedClusters -= (VcnToFill - StartingVcn);
                    VcnToFill = StartingVcn;
                }
            }

            *DesiredClusterCount = VcnToFill - OriginalStartingVcn;
        }

        //
        //  At this point we've allocated everything we were asked to do
        //  so now call a routine to read ahead into our cache the disk
        //  information at the last lcn we allocated.  But only do the readahead
        //  if we allocated clusters and we couldn't satisfy the request in one
        //  run.
        //

        if (ClustersAllocated &&
            ((RunCount > 1) || AllocateFromBitmap) &&
            (FoundLcn + FoundClusterCount < Vcb->TotalClusters)) {

            NtfsReadAheadCachedBitmap( IrpContext, Vcb, FoundLcn + FoundClusterCount );
        }

    } finally {

        DebugUnwind( NtfsAllocateClusters );

        DebugTrace( 0, Dbg, ("%d\n", NtfsDumpCachedMcbInformation(Vcb)) );

        NtfsReleaseScb(IrpContext, Vcb->BitmapScb);
    }

    DebugTrace( -1, Dbg, ("NtfsAllocateClusters -> %08lx\n", ClustersAllocated) );

    return ClustersAllocated;
}


VOID
NtfsAddBadCluster (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN Lcn
    )

/*++

Routine Description:

    This routine helps append a bad cluster to the bad cluster file.
    It marks it as allocated in the volume bitmap and also adds
    the Lcn to the MCB for the bad cluster file.

Arguments:

    Vcb - Supplies the Vcb used in this operation

    Lcn - Supplies the Lcn of the new bad cluster

Return:

    None.

--*/

{
    PNTFS_MCB Mcb;
    LONGLONG FoundLcn;
    LONGLONG FoundClusters;
    PDEALLOCATED_CLUSTERS Clusters;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddBadCluster\n") );
    DebugTrace( 0, Dbg, ("Lcn = %0I64x\n", Lcn) );

    //
    //  Reference the bad cluster mcb and grab exclusive access to the
    //  bitmap scb
    //

    Mcb = &Vcb->BadClusterFileScb->Mcb;

    NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );

    try {

        //
        //  We are given the bad Lcn so all we need to do is
        //  allocate it in the bitmap, and take care of some
        //  bookkeeping
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MODIFIED_BITMAP );

        NtfsAllocateBitmapRun( IrpContext, Vcb, Lcn, 1, FALSE );

        //
        //  Go ahead and remove this cluster from the recently deallocated arrays.
        //  We don't want to give this back to the bitmap package.
        //
        //  Best odds are that these are in the active deallocated clusters.
        //

        Clusters = (PDEALLOCATED_CLUSTERS)Vcb->DeallocatedClusterListHead.Flink;
        do {

            if (FsRtlLookupLargeMcbEntry( &Clusters->Mcb,
                                          Lcn,
                                          &FoundLcn,
                                          &FoundClusters,
                                          NULL,
                                          NULL,
                                          NULL ) &&
                (FoundLcn != UNUSED_LCN)) {

                FsRtlRemoveLargeMcbEntry( &Clusters->Mcb,
                                          Lcn,
                                          1 );

                //
                //  Removing one from Dealloc and Vcb.  Operation above
                //  could fail leaving entry in Deallocated cluster.  OK because the
                //  entry is still deallocated this operation will abort.
                //

                Clusters->ClusterCount -= 1;
                Vcb->DeallocatedClusters -= 1;
                break;
            }

            Clusters = (PDEALLOCATED_CLUSTERS)Clusters->Link.Flink;
        } while ( &Clusters->Link != &Vcb->DeallocatedClusterListHead );



        Vcb->FreeClusters -= 1;
        IrpContext->FreeClusterChange -= 1;

        ASSERT_LCN_RANGE_CHECKING( Vcb, (Lcn + 1) );

        //
        //  Vcn == Lcn in the bad cluster file.
        //

        NtfsAddNtfsMcbEntry( Mcb, Lcn, Lcn, (LONGLONG)1, FALSE );

    } finally {

        DebugUnwind( NtfsAddBadCluster );

        NtfsReleaseScb(IrpContext, Vcb->BitmapScb);
    }

    DebugTrace( -1, Dbg, ("NtfsAddBadCluster -> VOID\n") );

    return;
}


BOOLEAN
NtfsDeallocateClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN VCN StartingVcn,
    IN VCN EndingVcn,
    OUT PLONGLONG TotalAllocated OPTIONAL
    )

/*++

Routine Description:

    This routine deallocates (i.e., frees) disk space.  It free any clusters that
    are specified as allocated in the input mcb with the specified range of starting
    vcn to ending vcn inclusive.

    The basic algorithm used by this procedure is as follows:

    1. With a Vcn value beginning at starting vcn and progressing to ending vcn
       do the following steps...

       2. Lookup the Mcb entry at the vcn this will yield an lcn and a cluster count
          if the entry exists (even if it is a hole).  If the entry does not exist
          then we are completely done because we have run off the end of allocation.

       3. If the entry is a hole (i.e., Lcn == -1) then add the cluster count to
          Vcn and go back to step 1.

       4. At this point we have a real run of clusters that need to be deallocated but
          the cluster count might put us over the ending vcn so adjust the cluster
          count to keep us within the ending vcn.

       5. Now deallocate the clusters from the bitmap, and increment the free cluster
          count stored in the vcb.

       6. Add (i.e., change) any cached bitmap information concerning this run to indicate
          that it is now free.

       7. Remove the run from the mcb.

       8. Add the cluster count that we've just freed to Vcn and go back to step 1.

Arguments:

    Vcb - Supplies the vcb used in this operation

    Mcb - Supplies the mcb describing the runs to be deallocated

    StartingVcn - Supplies the vcn to start deallocating at in the input mcb

    EndingVcn - Supplies the vcn to end deallocating at in the input mcb

    TotalAllocated - If specified we will modifify the total allocated clusters
        for this file.

Return Value:

    FALSE - if nothing was deallocated.
    TRUE - if some space was deallocated.

--*/

{
    VCN Vcn;
    LCN Lcn;
    LONGLONG ClusterCount;
    LONGLONG ClustersRemoved = 0;
    BOOLEAN ClustersDeallocated = FALSE;
    LCN LastLcnAdded;
    BOOLEAN RaiseLogFull;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeallocateClusters\n") );
    DebugTrace( 0, Dbg, ("StartingVcn = %016I64x\n", StartingVcn) );
    DebugTrace( 0, Dbg, ("EndingVcn   = %016I64\n", EndingVcn) );

    NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );

    try {

        if (FlagOn( Vcb->VcbState, VCB_STATE_RELOAD_FREE_CLUSTERS )) {

            NtfsScanEntireBitmap( IrpContext, Vcb, FALSE );
        }

        //
        //  The following loop scans through the mcb from starting vcn to ending vcn
        //  with a step of cluster count.
        //

        for (Vcn = StartingVcn; Vcn <= EndingVcn; Vcn = Vcn + ClusterCount) {

            //
            //  Get the run information from the Mcb, and if this Vcn isn't specified
            //  in the mcb then return now to our caller
            //

            if (!NtfsLookupNtfsMcbEntry( &Scb->Mcb, Vcn, &Lcn, &ClusterCount, NULL, NULL, NULL, NULL )) {

                try_return( NOTHING );
            }

            //
            //  Make sure that the run we just looked up is not a hole otherwise
            //  if it is a hole we'll just continue with out loop continue with our
            //  loop
            //

            if (Lcn != UNUSED_LCN) {

                PDEALLOCATED_CLUSTERS CurrentClusters;

                ASSERT_LCN_RANGE_CHECKING( Vcb, (Lcn + ClusterCount) );

                //
                //  Now we have a real run to deallocate, but it might be too large
                //  to check for that the vcn plus cluster count must be less than
                //  or equal to the ending vcn plus 1.
                //

                if ((Vcn + ClusterCount) > EndingVcn) {

                    ClusterCount = (EndingVcn - Vcn) + 1;
                }

                //
                //  And to hold us off from reallocating the clusters right away we'll
                //  add this run to the recently deallocated mcb in the vcb.  If this fails
                //  because we are growing the mapping then change the code to
                //  LOG_FILE_FULL to empty the mcb.
                //

                RaiseLogFull = FALSE;

                try {

                    CurrentClusters = NtfsGetDeallocatedClusters( IrpContext, Vcb );
                    FsRtlAddLargeMcbEntry( &CurrentClusters->Mcb,
                                           Lcn,
                                           Lcn,
                                           ClusterCount );

                } except ((GetExceptionCode() == STATUS_INSUFFICIENT_RESOURCES) ?
                          EXCEPTION_EXECUTE_HANDLER :
                          EXCEPTION_CONTINUE_SEARCH) {

                    RaiseLogFull = TRUE;
                }

                if (RaiseLogFull) {

                    NtfsRaiseStatus( IrpContext, STATUS_LOG_FILE_FULL, NULL, NULL );
                }

                //
                //  Correct here because we increment only if successfully
                //  adding the clusters.  It is also added to dealloc and Vcb together.
                //

                CurrentClusters->ClusterCount += ClusterCount;

                Vcb->DeallocatedClusters += ClusterCount;
                IrpContext->DeallocatedClusters += ClusterCount;

                ClustersRemoved = ClusterCount;
                LastLcnAdded = Lcn + ClusterCount;

                //
                //  Now zap the bitmap, increment the free cluster count, and change
                //  the cached information on this run to indicate that it is now free
                //

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MODIFIED_BITMAP );

                NtfsFreeBitmapRun( IrpContext, Vcb, Lcn, &ClustersRemoved);
                ASSERT( ClustersRemoved == 0 );
                ClustersDeallocated = TRUE;

                //
                //  Reserve newly freed clusters if necc. to maintain balance for
                //  mapped data files
                //

                if (($DATA == Scb->AttributeTypeCode) &&
                    (Scb->CompressionUnit != 0) &&
                    FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE )) {

                    LONGLONG FileOffset;
                    ULONG ByteCount;
                    LONGLONG TempL;

                    TempL= NtfsCalculateNeededReservedSpace( Scb );

                    if (Scb->ScbType.Data.TotalReserved <= TempL) {

                        FileOffset = LlBytesFromClusters( Vcb, Vcn );
                        ByteCount =  BytesFromClusters( Vcb, ClusterCount );

                        //
                        //  If we're deallocating beyond allocation size as a result of DeallocateInternal
                        //  optimization (split and remove at back) compensate.
                        //

                        if (FileOffset >= Scb->Header.AllocationSize.QuadPart ) {
                            FileOffset = Scb->Header.AllocationSize.QuadPart - ByteCount;
                        }

                        //
                        //  Round attempted reservation down to needed amount if its larger
                        //

                        if (ByteCount > TempL - Scb->ScbType.Data.TotalReserved) {
                            ByteCount = (ULONG)(TempL - Scb->ScbType.Data.TotalReserved);
                        }

                        NtfsReserveClusters( IrpContext, Scb, FileOffset, ByteCount );
                    }
                }

                //
                //  Adjust the count of free clusters and adjust the IrpContext
                //  field for the change this transaction.
                //

                Vcb->FreeClusters += ClusterCount;

                //
                //  If we had shrunk the Mft zone and there is at least 1/16
                //  of the volume now available, then grow the zone back.
                //  Acquire MftScb so we can can manipulate its mcb. Use ex routines so we
                //  always drop it at the end in the finally clause. If we can't get it
                //  we'll just skip resizing the zone
                //

                if (FlagOn( Vcb->VcbState, VCB_STATE_REDUCED_MFT ) &&
                    (Int64ShraMod32( Vcb->TotalClusters, 4 ) < Vcb->FreeClusters)) {

                    if (NtfsAcquireResourceExclusive( IrpContext, Vcb->MftScb, FALSE )) {

                        try {
                            NtfsScanEntireBitmap( IrpContext, Vcb, TRUE );
                            NtfsInitializeMftZone( IrpContext, Vcb );
                        } finally {
                            NtfsReleaseResource( IrpContext, Vcb->MftScb );
                        }
                    }
                }

                IrpContext->FreeClusterChange += ClusterCount;

                //
                //  Modify the total allocated amount if the pointer is specified.
                //

                if (ARGUMENT_PRESENT( TotalAllocated )) {

                    NtfsAcquireReservedClusters( Vcb );
                    *TotalAllocated -= (LlBytesFromClusters( Vcb, ClusterCount ));

                    if (*TotalAllocated < 0) {

                        *TotalAllocated = 0;
                    }
                    NtfsReleaseReservedClusters( Vcb );
                }

                //
                //  Now remove this entry from the mcb and go back to the top of the
                //  loop
                //

                NtfsRemoveNtfsMcbEntry( &Scb->Mcb, Vcn, ClusterCount );

                //
                //  If this is the Mcb for the Mft file then remember this in the
                //  RemovedClusters Mcb.
                //

                if (&Scb->Mcb == &Vcb->MftScb->Mcb) {

                    FsRtlAddLargeMcbEntry( &Vcb->MftScb->ScbType.Mft.RemovedClusters,
                                           Vcn,
                                           Lcn,
                                           ClusterCount );
                }
            }
        }

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsDeallocateClusters );

        DebugTrace( 0, Dbg, ("%d\n", NtfsDumpCachedMcbInformation(Vcb)) );

        //
        //  Remove the entries from the recently deallocated entries
        //  if we didn't modify the bitmap.  ClustersRemoved contains
        //  the number we didn't insert in the last attempt to free bits
        //  in the bitmap.
        //

        if (ClustersRemoved != 0) {

            PDEALLOCATED_CLUSTERS Clusters = (PDEALLOCATED_CLUSTERS) Vcb->DeallocatedClusterListHead.Flink;

            FsRtlRemoveLargeMcbEntry( &Clusters->Mcb,
                                      LastLcnAdded - ClustersRemoved,
                                      ClustersRemoved );

            //
            //  This should be OK. We are backing out an insert above.
            //  Whatever space needed should be present because we are reverting to
            //  a known state.
            //

            Clusters->ClusterCount -= ClustersRemoved;
            Vcb->DeallocatedClusters -= ClustersRemoved;
        }

        NtfsReleaseScb( IrpContext, Vcb->BitmapScb );
    }

    DebugTrace( -1, Dbg, ("NtfsDeallocateClusters -> %02lx\n", ClustersDeallocated) );

    return ClustersDeallocated;
}


VOID
NtfsPreAllocateClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN LONGLONG ClusterCount,
    OUT PBOOLEAN AcquiredBitmap,
    OUT PBOOLEAN AcquiredMft
    )

/*++

Routine Description:

    This routine pre-allocates clusters in the bitmap within the specified range.
    All changes are made only in memory and neither logged nor written to disk.
    We allow  exceptions to flow out possibly with all the files acquired. At the end we hold
    the bitmap and mft exclusive to mark the reservation if we succeed

Arguments:

    Vcb - Supplies the vcb used in this operation

    StartingLcn - Supplies the starting Lcn index within the bitmap to
        start allocating (i.e., setting to 1).

    ClusterCount - Supplies the number of bits to set to 1 within the bitmap.

    AcquiredBitmap - set to true if we leave with bitmap acquired

    AcquiredMft - set to true if we leave with the mft acquired


Return Value:

    None.

--*/

{
    PAGED_CODE()

    NtfsAcquireExclusiveScb( IrpContext, Vcb->MftScb );
    *AcquiredMft = TRUE;

    NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );
    *AcquiredBitmap = TRUE;

    NtfsRunIsClear( IrpContext, Vcb, StartingLcn, ClusterCount );
}


VOID
NtfsScanEntireBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LOGICAL CachedRunsOnly
    )

/*++

Routine Description:

    This routine scans in the entire bitmap,  It computes the number of free clusters
    available, and at the same time remembers the largest free runs that it
    then inserts into the cached bitmap structure.

Arguments:

    Vcb - Supplies the vcb used by this operation

    CachedRunsOnly - Indicates that we only want to look for the longest runs.

Return Value:

    None.

--*/

{
    LCN Lcn;

    RTL_BITMAP Bitmap;
    PBCB BitmapBcb;

    BOOLEAN StuffAdded = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsScanEntireBitmap\n") );

    BitmapBcb = NULL;

    try {

        //
        //  If we are only reloading cached runs then check if there is any real work to do.
        //  We don't want to constantly rescan the bitmap if we are growing the Mft and never
        //  have any suitable runs available.
        //

        if (CachedRunsOnly) {

            USHORT RunIndex;
            BOOLEAN FoundRun;

            //
            //  If there hasn't been a lot of activity freeing clusters then
            //  don't do this work unless the cached run structure is empty.
            //

            if (Vcb->ClustersRecentlyFreed < BITMAP_VOLATILE_FREE_COUNT) {

                //
                //  Determine if there is a cached run that is at least as
                //  large as LongestFreedRun.
                //

                FoundRun = NtfsPositionCachedLcnByLength( &Vcb->CachedRuns,
                                                          Vcb->CachedRuns.LongestFreedRun,
                                                          NULL,
                                                          NULL,
                                                          TRUE,
                                                          &RunIndex );

                if (!FoundRun &&
                    (RunIndex < Vcb->CachedRuns.Used) &&
                    (Vcb->CachedRuns.LengthArray[ RunIndex ] != NTFS_CACHED_RUNS_DEL_INDEX) ) {

                    //
                    //  RunIndex points to a larger entry.
                    //

                    FoundRun = TRUE;

                    ASSERT( FoundRun ||
                            (RunIndex >= Vcb->CachedRuns.Used) ||
                            (Vcb->CachedRuns.LengthArray[ RunIndex ] == NTFS_CACHED_RUNS_DEL_INDEX) );
                }

                if (FoundRun) {

                    //
                    //  Use the entries we already have.
                    //

                    leave;
                }
            }

        //
        //  Set the current total free space to zero and the following loop will compute
        //  the actual number of free clusters.
        //

        } else {

            Vcb->FreeClusters = 0;
        }

        NtfsReinitializeCachedRuns( &Vcb->CachedRuns );

        //
        //  For every bitmap page we read it in and check how many free clusters there are.
        //  While we have the page in memory we also scan for a large chunks of free space.
        //

        for (Lcn = 0; Lcn < Vcb->TotalClusters; Lcn = Lcn + Bitmap.SizeOfBitMap) {

            LCN StartingLcn;

            RTL_BITMAP_RUN RunArray[64];
            ULONG RunArrayIndex;

            //
            //  Read in the bitmap page and make sure that we haven't messed up the math
            //

            if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE; }

            NtfsUnpinBcb( IrpContext, &BitmapBcb );
            NtfsMapPageInBitmap( IrpContext, Vcb, Lcn, &StartingLcn, &Bitmap, &BitmapBcb );
            ASSERTMSG("Math wrong for bits per page of bitmap", (Lcn == StartingLcn));

            //
            //  Compute the number of clear bits in the bitmap each clear bit denotes
            //  a free cluster.
            //

            if (!CachedRunsOnly) {

                Vcb->FreeClusters += RtlNumberOfClearBits( &Bitmap );
            }

            //
            //  Now bias the bitmap with the RecentlyDeallocatedMcb.
            //

            StuffAdded = NtfsAddRecentlyDeallocated( Vcb, StartingLcn, &Bitmap );

            //
            //  Find the 64 longest free runs in the bitmap and add them to the
            //  cached bitmap.
            //

            RunArrayIndex = RtlFindClearRuns( &Bitmap, RunArray, 64, TRUE );

            if (RunArrayIndex > 0) {

                NtfsAddCachedRunMult( IrpContext,
                                      Vcb,
                                      Lcn,
                                      RunArray,
                                      RunArrayIndex );
            }
        }

        Vcb->ClustersRecentlyFreed = 0;
        Vcb->CachedRuns.LongestFreedRun = 0;

    } finally {

        DebugUnwind( NtfsScanEntireBitmap );

        if (!AbnormalTermination() && !CachedRunsOnly) {

            ClearFlag( Vcb->VcbState, VCB_STATE_RELOAD_FREE_CLUSTERS );
        }

        if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); }

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    DebugTrace( -1, Dbg, ("NtfsScanEntireBitmap -> VOID\n") );

    return;
}


VOID
NtfsModifyBitsInBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LONGLONG FirstBit,
    IN LONGLONG BeyondFinalBit,
    IN ULONG RedoOperation,
    IN ULONG UndoOperation
    )

/*++

Routine Description:

    This routine is called to directly modify a specific range of bits in the volume bitmap.
    It should only be called by someone who is directly manipulating the volume bitmap
    (i.e. ExtendVolume).

Arguments:

    Vcb - This is the volume being modified.

    FirstBit - First bit in the bitmap to set.

    BeyondFinalBit - Indicates where to stop modifying.

    RedoOperation - Indicates whether we are setting or clearing the bits.

    UndoOperation - Indicates whether we need to back out the Redo operation above.

Return Value:

    None.

--*/

{
    RTL_BITMAP Bitmap;
    PBCB BitmapBcb = NULL;

    LONGLONG CurrentLcn;
    LONGLONG BaseLcn;
    BITMAP_RANGE BitmapRange;

    PVOID UndoBuffer = NULL;
    ULONG UndoBufferLength = 0;

    PAGED_CODE();

    //
    //  Use a try-finally to facilate cleanup.
    //

    try {

        //
        //  Loop and perform the necessary operations on each affected page
        //  in the bitmap.
        //

        for (CurrentLcn = FirstBit; CurrentLcn < BeyondFinalBit; CurrentLcn = BaseLcn + Bitmap.SizeOfBitMap) {

            //
            //  Read in the page of the bitmap.
            //

            NtfsUnpinBcb( IrpContext, &BitmapBcb );
            NtfsPinPageInBitmap( IrpContext, Vcb, CurrentLcn, &BaseLcn, &Bitmap, &BitmapBcb );

            //
            //  Determine how many bits to clear on the current page.
            //

            BitmapRange.BitMapOffset = (ULONG) (CurrentLcn - BaseLcn);
            BitmapRange.NumberOfBits = BITS_PER_PAGE - BitmapRange.BitMapOffset;

            if (BitmapRange.NumberOfBits > (ULONG) (BeyondFinalBit - CurrentLcn)) {

                BitmapRange.NumberOfBits = (ULONG) (BeyondFinalBit - CurrentLcn);
            }

            //
            //  Write the log record to clear or set the bits.
            //

            if (UndoOperation != Noop) {

                ASSERT( (UndoOperation == SetBitsInNonresidentBitMap) ||
                        (UndoOperation == ClearBitsInNonresidentBitMap) );

                UndoBuffer = &BitmapRange;
                UndoBufferLength = sizeof( BITMAP_RANGE );
            }

            (VOID)
            NtfsWriteLog( IrpContext,
                          Vcb->BitmapScb,
                          BitmapBcb,
                          RedoOperation,
                          &BitmapRange,
                          sizeof( BITMAP_RANGE ),
                          UndoOperation,
                          UndoBuffer,
                          UndoBufferLength,
                          Int64ShraMod32( BaseLcn, 3 ),
                          0,
                          0,
                          Bitmap.SizeOfBitMap >> 3 );

            //
            //  Call the appropriate routine to modify the bits.
            //

            if (RedoOperation == SetBitsInNonresidentBitMap) {

                NtfsRestartSetBitsInBitMap( IrpContext,
                                            &Bitmap,
                                            BitmapRange.BitMapOffset,
                                            BitmapRange.NumberOfBits );

            } else {

                NtfsRestartClearBitsInBitMap( IrpContext,
                                              &Bitmap,
                                              BitmapRange.BitMapOffset,
                                              BitmapRange.NumberOfBits );
            }
        }

    } finally {

        DebugUnwind( NtfsModifyBitsInBitmap );

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    return;
}


BOOLEAN
NtfsCreateMftHole (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to create a hole within the Mft.

Arguments:

    Vcb - Vcb for volume.

Return Value:

    None.

--*/

{
    BOOLEAN FoundHole = FALSE;
    PBCB BitmapBcb = NULL;
    BOOLEAN StuffAdded = FALSE;
    RTL_BITMAP Bitmap;
    PUCHAR BitmapBuffer;
    ULONG SizeToMap;

    ULONG BitmapOffset;
    ULONG BitmapSize;
    ULONG BitmapIndex;

    ULONG StartIndex;
    ULONG HoleCount;

    ULONG MftVcn;
    ULONG MftClusterCount;

    PAGED_CODE();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Compute the number of records in the Mft file and the full range to
        //  pin in the Mft bitmap.
        //

        BitmapIndex = (ULONG) LlFileRecordsFromBytes( Vcb, Vcb->MftScb->Header.FileSize.QuadPart );

        //
        //  Knock this index down to a hole boundary.
        //

        BitmapIndex &= Vcb->MftHoleInverseMask;

        //
        //  Compute the values for the bitmap.
        //

        BitmapSize = (BitmapIndex + 7) / 8;

        //
        //  Convert the index to the number of bits on this page.
        //

        BitmapIndex &= (BITS_PER_PAGE - 1);

        if (BitmapIndex == 0) {

            BitmapIndex = BITS_PER_PAGE;
        }

        //
        //  Set the Vcn count to the full size of the bitmap.
        //

        BitmapOffset = (ULONG) ROUND_TO_PAGES( BitmapSize );

        //
        //  Loop through all of the pages of the Mft bitmap looking for an appropriate
        //  hole.
        //

        while (BitmapOffset != 0) {

            //
            //  Move to the beginning of this page.
            //

            BitmapOffset -= BITS_PER_PAGE;

            if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE; }

            //
            //  Compute the number of bytes to map in the current page.
            //

            SizeToMap = BitmapSize - BitmapOffset;

            if (SizeToMap > PAGE_SIZE) {

                SizeToMap = PAGE_SIZE;
            }

            //
            //  Unmap any pages from a previous page and map the current page.
            //

            NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Initialize the bitmap for this page.
            //

            NtfsMapStream( IrpContext,
                           Vcb->MftBitmapScb,
                           BitmapOffset,
                           SizeToMap,
                           &BitmapBcb,
                           &BitmapBuffer );

            RtlInitializeBitMap( &Bitmap, (PULONG) BitmapBuffer, SizeToMap * 8 );

            StuffAdded = NtfsAddDeallocatedRecords( Vcb,
                                                    Vcb->MftScb,
                                                    BitmapOffset * 8,
                                                    &Bitmap );

            //
            //  Walk through the current page looking for a hole.  Continue
            //  until we find a hole or have reached the beginning of the page.
            //

            do {

                //
                //  Go back one Mft index and look for a clear run.
                //

                BitmapIndex -= 1;

                HoleCount = RtlFindLastBackwardRunClear( &Bitmap,
                                                         BitmapIndex,
                                                         &BitmapIndex );

                //
                //  If we couldn't find any run then break out of the loop.
                //

                if (HoleCount == 0) {

                    break;

                //
                //  If this is too small to make a hole then continue on.
                //

                } else if (HoleCount < Vcb->MftHoleGranularity) {

                    BitmapIndex &= Vcb->MftHoleInverseMask;
                    continue;
                }

                //
                //  Round up the starting index for this clear run and
                //  adjust the hole count.
                //

                StartIndex = (BitmapIndex + Vcb->MftHoleMask) & Vcb->MftHoleInverseMask;
                HoleCount -= (StartIndex - BitmapIndex);

                //
                //  Round the hole count down to a hole boundary.
                //

                HoleCount &= Vcb->MftHoleInverseMask;

                //
                //  If we couldn't find enough records for a hole then
                //  go to a previous index.
                //

                if (HoleCount < Vcb->MftHoleGranularity) {

                    BitmapIndex &= Vcb->MftHoleInverseMask;
                    continue;
                }

                //
                //  Convert the hole count to a cluster count.
                //

                if (Vcb->FileRecordsPerCluster == 0) {

                    HoleCount <<= Vcb->MftToClusterShift;

                } else {

                    HoleCount = 1;
                }

                //
                //  Loop by finding the run at the given Vcn and walk through
                //  subsequent runs looking for a hole.
                //

                do {

                    PVOID RangePtr;
                    ULONG McbIndex;
                    VCN ThisVcn;
                    LCN ThisLcn;
                    LONGLONG ThisClusterCount;

                    //
                    //  Find the starting Vcn for this hole and initialize
                    //  the cluster count for the current hole.
                    //

                    ThisVcn = StartIndex + (BitmapOffset * 3);

                    if (Vcb->FileRecordsPerCluster == 0) {

                        ThisVcn <<= Vcb->MftToClusterShift;

                    } else {

                        ThisVcn >>= Vcb->MftToClusterShift;
                    }

                    MftVcn = (ULONG) ThisVcn;
                    MftClusterCount = 0;

                    //
                    //  Lookup the run at the current Vcn.
                    //

                    NtfsLookupNtfsMcbEntry( &Vcb->MftScb->Mcb,
                                            ThisVcn,
                                            &ThisLcn,
                                            &ThisClusterCount,
                                            NULL,
                                            NULL,
                                            &RangePtr,
                                            &McbIndex );

                    //
                    //  Now walk through this bitmap run and look for a run we
                    //  can deallocate to create a hole.
                    //

                    do {

                        //
                        //  Go to the next run in the Mcb.
                        //

                        McbIndex += 1;

                        //
                        //  If this run extends beyond the end of the of the
                        //  hole then truncate the clusters in this run.
                        //

                        if (ThisClusterCount > HoleCount) {

                            ThisClusterCount = HoleCount;
                            HoleCount = 0;

                        } else {

                            HoleCount -= (ULONG) ThisClusterCount;
                        }

                        //
                        //  Check if this run is a hole then clear the count
                        //  of clusters.
                        //

                        if (ThisLcn == UNUSED_LCN) {

                            //
                            //  We want to skip this hole.  If we have found a
                            //  hole then we are done.  Otherwise we want to
                            //  find the next range in the Mft starting at the point beyond
                            //  the current run (which is a hole).  Nothing to do if we don't
                            //  have enough clusters for a full hole.
                            //

                            if (!FoundHole &&
                                (HoleCount >= Vcb->MftClustersPerHole)) {

                                //
                                //  Find the Vcn after the current Mft run.
                                //

                                ThisVcn += ThisClusterCount;

                                //
                                //  If this isn't on a hole boundary then
                                //  round up to a hole boundary.  Adjust the
                                //  available clusters for a hole.
                                //

                                MftVcn = (ULONG) (ThisVcn + Vcb->MftHoleClusterMask);
                                MftVcn = (ULONG) ThisVcn & Vcb->MftHoleClusterInverseMask;

                                //
                                //  Now subtract this from the HoleClusterCount.
                                //

                                HoleCount -= MftVcn - (ULONG) ThisVcn;

                                //
                                //  We need to convert the Vcn at this point to an Mft record
                                //  number.
                                //

                                if (Vcb->FileRecordsPerCluster == 0) {

                                    StartIndex = MftVcn >> Vcb->MftToClusterShift;

                                } else {

                                    StartIndex = MftVcn << Vcb->MftToClusterShift;
                                }
                            }

                            break;

                        //
                        //  We found a run to deallocate.
                        //

                        } else {

                            //
                            //  Add these clusters to the clusters already found.
                            //  Set the flag indicating we found a hole if there
                            //  are enough clusters to create a hole.
                            //

                            MftClusterCount += (ULONG) ThisClusterCount;

                            if (MftClusterCount >= Vcb->MftClustersPerHole) {

                                FoundHole = TRUE;
                            }
                        }

                    } while ((HoleCount != 0) &&
                             NtfsGetSequentialMcbEntry( &Vcb->MftScb->Mcb,
                                                        &RangePtr,
                                                        McbIndex,
                                                        &ThisVcn,
                                                        &ThisLcn,
                                                        &ThisClusterCount ));

                } while (!FoundHole && (HoleCount >= Vcb->MftClustersPerHole));

                //
                //  Round down to a hole boundary for the next search for
                //  a hole candidate.
                //

                BitmapIndex &= Vcb->MftHoleInverseMask;

            } while (!FoundHole && (BitmapIndex >= Vcb->MftHoleGranularity));

            //
            //  If we found a hole then deallocate the clusters and record
            //  the hole count change.
            //

            if (FoundHole) {

                IO_STATUS_BLOCK IoStatus;
                LONGLONG MftFileOffset;

                //
                //  We want to flush the data in the Mft out to disk in
                //  case a lazywrite comes in during a window where we have
                //  removed the allocation but before a possible abort.
                //

                MftFileOffset = LlBytesFromClusters( Vcb, MftVcn );

                //
                //  Round the cluster count and hole count down to a hole boundary.
                //


                MftClusterCount &= Vcb->MftHoleClusterInverseMask;

                if (Vcb->FileRecordsPerCluster == 0) {

                    HoleCount = MftClusterCount >> Vcb->MftToClusterShift;

                } else {

                    HoleCount = MftClusterCount << Vcb->MftToClusterShift;
                }

                CcFlushCache( &Vcb->MftScb->NonpagedScb->SegmentObject,
                              (PLARGE_INTEGER) &MftFileOffset,
                              BytesFromClusters( Vcb, MftClusterCount ),
                              &IoStatus );

                ASSERT( IoStatus.Status == STATUS_SUCCESS );

                //
                //  Remove the clusters from the Mcb for the Mft.
                //

                NtfsDeleteAllocation( IrpContext,
                                      Vcb->MftScb->FileObject,
                                      Vcb->MftScb,
                                      MftVcn,
                                      (LONGLONG) MftVcn + (MftClusterCount - 1),
                                      TRUE,
                                      FALSE );

                //
                //  Record the change to the hole count.
                //

                Vcb->MftHoleRecords += HoleCount;
                Vcb->MftScb->ScbType.Mft.HoleRecordChange += HoleCount;

                //
                //  Exit the loop.
                //

                break;
            }

            //
            //  Look at all of the bits on the previous page.
            //

            BitmapIndex = BITS_PER_PAGE;
        }

    } finally {

        DebugUnwind( NtfsCreateMftHole );

        if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); }
        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    return FoundHole;
}


BOOLEAN
NtfsFindMftFreeTail (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PLONGLONG FileOffset
    )

/*++

Routine Description:

    This routine is called to find the file offset where the run of free records at
    the end of the Mft file begins.  If we can't find a minimal run of file records
    we won't perform truncation.

Arguments:

    Vcb - This is the Vcb for the volume being defragged.

    FileOffset - This is the offset where the truncation may begin.

Return Value:

    BOOLEAN - TRUE if there is an acceptable candidate for truncation at the end of
        the file FALSE otherwise.

--*/

{
    ULONG FinalIndex;
    ULONG BaseIndex;
    ULONG ThisIndex;

    RTL_BITMAP Bitmap;
    PULONG BitmapBuffer;

    BOOLEAN StuffAdded = FALSE;
    BOOLEAN MftTailFound = FALSE;
    PBCB BitmapBcb = NULL;

    PAGED_CODE();

    //
    //  Use a try-finally to facilite cleanup.
    //

    try {

        //
        //  Find the page and range of the last page of the Mft bitmap.
        //

        FinalIndex = (ULONG)Int64ShraMod32(Vcb->MftScb->Header.FileSize.QuadPart, Vcb->MftShift) - 1;

        BaseIndex = FinalIndex & ~(BITS_PER_PAGE - 1);

        Bitmap.SizeOfBitMap = FinalIndex - BaseIndex + 1;

        //
        //  Pin this page.  If the last bit is not clear then return immediately.
        //

        NtfsMapStream( IrpContext,
                       Vcb->MftBitmapScb,
                       (LONGLONG)(BaseIndex / 8),
                       (Bitmap.SizeOfBitMap + 7) / 8,
                       &BitmapBcb,
                       &BitmapBuffer );

        RtlInitializeBitMap( &Bitmap, BitmapBuffer, Bitmap.SizeOfBitMap );

        StuffAdded = NtfsAddDeallocatedRecords( Vcb,
                                                Vcb->MftScb,
                                                BaseIndex,
                                                &Bitmap );

        //
        //  If the last bit isn't clear then there is nothing we can do.
        //

        if (RtlCheckBit( &Bitmap, Bitmap.SizeOfBitMap - 1 ) == 1) {

            try_return( NOTHING );
        }

        //
        //  Find the final free run of the page.
        //

        RtlFindLastBackwardRunClear( &Bitmap, Bitmap.SizeOfBitMap - 1, &ThisIndex );

        //
        //  This Index is a relative value.  Adjust by the page offset.
        //

        ThisIndex += BaseIndex;

        //
        //  Round up the index to a trucate/extend granularity value.
        //

        ThisIndex += Vcb->MftHoleMask;
        ThisIndex &= Vcb->MftHoleInverseMask;

        if (ThisIndex <= FinalIndex) {

            //
            //  Convert this value to a file offset and return it to our caller.
            //

            *FileOffset = LlBytesFromFileRecords( Vcb, ThisIndex );

            MftTailFound = TRUE;
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsFindMftFreeTail );

        if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); }
        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    return MftTailFound;
}


//
//  Local support routine
//

VOID
NtfsAllocateBitmapRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN LONGLONG ClusterCount,
    IN BOOLEAN FromCachedRuns
    )

/*++

Routine Description:

    This routine allocates clusters in the bitmap within the specified range.

Arguments:

    Vcb - Supplies the vcb used in this operation

    StartingLcn - Supplies the starting Lcn index within the bitmap to
        start allocating (i.e., setting to 1).

    ClusterCount - Supplies the number of bits to set to 1 within the
        bitmap.

    FromCachedRuns - Indicates the clusters came from cached information.  Allows
        us to handle the case where the cached runs are corrupt.

Return Value:

    None.

--*/

{
    LCN BaseLcn;

    RTL_BITMAP Bitmap;
    PBCB BitmapBcb;

    ULONG BitOffset;
    ULONG BitsToSet;

    BITMAP_RANGE BitmapRange;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAllocateBitmapRun\n") );
    DebugTrace( 0, Dbg, ("StartingLcn  = %016I64x\n", StartingLcn) );
    DebugTrace( 0, Dbg, ("ClusterCount = %016I64x\n", ClusterCount) );

    BitmapBcb = NULL;

    try {

        //
        //  While the cluster count is greater than zero then we
        //  will loop through reading in a page in the bitmap
        //  setting bits, and then updating cluster count,
        //  and starting lcn
        //

        while (ClusterCount > 0) {

            //
            //  Read in the base containing the starting lcn this will return
            //  a base lcn for the start of the bitmap
            //

            NtfsPinPageInBitmap( IrpContext, Vcb, StartingLcn, &BaseLcn, &Bitmap, &BitmapBcb );

            //
            //  Compute the bit offset within the bitmap of the first bit
            //  we are to set, and also compute the number of bits we need to
            //  set, which is the minimum of the cluster count and the
            //  number of bits left in the bitmap from BitOffset.
            //

            BitOffset = (ULONG)(StartingLcn - BaseLcn);

            if (ClusterCount <= (Bitmap.SizeOfBitMap - BitOffset)) {

                BitsToSet = (ULONG)ClusterCount;

            } else {

                BitsToSet = Bitmap.SizeOfBitMap - BitOffset;
            }

            //
            //  We can only make this check if it is not restart, because we have
            //  no idea whether the update is applied or not.  Raise corrupt if
            //  already set to prevent cross-links.
            //

#ifdef NTFS_CHECK_BITMAP
            if ((Vcb->BitmapCopy != NULL) &&
                !NtfsCheckBitmap( Vcb,
                                  (ULONG) BaseLcn + BitOffset,
                                  BitsToSet,
                                  FALSE )) {

                NtfsBadBitmapCopy( IrpContext, (ULONG) BaseLcn + BitOffset, BitsToSet );
            }
#endif

            //
            //  We hit an unexpected bit set in the bitmap.  The assumption here is that
            //  we got the bit from the cached run information.  If so then simply remove
            //  these clusters from the cached run information.
            //

            if (!RtlAreBitsClear( &Bitmap, BitOffset, BitsToSet )) {

                if (FromCachedRuns) {

                    //
                    //  Clear out the lists.
                    //

#ifdef NTFS_CHECK_CACHED_RUNS
                    ASSERT( FALSE );
#endif
                    NtfsReinitializeCachedRuns( &Vcb->CachedRuns );
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

                ASSERTMSG("Cannot set bits that are not clear ", FALSE );
                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  Now log this change as well.
            //

            BitmapRange.BitMapOffset = BitOffset;
            BitmapRange.NumberOfBits = BitsToSet;

            (VOID)
            NtfsWriteLog( IrpContext,
                          Vcb->BitmapScb,
                          BitmapBcb,
                          SetBitsInNonresidentBitMap,
                          &BitmapRange,
                          sizeof(BITMAP_RANGE),
                          ClearBitsInNonresidentBitMap,
                          &BitmapRange,
                          sizeof(BITMAP_RANGE),
                          Int64ShraMod32( BaseLcn, 3 ),
                          0,
                          0,
                          Bitmap.SizeOfBitMap >> 3 );

            //
            //  Now that we've logged the change go ahead and remove it from the
            //  free run Mcb.  Do it after it appears in a log record so that
            //  it won't be allocated to another file.
            //

            (VOID)NtfsAddCachedRun( IrpContext,
                                    Vcb,
                                    StartingLcn,
                                    BitsToSet,
                                    RunStateAllocated );

            //
            //  Now set the bits by calling the same routine used at restart.
            //

            NtfsRestartSetBitsInBitMap( IrpContext,
                                        &Bitmap,
                                        BitOffset,
                                        BitsToSet );

#ifdef NTFS_CHECK_BITMAP
            if (Vcb->BitmapCopy != NULL) {

                ULONG BitmapPage;
                ULONG StartBit;

                BitmapPage = ((ULONG) (BaseLcn + BitOffset)) / (PAGE_SIZE * 8);
                StartBit = ((ULONG) (BaseLcn + BitOffset)) & ((PAGE_SIZE * 8) - 1);

                RtlSetBits( Vcb->BitmapCopy + BitmapPage, StartBit, BitsToSet );
            }
#endif

            //
            // Unpin the Bcb now before possibly looping back.
            //

            NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Now decrement the cluster count and increment the starting lcn accordling
            //

            ClusterCount -= BitsToSet;
            StartingLcn += BitsToSet;
        }

    } finally {

        DebugUnwind( NtfsAllocateBitmapRun );

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    DebugTrace( -1, Dbg, ("NtfsAllocateBitmapRun -> VOID\n") );

    return;
}


VOID
NtfsRestartSetBitsInBitMap (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_BITMAP Bitmap,
    IN ULONG BitMapOffset,
    IN ULONG NumberOfBits
    )

/*++

Routine Description:

    This routine is common to normal operation and restart, and sets a range of
    bits within a single page (as determined by the system which wrote the log
    record) of the volume bitmap.

Arguments:

    Bitmap - The bit map structure in which to set the bits

    BitMapOffset - Bit offset to set

    NumberOfBits - Number of bits to set

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( IrpContext );

    PAGED_CODE();

    //
    //  Now set the bits and mark the bcb dirty.
    //

    RtlSetBits( Bitmap, BitMapOffset, NumberOfBits );
}


//
//  Local support routine
//

VOID
NtfsFreeBitmapRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN OUT PLONGLONG ClusterCount
    )

/*++

Routine Description:

    This routine frees clusters in the bitmap within the specified range.

Arguments:

    Vcb - Supplies the vcb used in this operation

    StartingLcn - Supplies the starting Lcn index within the bitmap to
        start freeing (i.e., setting to 0).

    ClusterCount - On entry supplies the number of bits to set to 0 within the
        bitmap.  On exit contains the number of bits left to insert.  This is
        used in the error case to correct the recently deallocated bitmap.

Return Value:

    None.

--*/

{
    LCN BaseLcn;

    RTL_BITMAP Bitmap;
    PBCB BitmapBcb;

    ULONG BitOffset;
    ULONG BitsToClear;

    BITMAP_RANGE BitmapRange;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFreeBitmapRun\n") );
    DebugTrace( 0, Dbg, ("StartingLcn  = %016I64\n", StartingLcn) );
    DebugTrace( 0, Dbg, ("ClusterCount = %016I64x\n", *ClusterCount) );

    BitmapBcb = NULL;

    try {

        //
        //  Keep track of how volatile the bitmap package is.
        //

        Vcb->ClustersRecentlyFreed += *ClusterCount;

        if (*ClusterCount > Vcb->CachedRuns.LongestFreedRun) {

            Vcb->CachedRuns.LongestFreedRun = *ClusterCount;
        }

        //
        //  While the cluster count is greater than zero then we
        //  will loop through reading in a page in the bitmap
        //  clearing bits, and then updating cluster count,
        //  and starting lcn
        //

        while (*ClusterCount > 0) {

            //
            //  Read in the base containing the starting lcn this will return
            //  a base lcn for the start of the bitmap
            //

            NtfsPinPageInBitmap( IrpContext, Vcb, StartingLcn, &BaseLcn, &Bitmap, &BitmapBcb );

            //
            //  Compute the bit offset within the bitmap of the first bit
            //  we are to clear, and also compute the number of bits we need to
            //  clear, which is the minimum of the cluster count and the
            //  number of bits left in the bitmap from BitOffset.
            //

            BitOffset = (ULONG)(StartingLcn - BaseLcn);

            if (*ClusterCount <= Bitmap.SizeOfBitMap - BitOffset) {

                BitsToClear = (ULONG)(*ClusterCount);

            } else {

                BitsToClear = Bitmap.SizeOfBitMap - BitOffset;
            }

            //
            //  We can only make this check if it is not restart, because we have
            //  no idea whether the update is applied or not.  Raise corrupt if
            //  these bits aren't set.
            //

#ifdef NTFS_CHECK_BITMAP
            if ((Vcb->BitmapCopy != NULL) &&
                !NtfsCheckBitmap( Vcb,
                                  (ULONG) BaseLcn + BitOffset,
                                  BitsToClear,
                                  TRUE )) {

                NtfsBadBitmapCopy( IrpContext, (ULONG) BaseLcn + BitOffset, BitsToClear );
            }
#endif

            //
            //  Check if the bits are incorrectly clear.
            //

            if (!RtlAreBitsSet( &Bitmap, BitOffset, BitsToClear )) {

                //
                //  Correct thing to do is to ignore the error since the bits are already clear.
                //

                NOTHING;

            //
            //  Don't log if the bits are already correct.  Otherwise we could set them in the
            //  abort path.
            //

            } else {

                //
                //  Now log this change as well.
                //

                BitmapRange.BitMapOffset = BitOffset;
                BitmapRange.NumberOfBits = BitsToClear;

                (VOID)
                NtfsWriteLog( IrpContext,
                              Vcb->BitmapScb,
                              BitmapBcb,
                              ClearBitsInNonresidentBitMap,
                              &BitmapRange,
                              sizeof(BITMAP_RANGE),
                              SetBitsInNonresidentBitMap,
                              &BitmapRange,
                              sizeof(BITMAP_RANGE),
                              Int64ShraMod32( BaseLcn, 3 ),
                              0,
                              0,
                              Bitmap.SizeOfBitMap >> 3 );


                //
                //  Now clear the bits by calling the same routine used at restart.
                //

                NtfsRestartClearBitsInBitMap( IrpContext,
                                              &Bitmap,
                                              BitOffset,
                                              BitsToClear );

#ifdef NTFS_CHECK_BITMAP
                if (Vcb->BitmapCopy != NULL) {

                    ULONG BitmapPage;
                    ULONG StartBit;

                    BitmapPage = ((ULONG) (BaseLcn + BitOffset)) / (PAGE_SIZE * 8);
                    StartBit = ((ULONG) (BaseLcn + BitOffset)) & ((PAGE_SIZE * 8) - 1);

                    RtlClearBits( Vcb->BitmapCopy + BitmapPage, StartBit, BitsToClear );
                }
#endif
            }

            //
            // Unpin the Bcb now before possibly looping back.
            //

            NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Now decrement the cluster count and increment the starting lcn accordling
            //

            *ClusterCount -= BitsToClear;
            StartingLcn += BitsToClear;
        }

    } finally {

        DebugUnwind( NtfsFreeBitmapRun );

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    DebugTrace( -1, Dbg, ("NtfsFreeBitmapRun -> VOID\n") );

    return;
}


VOID
NtfsRestartClearBitsInBitMap (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_BITMAP Bitmap,
    IN ULONG BitMapOffset,
    IN ULONG NumberOfBits
    )

/*++

Routine Description:

    This routine is common to normal operation and restart, and clears a range of
    bits within a single page (as determined by the system which wrote the log
    record) of the volume bitmap.

Arguments:

    Bitmap - Bitmap structure in which to clear the bits

    BitMapOffset - Bit offset to clear

    NumberOfBits - Number of bits to clear

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( IrpContext );

    PAGED_CODE();

    //
    //  Now clear the bits and mark the bcb dirty.
    //

    RtlClearBits( Bitmap, BitMapOffset, NumberOfBits );
}


//
//  Local support routine
//

BOOLEAN
NtfsFindFreeBitmapRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LONGLONG NumberToFind,
    IN LCN StartingSearchHint,
    IN BOOLEAN ReturnAnyLength,
    IN BOOLEAN IgnoreMftZone,
    OUT PLCN ReturnedLcn,
    OUT PLONGLONG ClusterCountFound
    )

/*++

Routine Description:

    This routine searches the bitmap for free clusters based on the
    hint, and number needed.  This routine is actually pretty dumb in
    that it doesn't try for the best fit, we'll assume the caching worked
    and already would have given us a good fit.

Arguments:

    Vcb - Supplies the vcb used in this operation

    NumberToFind - Supplies the number of clusters that we would
        really like to find

    StartingSearchHint - Supplies an Lcn to start the search from

    ReturnAnyLength - If TRUE then we are more interested in finding
        a run which begins with the StartingSearchHint rather than
        one which matches the length of the run.  Case in point is when
        we are trying to append to an existing file (the Mft is a
        critical case).

    ReturnedLcn - Recieves the Lcn of the free run of clusters that
        we were able to find

    IgnoreMftZone - If TRUE then don't adjust the request around the Mft zone.

    ClusterCountFound - Receives the number of clusters in this run

Return Value:

    BOOLEAN - TRUE if clusters allocated from zone.  FALSE otherwise.

--*/

{
    RTL_BITMAP Bitmap;
    PVOID BitmapBuffer;

    PBCB BitmapBcb;

    BOOLEAN AllocatedFromZone = FALSE;

    BOOLEAN StuffAdded;

    ULONG Count;
    ULONG RequestedCount;
    ULONG FoundCount;

    //
    //  As we walk through the bitmap pages we need to remember
    //  exactly where we are in the bitmap stream.  We walk through
    //  the volume bitmap a page at a time but the current bitmap
    //  contained within the current page but may not be the full
    //  page.
    //
    //      Lcn - Lcn used to find the bitmap page to pin.  This Lcn
    //          will lie within the page to pin.
    //
    //      BaseLcn - Bit offset of the start of the current bitmap in
    //          the bitmap stream.
    //
    //      LcnFromHint - Bit offset of the start of the page after
    //          the page which contains the StartingSearchHint.
    //
    //      BitOffset - Offset of found bits from the beginning
    //          of the current bitmap.
    //

    LCN Lcn = StartingSearchHint;
    LCN BaseLcn;
    LCN LcnFromHint;
    ULONG BitOffset;
    ULONG StartIndex;

    RTL_BITMAP_RUN RunArray[16];
    ULONG RunArrayIndex;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFindFreeBitmapRun\n") );
    DebugTrace( 0, Dbg, ("NumberToFind       = %016I64x\n", NumberToFind) );
    DebugTrace( 0, Dbg, ("StartingSearchHint = %016I64x\n", StartingSearchHint) );

    BitmapBcb = NULL;
    StuffAdded = FALSE;

    try {

        //
        //  First trim the number of clusters that we are being asked
        //  for to fit in a ulong
        //

        if (NumberToFind > MAXULONG) {

            RequestedCount = Count = MAXULONG;

        } else {

            RequestedCount = Count = (ULONG)NumberToFind;
        }

        //
        //  Let's not go past the end of the volume.
        //

        if (Lcn < Vcb->TotalClusters) {

            //
            //  Now read in the first bitmap based on the search hint, this will return
            //  a base lcn that we can use to compute the real bit off for our hint.  We also
            //  must bias the bitmap by whatever has been recently deallocated.
            //

            NtfsMapPageInBitmap( IrpContext, Vcb, Lcn, &BaseLcn, &Bitmap, &BitmapBcb );

            LcnFromHint = BaseLcn + Bitmap.SizeOfBitMap;

            StuffAdded = NtfsAddRecentlyDeallocated( Vcb, BaseLcn, &Bitmap );
            BitmapBuffer = Bitmap.Buffer;

            //
            //  We don't want to look in the Mft zone if it is at the beginning
            //  of this page unless our caller told us to skip any zone checks.  Adjust the
            //  bitmap so we skip this range.
            //

            if (!IgnoreMftZone &&
                (BaseLcn < Vcb->MftZoneEnd) && (Lcn > Vcb->MftZoneEnd)) {

                //
                //  Find the number of bits to swallow.  We know this will
                //  a multible of bytes since the Mft zone end is always
                //  on a ulong boundary.
                //

                BitOffset = (ULONG) (Vcb->MftZoneEnd - BaseLcn);

                //
                //  Adjust the bitmap size and buffer to skip this initial
                //  range in the Mft zone.
                //

                Bitmap.Buffer = Add2Ptr( Bitmap.Buffer, BitOffset / 8 );
                Bitmap.SizeOfBitMap -= BitOffset;

                BaseLcn = Vcb->MftZoneEnd;
            }

            //
            //  The bit offset is from the base of this bitmap to our starting Lcn.
            //

            BitOffset = (ULONG)(Lcn - BaseLcn);

            //
            //  Now search the bitmap for a clear number of bits based on our hint
            //  If we the returned bitoffset is not -1 then we have a hit.
            //

            if (ReturnAnyLength) {

                //
                //  We'd like to find a contiguous run.  If we don't then go back and
                //  ask for a longer run.
                //

                StartIndex = RtlFindClearBits( &Bitmap, 1, BitOffset );

                if ((StartIndex != -1) &&
                    (StartIndex != BitOffset)) {

                    BitOffset = RtlFindClearBits( &Bitmap, Count, BitOffset );

                } else {

                    BitOffset = StartIndex;
                }

                //
                //  We didn't find a contiguous length
                //


            } else {

                BitOffset = RtlFindClearBits( &Bitmap, Count, BitOffset );
            }

            if (BitOffset != -1) {

                //
                //  We found a run.  If the starting Lcn is our input hint AND
                //  we will accept any length then walk forward in the bitmap
                //  and find the real length of the run.
                //

                *ReturnedLcn = BitOffset + BaseLcn;

                if (ReturnAnyLength &&
                    (*ReturnedLcn == StartingSearchHint)) {

                    Count = 0;

                    while (TRUE) {


                        FoundCount = RtlFindNextForwardRunClear( &Bitmap,
                                                                 BitOffset,
                                                                 &StartIndex );

                        //
                        //  Verify that we found something and that the offset
                        //  begins with out start hint.
                        //

                        if (FoundCount &&
                            (BitOffset == StartIndex)) {

                            Count += FoundCount;

                            if (Count >= RequestedCount) {

                                Count = RequestedCount;
                                break;
                            }

                        } else {

                            break;
                        }

                        //
                        //  Break out if we found enough or the run doesn't
                        //  extend to the end of the bitmap or we are at
                        //  the last page of the bitmap.
                        //

                        if ((StartIndex + FoundCount != Bitmap.SizeOfBitMap) ||
                            (BaseLcn + Bitmap.SizeOfBitMap >= Vcb->TotalClusters)) {

                            break;
                        }

                        Lcn = BaseLcn + Bitmap.SizeOfBitMap;

                        if (StuffAdded) { NtfsFreePool( BitmapBuffer ); StuffAdded = FALSE; }

                        NtfsUnpinBcb( IrpContext, &BitmapBcb );
                        NtfsMapPageInBitmap( IrpContext, Vcb, Lcn, &BaseLcn, &Bitmap, &BitmapBcb );
                        ASSERTMSG("Math wrong for bits per page of bitmap", (Lcn == BaseLcn));

                        StuffAdded = NtfsAddRecentlyDeallocated( Vcb, BaseLcn, &Bitmap );
                        BitmapBuffer = Bitmap.Buffer;
                        BitOffset = 0;
                    }
                }

                *ClusterCountFound = Count;

                //
                //  While we have the bitmap let's grab some long runs
                //

                RunArrayIndex = RtlFindClearRuns( &Bitmap, RunArray, 16, TRUE );

                if (RunArrayIndex > 0) {

                    NtfsAddCachedRunMult( IrpContext,
                                          Vcb,
                                          BaseLcn,
                                          RunArray,
                                          RunArrayIndex );
                }

                leave;
            }

            //
            //  Well the first try didn't succeed so now just grab the longest free run in the
            //  current bitmap, and while we're at it will populate the cached run information
            //

            RunArrayIndex = RtlFindClearRuns( &Bitmap, RunArray, 16, TRUE );

            if (RunArrayIndex > 0) {

                USHORT LocalOffset;

                *ReturnedLcn = RunArray[0].StartingIndex + BaseLcn;
                *ClusterCountFound = RunArray[0].NumberOfBits;

                //
                //  There is no point in adding a free run for a range that is
                //  about to be consumed, although it won't affect correctness.
                //

                if (*ClusterCountFound > NumberToFind) {

                    //
                    //  Trim off the part of the free run that will be
                    //  consumed by the caller.
                    //

                    RunArray[0].StartingIndex += (ULONG)NumberToFind;
                    RunArray[0].NumberOfBits -= (ULONG)NumberToFind;
                    LocalOffset = 0;

                    //
                    //  Only return the requested amount to the caller.
                    //

                    *ClusterCountFound = NumberToFind;
                } else {

                    //
                    //  Skip the first entry since the caller will use all of
                    //  it.
                    //

                    LocalOffset = 1;
                }
                if (RunArrayIndex > LocalOffset) {

                    NtfsAddCachedRunMult( IrpContext,
                                          Vcb,
                                          BaseLcn,
                                          RunArray + LocalOffset,
                                          RunArrayIndex - LocalOffset );
                }

                leave;
            }

            //
            //  Well the current bitmap is full so now simply scan the disk looking
            //  for anything that is free, starting with the next bitmap.
            //  And again bias the bitmap with recently deallocated clusters.
            //  We won't even bother looking for the longest free runs we'll take
            //  whatever we can get.
            //

            if (StuffAdded) { NtfsFreePool( BitmapBuffer ); StuffAdded = FALSE; }
            NtfsUnpinBcb( IrpContext, &BitmapBcb );
            Lcn = BaseLcn + Bitmap.SizeOfBitMap;

            //
            //  If this is the Mft then scan from the current point to volume end,
            //  then back to the beginning.
            //

            if (IgnoreMftZone) {

                //
                //  Look in the following ranges.  Break out if we find anything.
                //
                //      - Current point to end of volume
                //      - Start of volume to current
                //

                if (NtfsScanBitmapRange( IrpContext,
                                         Vcb,
                                         Lcn,
                                         Vcb->TotalClusters,
                                         NumberToFind,
                                         ReturnedLcn,
                                         ClusterCountFound )) {

                    if ((*ReturnedLcn < Vcb->MftZoneEnd) &&
                        (*ReturnedLcn >= Vcb->MftZoneStart)) {

                        AllocatedFromZone = TRUE;
                    }
                    leave;
                }

                if (NtfsScanBitmapRange( IrpContext,
                                         Vcb,
                                         0,
                                         Lcn,
                                         NumberToFind,
                                         ReturnedLcn,
                                         ClusterCountFound )) {

                    if ((*ReturnedLcn < Vcb->MftZoneEnd) &&
                        (*ReturnedLcn >= Vcb->MftZoneStart)) {

                        AllocatedFromZone = TRUE;
                    }
                    leave;
                }

                //
                //  No luck.
                //

                *ClusterCountFound = 0;
                leave;
            }
        }

        //
        //  Check if we are starting before the Mft zone.
        //

        if (Lcn < Vcb->MftZoneStart) {

            //
            //  Look in the following ranges.  Break out if we find anything.
            //
            //      - Current point to Zone start
            //      - Zone end to end of volume
            //      - Start of volume to current
            //

            if (NtfsScanBitmapRange( IrpContext,
                                     Vcb,
                                     Lcn,
                                     Vcb->MftZoneStart,
                                     NumberToFind,
                                     ReturnedLcn,
                                     ClusterCountFound )) {
                leave;
            }

            if (NtfsScanBitmapRange( IrpContext,
                                     Vcb,
                                     Vcb->MftZoneEnd,
                                     Vcb->TotalClusters,
                                     NumberToFind,
                                     ReturnedLcn,
                                     ClusterCountFound )) {

                leave;
            }

            if (NtfsScanBitmapRange( IrpContext,
                                     Vcb,
                                     0,
                                     Lcn,
                                     NumberToFind,
                                     ReturnedLcn,
                                     ClusterCountFound )) {

                leave;
            }

        //
        //  Check if we are beyond the Mft zone.
        //

        } else if (Lcn > Vcb->MftZoneEnd) {

            //
            //  Look in the following ranges.  Break out if we find anything.
            //
            //      - Current point to end of volume
            //      - Start of volume to Zone start
            //      - Zone end to current point.
            //

            if (NtfsScanBitmapRange( IrpContext,
                                     Vcb,
                                     Lcn,
                                     Vcb->TotalClusters,
                                     NumberToFind,
                                     ReturnedLcn,
                                     ClusterCountFound )) {
                leave;
            }

            if (NtfsScanBitmapRange( IrpContext,
                                     Vcb,
                                     0,
                                     Vcb->MftZoneStart,
                                     NumberToFind,
                                     ReturnedLcn,
                                     ClusterCountFound )) {
                leave;
            }

            if (NtfsScanBitmapRange( IrpContext,
                                     Vcb,
                                     Vcb->MftZoneEnd,
                                     Lcn,
                                     NumberToFind,
                                     ReturnedLcn,
                                     ClusterCountFound )) {
                leave;
            }

        //
        //  We are starting within the zone.  Skip over the zone to check it last.
        //

        } else {

            //
            //  Look in the following ranges.  Break out if we find anything.
            //
            //      - End of zone to end of volume
            //      - Start of volume to start of zone
            //

            if (NtfsScanBitmapRange( IrpContext,
                                     Vcb,
                                     Vcb->MftZoneEnd,
                                     Vcb->TotalClusters,
                                     NumberToFind,
                                     ReturnedLcn,
                                     ClusterCountFound )) {

                leave;
            }

            if (NtfsScanBitmapRange( IrpContext,
                                     Vcb,
                                     0,
                                     Vcb->MftZoneStart,
                                     NumberToFind,
                                     ReturnedLcn,
                                     ClusterCountFound )) {

                leave;
            }
        }

        //
        //  We didn't find anything.  Let's examine the zone explicitly.
        //

        if (NtfsScanBitmapRange( IrpContext,
                                 Vcb,
                                 Vcb->MftZoneStart,
                                 Vcb->MftZoneEnd,
                                 NumberToFind,
                                 ReturnedLcn,
                                 ClusterCountFound )) {

            AllocatedFromZone = TRUE;
            leave;
        }

        //
        //  No luck.
        //

        *ClusterCountFound = 0;

    } finally {

        DebugUnwind( NtfsFindFreeBitmapRun );

        if (StuffAdded) { NtfsFreePool( BitmapBuffer ); }

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    DebugTrace( 0, Dbg, ("ReturnedLcn <- %016I64x\n", *ReturnedLcn) );
    DebugTrace( 0, Dbg, ("ClusterCountFound <- %016I64x\n", *ClusterCountFound) );
    DebugTrace( -1, Dbg, ("NtfsFindFreeBitmapRun -> VOID\n") );

    return AllocatedFromZone;
}


//
//  Local support routine
//

BOOLEAN
NtfsScanBitmapRange (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartLcn,
    IN LCN BeyondLcn,
    IN LONGLONG NumberToFind,
    OUT PLCN ReturnedLcn,
    OUT PLONGLONG ClusterCountFound
    )

/*++

Routine Description:

    This routine will scan a range of the bitmap looking for a free run.
    It is called when we need to limit the bits we are willing to consider
    at a time, typically to skip over the Mft zone.

Arguments:

    Vcb - Volume being scanned.

    StartLcn - First Lcn in the bitmap to consider.

    BeyondLcn - First Lcn in the bitmap past the range we want to consider.

    NumberToFind - Supplies the number of clusters that we would
        really like to find

    ReturnedLcn - Start of free range if found.

    ClusterCountFound - Length of free range if found.

Return Value:

    BOOLEAN - TRUE if a bitmap range was found.  FALSE otherwise.

--*/

{
    BOOLEAN FreeRangeFound = FALSE;
    RTL_BITMAP Bitmap;
    PVOID BitmapBuffer;
    ULONG BitOffset;

    PBCB BitmapBcb = NULL;

    BOOLEAN StuffAdded = FALSE;
    LCN BaseLcn;

    RTL_BITMAP_RUN RunArray[16];
    ULONG RunArrayIndex;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsScanBitmapRange...\n") );

    //
    //  The end Lcn might be beyond the end of the bitmap.
    //

    if (BeyondLcn > Vcb->TotalClusters) {

        BeyondLcn = Vcb->TotalClusters;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Now search the rest of the bitmap starting with right after the mft zone
        //  followed by the mft zone (or the beginning of the disk).  Again take whatever
        //  we can get and not bother with the longest runs.
        //

        while (StartLcn < BeyondLcn) {

            NtfsUnpinBcb( IrpContext, &BitmapBcb );
            NtfsMapPageInBitmap( IrpContext, Vcb, StartLcn, &BaseLcn, &Bitmap, &BitmapBcb );

            StuffAdded = NtfsAddRecentlyDeallocated( Vcb, BaseLcn, &Bitmap );
            BitmapBuffer = Bitmap.Buffer;

            //
            //  Check if we don't want to use the entire page.
            //

            if ((BaseLcn + Bitmap.SizeOfBitMap) > BeyondLcn) {

                Bitmap.SizeOfBitMap = (ULONG) (BeyondLcn - BaseLcn);
            }

            //
            //  Now adjust the starting Lcn if not at the beginning
            //  of the bitmap page.  We know this will be a multiple
            //  of bytes since the MftZoneEnd is always on a ulong
            //  boundary in the bitmap.
            //

            if (BaseLcn != StartLcn) {

                BitOffset = (ULONG) (StartLcn - BaseLcn);

                Bitmap.SizeOfBitMap -= BitOffset;
                Bitmap.Buffer = Add2Ptr( Bitmap.Buffer, BitOffset / 8 );

                BaseLcn = StartLcn;
            }

            RunArrayIndex = RtlFindClearRuns( &Bitmap, RunArray, 16, TRUE );

            if (RunArrayIndex > 0) {

                USHORT LocalOffset;

                *ReturnedLcn = RunArray[0].StartingIndex + BaseLcn;
                *ClusterCountFound = RunArray[0].NumberOfBits;
                FreeRangeFound = TRUE;

                //
                //  There is no point in adding a free run for a range that is
                //  about to be consumed, although it won't affect correctness.
                //

                if (*ClusterCountFound > NumberToFind) {

                    //
                    //  Trim off the part of the free run that will be
                    //  consumed by the caller.
                    //

                    RunArray[0].StartingIndex += (ULONG)NumberToFind;
                    RunArray[0].NumberOfBits -= (ULONG)NumberToFind;
                    LocalOffset = 0;
                } else {

                    //
                    //  Skip the first entry since the caller will use all of
                    //  it.
                    //

                    LocalOffset = 1;
                }
                if (RunArrayIndex > LocalOffset) {

                    NtfsAddCachedRunMult( IrpContext,
                                          Vcb,
                                          BaseLcn,
                                          RunArray + LocalOffset,
                                          RunArrayIndex - LocalOffset );
                }

                leave;
            }

            StartLcn = BaseLcn + Bitmap.SizeOfBitMap;

            if (StuffAdded) { NtfsFreePool( BitmapBuffer ); StuffAdded = FALSE; }
        }

    } finally {

        DebugUnwind( NtfsScanBitmapRange );

        if (StuffAdded) { NtfsFreePool( BitmapBuffer ); StuffAdded = FALSE; }
        NtfsUnpinBcb( IrpContext, &BitmapBcb );

        DebugTrace( -1, Dbg, ("NtfsScanBitmapRange -> %08lx\n", FreeRangeFound) );
    }

    return FreeRangeFound;
}


//
//  Local support routine
//

BOOLEAN
NtfsAddRecentlyDeallocated (
    IN PVCB Vcb,
    IN LCN StartingBitmapLcn,
    IN OUT PRTL_BITMAP Bitmap
    )

/*++

Routine Description:

    This routine will modify the input bitmap by removing from it
    any clusters that are in the recently deallocated mcb.  If we
    do add stuff then we will not modify the bitmap buffer itself but
    will allocate a new copy for the bitmap.

    We will always protect the boot sector on the disk by marking the
    first 8K as allocated.  This will prevent us from overwriting the
    boot sector if the volume becomes corrupted.

Arguments:

    Vcb - Supplies the Vcb used in this operation

    StartingBitmapLcn - Supplies the Starting Lcn of the bitmap

    Bitmap - Supplies the bitmap being modified

Return Value:

    BOOLEAN - TRUE if the bitmap has been modified and FALSE
        otherwise.

--*/

{
    BOOLEAN Results;
    PVOID NewBuffer;


    LCN EndingBitmapLcn;

    PLARGE_MCB Mcb;

    ULONG i;
    VCN StartingVcn;
    LCN StartingLcn;
    LCN EndingLcn;
    LONGLONG ClusterCount;
    PDEALLOCATED_CLUSTERS DeallocatedClusters;

    ULONG StartingBit;
    ULONG EndingBit;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddRecentlyDeallocated...\n") );

    //
    //  Until shown otherwise we will assume that we haven't updated anything
    //

    Results = FALSE;

    //
    //  If this is the first page of the bitmap then mark the first 8K as
    //  allocated.  This will prevent us from accidentally allocating out
    //  of the boot sector even if the bitmap is corrupt.
    //

    if ((StartingBitmapLcn == 0) &&
        !RtlAreBitsSet( Bitmap, 0, ClustersFromBytes( Vcb, 0x2000 ))) {

        NewBuffer = NtfsAllocatePool(PagedPool, (Bitmap->SizeOfBitMap+7)/8 );
        RtlCopyMemory( NewBuffer, Bitmap->Buffer, (Bitmap->SizeOfBitMap+7)/8 );
        Bitmap->Buffer = NewBuffer;

        Results = TRUE;

        //
        //  Now mark the bits as allocated.
        //

        RtlSetBits( Bitmap, 0, ClustersFromBytes( Vcb, 0x2000 ));
    }

    //
    //  Now compute the ending bitmap lcn for the bitmap
    //

    EndingBitmapLcn = StartingBitmapLcn + (Bitmap->SizeOfBitMap - 1);

    //
    //  For every run in the recently deallocated mcb we will check if it is real and
    //  then check if the run in contained in the bitmap.
    //
    //  There are really six cases to consider:
    //
    //         StartingBitmapLcn                   EndingBitmapLcn
    //                  +=================================+
    //
    //
    //   1 -------+ EndingLcn
    //
    //   2                                           StartingLcn +--------
    //
    //   3 -------------------+ EndingLcn
    //
    //   4                                StartingLcn +-------------------------
    //
    //   5 ---------------------------------------------------------------
    //
    //   6            EndingLcn +-------------------+ StartingLcn
    //
    //
    //      1. EndingLcn is before StartingBitmapLcn which means we haven't
    //         reached the bitmap yet.
    //
    //      2. StartingLcn is after EndingBitmapLcn which means we've gone
    //         beyond the bitmap
    //
    //      3, 4, 5, 6.  There is some overlap between the bitmap and
    //         the run.
    //

    DeallocatedClusters = (PDEALLOCATED_CLUSTERS)Vcb->DeallocatedClusterListHead.Flink;
    do {

        //
        //  Skip this Mcb if it has no entries.
        //

        if (DeallocatedClusters->ClusterCount != 0) {

            Mcb = &DeallocatedClusters->Mcb;

            for (i = 0; FsRtlGetNextLargeMcbEntry( Mcb, i, &StartingVcn, &StartingLcn, &ClusterCount ); i += 1) {

                if (StartingVcn == StartingLcn) {

                    //
                    //  Compute the ending lcn as the starting lcn minus cluster count plus 1.
                    //

                    EndingLcn = (StartingLcn + ClusterCount) - 1;

                    //
                    //  Check if we haven't reached the bitmap yet.
                    //

                    if (EndingLcn < StartingBitmapLcn) {

                        NOTHING;

                    //
                    //  Check if we've gone beyond the bitmap
                    //

                    } else if (EndingBitmapLcn < StartingLcn) {

                        break;

                    //
                    //  Otherwise we overlap with the bitmap in some way
                    //

                    } else {

                        //
                        //  First check if we have never set bit in the bitmap.  and if so then
                        //  now is the time to make an private copy of the bitmap buffer
                        //

                        if (Results == FALSE) {

                            NewBuffer = NtfsAllocatePool(PagedPool, (Bitmap->SizeOfBitMap+7)/8 );
                            RtlCopyMemory( NewBuffer, Bitmap->Buffer, (Bitmap->SizeOfBitMap+7)/8 );
                            Bitmap->Buffer = NewBuffer;

                            Results = TRUE;
                        }

                        //
                        //  Now compute the begining and ending bit that we need to set in the bitmap
                        //

                        StartingBit = (StartingLcn < StartingBitmapLcn ?
                                       0 :
                                       (ULONG)(StartingLcn - StartingBitmapLcn));

                        EndingBit = (EndingLcn > EndingBitmapLcn ?
                                     Bitmap->SizeOfBitMap - 1 :
                                     (ULONG)(EndingLcn - StartingBitmapLcn));

                        //
                        //  And set those bits
                        //

                        RtlSetBits( Bitmap, StartingBit, EndingBit - StartingBit + 1 );
                    }
                }
            }
        }

        DeallocatedClusters = (PDEALLOCATED_CLUSTERS)DeallocatedClusters->Link.Flink;

    } while (&DeallocatedClusters->Link != &Vcb->DeallocatedClusterListHead );

    DebugTrace( -1, Dbg, ("NtfsAddRecentlyDeallocated -> %08lx\n", Results) );

    return Results;
}


//
//  Local support routine
//

VOID
NtfsMapOrPinPageInBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN Lcn,
    OUT PLCN StartingLcn,
    IN OUT PRTL_BITMAP Bitmap,
    OUT PBCB *BitmapBcb,
    IN BOOLEAN AlsoPinData
    )

/*++

Routine Description:

    This routine reads in a single page of the bitmap file and returns
    an initialized bitmap variable for that page

Arguments:

    Vcb - Supplies the vcb used in this operation

    Lcn - Supplies the Lcn index in the bitmap that we want to read in
        In other words, this routine reads in the bitmap page containing
        the lcn index

    StartingLcn - Receives the base lcn index of the bitmap that we've
        just read in.

    Bitmap - Receives an initialized bitmap.  The memory for the bitmap
        header must be supplied by the caller

    BitmapBcb - Receives the Bcb for the bitmap buffer

    AlsoPinData - Indicates if this routine should also pin the page
        in memory, used if we need to modify the page

Return Value:

    None.

--*/

{
    ULONG BitmapSize;
    PVOID Buffer;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsMapOrPinPageInBitmap\n") );
    DebugTrace( 0, Dbg, ("Lcn = %016I64x\n", Lcn) );

    //
    //  Compute the starting lcn index of the page we're after
    //

    *StartingLcn = Lcn & ~(BITS_PER_PAGE-1);

    //
    //  Compute how many bits there are in the page we need to read
    //

    BitmapSize = (ULONG)(Vcb->TotalClusters - *StartingLcn);

    if (BitmapSize > BITS_PER_PAGE) {

        BitmapSize = BITS_PER_PAGE;
    }

    //
    //  Now either Pin or Map the bitmap page, we will add 7 to the bitmap
    //  size before dividing it by 8.  That way we will ensure we get the last
    //  byte read in.  For example a bitmap size of 1 through 8 reads in 1 byte
    //

    if (AlsoPinData) {

        NtfsPinStream( IrpContext,
                       Vcb->BitmapScb,
                       Int64ShraMod32( *StartingLcn, 3 ),
                       (BitmapSize+7)/8,
                       BitmapBcb,
                       &Buffer );

    } else {

        NtfsMapStream( IrpContext,
                       Vcb->BitmapScb,
                       Int64ShraMod32( *StartingLcn, 3 ),
                       (BitmapSize+7)/8,
                       BitmapBcb,
                       &Buffer );
    }

    //
    //  And initialize the bitmap
    //

    RtlInitializeBitMap( Bitmap, Buffer, BitmapSize );

    DebugTrace( 0, Dbg, ("StartingLcn <- %016I64x\n", *StartingLcn) );
    DebugTrace( -1, Dbg, ("NtfsMapOrPinPageInBitmap -> VOID\n") );

    return;
}


BOOLEAN
NtfsAddCachedRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN LONGLONG ClusterCount,
    IN NTFS_RUN_STATE RunState
    )

/*++

Routine Description:

    This procedure adds a new run to the cached free space
    bitmap information.

Arguments:

    Vcb - Supplies the vcb for this operation

    StartingLcn - Supplies the lcn for the run being added

    ClusterCount - Supplies the number of clusters in the run being added

    RunState - Supplies the state of the run being added.  This state
        must be either free or allocated.

Return Value:

    BOOLEAN - TRUE if more entries can be added to the list, FALSE otherwise.

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddCachedRun\n") );
    DebugTrace( 0, Dbg, ("StartingLcn  = %016I64x\n", StartingLcn) );
    DebugTrace( 0, Dbg, ("ClusterCount = %016I64x\n", ClusterCount) );

    //
    //  Based on whether we are adding a free or allocated run we
    //  setup or local variables to a point to the right
    //  vcb variables
    //

    if (RunState == RunStateFree) {

        //
        //  We better not be setting Lcn 0 free.
        //

        if (StartingLcn == 0) {

            ASSERT( FALSE );
            NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
        }

        //
        //  Sanity check that we aren't adding bits beyond the end of the
        //  bitmap.
        //

        ASSERT( StartingLcn + ClusterCount <= Vcb->TotalClusters );

        NtfsInsertCachedLcn( &Vcb->CachedRuns,
                             StartingLcn,
                             ClusterCount );

    } else {

        //
        //  Now remove the run from the cached runs because it can potentially already be
        //  there.
        //

        NtfsRemoveCachedLcn( &Vcb->CachedRuns,
                             StartingLcn,
                             ClusterCount );
    }

    DebugTrace( -1, Dbg, ("NtfsAddCachedRun -> VOID\n") );

    return ((Vcb->CachedRuns.Avail - Vcb->CachedRuns.Used + Vcb->CachedRuns.DelLcnCount) > 0);
}

#if 0

VOID
NtfsMakeSpaceCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN StartingLcn,
    IN RTL_BITMAP_RUN *RunArray,
    IN ULONG RunCount,
    IN PUSHORT LcnSorted OPTIONAL
    )

/*++

Routine Description:

    This procedure attempts to make space in the Lcn-sorted array for RunCount
    new entries in the given Lcn range.  This routine will not delete any
    existing entries to create the space because we don't know at this time
    how many will actually end up being inserted into the list.  They may not
    be inserted because their run lengths are too small relative to the
    entries already in the list.  This call is used because it is more
    efficient to create space once for all the entries than to do so
    individually.  In effect, this routine moves windows of deleted entries
    to the desired Lcn position.

Arguments:

    CachedRuns - Pointer to a cached run structure.

    StartingLcn - Supplies the base Lcn for the runs being added

    RunArray - The bit position and length of each of the free runs.
        The array will be sorted according to length.

    RunCount - Supplies the number of runs being added

    LcnSorted - An optional array of RunCount indices that gives the Lcn
        sort order.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsMakeSpaceCachedLcn\n") );

    DebugTrace( -1, Dbg, ("NtfsMakeSpaceCachedLcn -> VOID\n") );

    return;
}
#endif /* 0 */


VOID
NtfsAddCachedRunMult (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN PRTL_BITMAP_RUN RunArray,
    IN ULONG RunCount
    )

/*++

Routine Description:

    This procedure adds multiple new runs to the cached free space
    bitmap information.  It is assumed that the new runs fall
    in a close range of Lcn values.  As a rule, these runs come from
    a single page of the bitmap.

Arguments:

    Vcb - Supplies the vcb for this operation

    StartingLcn - Supplies the base Lcn for the runs being added

    RunArray - The bit position and length of each of the free runs.
        The array will be sorted according to length.

    RunCount - Supplies the number of runs being added

Return Value:

    None.

--*/

{
    USHORT Index1;
    PUSHORT LcnSorted = NULL;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddCachedRunMult\n") );
    DebugTrace( 0, Dbg, ("StartingLcn  = %016I64x\n", StartingLcn) );
    DebugTrace( 0, Dbg, ("RunArray = %08lx\n", RunArray) );
    DebugTrace( 0, Dbg, ("RunCount = %08lx\n", RunCount) );

#if 0

    //
    //  Sort the entries by Lcn.  It is often the case that at startup we are
    //  adding entries that will all fall at the end of the Lcn-sorted list.
    //  However, if the entries are not added in Lcn-sorted order there will
    //  likely be some moving around of entries in the Lcn-sorted list that
    //  could be avoided.
    //

    LcnSorted = NtfsAllocatePoolNoRaise( PagedPool, sizeof( USHORT ) * RunCount );
    if (LcnSorted != NULL) {

        USHORT Index2;

        //
        //  Bubble sort the elements.
        //

        for (Index1 = 1, LcnSorted[0] = 0;
             Index1 < RunCount;
             Index1 += 1) {

            for (Index2 = 0; Index2 < Index1; Index2 += 1) {

                if (RunArray[Index1].StartingIndex < RunArray[LcnSorted[Index2]].StartingIndex) {

                    //
                    //  Move the entries from Index2 through Index1 - 1 to the
                    //  right to make space for the current entry.
                    //

                    RtlMoveMemory( LcnSorted + Index2 + 1,
                                   LcnSorted + Index2,
                                   sizeof( USHORT ) * (Index1 - Index2) );
                    break;
                }
            }

            //
            //  Write the index into the correctly sorted location.
            //

            LcnSorted[Index2] = Index1;
        }
    }

    //
    //  Make space in the Lcn-sorted array for these new entries.
    //  This is done in advance because it is more efficient to create
    //  space once for all the entries than to do so individually.
    //  The following routine will not delete any existing entries to
    //  create the space because we don't know at this time how many will
    //  actually end up being inserted into the list.  They may not be
    //  inserted because their run lengths are too small relative to the
    //  entries already in the list.
    //

    NtfsMakeSpaceCachedLcn( &Vcb->CachedRuns,
                            StartingLcn,
                            RunArray,
                            RunCount,
                            LcnSorted );
#endif /* 0 */

    //
    //  Insert the new entries.
    //

    for (Index1 = 0; Index1 < RunCount; Index1 += 1) {

        //
        //  If not sorted then do the generic insert.  The gain for the sorted case
        //  that we won't have to do a memory copy for entries we just inserted.
        //

        if (LcnSorted != NULL) {

            (VOID) NtfsAddCachedRun( IrpContext,
                                     Vcb,
                                     StartingLcn + RunArray[ LcnSorted[ Index1 ]].StartingIndex,
                                     (LONGLONG)RunArray[ LcnSorted[ Index1 ]].NumberOfBits,
                                     RunStateFree );
        } else {

            (VOID) NtfsAddCachedRun( IrpContext,
                                     Vcb,
                                     StartingLcn + RunArray[ Index1 ].StartingIndex,
                                     (LONGLONG)RunArray[ Index1 ].NumberOfBits,
                                     RunStateFree );
        }
    }

    if (LcnSorted != NULL) {

        NtfsFreePool( LcnSorted );
    }

    DebugTrace( -1, Dbg, ("NtfsAddCachedRunMult -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsReadAheadCachedBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn
    )

/*++

Routine Description:

    This routine does a read ahead of the bitmap into the cached bitmap
    starting at the specified starting lcn.

Arguments:

    Vcb - Supplies the vcb to use in this operation

    StartingLcn - Supplies the starting lcn to use in this read ahead
        operation.

Return Value:

    None.

--*/

{
    RTL_BITMAP Bitmap;
    PBCB BitmapBcb;

    BOOLEAN StuffAdded;

    LCN BaseLcn;
    ULONG Index;
    LONGLONG Size;

    RTL_BITMAP_RUN RunArray[16];
    ULONG RunArrayIndex;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReadAheadCachedBitmap\n") );
    DebugTrace( 0, Dbg, ("StartingLcn = %016I64x\n", StartingLcn) );

    BitmapBcb = NULL;
    StuffAdded = FALSE;

    try {

        //
        //  Check if the lcn index is already in the cached runs info and if it is then
        //  our read ahead is done.
        //

        if (NtfsLookupCachedLcn( &Vcb->CachedRuns,
                                 StartingLcn,
                                 &BaseLcn,
                                 &BaseLcn,
                                 NULL )) {

            try_return( NOTHING );
        }

        //
        //  Map in the page containing the starting lcn and compute the bit index for the
        //  starting lcn within the bitmap.  And bias the bitmap with recently deallocated
        //  clusters.
        //

        NtfsMapPageInBitmap( IrpContext, Vcb, StartingLcn, &BaseLcn, &Bitmap, &BitmapBcb );

        StuffAdded = NtfsAddRecentlyDeallocated( Vcb, BaseLcn, &Bitmap );

        Index = (ULONG)(StartingLcn - BaseLcn);

        //
        //  Now if the index is clear then we can build up the hint at the starting index, we
        //  scan through the bitmap checking the size of the run and then adding the free run
        //  to the cached free space mcb
        //

        if (RtlCheckBit( &Bitmap, Index ) == 0) {

            Size = RtlFindNextForwardRunClear( &Bitmap, Index, &Index );

            (VOID) NtfsAddCachedRun( IrpContext, Vcb, StartingLcn, (LONGLONG)Size, RunStateFree );
        }

        //
        //  While we have the bitmap loaded we will scan it for a few longest runs
        //

        RunArrayIndex = RtlFindClearRuns( &Bitmap, RunArray, 16, TRUE );

        if (RunArrayIndex > 0) {

            NtfsAddCachedRunMult( IrpContext,
                                  Vcb,
                                  BaseLcn,
                                  RunArray,
                                  RunArrayIndex );
        }

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsReadAheadCachedBitmap );

        if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); }

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    DebugTrace( -1, Dbg, ("NtfsReadAheadCachedBitmap -> VOID\n") );

    return;
}


//
//  Local support routine
//

BOOLEAN
NtfsGetNextHoleToFill (
    IN PIRP_CONTEXT IrpContext,
    IN PNTFS_MCB Mcb,
    IN VCN StartingVcn,
    IN VCN EndingVcn,
    OUT PVCN VcnToFill,
    OUT PLONGLONG ClusterCountToFill,
    OUT PLCN PrecedingLcn
    )

/*++

Routine Description:

    This routine takes a specified range within an mcb and returns the to
    caller the first run that is not allocated to any lcn within the range

Arguments:

    Mcb - Supplies the mcb to use in this operation

    StartingVcn - Supplies the starting vcn to search from

    EndingVcn - Supplies the ending vcn to search to

    VcnToFill - Receives the first Vcn within the range that is unallocated

    ClusterCountToFill - Receives the size of the free run

    PrecedingLcn - Receives the Lcn of the allocated cluster preceding the
        free run.  If the free run starts at Vcn 0 then the preceding lcn
        is -1.

Return Value:

    BOOLEAN - TRUE if there is another hole to fill and FALSE otherwise

--*/

{
    BOOLEAN Result;
    BOOLEAN McbHit;
    LCN Lcn;
    LONGLONG MaximumRunSize;

    LONGLONG LlTemp1;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGetNextHoleToFill\n") );
    DebugTrace( 0, Dbg, ("StartingVcn = %016I64x\n", StartingVcn) );
    DebugTrace( 0, Dbg, ("EndingVcn   = %016I64x\n", EndingVcn) );

    //
    //  We'll first assume that there is not a hole to fill unless
    //  the following loop finds one to fill
    //

    Result = FALSE;

    for (*VcnToFill = StartingVcn;
         *VcnToFill <= EndingVcn;
         *VcnToFill += *ClusterCountToFill) {

        //
        //  Check if the hole is already filled and it so then do nothing but loop back up
        //  to the top of our loop and try again
        //

        if ((McbHit = NtfsLookupNtfsMcbEntry( Mcb, *VcnToFill, &Lcn, ClusterCountToFill, NULL, NULL, NULL, NULL )) &&
            (Lcn != UNUSED_LCN)) {

            NOTHING;

        } else {

            //
            //  We have a hole to fill so now compute the maximum size hole that
            //  we are allowed to fill and then check if we got an miss on the lookup
            //  and need to set cluster count or if the size we got back is too large
            //

            MaximumRunSize = (EndingVcn - *VcnToFill) + 1;

            if (!McbHit || (*ClusterCountToFill > MaximumRunSize)) {

                *ClusterCountToFill = MaximumRunSize;
            }

            //
            //  Now set the preceding lcn to either -1 if there isn't a preceding vcn or
            //  set it to the lcn of the preceding vcn
            //

            if (*VcnToFill == 0) {

                *PrecedingLcn = UNUSED_LCN;

            } else {

                LlTemp1 = *VcnToFill - 1;

                if (!NtfsLookupNtfsMcbEntry( Mcb, LlTemp1, PrecedingLcn, NULL, NULL, NULL, NULL, NULL )) {

                    *PrecedingLcn = UNUSED_LCN;
                }
            }

            //
            //  We found a hole so set our result to TRUE and break out of the loop
            //

            Result = TRUE;

            break;
        }
    }

    DebugTrace( 0, Dbg, ("VcnToFill <- %016I64x\n", *VcnToFill) );
    DebugTrace( 0, Dbg, ("ClusterCountToFill <- %016I64x\n", *ClusterCountToFill) );
    DebugTrace( 0, Dbg, ("PrecedingLcn <- %016I64x\n", *PrecedingLcn) );
    DebugTrace( -1, Dbg, ("NtfsGetNextHoleToFill -> %08lx\n", Result) );

    return Result;
}


//
//  Local support routine
//

LONGLONG
NtfsScanMcbForRealClusterCount (
    IN PIRP_CONTEXT IrpContext,
    IN PNTFS_MCB Mcb,
    IN VCN StartingVcn,
    IN VCN EndingVcn
    )

/*++

Routine Description:

    This routine scans the input mcb within the specified range and returns
    to the caller the exact number of clusters that a really free (i.e.,
    not mapped to any Lcn) within the range.

Arguments:

    Mcb - Supplies the Mcb used in this operation

    StartingVcn - Supplies the starting vcn to search from

    EndingVcn - Supplies the ending vcn to search to

Return Value:

    LONGLONG - Returns the number of unassigned clusters from
        StartingVcn to EndingVcn inclusive within the mcb.

--*/

{
    LONGLONG FreeCount;
    VCN Vcn;
    LCN Lcn;
    LONGLONG RunSize;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsScanMcbForRealClusterCount\n") );
    DebugTrace( 0, Dbg, ("StartingVcn = %016I64x\n", StartingVcn) );
    DebugTrace( 0, Dbg, ("EndingVcn   = %016I64x\n", EndingVcn) );

    //
    //  First compute free count as if the entire run is already unallocated
    //  and the in the following loop we march through the mcb looking for
    //  actual allocation and decrementing the free count appropriately
    //

    FreeCount = (EndingVcn - StartingVcn) + 1;

    for (Vcn = StartingVcn; Vcn <= EndingVcn; Vcn = Vcn + RunSize) {

        //
        //  Lookup the mcb entry and if we get back false then we're overrun
        //  the mcb and therefore nothing else above it can be allocated.
        //

        if (!NtfsLookupNtfsMcbEntry( Mcb, Vcn, &Lcn, &RunSize, NULL, NULL, NULL, NULL )) {

            break;
        }

        //
        //  If the lcn we got back is not -1 then this run is actually already
        //  allocated, so first check if the run size puts us over the ending
        //  vcn and adjust as necessary and then decrement the free count
        //  by the run size
        //

        if (Lcn != UNUSED_LCN) {

            if (RunSize > ((EndingVcn - Vcn) + 1)) {

                RunSize = (EndingVcn - Vcn) + 1;
            }

            FreeCount = FreeCount - RunSize;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsScanMcbForRealClusterCount -> %016I64x\n", FreeCount) );

    return FreeCount;
}


//
//  Local support routine, only defined with ntfs debug version
//

#ifdef NTFSDBG

ULONG
NtfsDumpCachedMcbInformation (
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine dumps out the cached bitmap information

Arguments:

    Vcb - Supplies the Vcb used by this operation

Return Value:

    ULONG - 1.

--*/

{
    DbgPrint("Dump BitMpSup Information, Vcb@ %08lx\n", Vcb);

    DbgPrint("TotalCluster: %016I64x\n", Vcb->TotalClusters);
    DbgPrint("FreeClusters: %016I64x\n", Vcb->FreeClusters);

    return 1;
}

#endif // NTFSDBG


//
//  The rest of this module implements the record allocation routines
//


VOID
NtfsInitializeRecordAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB DataScb,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute,
    IN ULONG BytesPerRecord,
    IN ULONG ExtendGranularity,
    IN ULONG TruncateGranularity,
    IN OUT PRECORD_ALLOCATION_CONTEXT RecordAllocationContext
    )

/*++

Routine Description:

    This routine initializes the record allocation context used for
    allocating and deallocating fixed sized records from a data stream.

    Note that the bitmap attribute size must always be at least a multiple
    of 32 bits.  However the data scb does not need to contain that many
    records.  If in the course of allocating a new record we discover that
    the data scb is too small we will then add allocation to the data scb.

Arguments:

    DataScb - Supplies the Scb representing the data stream that is being
        divided into fixed sized records with each bit in the bitmap corresponding
        to one record in the data stream

    BitmapAttribute - Supplies the enumeration context for the bitmap
        attribute.  The attribute can either be resident or nonresident
        and this routine will handle both cases properly.

    BytesPerRecord - Supplies the size of the homogenous records that
        that the data stream is being divided into.

    ExtendGranularity - Supplies the number of records (i.e., allocation units
        to extend the data scb by each time).

    TruncateGranularity - Supplies the number of records to use when truncating
        the data scb.  That is if the end of the data stream contains the
        specified number of free records then we truncate.

    RecordAllocationContext - Supplies the memory for an context record that is
        utilized by this record allocation routines.

Return Value:

    None.

--*/

{
    PATTRIBUTE_RECORD_HEADER AttributeRecordHeader;
    RTL_BITMAP Bitmap;

    ULONG ClearLength;
    ULONG ClearIndex;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( DataScb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInitializeRecordAllocation\n") );

    ASSERT( BytesPerRecord * ExtendGranularity >= DataScb->Vcb->BytesPerCluster );
    ASSERT( BytesPerRecord * TruncateGranularity >= DataScb->Vcb->BytesPerCluster );

    //
    //  First zero out the context record except for the data scb.
    //

    RtlZeroMemory( &RecordAllocationContext->BitmapScb,
                   sizeof(RECORD_ALLOCATION_CONTEXT) -
                   FIELD_OFFSET( RECORD_ALLOCATION_CONTEXT, BitmapScb ));

    //
    //  And then set the fields in the context record that do not depend on
    //  whether the bitmap attribute is resident or not
    //

    RecordAllocationContext->DataScb = DataScb;
    RecordAllocationContext->BytesPerRecord = BytesPerRecord;
    RecordAllocationContext->ExtendGranularity = ExtendGranularity;
    RecordAllocationContext->TruncateGranularity = TruncateGranularity;

    //
    //  Set up our hint fields.
    //

    RecordAllocationContext->LowestDeallocatedIndex = MAXULONG;

    if (DataScb == DataScb->Vcb->MftScb) {

        RecordAllocationContext->StartingHint = FIRST_USER_FILE_NUMBER;

    } else {

        RecordAllocationContext->StartingHint = 0;
    }

    //
    //  Now get a reference to the bitmap record header and then take two
    //  different paths depending if the bitmap attribute is resident or not
    //

    AttributeRecordHeader = NtfsFoundAttribute(BitmapAttribute);

    if (NtfsIsAttributeResident(AttributeRecordHeader)) {

        ASSERTMSG("bitmap must be multiple quadwords", AttributeRecordHeader->Form.Resident.ValueLength % 8 == 0);

        //
        //  For a resident bitmap attribute the bitmap scb field is null and we
        //  set the bitmap size from the value length.  Also we will initialize
        //  our local bitmap variable and determine the number of free bits
        //  current available.
        //
        //

        RecordAllocationContext->BitmapScb = NULL;

        RecordAllocationContext->CurrentBitmapSize = 8 * AttributeRecordHeader->Form.Resident.ValueLength;

        RtlInitializeBitMap( &Bitmap,
                             (PULONG)NtfsAttributeValue( AttributeRecordHeader ),
                             RecordAllocationContext->CurrentBitmapSize );

        RecordAllocationContext->NumberOfFreeBits = RtlNumberOfClearBits( &Bitmap );

        ClearLength = RtlFindLastBackwardRunClear( &Bitmap,
                                                   RecordAllocationContext->CurrentBitmapSize - 1,
                                                   &ClearIndex );

    } else {

        UNICODE_STRING BitmapName;

        BOOLEAN ReturnedExistingScb;
        PBCB BitmapBcb;
        PVOID BitmapBuffer;

        ASSERTMSG("bitmap must be multiple quadwords", ((ULONG)AttributeRecordHeader->Form.Nonresident.FileSize) % 8 == 0);

        //
        //  For a non resident bitmap attribute we better have been given the
        //  record header for the first part and not somthing that has spilled
        //  into multiple segment records
        //

        ASSERT( AttributeRecordHeader->Form.Nonresident.LowestVcn == 0 );

        BitmapBcb = NULL;

        try {

            ULONG StartingByte;

            ULONG BitsThisPage;
            ULONG BytesThisPage;
            ULONG RemainingBytes;

            ULONG ThisClearIndex;
            ULONG ThisClearLength;

            //
            //  Create the bitmap scb for the bitmap attribute
            //

            BitmapName.MaximumLength =
                BitmapName.Length = AttributeRecordHeader->NameLength * sizeof( WCHAR );
            BitmapName.Buffer = Add2Ptr(AttributeRecordHeader, AttributeRecordHeader->NameOffset);

            RecordAllocationContext->BitmapScb = NtfsCreateScb( IrpContext,
                                                                DataScb->Fcb,
                                                                AttributeRecordHeader->TypeCode,
                                                                &BitmapName,
                                                                FALSE,
                                                                &ReturnedExistingScb );

            //
            //  Now determine the bitmap size, for now we'll only take bitmap attributes that are
            //  no more than 16 pages large.
            //

            RecordAllocationContext->CurrentBitmapSize = 8 * ((ULONG)AttributeRecordHeader->Form.Nonresident.FileSize);

            //
            //  Create the stream file if not present.
            //

            if (RecordAllocationContext->BitmapScb->FileObject == NULL) {

                NtfsCreateInternalAttributeStream( IrpContext,
                                                   RecordAllocationContext->BitmapScb,
                                                   TRUE,
                                                   &NtfsInternalUseFile[INITIALIZERECORDALLOCATION_FILE_NUMBER] );
            }

            //
            //  Walk through each page of the bitmap and compute the number of set
            //  bits and the last set bit in the bitmap.
            //

            RecordAllocationContext->NumberOfFreeBits = 0;
            RemainingBytes = (ULONG) AttributeRecordHeader->Form.Nonresident.FileSize;
            StartingByte = 0;
            ClearLength = 0;

            while (TRUE) {

                BytesThisPage = RemainingBytes;

                if (RemainingBytes > PAGE_SIZE) {

                    BytesThisPage = PAGE_SIZE;
                }

                BitsThisPage = BytesThisPage * 8;

                //
                //  Now map the bitmap data, initialize our local bitmap variable and
                //  calculate the number of free bits currently available
                //

                NtfsUnpinBcb( IrpContext, &BitmapBcb );

                NtfsMapStream( IrpContext,
                               RecordAllocationContext->BitmapScb,
                               (LONGLONG)StartingByte,
                               BytesThisPage,
                               &BitmapBcb,
                               &BitmapBuffer );

                RtlInitializeBitMap( &Bitmap,
                                     BitmapBuffer,
                                     BitsThisPage );

                RecordAllocationContext->NumberOfFreeBits += RtlNumberOfClearBits( &Bitmap );

                //
                //  We are interested in remembering the last set bit in this bitmap.
                //  If the bitmap ends with a clear run then the last set bit is
                //  immediately prior to this clear run.  We need to check each page
                //  as we go through the bitmap to see if a clear run ends at the end
                //  of the current page.
                //

                ThisClearLength = RtlFindLastBackwardRunClear( &Bitmap,
                                                               BitsThisPage - 1,
                                                               &ThisClearIndex );

                //
                //  If there is a run and it ends at the end of the page then
                //  either combine with a previous run or remember that this is the
                //  start of the run.
                //

                if ((ThisClearLength != 0) &&
                    ((ThisClearLength + ThisClearIndex) == BitsThisPage)) {

                    //
                    //  If this is the entire page and the previous page ended
                    //  with a clear run then just extend that run.
                    //

                    if ((ThisClearIndex == 0) && (ClearLength != 0)) {

                        ClearLength += ThisClearLength;

                    //
                    //  Otherwise this is a new clear run.  Bias the starting index
                    //  by the bit offset of this page.
                    //

                    } else {

                        ClearLength = ThisClearLength;
                        ClearIndex = ThisClearIndex + (StartingByte * 8);
                    }

                //
                //  This page does not end with a clear run.
                //

                } else {

                    ClearLength = 0;
                }

                //
                //  If we are not at the end of the bitmap then update our
                //  counters.
                //

                if (RemainingBytes != BytesThisPage) {

                    StartingByte += PAGE_SIZE;
                    RemainingBytes -= PAGE_SIZE;

                } else {

                    break;
                }
            }

        } finally {

            DebugUnwind( NtfsInitializeRecordAllocation );

            NtfsUnpinBcb( IrpContext, &BitmapBcb );
        }
    }

    //
    //  With ClearLength and ClearIndex we can now deduce the last set bit in the
    //  bitmap
    //

    if ((ClearLength != 0) && ((ClearLength + ClearIndex) == RecordAllocationContext->CurrentBitmapSize)) {

        RecordAllocationContext->IndexOfLastSetBit = ClearIndex - 1;

    } else {

        RecordAllocationContext->IndexOfLastSetBit = RecordAllocationContext->CurrentBitmapSize - 1;
    }

    DebugTrace( -1, Dbg, ("NtfsInitializeRecordAllocation -> VOID\n") );

    return;
}


VOID
NtfsUninitializeRecordAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PRECORD_ALLOCATION_CONTEXT RecordAllocationContext
    )

/*++

Routine Description:

    This routine is used to uninitialize the record allocation context.

Arguments:

    RecordAllocationContext - Supplies the record allocation context being
        decommissioned.

Return Value:

    None.

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUninitializeRecordAllocation\n") );

    //
    //  And then for safe measure zero out the entire record except for the
    //  the data Scb.
    //

    RtlZeroMemory( &RecordAllocationContext->BitmapScb,
                   sizeof(RECORD_ALLOCATION_CONTEXT) -
                   FIELD_OFFSET( RECORD_ALLOCATION_CONTEXT, BitmapScb ));

    DebugTrace( -1, Dbg, ("NtfsUninitializeRecordAllocation -> VOID\n") );

    return;
}


ULONG
NtfsAllocateRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PRECORD_ALLOCATION_CONTEXT RecordAllocationContext,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    )

/*++

Routine Description:

    This routine is used to allocate a new record for the specified record
    allocation context.

    It will return the index of a free record in the data scb as denoted by
    the bitmap attribute.  If necessary this routine will extend the bitmap
    attribute size (including spilling over to the nonresident case), and
    extend the data scb size.

    On return the record is zeroed.

Arguments:

    RecordAllocationContext - Supplies the record allocation context used
        in this operation

    BitmapAttribute - Supplies the enumeration context for the bitmap
        attribute.  This parameter is ignored if the bitmap attribute is
        non resident, in which case we create an scb for the attribute and
        store a pointer to it in the record allocation context.

Return Value:

    ULONG - Returns the index of the record just allocated, zero based.

--*/

{
    PSCB DataScb;
    LONGLONG DataOffset;

    LONGLONG ClusterCount;

    ULONG BytesPerRecord;
    ULONG ExtendGranularity;
    ULONG TruncateGranularity;

    PULONG CurrentBitmapSize;
    PULONG NumberOfFreeBits;

    PSCB BitmapScb;
    PBCB BitmapBcb;
    RTL_BITMAP Bitmap;
    PUCHAR BitmapBuffer;
    ULONG BitmapOffset;
    ULONG BitmapIndex;
    ULONG BitmapSizeInBytes;
    ULONG BitmapCurrentOffset = 0;
    ULONG BitmapSizeInPages;

    BOOLEAN StuffAdded = FALSE;
    BOOLEAN Rescan;

    ULONG Hint;

    PVCB Vcb;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAllocateRecord\n") );

    //
    //  Synchronize by acquiring the data scb exclusive, as an "end resource".
    //  Then use try-finally to insure we free it up.
    //

    DataScb = RecordAllocationContext->DataScb;
    NtfsAcquireExclusiveScb( IrpContext, DataScb );

    try {

        //
        //  Remember some values for convenience.
        //

        BytesPerRecord = RecordAllocationContext->BytesPerRecord;
        ExtendGranularity = RecordAllocationContext->ExtendGranularity;
        TruncateGranularity = RecordAllocationContext->TruncateGranularity;

        Vcb = DataScb->Vcb;

        //
        //  See if someone made the bitmap nonresident, and we still think
        //  it is resident.  If so, we must uninitialize and insure reinitialization
        //  below.
        //

        if ((RecordAllocationContext->BitmapScb == NULL) &&
            !NtfsIsAttributeResident( NtfsFoundAttribute( BitmapAttribute ))) {

            NtfsUninitializeRecordAllocation( IrpContext,
                                              RecordAllocationContext );

            RecordAllocationContext->CurrentBitmapSize = MAXULONG;
        }

        //
        //  Reinitialize the record context structure if necessary.
        //

        if (RecordAllocationContext->CurrentBitmapSize == MAXULONG) {

            NtfsInitializeRecordAllocation( IrpContext,
                                            DataScb,
                                            BitmapAttribute,
                                            BytesPerRecord,
                                            ExtendGranularity,
                                            TruncateGranularity,
                                            RecordAllocationContext );
        }

        BitmapScb = RecordAllocationContext->BitmapScb;
        CurrentBitmapSize = &RecordAllocationContext->CurrentBitmapSize;
        NumberOfFreeBits = &RecordAllocationContext->NumberOfFreeBits;

        BitmapSizeInBytes = *CurrentBitmapSize / 8;

        Hint = RecordAllocationContext->StartingHint;

        //
        //  We will do different operations based on whether the bitmap is resident or nonresident
        //  The first case we will handle is the resident bitmap.
        //

        if (BitmapScb == NULL) {

            BOOLEAN SizeExtended = FALSE;
            UCHAR NewByte;

            //
            //  Now now initialize the local bitmap variable and hunt for that free bit
            //

            BitmapBuffer = (PUCHAR) NtfsAttributeValue( NtfsFoundAttribute( BitmapAttribute ));

            RtlInitializeBitMap( &Bitmap,
                                 (PULONG)BitmapBuffer,
                                 *CurrentBitmapSize );

            StuffAdded = NtfsAddDeallocatedRecords( Vcb, DataScb, 0, &Bitmap );

            BitmapIndex = RtlFindClearBits( &Bitmap, 1, Hint );

            //
            //  Check if we have found a free record that can be allocated,  If not then extend
            //  the size of the bitmap by 64 bits, and set the index to the bit first bit
            //  of the extension we just added
            //

            if (BitmapIndex == 0xffffffff) {

                union {
                    QUAD Quad;
                    UCHAR Uchar[ sizeof(QUAD) ];
                } ZeroQuadWord;

                *(PLARGE_INTEGER)&(ZeroQuadWord.Uchar)[0] = Li0;

                NtfsChangeAttributeValue( IrpContext,
                                          DataScb->Fcb,
                                          BitmapSizeInBytes,
                                          &(ZeroQuadWord.Uchar)[0],
                                          sizeof( QUAD ),
                                          TRUE,
                                          TRUE,
                                          FALSE,
                                          TRUE,
                                          BitmapAttribute );

                BitmapIndex = *CurrentBitmapSize;
                *CurrentBitmapSize += BITMAP_EXTEND_GRANULARITY;
                *NumberOfFreeBits += BITMAP_EXTEND_GRANULARITY;

                BitmapSizeInBytes += (BITMAP_EXTEND_GRANULARITY / 8);

                SizeExtended = TRUE;

                //
                //  We now know that the byte value we should start with is 0
                //  We cannot safely access the bitmap attribute any more because
                //  it may have moved.
                //

                NewByte = 0;

            } else {

                //
                //  Capture the current value of the byte for the index if we
                //  are not extending.  Notice that we always take this from the
                //  unbiased original bitmap.
                //

                NewByte = BitmapBuffer[ BitmapIndex / 8 ];
            }

            //
            //  Check if we made the Bitmap go non-resident and if so then
            //  we will reinitialize the record allocation context and fall through
            //  to the non-resident case
            //

            if (SizeExtended && !NtfsIsAttributeResident( NtfsFoundAttribute( BitmapAttribute ))) {

                NtfsUninitializeRecordAllocation( IrpContext,
                                                  RecordAllocationContext );

                NtfsInitializeRecordAllocation( IrpContext,
                                                DataScb,
                                                BitmapAttribute,
                                                BytesPerRecord,
                                                ExtendGranularity,
                                                TruncateGranularity,
                                                RecordAllocationContext );

                BitmapScb = RecordAllocationContext->BitmapScb;
                
                ASSERT( BitmapScb != NULL );
                
                //
                //  Snapshot the bitmap in case we modify it later on - we automatically 
                //  snapped the data scb when we acquired it above
                // 

                NtfsSnapshotScb( IrpContext, BitmapScb );

            } else {

                //
                //  Index is now the free bit so set the bit in the bitmap and also change
                //  the byte containing the bit in the attribute.  Be careful to set the
                //  bit in the byte from the *original* bitmap, and not the one we merged
                //  the recently-deallocated bits with.
                //

                ASSERT( !FlagOn( NewByte, BitMask[BitmapIndex % 8]) );

                SetFlag( NewByte, BitMask[BitmapIndex % 8] );

                NtfsChangeAttributeValue( IrpContext,
                                          DataScb->Fcb,
                                          BitmapIndex / 8,
                                          &NewByte,
                                          1,
                                          FALSE,
                                          FALSE,
                                          FALSE,
                                          FALSE,
                                          BitmapAttribute );
            }
        
        } else {

            //
            //  Snapshot the bitmap in case we modify it later on - we automatically 
            //  snapped the data scb when we acquired it above
            // 

            NtfsSnapshotScb( IrpContext, BitmapScb );
        }

        //
        //  Use a loop here to handle the extreme case where extending the allocation
        //  of the volume bitmap causes us to renter this routine recursively.
        //  In that case the top level guy will fail expecting the first bit to
        //  be available in the added clusters.  Instead we will return to the
        //  top of this loop after extending the bitmap and just do our normal
        //  scan.
        //

        while (BitmapScb != NULL) {

            ULONG SizeToPin;
            ULONG HoleIndex;

            BitmapBcb = NULL;
            Rescan = FALSE;
            HoleIndex = 0;

            try {

                if (!FlagOn( BitmapScb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                    NtfsUpdateScbFromAttribute( IrpContext, BitmapScb, NULL );
                }

                //
                //  Snapshot the Scb values in case we change any of them.
                //

                NtfsSnapshotScb( IrpContext, BitmapScb );

                //
                //  Create the stream file if not present.
                //

                if (BitmapScb->FileObject == NULL) {

                    NtfsCreateInternalAttributeStream( IrpContext,
                                                       BitmapScb,
                                                       FALSE,
                                                       &NtfsInternalUseFile[DEALLOCATERECORD_FILE_NUMBER] );
                }

                //
                //  Remember the starting offset for the page containing the hint.
                //

                BitmapCurrentOffset = (Hint / 8) & ~(PAGE_SIZE - 1);
                Hint &= (BITS_PER_PAGE - 1);

                BitmapSizeInPages = (ULONG) ROUND_TO_PAGES( BitmapSizeInBytes );

                //
                //  Loop for the size of the bitmap plus one page, so that we will
                //  retry the initial page once starting from a hint offset of 0.
                //

                for (BitmapOffset = 0;
                     BitmapOffset <= BitmapSizeInPages;
                     BitmapOffset += PAGE_SIZE, BitmapCurrentOffset += PAGE_SIZE) {

                    ULONG LocalHint;

                    //
                    //  If our current position is past the end of the bitmap
                    //  then go to the beginning of the bitmap.
                    //

                    if (BitmapCurrentOffset >= BitmapSizeInBytes) {

                        BitmapCurrentOffset = 0;
                    }

                    //
                    //  If this is the Mft and there are more than the system
                    //  files in the first cluster of the Mft then move past
                    //  the first cluster.
                    //

                    if ((BitmapCurrentOffset == 0) &&
                        (DataScb == Vcb->MftScb) &&
                        (Vcb->FileRecordsPerCluster > FIRST_USER_FILE_NUMBER) &&
                        (Hint < Vcb->FileRecordsPerCluster)) {

                        Hint = Vcb->FileRecordsPerCluster;
                    }

                    //
                    //  Calculate the size to read from this point to the end of
                    //  bitmap, or a page, whichever is less.
                    //

                    SizeToPin = BitmapSizeInBytes - BitmapCurrentOffset;

                    if (SizeToPin > PAGE_SIZE) { SizeToPin = PAGE_SIZE; }

                    //
                    //  Unpin any Bcb from a previous loop.
                    //

                    if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE; }

                    NtfsUnpinBcb( IrpContext, &BitmapBcb );

                    //
                    //  Read the desired bitmap page.
                    //

                    NtfsPinStream( IrpContext,
                                   BitmapScb,
                                   (LONGLONG)BitmapCurrentOffset,
                                   SizeToPin,
                                   &BitmapBcb,
                                   &BitmapBuffer );

                    //
                    //  Initialize the bitmap and search for a free bit.
                    //

                    RtlInitializeBitMap( &Bitmap, (PULONG) BitmapBuffer, SizeToPin * 8 );

                    StuffAdded = NtfsAddDeallocatedRecords( Vcb,
                                                            DataScb,
                                                            BitmapCurrentOffset * 8,
                                                            &Bitmap );

                    //
                    //  We make a loop here to test whether the index found is
                    //  within an Mft hole.  We will always use a hole last.
                    //

                    LocalHint = Hint;

                    while (TRUE) {

                        BitmapIndex = RtlFindClearBits( &Bitmap, 1, LocalHint );

                        //
                        //  If this is the Mft Scb then check if this is a hole.
                        //

                        if ((BitmapIndex != 0xffffffff) &&
                            (DataScb == Vcb->MftScb)) {

                            ULONG ThisIndex;
                            ULONG HoleCount;

                            ThisIndex = BitmapIndex + (BitmapCurrentOffset * 8);

                            if (NtfsIsMftIndexInHole( IrpContext,
                                                      Vcb,
                                                      ThisIndex,
                                                      &HoleCount )) {

                                //
                                //  There is a hole.  Save this index if we haven't
                                //  already saved one.  If we can't find an index
                                //  not part of a hole we will use this instead of
                                //  extending the file.
                                //

                                if (HoleIndex == 0) {

                                    HoleIndex = ThisIndex;
                                }

                                //
                                //  Now update the hint and try this page again
                                //  unless the reaches to the end of the page.
                                //

                                if (BitmapIndex + HoleCount < SizeToPin * 8) {

                                    //
                                    //  Bias the bitmap with these Mft holes
                                    //  so the bitmap package doesn't see
                                    //  them if it rescans from the
                                    //  start of the page.
                                    //

                                    if (!StuffAdded) {

                                        PVOID NewBuffer;

                                        NewBuffer = NtfsAllocatePool(PagedPool, SizeToPin );
                                        RtlCopyMemory( NewBuffer, Bitmap.Buffer, SizeToPin );
                                        Bitmap.Buffer = NewBuffer;
                                        StuffAdded = TRUE;
                                    }

                                    RtlSetBits( &Bitmap,
                                                BitmapIndex,
                                                HoleCount );

                                    LocalHint = BitmapIndex + HoleCount;
                                    continue;
                                }

                                //
                                //  Store a -1 in Index to show we don't have
                                //  anything yet.
                                //

                                BitmapIndex = 0xffffffff;
                            }
                        }

                        break;
                    }

                    //
                    //  If we found something, then leave the loop.
                    //

                    if (BitmapIndex != 0xffffffff) {

                        break;
                    }

                    //
                    //  If we get here, we could not find anything in the page of
                    //  the hint, so clear out the page offset from the hint.
                    //

                    Hint = 0;
                }

                //
                //  Now check if we have located a record that can be allocated,  If not then extend
                //  the size of the bitmap by 64 bits.
                //

                if (BitmapIndex == 0xffffffff) {

                    //
                    //  Cleanup from previous loop.
                    //

                    if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE; }

                    NtfsUnpinBcb( IrpContext, &BitmapBcb );

                    //
                    //  If we have a hole index it means that we found a free record but
                    //  it exists in a hole.  Let's go back to this page and set up
                    //  to fill in the hole.  We will do an unsafe test of the
                    //  defrag permitted flag.  This is OK here because once set it
                    //  will only go to the non-set state in order to halt
                    //  future defragging.
                    //

                    if ((HoleIndex != 0) && FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED )) {

                        //
                        //  Start by filling this hole.
                        //

                        NtfsCheckRecordStackUsage( IrpContext );
                        NtfsFillMftHole( IrpContext, Vcb, HoleIndex );

                        //
                        //  Since filling the Mft hole may cause us to allocate
                        //  a bit we will go back to the start of the routine
                        //  and scan starting from the hole we just filled in.
                        //

                        Hint = HoleIndex;
                        Rescan = TRUE;
                        try_return( NOTHING );

                    } else {

                        //
                        //  Allocate the first bit past the end of the bitmap.
                        //

                        BitmapIndex = *CurrentBitmapSize & (BITS_PER_PAGE - 1);

                        //
                        //  Now advance the sizes and calculate the size in bytes to
                        //  read.
                        //

                        *CurrentBitmapSize += BITMAP_EXTEND_GRANULARITY;
                        *NumberOfFreeBits += BITMAP_EXTEND_GRANULARITY;

                        //
                        //  Calculate the size to read from this point to the end of
                        //  bitmap.
                        //

                        BitmapSizeInBytes += BITMAP_EXTEND_GRANULARITY / 8;

                        BitmapCurrentOffset = BitmapScb->Header.FileSize.LowPart & ~(PAGE_SIZE - 1);

                        SizeToPin = BitmapSizeInBytes - BitmapCurrentOffset;

                        //
                        //  Check for allocation first.
                        //

                        if (BitmapScb->Header.AllocationSize.LowPart < BitmapSizeInBytes) {

                            //
                            //  Calculate number of clusters to next page boundary, and allocate
                            //  that much.
                            //

                            ClusterCount = ((BitmapSizeInBytes + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1));

                            ClusterCount = LlClustersFromBytes( Vcb,
                                                                ((ULONG) ClusterCount - BitmapScb->Header.AllocationSize.LowPart) );

                            NtfsCheckRecordStackUsage( IrpContext );
                            NtfsAddAllocation( IrpContext,
                                               BitmapScb->FileObject,
                                               BitmapScb,
                                               LlClustersFromBytes( Vcb,
                                                                    BitmapScb->Header.AllocationSize.QuadPart ),
                                               ClusterCount,
                                               FALSE,
                                               NULL );
                        }

                        //
                        //  Tell the cache manager about the new file size.
                        //

                        BitmapScb->Header.FileSize.QuadPart = BitmapSizeInBytes;

                        CcSetFileSizes( BitmapScb->FileObject,
                                        (PCC_FILE_SIZES)&BitmapScb->Header.AllocationSize );

                        if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE; }

                        //
                        //  Read the desired bitmap page.
                        //

                        NtfsPinStream( IrpContext,
                                       BitmapScb,
                                       (LONGLONG) BitmapCurrentOffset,
                                       SizeToPin,
                                       &BitmapBcb,
                                       &BitmapBuffer );

                        //
                        //  If we have just moved to the next page of the bitmap then
                        //  set this page dirty so it doesn't leave memory while we
                        //  twiddle valid data length.  Otherwise it will be reread after
                        //  we advance valid data and we will get garbage data from the
                        //  disk.
                        //

                        if (FlagOn( BitmapSizeInBytes, PAGE_SIZE - 1 ) <= BITMAP_EXTEND_GRANULARITY / 8) {

                            *((volatile ULONG *) BitmapBuffer) = *((PULONG) BitmapBuffer);
                            CcSetDirtyPinnedData( BitmapBcb, NULL );
                        }

                        //
                        //  Initialize the bitmap.
                        //

                        RtlInitializeBitMap( &Bitmap, (PULONG) BitmapBuffer, SizeToPin * 8 );

                        //
                        //  Now look up a free bit in this page.  We don't trust
                        //  the index we already had since growing the MftBitmap
                        //  allocation may have caused another bit in the bitmap
                        //  to be set.
                        //

                        BitmapIndex = RtlFindClearBits( &Bitmap, 1, BitmapIndex );

                        //
                        //  Update the ValidDataLength, now that we have read (and possibly
                        //  zeroed) the page.
                        //

                        BitmapScb->Header.ValidDataLength.QuadPart = BitmapSizeInBytes;

                        NtfsWriteFileSizes( IrpContext,
                                            BitmapScb,
                                            &BitmapScb->Header.ValidDataLength.QuadPart,
                                            TRUE,
                                            TRUE,
                                            TRUE );
                    }
                }

                //
                //  We can only make this check if it is not restart, because we have
                //  no idea whether the update is applied or not.  Raise corrupt if
                //  the bits are not clear to prevent double allocation.
                //

                if (!RtlAreBitsClear( &Bitmap, BitmapIndex, 1 )) {

                    ASSERTMSG("Cannot set bits that are not clear ", FALSE );
                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                //
                //  Set the bit by calling the same routine used at restart.
                //  But first check if we should revert back to the orginal bitmap
                //  buffer.
                //

                if (StuffAdded) {

                    NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE;

                    Bitmap.Buffer = (PULONG) BitmapBuffer;
                }

                //
                //  Now log this change as well.
                //

                {
                    BITMAP_RANGE BitmapRange;

                    BitmapRange.BitMapOffset = BitmapIndex;
                    BitmapRange.NumberOfBits = 1;

                    (VOID) NtfsWriteLog( IrpContext,
                                         BitmapScb,
                                         BitmapBcb,
                                         SetBitsInNonresidentBitMap,
                                         &BitmapRange,
                                         sizeof(BITMAP_RANGE),
                                         ClearBitsInNonresidentBitMap,
                                         &BitmapRange,
                                         sizeof(BITMAP_RANGE),
                                         BitmapCurrentOffset,
                                         0,
                                         0,
                                         SizeToPin );

                    NtfsRestartSetBitsInBitMap( IrpContext,
                                                &Bitmap,
                                                BitmapIndex,
                                                1 );
                }

            try_exit:  NOTHING;
            } finally {

                DebugUnwind( NtfsAllocateRecord );

                //
                //  Reinitialize the context on any error.
                //

                if (AbnormalTermination()) {
                    RecordAllocationContext->CurrentBitmapSize = MAXULONG;
                }

                if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE; }

                NtfsUnpinBcb( IrpContext, &BitmapBcb );
            }

            //
            //  If we added Mft allocation then go to the top of the loop.
            //

            if (Rescan) { continue; }

            //
            //  The Index at this point is actually relative, so convert it to absolute
            //  before rejoining common code.
            //

            BitmapIndex += (BitmapCurrentOffset * 8);

            //
            //  Always break out in the normal case.
            //

            break;
        }

        //
        //  Now that we've located an index we can subtract the number of free bits in the bitmap
        //

        *NumberOfFreeBits -= 1;

        //
        //  Check if we need to extend the data stream.
        //

        DataOffset = UInt32x32To64( BitmapIndex + 1, BytesPerRecord );

        //
        //  Now check if we are extending the file.  We update the file size and
        //  valid data now.
        //

        if (DataOffset > DataScb->Header.FileSize.QuadPart) {

            //
            //  Check for allocation first.
            //

            if (DataOffset > DataScb->Header.AllocationSize.QuadPart) {

                //
                //  We want to allocate up to the next extend granularity
                //  boundary.
                //

                ClusterCount = UInt32x32To64( (BitmapIndex + ExtendGranularity) & ~(ExtendGranularity - 1),
                                              BytesPerRecord );

                ClusterCount -= DataScb->Header.AllocationSize.QuadPart;
                ClusterCount = LlClustersFromBytesTruncate( Vcb, ClusterCount );

                NtfsCheckRecordStackUsage( IrpContext );
                NtfsAddAllocation( IrpContext,
                                   DataScb->FileObject,
                                   DataScb,
                                   LlClustersFromBytes( Vcb,
                                                        DataScb->Header.AllocationSize.QuadPart ),
                                   ClusterCount,
                                   FALSE,
                                   NULL );
            }

            DataScb->Header.FileSize.QuadPart = DataOffset;
            DataScb->Header.ValidDataLength.QuadPart = DataOffset;

            NtfsWriteFileSizes( IrpContext,
                                DataScb,
                                &DataScb->Header.ValidDataLength.QuadPart,
                                TRUE,
                                TRUE,
                                TRUE );

            //
            //  Tell the cache manager about the new file size.
            //

            CcSetFileSizes( DataScb->FileObject,
                            (PCC_FILE_SIZES)&DataScb->Header.AllocationSize );

        //
        //  If we didn't extend the file then we have used a free file record in the file.
        //  Update our bookeeping count for free file records.
        //

        } else if (DataScb == Vcb->MftScb) {

            DataScb->ScbType.Mft.FreeRecordChange -= 1;
            Vcb->MftFreeRecords -= 1;
        }

        //
        //  Now determine if we extended the index of the last set bit
        //

        if ((LONG)BitmapIndex > RecordAllocationContext->IndexOfLastSetBit) {

            RecordAllocationContext->IndexOfLastSetBit = BitmapIndex;
        }

    } finally {

        if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); }

        NtfsReleaseScb( IrpContext, DataScb );
    }

    //
    //  Update our hint with this value.
    //

    RecordAllocationContext->StartingHint = BitmapIndex;

    //
    //  We shouldn't allocate within the same byte as the reserved index for
    //  the Mft.
    //

    ASSERT( (DataScb != DataScb->Vcb->MftScb) ||
            ((BitmapIndex & ~7) != (DataScb->ScbType.Mft.ReservedIndex & ~7)) );

    DebugTrace( -1, Dbg, ("NtfsAllocateRecord -> %08lx\n", BitmapIndex) );

    return BitmapIndex;
}


VOID
NtfsDeallocateRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PRECORD_ALLOCATION_CONTEXT RecordAllocationContext,
    IN ULONG Index,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    )

/*++

Routine Description:

    This routine is used to deallocate a record from the specified record
    allocation context.

    If necessary this routine will also shrink the bitmap attribute and
    the data scb (according to the truncation granularity used to initialize
    the allocation context).

Arguments:

    RecordAllocationContext - Supplies the record allocation context used
        in this operation

    Index - Supplies the index of the record to deallocate, zero based.

    BitmapAttribute - Supplies the enumeration context for the bitmap
        attribute.  This parameter is ignored if the bitmap attribute is
        non resident, in which case we create an scb for the attribute and
        store a pointer to it in the record allocation context.

Return Value:

    None.

--*/

{
    PSCB DataScb;
    IO_STATUS_BLOCK Iosb;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );

    DebugTrace( +1, Dbg, ("NtfsDeallocateRecord\n") );

    //
    //  Synchronize by acquiring the data scb exclusive, as an "end resource".
    //  Then use try-finally to insure we free it up.
    //

    DataScb = RecordAllocationContext->DataScb;
    NtfsAcquireExclusiveScb( IrpContext, DataScb );

    try {

        PVCB Vcb;
        PSCB BitmapScb;

        RTL_BITMAP Bitmap;

        PLONG IndexOfLastSetBit;
        ULONG BytesPerRecord;
        ULONG TruncateGranularity;

        ULONG ClearIndex;
        ULONG BitmapOffset = 0;

        Vcb = DataScb->Vcb;

        {
            ULONG ExtendGranularity;

            //
            //  Remember the current values in the record context structure.
            //

            BytesPerRecord = RecordAllocationContext->BytesPerRecord;
            TruncateGranularity = RecordAllocationContext->TruncateGranularity;
            ExtendGranularity = RecordAllocationContext->ExtendGranularity;

            //
            //  See if someone made the bitmap nonresident, and we still think
            //  it is resident.  If so, we must uninitialize and insure reinitialization
            //  below.
            //

            if ((RecordAllocationContext->BitmapScb == NULL)
                && !NtfsIsAttributeResident(NtfsFoundAttribute(BitmapAttribute))) {

                NtfsUninitializeRecordAllocation( IrpContext,
                                                  RecordAllocationContext );

                RecordAllocationContext->CurrentBitmapSize = MAXULONG;
            }

            //
            //  Reinitialize the record context structure if necessary.
            //

            if (RecordAllocationContext->CurrentBitmapSize == MAXULONG) {

                NtfsInitializeRecordAllocation( IrpContext,
                                                DataScb,
                                                BitmapAttribute,
                                                BytesPerRecord,
                                                ExtendGranularity,
                                                TruncateGranularity,
                                                RecordAllocationContext );
            }
        }

        BitmapScb = RecordAllocationContext->BitmapScb;
        IndexOfLastSetBit = &RecordAllocationContext->IndexOfLastSetBit;

        //
        //  We will do different operations based on whether the bitmap is resident or nonresident
        //  The first case will handle the resident bitmap
        //

        if (BitmapScb == NULL) {

            UCHAR NewByte;

            //
            //  Initialize the local bitmap
            //

            RtlInitializeBitMap( &Bitmap,
                                 (PULONG)NtfsAttributeValue( NtfsFoundAttribute( BitmapAttribute )),
                                 RecordAllocationContext->CurrentBitmapSize );

            //
            //  And clear the indicated bit, and also change the byte containing the bit in the
            //  attribute
            //

            NewByte = ((PUCHAR)Bitmap.Buffer)[ Index / 8 ];

            ASSERT( FlagOn( NewByte, BitMask[Index % 8]) );

            ClearFlag( NewByte, BitMask[Index % 8] );

            NtfsChangeAttributeValue( IrpContext,
                                      DataScb->Fcb,
                                      Index / 8,
                                      &NewByte,
                                      1,
                                      FALSE,
                                      FALSE,
                                      FALSE,
                                      FALSE,
                                      BitmapAttribute );

            //
            //  Now if the bit set just cleared is the same as the index for the last set bit
            //  then we must compute a new last set bit
            //

            if (Index == (ULONG)*IndexOfLastSetBit) {

                RtlFindLastBackwardRunClear( &Bitmap, Index, &ClearIndex );
            }

        } else {

            PBCB BitmapBcb = NULL;

            try {

                ULONG RelativeIndex;
                ULONG SizeToPin;

                PVOID BitmapBuffer;

                //
                //  Snapshot the Scb values in case we change any of them.
                //

                if (!FlagOn( BitmapScb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                    NtfsUpdateScbFromAttribute( IrpContext, BitmapScb, NULL );
                }

                NtfsSnapshotScb( IrpContext, BitmapScb );

                //
                //  Create the stream file if not present.
                //

                if (BitmapScb->FileObject == NULL) {

                    NtfsCreateInternalAttributeStream( IrpContext,
                                                       BitmapScb,
                                                       FALSE,
                                                       &NtfsInternalUseFile[DEALLOCATERECORD_FILE_NUMBER] );
                }

                //
                //  Calculate offset and relative index of the bit we will deallocate,
                //  from the nearest page boundary.
                //

                BitmapOffset = Index /8 & ~(PAGE_SIZE - 1);
                RelativeIndex = Index & (BITS_PER_PAGE - 1);

                //
                //  Calculate the size to read from this point to the end of
                //  bitmap.
                //

                SizeToPin = (RecordAllocationContext->CurrentBitmapSize / 8) - BitmapOffset;

                if (SizeToPin > PAGE_SIZE) {

                    SizeToPin = PAGE_SIZE;
                }

                NtfsPinStream( IrpContext,
                               BitmapScb,
                               BitmapOffset,
                               SizeToPin,
                               &BitmapBcb,
                               &BitmapBuffer );

                RtlInitializeBitMap( &Bitmap, BitmapBuffer, SizeToPin * 8 );

                //
                //  We can only make this check if it is not restart, because we have
                //  no idea whether the update is applied or not.  Raise corrupt if
                //  we are trying to clear bits which aren't set.
                //

                if (!RtlAreBitsSet( &Bitmap, RelativeIndex, 1 )) {

                    ASSERTMSG("Cannot clear bits that are not set ", FALSE );
                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                //
                //  Now log this change as well.
                //

                {
                    BITMAP_RANGE BitmapRange;

                    BitmapRange.BitMapOffset = RelativeIndex;
                    BitmapRange.NumberOfBits = 1;

                    (VOID) NtfsWriteLog( IrpContext,
                                         BitmapScb,
                                         BitmapBcb,
                                         ClearBitsInNonresidentBitMap,
                                         &BitmapRange,
                                         sizeof(BITMAP_RANGE),
                                         SetBitsInNonresidentBitMap,
                                         &BitmapRange,
                                         sizeof(BITMAP_RANGE),
                                         BitmapOffset,
                                         0,
                                         0,
                                         SizeToPin );
                }

                //
                //  Clear the bit by calling the same routine used at restart.
                //

                NtfsRestartClearBitsInBitMap( IrpContext,
                                              &Bitmap,
                                              RelativeIndex,
                                              1 );

                //
                //  Now if the bit set just cleared is the same as the index for the last set bit
                //  then we must compute a new last set bit
                //

                if (Index == (ULONG)*IndexOfLastSetBit) {

                    ULONG ClearLength;

                    ClearLength = RtlFindLastBackwardRunClear( &Bitmap, RelativeIndex, &ClearIndex );

                    //
                    //  If the last page of the bitmap is clear, then loop to
                    //  find the first set bit in the previous page(s).
                    //  When we reach the first page then we exit.  The ClearBit
                    //  value will be 0.
                    //

                    while ((ClearLength == (RelativeIndex + 1)) &&
                           (BitmapOffset != 0)) {

                        BitmapOffset -= PAGE_SIZE;
                        RelativeIndex = BITS_PER_PAGE - 1;

                        NtfsUnpinBcb( IrpContext, &BitmapBcb );


                        NtfsMapStream( IrpContext,
                                       BitmapScb,
                                       BitmapOffset,
                                       PAGE_SIZE,
                                       &BitmapBcb,
                                       &BitmapBuffer );

                        RtlInitializeBitMap( &Bitmap, BitmapBuffer, BITS_PER_PAGE );

                        ClearLength = RtlFindLastBackwardRunClear( &Bitmap, RelativeIndex, &ClearIndex );
                    }
                }

            } finally {

                DebugUnwind( NtfsDeallocateRecord );

                NtfsUnpinBcb( IrpContext, &BitmapBcb );
            }
        }

        RecordAllocationContext->NumberOfFreeBits += 1;

        //
        //  Now decide if we need to truncate the allocation.  First check if we need to
        //  set the last set bit index and then check if the new last set bit index is
        //  small enough that we should now truncate the allocation.  We will truncate
        //  if the last set bit index plus the trucate granularity is smaller than
        //  the current number of records in the data scb.
        //
        //  ****    For now, we will not truncate the Mft, since we do not synchronize
        //          reads and writes, and a truncate can collide with the Lazy Writer.
        //

        if (Index == (ULONG)*IndexOfLastSetBit) {

            *IndexOfLastSetBit = ClearIndex - 1 + (BitmapOffset * 8);

            if ((DataScb != Vcb->MftScb) &&
                (DataScb->Header.AllocationSize.QuadPart >
                   Int32x32To64( *IndexOfLastSetBit + 1 + TruncateGranularity, BytesPerRecord ))) {

                VCN StartingVcn;
                LONGLONG EndOfIndexOffset;
                LONGLONG TruncatePoint;

                //
                //  We can get into a situation where there is so much extra allocation that
                //  we can't delete it without overflowing the log file.  We can't perform
                //  checkpoints in this path so we will forget about truncating in
                //  this path unless this is the first truncate of the data scb.  We
                //  only deallocate a small piece of the allocation.
                //

                TruncatePoint =
                EndOfIndexOffset = Int32x32To64( *IndexOfLastSetBit + 1, BytesPerRecord );

                if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_EXCESS_LOG_FULL )) {

                    //
                    //  Use a fudge factor of 8 to allow for the overused bits in
                    //  the snapshot allocation field.
                    //

                    if (DataScb->Header.AllocationSize.QuadPart + 8 >= DataScb->ScbSnapshot->AllocationSize) {

                        TruncatePoint = DataScb->Header.AllocationSize.QuadPart - (MAXIMUM_RUNS_AT_ONCE * Vcb->BytesPerCluster);

                        if (TruncatePoint < EndOfIndexOffset) {

                            TruncatePoint = EndOfIndexOffset;
                        }

                    } else {

                        TruncatePoint = DataScb->Header.AllocationSize.QuadPart;
                    }
                }

                //
                //  Force deleted piece to flush first so dirty page dumps are
                //  accurate. This is only neccessary for indexes
                //

                if (DataScb->AttributeTypeCode == $INDEX_ALLOCATION ) {

                    ASSERT( DataScb->Header.PagingIoResource == NULL );

                    CcFlushCache( &DataScb->NonpagedScb->SegmentObject, (PLARGE_INTEGER)&TruncatePoint, (ULONG)(DataScb->Header.FileSize.QuadPart - TruncatePoint), &Iosb );
                    NtfsNormalizeAndCleanupTransaction( IrpContext, &Iosb.Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );
                }



                StartingVcn = LlClustersFromBytes( Vcb, TruncatePoint );

                NtfsDeleteAllocation( IrpContext,
                                      DataScb->FileObject,
                                      DataScb,
                                      StartingVcn,
                                      MAXLONGLONG,
                                      TRUE,
                                      FALSE );

                //
                //  Now truncate the file sizes to the end of the last allocated record.
                //

                DataScb->Header.ValidDataLength.QuadPart =
                DataScb->Header.FileSize.QuadPart = EndOfIndexOffset;

                NtfsWriteFileSizes( IrpContext,
                                    DataScb,
                                    &DataScb->Header.ValidDataLength.QuadPart,
                                    FALSE,
                                    TRUE,
                                    TRUE );

                //
                //  Tell the cache manager about the new file size.
                //

                CcSetFileSizes( DataScb->FileObject,
                                (PCC_FILE_SIZES)&DataScb->Header.AllocationSize );

                //
                //  We have truncated the index stream.  Update the change count
                //  so that we won't trust any cached index entry information.
                //

                DataScb->ScbType.Index.ChangeCount += 1;
            }
        }

        //
        //  As our final task we need to add this index to the recently deallocated
        //  queues for the Scb and the Irp Context.  First scan through the IrpContext queue
        //  looking for a matching Scb.  I do don't find one then we allocate a new one and insert
        //  it in the appropriate queues and lastly we add our index to the entry
        //

        {
            PDEALLOCATED_RECORDS DeallocatedRecords;
            PLIST_ENTRY Links;

            //
            //  After the following loop either we've found an existing record in the irp context
            //  queue for the appropriate scb or deallocated records is null and we know we need
            //  to create a record
            //

            DeallocatedRecords = NULL;
            for (Links = IrpContext->RecentlyDeallocatedQueue.Flink;
                 Links != &IrpContext->RecentlyDeallocatedQueue;
                 Links = Links->Flink) {

                DeallocatedRecords = CONTAINING_RECORD( Links, DEALLOCATED_RECORDS, IrpContextLinks );

                if (DeallocatedRecords->Scb == DataScb) {

                    break;
                }

                DeallocatedRecords = NULL;
            }

            //
            //  If we need to create a new record then allocate a record and insert it in both queues
            //  and initialize its other fields
            //

            if (DeallocatedRecords == NULL) {

                DeallocatedRecords = (PDEALLOCATED_RECORDS)ExAllocateFromPagedLookasideList( &NtfsDeallocatedRecordsLookasideList );
                InsertTailList( &DataScb->ScbType.Index.RecentlyDeallocatedQueue, &DeallocatedRecords->ScbLinks );
                InsertTailList( &IrpContext->RecentlyDeallocatedQueue, &DeallocatedRecords->IrpContextLinks );
                DeallocatedRecords->Scb = DataScb;
                DeallocatedRecords->NumberOfEntries = DEALLOCATED_RECORD_ENTRIES;
                DeallocatedRecords->NextFreeEntry = 0;
            }

            //
            //  At this point deallocated records points to a record that we are to fill in.
            //  We need to check whether there is space to add this entry.  Otherwise we need
            //  to allocate a larger deallocated record structure from pool.
            //

            if (DeallocatedRecords->NextFreeEntry == DeallocatedRecords->NumberOfEntries) {

                PDEALLOCATED_RECORDS NewDeallocatedRecords;
                ULONG BytesInEntryArray;

                //
                //  Double the number of entries in the current structure and
                //  allocate directly from pool.
                //

                BytesInEntryArray = 2 * DeallocatedRecords->NumberOfEntries * sizeof( ULONG );
                NewDeallocatedRecords = NtfsAllocatePool( PagedPool,
                                                           DEALLOCATED_RECORDS_HEADER_SIZE + BytesInEntryArray );
                RtlZeroMemory( NewDeallocatedRecords, DEALLOCATED_RECORDS_HEADER_SIZE + BytesInEntryArray );

                //
                //  Initialize the structure by copying the existing structure.  Then
                //  update the number of entries field.
                //

                RtlCopyMemory( NewDeallocatedRecords,
                               DeallocatedRecords,
                               DEALLOCATED_RECORDS_HEADER_SIZE + (BytesInEntryArray / 2) );

                NewDeallocatedRecords->NumberOfEntries = DeallocatedRecords->NumberOfEntries * 2;

                //
                //  Remove the previous structure from the list and insert the new structure.
                //

                RemoveEntryList( &DeallocatedRecords->ScbLinks );
                RemoveEntryList( &DeallocatedRecords->IrpContextLinks );

                InsertTailList( &DataScb->ScbType.Index.RecentlyDeallocatedQueue,
                                &NewDeallocatedRecords->ScbLinks );
                InsertTailList( &IrpContext->RecentlyDeallocatedQueue,
                                &NewDeallocatedRecords->IrpContextLinks );

                //
                //  Deallocate the previous structure and use the new structure in its place.
                //

                if (DeallocatedRecords->NumberOfEntries == DEALLOCATED_RECORD_ENTRIES) {

                    ExFreeToPagedLookasideList( &NtfsDeallocatedRecordsLookasideList, DeallocatedRecords );

                } else {

                    NtfsFreePool( DeallocatedRecords );
                }

                DeallocatedRecords = NewDeallocatedRecords;
            }

            ASSERT( DeallocatedRecords->NextFreeEntry < DeallocatedRecords->NumberOfEntries );

            DeallocatedRecords->Index[DeallocatedRecords->NextFreeEntry] = Index;
            DeallocatedRecords->NextFreeEntry += 1;
        }

    } finally {

        NtfsReleaseScb( IrpContext, DataScb );
    }

    //
    //  Check if this is the lowest index we've deallocated.  It will be a future starting
    //  hint if so.
    //

    if (RecordAllocationContext->LowestDeallocatedIndex > Index) {

        RecordAllocationContext->LowestDeallocatedIndex = Index;
    }

    DebugTrace( -1, Dbg, ("NtfsDeallocateRecord -> VOID\n") );

    return;
}


VOID
NtfsReserveMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    )

/*++

Routine Description:

    This routine reserves a record, without actually allocating it, so that the
    record may be allocated later via NtfsAllocateReservedRecord.  This support
    is used, for example, to reserve a record for describing Mft extensions in
    the current Mft mapping.  Only one record may be reserved at a time.

    Note that even though the reserved record number is returned, it may not
    be used until it is allocated.

Arguments:

    Vcb - This is the Vcb for the volume.  We update flags in the Vcb on
        completion of this operation.

    BitmapAttribute - Supplies the enumeration context for the bitmap
        attribute.  This parameter is ignored if the bitmap attribute is
        non resident, in which case we create an scb for the attribute and
        store a pointer to it in the record allocation context.

Return Value:

    None - We update the Vcb and MftScb during this operation.

--*/

{
    PSCB DataScb;

    RTL_BITMAP Bitmap;

    BOOLEAN StuffAdded = FALSE;
    PBCB BitmapBcb = NULL;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReserveMftRecord\n") );

    //
    //  Synchronize by acquiring the data scb exclusive, as an "end resource".
    //  Then use try-finally to insure we free it up.
    //

    DataScb = Vcb->MftScb;
    NtfsAcquireExclusiveScb( IrpContext, DataScb );

    try {

        PSCB BitmapScb;
        PULONG CurrentBitmapSize;
        ULONG BitmapSizeInBytes;
        LONGLONG EndOfIndexOffset;
        LONGLONG ClusterCount;

        ULONG Index;
        ULONG BitOffset;
        PVOID BitmapBuffer;
        UCHAR BitmapByte = 0;

        ULONG SizeToPin;

        ULONG BitmapCurrentOffset;

        //
        //  See if someone made the bitmap nonresident, and we still think
        //  it is resident.  If so, we must uninitialize and insure reinitialization
        //  below.
        //

        {
            ULONG BytesPerRecord = DataScb->ScbType.Index.RecordAllocationContext.BytesPerRecord;
            ULONG ExtendGranularity = DataScb->ScbType.Index.RecordAllocationContext.ExtendGranularity;

            if ((DataScb->ScbType.Index.RecordAllocationContext.BitmapScb == NULL) &&
                !NtfsIsAttributeResident( NtfsFoundAttribute( BitmapAttribute ))) {

                NtfsUninitializeRecordAllocation( IrpContext,
                                                  &DataScb->ScbType.Index.RecordAllocationContext );

                DataScb->ScbType.Index.RecordAllocationContext.CurrentBitmapSize = MAXULONG;
            }

            //
            //  Reinitialize the record context structure if necessary.
            //

            if (DataScb->ScbType.Index.RecordAllocationContext.CurrentBitmapSize == MAXULONG) {

                NtfsInitializeRecordAllocation( IrpContext,
                                                DataScb,
                                                BitmapAttribute,
                                                BytesPerRecord,
                                                ExtendGranularity,
                                                ExtendGranularity,
                                                &DataScb->ScbType.Index.RecordAllocationContext );
            }
        }

        BitmapScb = DataScb->ScbType.Index.RecordAllocationContext.BitmapScb;
        CurrentBitmapSize = &DataScb->ScbType.Index.RecordAllocationContext.CurrentBitmapSize;
        BitmapSizeInBytes = *CurrentBitmapSize / 8;

        //
        //  Snapshot the bitmap before possibly modifying it - we own it exclusive through
        //  the data scb since they share the same resource but have not snapped it before
        //  

        NtfsSnapshotScb( IrpContext, BitmapScb );

        //
        //  Loop through the entire bitmap.  We always start from the first user
        //  file number as our starting point.
        //

        BitOffset = FIRST_USER_FILE_NUMBER;

        for (BitmapCurrentOffset = 0;
             BitmapCurrentOffset < BitmapSizeInBytes;
             BitmapCurrentOffset += PAGE_SIZE) {

            //
            //  Calculate the size to read from this point to the end of
            //  bitmap, or a page, whichever is less.
            //

            SizeToPin = BitmapSizeInBytes - BitmapCurrentOffset;

            if (SizeToPin > PAGE_SIZE) { SizeToPin = PAGE_SIZE; }

            //
            //  Unpin any Bcb from a previous loop.
            //

            if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE; }

            NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Read the desired bitmap page.
            //

            NtfsMapStream( IrpContext,
                           BitmapScb,
                           BitmapCurrentOffset,
                           SizeToPin,
                           &BitmapBcb,
                           &BitmapBuffer );

            //
            //  Initialize the bitmap and search for a free bit.
            //

            RtlInitializeBitMap( &Bitmap, BitmapBuffer, SizeToPin * 8 );

            StuffAdded = NtfsAddDeallocatedRecords( Vcb,
                                                    DataScb,
                                                    BitmapCurrentOffset * 8,
                                                    &Bitmap );

            Index = RtlFindClearBits( &Bitmap, 1, BitOffset );

            //
            //  If we found something, then leave the loop.
            //

            if (Index != 0xffffffff) {

                //
                //  Remember the byte containing the reserved index.
                //

                BitmapByte = ((PCHAR) Bitmap.Buffer)[Index / 8];

                break;
            }

            //
            //  For each subsequent page the page offset is zero.
            //

            BitOffset = 0;
        }

        //
        //  Now check if we have located a record that can be allocated,  If not then extend
        //  the size of the bitmap by 64 bits.
        //

        if (Index == 0xffffffff) {

            //
            //  Cleanup from previous loop.
            //

            if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE; }

            NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Calculate the page offset for the next page to pin.
            //

            BitmapCurrentOffset = BitmapSizeInBytes & ~(PAGE_SIZE - 1);

            //
            //  Calculate the index of next file record to allocate.
            //

            Index = *CurrentBitmapSize;

            //
            //  Now advance the sizes and calculate the size in bytes to
            //  read.
            //

            *CurrentBitmapSize += BITMAP_EXTEND_GRANULARITY;
            DataScb->ScbType.Index.RecordAllocationContext.NumberOfFreeBits += BITMAP_EXTEND_GRANULARITY;

            //
            //  Calculate the new size of the bitmap in bits and check if we must grow
            //  the allocation.
            //

            BitmapSizeInBytes = *CurrentBitmapSize / 8;

            //
            //  Check for allocation first.
            //

            if (BitmapScb->Header.AllocationSize.LowPart < BitmapSizeInBytes) {

                //
                //  Calculate number of clusters to next page boundary, and allocate
                //  that much.
                //

                ClusterCount = ((BitmapSizeInBytes + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1));

                ClusterCount = LlClustersFromBytes( Vcb,
                                                    ((ULONG) ClusterCount - BitmapScb->Header.AllocationSize.LowPart) );

                NtfsAddAllocation( IrpContext,
                                   BitmapScb->FileObject,
                                   BitmapScb,
                                   LlClustersFromBytes( Vcb,
                                                        BitmapScb->Header.AllocationSize.QuadPart ),
                                   ClusterCount,
                                   FALSE,
                                   NULL );
            }

            //
            //  Tell the cache manager about the new file size.
            //

            BitmapScb->Header.FileSize.QuadPart = BitmapSizeInBytes;

            CcSetFileSizes( BitmapScb->FileObject,
                            (PCC_FILE_SIZES)&BitmapScb->Header.AllocationSize );

            //
            //  Now read the page in and mark it dirty so that any new range will
            //  be zeroed.
            //

            SizeToPin = BitmapSizeInBytes - BitmapCurrentOffset;

            if (SizeToPin > PAGE_SIZE) { SizeToPin = PAGE_SIZE; }

            NtfsPinStream( IrpContext,
                           BitmapScb,
                           BitmapCurrentOffset,
                           SizeToPin,
                           &BitmapBcb,
                           &BitmapBuffer );

            CcSetDirtyPinnedData( BitmapBcb, NULL );

            //
            //  Update the ValidDataLength, now that we have read (and possibly
            //  zeroed) the page.
            //

            BitmapScb->Header.ValidDataLength.LowPart = BitmapSizeInBytes;

            NtfsWriteFileSizes( IrpContext,
                                BitmapScb,
                                &BitmapScb->Header.ValidDataLength.QuadPart,
                                TRUE,
                                TRUE,
                                TRUE );

        } else {

            //
            //  The Index at this point is actually relative, so convert it to absolute
            //  before rejoining common code.
            //

            Index += (BitmapCurrentOffset * 8);
        }

        //
        //  We now have an index.  There are three possible states for the file
        //  record corresponding to this index within the Mft.  They are:
        //
        //      - File record could lie beyond the current end of the file.
        //          There is nothing to do in this case.
        //
        //      - File record is part of a hole in the Mft.  In that case
        //          we allocate space for it bring it into memory.
        //
        //      - File record is already within allocated space.  There is nothing
        //          to do in that case.
        //
        //  We store the index as our reserved index and update the Vcb flags.  If
        //  the hole filling operation fails then the RestoreScbSnapshots routine
        //  will clear these values.
        //

        DataScb->ScbType.Mft.ReservedIndex = Index;

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        SetFlag( Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED );
        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MFT_REC_RESERVED );
        NtfsReleaseCheckpoint( IrpContext, Vcb );

        if (NtfsIsMftIndexInHole( IrpContext, Vcb, Index, NULL )) {

            //
            //  Make sure nothing is left pinned in the bitmap.
            //

            NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Try to fill the hole in the Mft.  We will have this routine
            //  raise if unable to fill in the hole.
            //

            NtfsFillMftHole( IrpContext, Vcb, Index );
        }

        //
        //  At this point we have the index to reserve and the value of the
        //  byte in the bitmap which contains this bit.  We make sure the
        //  Mft includes the allocation for this index and the other
        //  bits within the same byte.  This is so we can uninitialize these
        //  file records so chkdsk won't look at stale data.
        //

        EndOfIndexOffset = LlBytesFromFileRecords( Vcb, (Index + 8) & ~(7));

        //
        //  Now check if we are extending the file.  We update the file size and
        //  valid data now.
        //

        if (EndOfIndexOffset > DataScb->Header.FileSize.QuadPart) {

            ULONG AddedFileRecords;
            ULONG CurrentIndex;

            //
            //  Check for allocation first.
            //

            if (EndOfIndexOffset > DataScb->Header.AllocationSize.QuadPart) {

                ClusterCount = ((Index + DataScb->ScbType.Index.RecordAllocationContext.ExtendGranularity) &
                                ~(DataScb->ScbType.Index.RecordAllocationContext.ExtendGranularity - 1));

                ClusterCount = LlBytesFromFileRecords( Vcb, (ULONG) ClusterCount );

                ClusterCount = LlClustersFromBytesTruncate( Vcb,
                                                            ClusterCount - DataScb->Header.AllocationSize.QuadPart );

                NtfsAddAllocation( IrpContext,
                                   DataScb->FileObject,
                                   DataScb,
                                   LlClustersFromBytes( Vcb,
                                                        DataScb->Header.AllocationSize.QuadPart ),
                                   ClusterCount,
                                   FALSE,
                                   NULL );
            }

            //
            //  Now we have to figure out how many file records we will be
            //  adding and the index of the first record being added.
            //

            CurrentIndex = (ULONG) LlFileRecordsFromBytes( Vcb, DataScb->Header.FileSize.QuadPart );
            AddedFileRecords = (ULONG) (EndOfIndexOffset - DataScb->Header.FileSize.QuadPart);
            AddedFileRecords = FileRecordsFromBytes( Vcb, AddedFileRecords );

            DataScb->Header.FileSize.QuadPart = EndOfIndexOffset;
            DataScb->Header.ValidDataLength.QuadPart = EndOfIndexOffset;

            NtfsWriteFileSizes( IrpContext,
                                DataScb,
                                &DataScb->Header.ValidDataLength.QuadPart,
                                TRUE,
                                TRUE,
                                TRUE );

            //
            //  Tell the cache manager about the new file size.
            //

            CcSetFileSizes( DataScb->FileObject,
                            (PCC_FILE_SIZES)&DataScb->Header.AllocationSize );

            //
            //  Update our bookeeping to reflect the number of file records
            //  added.
            //

            DataScb->ScbType.Mft.FreeRecordChange += AddedFileRecords;
            Vcb->MftFreeRecords += AddedFileRecords;

            //
            //  We now have to go through each of the file records added
            //  and mark it as not IN_USE.  We don't want stale data in this range
            //  to ever confuse chkdsk or rescan.  These records begin after the
            //  current end of file.  We won't worry about anything currently
            //  in the file because it would already be marked as IN-USE or
            //  not correctly.  We are only concerned with records which will
            //  become part of the valid portion of the file since we will
            //  skip them in the normal allocation path (we want to limit
            //  disk IO in a file record containing MFT mapping).
            //

            //
            //  Chop off the bits which are already part of the file.
            //

            BitmapByte >>= (8 - AddedFileRecords);

            //
            //  Now perform the initialization routine for each file record beyond the
            //  previous end of the file.
            //

            while (AddedFileRecords) {

                //
                //  If not allocated then uninitialize it now.
                //

                if (!FlagOn( BitmapByte, 0x1 )) {

                    NtfsInitializeMftHoleRecords( IrpContext,
                                                  Vcb,
                                                  CurrentIndex,
                                                  1 );
                }

                BitmapByte >>= 1;
                CurrentIndex += 1;
                AddedFileRecords -= 1;
            }
        }

    } finally {

        DebugUnwind( NtfsReserveMftRecord );

        if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); }

        NtfsUnpinBcb( IrpContext, &BitmapBcb );

        NtfsReleaseScb( IrpContext, DataScb );
    }

    DebugTrace( -1, Dbg, ("NtfsReserveMftRecord -> Exit\n") );

    return;
}


ULONG
NtfsAllocateMftReservedRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    )

/*++

Routine Description:

    This routine allocates a previously reserved record, and returns its
    number.

Arguments:

    Vcb - This is the Vcb for the volume.

    BitmapAttribute - Supplies the enumeration context for the bitmap
        attribute.  This parameter is ignored if the bitmap attribute is
        non resident, in which case we create an scb for the attribute and
        store a pointer to it in the record allocation context.

Return Value:

    ULONG - Returns the index of the record just reserved, zero based.

--*/

{
    PSCB DataScb;

    ULONG ReservedIndex;

    PBCB BitmapBcb = NULL;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAllocateMftReservedRecord\n") );

    //
    //  Synchronize by acquiring the data scb exclusive, as an "end resource".
    //  Then use try-finally to insure we free it up.
    //

    DataScb = Vcb->MftScb;
    NtfsAcquireExclusiveScb( IrpContext, DataScb );

    try {

        PSCB BitmapScb;
        ULONG RelativeIndex;
        ULONG SizeToPin;

        RTL_BITMAP Bitmap;
        PVOID BitmapBuffer;

        BITMAP_RANGE BitmapRange;
        ULONG BitmapCurrentOffset = 0;

        //
        //  If we are going to allocate file record 15 then do so and set the
        //  flags in the IrpContext and Vcb.
        //

        if (!FlagOn( Vcb->MftReserveFlags, VCB_MFT_RECORD_15_USED )) {

            SetFlag( Vcb->MftReserveFlags, VCB_MFT_RECORD_15_USED );
            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MFT_REC_15_USED );

            try_return( ReservedIndex = FIRST_USER_FILE_NUMBER - 1 );
        }

        //
        //  See if someone made the bitmap nonresident, and we still think
        //  it is resident.  If so, we must uninitialize and insure reinitialization
        //  below.
        //

        {
            ULONG BytesPerRecord = DataScb->ScbType.Index.RecordAllocationContext.BytesPerRecord;
            ULONG ExtendGranularity = DataScb->ScbType.Index.RecordAllocationContext.ExtendGranularity;

            if ((DataScb->ScbType.Index.RecordAllocationContext.BitmapScb == NULL) &&
                !NtfsIsAttributeResident( NtfsFoundAttribute( BitmapAttribute ))) {

                NtfsUninitializeRecordAllocation( IrpContext,
                                                  &DataScb->ScbType.Index.RecordAllocationContext );

                DataScb->ScbType.Index.RecordAllocationContext.CurrentBitmapSize = MAXULONG;
            }

            //
            //  Reinitialize the record context structure if necessary.
            //

            if (DataScb->ScbType.Index.RecordAllocationContext.CurrentBitmapSize == MAXULONG) {

                NtfsInitializeRecordAllocation( IrpContext,
                                                DataScb,
                                                BitmapAttribute,
                                                BytesPerRecord,
                                                ExtendGranularity,
                                                ExtendGranularity,
                                                &DataScb->ScbType.Index.RecordAllocationContext );
            }
        }

        BitmapScb = DataScb->ScbType.Index.RecordAllocationContext.BitmapScb;
        ReservedIndex = DataScb->ScbType.Mft.ReservedIndex;

        //
        //  Find the start of the page containing the reserved index.
        //

        BitmapCurrentOffset = (ReservedIndex / 8) & ~(PAGE_SIZE - 1);

        RelativeIndex = ReservedIndex & (BITS_PER_PAGE - 1);

        //
        //  Calculate the size to read from this point to the end of
        //  bitmap, or a page, whichever is less.
        //

        SizeToPin = (DataScb->ScbType.Index.RecordAllocationContext.CurrentBitmapSize / 8)
                    - BitmapCurrentOffset;

        if (SizeToPin > PAGE_SIZE) { SizeToPin = PAGE_SIZE; }

        //
        //  Read the desired bitmap page.
        //

        NtfsPinStream( IrpContext,
                       BitmapScb,
                       BitmapCurrentOffset,
                       SizeToPin,
                       &BitmapBcb,
                       &BitmapBuffer );

        //
        //  Initialize the bitmap.
        //

        RtlInitializeBitMap( &Bitmap, BitmapBuffer, SizeToPin * 8 );

        //
        //  Now log this change as well.
        //

        BitmapRange.BitMapOffset = RelativeIndex;
        BitmapRange.NumberOfBits = 1;

        (VOID) NtfsWriteLog( IrpContext,
                             BitmapScb,
                             BitmapBcb,
                             SetBitsInNonresidentBitMap,
                             &BitmapRange,
                             sizeof(BITMAP_RANGE),
                             ClearBitsInNonresidentBitMap,
                             &BitmapRange,
                             sizeof(BITMAP_RANGE),
                             BitmapCurrentOffset,
                             0,
                             0,
                             Bitmap.SizeOfBitMap >> 3 );

        NtfsRestartSetBitsInBitMap( IrpContext, &Bitmap, RelativeIndex, 1 );

        //
        //  Now that we've located an index we can subtract the number of free bits in the bitmap
        //

        DataScb->ScbType.Index.RecordAllocationContext.NumberOfFreeBits -= 1;

        //
        //  If we didn't extend the file then we have used a free file record in the file.
        //  Update our bookeeping count for free file records.
        //

        DataScb->ScbType.Mft.FreeRecordChange -= 1;
        Vcb->MftFreeRecords -= 1;

        //
        //  Now determine if we extended the index of the last set bit
        //

        if (ReservedIndex > (ULONG)DataScb->ScbType.Index.RecordAllocationContext.IndexOfLastSetBit) {

            DataScb->ScbType.Index.RecordAllocationContext.IndexOfLastSetBit = ReservedIndex;
        }

        //
        //  Clear the fields that indicate we have a reserved index.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        ClearFlag( Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED );
        NtfsReleaseCheckpoint( IrpContext, Vcb );
        DataScb->ScbType.Mft.ReservedIndex = 0;

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsAllocateMftReserveRecord );

        NtfsUnpinBcb( IrpContext, &BitmapBcb );

        NtfsReleaseScb( IrpContext, DataScb );
    }

    DebugTrace( -1, Dbg, ("NtfsAllocateMftReserveRecord -> %08lx\n", ReservedIndex) );

    return ReservedIndex;
}


VOID
NtfsDeallocateRecordsComplete (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine removes recently deallocated record information from
    the Scb structures based on the input irp context.

Arguments:

    IrpContext - Supplies the Queue of recently deallocate records

Return Value:

    None.

--*/

{
    PDEALLOCATED_RECORDS DeallocatedRecords;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeallocateRecordsComplete\n") );

    //
    //  Now while the irp context's recently deallocated queue is not empty
    //  we will grap the first entry off the queue, remove it from both
    //  the scb and irp context queue, and free the record
    //

    while (!IsListEmpty( &IrpContext->RecentlyDeallocatedQueue )) {

        DeallocatedRecords = CONTAINING_RECORD( IrpContext->RecentlyDeallocatedQueue.Flink,
                                                DEALLOCATED_RECORDS,
                                                IrpContextLinks );

        RemoveEntryList( &DeallocatedRecords->ScbLinks );

        //
        //  Reset our hint index if one of the deallocated indexes is suitable.
        //

        if (DeallocatedRecords->Scb->ScbType.Index.RecordAllocationContext.StartingHint >
            DeallocatedRecords->Scb->ScbType.Index.RecordAllocationContext.LowestDeallocatedIndex) {

            DeallocatedRecords->Scb->ScbType.Index.RecordAllocationContext.StartingHint =
                DeallocatedRecords->Scb->ScbType.Index.RecordAllocationContext.LowestDeallocatedIndex;
        }

        //
        //  Make sure to reset the LowestDeallocated.
        //

        DeallocatedRecords->Scb->ScbType.Index.RecordAllocationContext.LowestDeallocatedIndex = MAXULONG;

        //
        //  Now remove the record from the irp context queue and deallocate the
        //  record
        //

        RemoveEntryList( &DeallocatedRecords->IrpContextLinks );

        //
        //  If this record is the default size then return it to our private list.
        //  Otherwise deallocate it to pool.
        //

        if (DeallocatedRecords->NumberOfEntries == DEALLOCATED_RECORD_ENTRIES) {

            ExFreeToPagedLookasideList( &NtfsDeallocatedRecordsLookasideList, DeallocatedRecords );

        } else {

            NtfsFreePool( DeallocatedRecords );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsDeallocateRecordsComplete -> VOID\n") );

    return;
}


BOOLEAN
NtfsIsRecordAllocated (
    IN PIRP_CONTEXT IrpContext,
    IN PRECORD_ALLOCATION_CONTEXT RecordAllocationContext,
    IN ULONG Index,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    )

/*++

Routine Description:

    This routine is used to query if a record is currently allocated for
    the specified record allocation context.

Arguments:

    RecordAllocationContext - Supplies the record allocation context used
        in this operation

    Index - Supplies the index of the record being queried, zero based.

    BitmapAttribute - Supplies the enumeration context for the bitmap
        attribute.  This parameter is ignored if the bitmap attribute is
        non resident, in which case we create an scb for the attribute and
        store a pointer to it in the record allocation context.

Return Value:

    BOOLEAN - TRUE if the record is currently allocated and FALSE otherwise.

--*/

{
    BOOLEAN Results;

    PSCB DataScb;
    PSCB BitmapScb;
    ULONG CurrentBitmapSize;

    PVCB Vcb;

    RTL_BITMAP Bitmap;
    PBCB BitmapBcb = NULL;

    PATTRIBUTE_RECORD_HEADER AttributeRecordHeader;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsIsRecordAllocated\n") );

    //
    //  Synchronize by acquiring the data scb exclusive, as an "end resource".
    //  Then use try-finally to insure we free it up.
    //

    DataScb = RecordAllocationContext->DataScb;
    NtfsAcquireExclusiveScb( IrpContext, DataScb );

    try {

        Vcb = DataScb->Fcb->Vcb;

        //
        //  See if someone made the bitmap nonresident, and we still think
        //  it is resident.  If so, we must uninitialize and insure reinitialization
        //  below.
        //

        BitmapScb = RecordAllocationContext->BitmapScb;

        {
            ULONG ExtendGranularity;
            ULONG BytesPerRecord;
            ULONG TruncateGranularity;

            //
            //  Remember the current values in the record context structure.
            //

            BytesPerRecord = RecordAllocationContext->BytesPerRecord;
            TruncateGranularity = RecordAllocationContext->TruncateGranularity;
            ExtendGranularity = RecordAllocationContext->ExtendGranularity;

            if ((BitmapScb == NULL) && !NtfsIsAttributeResident(NtfsFoundAttribute(BitmapAttribute))) {

                NtfsUninitializeRecordAllocation( IrpContext,
                                                  RecordAllocationContext );

                RecordAllocationContext->CurrentBitmapSize = MAXULONG;
            }

            //
            //  Reinitialize the record context structure if necessary.
            //

            if (RecordAllocationContext->CurrentBitmapSize == MAXULONG) {

                NtfsInitializeRecordAllocation( IrpContext,
                                                DataScb,
                                                BitmapAttribute,
                                                BytesPerRecord,
                                                ExtendGranularity,
                                                TruncateGranularity,
                                                RecordAllocationContext );
            }
        }

        BitmapScb = RecordAllocationContext->BitmapScb;
        CurrentBitmapSize = RecordAllocationContext->CurrentBitmapSize;

        //
        //  We will do different operations based on whether the bitmap is resident or nonresident
        //  The first case will handle the resident bitmap
        //

        if (BitmapScb == NULL) {

            UCHAR NewByte;

            //
            //  Initialize the local bitmap
            //

            AttributeRecordHeader = NtfsFoundAttribute( BitmapAttribute );

            RtlInitializeBitMap( &Bitmap,
                                 (PULONG)NtfsAttributeValue( AttributeRecordHeader ),
                                 CurrentBitmapSize );

            //
            //  And check if the indcated bit is Set.  If it is set then the record is allocated.
            //

            NewByte = ((PUCHAR)Bitmap.Buffer)[ Index / 8 ];

            Results = BooleanFlagOn( NewByte, BitMask[Index % 8] );

        } else {

            PVOID BitmapBuffer;
            ULONG SizeToMap;
            ULONG RelativeIndex;
            ULONG BitmapCurrentOffset;

            //
            //  Calculate Vcn and relative index of the bit we will deallocate,
            //  from the nearest page boundary.
            //

            BitmapCurrentOffset = (Index / 8) & ~(PAGE_SIZE - 1);
            RelativeIndex = Index & (BITS_PER_PAGE - 1);

            //
            //  Calculate the size to read from this point to the end of
            //  bitmap.
            //

            SizeToMap = CurrentBitmapSize / 8 - BitmapCurrentOffset;

            if (SizeToMap > PAGE_SIZE) { SizeToMap = PAGE_SIZE; }

            NtfsMapStream( IrpContext,
                           BitmapScb,
                           BitmapCurrentOffset,
                           SizeToMap,
                           &BitmapBcb,
                           &BitmapBuffer );

            RtlInitializeBitMap( &Bitmap, BitmapBuffer, SizeToMap * 8 );

            //
            //  Now check if the indicated bit is set.  If it is set then the record is allocated.
            //  no idea whether the update is applied or not.
            //

            Results = RtlAreBitsSet(&Bitmap, RelativeIndex, 1);
        }

    } finally {

        DebugUnwind( NtfsIsRecordDeallocated );

        NtfsUnpinBcb( IrpContext, &BitmapBcb );

        NtfsReleaseScb( IrpContext, DataScb );
    }

    DebugTrace( -1, Dbg, ("NtfsIsRecordAllocated -> %08lx\n", Results) );

    return Results;
}


VOID
NtfsScanMftBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb
    )

/*++

Routine Description:

    This routine is called during mount to initialize the values related to
    the Mft in the Vcb.  These include the number of free records and hole
    records.  Also whether we have already used file record 15.  We also scan
    the Mft to check whether there is any excess mapping.

Arguments:

    Vcb - Supplies the Vcb for the volume.

Return Value:

    None.

--*/

{
    PBCB BitmapBcb = NULL;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsScanMftBitmap...\n") );

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        ULONG SizeToMap;
        ULONG FileRecords;
        ULONG RemainingRecords;
        ULONG BitmapCurrentOffset;
        ULONG BitmapBytesToRead;
        PUCHAR BitmapBuffer;
        UCHAR NextByte;
        VCN Vcn;
        LCN Lcn;
        LONGLONG Clusters;

        //
        //  Start by walking through the file records for the Mft
        //  checking for excess mapping.
        //

        NtfsLookupAttributeForScb( IrpContext, Vcb->MftScb, NULL, &AttrContext );

        //
        //  We don't care about the first one.  Let's find the rest of them.
        //

        while (NtfsLookupNextAttributeForScb( IrpContext,
                                              Vcb->MftScb,
                                              &AttrContext )) {

            PFILE_RECORD_SEGMENT_HEADER FileRecord;

            SetFlag( Vcb->MftReserveFlags, VCB_MFT_RECORD_15_USED );

            FileRecord = NtfsContainingFileRecord( &AttrContext );

            //
            //  Now check for the free space.
            //

            if (FileRecord->BytesAvailable - FileRecord->FirstFreeByte < Vcb->MftReserved) {

                NtfsAcquireCheckpoint( IrpContext, Vcb );
                SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_EXCESS_MAP );
                NtfsReleaseCheckpoint( IrpContext, Vcb );
                break;
            }
        }

        //
        //  We now want to find the number of free records within the Mft
        //  bitmap.  We need to figure out how many file records are in
        //  the Mft and then map the necessary bytes in the bitmap and
        //  find the count of set bits.  We will round the bitmap length
        //  down to a byte boundary and then look at the last byte
        //  separately.
        //

        FileRecords = (ULONG) LlFileRecordsFromBytes( Vcb, Vcb->MftScb->Header.FileSize.QuadPart );

        //
        //  Remember how many file records are in the last byte of the bitmap.
        //

        RemainingRecords = FileRecords & 7;

        FileRecords &= ~(7);
        BitmapBytesToRead = FileRecords / 8;

        for (BitmapCurrentOffset = 0;
             BitmapCurrentOffset < BitmapBytesToRead;
             BitmapCurrentOffset += PAGE_SIZE) {

            RTL_BITMAP Bitmap;
            ULONG MapAdjust;

            //
            //  Calculate the size to read from this point to the end of
            //  bitmap, or a page, whichever is less.
            //

            SizeToMap = BitmapBytesToRead - BitmapCurrentOffset;

            if (SizeToMap > PAGE_SIZE) { SizeToMap = PAGE_SIZE; }

            //
            //  If we aren't pinning a full page and have some bits
            //  in the next byte then pin an extra byte.
            //

            if ((SizeToMap != PAGE_SIZE) && (RemainingRecords != 0)) {

                MapAdjust = 1;

            } else {

                MapAdjust = 0;
            }

            //
            //  Unpin any Bcb from a previous loop.
            //

            NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Read the desired bitmap page.
            //

            NtfsMapStream( IrpContext,
                           Vcb->MftBitmapScb,
                           BitmapCurrentOffset,
                           SizeToMap + MapAdjust,
                           &BitmapBcb,
                           &BitmapBuffer );

            //
            //  Initialize the bitmap and search for a free bit.
            //

            RtlInitializeBitMap( &Bitmap, (PULONG) BitmapBuffer, SizeToMap * 8 );

            Vcb->MftFreeRecords += RtlNumberOfClearBits( &Bitmap );
        }

        //
        //  If there are some remaining bits in the next byte then process
        //  them now.
        //

        if (RemainingRecords) {

            PVOID RangePtr;
            ULONG Index;

            //
            //  Hopefully this byte is on the same page.  Otherwise we will
            //  free this page and go to the next.  In this case the Vcn will
            //  have the correct value because we walked past the end of the
            //  current file records already.
            //

            if (SizeToMap == PAGE_SIZE) {

                //
                //  Unpin any Bcb from a previous loop.
                //

                NtfsUnpinBcb( IrpContext, &BitmapBcb );

                //
                //  Read the desired bitmap page.
                //

                NtfsMapStream( IrpContext,
                               Vcb->MftScb->ScbType.Index.RecordAllocationContext.BitmapScb,
                               BitmapCurrentOffset,
                               1,
                               &BitmapBcb,
                               &BitmapBuffer );

                //
                //  Set this to the byte prior to the last byte.  This will
                //  set this to the same state as if on the same page.
                //

                SizeToMap = 0;
            }

            //
            //  We look at the next byte in the page and figure out how
            //  many bits are set.
            //

            NextByte = *((PUCHAR) Add2Ptr( BitmapBuffer, SizeToMap + 1 ));

            while (RemainingRecords--) {

                if (!FlagOn( NextByte, 0x01 )) {

                    Vcb->MftFreeRecords += 1;
                }

                NextByte >>= 1;
            }

            //
            //  We are now ready to look for holes within the Mft.  We will look
            //  through the Mcb for the Mft looking for holes.  The holes must
            //  always be an integral number of file records.
            //

            RangePtr = NULL;
            Index = 0;

            while (NtfsGetSequentialMcbEntry( &Vcb->MftScb->Mcb,
                                              &RangePtr,
                                              Index,
                                              &Vcn,
                                              &Lcn,
                                              &Clusters )) {

                //
                //  Look for a hole and count the clusters.
                //

                if (Lcn == UNUSED_LCN) {

                    if (Vcb->FileRecordsPerCluster == 0) {

                        Vcb->MftHoleRecords += (((ULONG)Clusters) >> Vcb->MftToClusterShift);

                    } else {

                        Vcb->MftHoleRecords += (((ULONG)Clusters) << Vcb->MftToClusterShift);
                    }
                }

                Index += 1;
            }
        }

    } finally {

        DebugUnwind( NtfsScanMftBitmap );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        NtfsUnpinBcb( IrpContext, &BitmapBcb );

        DebugTrace( -1, Dbg, ("NtfsScanMftBitmap...\n") );
    }

    return;
}


//
//  Local support routine
//

BOOLEAN
NtfsAddDeallocatedRecords (
    IN PVCB Vcb,
    IN PSCB Scb,
    IN ULONG StartingIndexOfBitmap,
    IN OUT PRTL_BITMAP Bitmap
    )

/*++

Routine Description:

    This routine will modify the input bitmap by removing from it
    any records that are in the recently deallocated queue of the scb.
    If we do add stuff then we will not modify the bitmap buffer itself but
    will allocate a new copy for the bitmap.

Arguments:

    Vcb - Supplies the Vcb for the volume

    Scb - Supplies the Scb used in this operation

    StartingIndexOfBitmap - Supplies the base index to use to bias the bitmap

    Bitmap - Supplies the bitmap being modified

Return Value:

    BOOLEAN - TRUE if the bitmap has been modified and FALSE
        otherwise.

--*/

{
    BOOLEAN Results;
    ULONG EndingIndexOfBitmap;
    PLIST_ENTRY Links;
    PDEALLOCATED_RECORDS DeallocatedRecords;
    ULONG i;
    ULONG Index;
    PVOID NewBuffer;
    ULONG SizeOfBitmapInBytes;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddDeallocatedRecords...\n") );

    //
    //  Until shown otherwise we will assume that we haven't updated anything
    //

    Results = FALSE;

    //
    //  Calculate the last index in the bitmap
    //

    EndingIndexOfBitmap = StartingIndexOfBitmap + Bitmap->SizeOfBitMap - 1;
    SizeOfBitmapInBytes = (Bitmap->SizeOfBitMap + 7) / 8;

    //
    //  Check if we need to bias the bitmap with the reserved index
    //

    if ((Scb == Vcb->MftScb) &&
        FlagOn( Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED ) &&
        (StartingIndexOfBitmap <= Scb->ScbType.Mft.ReservedIndex) &&
        (Scb->ScbType.Mft.ReservedIndex <= EndingIndexOfBitmap)) {

        //
        //  The index is a hit so now bias the index with the start of the bitmap
        //  and allocate an extra buffer to hold the bitmap
        //

        Index = Scb->ScbType.Mft.ReservedIndex - StartingIndexOfBitmap;

        NewBuffer = NtfsAllocatePool(PagedPool, SizeOfBitmapInBytes );
        RtlCopyMemory( NewBuffer, Bitmap->Buffer, SizeOfBitmapInBytes );
        Bitmap->Buffer = NewBuffer;

        Results = TRUE;

        //
        //  And now set the bits in the bitmap to indicate that the record
        //  cannot be reallocated yet.  Also set the other bits within the
        //  same byte so we can put all of the file records for the Mft
        //  within the same pages of the Mft.
        //

        ((PUCHAR) Bitmap->Buffer)[ Index / 8 ] = 0xff;
    }

    //
    //  Scan through the recently deallocated queue looking for any indexes that
    //  we need to modify
    //

    for (Links = Scb->ScbType.Index.RecentlyDeallocatedQueue.Flink;
         Links != &Scb->ScbType.Index.RecentlyDeallocatedQueue;
         Links = Links->Flink) {

        DeallocatedRecords = CONTAINING_RECORD( Links, DEALLOCATED_RECORDS, ScbLinks );

        //
        //  For every index in the record check if the index is within the range
        //  of the bitmap we are working with
        //

        for (i = 0; i < DeallocatedRecords->NextFreeEntry; i += 1) {

            if ((StartingIndexOfBitmap <= DeallocatedRecords->Index[i]) &&
                 (DeallocatedRecords->Index[i] <= EndingIndexOfBitmap)) {

                //
                //  The index is a hit so now bias the index with the start of the bitmap
                //  and check if we need to allocate an extra buffer to hold the bitmap
                //

                Index = DeallocatedRecords->Index[i] - StartingIndexOfBitmap;

                if (!Results) {

                    NewBuffer = NtfsAllocatePool(PagedPool, SizeOfBitmapInBytes );
                    RtlCopyMemory( NewBuffer, Bitmap->Buffer, SizeOfBitmapInBytes );
                    Bitmap->Buffer = NewBuffer;

                    Results = TRUE;
                }

                //
                //  And now set the bit in the bitmap to indicate that the record
                //  cannot be reallocated yet.  It's possible that the bit is
                //  already set if we have aborted a transaction which then
                //  restores the bit.
                //

                SetFlag( ((PUCHAR)Bitmap->Buffer)[ Index / 8 ], BitMask[Index % 8] );
            }
        }
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsAddDeallocatedRecords -> %08lx\n", Results) );

    return Results;
}


//
//  Local support routine
//

LCN
NtfsInitializeMftZone (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to reserve a range of the volume bitmap for use by the
    Mft zone.  We first look for a range which is contiguous with the end of the Mft.
    If unavailable we look for a suitable length range out of the cached runs array.

    We expect our caller has loaded the cached runs array with free runs in the volume
    bitmap and also that the Mcb for the Mft is fully loaded.

Arguments:

    Vcb - This is the Vcb for the volume we are looking for the zone for.

Return Value:

    LCN - Return the LCN for the first run in the free portion of the zone.

--*/

{
    LONGLONG ClusterCount;
    LCN Lcn;
    VCN Vcn;
    LCN ZoneStart;
    LONGLONG MinZoneSize;
    LONGLONG DefaultZoneSize;
    LONGLONG MftClusters;
    BOOLEAN FoundRun;

    PAGED_CODE();

    //
    //  We synchronize on the volume bitmap.
    //

    ASSERT( NtfsIsExclusiveScb( Vcb->BitmapScb ));
    ASSERT( NtfsIsExclusiveScb( Vcb->MftScb ));

    DebugTrace( +1, Dbg, ("NtfsInitializeMftZone\n") );

    //
    //  Remember the default size of the new zone and the number of clusters in the Mft.
    //

    MinZoneSize = Vcb->TotalClusters >> (NTFS_MFT_ZONE_DEFAULT_SHIFT + 1);
    DefaultZoneSize = (Vcb->TotalClusters >> NTFS_MFT_ZONE_DEFAULT_SHIFT) * NtfsMftZoneMultiplier;
    MftClusters = LlClustersFromBytesTruncate( Vcb, Vcb->MftScb->Header.AllocationSize.QuadPart );

    if (DefaultZoneSize > MftClusters + MinZoneSize) {

        DefaultZoneSize -= MftClusters;

    } else {

        DefaultZoneSize = MinZoneSize;
    }

    //
    //  Get the last Lcn for the Mft and check if we can find a contiguous free run.
    //

    FoundRun = NtfsLookupLastNtfsMcbEntry( &Vcb->MftScb->Mcb,
                                           &Vcn,
                                           &Lcn );

    ASSERT( FoundRun && (Vcn + 1 >= MftClusters) );

    //
    //  Look first in the cached runs array.  If not there then look to the disk.
    //

    Lcn += 1;
    if (!NtfsLookupCachedLcn( &Vcb->CachedRuns,
                              Lcn,
                              &ZoneStart,
                              &ClusterCount,
                              NULL )) {

        //
        //  If there are no free runs then set the zone to a default value.
        //

        if (Vcb->CachedRuns.Used == 0) {

            ZoneStart = Lcn;
            ClusterCount = DefaultZoneSize;

        //
        //  There should be a run available in the bitmap.
        //

        } else {

            NtfsFindFreeBitmapRun( IrpContext,
                                   Vcb,
                                   DefaultZoneSize,
                                   Lcn,
                                   TRUE,
                                   TRUE,
                                   &ZoneStart,
                                   &ClusterCount );

            //
            //  If there is no contiguous range then look for the best fit in the cached
            //  runs array.  Start by asking for half the original zone request.  Up it
            //  if the current Mft is rather small.
            //

            if (ZoneStart != Lcn) {

                ClusterCount = DefaultZoneSize;

                //
                //  Lookup in the cached runs array by length.
                //

                NtfsLookupCachedLcnByLength( &Vcb->CachedRuns,
                                             ClusterCount,
                                             TRUE,
                                             Lcn,
                                             &ZoneStart,
                                             &ClusterCount,
                                             NULL );
            }
        }
    }

    //
    //  We now have a value for the zone start and length.  Make sure we aren't overreserving the
    //  volume.  Consider the current size of the Mft and the length of the additional zone.
    //

    if (ClusterCount > DefaultZoneSize) {

        ClusterCount = DefaultZoneSize;
    }

    //
    //  Align the zone on ULONG boundary.  RtlFindNextForwardRunClear expects the pointers
    //  to be ulong aligned.
    //

    Vcb->MftZoneStart = ZoneStart & ~0x1f;
    Vcb->MftZoneEnd = (ZoneStart + ClusterCount + 0x1f) & ~0x1f;

    //
    //  Keep it close to total clusters.
    //

    if (Vcb->MftZoneEnd > Vcb->TotalClusters) {

        Vcb->MftZoneEnd = (Vcb->TotalClusters + 0x1f) & ~0x1f;
    }

    ClearFlag( Vcb->VcbState, VCB_STATE_REDUCED_MFT );

    //
    //  Remove the Mft zone from the cached runs.  We always look to the
    //  bitmap directly when extending the Mft.
    //

    NtfsRemoveCachedLcn( &Vcb->CachedRuns,
                         Vcb->MftZoneStart,
                         Vcb->MftZoneEnd - Vcb->MftZoneStart );

    DebugTrace( -1, Dbg, ("NtfsInitializeMftZone -> VOID\n") );

    return ZoneStart;
}


//
//  Local support routine
//

BOOLEAN
NtfsReduceMftZone (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called when it appears that there is no disk space left on the
    disk except the Mft zone.  We will try to reduce the zone to make space
    available for user files.

Arguments:

    Vcb - Supplies the Vcb for the volume

Return Value:

    BOOLEAN - TRUE if the Mft zone was shrunk.  FALSE otherwise.

--*/

{
    BOOLEAN ReduceMft = FALSE;

    LONGLONG FreeClusters;
    LONGLONG TargetFreeClusters;
    LONGLONG PrevFreeClusters;

    ULONG CurrentOffset;

    LCN Lcn;
    LCN StartingLcn;
    LCN SplitLcn;
    LCN FinalLcn;

    RTL_BITMAP Bitmap;
    PBCB BitmapBcb = NULL;

    PAGED_CODE();

    //
    //  Nothing to do if disk is almost empty.
    //

    if (Vcb->FreeClusters < (4 * MFT_EXTEND_GRANULARITY)) {

        return FALSE;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Bound our search by the end of the volume.
        //

        FinalLcn = Vcb->MftZoneEnd;
        if (Vcb->MftZoneEnd > Vcb->TotalClusters) {

            FinalLcn = Vcb->TotalClusters;
        }

        //
        //  We want to find the number of free clusters in the Mft zone and
        //  return half of them to the pool of clusters for users files.
        //

        FreeClusters = 0;

        for (Lcn = Vcb->MftZoneStart;
             Lcn < FinalLcn;
             Lcn = StartingLcn + Bitmap.SizeOfBitMap) {

            NtfsUnpinBcb( IrpContext, &BitmapBcb );
            NtfsMapPageInBitmap( IrpContext, Vcb, Lcn, &StartingLcn, &Bitmap, &BitmapBcb );

            if ((StartingLcn + Bitmap.SizeOfBitMap) > FinalLcn) {

                Bitmap.SizeOfBitMap = (ULONG) (FinalLcn - StartingLcn);
            }

            if (StartingLcn != Lcn) {

                Bitmap.SizeOfBitMap -= (ULONG) (Lcn - StartingLcn);
                Bitmap.Buffer = Add2Ptr( Bitmap.Buffer,
                                         (ULONG) (Lcn - StartingLcn) / 8 );

                StartingLcn = Lcn;
            }

            FreeClusters += RtlNumberOfClearBits( &Bitmap );
        }

        //
        //  If we are below our threshold then don't do the split.
        //

        if (FreeClusters < (4 * MFT_EXTEND_GRANULARITY)) {

            try_return( NOTHING );
        }

        //
        //  Now we want to calculate 1/2 of this number of clusters and set the
        //  zone end to this point.
        //

        TargetFreeClusters = Int64ShraMod32( FreeClusters, 1 );

        //
        //  Now look for the page which contains the split point.
        //

        FreeClusters = 0;

        for (Lcn = Vcb->MftZoneStart;
             Lcn < FinalLcn;
             Lcn = StartingLcn + Bitmap.SizeOfBitMap) {

            NtfsUnpinBcb( IrpContext, &BitmapBcb );
            NtfsMapPageInBitmap( IrpContext, Vcb, Lcn, &StartingLcn, &Bitmap, &BitmapBcb );

            if ((StartingLcn + Bitmap.SizeOfBitMap) > FinalLcn) {

                Bitmap.SizeOfBitMap = (ULONG) (FinalLcn - StartingLcn);
            }

            if (StartingLcn != Lcn) {

                Bitmap.SizeOfBitMap -= (ULONG) (Lcn - StartingLcn);
                Bitmap.Buffer = Add2Ptr( Bitmap.Buffer,
                                         (ULONG) (Lcn - StartingLcn) / 8 );

                StartingLcn = Lcn;
            }

            PrevFreeClusters = FreeClusters;
            FreeClusters += RtlNumberOfClearBits( &Bitmap );

            //
            //  Check if we found the page containing the split point.
            //

            if (FreeClusters >= TargetFreeClusters) {

                CurrentOffset = 0;

                while (TRUE) {

                    if (!RtlCheckBit( &Bitmap, CurrentOffset )) {

                        PrevFreeClusters += 1;
                        if (PrevFreeClusters == TargetFreeClusters) {

                            break;
                        }
                    }

                    CurrentOffset += 1;
                }

                SplitLcn = Lcn + CurrentOffset;
                ReduceMft = TRUE;
                break;
            }
        }

        //
        //  If we are to reduce the Mft zone then set the split point and exit.
        //  We always round the split point up to a ULONG bitmap boundary so
        //  that the bitmap for the zone is ULONG aligned.  RtlFindNextForwardRunClear
        //  expects the pointers to be ulong aligned.
        //

        if (ReduceMft) {

            Vcb->MftZoneEnd = (SplitLcn + 0x1f) & ~0x1f;

            //
            //  Keep it close to total clusters.
            //

            if (Vcb->MftZoneEnd > Vcb->TotalClusters) {

                Vcb->MftZoneEnd = (Vcb->TotalClusters + 0x1f) & ~0x1f;
            }

            ASSERT( Vcb->MftZoneEnd >= Vcb->MftZoneStart );

            if (Int64ShraMod32( Vcb->TotalClusters, 4 ) > Vcb->FreeClusters) {

                SetFlag( Vcb->VcbState, VCB_STATE_REDUCED_MFT );
            }
        }

    try_exit:  NOTHING;
    } finally {

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    return ReduceMft;
}


//
//  Local support routine
//

VOID
NtfsCheckRecordStackUsage (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine is called in the record package prior to adding allocation
    to either a data stream or bitmap stream.  The purpose is to verify
    that there is room on the stack to perform a log file full in the
    AddAllocation operation.  This routine will check the stack space and
    the available log file space and raise LOG_FILE_FULL defensively if
    both of these reach a critical threshold.

Arguments:

Return Value:

    None - this routine will raise if necessary.

--*/

{
    LOG_FILE_INFORMATION LogFileInfo;
    ULONG InfoSize;
    LONGLONG RemainingLogFile;

    PAGED_CODE();

    //
    //  Check the stack usage first.
    //

    if (IoGetRemainingStackSize() < OVERFLOW_RECORD_THRESHHOLD) {

        //
        //  Now check the log file space.
        //

        InfoSize = sizeof( LOG_FILE_INFORMATION );

        RtlZeroMemory( &LogFileInfo, InfoSize );

        LfsReadLogFileInformation( IrpContext->Vcb->LogHandle,
                                   &LogFileInfo,
                                   &InfoSize );

        //
        //  Check that 1/4 of the log file is available.
        //

        if (InfoSize != 0) {

            RemainingLogFile = LogFileInfo.CurrentAvailable - LogFileInfo.TotalUndoCommitment;

            if ((RemainingLogFile <= 0) ||
                (RemainingLogFile < Int64ShraMod32(LogFileInfo.TotalAvailable, 2))) {

                NtfsRaiseStatus( IrpContext, STATUS_LOG_FILE_FULL, NULL, NULL );
            }
        }
    }

    return;
}


//
//  Local support routine
//

VOID
NtfsRunIsClear (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN LONGLONG RunLength
    )

/*++

Routine Description:

    This routine verifies that a group of clusters are unallocated.

Arguments:

    Vcb - Supplies the Vcb used in this operation

    StartingLcn - Supplies the start of the cluster run

    RunLength   - Supplies the length of the cluster run

Return Value:

    None.

--*/
{
    RTL_BITMAP Bitmap;
    PBCB BitmapBcb = NULL;
    BOOLEAN StuffAdded = FALSE;
    LONGLONG BitOffset;
    LONGLONG BitCount;
    LCN BaseLcn;
    LCN Lcn = StartingLcn;
    LONGLONG ValidDataLength;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRunIsClear\n") );

    ValidDataLength = Vcb->BitmapScb->Header.ValidDataLength.QuadPart;

    try {

        //
        //  Ensure that StartingLcn is not past the length of the bitmap.
        //

        if (StartingLcn > ValidDataLength * 8) {

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER, NULL, NULL );
        }

        while (RunLength > 0){

            //
            //  Access the next page of bitmap and update it
            //

            NtfsMapPageInBitmap(IrpContext, Vcb, Lcn, &BaseLcn, &Bitmap, &BitmapBcb);

            //
            //  Get offset into this page and bits to end of this page
            //

            BitOffset = Lcn - BaseLcn;
            BitCount = Bitmap.SizeOfBitMap - BitOffset;

            //
            //  Adjust for bits to end of page
            //

            if (BitCount > RunLength){

                BitCount = RunLength;
            }

            //
            //  If any bit is set get out
            //

            if (!RtlAreBitsClear( &Bitmap, (ULONG)BitOffset, (ULONG)BitCount)) {

                NtfsRaiseStatus( IrpContext, STATUS_ALREADY_COMMITTED, NULL, NULL );
            }

            StuffAdded = NtfsAddRecentlyDeallocated(Vcb, BaseLcn, &Bitmap);

            //
            //  Now if anything was added, check if the desired clusters are still
            //  free, else just free the stuff added.
            //

            if (StuffAdded) {

                //
                //  If any bit is set now, raise STATUS_DELETE_PENDING to indicate
                //  that the space will soon be free (or can be made free).
                //

                if (!RtlAreBitsClear( &Bitmap, (ULONG)BitOffset, (ULONG)BitCount)) {

                    NtfsRaiseStatus( IrpContext, STATUS_DELETE_PENDING, NULL, NULL );
                }

                //
                //  Free up resources
                //

                NtfsFreePool(Bitmap.Buffer);
                StuffAdded = FALSE;
            }

            NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Decrease remaining bits by amount checked in this page and move Lcn to beginning
            //  of next page
            //

            RunLength = RunLength - BitCount;
            Lcn = BaseLcn + Bitmap.SizeOfBitMap;
        }

    } finally {

        DebugUnwind(NtfsRunIsClear);

        //
        //  Free up resources
        //

        if(StuffAdded){ NtfsFreePool(Bitmap.Buffer); StuffAdded = FALSE; }

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    DebugTrace( -1, Dbg, ("NtfsRunIsClear -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsInitializeCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns
    )

/*++

Routine Description:

    This routine will initialize the cached run information.

Arguments:

    CachedRuns - Pointer to an uninitialized cached run structure.

Return Value:

    None - this routine will raise if unable to initialize the structure.

--*/

{
    USHORT Index;
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInitializeCachedRuns\n") );

    //
    //  Initialize the operating parameters.
    //

    CachedRuns->MaximumSize = 9000;
    CachedRuns->MinCount = 100;

    //
    //  Allocate pool for the arrays.
    //

    CachedRuns->LcnArray = NtfsAllocatePool( PagedPool,
                                             sizeof( NTFS_LCN_CLUSTER_RUN ) * NTFS_INITIAL_CACHED_RUNS );

    CachedRuns->LengthArray = NtfsAllocatePool( PagedPool,
                                                sizeof( USHORT ) * NTFS_INITIAL_CACHED_RUNS );

    //
    //  Mark all entries so that they can be detected as deleted.
    //

    for (Index = 0; Index < NTFS_INITIAL_CACHED_RUNS; Index += 1) {

        CachedRuns->LcnArray[Index].RunLength = 0;
        CachedRuns->LcnArray[Index].LengthIndex = NTFS_CACHED_RUNS_DEL_INDEX;
        CachedRuns->LengthArray[Index] = NTFS_CACHED_RUNS_DEL_INDEX;
    }

    CachedRuns->Avail = NTFS_INITIAL_CACHED_RUNS;

    //
    //  Allocate space for the histogram of small run lengths.
    //

    CachedRuns->Bins = NTFS_CACHED_RUNS_BIN_COUNT;
    CachedRuns->BinArray = NtfsAllocatePool( PagedPool,
                                             sizeof( USHORT ) * CachedRuns->Bins );
    RtlZeroMemory( CachedRuns->BinArray,
                   sizeof( USHORT ) * CachedRuns->Bins );

    //
    //  Allocate space for the windows of deleted entries in the sorted
    //  arrays.
    //

    CachedRuns->DelLcnCount = 0;
    CachedRuns->DelLengthCount = 0;
    CachedRuns->DeletedLcnWindows = NtfsAllocatePool( PagedPool,
                                                      sizeof( NTFS_DELETED_RUNS ) * NTFS_CACHED_RUNS_MAX_DEL_WINDOWS );
    CachedRuns->DeletedLengthWindows = NtfsAllocatePool( PagedPool,
                                                         sizeof( NTFS_DELETED_RUNS ) * NTFS_CACHED_RUNS_MAX_DEL_WINDOWS );

    //
    //  Create a window of deleted entries to cover the newly allocated
    //  entries.
    //

    NtfsAddDelWindow( CachedRuns, 0, CachedRuns->Avail - 1, TRUE );
    NtfsAddDelWindow( CachedRuns, 0, CachedRuns->Avail - 1, FALSE );

    //
    //  Clear the in use count.
    //

    CachedRuns->Used = 0;

    //
    //  Reset the longest freed run.
    //

    CachedRuns->LongestFreedRun = MAXLONGLONG;

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, FALSE, FALSE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsInitializeCachedRuns -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsReinitializeCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns
    )

/*++

Routine Description:

    This routine is called to reinitialize the cached runs array.

Arguments:

    CachedRuns - Pointer to a cached run structure.

Return Value:

    None

--*/

{
    USHORT Index;
    PNTFS_LCN_CLUSTER_RUN NewLcnArray;
    PUSHORT NewLengthArray;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReinitializeCachedRuns\n") );

    //
    //  Reallocate to get a smaller array.  If we get an allocation failure then simply
    //  empty the larger arrays.
    //

    if (CachedRuns->Avail != NTFS_INITIAL_CACHED_RUNS) {

        NewLcnArray = NtfsAllocatePoolNoRaise( PagedPool,
                                               sizeof( NTFS_LCN_CLUSTER_RUN ) * NTFS_INITIAL_CACHED_RUNS );

        if (NewLcnArray != NULL) {

            //
            //  Allocate the length array.
            //

            NewLengthArray = NtfsAllocatePoolNoRaise( PagedPool,
                                                      sizeof( USHORT ) * NTFS_INITIAL_CACHED_RUNS );

            //
            //  If we didn't get the Length array then simply use what we have already.
            //

            if (NewLengthArray == NULL) {

                NtfsFreePool( NewLcnArray );

            //
            //  Otherwise replace the Lcn and length arrays.
            //

            } else {

                NtfsFreePool( CachedRuns->LcnArray );
                CachedRuns->LcnArray = NewLcnArray;

                NtfsFreePool( CachedRuns->LengthArray );
                CachedRuns->LengthArray = NewLengthArray;

                CachedRuns->Avail = NTFS_INITIAL_CACHED_RUNS;
            }
        }
    }

    //
    //  Mark all entries so that they can be detected as deleted.
    //

    for (Index = 0; Index < CachedRuns->Avail; Index += 1) {

        CachedRuns->LcnArray[Index].RunLength = 0;
        CachedRuns->LcnArray[Index].LengthIndex = NTFS_CACHED_RUNS_DEL_INDEX;
        CachedRuns->LengthArray[Index] = NTFS_CACHED_RUNS_DEL_INDEX;
    }

    //
    //  Clear the histogram of run lengths.
    //

    RtlZeroMemory( CachedRuns->BinArray, sizeof( USHORT ) * CachedRuns->Bins );

    //
    //  Clear the list of windows of deleted entries.
    //

    CachedRuns->DelLcnCount = 0;
    CachedRuns->DelLengthCount = 0;

    //
    //  Create a window of deleted entries to cover all of the entries.
    //

    NtfsAddDelWindow( CachedRuns, 0, CachedRuns->Avail - 1, TRUE );
    NtfsAddDelWindow( CachedRuns, 0, CachedRuns->Avail - 1, FALSE );

    //
    //  Clear the in use count.
    //

    CachedRuns->Used = 0;

    //
    //  Reset the longest freed run.
    //

    CachedRuns->LongestFreedRun = MAXLONGLONG;

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, FALSE, FALSE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsReinitializeCachedRuns -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsUninitializeCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns
    )

/*++

Routine Description:

    This routine is called to clean up the cached run information.

Arguments:

    CachedRuns - Pointer to a cached run structure.  Be defensive and check that
    it is really initialized.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUninitializeCachedRuns\n") );

    if (CachedRuns->LcnArray != NULL) {

        NtfsFreePool( CachedRuns->LcnArray );
        CachedRuns->LcnArray = NULL;
    }

    if (CachedRuns->LengthArray != NULL) {

        NtfsFreePool( CachedRuns->LengthArray );
        CachedRuns->LengthArray = NULL;
    }

    if (CachedRuns->BinArray != NULL) {

        NtfsFreePool( CachedRuns->BinArray );
        CachedRuns->BinArray = NULL;
    }

    if (CachedRuns->DeletedLcnWindows != NULL) {

        NtfsFreePool( CachedRuns->DeletedLcnWindows );
        CachedRuns->DeletedLcnWindows = NULL;
    }

    if (CachedRuns->DeletedLengthWindows != NULL) {

        NtfsFreePool( CachedRuns->DeletedLengthWindows );
        CachedRuns->DeletedLengthWindows = NULL;
    }

    CachedRuns->Used = 0;
    CachedRuns->Avail = 0;
    CachedRuns->DelLcnCount = 0;
    CachedRuns->DelLengthCount = 0;
    CachedRuns->Bins = 0;

    DebugTrace( -1, Dbg, ("NtfsUninitializeCachedRuns -> VOID\n") );

    return;
}


//
//  Local support routine
//

BOOLEAN
NtfsLookupCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    OUT PLCN StartingLcn,
    OUT PLONGLONG RunLength,
    OUT PUSHORT Index OPTIONAL
    )

/*++

Routine Description:

    This routine is called to look up a specific Lcn in the cached runs structure.
    If found it will return the entire run.  It will also return the index in the
    Lcn array to use as an optimization in a later call.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    Lcn - This is the desired Lcn.

    StartingLcn - Address to store the Lcn which begins the run in the cached
        structure.  Typically this is the same as the Lcn above.

    RunLength - Address to store the length of the found run.

    Index - If specified we store the index for the run we found.  This can be
        used as an optimization if we later remove the run.

Return Value:

    BOOLEAN - TRUE if the run was found.  FALSE otherwise.

--*/

{
    PNTFS_LCN_CLUSTER_RUN ThisEntry;
    USHORT FoundIndex;
    BOOLEAN FoundLcn;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsLookupCachedLcn\n") );

    //
    //  Lookup a run containing the specific Lcn.
    //

    FoundLcn = NtfsPositionCachedLcn( CachedRuns,
                                      Lcn,
                                      &FoundIndex );

    //
    //  If we found the Lcn then return the full run.
    //

    if (FoundLcn) {

        ThisEntry = CachedRuns->LcnArray + FoundIndex;
        *StartingLcn = ThisEntry->Lcn;
        *RunLength = ThisEntry->RunLength;
    }

    if (ARGUMENT_PRESENT( Index )) {

        *Index = FoundIndex;
    }

    DebugTrace( -1, Dbg, ("NtfsLookupCachedLcn -> %01x\n", FoundLcn) );

    return FoundLcn;
}


//
//  Local support routine
//

BOOLEAN
NtfsGetNextCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT Index,
    OUT PLCN StartingLcn,
    OUT PLONGLONG RunLength
    )

/*++

Routine Description:

    This routine is called to find an entry in the Lcn array by position.
    It is assumed that the entry is not deleted.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    Index - Index to look up.  It might point beyond the array.

    StartingLcn - Address to store the Lcn at this position.

    RunLength - Address to store the RunLength at this position.

Return Value:

    BOOLEAN - TRUE if an entry was found, FALSE otherwise.

--*/

{
    PNTFS_LCN_CLUSTER_RUN ThisEntry;
    BOOLEAN FoundRun = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGetNextCachedLcn\n") );

    //
    //  If the input index is within the array then return the run.
    //

    if (Index < CachedRuns->Used) {

        ThisEntry = CachedRuns->LcnArray + Index;

        ASSERT( ThisEntry->RunLength );
        *StartingLcn = ThisEntry->Lcn;
        *RunLength = ThisEntry->RunLength;
        FoundRun = TRUE;
    }

    DebugTrace( -1, Dbg, ("NtfsGetNextCachedLcn -> %01x\n", FoundRun) );

    return FoundRun;
}


//
//  Local support routine
//

BOOLEAN
NtfsLookupCachedLcnByLength (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LONGLONG Length,
    IN BOOLEAN AllowShorter,
    IN LCN Lcn,
    OUT PLCN StartingLcn,
    OUT PLONGLONG RunLength,
    OUT PUSHORT Index OPTIONAL
    )

/*++

Routine Description:

    This routine is called to look up a cached run of a certain length.  We
    give caller any run of the given length or longer if possible.  If there
    is no such entry, we will use a shorter entry if allowed.

Arguments:

    CachedRuns - Pointer to the cached run structure.

    Length - Length of the run we are interested in.

    AllowShorter - whether to accept a shorter length run if nothing else is available

    Lcn - We try to find the run which is closest to this Lcn, but has the
        requested Length.

    StartingLcn - Address to store the starting Lcn of the run we found.

    RunLength - Address to store the length of the run we found.

    Index - If specified then this is the index in the RunLength array
        of the entry we found.  It can be used later to remove the entry.

Return Value:

    BOOLEAN - TRUE if an entry was found, FALSE otherwise.

--*/

{
    USHORT FoundIndex;
    PNTFS_LCN_CLUSTER_RUN ThisEntry;
    PNTFS_DELETED_RUNS DelWindow;
    BOOLEAN FoundRun;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsLookupCachedLcnByLength\n") );

    //
    //  Position ourselves for a run of a particular length.
    //

    FoundRun = NtfsPositionCachedLcnByLength( CachedRuns,
                                              Length,
                                              &Lcn,
                                              NULL,
                                              TRUE,
                                              &FoundIndex );

    if (!FoundRun) {

        //
        //  We didn't find a run with the desired length.  However if
        //  we aren't pointing past the end of the array then there
        //  is an entry available we can use.
        //

        if (FoundIndex < CachedRuns->Used) {

            FoundRun = TRUE;

        } else if (AllowShorter && (CachedRuns->Used > 0)) {

            //
            //  There are no larger entries, but there might be smaller
            //  ones and the caller has indicated we can use them.  The
            //  entry at the end of the list should be the largest
            //  available.
            //

            FoundIndex = CachedRuns->Used - 1;
            FoundRun = TRUE;
        }

        //
        //  Check and see if there is a suitable element at or near this index.
        //

        if (FoundRun) {

            //
            //  The entry has been deleted.  Get the window of deleted
            //  entries that covers it and see if there is a usable entry on either side.
            //

            if (CachedRuns->LengthArray[ FoundIndex ] == NTFS_CACHED_RUNS_DEL_INDEX) {

                DelWindow = NtfsGetDelWindow( CachedRuns,
                                              FoundIndex,
                                              FoundIndex,
                                              FALSE,
                                              NULL);

                ASSERT( DelWindow );
                ASSERT( DelWindow->StartIndex <= FoundIndex );
                ASSERT( DelWindow->EndIndex >= FoundIndex );

                //
                //  Use the entry just before the start of this window
                //  of deleted entries if one exists.
                //

                if (DelWindow->StartIndex > 0) {

                    FoundIndex = DelWindow->StartIndex - 1;

                //
                //  All of the entries are deleted.
                //

                } else {

                    FoundRun = FALSE;
                }

            //
            //  If we aren't considering a shorter element then this should be a longer one.
            //

            } else {

                ASSERT( AllowShorter ||
                        (CachedRuns->LcnArray[ CachedRuns->LengthArray[ FoundIndex ]].RunLength >= Length) );

            }
        }
    }

    //
    //  If we have a run then return the run information.
    //

    if (FoundRun) {

        ThisEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ FoundIndex ];
        ASSERT( ThisEntry->RunLength != 0 );
        *StartingLcn = ThisEntry->Lcn;
        *RunLength = ThisEntry->RunLength;

        if (ARGUMENT_PRESENT( Index )) {

            *Index = FoundIndex;
        }
    }

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, FALSE, FALSE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsLookupCachedLcnByLength -> %01x\n", FoundRun) );

    return FoundRun;
}


//
//  Local support routine
//

VOID
NtfsAddDelWindow (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN LcnList
    )

/*++

Routine Description:

    This routine is called to add the given range of indices to a window
    of entries known to be deleted.  If the entries are adjacent to an
    existing window, that window is extended.  Otherwise a new window is
    allocated.  If there is no space in the array to add a new window, the
    list is compacted.  Therefore, callers should be aware that indices may
    change across this call.  However we do guarantee that the indices in
    [FirstIndex..LastIndex] will not move.

    It is assumed that no window already includes the given index range.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    FirstIndex - Index that marks the start of the range of deleted entries.

    LastIndex - The index of the last entry in the range of deleted entries.

    LcnList - If TRUE, the indices are from the Lcn-sorted list.
        If FALSE, the indices are from the length-sorted list.

Return Value:

    None.

--*/

{
    USHORT WindowIndex;
    PUSHORT Count;
    PNTFS_DELETED_RUNS FirstWindow;
    PNTFS_DELETED_RUNS DelWindow;
    PNTFS_DELETED_RUNS NextWindow;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddDelWindow\n") );

    //
    //  Get pointers to the windows we will be updating.
    //

    if (LcnList) {

        Count = &CachedRuns->DelLcnCount;
        FirstWindow = CachedRuns->DeletedLcnWindows;

    } else {

        Count = &CachedRuns->DelLengthCount;
        FirstWindow = CachedRuns->DeletedLengthWindows;
    }

    ASSERT( *Count <= NTFS_CACHED_RUNS_MAX_DEL_WINDOWS );

    while (TRUE) {

        DebugTrace( 0, Dbg, ("*Count=%04x, FirstIndex=%04x, LastIndex=%04x\n", *Count, FirstIndex, LastIndex) );

        if (*Count != 0) {

            //
            //  Get the window of deleted entries that is closest to the range
            //  of indices we are adding.
            //

            DelWindow = NtfsGetDelWindow(CachedRuns,
                                         FirstIndex,
                                         LastIndex,
                                         LcnList,
                                         &WindowIndex );

            ASSERT( DelWindow != NULL );
            ASSERT( (DelWindow->EndIndex < FirstIndex) || (DelWindow->StartIndex > LastIndex) );

            DebugTrace( 0, Dbg, ("WindowIndex=%04x, StartIndex=%04x, EndIndex=%04x\n",
                                 WindowIndex, DelWindow->StartIndex, DelWindow->EndIndex) );

            //
            //  Check if our range extends this window.
            //

            if (DelWindow->EndIndex == (FirstIndex - 1)) {

                //
                //  Extend this window upwards.
                //

                DebugTrace( 0, Dbg, ("Extend window up from %04x to %04x\n",
                                     DelWindow->EndIndex, LastIndex) );

                DelWindow->EndIndex = LastIndex;

                //
                //  If not the last window then check if we ajoin the following window.
                //

                if (WindowIndex < (*Count - 1) ) {

                    NextWindow = DelWindow + 1;
                    ASSERT( NextWindow->StartIndex > LastIndex );

                    if (NextWindow->StartIndex == (LastIndex + 1) ) {

                        //
                        //  Combine these two windows.
                        //

                        DebugTrace( 0, Dbg, ("Combine with next window up to %04x\n",
                                             NextWindow->EndIndex) );

                        DelWindow->EndIndex = NextWindow->EndIndex;

                        //
                        //  Delete the additional window.
                        //

                        NtfsDeleteDelWindow( CachedRuns,
                                             LcnList,
                                             WindowIndex + 1 );
                    }
                }

                break;

            //
            //  Check if we extend this window downwards.
            //

            } else if (DelWindow->StartIndex == (LastIndex + 1)) {

                DebugTrace( 0, Dbg, ("Extend window down from %04x to %04x\n",
                                     DelWindow->EndIndex, FirstIndex) );

                DelWindow->StartIndex = FirstIndex;

                //
                //  Check if we join the previous window if present.
                //

                if (WindowIndex > 0) {

                    NextWindow = DelWindow - 1;
                    ASSERT( NextWindow->EndIndex < FirstIndex );

                    if (NextWindow->EndIndex == (FirstIndex - 1) ) {

                        //
                        //  Combine these two windows.
                        //

                        DebugTrace( 0,
                                    Dbg,
                                    ("Combine with prev window up to %04x\n", NextWindow->StartIndex) );

                        NextWindow->EndIndex = DelWindow->EndIndex;

                        //
                        //  Delete the unused window.
                        //

                        NtfsDeleteDelWindow( CachedRuns,
                                             LcnList,
                                             WindowIndex );
                    }
                }

                break;

            //
            //  Add a new window after the window we found.
            //

            } else if (DelWindow->EndIndex < FirstIndex) {

                //
                //  Insert the new window after WindowIndex.
                //

                DebugTrace( 0, Dbg, ("New window at %04x + 1\n", WindowIndex) );
                WindowIndex += 1;

            } else {

                //
                //  Insert the new window at WindowIndex.
                //

                DebugTrace( 0, Dbg, ("New window at %04x\n", WindowIndex) );
            }

        } else {

            //
            //  Just create a new window at index 0.
            //

            DebugTrace( 0, Dbg, ("First new window\n") );
            WindowIndex = 0;
        }

        //
        //  If we reach this point then we need to make a new window.  We have the position
        //  we want to put the window.
        //
        //  If we don't have an available run then compact two of the existing runs.
        //

        if (*Count == NTFS_CACHED_RUNS_MAX_DEL_WINDOWS) {

            DebugTrace( 0, Dbg, ("Compact\n") );

            NtfsCompactCachedRuns( CachedRuns,
                                   FirstIndex,
                                   LastIndex,
                                   LcnList );

            ASSERT( *Count < NTFS_CACHED_RUNS_MAX_DEL_WINDOWS );

            //
            //  Retry the loop to find the correct window position.
            //

            continue;
        }

        //
        //  Position ourselves at the insert point.
        //

        DelWindow = FirstWindow + WindowIndex;

        //
        //  Right copy the windows to make a space if we aren't at the end.
        //

        if (WindowIndex < *Count) {

            DebugTrace( 0, Dbg, ("Copy up window indices from %04x, %04x entries\n",
                                 WindowIndex,
                                 *Count - WindowIndex) );

            RtlMoveMemory( DelWindow + 1,
                           DelWindow,
                           sizeof( NTFS_DELETED_RUNS ) * (*Count - WindowIndex) );
        }

        //
        //  Put the new information in DelWindow
        //

        DelWindow->StartIndex = FirstIndex;
        DelWindow->EndIndex = LastIndex;

        //
        //  Increment the windows count.
        //

        *Count += 1;
        break;
    }

    ASSERT( (CachedRuns->DelLcnCount > 0) || !LcnList );
    ASSERT( (CachedRuns->DelLengthCount > 0) || LcnList );

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {

        //
        //  Make certain that the windows are in order and don't overlap.
        //

        for (WindowIndex = 0, DelWindow = NextWindow = FirstWindow;
             WindowIndex < *Count;
             WindowIndex += 1, NextWindow += 1) {

            ASSERT( NextWindow->StartIndex <= NextWindow->EndIndex );
            if (NextWindow != DelWindow) {

                ASSERT( NextWindow->StartIndex > (DelWindow->EndIndex + 1) );
                DelWindow += 1;
            }
        }
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsAddDelWindow -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsShrinkDelWindow (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN BOOLEAN ShrinkFromStart,
    IN BOOLEAN LcnWindow,
    IN USHORT WindowIndex
    )

/*++

Routine Description:

    This routine is called to remove one entry from the given window
    of entries known to be deleted.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    ShrinkFromStart - If TRUE, remove the first entry in the window.
        If FALSE, remove the last entry in the window.

    LcnWindow - If TRUE, the window is of Lcn indices.  If FALSE, the window is
        of length indices.

    WindowIndex - The index of the window.

Return Value:

    None.

--*/

{
    PUSHORT Count;
    PNTFS_DELETED_RUNS DelWindow;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsShrinkDelWindow\n") );
    DebugTrace( 0, Dbg, ("WindowIndex %04x\n", WindowIndex) );

    if (LcnWindow) {

        Count = &CachedRuns->DelLcnCount;
        DelWindow = (CachedRuns->DeletedLcnWindows + WindowIndex);

    } else {

        Count = &CachedRuns->DelLengthCount;
        DelWindow = (CachedRuns->DeletedLengthWindows + WindowIndex);
    }

    //
    //  Caller better give us something in the correct range.
    //

    ASSERT( WindowIndex < *Count );

    //
    //  If the window has a single entry then remove it.
    //

    if (DelWindow->StartIndex == DelWindow->EndIndex) {

        NtfsDeleteDelWindow( CachedRuns,
                             LcnWindow,
                             WindowIndex );

    //
    //  Remove the first entry if desired.
    //

    } else if (ShrinkFromStart) {

        DelWindow->StartIndex += 1;

    //
    //  Otherwise the last entry.
    //

    } else {

        DelWindow->EndIndex -= 1;
    }

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {

        PNTFS_DELETED_RUNS FirstWindow;
        PNTFS_DELETED_RUNS NextWindow;
        USHORT Index;

        //
        //  Make certain that the windows are in order and don't overlap.
        //

        if (LcnWindow) {

            FirstWindow = CachedRuns->DeletedLcnWindows;

        } else {

            FirstWindow = CachedRuns->DeletedLengthWindows;
        }

        for (Index = 0, DelWindow = NextWindow = FirstWindow;
             Index < *Count;
             Index += 1, NextWindow += 1) {

            ASSERT( NextWindow->StartIndex <= NextWindow->EndIndex );
            if (NextWindow != DelWindow) {

                ASSERT( NextWindow->StartIndex > (DelWindow->EndIndex + 1) );
                DelWindow += 1;
            }
        }
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsShrinkDelWindow -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsDeleteDelWindow (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN BOOLEAN LcnWindow,
    IN USHORT WindowIndex
    )

/*++

Routine Description:

    This routine is called to remove the given window of entries known to
    be deleted.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    LcnWindow - If TRUE, the window is of Lcn indices.  If FALSE, the window is of length indices.

    WindowIndex - The index of the window.

Return Value:

    None.

--*/

{
    PUSHORT Count;
    PNTFS_DELETED_RUNS FirstWindow;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeleteDelWindow\n") );
    DebugTrace( 0, Dbg, ("WindowIndex %04x\n", WindowIndex) );

    //
    //  Use the correct deleted window array.
    //

    if (LcnWindow) {

        Count = &CachedRuns->DelLcnCount;
        FirstWindow = CachedRuns->DeletedLcnWindows;

    } else {

        Count = &CachedRuns->DelLengthCount;
        FirstWindow = CachedRuns->DeletedLengthWindows;
    }

    //
    //  Delete this window by shifting any existing windows from the right.
    //

    if (WindowIndex < (*Count - 1)) {

        //
        //  Remove the deleted window.
        //

        DebugTrace( 0,
                    Dbg,
                    ("Move from WindowIndex %04x, %04x entries\n", WindowIndex + 1, *Count - 1 - WindowIndex) );

        RtlMoveMemory( FirstWindow + WindowIndex,
                       FirstWindow + WindowIndex + 1,
                       sizeof( NTFS_DELETED_RUNS ) * (*Count - 1 - WindowIndex) );
    }

    //
    //  Decrement the windows count.
    //

    *Count -= 1;

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {

        PNTFS_DELETED_RUNS DelWindow;
        PNTFS_DELETED_RUNS NextWindow;

        //
        //  Make certain that the windows are in order and don't overlap.
        //

        for (WindowIndex = 0, DelWindow = NextWindow = FirstWindow;
             WindowIndex < *Count;
             WindowIndex += 1, NextWindow += 1) {

            ASSERT( NextWindow->StartIndex <= NextWindow->EndIndex );

            //
            //  Check against previous window if not at the first element.  We don't allow
            //  adjacent windows to touch because they should have merged.
            //

            if (NextWindow != DelWindow) {

                ASSERT( NextWindow->StartIndex > (DelWindow->EndIndex + 1) );
                DelWindow += 1;
            }
        }
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsDeleteDelWindow -> VOID\n") );

    return;
}


//
//  Local support routine
//


PNTFS_DELETED_RUNS
NtfsGetDelWindow (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN LcnList,
    OUT PUSHORT WindowIndex OPTIONAL
    )

/*++

Routine Description:

    This routine is called to find the window of entries known to be deleted
    that is closest to the given range of indices.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    FirstIndex - Index that marks the start of the range.

    LastIndex - The index of the last entry in the range.

    LcnList - If TRUE, the indices are from the Lcn-sorted list.
        If FALSE, the indices are from the length-sorted list.

    WindowIndex - If specified, the index of the returned window is put here.

Return Value:

    PNTFS_DELETED_RUNS - Returns the closest window of deleted entries, or
        NULL is there are no windows.

--*/

{
    USHORT Count;
    USHORT Distance;
    USHORT Max, Min, Current;
    BOOLEAN Overlap = FALSE;
    PNTFS_DELETED_RUNS FirstWindow, NextWindow;
    PNTFS_DELETED_RUNS DelWindow = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGetDelWindow\n") );

    //
    //  Get pointers to the windows we will be searching.
    //

    if (LcnList) {

        Count = CachedRuns->DelLcnCount;
        FirstWindow = CachedRuns->DeletedLcnWindows;

    } else {

        Count = CachedRuns->DelLengthCount;
        FirstWindow = CachedRuns->DeletedLengthWindows;
    }

    if (Count != 0) {

        //
        //  Perform a binary search to find the next element to the right.
        //  We always do at least one comparison to determine if a single element
        //  is to the left or right.
        //

        Min = 0;
        Max = Count - 1;

        while (TRUE) {

            Current = (USHORT) (((ULONG) Max + Min) / 2);
            NextWindow = FirstWindow + Current;

            if (LastIndex < NextWindow->StartIndex) {

                //
                //  We are done if Max and Min match.  We test before changing Max
                //  because if Min is still 0 then we've never looked at it.
                //

                if (Min == Max) {

                    break;
                }

                Max = Current;

            } else if (LastIndex > NextWindow->EndIndex) {

                //
                //  Advance Min past this point.
                //

                Min = Current + 1;

                //
                //  Break if past Max.  This should only occur if our range is
                //  past the last window.
                //

                if (Min > Max) {

                    ASSERT( Min == Count );
                    break;
                }

            } else {

                //
                //  Simple case.  This is an overlap.
                //

                Overlap = TRUE;
                Min = Current;
                break;
            }
        }

        //
        //  Now find nearest.  First check if we are beyond the end of the array.
        //

        if (Min == Count) {

            Min = Count - 1;

        //
        //  If we aren't at the first entry and didn't already detect an overlap then
        //  compare adjacent entries.
        //

        } else if ((Min != 0) && !Overlap) {

            DelWindow = FirstWindow + Min - 1;
            NextWindow = DelWindow + 1;

            //
            //  Test that there is no overlap with the previous
            //  window.  If no overlap then check for the distance to
            //  the adjacent ranges.
            //

            if (FirstIndex > DelWindow->EndIndex) {

                ASSERT( NextWindow->StartIndex > LastIndex );
                Distance = NextWindow->StartIndex - LastIndex;

                if (Distance > FirstIndex - DelWindow->EndIndex) {

                    //
                    //  Move to the previous window.
                    //

                    Min -= 1;
                }

            //
            //  The previous window has an overlap.
            //

            } else {

                Min -= 1;
            }
        }

        if (ARGUMENT_PRESENT( WindowIndex )) {

            *WindowIndex = Min;
        }

        DelWindow = FirstWindow + Min;

        DebugTrace( 0, Dbg, ("Index -> %04x\n", Min) );
    }

    DebugTrace( -1, Dbg, ("NtfsGetDelWindow -> 0x%x\n", DelWindow) );

    return DelWindow;
}


//
//  Local support routine
//

USHORT
NtfsGetCachedLengthInsertionPoint (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    IN LONGLONG Length
    )

/*++

Routine Description:

    This routine is called to add a new entry in the Lcn-sorted and
    length-sorted lists.  It is assumed that the caller has made certain
    that this new entry will not overlap any existing entries.

    This routine may chose not to add the new entry to the lists.  If adding
    this entry would force an equally or more desirable run out of the cache,
    we don't make the change.

    This routine can compact the lists.  Therefore, the caller should not
    assume that entries will not move.

    If this routine finds an insertion point and there is already an undeleted
    at that position, the new run sorts before it.  If the new run sorts
    higher than the entry at index CachedRuns->Avail - 1, we will return an
    index of CachedRuns->Avail.  The caller must check for this case and
    not access an entry beyond the list size.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    Lcn - Lcn to insert.

    Length - Length of the run to insert.

Return Value:

    USHORT - The index into the length-sorted table at which the given Length
        should be inserted.  If the entry should not be inserted,
        NTFS_CACHED_RUNS_DEL_INDEX is returned.

--*/

{
    BOOLEAN FoundRun;
    USHORT Index;
    LONGLONG RunLength;
    PNTFS_LCN_CLUSTER_RUN ThisEntry;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGetCachedLengthInsertionPoint\n") );

    if ((CachedRuns->Used == CachedRuns->Avail) &&
        (CachedRuns->DelLengthCount == 0) ) {

        //
        //  Grow the lists.
        //

        if (!NtfsGrowCachedRuns( CachedRuns )) {

            //
            //  We couldn't grow the lists.
            //

            if (CachedRuns->Used == 0) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            //
            //  Adding this entry will force another one to be deleted.
            //  Make sure the new entry is more desirable to add than
            //  all existing entries.
            //
            //  The check is to make certain that we have more than enough
            //  entries of a size smaller than Length such that we would
            //  be willing to delete one.
            //

            RunLength = 0;

            for (Index = 0;
                 (Index < CachedRuns->Bins) && (Index < (Length - 1) );
                 Index += 1) {

                if (CachedRuns->BinArray[ Index ] > CachedRuns->MinCount) {

                    //
                    //  We should delete an entry with RunLength = Index + 1
                    //

                    RunLength = Index + 1;
                    break;
                }
            }

            if (RunLength != 0) {

                //
                //  Find an entry of this length.
                //

                FoundRun = NtfsPositionCachedLcnByLength( CachedRuns,
                                                          RunLength,
                                                          NULL,
                                                          NULL,
                                                          TRUE,
                                                          &Index );
                ASSERT( FoundRun );
                ASSERT( (CachedRuns->LengthArray[Index] != NTFS_CACHED_RUNS_DEL_INDEX) &&
                        (CachedRuns->LcnArray[CachedRuns->LengthArray[Index]].RunLength != 0) );

                //
                //  Delete the entry.
                //

                ThisEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ Index ];
                NtfsDeleteCachedRun( CachedRuns,
                                     CachedRuns->LengthArray[ Index ],
                                     Index );

            } else {

                //
                //  Do not add the new entry.
                //

                DebugTrace( -1,
                            Dbg,
                            ("NtfsGetCachedLengthInsertionPoint -> 0x%x\n", NTFS_CACHED_RUNS_DEL_INDEX) );
                return NTFS_CACHED_RUNS_DEL_INDEX;
            }
        }
    }

    //
    //  Get the insertion point for the new entry.
    //  If FoundRun is FALSE, the entry pointed to by Index is either deleted
    //  or sorts higher than the new one.
    //

    FoundRun = NtfsPositionCachedLcnByLength( CachedRuns,
                                              Length,
                                              &Lcn,
                                              NULL,
                                              TRUE,
                                              &Index );

    //
    //  Index points to the closest run by Lcn that has a RunLength equal
    //  to Length.  We need to check to see if the new entry should be
    //  inserted before or after it.
    //

    if (FoundRun) {

        ThisEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ Index ];
        if (ThisEntry->Lcn < Lcn) {

            //
            //  The new run should come after this one.
            //

            Index += 1;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsGetCachedLengthInsertionPoint -> 0x%x\n", Index) );

    return Index;
}


//
//  Local support routine
//

VOID
NtfsInsertCachedRun (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    IN LONGLONG Length,
    IN USHORT LcnIndex
    )

/*++

Routine Description:

    This routine is called to add a new entry in the Lcn-sorted and
    length-sorted lists.  It is assumed that the caller has made certain
    that this new entry will not overlap any existing entries.

    This routine may chose not to add the new entry to the lists.  If adding
    this entry would force an equally or more desirable run out of the cache,
    we don't make the change.

    This routine can compact the lists.  Therefore, the caller should not
    assume that entries will not move.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    Lcn - Lcn to insert.

    Length - Length of the run to insert.

    LcnIndex - Index into the Lcn-sorted list where this new entry should
        be added.  Any non-deleted entry already at this position sorts
        after the new entry.

Return Value:

    None.

--*/

{
    USHORT Count;
    USHORT RunIndex;
    USHORT LenIndex;
    USHORT WindowIndex;
    PNTFS_DELETED_RUNS DelWindow;
    PNTFS_LCN_CLUSTER_RUN ThisEntry;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInsertCachedRun\n") );

    //
    //  Find the position in the length-sorted list to insert this new
    //  entry.  This routine will grow the lists if necessary.
    //

    LenIndex = NtfsGetCachedLengthInsertionPoint( CachedRuns,
                                                  Lcn,
                                                  Length );

    //
    //  This entry will not be added to the lists because it would degrade the
    //  distribution of the length entries.
    //

    if (LenIndex == NTFS_CACHED_RUNS_DEL_INDEX) {

        return;
    }

    //
    //  Find the closest window of deleted entries to LcnIndex.
    //

    DelWindow = NtfsGetDelWindow( CachedRuns,
                                  LcnIndex,
                                  LcnIndex,
                                  TRUE,
                                  &WindowIndex );

    ASSERT( DelWindow != NULL );
    ASSERT( (DelWindow->EndIndex + 1 < LcnIndex) ||
            (LcnIndex < CachedRuns->Avail) );

    //
    //  Move the entries between LcnIndex and the start of the
    //  window up to make room for this new entry.
    //

    if (DelWindow->StartIndex > LcnIndex) {

        RtlMoveMemory( CachedRuns->LcnArray + LcnIndex + 1,
                       CachedRuns->LcnArray + LcnIndex,
                       sizeof( NTFS_LCN_CLUSTER_RUN ) * (DelWindow->StartIndex - LcnIndex) );

        //
        //  Update the indices in the Length-sorted list to reflect the
        //  move of the lcn-sorted entries.
        //

        for (Count = LcnIndex + 1;
             Count < DelWindow->StartIndex + 1;
             Count += 1) {

            RunIndex = CachedRuns->LcnArray[ Count ].LengthIndex;
            ASSERT( RunIndex != NTFS_CACHED_RUNS_DEL_INDEX );
            CachedRuns->LengthArray[ RunIndex ] += 1;
        }

        //
        //  Check if we are using the deleted window at the tail of the array.  If
        //  so then we just increased the number of entries in use with this
        //  right shift.
        //

        if (DelWindow->StartIndex == CachedRuns->Used) {

            CachedRuns->LengthArray[ CachedRuns->Used ] = NTFS_CACHED_RUNS_DEL_INDEX;
            CachedRuns->Used += 1;
        }

        //
        //  Update the window.
        //

        NtfsShrinkDelWindow( CachedRuns,
                             TRUE,
                             TRUE,
                             WindowIndex);

    //
    //  Check if we need to move entries down to the nearest deleted window.
    //

    } else if ((DelWindow->EndIndex + 1) < LcnIndex) {

        //
        //  Update the insertion point to be LcnIndex - 1 and make a gap there
        //

        LcnIndex -= 1;

        //
        //  Move the entries between the end of the window and
        //  LcnIndex down to make room for this new entry.
        //

        RtlMoveMemory( CachedRuns->LcnArray + DelWindow->EndIndex,
                       CachedRuns->LcnArray + DelWindow->EndIndex + 1,
                       sizeof( NTFS_LCN_CLUSTER_RUN ) * (LcnIndex - DelWindow->EndIndex) );

        //
        // Update the indices in the Length-sorted list to reflect the
        // move of the lcn-sorted entries.
        //

        for (Count = DelWindow->EndIndex;
             Count < LcnIndex;
             Count += 1) {

            RunIndex = CachedRuns->LcnArray[ Count ].LengthIndex;
            ASSERT( RunIndex != NTFS_CACHED_RUNS_DEL_INDEX );
            CachedRuns->LengthArray[ RunIndex ] -= 1;
        }

        //
        //  Update the window.
        //

        NtfsShrinkDelWindow( CachedRuns,
                             FALSE,
                             TRUE,
                             WindowIndex);

    //
    //  The window is adjacent to LcnIndex and the entry at LcnIndex
    //  sorts higher than the new run.  No moves are necessary.
    //  Decrement LcnIndex.
    //

    } else if ((DelWindow->EndIndex + 1) == LcnIndex) {

        LcnIndex -= 1;

        //
        //  Update the window.
        //

        NtfsShrinkDelWindow( CachedRuns,
                             FALSE,
                             TRUE,
                             WindowIndex);
    } else {

        //
        //  The window covers LcnIndex.  No moves are necessary.
        //

        if (DelWindow->StartIndex == LcnIndex) {

            //
            //  Update the window.
            //

            NtfsShrinkDelWindow( CachedRuns,
                                 TRUE,
                                 TRUE,
                                 WindowIndex);

        } else if (DelWindow->EndIndex == LcnIndex) {

            //
            //  Update the window.
            //

            NtfsShrinkDelWindow( CachedRuns,
                                 FALSE,
                                 TRUE,
                                 WindowIndex);
        } else {

            //
            //  LcnIndex does not fall on the first or last entry in
            //  the window, we will update it to do so.  Otherwise we
            //  would have to split the window, with no real gain.
            //

            LcnIndex = DelWindow->EndIndex;

            //
            //  Update the window.
            //

            NtfsShrinkDelWindow( CachedRuns,
                                 FALSE,
                                 TRUE,
                                 WindowIndex);
        }
    }

    ASSERT( LcnIndex < CachedRuns->Avail );
    ASSERT( LcnIndex <= CachedRuns->Used );

    //
    //  Find the closest window of deleted entries to LenIndex.
    //

    DelWindow = NtfsGetDelWindow( CachedRuns,
                                  LenIndex,
                                  LenIndex,
                                  FALSE,
                                  &WindowIndex);
    ASSERT( DelWindow != NULL );
    ASSERT( (DelWindow->EndIndex < (LenIndex - 1)) ||
            (LenIndex < CachedRuns->Avail) );

    //
    //  The window is to the right.  Go ahead and
    //  move the entries between LenIndex and the start of the
    //  window up to make room for this new entry.
    //

    if (DelWindow->StartIndex > LenIndex) {

        RtlMoveMemory( CachedRuns->LengthArray + LenIndex + 1,
                       CachedRuns->LengthArray + LenIndex,
                       sizeof( USHORT ) * (DelWindow->StartIndex - LenIndex) );

        //
        // Update the indices in the Lcn-sorted list to reflect the
        // move of the length-sorted entries.
        //

        for (Count = LenIndex + 1;
             Count < DelWindow->StartIndex + 1;
             Count += 1) {

            RunIndex = CachedRuns->LengthArray[ Count ];
            ASSERT( RunIndex != NTFS_CACHED_RUNS_DEL_INDEX );
            CachedRuns->LcnArray[ RunIndex ].LengthIndex += 1;
        }

        //
        //  We have just increased the number of entries in use with this
        //  right shift.
        //

        if (DelWindow->StartIndex == CachedRuns->Used) {

            CachedRuns->LcnArray[ CachedRuns->Used ].RunLength = 0;
            CachedRuns->LcnArray[ CachedRuns->Used ].LengthIndex = NTFS_CACHED_RUNS_DEL_INDEX;
            CachedRuns->Used += 1;
        }

        //
        //  Update the window.
        //

        NtfsShrinkDelWindow( CachedRuns,
                             TRUE,
                             FALSE,
                             WindowIndex);

    //
    //  The deleted window is to the left.  Slide everything to the left and
    //  Update the insertion point to be LenIndex - 1 and make a gap there.
    //

    } else if ((DelWindow->EndIndex + 1) < LenIndex) {

        LenIndex -= 1;

        //
        //  Move the entries between the end of the window and
        //  LenIndex down to make room for this new entry.
        //

        RtlMoveMemory( CachedRuns->LengthArray + DelWindow->EndIndex,
                       CachedRuns->LengthArray + DelWindow->EndIndex + 1,
                       sizeof( USHORT ) * (LenIndex - DelWindow->EndIndex) );

        //
        // Update the indices in the Lcn-sorted list to reflect the
        // move of the length-sorted entries.
        //

        for (Count = DelWindow->EndIndex;
             Count < LenIndex;
             Count += 1) {

            RunIndex = CachedRuns->LengthArray[ Count ];
            ASSERT( RunIndex != NTFS_CACHED_RUNS_DEL_INDEX );
            CachedRuns->LcnArray[ RunIndex ].LengthIndex -= 1;
        }

        //
        //  Update the window.
        //

        NtfsShrinkDelWindow( CachedRuns,
                             FALSE,
                             FALSE,
                             WindowIndex);

    //
    //  The window is adjacent to LenIndex and the entry at LenIndex
    //  sorts higher than the new run.  No moves are necessary.
    //  Decrement LenIndex.
    //

    } else if ((DelWindow->EndIndex + 1) == LenIndex) {

        LenIndex -= 1;

        //
        //  Update the window.
        //

        NtfsShrinkDelWindow( CachedRuns,
                             FALSE,
                             FALSE,
                             WindowIndex);
    //
    //  The window covers LenIndex.  No moves are necessary.
    //

    } else {

        if (DelWindow->StartIndex == LenIndex) {

            //
            //  Update the window.
            //

            NtfsShrinkDelWindow( CachedRuns,
                                 TRUE,
                                 FALSE,
                                 WindowIndex);

        } else if (DelWindow->EndIndex == LenIndex) {

            //
            //  Update the window.
            //

            NtfsShrinkDelWindow( CachedRuns,
                                 FALSE,
                                 FALSE,
                                 WindowIndex);
        } else {

            //
            //  LenIndex does not fall on the first or last entry in
            //  the window, we will update it to do so.  Otherwise we
            //  would have to split the window, with no real gain.
            //

            LenIndex = DelWindow->EndIndex;

            //
            //  Update the window.
            //

            NtfsShrinkDelWindow( CachedRuns,
                                 FALSE,
                                 FALSE,
                                 WindowIndex);
        }
    }

    ASSERT( LenIndex < CachedRuns->Avail );
    ASSERT( LenIndex <= CachedRuns->Used );

    //
    //  Insert the new entry at LcnIndex, LenIndex
    //

    ThisEntry = CachedRuns->LcnArray + LcnIndex;
    ThisEntry->Lcn = Lcn;
    ThisEntry->RunLength = Length;
    ThisEntry->LengthIndex = LenIndex;
    CachedRuns->LengthArray[ LenIndex ] = LcnIndex;

    //
    //  Update the count of entries of this size.
    //

    if (Length <= CachedRuns->Bins) {

        CachedRuns->BinArray[ Length - 1 ] += 1;
    }

    //
    //  Check if we've grown the number of entries used.
    //

    if (LcnIndex == CachedRuns->Used) {

        //
        //  Increase the count of the number of entries in use.
        //

        ASSERT( (CachedRuns->LengthArray[ CachedRuns->Used ] == NTFS_CACHED_RUNS_DEL_INDEX) ||
                (LenIndex == CachedRuns->Used) );

        CachedRuns->Used += 1;
    }

    if (LenIndex == CachedRuns->Used) {

        //
        //  Increase the count of the number of entries in use.
        //

        ASSERT( (CachedRuns->LcnArray[ CachedRuns->Used ].RunLength == 0) &&
                (CachedRuns->LcnArray[ CachedRuns->Used ].LengthIndex == NTFS_CACHED_RUNS_DEL_INDEX) );

        CachedRuns->Used += 1;
    }

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, FALSE, FALSE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsInsertCachedRun -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsDeleteCachedRun (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT LcnIndex,
    IN USHORT LenIndex
    )

/*++

Routine Description:

    This routine is called to delete an Lcn run from the cached run arrays.

    It is possible that the lists will be compacted.  This will happen if
    we use the last window of deleted entries that we are allowed to cache
    for either the Lcn-sorted or Length-sorted lists.  Therefore, callers
    should be aware that indices may change across this call.  However we do
    guarantee that the indices LcnIndex and LenIndex will not move.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    LcnIndex - The index in the Lcn-sorted list of the entry to be deleted.

    LenIndex - The index in the Length-sorted list of the entry to be deleted.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeleteCachedRun\n") );

    ASSERT( LcnIndex != NTFS_CACHED_RUNS_DEL_INDEX );
    ASSERT( LenIndex != NTFS_CACHED_RUNS_DEL_INDEX );

    //
    //  Update count of how many entries have this length.
    //

    if (CachedRuns->LcnArray[ LcnIndex ].RunLength <= CachedRuns->Bins) {

        CachedRuns->BinArray[CachedRuns->LcnArray[LcnIndex].RunLength - 1] -= 1;
    }

    //
    //  Update the entries so they appear to be deleted.
    //

    CachedRuns->LcnArray[ LcnIndex ].RunLength = 0;
    CachedRuns->LcnArray[ LcnIndex ].LengthIndex = NTFS_CACHED_RUNS_DEL_INDEX;
    CachedRuns->LengthArray[ LenIndex ] = NTFS_CACHED_RUNS_DEL_INDEX;

    //
    //  Create windows of deleted entries to cover this newly deleted
    //  entry.
    //

    NtfsAddDelWindow( CachedRuns, LcnIndex, LcnIndex, TRUE );
    NtfsAddDelWindow( CachedRuns, LenIndex, LenIndex, FALSE );

#ifdef NTFS_CHECK_CACHED_RUNS

    //
    //  We will not check sort orders in NtfsVerifyCachedRuns because we
    //  could be making this call as part of deleting runs that have an
    //  overlap with a newly inserted run.  This could give false corruption
    //  warnings.
    //

    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, TRUE, TRUE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsDeleteCachedRun -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsInsertCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    IN LONGLONG Length
    )

/*++

Routine Description:

    This routine is called to insert an Lcn run into the cached run arrays.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    Lcn - Lcn to insert.

    Length - Length of the run to insert.

Return Value:

    None

--*/

{
    USHORT NextIndex;
    USHORT ThisIndex;
    LCN StartingLcn;
    LCN SaveLcn;
    LONGLONG RunLength;
    LONGLONG OldLength = 0;
    LCN EndOfNewRun;
    LCN EndOfThisRun;
    LCN EndOfNextRun;

    BOOLEAN ExtendedEntry = FALSE;
    BOOLEAN ScanForOverlap = FALSE;

    PNTFS_DELETED_RUNS DelWindow;
    PNTFS_LCN_CLUSTER_RUN ThisEntry, NextEntry;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInsertCachedLcn\n") );

    //
    //  Return immediately if length is zero.
    //

    if (Length == 0) {

        DebugTrace( -1, Dbg, ("NtfsInsertCachedLcn -> VOID\n") );
        return;
    }

    //
    //  Lookup the Lcn at the start of our run.
    //

    NtfsLookupCachedLcn( CachedRuns,
                         Lcn,
                         &StartingLcn,
                         &RunLength,
                         &NextIndex );

    //
    //  We have a run to insert.  We need to deal with the following cases.
    //  Our strategy is to position ThisEntry at the position we want to store
    //  the resulting run.  Then remove any subsequent runs we overlap with, possibly
    //  extending the run we are working with.
    //
    //
    //      1 - We can merge with the prior run.  Save that position
    //          and remove any following slots we overlap with.
    //
    //      2 - We are beyond the array.  Simply store our run in
    //          this slot.
    //
    //      3 - We don't overlap with the current run.  Simply slide
    //          the runs up and insert a new entry.
    //
    //      4 - We are contained within the current run.  There is nothing
    //          we need to do.
    //
    //      5 - We overlap with the current run.  Use that slot
    //          and remove any following slots we overlap with.
    //

    NextEntry = CachedRuns->LcnArray + NextIndex;

    //
    //  Find a previous entry if present.
    //

    ThisIndex = NTFS_CACHED_RUNS_DEL_INDEX;

    if (NextIndex > 0) {

        ThisIndex = NextIndex - 1;
        ThisEntry = CachedRuns->LcnArray + ThisIndex;

        //
        //  If the entry has been deleted it must be ignored.  Get the
        //  window of deleted entries that covers it.
        //

        if (ThisEntry->RunLength == 0) {

            DelWindow = NtfsGetDelWindow( CachedRuns,
                                          ThisIndex,
                                          ThisIndex,
                                          TRUE,
                                          NULL);
            ASSERT( DelWindow != NULL );
            ASSERT( DelWindow->EndIndex >= ThisIndex );
            ASSERT( DelWindow->StartIndex <= ThisIndex );

            //
            //  Move to the entry just before the deleted window.
            //

            if (DelWindow->StartIndex > 0) {

                ThisIndex = DelWindow->StartIndex - 1;
                ThisEntry = CachedRuns->LcnArray + ThisIndex;

            } else {

                //
                //  All entries preceding NextEntry are deleted.
                //

                ThisIndex = NTFS_CACHED_RUNS_DEL_INDEX;
            }
        }

        //
        //  Capture the end of the run.  It's invalid if we don't have
        //  a real index but all of the users of this will know that.
        //

        EndOfThisRun = ThisEntry->Lcn + ThisEntry->RunLength;
    }


    //
    //  Let's remember the end of the next run if present.
    //

    EndOfNewRun = Lcn + Length;

    if ((NextIndex < CachedRuns->Used) &&
        (NextEntry->RunLength != 0)) {

        EndOfNextRun = NextEntry->Lcn + NextEntry->RunLength;
    }

    //
    //  Case 1 - Merge with previous run.
    //

    if ((ThisIndex != NTFS_CACHED_RUNS_DEL_INDEX) &&
        (Lcn == EndOfThisRun)) {

        //
        //  Extend the entry in the runs array and remember the
        //  new length.  We will defer moving the run within the
        //  length-sorted array until we know the final length.
        //  It is possible that the combined entry overlaps with
        //  subsequent entries.  If the overlap lands in the middle
        //  of the final entry, the length may need to be extended
        //  even more.
        //

        Lcn = ThisEntry->Lcn;

        //
        //  Remember the original length of the entry.
        //

        OldLength = ThisEntry->RunLength;
        Length += ThisEntry->RunLength;
        ThisEntry->RunLength = Length;
        ExtendedEntry = TRUE;
        ScanForOverlap = TRUE;

    //
    //  Case 2 - We are at the end of the array
    //  Case 3 - We have a non-overlapping interior entry
    //

    } else if ((NextIndex >= CachedRuns->Used) ||
               (NextEntry->RunLength == 0) ||
               (EndOfNewRun < NextEntry->Lcn)) {

        //
        //  Insert the new run in both lists.
        //

        NtfsInsertCachedRun( CachedRuns,
                             Lcn,
                             Length,
                             NextIndex );

    //
    //  Case 4 - We are contained within the current entry.
    //

    } else if ((Lcn >= NextEntry->Lcn) &&
               (EndOfNewRun <= EndOfNextRun)) {

        NOTHING;

    //
    //  Case 5 - We overlap the next entry.  Extend the run to the end of
    //      current run if we end early.  Extend to the beginning of the
    //      run if we need to.
    //

    } else {

        //
        //  Remember if we are extending the run backwards.
        //

        if (Lcn < NextEntry->Lcn) {


            //
            //  Move the starting point back.
            //

            NextEntry->Lcn = Lcn;
            ExtendedEntry = TRUE;
            OldLength = NextEntry->RunLength;
        }

        //
        //  Remember if we go past the end of this run.
        //

        if (EndOfNewRun > EndOfNextRun) {

            ExtendedEntry = TRUE;
            ScanForOverlap = TRUE;
            OldLength = NextEntry->RunLength;
            Length = EndOfNewRun - NextEntry->Lcn;

        //
        //  Remember the full new length of this run.
        //

        } else {

            Length = EndOfNextRun - NextEntry->Lcn;
        }


        //
        //  Update the entry and position ThisEntry to point to it.
        //

        NextEntry->RunLength = Length;
        ThisEntry = NextEntry;
        ThisIndex = NextIndex;
    }

    //
    //  Walk forward to see if we need to join with other entires.
    //

    if (ScanForOverlap) {

        NextIndex = ThisIndex + 1;
        EndOfNewRun = ThisEntry->Lcn + ThisEntry->RunLength;

        while (NextIndex < CachedRuns->Used) {

            NextEntry = CachedRuns->LcnArray + NextIndex;

            //
            //  The entry has been deleted and must be ignored.  Get the
            //  window of deleted entries that covers it.
            //

            if (NextEntry->RunLength == 0) {

                DelWindow = NtfsGetDelWindow( CachedRuns,
                                              NextIndex,
                                              NextIndex,
                                              TRUE,
                                              NULL );

                ASSERT( DelWindow );
                ASSERT( DelWindow->EndIndex >= NextIndex );
                ASSERT( DelWindow->StartIndex <= NextIndex );

                NextIndex = DelWindow->EndIndex + 1;
                continue;
            }

            //
            //  Exit if there is no overlap.
            //

            if (EndOfNewRun < NextEntry->Lcn) {

                break;
            }

            //
            //  The runs overlap.
            //

            EndOfNextRun = NextEntry->Lcn + NextEntry->RunLength;
            if (EndOfNewRun < EndOfNextRun) {

                //
                //  Extend the new run.
                //

                ThisEntry->RunLength = EndOfNextRun - ThisEntry->Lcn;
                ExtendedEntry = TRUE;
                EndOfNewRun = EndOfNextRun;
            }

            //
            //  Delete the run.  This can cause compaction to be run and
            //  that will require us to have to recalculate ThisIndex.
            //

            SaveLcn = ThisEntry->Lcn;
            NtfsDeleteCachedRun( CachedRuns,
                                 NextIndex,
                                 NextEntry->LengthIndex );

            //
            //  Check if we should recompute ThisIndex because ThisEntry must have moved
            //  during compaction.
            //

            if ((ThisEntry->Lcn != SaveLcn) ||
                (ThisEntry->RunLength == 0) ) {

                NtfsLookupCachedLcn( CachedRuns,
                                     Lcn,
                                     &StartingLcn,
                                     &RunLength,
                                     &ThisIndex );
                ThisEntry = CachedRuns->LcnArray + ThisIndex;

                //
                //  Reset NextIndex to point to the end after ThisIndex.  That
                //  value may have moved due to compaction.
                //

                NextIndex = ThisIndex + 1;
            }

            if (EndOfNewRun == EndOfNextRun) {

                break;
            }
        }
    }

    //
    //  If we changed the existing entry then update the length bins.
    //

    if (ExtendedEntry) {

        NtfsModifyCachedBinArray( CachedRuns,
                                  OldLength,
                                  ThisEntry->RunLength );

        //
        //  Move the entry to the correct position in the length-sorted array
        //

        NtfsGrowLengthInCachedLcn( CachedRuns,
                                   ThisEntry,
                                   ThisIndex );
    }

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, FALSE, FALSE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsInsertCachedLcn -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsGrowLengthInCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN PNTFS_LCN_CLUSTER_RUN ThisEntry,
    IN USHORT LcnIndex
    )

/*++

Routine Description:

    This routine is called when a run's length has been increased.  This
    routine makes the necessary changes to the length-sorted list.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    ThisEntry - Entry whose size is being changed.

    LcnIndex - The index in the Lcn-sorted array of this entry.

Return Value:

    None

--*/

{
    BOOLEAN FoundRun;
    USHORT Index;
    USHORT Count;
    USHORT RunIndex;
    USHORT WindowIndex;
    USHORT FirstWindowIndex;
    PNTFS_LCN_CLUSTER_RUN OldEntry;
    PNTFS_DELETED_RUNS DelWindow;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGrowLengthInCachedLcn\n") );
    DebugTrace( 0, Dbg, ("ThisEntry = %08lx\n", ThisEntry) );
    DebugTrace( 0, Dbg, ("LcnIndex = %04x\n", LcnIndex) );
    DebugTrace( 0, Dbg, ("LengthIndex = %04x\n", ThisEntry->LengthIndex) );

    //
    //  Find the new insertion point.
    //

    //
    //  Find the nearest non-deleted entry with
    //  index > ThisEntry->LengthIndex.
    //

    if (ThisEntry->LengthIndex < (CachedRuns->Used - 1) ) {

        RunIndex = ThisEntry->LengthIndex + 1;

        if (CachedRuns->LengthArray[ RunIndex ] == NTFS_CACHED_RUNS_DEL_INDEX) {

            //
            //  The entry has been deleted and must be ignored.  Get the
            //  window of deleted entries that covers it.
            //

            DelWindow = NtfsGetDelWindow( CachedRuns,
                                          RunIndex,
                                          RunIndex,
                                          FALSE,
                                          NULL);
            ASSERT( DelWindow != NULL );
            ASSERT( DelWindow->EndIndex >= RunIndex );
            ASSERT( DelWindow->StartIndex <= RunIndex );

            //
            //  Set RunIndex to the entry just after this deleted
            //  window.
            //

            if (DelWindow->EndIndex < (CachedRuns->Used - 1)) {

                RunIndex = DelWindow->EndIndex + 1;

            //
            //  Nothing to do.  The entry is still the largest in the
            //  list.
            //

            } else {

                RunIndex = NTFS_CACHED_RUNS_DEL_INDEX;
            }
        }

    //
    //  Nothing to do.  The entry is still the largest in the list.
    //

    } else {

        RunIndex = NTFS_CACHED_RUNS_DEL_INDEX;
    }


    //
    //  If the run is possible out of position then compare our length with the following length.
    //

    if (RunIndex != NTFS_CACHED_RUNS_DEL_INDEX) {

        OldEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ RunIndex ];

        //
        //  The entry will move in the list.  We need to search for
        //  the insertion position in the
        //  range [RunIndex..CachedRuns->Used].
        //

        if ((OldEntry->RunLength < ThisEntry->RunLength) ||
            ((OldEntry->RunLength == ThisEntry->RunLength) &&
             (OldEntry->Lcn < ThisEntry->Lcn)) ) {

            //
            //  Get the insertion point for the new entry.
            //

            FoundRun = NtfsPositionCachedLcnByLength( CachedRuns,
                                                      ThisEntry->RunLength,
                                                      &ThisEntry->Lcn,
                                                      &RunIndex,
                                                      TRUE,
                                                      &Index );

            //
            //  Index points to the closest run by Lcn that has a RunLength
            //  equal to Length.  We need to check to see if the new entry
            //  should be inserted before or after it.
            //

            if (FoundRun) {

                OldEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ Index ];
                ASSERT( OldEntry->RunLength == ThisEntry->RunLength );

                //
                //  The new run should come before this one.
                //

                if (OldEntry->Lcn > ThisEntry->Lcn) {

                    //
                    //  We need to adjust Index downwards.
                    //

                    Index -= 1;
                }

            } else {

                //
                //  The entry pointed to by Index is either deleted or sorts
                //  higher than the new one.  Move the insertion point back one
                //  position.
                //

                Index -= 1;
            }

            //
            //  At this point, Index indicates the new position for the entry.
            //  Any entry currently at Index sorts lower.
            //

            ASSERT( Index > ThisEntry->LengthIndex );

            if (CachedRuns->LengthArray[ Index ] == NTFS_CACHED_RUNS_DEL_INDEX) {

                //
                //  Advance Index to before the start of this window of deleted
                //  entries.
                //

                DelWindow = NtfsGetDelWindow( CachedRuns,
                                              Index,
                                              Index,
                                              FALSE,
                                              NULL);
                ASSERT( DelWindow );
                ASSERT( DelWindow->StartIndex <= Index );
                ASSERT( DelWindow->EndIndex >= Index );

                Index = DelWindow->StartIndex - 1;
            }

            ASSERT( Index > ThisEntry->LengthIndex );

            //
            //  Move the entries between ThisEntry->LengthIndex + 1 and Index
            //  to the left.
            //

            RtlMoveMemory( CachedRuns->LengthArray + ThisEntry->LengthIndex,
                           CachedRuns->LengthArray + ThisEntry->LengthIndex + 1,
                           sizeof( USHORT ) * (Index - ThisEntry->LengthIndex) );

            //
            //  Update the indices in the Lcn-sorted list to reflect
            //  the move of the length-sorted entries.
            //

            for (Count = ThisEntry->LengthIndex, DelWindow = NULL;
                 Count < Index;
                 Count += 1) {

                RunIndex = CachedRuns->LengthArray[ Count ];

                //
                //  Update the Lcn array if the length entry isn't deleted.
                //

                if (RunIndex != NTFS_CACHED_RUNS_DEL_INDEX) {

                    CachedRuns->LcnArray[ RunIndex ].LengthIndex = Count;

                } else {

                    //
                    //  Update the window of deleted entries.
                    //

                    if (DelWindow != NULL) {

                        //
                        //  The window we want must follow the last one we
                        //  found.
                        //

                        DelWindow += 1;
                        WindowIndex += 1;

                        ASSERT( WindowIndex < CachedRuns->DelLengthCount );

                    } else {

                        //
                        //  Lookup the window containing the entry.  Remember
                        //  to look for Count + 1 because the window we are
                        //  seaching for has not yet been updated.
                        //

                        DelWindow = NtfsGetDelWindow( CachedRuns,
                                                      Count + 1,
                                                      Count + 1,
                                                      FALSE,
                                                      &WindowIndex);
                        ASSERT( DelWindow != NULL );
                        FirstWindowIndex = WindowIndex;
                    }

                    ASSERT( DelWindow->StartIndex == (Count + 1) );
                    ASSERT( DelWindow->EndIndex < Index );

                    //
                    //  Update the window.
                    //

                    DelWindow->StartIndex -= 1;
                    DelWindow->EndIndex -= 1;

                    //
                    //  Advance Count past window.
                    //

                    Count = DelWindow->EndIndex;
                }
            }

            //
            //  We may have moved the first window to the left such that
            //  it should be merged with the preceding window.
            //

            if ((DelWindow != NULL) && (FirstWindowIndex > 0) ) {

                PNTFS_DELETED_RUNS PrevWindow;

                DelWindow = CachedRuns->DeletedLengthWindows + FirstWindowIndex;
                PrevWindow = DelWindow - 1;

                if (PrevWindow->EndIndex == (DelWindow->StartIndex - 1) ) {

                    //
                    //  We need to merge these windows.
                    //

                    PrevWindow->EndIndex = DelWindow->EndIndex;
                    NtfsDeleteDelWindow( CachedRuns,
                                         FALSE,
                                         FirstWindowIndex);
                }
            }

            //
            //  Update the entries corresponding to ThisEntry;
            //

            CachedRuns->LengthArray[ Index ] = LcnIndex;
            ThisEntry->LengthIndex = Index;
        }
    }

    DebugTrace( 0, Dbg, ("Final LengthIndex = %04x\n", ThisEntry->LengthIndex) );

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, TRUE, TRUE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsGrowLengthInCachedLcn -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsShrinkLengthInCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN PNTFS_LCN_CLUSTER_RUN ThisEntry,
    IN USHORT LcnIndex
    )

/*++

Routine Description:

    This routine is called when a run's length has been reduced.  This routine
    makes the necessary changes to the length-sorted list.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    ThisEntry - Entry whose size is being changed.

    LcnIndex - The index in the Lcn-sorted array of this entry.

Return Value:

    None

--*/

{
    BOOLEAN FoundRun;
    USHORT Index;
    USHORT WindowIndex;
    USHORT Count;
    USHORT RunIndex;
    PNTFS_LCN_CLUSTER_RUN OldEntry;
    PNTFS_DELETED_RUNS DelWindow;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsShrinkLengthInCachedLcn\n") );
    DebugTrace( 0, Dbg, ("ThisEntry = %08lx\n", ThisEntry) );
    DebugTrace( 0, Dbg, ("LcnIndex = %04x\n", LcnIndex) );
    DebugTrace( 0, Dbg, ("LengthIndex = %04x\n", ThisEntry->LengthIndex) );

    //
    //  Find the nearest non-deleted entry with
    //  index < ThisEntry->LengthIndex.
    //

    if (ThisEntry->LengthIndex > 0) {

        RunIndex = ThisEntry->LengthIndex - 1;
        if (CachedRuns->LengthArray[ RunIndex ] == NTFS_CACHED_RUNS_DEL_INDEX) {

            //
            //  The entry has been deleted and must be ignored.  Get the
            //  window of deleted entries that covers it.
            //

            DelWindow = NtfsGetDelWindow( CachedRuns,
                                          RunIndex,
                                          RunIndex,
                                          FALSE,
                                          NULL);
            ASSERT( DelWindow );
            ASSERT( DelWindow->EndIndex >= RunIndex );
            ASSERT( DelWindow->StartIndex <= RunIndex );

            //
            //  Move ahead of this window if possible.
            //

            if (DelWindow->StartIndex > 0) {

                RunIndex = DelWindow->StartIndex - 1;

            //
            //  Nothing to do.  The entry is still the smallest in the
            //  list.
            //

            } else {

                RunIndex = NTFS_CACHED_RUNS_DEL_INDEX;
            }
        }

    //
    //  Nothing to do.  The entry is still the smallest in the list.
    //

    } else {

        RunIndex = NTFS_CACHED_RUNS_DEL_INDEX;
    }

    //
    //  If the run is possible out of position then compare our length with the prior length.
    //

    if (RunIndex != NTFS_CACHED_RUNS_DEL_INDEX) {

        OldEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ RunIndex ];

        //
        //  Check for a conflict with the previous run.
        //

        if ((OldEntry->RunLength > ThisEntry->RunLength) ||
            ((OldEntry->RunLength == ThisEntry->RunLength) &&
             (OldEntry->Lcn > ThisEntry->Lcn)) ) {

            //
            //  Get the insertion point for the new entry.
            //

            FoundRun = NtfsPositionCachedLcnByLength( CachedRuns,
                                                      ThisEntry->RunLength,
                                                      &ThisEntry->Lcn,
                                                      &RunIndex,
                                                      FALSE,
                                                      &Index );

            //
            //  If found Index points to the closest run by Lcn that has a RunLength
            //  equal to Length.  We need to check to see if the new entry
            //  should be inserted before or after it.
            //

            if (FoundRun) {

                OldEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ Index ];
                ASSERT( OldEntry->RunLength == ThisEntry->RunLength );

                if (OldEntry->Lcn < ThisEntry->Lcn) {

                    //
                    //  The new run should come after this one.
                    //  We need to adjust Index upwards.
                    //

                    Index += 1;
                    DebugTrace( 0, Dbg, ("Increment Index to %04x\n", Index) );
                }
            }

            //
            //  At this point, Index indicates the new position for the entry.
            //  Any entry currently at Index sorts higher.
            //

            ASSERT( Index < ThisEntry->LengthIndex );

            //
            //  Advance Index past the end of this window of deleted
            //  entries.
            //

            if (CachedRuns->LengthArray[ Index ] == NTFS_CACHED_RUNS_DEL_INDEX) {

                DelWindow = NtfsGetDelWindow( CachedRuns,
                                              Index,
                                              Index,
                                              FALSE,
                                              NULL);
                ASSERT( DelWindow );
                ASSERT( DelWindow->StartIndex <= Index );
                ASSERT( DelWindow->EndIndex >= Index );

                Index = DelWindow->EndIndex + 1;
                ASSERT( Index < ThisEntry->LengthIndex );
            }

            //  Move the entries between Index and ThisEntry->LengthIndex - 1
            //  to the right.
            //

            RtlMoveMemory( CachedRuns->LengthArray + Index + 1,
                           CachedRuns->LengthArray + Index,
                           sizeof( USHORT ) * (ThisEntry->LengthIndex - Index) );

            //
            //  Update the indices in the Lcn-sorted list to reflect
            //  the move of the length-sorted entries.
            //

            for (Count = Index + 1, DelWindow = NULL;
                 Count <= ThisEntry->LengthIndex;
                 Count += 1) {

                RunIndex = CachedRuns->LengthArray[ Count ];

                //
                //  Update the Lcn array if the length entry isn't deleted.
                //

                if (RunIndex != NTFS_CACHED_RUNS_DEL_INDEX) {

                    CachedRuns->LcnArray[ RunIndex ].LengthIndex = Count;

                } else {

                    //
                    //  Update the window of deleted entries.
                    //

                    if (DelWindow != NULL) {

                        //
                        //  The window we want must follow the last one we
                        //  found.
                        //

                        DelWindow += 1;
                        WindowIndex += 1;

                        ASSERT( WindowIndex < CachedRuns->DelLengthCount );

                    //
                    //  Lookup the window containing the entry.  Remeber
                    //  to look for Count - 1 because the window we are
                    //  seaching for has not yet been updated.
                    //

                    } else {

                        DelWindow = NtfsGetDelWindow( CachedRuns,
                                                      Count - 1,
                                                      Count - 1,
                                                      FALSE,
                                                      &WindowIndex);
                        ASSERT( DelWindow != NULL );
                    }

                    ASSERT( DelWindow->StartIndex == (Count - 1) );
                    ASSERT( DelWindow->EndIndex < ThisEntry->LengthIndex );

                    //
                    //  Update the window.
                    //

                    DelWindow->StartIndex += 1;
                    DelWindow->EndIndex += 1;

                    //
                    //  Advance Count past window.
                    //

                    Count = DelWindow->EndIndex;
                }
            }

            //
            //  We may have moved the last window to the right such that
            //  it should be merged with the following window.
            //

            if ((DelWindow != NULL) &&
                ((WindowIndex + 1) < CachedRuns->DelLengthCount)) {

                PNTFS_DELETED_RUNS NextWindow = DelWindow + 1;

                if (DelWindow->EndIndex == (NextWindow->StartIndex - 1) ) {

                    //
                    //  We need to merge these windows.
                    //

                    DelWindow->EndIndex = NextWindow->EndIndex;
                    NtfsDeleteDelWindow( CachedRuns,
                                         FALSE,
                                         WindowIndex + 1);
                }
            }

            //
            //  Update the entries corresponding to ThisEntry;
            //

            CachedRuns->LengthArray[ Index ] = LcnIndex;
            ThisEntry->LengthIndex = Index;
        }
    }

    DebugTrace( 0, Dbg, ("Final LengthIndex = %04x\n", ThisEntry->LengthIndex) );

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, FALSE, FALSE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsShrinkLengthInCachedLcn -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsRemoveCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    IN LONGLONG Length
    )

/*++

Routine Description:

    This routine is called to remove an entry from the cached run array.  The run is not
    guaranteed to be present.

Arguments:

    CachedRuns - Pointer to the cached runs structure.

    Lcn - Start of run to remove.

    Length - Length of run to remove.

Return Value:

    None

--*/

{
    USHORT Index;
    LCN StartingLcn;

    LCN EndOfExistingRun;
    LCN EndOfInputRun = Lcn + Length;
    LONGLONG RunLength;

    PNTFS_DELETED_RUNS DelWindow;
    PNTFS_LCN_CLUSTER_RUN ThisEntry;

    BOOLEAN FirstFragSmaller = FALSE;
    BOOLEAN DontSplit = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRemoveCachedLcn\n") );

    //
    //  Return immediately if length is zero.
    //

    if (Length == 0) {

        DebugTrace( -1, Dbg, ("NtfsRemoveCachedLcn -> VOID\n") );
        return;
    }

    //
    //  Lookup the run.  If we don't find anything then point past the end
    //  of the array.
    //

    NtfsLookupCachedLcn( CachedRuns, Lcn, &StartingLcn, &RunLength, &Index );

    //
    //  We have several cases to deal with.
    //
    //      1 - This run is past the end of array.  Nothing to do.
    //      2 - This run is not in the array.  Nothing to do.
    //      3 - This run starts past the beginning of a entry.  Resize the entry.
    //      4 - This run contains a complete array entry.  Remove the entry.
    //      5 - This run ends before the end of an entry.  Resize the entry.
    //

    //
    //  Loop to process the case where we encounter several entries.
    //  Test for case 1 as the exit condition for the loop.
    //

    while (Index < CachedRuns->Used) {

        ThisEntry = CachedRuns->LcnArray + Index;

        //
        //  The entry has been deleted and must be ignored.  Get the
        //  window of deleted entries that covers it.
        //

        if (ThisEntry->RunLength == 0) {

            DelWindow = NtfsGetDelWindow( CachedRuns,
                                          Index,
                                          Index,
                                          TRUE,
                                          NULL);
            ASSERT( DelWindow != NULL );
            ASSERT( DelWindow->EndIndex >= Index );
            ASSERT( DelWindow->StartIndex <= Index );

            //
            //  Advance the index past the deleted entries.
            //

            Index = DelWindow->EndIndex + 1;
            continue;
        }

        //
        //  Remember the range of this run.
        //

        EndOfExistingRun = ThisEntry->Lcn + ThisEntry->RunLength;

        //
        //  Case 2 - No overlap.
        //

        if (EndOfInputRun <= ThisEntry->Lcn) {

            break;

        //
        //  Case 3 - The run starts beyond the beginning of this run.
        //

        } else if (Lcn > ThisEntry->Lcn) {

            //
            //  Reduce the current entry so that is covers only the
            //  first fragment and move it to the correct position in
            //  the length-sorted array.
            //

            NtfsModifyCachedBinArray( CachedRuns,
                                      ThisEntry->RunLength,
                                      Lcn - ThisEntry->Lcn );

            ThisEntry->RunLength = Lcn - ThisEntry->Lcn;

            //
            //  Adjust this length in the run length array.
            //

            NtfsShrinkLengthInCachedLcn( CachedRuns,
                                         ThisEntry,
                                         Index );

            //
            //  We need to split this entry in two.  Now reinsert the portion
            //  split off.
            //

            if (EndOfInputRun < EndOfExistingRun) {

                //
                //  Now create a new entry that covers the second
                //  fragment.  It should directly follow ThisEntry in the
                //  Lcn-sorted list.
                //

                NtfsInsertCachedRun( CachedRuns,
                                     EndOfInputRun,
                                     EndOfExistingRun - EndOfInputRun,
                                     Index + 1);

                //
                //  Nothing else to do.
                //

                break;

            //
            //  We will trim the tail of this entry.
            //

            } else if (EndOfInputRun > EndOfExistingRun) {

                Lcn = EndOfExistingRun;
                Index += 1;

            } else {

                break;
            }

        //
        //  Case 4 - Remove a complete entry.
        //

        } else if (EndOfInputRun >= EndOfExistingRun) {

            ASSERT( Lcn <= ThisEntry->Lcn );

            //
            //  Delete the run.  This can cause compaction to be run but we
            //  are guaranteed that the entry at Index will not move.
            //

            NtfsDeleteCachedRun( CachedRuns,
                                 Index,
                                 ThisEntry->LengthIndex );

            //
            //  Advance the Lcn if we go past this entry.
            //

            if (EndOfInputRun > EndOfExistingRun) {

                Lcn = EndOfExistingRun;

            } else {

                break;
            }

        //
        //  Case 5 - This entry starts at or before the start of the run
        //      and ends before the end of the run.
        //

        } else {

            ASSERT( Lcn <= ThisEntry->Lcn );
            ASSERT( EndOfInputRun < EndOfExistingRun );

            //
            //  Reduce the current entry so that is covers only the end of the
            //  run and move it to the correct position in the length-sorted
            //  array.
            //

            NtfsModifyCachedBinArray( CachedRuns,
                                      ThisEntry->RunLength,
                                      EndOfExistingRun - EndOfInputRun );

            ThisEntry->RunLength = EndOfExistingRun - EndOfInputRun;

            ThisEntry->Lcn = EndOfInputRun;
            NtfsShrinkLengthInCachedLcn( CachedRuns,
                                         ThisEntry,
                                         Index );
            break;
        }
    }

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, FALSE, FALSE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsRemoveCachedLcn -> VOID\n") );

    return;
}


//
//  Local support routine
//

BOOLEAN
NtfsGrowCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns
    )

/*++

Routine Description:

    This routine is called to grow the size of the cached run arrays if
    necessary.  We will not exceed the CachedRuns->MaximumSize.  It
    is assumed that there are no deleted entries in the arrays.  If we can
    grow the arrays, we double the size unless we would grow it by more than
    our max delta.  Otherwise we grow it by that amount.

Arguments:

    CachedRuns - Pointer to the cached runs structure to grow.

Return Value:

    BOOLEAN - TRUE if we were able to grow the structure, FALSE otherwise.

--*/

{
    USHORT NewSize;
    USHORT OldSize = CachedRuns->Avail;
    USHORT Index;
    PNTFS_LCN_CLUSTER_RUN NewLcnArray;
    PUSHORT NewLengthArray;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGrowCachedRuns\n") );

    //
    //  Calculate the new size.
    //

    if (CachedRuns->Avail > NTFS_MAX_CACHED_RUNS_DELTA) {

        NewSize = CachedRuns->Avail + NTFS_MAX_CACHED_RUNS_DELTA;

    } else {

        NewSize = CachedRuns->Avail * 2;
    }

    if (NewSize > CachedRuns->MaximumSize) {

        NewSize = CachedRuns->MaximumSize;
    }

    if (NewSize > CachedRuns->Avail) {

        //
        //  Allocate the new buffers and copy the previous buffers over.
        //

        NewLcnArray = NtfsAllocatePoolNoRaise( PagedPool,
                                               sizeof( NTFS_LCN_CLUSTER_RUN ) * NewSize );

        if (NewLcnArray == NULL) {

            DebugTrace( -1, Dbg, ("NtfsGrowCachedRuns -> FALSE\n") );
            return FALSE;
        }

        NewLengthArray = NtfsAllocatePoolNoRaise( PagedPool,
                                                  sizeof( USHORT ) * NewSize );

        if (NewLengthArray == NULL) {

            NtfsFreePool( NewLcnArray );
            DebugTrace( -1, Dbg, ("NtfsGrowCachedRuns -> FALSE\n") );
            return FALSE;
        }

        RtlCopyMemory( NewLcnArray,
                       CachedRuns->LcnArray,
                       sizeof( NTFS_LCN_CLUSTER_RUN ) * CachedRuns->Used );

        RtlCopyMemory( NewLengthArray,
                       CachedRuns->LengthArray,
                       sizeof( USHORT ) * CachedRuns->Used );

        //
        //  Mark all entries so that they can be detected as deleted.
        //

        for (Index = CachedRuns->Used; Index < NewSize; Index += 1) {

            NewLcnArray[ Index ].RunLength = 0;
            NewLcnArray[ Index ].LengthIndex = NTFS_CACHED_RUNS_DEL_INDEX;
            NewLengthArray[ Index ] = NTFS_CACHED_RUNS_DEL_INDEX;
        }

        //
        //  Deallocate the existing buffers and set the cached runs structure
        //  to point to the new buffers.
        //

        NtfsFreePool( CachedRuns->LcnArray );
        CachedRuns->LcnArray = NewLcnArray;

        NtfsFreePool( CachedRuns->LengthArray );
        CachedRuns->LengthArray = NewLengthArray;

        //
        //  Update the count of available entries.
        //

        CachedRuns->Avail = NewSize;

        //
        //  Create a window of deleted entries to cover the newly allocated
        //  entries.
        //

        NtfsAddDelWindow( CachedRuns, OldSize, NewSize - 1, TRUE );
        NtfsAddDelWindow( CachedRuns, OldSize, NewSize - 1, FALSE );

    } else {

        DebugTrace( -1, Dbg, ("NtfsGrowCachedRuns -> FALSE\n") );
        return FALSE;
    }

#ifdef NTFS_CHECK_CACHED_RUNS
    if (NtfsDoVerifyCachedRuns) {
        NtfsVerifyCachedRuns( CachedRuns, FALSE, FALSE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsGrowCachedRuns -> TRUE\n") );

    return TRUE;
}


//
//  Local support routine
//

VOID
NtfsCompactCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN LcnSortedList
    )

/*++

Routine Description:

    This routine is called to compact two of the windows of deleted entries
    into a single window.  Note that entries in the given range of indices
    have been marked as deleted, but are not yet in a window of deleted
    entries.  This should not trigger a corruption warning.  To avoid
    confusion, we will be sure not to choose the windows to be compacted
    such that the given range of indices gets moved.

Arguments:

    CachedRuns - Pointer to the cached run structure.

    FirstIndex - Index that marks the start of the newest range of deleted
        entries.

    LastIndex - The index of the last entry in the newest range of deleted
        entries.

    LcnSortedList - If TRUE, the Lcn-sorted list is compacted.
        If FALSE, the length-sorted list is compacted.

Return Value:

    None

--*/

{
    USHORT Gap1;
    USHORT Gap2;
    USHORT RunIndex;
    USHORT Count;
    USHORT GapIndex;
    PUSHORT WindowCount;
    PNTFS_DELETED_RUNS DelWindow;
    PNTFS_DELETED_RUNS PrevWindow;
    PNTFS_DELETED_RUNS Windows;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCompactCachedRuns\n") );

    ASSERT( FirstIndex != NTFS_CACHED_RUNS_DEL_INDEX );
    ASSERT( LastIndex != NTFS_CACHED_RUNS_DEL_INDEX );

    if (LcnSortedList) {

        WindowCount = &CachedRuns->DelLcnCount;
        Windows = CachedRuns->DeletedLcnWindows;

    } else {

        WindowCount = &CachedRuns->DelLengthCount;
        Windows = CachedRuns->DeletedLengthWindows;
    }

    ASSERT( *WindowCount > 1 );

    //
    //  Loop through the windows looking for the smallest gap of non-deleted
    //  entries.  We will not choose a gap the covers [FirstIndex..LastIndex]
    //

    Gap1 = NTFS_CACHED_RUNS_DEL_INDEX;
    for (Count = 1, DelWindow = Windows + 1, PrevWindow = Windows;
         (Count < *WindowCount) && (Gap1 > 1);
         Count += 1, PrevWindow += 1, DelWindow += 1) {

        //
        //  Compute this gap if the exempt range doesn't fall within it.  We want to track the
        //  actual number of entries.
        //

        if ((PrevWindow->StartIndex > LastIndex) ||
            (DelWindow->EndIndex < FirstIndex)) {

            Gap2 = DelWindow->StartIndex - (PrevWindow->EndIndex + 1);

            //
            //  Remember if this gap is our smallest so far.
            //

            if (Gap2 < Gap1) {

                Gap1 = Gap2;
                GapIndex = Count;
            }
        }
    }

    //
    //  Merge the window at GapIndex with the one that precedes it by moving
    //  the non-deleted entries in the gap between them to the start of the
    //  preceding window.
    //

    DelWindow = Windows + GapIndex;
    PrevWindow = DelWindow - 1;

    //
    //  Copy the block of entries that we will be keeping
    //  into the insertion point.
    //

    DebugTrace( 0,
                Dbg,
                ("copy %04x entries from=%04x to=%04x\n", Gap1, PrevWindow->EndIndex + 1, PrevWindow->StartIndex) );

    if (LcnSortedList) {

        RtlMoveMemory( CachedRuns->LcnArray + PrevWindow->StartIndex,
                       CachedRuns->LcnArray + PrevWindow->EndIndex + 1,
                       sizeof( NTFS_LCN_CLUSTER_RUN ) * Gap1 );

        //
        //  Update the indices in the Length-sorted list to
        //  reflect the move of the lcn-sorted entries.
        //

        for (Count = 0; Count < Gap1; Count += 1) {

            RunIndex = CachedRuns->LcnArray[ PrevWindow->StartIndex + Count ].LengthIndex;
            ASSERT( RunIndex != NTFS_CACHED_RUNS_DEL_INDEX );
            CachedRuns->LengthArray[ RunIndex ] = PrevWindow->StartIndex + Count;
        }

        //
        //  Mark the entries from the gap that are going to be part of the
        //  merged windows as deleted.
        //
        //  We only need to do this for entries past the end of the gap we are deleting.
        //

        Count = PrevWindow->StartIndex + Gap1;

        if (Count < PrevWindow->EndIndex + 1) {

            Count = PrevWindow->EndIndex + 1;
        }

        while (Count < DelWindow->StartIndex) {

            CachedRuns->LcnArray[ Count ].LengthIndex = NTFS_CACHED_RUNS_DEL_INDEX;
            CachedRuns->LcnArray[ Count ].RunLength = 0;
            Count += 1;
        }

    } else {

        RtlMoveMemory( CachedRuns->LengthArray + PrevWindow->StartIndex,
                       CachedRuns->LengthArray + PrevWindow->EndIndex + 1,
                       sizeof( USHORT ) * Gap1 );

        //
        //  Update the indices in the Lcn-sorted list to reflect
        //  the move of the length-sorted entries.
        //

        for (Count = 0; Count < Gap1; Count += 1) {

            RunIndex = CachedRuns->LengthArray[ PrevWindow->StartIndex + Count ];
            ASSERT( RunIndex != NTFS_CACHED_RUNS_DEL_INDEX );
            CachedRuns->LcnArray[ RunIndex ].LengthIndex = PrevWindow->StartIndex + Count;
        }

        //
        //  Mark the entries from the gap that are going to be part of the
        //  merged windows as deleted.
        //
        //  We only need to do this for entries past the end of the gap we are deleting.
        //


        Count = PrevWindow->StartIndex + Gap1;

        if (Count < PrevWindow->EndIndex + 1) {

            Count = PrevWindow->EndIndex + 1;
        }

        while (Count < DelWindow->StartIndex) {

            CachedRuns->LengthArray[ Count ] = NTFS_CACHED_RUNS_DEL_INDEX;
            Count += 1;
        }
    }

    //
    //  Update the previous window to reflect the larger size.
    //

    ASSERT( (PrevWindow->EndIndex + Gap1 + 1) == DelWindow->StartIndex );
    PrevWindow->StartIndex += Gap1;
    PrevWindow->EndIndex = DelWindow->EndIndex;

    //
    //  Delete DelWindow.
    //

    NtfsDeleteDelWindow( CachedRuns,
                         LcnSortedList,
                         GapIndex);

#ifdef NTFS_CHECK_CACHED_RUNS

    //
    //  We will not check sort orders in NtfsVerifyCachedRuns because we
    //  could be making this call as part of deleting runs that have an
    //  overlap with a newly inserted run.  This could give false corruption
    //  warnings.
    //

    if (LcnSortedList) {

        NtfsVerifyCachedLcnRuns ( CachedRuns,
                                  FirstIndex,
                                  LastIndex,
                                  TRUE,
                                  TRUE );
    } else {

        NtfsVerifyCachedLenRuns ( CachedRuns,
                                  FirstIndex,
                                  LastIndex,
                                  TRUE );
    }
#endif

    DebugTrace( -1, Dbg, ("NtfsCompactCachedRuns -> VOID\n") );
    return;
}


//
//  Local support routine
//

BOOLEAN
NtfsPositionCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    OUT PUSHORT Index
    )

/*++

Routine Description:

    This routine is called to position ourselves with an Lcn lookup.  On return
    we will return the index where the current entry should go or where it
    currently resides.  The return value indicates whether the entry is
    present.  The Lcn does not have to be at the beginning of the found run.

Arguments:

    CachedRuns - Pointer to the cached run structure.

    Lcn - Lcn we are interested in.

    Index - Address to store the index of the position in the Lcn array.

Return Value:

    BOOLEAN - TRUE if the entry is found, FALSE otherwise.

--*/

{
    USHORT Min, Max, Current;
    PNTFS_LCN_CLUSTER_RUN ThisEntry;
    PNTFS_DELETED_RUNS DelWindow;
    BOOLEAN FoundLcn = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPositionCachedLcn\n") );

    //
    //  Perform a binary search to find the index.  Note we start Max past
    //  the end so don't rely on it being valid.
    //

    Min = 0;
    Max = CachedRuns->Avail;

    while (Min != Max) {

        Current = (USHORT) (((ULONG) Max + Min) / 2);
        ThisEntry = CachedRuns->LcnArray + Current;

        //
        //  The current entry has been deleted and must be ignored.
        //  Get the window of deleted entries that covers Current.
        //

        if (ThisEntry->RunLength == 0) {

            DelWindow = NtfsGetDelWindow( CachedRuns,
                                          Current,
                                          Current,
                                          TRUE,
                                          NULL);
            ASSERT( DelWindow != NULL );
            ASSERT( DelWindow->EndIndex >= Current );
            ASSERT( DelWindow->StartIndex <= Current );

            //
            //  Go to the edges of this deleted entries window to determine
            //  which way we should go.
            //

            //
            //  If the deleted window spans the remaining used runs then move
            //  to the beginning of the window.
            //

            if ((DelWindow->EndIndex + 1) >= CachedRuns->Used ) {

                Max = DelWindow->StartIndex;
                ASSERT( Min <= Max );

            //
            //  If the deleted window is not at index zero then look to the entry
            //  on the left.
            //

            } else if (DelWindow->StartIndex > 0) {

                ThisEntry = CachedRuns->LcnArray + DelWindow->StartIndex - 1;
                ASSERT( ThisEntry->RunLength != 0 );

                if (Lcn < (ThisEntry->Lcn + ThisEntry->RunLength)) {

                    //
                    //  The search should continue from the lower edge of the
                    //  window.
                    //

                    Max = DelWindow->StartIndex;
                    ASSERT( Min <= Max );

                } else {

                    //
                    //  The search should continue from the upper edge of the
                    //  window.
                    //

                    Min = DelWindow->EndIndex + 1;
                    ASSERT( Min <= Max );
                }

            //
            //  The search should continue from the upper edge of the
            //  deleted window.
            //

            } else {

                Min = DelWindow->EndIndex + 1;
                ASSERT( Min <= Max );
            }

            //
            //  Loop back now that Min or Max has been updated.
            //

            continue;
        }

        //
        //  If our Lcn is less than this then move the Max value down.
        //

        if (Lcn < ThisEntry->Lcn) {

            Max = Current;
            ASSERT( Min <= Max );

        //
        //  If our Lcn is outside the range for this entry then move
        //  the Min value up.  Make it one greater than the current
        //  index since we always round the index down.
        //

        } else if (Lcn >= (ThisEntry->Lcn + ThisEntry->RunLength)) {

            Min = Current + 1;
            ASSERT( Min <= Max );

        //
        //  This must be a hit.
        //

        } else {

            Min = Current;

            FoundLcn = TRUE;
            break;
        }
    }

    *Index = Min;

    //
    //  Check that we are positioned correctly.
    //

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    ThisEntry = CachedRuns->LcnArray + *Index - 1;

    ASSERT( FoundLcn ||
            (*Index == 0) ||
            (ThisEntry->RunLength == 0) ||
            (Lcn >= (ThisEntry->Lcn + ThisEntry->RunLength)) );

    ThisEntry = CachedRuns->LcnArray + *Index;
    ASSERT( FoundLcn ||
            (*Index == CachedRuns->Used) ||
            (ThisEntry->RunLength == 0) ||
            (Lcn < ThisEntry->Lcn) );
#endif

    DebugTrace( -1, Dbg, ("NtfsPositionCachedLcn -> %01x\n", FoundLcn) );

    return FoundLcn;
}


//
//  Local support routine
//

BOOLEAN
NtfsPositionCachedLcnByLength (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LONGLONG RunLength,
    IN PLCN Lcn OPTIONAL,
    IN PUSHORT StartIndex OPTIONAL,
    IN BOOLEAN SearchForward,
    OUT PUSHORT RunIndex
    )
/*++

Routine Description:

    This routine is called to search for a run of a particular length.  It
    returns the position of the run being looked for.  If the Lcn is specified
    then the run matching the desired RunLength that is closest to Lcn is
    chosen.

    This routine can be used to determine the insertion position for a new
    run.  The returned Index will be at or adjacent to the new run's position
    in the list.  The caller will have to check which.

    If this routine fails to find a run of the desired length, the returned
    Index will either point to a deleted entry or an entry that is larger or
    past the end of the array.

    ENHANCEMENT - If there is no match for the desired RunLength we currently choose the
    next higher size without checking for the one with the closest Lcn value.
    We could change the routine to restart the loop looking explicitly for the
    larger size so that the best choice in Lcn terms is returned.

Arguments:

    CachedRuns - Pointer to cached run structure.

    RunLength - Run length to look for.

    Lcn - If specified then we try to find the run which is closest to
        this Lcn, but has the requested Length.  If Lcn is UNUSED_LCN, we
        will end up choosing a match with the lowest Lcn as UNUSED_LCN
        is < 0.  This will result in maximum left-packing of the disk.
        If not specified we will randomly allocate matches on the length
        array.

    StartIndex - Optional index where the search should begin.

    SearchForward - If TRUE, the search should begin at StartIndex.  If
        FALSE, the search should end at StartIndex.

    RunIndex - Address to store index where the desired run is or should be.

Return Value:

    BOOLEAN - TRUE if we found a run with the desired RunLength,
        FALSE otherwise.

--*/

{
    USHORT Min, Max, Current, LcnIndex;
    USHORT MinMatch, MaxMatch;
    LONGLONG Distance;
    PNTFS_LCN_CLUSTER_RUN ThisEntry;
    PNTFS_DELETED_RUNS DelWindow;
    BOOLEAN FoundRun = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPositionCachedLcnByLength\n") );

    ASSERT( UNUSED_LCN < 0 );

    //
    //  Keep track of whether we are hitting matching length entries during the search.
    //

    MinMatch = MaxMatch = NTFS_CACHED_RUNS_DEL_INDEX;

    //
    //  Binary search to find the first entry which is equal to
    //  or larger than the one we wanted.  Bias the search with the
    //  user's end point if necessary.
    //

    Min = 0;
    Max = CachedRuns->Avail;
    if (ARGUMENT_PRESENT( StartIndex )) {

        if (SearchForward) {

            Min = *StartIndex;

        } else {

            Max = *StartIndex + 1;

            //
            //  The only time this could happen is if we are trying to
            //  find an entry that is larger than the largest in use.
            //  Just use values that will terminate the search.
            //

            if (Max > CachedRuns->Used) {

                Min = Max = CachedRuns->Used;
            }
        }

        ASSERT( Min <= Max );
    }

    while (Min != Max) {

        ASSERT( Min <= Max );

        //
        //  Find the mid-index point along with the Lcn index out of
        //  the length array and the entry in the Lcn array.
        //

        Current = (USHORT) (((ULONG) Max + Min) / 2);
        LcnIndex = CachedRuns->LengthArray[Current];
        ThisEntry = CachedRuns->LcnArray + LcnIndex;

        //
        //  The current entry has been deleted and must be
        //  ignored.  Get the window of deleted entries that
        //  covers Current.
        //

        if (LcnIndex == NTFS_CACHED_RUNS_DEL_INDEX) {

            DelWindow = NtfsGetDelWindow( CachedRuns,
                                          Current,
                                          Current,
                                          FALSE,
                                          NULL);
            ASSERT( DelWindow );
            ASSERT( DelWindow->EndIndex >= Current );
            ASSERT( DelWindow->StartIndex <= Current );

            //
            //  Go to the edges of this deleted entries window to determine
            //  which way we should go.
            //

            //
            //  If this window extends past the end of the used entries
            //  then move to the begining of it.
            //

            if ((DelWindow->EndIndex + 1) >= CachedRuns->Used ) {

                Max = DelWindow->StartIndex;
                ASSERT( Min <= Max );

            //
            //  If this window doesn't start at index zero then determine which
            //  direction to go.
            //

            } else if (DelWindow->StartIndex > 0) {

                //
                //  Point to the entry adjacent to the lower end of the window.
                //

                LcnIndex = CachedRuns->LengthArray[ DelWindow->StartIndex - 1 ];
                ASSERT( LcnIndex != NTFS_CACHED_RUNS_DEL_INDEX );

                ThisEntry = CachedRuns->LcnArray + LcnIndex;
                ASSERT( ThisEntry->RunLength != 0 );

                //
                //  If this entry is longer than we asked for then the search
                //  should continue from the lower edge of the window.
                //

                if (RunLength < ThisEntry->RunLength) {

                    Max = DelWindow->StartIndex;
                    ASSERT( Min <= Max );

                //
                //  The search should continue from the upper edge of the
                //  window if our run length is longer.
                //

                } else if (RunLength > ThisEntry->RunLength) {

                    Min = DelWindow->EndIndex + 1;
                    ASSERT( Min <= Max );

                //
                //  We have found the desired run if our caller didn't specify
                //  an Lcn.
                //

                } else if (!ARGUMENT_PRESENT( Lcn )) {

                    Min = DelWindow->StartIndex - 1;
                    FoundRun = TRUE;
                    break;

                //
                //  If our Lcn is less than the Lcn in the entry then the search
                //  should continue from the lower edge of the window.
                //

                } else if (*Lcn < ThisEntry->Lcn) {

                    Max = DelWindow->StartIndex;
                    ASSERT( Min <= Max );

                //
                //  If the entry overlaps then we have a match.  We already
                //  know our Lcn is >= to the start Lcn of the range from
                //  the test above.
                //

                } else if (*Lcn < (ThisEntry->Lcn + ThisEntry->RunLength)) {

                    Min = DelWindow->StartIndex - 1;
                    FoundRun = TRUE;
                    break;

                //
                //  Move Min past the end of the window.  We'll check later to see
                //  which end is closer.
                //

                } else {

                    Min = DelWindow->EndIndex + 1;
                    MinMatch = DelWindow->StartIndex - 1;
                    ASSERT( Min <= Max );
                    ASSERT( MinMatch != MaxMatch );
                }

            //
            //  The search should continue from the upper edge of the
            //  window.
            //

            } else {

                Min = DelWindow->EndIndex + 1;
                ASSERT( Min <= Max );
            }

            //
            //  Loop back now that Min or Max has been updated.
            //

            continue;
        }

        //
        //  If the run length of this entry is more than we want then
        //  move the Max value down.
        //

        if (RunLength < ThisEntry->RunLength) {

            Max = Current;
            ASSERT( Min <= Max );

        //
        //  If the run length of this entry is less than we want then
        //  move the Min value up.
        //

        } else if (RunLength > ThisEntry->RunLength) {

            Min = Current + 1;
            ASSERT( Min <= Max );

        //
        //  If our caller doesn't care about the Lcn then return this entry to
        //  him.
        //

        } else if (!ARGUMENT_PRESENT( Lcn )) {

            //
            //  The caller doesn't care about the Lcn, or the Lcn falls in
            //  the current run.
            //

            Min = Current;
            FoundRun = TRUE;
            break;

        //
        //  If the Lcn is less than the Lcn in the entry then move Max down.
        //

        } else if (*Lcn < ThisEntry->Lcn) {

            Max = Current;

            if (Current != MinMatch) {

                MaxMatch = Current;
            }
            ASSERT( Min <= Max );
            ASSERT( MinMatch != MaxMatch );

        //
        //  If the entry overlaps then we have a match.  We already
        //  know our Lcn is >= to the start Lcn of the range from
        //  the test above.
        //

        } else if (*Lcn < (ThisEntry->Lcn + ThisEntry->RunLength)) {

            Min = Current;
            FoundRun = TRUE;
            break;

        //
        //  Advance Min past the current point.
        //

        } else {

            Min = Current + 1;
            MinMatch = Current;
            ASSERT( Min <= Max );
            ASSERT( MinMatch != MaxMatch );
        }
    }

    //
    //  If we don't have an exact match then we want to find the nearest point.  We kept track
    //  of the nearest length matches as we went along.
    //

    if (!FoundRun) {

        //
        //  We have a length match if either match entry was updated.  Check for the nearest
        //  distance if they don't match.
        //

        ASSERT( (MinMatch == NTFS_CACHED_RUNS_DEL_INDEX) ||
                (MinMatch != MaxMatch) );

        if (MinMatch != MaxMatch) {

            FoundRun = TRUE;

            //
            //  Make sure our search found one of these.
            //

            ASSERT( (MinMatch == NTFS_CACHED_RUNS_DEL_INDEX) ||
                    (MinMatch <= Min) );
            ASSERT( (MinMatch == NTFS_CACHED_RUNS_DEL_INDEX) ||
                    (MinMatch == Min) ||
                    (MinMatch == Min - 1) ||
                    (CachedRuns->LengthArray[ Min - 1 ] == NTFS_CACHED_RUNS_DEL_INDEX) );

            ASSERT( (MaxMatch == NTFS_CACHED_RUNS_DEL_INDEX) ||
                    (MaxMatch >= Min) );
            ASSERT( (MaxMatch == NTFS_CACHED_RUNS_DEL_INDEX) ||
                    (MaxMatch == Min) ||
                    (MaxMatch == Min + 1) ||
                    (CachedRuns->LengthArray[ Min + 1 ] == NTFS_CACHED_RUNS_DEL_INDEX) );

            //
            //  If the user specified an Lcn then we need to check for the nearest entry.
            //

            if (ARGUMENT_PRESENT( Lcn )) {

                Min = MinMatch;

                if (MaxMatch != NTFS_CACHED_RUNS_DEL_INDEX) {

                    ThisEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ MaxMatch ];

                    Distance = ThisEntry->Lcn - *Lcn;
                    Min = MaxMatch;

                    if (MinMatch != NTFS_CACHED_RUNS_DEL_INDEX) {

                        ThisEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ MinMatch ];

                        if (*Lcn - (ThisEntry->Lcn + RunLength) < Distance) {

                            Min = MinMatch;
                        }
                    }
                }
            }
        }
    }

    *RunIndex = Min;

#ifdef NTFS_CHECK_CACHED_RUNS
    if (FoundRun) {

        LcnIndex = CachedRuns->LengthArray[ Min ];
        ASSERT( LcnIndex != NTFS_CACHED_RUNS_DEL_INDEX );

        ThisEntry = CachedRuns->LcnArray + LcnIndex;
        ASSERT( RunLength == ThisEntry->RunLength );
    }
#endif

    DebugTrace( 0, Dbg, ("*RunIndex = %04x\n", *RunIndex) );
    DebugTrace( -1, Dbg, ("NtfsPositionCachedLcnByLength -> %01x\n", FoundRun) );

    return FoundRun;
}

#ifdef NTFS_CHECK_CACHED_RUNS

//
//  Local support routine
//

VOID
NtfsVerifyCachedLcnRuns (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN SkipSortCheck,
    IN BOOLEAN SkipBinCheck
    )

/*++

Routine Description:

    This routine is called to verify the state of the cached runs arrays.

Arguments:

    CachedRuns - Pointer to the cached runs structure

    FirstIndex - Index that marks the start of the newest range of deleted
        entries.  This new range will not be in a deleted window yet.

    LastIndex - The index of the last entry in the newest range of deleted
        entries.  This new range will not be in a deleted window yet.

    SkipSortCheck - If TRUE, the list may be out of order at this time and
        we should skip the checks for overlapping ranges or length sorts.

    SkipBinCheck - If TRUE, the BinArray may be out of sync and should not
        be checked.

Return Value:

    None

--*/

{
    USHORT Index;
    USHORT BinArray[ NTFS_CACHED_RUNS_BIN_COUNT ];
    USHORT LcnWindowIndex = 0;
    PNTFS_LCN_CLUSTER_RUN ThisEntry;
    PNTFS_LCN_CLUSTER_RUN LastEntry = NULL;
    PNTFS_DELETED_RUNS LcnDelWindow = NULL;
    PNTFS_DELETED_RUNS NextWindow;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsVerifyCachedLcnRuns\n") );

    ASSERT( CachedRuns->Used <= CachedRuns->Avail );

    //
    //  Initialize the tracking variables.
    //

    RtlZeroMemory( BinArray, NTFS_CACHED_RUNS_BIN_COUNT * sizeof( USHORT ));

    if (CachedRuns->DelLcnCount != 0) {

        LcnDelWindow = CachedRuns->DeletedLcnWindows;
    }

    ASSERT( CachedRuns->DelLcnCount <= NTFS_CACHED_RUNS_MAX_DEL_WINDOWS );

    //
    //  Verify that every element in the Lcn-sorted list is correctly
    //  ordered.  If it's RunLength is 0, make certain its index is
    //  recorded in a window of deleted entries.  If its LengthIndex is
    //  not NTFS_CACHED_RUNS_DEL_INDEX, make sure it refers to an entry in
    //  the length-sorted list that refers back to it and is in a window of
    //  deleted entries if and only if RunLength is 0.
    //

    for (Index = 0, ThisEntry = CachedRuns->LcnArray;
         Index < CachedRuns->Avail;
         Index += 1, ThisEntry += 1) {

        //
        //  This entry is not deleted.
        //

        if (ThisEntry->RunLength != 0) {

            //
            //  Better be in the used region with valid indexes.
            //

            ASSERT( Index < CachedRuns->Used );
            ASSERT( ThisEntry->LengthIndex != NTFS_CACHED_RUNS_DEL_INDEX );
            ASSERT( ThisEntry->LengthIndex < CachedRuns->Used );
            ASSERT( ThisEntry->Lcn != UNUSED_LCN );

            //
            //  Verify that the entry is not in the current window of deleted
            //  entries.
            //

            ASSERT( (LcnDelWindow == NULL) ||
                    (LcnDelWindow->StartIndex > Index) );

            //
            //  Verify the sort order.
            //

            ASSERT( (LastEntry == NULL) ||
                    SkipSortCheck ||
                    (ThisEntry->Lcn > (LastEntry->Lcn + LastEntry->RunLength)) );

            LastEntry = ThisEntry;

            //
            //  Make certain that the corresponding entry in the Length-sorted
            //  list points back to this entry.
            //

            ASSERT( CachedRuns->LengthArray[ ThisEntry->LengthIndex ] == Index );

            //
            //  Keep track of how many entries have this length.
            //

            if (ThisEntry->RunLength <= CachedRuns->Bins) {

                BinArray[ ThisEntry->RunLength - 1 ] += 1;
            }

        //
        //  This is a deleted entry.  Make sure it is in the deleted window array.
        //

        } else {

            ASSERT( ThisEntry->LengthIndex == NTFS_CACHED_RUNS_DEL_INDEX );

            //
            //  Verify that the entry is in the current window of deleted
            //  entries unless we have excluded this entry.
            //

            if ((FirstIndex != NTFS_CACHED_RUNS_DEL_INDEX) &&
                (LastIndex != NTFS_CACHED_RUNS_DEL_INDEX) &&
                ((FirstIndex > Index) ||
                 (LastIndex < Index))) {

                ASSERT( (LcnDelWindow != NULL) &&
                        (LcnDelWindow->StartIndex <= Index) &&
                        (LcnDelWindow->EndIndex >= Index) );
            }

            //
            //  Advance the window of deleted entries if we are at the end.
            //

            if ((LcnDelWindow != NULL) && (LcnDelWindow->EndIndex == Index)) {

                LcnWindowIndex += 1;
                if (LcnWindowIndex < CachedRuns->DelLcnCount) {

                    LcnDelWindow += 1;

                } else {

                    LcnDelWindow = NULL;
                }
            }
        }
    }

    //
    //  We should have walked past all of the deleted entries.
    //

    //
    //  Make certain that the windows are in order and don't overlap.
    //

    for (LcnWindowIndex = 0, LcnDelWindow = NextWindow = CachedRuns->DeletedLcnWindows;
         LcnWindowIndex < CachedRuns->DelLcnCount;
         LcnWindowIndex += 1, NextWindow += 1) {

        ASSERT( NextWindow->StartIndex <= NextWindow->EndIndex );
        if (NextWindow != LcnDelWindow) {

            ASSERT( NextWindow->StartIndex > (LcnDelWindow->EndIndex + 1) );
            LcnDelWindow += 1;
        }
    }

    //
    //  Verify that the histogram of RunLengths is correct.
    //

    for (Index = 0;
         Index < NTFS_CACHED_RUNS_BIN_COUNT;
         Index += 1) {

        ASSERT( SkipBinCheck || (BinArray[ Index ] == CachedRuns->BinArray[ Index ]) );
    }

    DebugTrace( -1, Dbg, ("NtfsVerifyCachedLcnRuns -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsVerifyCachedLenRuns (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN SkipSortCheck
    )

/*++

Routine Description:

    This routine is called to verify the state of the cached runs arrays.

Arguments:

    CachedRuns - Pointer to the cached runs structure

    FirstIndex - Index that marks the start of the newest range of deleted
        entries.  This new range will not be in a deleted window yet.

    LastIndex - The index of the last entry in the newest range of deleted
        entries.  This new range will not be in a deleted window yet.

    SkipSortCheck - If TRUE, the list may be out of order at this time and
        we should skip the checks for overlapping ranges or length sorts.

Return Value:

    None

--*/

{
    USHORT Index;
    USHORT LenWindowIndex = 0;
    PNTFS_LCN_CLUSTER_RUN ThisEntry;
    PNTFS_LCN_CLUSTER_RUN LastEntry = NULL;
    PNTFS_DELETED_RUNS LenDelWindow = NULL;
    PNTFS_DELETED_RUNS NextWindow;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsVerifyCachedLenRuns\n") );

    ASSERT( CachedRuns->Used <= CachedRuns->Avail );

    //
    //  Initialize the tracking variables.
    //

    if (CachedRuns->DelLengthCount != 0) {

        LenDelWindow = CachedRuns->DeletedLengthWindows;
    }

    ASSERT( CachedRuns->DelLengthCount <= NTFS_CACHED_RUNS_MAX_DEL_WINDOWS );

    //
    //  Verify that every element in the Length-sorted list is correctly
    //  ordered.  If it's index is NTFS_CACHED_RUNS_DEL_INDEX, make certain
    //  its index is recorded in a window of deleted entries.  Otherwise,
    //  make certain that its Index refers to an entry in the lcn-sorted list
    //  that refers back to it.
    //

    for (Index = 0; Index < CachedRuns->Avail; Index += 1) {

        //
        //  Verify any entry not in a deleted window.
        //

        if (CachedRuns->LengthArray[ Index ] != NTFS_CACHED_RUNS_DEL_INDEX) {

            ASSERT( Index < CachedRuns->Used );
            ASSERT( CachedRuns->LengthArray[ Index ] < CachedRuns->Used );
            ThisEntry = CachedRuns->LcnArray + CachedRuns->LengthArray[ Index ];

            //
            //  Verify that the corresponding Lcn-sorted entry is not deleted.
            //

            ASSERT( ThisEntry->RunLength != 0 );

            //
            //  Verify that the entry is not in the current window of deleted
            //  entries.
            //

            ASSERT( (LenDelWindow == NULL) ||
                    (LenDelWindow->StartIndex > Index) );

            //
            //  Verify the sort order if we have the previous entry.
            //

            ASSERT( (LastEntry == NULL) ||
                    SkipSortCheck ||
                    (LastEntry->RunLength < ThisEntry->RunLength) ||
                    ((LastEntry->RunLength == ThisEntry->RunLength) &&
                     (ThisEntry->Lcn > (LastEntry->Lcn + LastEntry->RunLength))) );

            LastEntry = ThisEntry;

            //
            //  Make certain that the corresponding entry in the Lcn-sorted
            //  list points back to this entry.
            //

            ASSERT( ThisEntry->LengthIndex == Index );

        //
        //  The entry is deleted.
        //

        } else {

            //
            //  Verify that the entry is in the current window of deleted
            //  entries unless we have excluded this entry.
            //

            if ((FirstIndex != NTFS_CACHED_RUNS_DEL_INDEX) &&
                (LastIndex != NTFS_CACHED_RUNS_DEL_INDEX) &&
                ((FirstIndex > Index) ||
                 (LastIndex < Index))) {

                //
                //  Verify that the entry is in the current window of deleted
                //  entries.
                //

                ASSERT( (LenDelWindow != NULL) &&
                        (LenDelWindow->StartIndex <= Index) &&
                        (LenDelWindow->EndIndex >= Index) );
            }
        }

        //
        //  Advance the window of deleted entries if we are at the end.
        //

        if ((LenDelWindow != NULL) && (LenDelWindow->EndIndex == Index)) {

            LenWindowIndex += 1;
            if (LenWindowIndex < CachedRuns->DelLengthCount) {

                LenDelWindow += 1;

            } else {

                LenDelWindow = NULL;
            }
        }
    }

    //
    //  We should have walked past all of the deleted entries.
    //

    ASSERT( LenDelWindow == NULL );

    //
    //  Make certain that the windows are in order and don't overlap.
    //

    for (LenWindowIndex = 0, LenDelWindow = NextWindow = CachedRuns->DeletedLengthWindows;
         LenWindowIndex < CachedRuns->DelLengthCount;
         LenWindowIndex += 1, NextWindow += 1) {

        ASSERT( NextWindow->StartIndex <= NextWindow->EndIndex );
        if (NextWindow != LenDelWindow) {

            ASSERT( NextWindow->StartIndex > (LenDelWindow->EndIndex + 1) );
            LenDelWindow += 1;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsVerifyCachedLenRuns -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsVerifyCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN BOOLEAN SkipSortCheck,
    IN BOOLEAN SkipBinCheck
    )

/*++

Routine Description:

    This routine is called to verify the state of the cached runs arrays.

Arguments:

    CachedRuns - Pointer to the cached runs structure

    SkipSortCheck - If TRUE, the list may be out of order at this time and
        we should skip the checks for overlapping ranges or length sorts.

    SkipBinCheck - If TRUE, the BinArray may be out of sync and should not
        be checked.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsVerifyCachedRuns\n") );

    NtfsVerifyCachedLcnRuns ( CachedRuns,
                              NTFS_CACHED_RUNS_DEL_INDEX,
                              NTFS_CACHED_RUNS_DEL_INDEX,
                              SkipSortCheck,
                              SkipBinCheck );

    NtfsVerifyCachedLenRuns ( CachedRuns,
                              NTFS_CACHED_RUNS_DEL_INDEX,
                              NTFS_CACHED_RUNS_DEL_INDEX,
                              SkipSortCheck );

    DebugTrace( -1, Dbg, ("NtfsVerifyCachedRuns -> VOID\n") );

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\cleanup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Cleanup.c

Abstract:

    This module implements the File Cleanup routine for Ntfs called by the
    dispatch driver.

Author:

    Your Name       [Email]         dd-Mon-Year

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_CLEANUP)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLEANUP)

#ifdef BRIANDBG
ULONG NtfsCleanupDiskFull = 0;
ULONG NtfsCleanupNoPool = 0;
#endif

#ifdef BRIANDBG
LONG
NtfsFsdCleanupExceptionFilter (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonCleanup)
#pragma alloc_text(PAGE, NtfsFsdCleanup)
#pragma alloc_text(PAGE, NtfsTrimNormalizedNames)
#endif


NTSTATUS
NtfsFsdCleanup (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of Cleanup.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext = NULL;
    IRP_CONTEXT LocalIrpContext;

    ULONG LogFileFullCount = 0;

    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS
    //

    if (VolumeDeviceObject->DeviceObject.Size == (USHORT)sizeof(DEVICE_OBJECT)) {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FILE_OPENED;

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );

        return STATUS_SUCCESS;
    }

    DebugTrace( +1, Dbg, ("NtfsFsdCleanup\n") );

    //
    //  Call the common Cleanup routine
    //

    FsRtlEnterFileSystem();

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );

    //
    //  Do the following in a loop to catch the log file full and cant wait
    //  calls.
    //

    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {

                //
                //  Allocate and initialize the Irp.  Always use the local IrpContext
                //  for cleanup.  It is never posted.
                //

                IrpContext = &LocalIrpContext;
                NtfsInitializeIrpContext( Irp, TRUE, &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );

                if (++LogFileFullCount >= 2) {

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_EXCESS_LOG_FULL );
                }
            }
            Status = NtfsCommonCleanup( IrpContext, Irp );
            break;

#ifdef BRIANDBG
        } except(NtfsFsdCleanupExceptionFilter( IrpContext, GetExceptionInformation() )) {
#else
        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {
#endif

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  exception code
            //

            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdCleanup -> %08lx\n", Status) );

    return Status;
}



NTSTATUS
NtfsCommonCleanup (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Cleanup called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PLCB Lcb;
    PLCB LcbForUpdate;
    PLCB LcbForCounts;
    PSCB ParentScb = NULL;
    PFCB ParentFcb = NULL;

    PLCB ThisLcb;
    PSCB ThisScb;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PLONGLONG TruncateSize = NULL;
    LONGLONG LocalTruncateSize;

    BOOLEAN DeleteFile = FALSE;
    BOOLEAN DeleteStream = FALSE;
    BOOLEAN OpenById;
    BOOLEAN RemoveLink;

    BOOLEAN AcquiredParentScb = FALSE;
    BOOLEAN VolumeMounted = TRUE;
    LOGICAL VolumeMountedReadOnly;
    BOOLEAN AcquiredObjectID = FALSE;

    BOOLEAN CleanupAttrContext = FALSE;

    BOOLEAN UpdateDuplicateInfo = FALSE;
    BOOLEAN AddToDelayQueue = TRUE;
    BOOLEAN UnlockedVolume = FALSE;
    BOOLEAN DeleteFromFcbTable = FALSE;

    USHORT TotalLinkAdj = 0;
    PLIST_ENTRY Links;

    NAME_PAIR NamePair;
    NTFS_TUNNELED_DATA TunneledData;

    ULONG FcbStateClearFlags = 0;

    BOOLEAN DecrementScb = FALSE;
    PSCB ImageScb;

#ifdef BRIANDBG
    BOOLEAN DecrementedCleanupCount = FALSE;
#endif

    PSCB CurrentParentScb;
    BOOLEAN AcquiredCheckpoint = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    NtfsInitializeNamePair( &NamePair );

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonCleanup\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    Status = STATUS_SUCCESS;

    //
    //  Special case the unopened file object and stream files.
    //

    if ((TypeOfOpen == UnopenedFileObject) ||
        (TypeOfOpen == StreamFileOpen)) {

        //
        //  Just set the FO_CLEANUP_COMPLETE flag, and get outsky...
        //

        SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

        //
        //  Theoretically we should never hit this case.  It means an app
        //  tried to close a handle he didn't open (call NtClose with a handle
        //  value that happens to be in the handle table).  It is safe to
        //  simply return SUCCESS in this case.
        //
        //  Trigger an assert so we can find the bad app though.
        //

        ASSERT( TypeOfOpen != StreamFileOpen );

        DebugTrace( -1, Dbg, ("NtfsCommonCleanup -> %08lx\n", Status) );
        NtfsCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Remember if this is an open by file Id open.
    //

    OpenById = BooleanFlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID );

    //
    //  Remember the source info flags in the Ccb.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;


    //
    //  Acquire exclusive access to the Vcb and enqueue the irp if we didn't
    //  get access
    //

    if (TypeOfOpen == UserVolumeOpen) {

        if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DASD_UNLOCK )) {

            //
            //  Start by locking out all other checkpoint
            //  operations.
            //

            NtfsAcquireCheckpointSynchronization( IrpContext, Vcb );
            AcquiredCheckpoint = TRUE;
        }

        ASSERTMSG( "Acquire could fail.\n", FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) );

        NtfsAcquireExclusiveVcb( IrpContext, Vcb, FALSE );

    } else {

        //
        //  We will never have the checkpoint here so we can raise if dismounted
        //

        ASSERT( !AcquiredCheckpoint );
        NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
    }

    //
    //  Remember if the volume has been dismounted.  No point in makeing any disk
    //  changes in that case.
    //

    if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

        VolumeMounted = FALSE;
    }

    VolumeMountedReadOnly =  (LOGICAL)NtfsIsVolumeReadOnly( Vcb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire Paging I/O first, since we may be deleting or truncating.
        //  Testing for the PagingIoResource is not really safe without
        //  holding the main resource, so we correct for that below.
        //

        if (Fcb->PagingIoResource != NULL) {

            NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
            NtfsAcquireExclusiveScb( IrpContext, Scb );

        } else {

            NtfsAcquireExclusiveScb( IrpContext, Scb );

            //
            //  If we now do not see a paging I/O resource we are golden,
            //  othewise we can absolutely release and acquire the resources
            //  safely in the right order, since a resource in the Fcb is
            //  not going to go away.
            //

            if (Fcb->PagingIoResource != NULL) {
                NtfsReleaseScb( IrpContext, Scb );
                NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
                NtfsAcquireExclusiveScb( IrpContext, Scb );
            }
        }

        LcbForUpdate = LcbForCounts = Lcb = Ccb->Lcb;

        if (Lcb != NULL) {

            ParentScb = Lcb->Scb;

            if (ParentScb != NULL) {

                ParentFcb = ParentScb->Fcb;
            }
        }

        if (VolumeMounted && !VolumeMountedReadOnly) {

            //
            //  Update the Lcb/Scb to reflect the case where this opener had
            //  specified delete on close.
            //

            if (FlagOn( Ccb->Flags, CCB_FLAG_DELETE_ON_CLOSE )) {

                if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

                    BOOLEAN LastLink;
                    BOOLEAN NonEmptyIndex;

                    //
                    //  It is ok to get rid of this guy.  All we need to do is
                    //  mark this Lcb for delete and decrement the link count
                    //  in the Fcb.  If this is a primary link, then we
                    //  indicate that the primary link has been deleted.
                    //

                    if (!LcbLinkIsDeleted( Lcb ) &&
                        (!IsDirectory( &Fcb->Info ) ||
                         NtfsIsLinkDeleteable( IrpContext, Fcb, &NonEmptyIndex, &LastLink))) {

                        //
                        //  Walk through all of the Scb's for this stream and
                        //  make sure there are no active image sections.
                        //

                        ImageScb = NULL;

                        while ((ImageScb = NtfsGetNextChildScb( Fcb, ImageScb )) != NULL) {

                            InterlockedIncrement( &ImageScb->CloseCount );
                            DecrementScb = TRUE;

                            if (NtfsIsTypeCodeUserData( ImageScb->AttributeTypeCode ) &&
                                !FlagOn( ImageScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED ) &&
                                (ImageScb->NonpagedScb->SegmentObject.ImageSectionObject != NULL)) {

                                if (!MmFlushImageSection( &ImageScb->NonpagedScb->SegmentObject,
                                                          MmFlushForDelete )) {

                                    InterlockedDecrement( &ImageScb->CloseCount );
                                    DecrementScb = FALSE;
                                    break;
                                }
                            }

                            InterlockedDecrement( &ImageScb->CloseCount );
                            DecrementScb = FALSE;
                        }

                        if (ImageScb == NULL) {

                            if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS )) {

                                SetFlag( Fcb->FcbState, FCB_STATE_PRIMARY_LINK_DELETED );
                            }

                            Fcb->LinkCount -= 1;

                            SetFlag( Lcb->LcbState, LCB_STATE_DELETE_ON_CLOSE );

                            //
                            //  Call into the notify package to close any handles on
                            //  a directory being deleted.
                            //

                            if (IsDirectory( &Fcb->Info )) {

                                FsRtlNotifyFilterChangeDirectory( Vcb->NotifySync,
                                                                  &Vcb->DirNotifyList,
                                                                  FileObject->FsContext,
                                                                  NULL,
                                                                  FALSE,
                                                                  FALSE,
                                                                  0,
                                                                  NULL,
                                                                  NULL,
                                                                  NULL,
                                                                  NULL );
                            }
                        }
                    }

                //
                //  Otherwise we are simply removing the attribute.
                //

                } else {

                    ImageScb = Scb;
                    InterlockedIncrement( &ImageScb->CloseCount );
                    DecrementScb = TRUE;

                    if ((ImageScb->NonpagedScb->SegmentObject.ImageSectionObject == NULL) ||
                        MmFlushImageSection( &ImageScb->NonpagedScb->SegmentObject,
                                             MmFlushForDelete )) {

                        SetFlag( Scb->ScbState, SCB_STATE_DELETE_ON_CLOSE );
                    }

                    InterlockedDecrement( &ImageScb->CloseCount );
                    DecrementScb = FALSE;
                }

                //
                //  Clear the flag so we will ignore it in the log file full case.
                //

                ClearFlag( Ccb->Flags, CCB_FLAG_DELETE_ON_CLOSE );
            }

            //
            //  If we are going to try and delete something, anything, knock the file
            //  size and valid data down to zero.  Then update the snapshot
            //  so that the sizes will be zero even if the operation fails.
            //
            //  If we're deleting the file, go through all of the Scb's.
            //

            if ((Fcb->LinkCount == 0) &&
                (Fcb->CleanupCount == 1)) {

                DeleteFile = TRUE;
                NtfsFreeSnapshotsForFcb( IrpContext, Scb->Fcb );

                for (Links = Fcb->ScbQueue.Flink;
                     Links != &Fcb->ScbQueue;
                     Links = Links->Flink) {

                    ThisScb = CONTAINING_RECORD( Links, SCB, FcbLinks );

                    //
                    //  Set the Scb sizes to zero except for the attribute list.
                    //

                    if ((ThisScb->AttributeTypeCode != $ATTRIBUTE_LIST) &&
                        (ThisScb->AttributeTypeCode != $REPARSE_POINT)) {

                        //
                        //  If the file is non-resident we will need a file object
                        //  when we delete the allocation.  Create it now
                        //  so that CC will know the stream is shrinking to zero
                        //  and will purge the data.
                        //

                        if ((ThisScb->FileObject == NULL) &&
                            (ThisScb->AttributeTypeCode == $DATA) &&
                            (ThisScb->NonpagedScb->SegmentObject.DataSectionObject != NULL) &&
                            !FlagOn( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                            //
                            //  Use a try-finally here in case we get an
                            //  INSUFFICIENT_RESOURCES.  We still need to
                            //  proceed with the delete.
                            //

                            try {

                                NtfsCreateInternalAttributeStream( IrpContext,
                                                                   ThisScb,
                                                                   TRUE,
                                                                   &NtfsInternalUseFile[COMMONCLEANUP_FILE_NUMBER] );

                            } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                if (Status == STATUS_INSUFFICIENT_RESOURCES) {

                                    Status = STATUS_SUCCESS;
                                }
                            }
                        }

                        ThisScb->Header.FileSize =
                        ThisScb->Header.ValidDataLength = Li0;
                    }

                    if (FlagOn( ThisScb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

                        NtfsSnapshotScb( IrpContext, ThisScb );
                    }
                }

            //
            //  Otherwise we may only be deleting this stream.
            //

            } else if (FlagOn( Scb->ScbState, SCB_STATE_DELETE_ON_CLOSE ) &&
                       (Scb->CleanupCount == 1)) {

                try {

                    //
                    //  We may have expanded the quota here and currently own some
                    //  quota resource.  We want to release them now so we don't
                    //  deadlock with resources acquired later.
                    //

                    NtfsCheckpointCurrentTransaction( IrpContext );

                    if (IrpContext->SharedScb != NULL) {

                        NtfsReleaseSharedResources( IrpContext );
                    }

                    DeleteStream = TRUE;
                    Scb->Header.FileSize =
                    Scb->Header.ValidDataLength = Li0;

                    NtfsFreeSnapshotsForFcb( IrpContext, Scb->Fcb );

                    if (FlagOn( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

                        NtfsSnapshotScb( IrpContext, Scb );
                    }

                } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                    NOTHING;
                }
            }
        }

        //
        //  Let's do a sanity check.
        //

        ASSERT( Fcb->CleanupCount != 0 );
        ASSERT( Scb->CleanupCount != 0 );

        //
        //  Case on the type of open that we are trying to cleanup.
        //

        switch (TypeOfOpen) {

        case UserVolumeOpen :

            DebugTrace( 0, Dbg, ("Cleanup on user volume\n") );

            //
            //  First set the FO_CLEANUP_COMPLETE flag.
            //

            SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

            //
            //  For a volume open, we check if this open locked the volume.
            //  All the other work is done in common code below.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_LOCKED ) &&
                (((ULONG_PTR)Vcb->FileObjectWithVcbLocked & ~1) == (ULONG_PTR)FileObject)) {

                //
                //  Note its unlock attempt and retry so we can serialize with checkpoints
                //

                if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DASD_UNLOCK )) {
                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_DASD_UNLOCK );
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

                if ((ULONG_PTR)Vcb->FileObjectWithVcbLocked == ((ULONG_PTR)FileObject)+1) {

                    NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );

                //
                //  Purge the volume for the autocheck case.
                //

                } else if (FlagOn( FileObject->Flags, FO_FILE_MODIFIED )) {

                    if (VolumeMounted && !VolumeMountedReadOnly) {

                        //
                        //  Drop the Scb for the volume Dasd around this call.
                        //

                        NtfsReleaseScb( IrpContext, Scb );

                        try {

                            NtfsFlushVolume( IrpContext, Vcb, FALSE, TRUE, TRUE, FALSE );

                        } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                            NOTHING;
                        }

                        NtfsAcquireExclusiveScb( IrpContext, Scb );
                    }

                    //
                    //  If this is not the boot partition then dismount the Vcb.
                    //

#ifdef SYSCACHE_DEBUG
                    if ((((Vcb->SyscacheScb) && (Vcb->CleanupCount == 2)) || (Vcb->CleanupCount == 1)) &&

#else
                    if ((Vcb->CleanupCount == 1) &&
#endif
                        ((Vcb->CloseCount - Vcb->SystemFileCloseCount) == 1)) {

                        try {

                            NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );

                        } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                            NOTHING;
                        }
                    }
                }

                ClearFlag( Vcb->VcbState, VCB_STATE_LOCKED | VCB_STATE_EXPLICIT_LOCK );
                Vcb->FileObjectWithVcbLocked = NULL;
                UnlockedVolume = TRUE;

                //
                //  If the quota tracking has been requested and the quotas
                //  need to be repaired then try to repair them now.  Also restart
                //  the Usn journal deletion if it was underway.
                //

                if (VolumeMounted && !VolumeMountedReadOnly) {

                    if ((Status == STATUS_SUCCESS) &&
                        (Vcb->DeleteUsnData.FinalStatus == STATUS_VOLUME_DISMOUNTED)) {

                        Vcb->DeleteUsnData.FinalStatus = STATUS_SUCCESS;

                        try {

                            NtfsPostSpecial( IrpContext, Vcb, NtfsDeleteUsnSpecial, &Vcb->DeleteUsnData );

                        } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                            NOTHING;
                        }
                    }

                    if ((Status == STATUS_SUCCESS) &&
                        FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED) &&
                        FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_OUT_OF_DATE |
                                                 QUOTA_FLAG_CORRUPT |
                                                 QUOTA_FLAG_PENDING_DELETES)) {

                        try {
                            NtfsPostRepairQuotaIndex( IrpContext, Vcb );

                        } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                            NOTHING;
                        }
                    }
                }
            }

            break;

        case UserViewIndexOpen :
        case UserDirectoryOpen :

            DebugTrace( 0, Dbg, ("Cleanup on user directory/file\n") );

            NtfsSnapshotScb( IrpContext, Scb );

            //
            //  Capture any changes to the time stamps for this file.
            //

            NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );

            //
            //  Now set the FO_CLEANUP_COMPLETE flag.
            //

            SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

            //
            //  To perform cleanup on a directory, we first complete any
            //  Irps watching from this directory.  If we are deleting the
            //  file then we remove all prefix entries for all the Lcb's going
            //  into this directory and delete the file.  We then report to
            //  dir notify that this file is going away.
            //

            //
            //  Complete any Notify Irps on this file handle.
            //

            if (FlagOn( Ccb->Flags, CCB_FLAG_DIR_NOTIFY )) {

                //
                //  Both the notify count and notify list are separate for view
                //  indices versus file name indices (directories).
                //

                if (TypeOfOpen == UserViewIndexOpen) {

                    FsRtlNotifyCleanup( Vcb->NotifySync, &Vcb->ViewIndexNotifyList, Ccb );
                    ClearFlag( Ccb->Flags, CCB_FLAG_DIR_NOTIFY );
                    InterlockedDecrement( &Vcb->ViewIndexNotifyCount );

                } else {

                    FsRtlNotifyCleanup( Vcb->NotifySync, &Vcb->DirNotifyList, Ccb );
                    ClearFlag( Ccb->Flags, CCB_FLAG_DIR_NOTIFY );
                    InterlockedDecrement( &Vcb->NotifyCount );
                }
            }

            //
            //  Try to remove normalized name if its long and  if no handles active (only this 1 left)
            //  and no lcbs are active - all notifies farther down in function
            //  use parent Scb's normalized name.  If we don't remove it here
            //  this always goes away during a close
            //

            if ((Scb->ScbType.Index.NormalizedName.MaximumLength > LONGNAME_THRESHOLD) &&
                (Fcb->CleanupCount == 1)) {

                //
                //  Cleanup the current scb node and then trim its parents
                //

                NtfsDeleteNormalizedName( Scb );

                if (Lcb != NULL) {
                    CurrentParentScb = Lcb->Scb;
                } else {
                    CurrentParentScb = NULL;
                }

                if ((CurrentParentScb != NULL) &&
                    (CurrentParentScb->ScbType.Index.NormalizedName.MaximumLength > LONGNAME_THRESHOLD)) {

                    NtfsTrimNormalizedNames( IrpContext, Fcb, CurrentParentScb );
                }
            }

            //
            //  When cleaning up a user directory, we always remove the
            //  share access and modify the file counts.  If the Fcb
            //  has been marked as delete on close and this is the last
            //  open file handle, we remove the file from the Mft and
            //  remove it from it's parent index entry.
            //

            if (VolumeMounted &&
               (!VolumeMountedReadOnly) &&
               ((SafeNodeType( Scb ) == NTFS_NTC_SCB_INDEX))) {

                if (DeleteFile) {

                    BOOLEAN AcquiredFcbTable = FALSE;

                    ASSERT( (Lcb == NULL) ||
                            (LcbLinkIsDeleted( Lcb ) && Lcb->CleanupCount == 1 ));

                    //
                    //  If we don't have an Lcb and there is one on the Fcb then
                    //  let's use it.
                    //

                    if ((Lcb == NULL) && !IsListEmpty( &Fcb->LcbQueue )) {

                        Lcb = CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                                 LCB,
                                                 FcbLinks );

                        ParentScb = Lcb->Scb;
                        if (ParentScb != NULL) {

                            ParentFcb = ParentScb->Fcb;
                        }
                    }

                    try {

                        //
                        //  In a very rare case the handle on a file may be an
                        //  OpenByFileID handle.  In that case we need to find
                        //  the parent for the remaining link on the file.
                        //

                        if (ParentScb == NULL) {

                            PFILE_NAME FileNameAttr;
                            UNICODE_STRING FileName;

                            NtfsInitializeAttributeContext( &AttrContext );
                            CleanupAttrContext = TRUE;

                            if (!NtfsLookupAttributeByCode( IrpContext,
                                                            Fcb,
                                                            &Fcb->FileReference,
                                                            $FILE_NAME,
                                                            &AttrContext )) {

                                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                            }

                            //
                            //  Now we need an Fcb and then an Scb for the directory.
                            //

                            FileNameAttr = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                            NtfsAcquireFcbTable( IrpContext, Vcb );
                            AcquiredFcbTable = TRUE;

                            ParentFcb = NtfsCreateFcb( IrpContext,
                                                       Vcb,
                                                       FileNameAttr->ParentDirectory,
                                                       FALSE,
                                                       TRUE,
                                                       NULL );

                            ParentFcb->ReferenceCount += 1;

                            if (!NtfsAcquireExclusiveFcb( IrpContext, ParentFcb, NULL, ACQUIRE_NO_DELETE_CHECK | ACQUIRE_DONT_WAIT )) {

                                NtfsReleaseFcbTable( IrpContext, Vcb );
                                NtfsAcquireExclusiveFcb( IrpContext, ParentFcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                                NtfsAcquireFcbTable( IrpContext, Vcb );
                            }

                            ParentFcb->ReferenceCount -= 1;

                            NtfsReleaseFcbTable( IrpContext, Vcb );
                            AcquiredFcbTable = FALSE;

                            ParentScb = NtfsCreateScb( IrpContext,
                                                       ParentFcb,
                                                       $INDEX_ALLOCATION,
                                                       &NtfsFileNameIndex,
                                                       FALSE,
                                                       NULL );

                            if (FlagOn(Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED)) {

                                NtfsSnapshotScb( IrpContext, Scb );
                            }

                            //
                            //  Make sure this new Scb is connected to our Fcb so teardown
                            //  will happen.
                            //

                            FileName.Buffer = &FileNameAttr->FileName[0];
                            FileName.MaximumLength =
                            FileName.Length = FileNameAttr->FileNameLength * sizeof( WCHAR );

                            NtfsCreateLcb( IrpContext,
                                           ParentScb,
                                           Fcb,
                                           FileName,
                                           FileNameAttr->Flags,
                                           NULL );

                            AcquiredParentScb = TRUE;
                        }

                        NtfsDeleteFile( IrpContext, Fcb, ParentScb, &AcquiredParentScb, NULL, NULL );

                        //
                        //  Commit the delete - this has the nice effect of writing out all usn journal records for the
                        //  delete after this we can safely remove the in memory structures (esp. the fcbtable)
                        //  and not worry about retrying the request due to a logfilefull
                        //

                        NtfsCheckpointCurrentTransaction( IrpContext );

                        TotalLinkAdj += 1;

                        //
                        //  Remove all tunneling entries for this directory
                        //

                        FsRtlDeleteKeyFromTunnelCache( &Vcb->Tunnel,
                                                       *(PULONGLONG) &Fcb->FileReference );

                        if (ParentFcb != NULL) {

                            NtfsUpdateFcb( ParentFcb,
                                           (FCB_INFO_CHANGED_LAST_CHANGE |
                                            FCB_INFO_CHANGED_LAST_MOD |
                                            FCB_INFO_UPDATE_LAST_ACCESS) );
                        }

                    } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                        NOTHING;
                    }

                    if (AcquiredFcbTable) {

                        NtfsReleaseFcbTable( IrpContext, Vcb );
                    }

                    if (STATUS_SUCCESS == Status) {

                        if (!OpenById && (Vcb->NotifyCount != 0)) {

                            NtfsReportDirNotify( IrpContext,
                                                 Vcb,
                                                 &Ccb->FullFileName,
                                                 Ccb->LastFileNameOffset,
                                                 NULL,
                                                 ((FlagOn( Ccb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                                   (Ccb->Lcb != NULL) &&
                                                   (Ccb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                                  &Ccb->Lcb->Scb->ScbType.Index.NormalizedName :
                                                  NULL),
                                                 FILE_NOTIFY_CHANGE_DIR_NAME,
                                                 FILE_ACTION_REMOVED,
                                                 ParentFcb );
                        }

                        SetFlag( Fcb->FcbState, FCB_STATE_FILE_DELETED );
                        SetFlag( FcbStateClearFlags, FCB_STATE_FILE_DELETED );
                        DeleteFromFcbTable = TRUE;

                        //
                        //  We need to mark all of the links on the file as gone.
                        //  If there is a parent Scb then it will be the parent
                        //  for all of the links.
                        //

                        for (Links = Fcb->LcbQueue.Flink;
                             Links != &Fcb->LcbQueue;
                             Links = Links->Flink) {

                            ThisLcb = CONTAINING_RECORD( Links, LCB, FcbLinks );

                            //
                            //  Remove all remaining prefixes on this link.
                            //  Make sure the resource is acquired.
                            //

                            if (!AcquiredParentScb) {

                                NtfsAcquireExclusiveScb( IrpContext, ParentScb );
                                AcquiredParentScb = TRUE;
                            }

                            NtfsRemovePrefix( ThisLcb );

                            //
                            //  Remove any hash table entries for this Lcb.
                            //

                            NtfsRemoveHashEntriesForLcb( ThisLcb );

                            SetFlag( ThisLcb->LcbState, LCB_STATE_LINK_IS_GONE );

                            //
                            //  We don't need to report any changes on this link.
                            //

                            ThisLcb->InfoFlags = 0;
                        }

                        //
                        //  We need to mark all of the Scbs as gone.
                        //

                        for (Links = Fcb->ScbQueue.Flink;
                             Links != &Fcb->ScbQueue;
                             Links = Links->Flink) {

                            ThisScb = CONTAINING_RECORD( Links, SCB, FcbLinks );

                            ClearFlag( ThisScb->ScbState,
                                       SCB_STATE_NOTIFY_ADD_STREAM |
                                       SCB_STATE_NOTIFY_REMOVE_STREAM |
                                       SCB_STATE_NOTIFY_RESIZE_STREAM |
                                       SCB_STATE_NOTIFY_MODIFY_STREAM );

                            if (!FlagOn( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

                                NtfsSnapshotScb( IrpContext, ThisScb );

                                ThisScb->ValidDataToDisk =
                                ThisScb->Header.AllocationSize.QuadPart =
                                ThisScb->Header.FileSize.QuadPart =
                                ThisScb->Header.ValidDataLength.QuadPart = 0;

                                SetFlag( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
                            }
                        }

                        //
                        //  We certainly don't need to any on disk update for this
                        //  file now.
                        //

                        Fcb->InfoFlags = 0;
                        ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

                        ClearFlag( Ccb->Flags,
                                   CCB_FLAG_USER_SET_LAST_MOD_TIME |
                                   CCB_FLAG_USER_SET_LAST_CHANGE_TIME |
                                   CCB_FLAG_USER_SET_LAST_ACCESS_TIME );

                    }


                } else {

                    //
                    //  Determine if we should put this on the delayed close list.
                    //  The following must be true.
                    //
                    //  - This is not the root directory
                    //  - This directory is not about to be deleted
                    //  - This is the last handle and last file object for this
                    //      directory.
                    //  - There are no other file objects on this file.
                    //  - We are not currently reducing the delayed close queue.
                    //

                    if ((Fcb->CloseCount == 1) &&
                        (NtfsData.DelayedCloseCount <= NtfsMaxDelayedCloseCount)) {

                        NtfsAcquireFsrtlHeader( Scb );
                        SetFlag( Scb->ScbState, SCB_STATE_DELAY_CLOSE );
                        NtfsReleaseFsrtlHeader( Scb );
                    }
                }
            }

            break;

        case UserFileOpen :

            DebugTrace( 0, Dbg, ("Cleanup on user file\n") );

            //
            //  If the Scb is uninitialized, we read it from the disk.
            //

            if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED ) &&
                VolumeMounted &&
                !VolumeMountedReadOnly) {

                try {

                    NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );

                } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                    NOTHING;
                }
            }

            NtfsSnapshotScb( IrpContext, Scb );

            //
            //  Coordinate the cleanup operation with the oplock state.
            //  Cleanup operations can always cleanup immediately.
            //

            if (SafeNodeType( Scb ) == NTFS_NTC_SCB_DATA) {
                FsRtlCheckOplock( &Scb->ScbType.Data.Oplock,
                                  Irp,
                                  IrpContext,
                                  NULL,
                                  NULL );
            }


            //
            //  In this case, we have to unlock all the outstanding file
            //  locks, update the time stamps for the file and sizes for
            //  this attribute, and set the archive bit if necessary.
            //

            if (SafeNodeType( Scb ) == NTFS_NTC_SCB_DATA &&
                Scb->ScbType.Data.FileLock != NULL) {

                (VOID) FsRtlFastUnlockAll( Scb->ScbType.Data.FileLock,
                                           FileObject,
                                           IoGetRequestorProcess( Irp ),
                                           NULL );
            }

            //
            //  Update the FastIoField.
            //

            NtfsAcquireFsrtlHeader( Scb );
            Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
            NtfsReleaseFsrtlHeader( Scb );

            //
            //  Trim normalized names of parent dirs if they are over the threshold
            //

            ASSERT( IrpContext->TransactionId == 0 );

            if (Fcb->CleanupCount == 1) {

                if (Lcb != NULL) {
                    CurrentParentScb = Lcb->Scb;
                } else {
                    CurrentParentScb = NULL;
                }

                if ((CurrentParentScb != NULL) &&
                    (CurrentParentScb->ScbType.Index.NormalizedName.MaximumLength > LONGNAME_THRESHOLD)) {

                    NtfsTrimNormalizedNames( IrpContext, Fcb, CurrentParentScb );
                }

            } //  endif cleanupcnt == 1


            //
            //  If the Fcb is in valid shape, we check on the cases where we delete
            //  the file or attribute.
            //

            if (VolumeMounted && !VolumeMountedReadOnly) {

                //
                //  Capture any changes to the time stamps for this file.
                //

                NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );

                //
                //  Now set the FO_CLEANUP_COMPLETE flag.
                //

                SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

                if (Status == STATUS_SUCCESS) {

                    //
                    //  We are checking here for special actions we take when
                    //  we have the last user handle on a link and the link has
                    //  been marked for delete.  We could either be removing the
                    //  file or removing a link.
                    //

                    if ((Lcb == NULL) || (LcbLinkIsDeleted( Lcb ) && (Lcb->CleanupCount == 1))) {

                        if (DeleteFile) {

                            BOOLEAN AcquiredFcbTable = FALSE;

                            //
                            //  If we don't have an Lcb and the Fcb has some entries then
                            //  grab one of these to do the update.
                            //

                            if (Lcb == NULL) {

                                for (Links = Fcb->LcbQueue.Flink;
                                     Links != &Fcb->LcbQueue;
                                     Links = Links->Flink) {

                                    ThisLcb = CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                                                 LCB,
                                                                 FcbLinks );

                                    if (!FlagOn( ThisLcb->LcbState, LCB_STATE_LINK_IS_GONE )) {

                                        Lcb = ThisLcb;

                                        ParentScb = Lcb->Scb;
                                        if (ParentScb != NULL) {

                                            ParentFcb = ParentScb->Fcb;
                                        }

                                        break;
                                    }
                                }
                            }

                            try {

                                //
                                //  In a very rare case the handle on a file may be an
                                //  OpenByFileID handle.  In that case we need to find
                                //  the parent for the remaining link on the file.
                                //

                                if (ParentScb == NULL) {

                                    PFILE_NAME FileNameAttr;
                                    UNICODE_STRING FileName;

                                    NtfsInitializeAttributeContext( &AttrContext );
                                    CleanupAttrContext = TRUE;

                                    if (!NtfsLookupAttributeByCode( IrpContext,
                                                                    Fcb,
                                                                    &Fcb->FileReference,
                                                                    $FILE_NAME,
                                                                    &AttrContext )) {

                                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                                    }

                                    //
                                    //  Now we need an Fcb and then an Scb for the directory.
                                    //

                                    FileNameAttr = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                                    NtfsAcquireFcbTable( IrpContext, Vcb );
                                    AcquiredFcbTable = TRUE;

                                    ParentFcb = NtfsCreateFcb( IrpContext,
                                                               Vcb,
                                                               FileNameAttr->ParentDirectory,
                                                               FALSE,
                                                               TRUE,
                                                               NULL );

                                    ParentFcb->ReferenceCount += 1;

                                    if (!NtfsAcquireExclusiveFcb( IrpContext, ParentFcb, NULL, ACQUIRE_NO_DELETE_CHECK | ACQUIRE_DONT_WAIT )) {

                                        NtfsReleaseFcbTable( IrpContext, Vcb );
                                        NtfsAcquireExclusiveFcb( IrpContext, ParentFcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                                        NtfsAcquireFcbTable( IrpContext, Vcb );
                                    }

                                    ParentFcb->ReferenceCount -= 1;

                                    NtfsReleaseFcbTable( IrpContext, Vcb );
                                    AcquiredFcbTable = FALSE;

                                    ParentScb = NtfsCreateScb( IrpContext,
                                                               ParentFcb,
                                                               $INDEX_ALLOCATION,
                                                               &NtfsFileNameIndex,
                                                               FALSE,
                                                               NULL );

                                    if (FlagOn(Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED)) {

                                        NtfsSnapshotScb( IrpContext, Scb );
                                    }

                                    //
                                    //  Make sure this new Scb is connected to our Fcb so teardown
                                    //  will happen.
                                    //

                                    FileName.Buffer = &FileNameAttr->FileName[0];
                                    FileName.MaximumLength =
                                    FileName.Length = FileNameAttr->FileNameLength * sizeof( WCHAR );

                                    NtfsCreateLcb( IrpContext,
                                                   ParentScb,
                                                   Fcb,
                                                   FileName,
                                                   FileNameAttr->Flags,
                                                   NULL );

                                    AcquiredParentScb = TRUE;
                                }

                                AddToDelayQueue = FALSE;
                                TunneledData.HasObjectId = FALSE;
                                NtfsDeleteFile( IrpContext, Fcb, ParentScb, &AcquiredParentScb, &NamePair, &TunneledData );

                                //
                                //  Commit the delete - this has the nice effect of writing out all usn journal records for the
                                //  delete after this we can safely remove the in memory structures (esp. the fcbtable)
                                //  and not worry about retrying the request due to a logfilefull
                                //

                                NtfsCheckpointCurrentTransaction( IrpContext );
                                TotalLinkAdj += 1;

                                //
                                //  Stash property information in the tunnel if the object was
                                //  opened by name, has a parent directory caller was treating it
                                //  as a non-POSIX object and we had an good, active link
                                //

                                if (!OpenById &&
                                    ParentScb &&
                                    Ccb->Lcb &&
                                    !FlagOn(FileObject->Flags, FO_OPENED_CASE_SENSITIVE)) {

                                    NtfsGetTunneledData( IrpContext,
                                                         Fcb,
                                                         &TunneledData );

                                    FsRtlAddToTunnelCache(  &Vcb->Tunnel,
                                                            *(PULONGLONG)&ParentScb->Fcb->FileReference,
                                                            &NamePair.Short,
                                                            &NamePair.Long,
                                                            BooleanFlagOn(Ccb->Lcb->FileNameAttr->Flags, FILE_NAME_DOS),
                                                            sizeof(NTFS_TUNNELED_DATA),
                                                            &TunneledData);
                                }

                                if (ParentFcb != NULL) {

                                    NtfsUpdateFcb( ParentFcb,
                                                   (FCB_INFO_CHANGED_LAST_CHANGE |
                                                    FCB_INFO_CHANGED_LAST_MOD |
                                                    FCB_INFO_UPDATE_LAST_ACCESS) );
                                }

                            } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                NOTHING;
                            }

                            if (AcquiredFcbTable) {

                                NtfsReleaseFcbTable( IrpContext, Vcb );
                            }

                            if (Status == STATUS_SUCCESS) {

                                if ((Vcb->NotifyCount != 0) &&
                                    !OpenById) {

                                    NtfsReportDirNotify( IrpContext,
                                                         Vcb,
                                                         &Ccb->FullFileName,
                                                         Ccb->LastFileNameOffset,
                                                         NULL,
                                                         ((FlagOn( Ccb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                                           (Ccb->Lcb != NULL) &&
                                                           (Ccb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                                          &Ccb->Lcb->Scb->ScbType.Index.NormalizedName :
                                                          NULL),
                                                         FILE_NOTIFY_CHANGE_FILE_NAME,
                                                         FILE_ACTION_REMOVED,
                                                         ParentFcb );
                                }

                                SetFlag( Fcb->FcbState, FCB_STATE_FILE_DELETED );
                                SetFlag( FcbStateClearFlags, FCB_STATE_FILE_DELETED );
                                DeleteFromFcbTable = TRUE;

                                //
                                //  We need to mark all of the links on the file as gone.
                                //

                                for (Links = Fcb->LcbQueue.Flink;
                                     Links != &Fcb->LcbQueue;
                                     Links = Links->Flink) {

                                    ThisLcb = CONTAINING_RECORD( Links, LCB, FcbLinks );

                                    if (ThisLcb->Scb == ParentScb) {

                                        //
                                        //  Remove all remaining prefixes on this link.
                                        //  Make sure the resource is acquired.
                                        //

                                        if (!AcquiredParentScb) {

                                            NtfsAcquireExclusiveScb( IrpContext, ParentScb );
                                            AcquiredParentScb = TRUE;
                                        }

                                        NtfsRemovePrefix( ThisLcb );

                                        //
                                        //  Remove any hash table entries for this Lcb.
                                        //

                                        NtfsRemoveHashEntriesForLcb( ThisLcb );

                                        SetFlag( ThisLcb->LcbState, LCB_STATE_LINK_IS_GONE );

                                        //
                                        //  We don't need to report any changes on this link.
                                        //

                                        ThisLcb->InfoFlags = 0;
                                    }
                                }

                                //
                                //  We need to mark all of the Scbs as gone.
                                //

                                for (Links = Fcb->ScbQueue.Flink;
                                     Links != &Fcb->ScbQueue;
                                     Links = Links->Flink) {

                                    ThisScb = CONTAINING_RECORD( Links, SCB, FcbLinks );

                                    ClearFlag( ThisScb->ScbState,
                                               SCB_STATE_NOTIFY_ADD_STREAM |
                                               SCB_STATE_NOTIFY_REMOVE_STREAM |
                                               SCB_STATE_NOTIFY_RESIZE_STREAM |
                                               SCB_STATE_NOTIFY_MODIFY_STREAM );

                                    if (!FlagOn( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

                                        NtfsSnapshotScb( IrpContext, ThisScb );

                                        ThisScb->ValidDataToDisk =
                                        ThisScb->Header.AllocationSize.QuadPart =
                                        ThisScb->Header.FileSize.QuadPart =
                                        ThisScb->Header.ValidDataLength.QuadPart = 0;

                                        SetFlag( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
                                    }
                                }

                                //
                                //  We certainly don't need to any on disk update for this
                                //  file now.
                                //

                                Fcb->InfoFlags = 0;
                                ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

                                ClearFlag( Ccb->Flags,
                                           CCB_FLAG_USER_SET_LAST_MOD_TIME |
                                           CCB_FLAG_USER_SET_LAST_CHANGE_TIME |
                                           CCB_FLAG_USER_SET_LAST_ACCESS_TIME );

                                //
                                //  We will truncate the attribute to size 0.
                                //

                                TruncateSize = (PLONGLONG)&Li0;
                            }

                        //
                        //  Now we want to check for the last user's handle on a
                        //  link (or the last handle on a Ntfs/8.3 pair).  In this
                        //  case we want to remove the links from the disk.
                        //

                        } else if (Lcb != NULL) {

                            ThisLcb = NULL;
                            RemoveLink = TRUE;

                            if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS ) &&
                                (Lcb->FileNameAttr->Flags != (FILE_NAME_NTFS | FILE_NAME_DOS))) {

                                //
                                //  Walk through all the links looking for a link
                                //  with a flag set which is not the same as the
                                //  link we already have.
                                //

                                for (Links = Fcb->LcbQueue.Flink;
                                     Links != &Fcb->LcbQueue;
                                     Links = Links->Flink) {

                                    ThisLcb = CONTAINING_RECORD( Links, LCB, FcbLinks );

                                    //
                                    //  If this has a flag set and is not the Lcb
                                    //  for this cleanup, then we check if there
                                    //  are no Ccb's left for this.
                                    //

                                    if (FlagOn( ThisLcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS )

                                                &&

                                        (ThisLcb != Lcb)) {

                                        if (ThisLcb->CleanupCount != 0) {

                                             RemoveLink = FALSE;
                                        }

                                        break;
                                    }

                                    ThisLcb = NULL;
                                }
                            }

                            //
                            //  If we are to remove the link, we do so now.  This removes
                            //  the filename attributes and the entries in the parent
                            //  indexes for this link.  In addition, we mark the links
                            //  as having been removed and decrement the number of links
                            //  left on the file.  We don't remove the link if this the
                            //  last link on the file.  This means that someone has the
                            //  file open by FileID.  We don't want to remove the last
                            //  link until all the handles are closed.
                            //

                            if (RemoveLink && (Fcb->TotalLinks > 1)) {

                                NtfsAcquireExclusiveScb( IrpContext, ParentScb );
                                AcquiredParentScb = TRUE;

                                //
                                //  We might end up with deallocating or even allocating an MFT
                                //  record in the process of deleting this entry. So, it's wise to preacquire
                                //  QuotaControl resource, lest we deadlock with the MftScb resource.
                                //  Unfortunately, it's not easy to figure out whether any of those will
                                //  actually happen at this point.
                                //
                                //  We must have acquired all the other resources except $ObjId
                                //  at this point. QuotaControl must get acquired after ObjId Scb.
                                //

                                if (NtfsPerformQuotaOperation( Fcb )) {

                                    NtfsAcquireSharedScb( IrpContext, Vcb->ObjectIdTableScb );
                                    AcquiredObjectID = TRUE;
                                    NtfsAcquireQuotaControl( IrpContext, Fcb->QuotaControl );
                                }

                                try {

                                    AddToDelayQueue = FALSE;
                                    TunneledData.HasObjectId = FALSE;

                                    //
                                    //  Post the link change.
                                    //

                                    NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_HARD_LINK_CHANGE );
                                    NtfsRemoveLink( IrpContext,
                                                    Fcb,
                                                    ParentScb,
                                                    Lcb->ExactCaseLink.LinkName,
                                                    &NamePair,
                                                    &TunneledData );

                                    //
                                    //  It's possible that this is the link that was used for the
                                    //  Usn name.  Make sure we look up the Usn name on the
                                    //  next operation.
                                    //

                                    ClearFlag( Fcb->FcbState, FCB_STATE_VALID_USN_NAME );

                                    //
                                    //  Stash property information in the tunnel if caller opened the
                                    //  object by name and was treating it as a non-POSIX object
                                    //

                                    if (!OpenById && !FlagOn(FileObject->Flags, FO_OPENED_CASE_SENSITIVE)) {

                                        NtfsGetTunneledData( IrpContext,
                                                             Fcb,
                                                             &TunneledData );

                                        FsRtlAddToTunnelCache(  &Vcb->Tunnel,
                                                                *(PULONGLONG)&ParentScb->Fcb->FileReference,
                                                                &NamePair.Short,
                                                                &NamePair.Long,
                                                                BooleanFlagOn(Lcb->FileNameAttr->Flags, FILE_NAME_DOS),
                                                                sizeof(NTFS_TUNNELED_DATA),
                                                                &TunneledData);
                                    }

                                    TotalLinkAdj += 1;
                                    NtfsUpdateFcb( ParentFcb,
                                                   (FCB_INFO_CHANGED_LAST_CHANGE |
                                                    FCB_INFO_CHANGED_LAST_MOD |
                                                    FCB_INFO_UPDATE_LAST_ACCESS) );

                                } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                    NOTHING;
                                }

                                if ((Vcb->NotifyCount != 0) &&
                                    !OpenById &&
                                    (Status == STATUS_SUCCESS)) {

                                    NtfsReportDirNotify( IrpContext,
                                                         Vcb,
                                                         &Ccb->FullFileName,
                                                         Ccb->LastFileNameOffset,
                                                         NULL,
                                                         ((FlagOn( Ccb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                                           (Ccb->Lcb != NULL) &&
                                                           (Ccb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                                          &Ccb->Lcb->Scb->ScbType.Index.NormalizedName :
                                                          NULL),
                                                         FILE_NOTIFY_CHANGE_FILE_NAME,
                                                         FILE_ACTION_REMOVED,
                                                         ParentFcb );
                                }

                                //
                                //  Remove all remaining prefixes on this link.
                                //

                                ASSERT( NtfsIsExclusiveScb( Lcb->Scb ) );

                                NtfsRemovePrefix( Lcb );

                                //
                                //  Remove any hash table entries for this Lcb.
                                //

                                NtfsRemoveHashEntriesForLcb( Lcb );

                                //
                                //  Mark the links as being removed.
                                //

                                SetFlag( Lcb->LcbState, LCB_STATE_LINK_IS_GONE );

                                if (ThisLcb != NULL) {

                                    //
                                    //  Remove all remaining prefixes on this link.
                                    //

                                    ASSERT( NtfsIsExclusiveScb( ThisLcb->Scb ) );
                                    NtfsRemovePrefix( ThisLcb );

                                    //
                                    //  Remove any hash table entries for this Lcb.
                                    //

                                    NtfsRemoveHashEntriesForLcb( ThisLcb );

                                    SetFlag( ThisLcb->LcbState, LCB_STATE_LINK_IS_GONE );
                                    ThisLcb->InfoFlags = 0;
                                }

                                //
                                //  Since the link is gone we don't want to update the
                                //  duplicate information for this link.
                                //

                                Lcb->InfoFlags = 0;
                                LcbForUpdate = NULL;

                                //
                                //  Update the time stamps for removing the link.  Clear the
                                //  FO_CLEANUP_COMPLETE flag around this call so the time
                                //  stamp change is not nooped.
                                //

                                SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );
                                ClearFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );
                                NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );
                                SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );
                            }
                        }
                    }

                    //
                    //  If the file/attribute is not going away, we update the
                    //  attribute size now rather than waiting for the Lazy
                    //  Writer to catch up.  If the cleanup count isn't 1 then
                    //  defer the following actions.
                    //

                    if ((Scb->CleanupCount == 1) &&
                        (Fcb->LinkCount != 0) &&
                        (Status == STATUS_SUCCESS)) {

                        //
                        //  We may also have to delete this attribute only.
                        //

                        if (DeleteStream) {

                            //
                            //  If this stream is subject to quota then we need to acquire the
                            //  parent now.  Other we will acquire quota control during the
                            //  delete operation and then try to acquire the parent to
                            //  perform the update duplicate info.
                            //

                            if (NtfsPerformQuotaOperation( Fcb ) && (LcbForUpdate != NULL) && (!FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE ))) {

                                NtfsPrepareForUpdateDuplicate( IrpContext,
                                                               Fcb,
                                                               &LcbForUpdate,
                                                               &ParentScb,
                                                               TRUE );
                            }

                            //
                            //  We might be retrying the delete stream operation due to a log file
                            //  full.  If the attribute type code is $UNUSED then the stream has
                            //  already been deleted.
                            //

                            if (Scb->AttributeTypeCode != $UNUSED) {

                                try {

                                    //
                                    //  Delete the attribute only.
                                    //

                                    if (CleanupAttrContext) {

                                        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                                    }

                                    NtfsInitializeAttributeContext( &AttrContext );
                                    CleanupAttrContext = TRUE;

                                    NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );

                                    do {

                                        NtfsDeleteAttributeRecord( IrpContext,
                                                                   Fcb,
                                                                   (DELETE_LOG_OPERATION |
                                                                    DELETE_RELEASE_FILE_RECORD |
                                                                    DELETE_RELEASE_ALLOCATION),
                                                                   &AttrContext );

                                    } while (NtfsLookupNextAttributeForScb( IrpContext, Scb, &AttrContext ));

                                } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                    NOTHING;
                                }

                                NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_STREAM_CHANGE );
                            }

                            //
                            //  Now that we're done deleting the attribute, we need to checkpoint
                            //  so that the Mft resource can be released.  First we need to set
                            //  the appropriate IrpContext flag to indicate whether we really need
                            //  to release the Mft.
                            //

                            if ((Vcb->MftScb != NULL) &&
                                (Vcb->MftScb->Fcb->ExclusiveFcbLinks.Flink != NULL) &&
                                NtfsIsExclusiveScb( Vcb->MftScb )) {

                                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_MFT );
                            }

                            try {

                                NtfsCheckpointCurrentTransaction( IrpContext );

                            } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                NOTHING;
                            }

                            //
                            //  Set the Scb flag to indicate that the attribute is
                            //  gone.
                            //

                            Scb->ValidDataToDisk =
                            Scb->Header.AllocationSize.QuadPart =
                            Scb->Header.FileSize.QuadPart =
                            Scb->Header.ValidDataLength.QuadPart = 0;

                            Scb->AttributeTypeCode = $UNUSED;
                            SetFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );

                            SetFlag( Scb->ScbState, SCB_STATE_NOTIFY_REMOVE_STREAM );

                            ClearFlag( Scb->ScbState,
                                       SCB_STATE_NOTIFY_RESIZE_STREAM |
                                       SCB_STATE_NOTIFY_MODIFY_STREAM |
                                       SCB_STATE_NOTIFY_ADD_STREAM );

                            //
                            //  Update the time stamps for removing the link.  Clear the
                            //  FO_CLEANUP_COMPLETE flag around this call so the time
                            //  stamp change is not nooped.
                            //

                            SetFlag( Ccb->Flags,
                                     CCB_FLAG_UPDATE_LAST_CHANGE | CCB_FLAG_SET_ARCHIVE );
                            ClearFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );
                            NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );
                            SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

                            TruncateSize = (PLONGLONG)&Li0;

                        //
                        //  Check if we're to modify the allocation size or file size.
                        //

                        } else {

                            if (FlagOn( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE )) {

                                //
                                //  Acquire the parent now so we enforce our locking
                                //  rules that the Mft Scb must be acquired after
                                //  the normal file resources.
                                //

                                if (!FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {
                                    NtfsPrepareForUpdateDuplicate( IrpContext,
                                                                   Fcb,
                                                                   &LcbForUpdate,
                                                                   &ParentScb,
                                                                   TRUE );
                                }


                                //
                                //  For the non-resident streams we will write the file
                                //  size to disk.
                                //


                                if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                                    //
                                    //  Setting AdvanceOnly to FALSE guarantees we will not
                                    //  incorrectly advance the valid data size.
                                    //

                                    try {

                                        NtfsWriteFileSizes( IrpContext,
                                                            Scb,
                                                            &Scb->Header.ValidDataLength.QuadPart,
                                                            FALSE,
                                                            TRUE,
                                                            TRUE );

                                    } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                        NOTHING;
                                    }

                                //
                                //  For resident streams we will write the correct size to
                                //  the resident attribute.
                                //

                                } else {

                                    //
                                    //  We need to lookup the attribute and change
                                    //  the attribute value.  We can point to
                                    //  the attribute itself as the changing
                                    //  value.
                                    //

                                    NtfsInitializeAttributeContext( &AttrContext );
                                    CleanupAttrContext = TRUE;

                                    try {

                                        NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );

                                        NtfsChangeAttributeValue( IrpContext,
                                                                  Fcb,
                                                                  Scb->Header.FileSize.LowPart,
                                                                  NULL,
                                                                  0,
                                                                  TRUE,
                                                                  TRUE,
                                                                  FALSE,
                                                                  FALSE,
                                                                  &AttrContext );

                                    } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                        NOTHING;
                                    }

                                    //
                                    //  Verify the allocation size is now correct.
                                    //

                                    if (QuadAlign( Scb->Header.FileSize.LowPart ) != Scb->Header.AllocationSize.LowPart) {

                                        Scb->Header.AllocationSize.LowPart = QuadAlign(Scb->Header.FileSize.LowPart);
                                    }
                                }

                                //
                                //  Update the size change to the Fcb.
                                //

                                NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );
                            }

                            if (Status == STATUS_SUCCESS) {

                                if (FlagOn( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE ) &&
                                    (Status == STATUS_SUCCESS)) {

                                    //
                                    //  Acquire the parent now so we enforce our locking
                                    //  rules that the Mft Scb must be acquired after
                                    //  the normal file resources.
                                    //

                                    if (!FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE)) {
                                        NtfsPrepareForUpdateDuplicate( IrpContext,
                                                                       Fcb,
                                                                       &LcbForUpdate,
                                                                       &ParentScb,
                                                                       TRUE );
                                    }


                                    //
                                    //  We have two cases:
                                    //
                                    //      Resident:  We are looking for the case where the
                                    //          valid data length is less than the file size.
                                    //          In this case we shrink the attribute.
                                    //
                                    //      NonResident:  We are looking for unused clusters
                                    //          past the end of the file.
                                    //
                                    //  We skip the following if we had any previous errors.
                                    //

                                    if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                                        //
                                        //  We don't need to truncate if the file size is 0.
                                        //

                                        if (Scb->Header.AllocationSize.QuadPart != 0) {

                                            VCN StartingCluster;
                                            VCN EndingCluster;
                                            LONGLONG AllocationSize;

                                            //
                                            //  ****    Do we need to give up the Vcb for this
                                            //          call.
                                            //

                                            StartingCluster = LlClustersFromBytes( Vcb, Scb->Header.FileSize.QuadPart );
                                            EndingCluster = LlClustersFromBytes( Vcb, Scb->Header.AllocationSize.QuadPart );
                                            AllocationSize = Scb->Header.AllocationSize.QuadPart;

                                            //
                                            //  If there are clusters to delete, we do so now.
                                            //

                                            if (EndingCluster != StartingCluster) {

                                                try {
                                                    NtfsDeleteAllocation( IrpContext,
                                                                          FileObject,
                                                                          Scb,
                                                                          StartingCluster,
                                                                          MAXLONGLONG,
                                                                          TRUE,
                                                                          TRUE );

                                                } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                                    NOTHING;
                                                }
                                            }

                                            LocalTruncateSize = Scb->Header.FileSize.QuadPart;
                                            TruncateSize = &LocalTruncateSize;
                                        }

                                    //
                                    //  This is the resident case.
                                    //

                                    } else {

                                        //
                                        //  Check if the file size length is less than
                                        //  the allocated size.
                                        //

                                        if (QuadAlign( Scb->Header.FileSize.LowPart ) < Scb->Header.AllocationSize.LowPart) {

                                            //
                                            //  We need to lookup the attribute and change
                                            //  the attribute value.  We can point to
                                            //  the attribute itself as the changing
                                            //  value.
                                            //

                                            if (CleanupAttrContext) {

                                                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                                            }

                                            NtfsInitializeAttributeContext( &AttrContext );
                                            CleanupAttrContext = TRUE;

                                            try {

                                                NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );

                                                NtfsChangeAttributeValue( IrpContext,
                                                                          Fcb,
                                                                          Scb->Header.FileSize.LowPart,
                                                                          NULL,
                                                                          0,
                                                                          TRUE,
                                                                          TRUE,
                                                                          FALSE,
                                                                          FALSE,
                                                                          &AttrContext );

                                            } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                                NOTHING;
                                            }

                                            //
                                            //  Remember the smaller allocation size
                                            //

                                            Scb->Header.AllocationSize.LowPart = QuadAlign( Scb->Header.FileSize.LowPart );
                                            Scb->TotalAllocated = Scb->Header.AllocationSize.QuadPart;
                                        }
                                    }

                                    NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );
                                }
                            }
                        }
                    }

                    //
                    //  If this was the last cached open, and there are open
                    //  non-cached handles, attempt a flush and purge operation
                    //  to avoid cache coherency overhead from these non-cached
                    //  handles later.  We ignore any I/O errors from the flush
                    //  except for CANT_WAIT and LOG_FILE_FULL.
                    //

                    if ((Scb->NonCachedCleanupCount != 0) &&
                        (Scb->CleanupCount == (Scb->NonCachedCleanupCount + 1)) &&
                        (Scb->CompressionUnit == 0) &&
                        (Scb->NonpagedScb->SegmentObject.ImageSectionObject == NULL) &&
                        !FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) &&
                        (Status == STATUS_SUCCESS) &&
                        MmCanFileBeTruncated( &Scb->NonpagedScb->SegmentObject, NULL ) &&
                        !FlagOn( Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

                        //
                        //  FlushAndPurge may release the parent.  Go ahead and explicitly
                        //  release it.  Otherwise we may overrelease it later before uninitializing
                        //  the cache map. At the same time release the quota control if necc. via
                        //  release shared resources
                        //

                        try {
                            NtfsCheckpointCurrentTransaction( IrpContext );
                            FcbStateClearFlags = 0;

                        } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                            NOTHING;
                        }

                        if (AcquiredParentScb) {

                            NtfsReleaseScb( IrpContext, ParentScb );
                            AcquiredParentScb = FALSE;
                        }
                        if (IrpContext->SharedScbSize > 0) {
                            NtfsReleaseSharedResources( IrpContext );
                        }

                        //
                        //  Flush and purge the stream.
                        //

                        try {

                            NtfsFlushAndPurgeScb( IrpContext,
                                                  Scb,
                                                  NULL );

                        } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                            NOTHING;
                        }

                        //
                        //  Ignore any errors in this path.
                        //

                        IrpContext->ExceptionStatus = STATUS_SUCCESS;
                    }

                    if ((Fcb->CloseCount == 1) &&
                        AddToDelayQueue &&
                        (NtfsData.DelayedCloseCount <= NtfsMaxDelayedCloseCount) &&
                        (Status == STATUS_SUCCESS) &&
                        !FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

                        NtfsAcquireFsrtlHeader( Scb );
                        SetFlag( Scb->ScbState, SCB_STATE_DELAY_CLOSE );
                        NtfsReleaseFsrtlHeader( Scb );
                    }
                }

            //
            //  If the Fcb is bad, we will truncate the cache to size zero.
            //

            } else {

                //
                //  Now set the FO_CLEANUP_COMPLETE flag.
                //

                SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

                TruncateSize = (PLONGLONG)&Li0;
            }

            break;

        default :

            NtfsBugCheck( TypeOfOpen, 0, 0 );
        }

        //
        //  If any of the Fcb Info flags are set we call the routine
        //  to update the duplicated information in the parent directories.
        //  We need to check here in case none of the flags are set but
        //  we want to update last access time.
        //

        if (Fcb->Info.LastAccessTime != Fcb->CurrentLastAccess) {

            ASSERT( TypeOfOpen != UserVolumeOpen );

            if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

                ASSERT( !FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ));

                Fcb->Info.LastAccessTime = Fcb->CurrentLastAccess;
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_ACCESS );

            } else if (!FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED )) {

                if (NtfsCheckLastAccess( IrpContext, Fcb )) {

                    SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
                    SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_ACCESS );
                }
            }
        }

        if (VolumeMounted && !VolumeMountedReadOnly) {

            //
            //  We check if we have the standard information attribute.
            //  We can only update attributes on mounted volumes.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO ) &&
                (Status == STATUS_SUCCESS)) {

                ASSERT( !FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ));
                ASSERT( TypeOfOpen != UserVolumeOpen );

                try {

                    NtfsUpdateStandardInformation( IrpContext, Fcb );

                } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                    NOTHING;
                }
            }

            //
            //  Now update the duplicate information as well for volumes that are still mounted.
            //

            if ((FlagOn( Fcb->InfoFlags, FCB_INFO_DUPLICATE_FLAGS ) ||
                         ((LcbForUpdate != NULL) &&
                          FlagOn( LcbForUpdate->InfoFlags, FCB_INFO_DUPLICATE_FLAGS ))) &&
                (Status == STATUS_SUCCESS) &&
                (!FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE))) {

                ASSERT( TypeOfOpen != UserVolumeOpen );
                ASSERT( !FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ));

                NtfsPrepareForUpdateDuplicate( IrpContext, Fcb, &LcbForUpdate, &ParentScb, TRUE );

                //
                //  Now update the duplicate info.
                //

                try {

                    NtfsUpdateDuplicateInfo( IrpContext, Fcb, LcbForUpdate, ParentScb );

                } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                    NOTHING;
                }

                UpdateDuplicateInfo = TRUE;
            }

            //
            //  If we have modified the Info structure or security, we report this
            //  to the dir-notify package (except for OpenById cases).
            //

            if (!OpenById && (Status == STATUS_SUCCESS)) {

                ULONG FilterMatch;

                //
                //  Check whether we need to report on file changes.
                //

                if ((Vcb->NotifyCount != 0) &&
                    (UpdateDuplicateInfo || FlagOn( Fcb->InfoFlags, FCB_INFO_MODIFIED_SECURITY ))) {

                    ASSERT( TypeOfOpen != UserVolumeOpen );

                    //
                    //  We map the Fcb info flags into the dir notify flags.
                    //

                    FilterMatch = NtfsBuildDirNotifyFilter( IrpContext,
                                                            (Fcb->InfoFlags |
                                                             (LcbForUpdate ? LcbForUpdate->InfoFlags : 0) ));

                    //
                    //  If the filter match is non-zero, that means we also need to do a
                    //  dir notify call.
                    //

                    if (FilterMatch != 0) {

                        ASSERT( TypeOfOpen != UserVolumeOpen );
                        ASSERT( !FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ));

                        NtfsReportDirNotify( IrpContext,
                                             Vcb,
                                             &Ccb->FullFileName,
                                             Ccb->LastFileNameOffset,
                                             NULL,
                                             ((FlagOn( Ccb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                               (Ccb->Lcb != NULL) &&
                                               (Ccb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                              &Ccb->Lcb->Scb->ScbType.Index.NormalizedName :
                                              NULL),
                                             FilterMatch,
                                             FILE_ACTION_MODIFIED,
                                             ParentFcb );
                    }
                }

                ClearFlag( Fcb->InfoFlags, FCB_INFO_MODIFIED_SECURITY );

                //
                //  If this is a named stream with changes then report them as well.
                //

                if ((Scb->AttributeName.Length != 0) &&
                    NtfsIsTypeCodeUserData( Scb->AttributeTypeCode )) {

                    if ((Vcb->NotifyCount != 0) &&
                        FlagOn( Scb->ScbState,
                                SCB_STATE_NOTIFY_REMOVE_STREAM |
                                SCB_STATE_NOTIFY_RESIZE_STREAM |
                                SCB_STATE_NOTIFY_MODIFY_STREAM )) {

                        ULONG Action;

                        FilterMatch = 0;

                        //
                        //  Start by checking for a delete.
                        //

                        if (FlagOn( Scb->ScbState, SCB_STATE_NOTIFY_REMOVE_STREAM )) {

                            FilterMatch = FILE_NOTIFY_CHANGE_STREAM_NAME;
                            Action = FILE_ACTION_REMOVED_STREAM;

                        } else {

                            //
                            //  Check if the file size changed.
                            //

                            if (FlagOn( Scb->ScbState, SCB_STATE_NOTIFY_RESIZE_STREAM )) {

                                FilterMatch = FILE_NOTIFY_CHANGE_STREAM_SIZE;
                            }

                            //
                            //  Now check if the stream data was modified.
                            //

                            if (FlagOn( Scb->ScbState, SCB_STATE_NOTIFY_MODIFY_STREAM )) {

                                SetFlag( FilterMatch, FILE_NOTIFY_CHANGE_STREAM_WRITE );
                            }

                            Action = FILE_ACTION_MODIFIED_STREAM;
                        }

                        NtfsReportDirNotify( IrpContext,
                                             Vcb,
                                             &Ccb->FullFileName,
                                             Ccb->LastFileNameOffset,
                                             &Scb->AttributeName,
                                             ((FlagOn( Ccb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                               (Ccb->Lcb != NULL) &&
                                               (Ccb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                              &Ccb->Lcb->Scb->ScbType.Index.NormalizedName :
                                              NULL),
                                             FilterMatch,
                                             Action,
                                             ParentFcb );
                    }

                    ClearFlag( Scb->ScbState,
                               SCB_STATE_NOTIFY_ADD_STREAM |
                               SCB_STATE_NOTIFY_REMOVE_STREAM |
                               SCB_STATE_NOTIFY_RESIZE_STREAM |
                               SCB_STATE_NOTIFY_MODIFY_STREAM );
                }
            }

            if (UpdateDuplicateInfo) {

                NtfsUpdateLcbDuplicateInfo( Fcb, LcbForUpdate );
                Fcb->InfoFlags = 0;
            }
        }

        //
        //  Always clear the update standard information flag.
        //

        ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

        //
        //  Let's give up the parent Fcb if we have acquired it.  This will
        //  prevent deadlocks in any uninitialize code below.
        //

        if (AcquiredParentScb) {

            NtfsReleaseScb( IrpContext, ParentScb );
            AcquiredParentScb = FALSE;
        }

        //
        //  Uninitialize the cache map if this file has been cached or we are
        //  trying to delete.
        //

        if ((FileObject->PrivateCacheMap != NULL) || (TruncateSize != NULL)) {

            CcUninitializeCacheMap( FileObject, (PLARGE_INTEGER)TruncateSize, NULL );
        }

        //
        //  Check that the non-cached handle count is consistent.
        //

        ASSERT( !FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) ||
                (Scb->NonCachedCleanupCount != 0 ));

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            CleanupAttrContext = FALSE;
        }

        //
        //  On final cleanup, post the close to the Usn Journal, if other changes have been
        //  posted.
        //

        if ((Fcb->CleanupCount == 1) &&
            (Fcb->FcbUsnRecord != NULL) &&
            ((Fcb->FcbUsnRecord->UsnRecord.Reason != 0) ||
             ((IrpContext->Usn.CurrentUsnFcb != NULL) && (IrpContext->Usn.NewReasons != 0)))) {

            PSCB TempScb;

            //
            //  Leave if there are any streams with user-mapped files.
            //

            TempScb = (PSCB)CONTAINING_RECORD( Fcb->ScbQueue.Flink,
                                               SCB,
                                               FcbLinks );

            while (&TempScb->FcbLinks != &Fcb->ScbQueue) {

                if (FlagOn(TempScb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE)) {
                    goto NoPost;
                }

                TempScb = (PSCB)CONTAINING_RECORD( TempScb->FcbLinks.Flink,
                                                   SCB,
                                                   FcbLinks );
            }

            //
            //  Now try to actually post the change.
            //

            NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_CLOSE );

            //
            //  Escape here if we are not posting the close due to a user-mapped file.
            //

        NoPost: NOTHING;
        }

        //
        //  Now, if anything at all is posted to the Usn Journal, we must write it now
        //  so that we do not get a log file full later.
        //

        ASSERT( IrpContext->Usn.NextUsnFcb == NULL );
        if ((IrpContext->Usn.CurrentUsnFcb != NULL) &&
            (Status == STATUS_SUCCESS)) {

            //
            //  Now write the journal, checkpoint the transaction, and free the UsnJournal to
            //  reduce contention.
            //

            try {

                NtfsWriteUsnJournalChanges( IrpContext );
                NtfsCheckpointCurrentTransaction( IrpContext );
                FcbStateClearFlags = 0;

            } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                NOTHING;
            }
        }

        //
        //  Make sure the TRUNCATE and ATTRIBUTE_SIZE flags in the Scb are cleared.
        //

        if (FlagOn( Scb->ScbState,
                    SCB_STATE_CHECK_ATTRIBUTE_SIZE | SCB_STATE_TRUNCATE_ON_CLOSE ) &&
                    (Scb->CleanupCount == 1)) {

            NtfsAcquireFsrtlHeader( Scb );
            ClearFlag( Scb->ScbState,
                       SCB_STATE_CHECK_ATTRIBUTE_SIZE | SCB_STATE_TRUNCATE_ON_CLOSE );
            NtfsReleaseFsrtlHeader( Scb );
        }

        //
        //  Now decrement the cleanup counts.
        //
        //  NOTE - DO NOT ADD CODE AFTER THIS POINT THAT CAN CAUSE A RETRY.
        //

        NtfsDecrementCleanupCounts( Scb,
                                    LcbForCounts,
                                    BooleanFlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ));

#ifdef BRIANDBG
        DecrementedCleanupCount = TRUE;
#endif
        //
        //  We remove the share access from the Scb.
        //

        IoRemoveShareAccess( FileObject, &Scb->ShareAccess );

        //
        //  Modify the delete counts in the Fcb.
        //

        if (FlagOn( Ccb->Flags, CCB_FLAG_DELETE_FILE )) {

            Fcb->FcbDeleteFile -= 1;
            ClearFlag( Ccb->Flags, CCB_FLAG_DELETE_FILE );
        }

        if (FlagOn( Ccb->Flags, CCB_FLAG_DENY_DELETE )) {

            Fcb->FcbDenyDelete -= 1;
            ClearFlag( Ccb->Flags, CCB_FLAG_DENY_DELETE );
        }

        if (FlagOn( Ccb->Flags, CCB_FLAG_DENY_DEFRAG)) {
            ClearFlag( Ccb->Flags, CCB_FLAG_DENY_DEFRAG );
            ClearFlag( Scb->ScbPersist, SCB_PERSIST_DENY_DEFRAG );
        }

        //
        //  Since this request has completed we can adjust the total link count
        //  in the Fcb.
        //

        Fcb->TotalLinks -= TotalLinkAdj;

        //
        //  Release the quota control block.  This does not have to be done
        //  here however, it allows us to free up the quota control block
        //  before the fcb is removed from the table.  This keeps the assert
        //  about quota table empty from triggering in
        //  NtfsClearAndVerifyQuotaIndex.
        //

        if (NtfsPerformQuotaOperation(Fcb) &&
            FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED )) {
            NtfsDereferenceQuotaControlBlock( Vcb,
                                              &Fcb->QuotaControl );
        }

        //
        //  If we hit some failure in modifying the disk then make sure to roll back
        //  all of the changes.
        //

        if (Status != STATUS_SUCCESS) {

            NtfsRaiseStatus( IrpContext, STATUS_SUCCESS, NULL, NULL );
        }

        FcbStateClearFlags = 0;

    } finally {

        DebugUnwind( NtfsCommonCleanup );

        //
        //  Clear any FcbState flags we want to unwind.
        //

        ClearFlag( Fcb->FcbState, FcbStateClearFlags );

        //
        //  Remove this fcb from the Fcb table if neccessary. We delay this for
        //  synchronization with usn delete worker. By finishing the delete now we're
        //  guarranteed our usn work occured safely
        //

        if (DeleteFromFcbTable && FlagOn( Fcb->FcbState, FCB_STATE_IN_FCB_TABLE )) {

            NtfsAcquireFcbTable( IrpContext, Vcb );
            NtfsDeleteFcbTableEntry( Fcb->Vcb, Fcb->FileReference );
            NtfsReleaseFcbTable( IrpContext, Vcb );
            ClearFlag( Fcb->FcbState, FCB_STATE_IN_FCB_TABLE );
        }

        //
        //  We clear the file object pointer in the Ccb.
        //  This prevents us from trying to access this in a
        //  rename operation.
        //

        SetFlag( Ccb->Flags, CCB_FLAG_CLEANUP );

        //
        //  Release any resources held.
        //

        if (AcquiredObjectID) {

            NtfsReleaseScb( IrpContext, Vcb->ObjectIdTableScb );
        }

        NtfsReleaseVcb( IrpContext, Vcb );

        if (AcquiredCheckpoint) {
            NtfsReleaseCheckpointSynchronization( IrpContext, Vcb );
            AcquiredCheckpoint = FALSE;
        }

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        if (NamePair.Long.Buffer != NamePair.LongBuffer) {

            NtfsFreePool(NamePair.Long.Buffer);
        }

        if (DecrementScb) {

            InterlockedDecrement( &ImageScb->CloseCount );
        }

        //
        //  If we just cleaned up a volume handle and in so doing unlocked the
        //  volume, notify anyone who might be interested.  We can't do this
        //  until we've released all our resources, since there's no telling
        //  what services might do when they get notified, and we don't want
        //  to introduce potential deadlocks.
        //

        if (UnlockedVolume) {

            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_UNLOCK );
        }

        ASSERT( !AbnormalTermination() ||
                !DeleteFile ||
                FlagOn( Fcb->FcbState, FCB_STATE_IN_FCB_TABLE ) ||
                (IrpContext->TransactionId == 0) );

        //
        //  After a file is deleted and committed no more usn reasons should be left
        //  whether or not the journal is active
        //

        ASSERT( AbnormalTermination() ||
                !FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ) ||
                (Fcb->FcbUsnRecord == NULL) ||
                (Fcb->FcbUsnRecord->UsnRecord.Reason == 0) );

        //
        //  And return to our caller
        //

        DebugTrace( -1, Dbg, ("NtfsCommonCleanup -> %08lx\n", Status) );
    }

#ifdef BRIANDBG
    ASSERT( DecrementedCleanupCount );
#endif

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


VOID
NtfsTrimNormalizedNames (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB ParentScb
    )
/*++

Routine Description:

    Walk up the FCB/SCB chain removing all normalized names longer than
    the threshold size in inactive directories

    Try to remove parent dir normalized name if its long and  if no handles active (only this 1 left)
    and no lcbs are active - all notifies farther down in function (NtfsCommonCleanup)
    use parent Scb's normalized name.  If we don't remove it here
    this always goes away during a close

Arguments:

    IrpContext --

    Fcb -- The fcb of the starting node should already be acquired

    ParentScb - The scb of the parent of the current node

Return Value:

    none

--*/
{
    BOOLEAN DirectoryActive = FALSE;
    PFCB CurrentFcb;
    PSCB CurrentParentScb;
    PLCB ChildLcb;
    PLCB ParentLcb;
    PLIST_ENTRY Links;

    PAGED_CODE()

    //
    //  We may be occuring during a transaction so be careful to not acquire resources
    //  for the life of the transaction while traversing the tree
    //

    CurrentFcb = Fcb;
    CurrentParentScb = ParentScb;
    NtfsAcquireResourceExclusive( IrpContext, CurrentParentScb, TRUE );

    while ((CurrentParentScb->ScbType.Index.NormalizedName.MaximumLength > LONGNAME_THRESHOLD) &&
           (CurrentParentScb->CleanupCount == 0)) {

        ASSERT( (CurrentParentScb->Header.NodeTypeCode == NTFS_NTC_SCB_INDEX) ||
                (CurrentParentScb->Header.NodeTypeCode == NTFS_NTC_SCB_ROOT_INDEX) );

        //
        //  Determine that directory has no active links or handles
        //

        for (Links = CurrentParentScb->ScbType.Index.LcbQueue.Flink;
             Links != &(CurrentParentScb->ScbType.Index.LcbQueue);
             Links = Links->Flink) {

            ChildLcb = CONTAINING_RECORD( Links, LCB, ScbLinks );

            //
            //  We know the Fcb we were called with has a single cleanup count left.
            //

            if ((ChildLcb->CleanupCount != 0) &&
                (ChildLcb->Fcb != CurrentFcb)) {

                DirectoryActive = TRUE;
                break;
            }
        }

        if (!DirectoryActive) {

            //
            //  Now acquire and free name in SCB
            //

            NtfsDeleteNormalizedName( CurrentParentScb );

            //
            //  Move up to next level
            //

            if (CurrentFcb != Fcb) {
                NtfsReleaseResource( IrpContext, CurrentFcb );
            }

            CurrentFcb = CurrentParentScb->Fcb;
            if (CurrentFcb->CleanupCount != 0) {

                //
                //  Setting equal to FCB just means don't release it when we exit below
                //

                CurrentFcb = Fcb;
                break;
            }

            if (!(IsListEmpty( &(CurrentFcb->LcbQueue) ))) {


                ParentLcb = CONTAINING_RECORD( CurrentFcb->LcbQueue.Flink,
                                               LCB,
                                               FcbLinks );
                CurrentParentScb = ParentLcb->Scb;
                if (CurrentParentScb != NULL) {
                    NtfsAcquireResourceExclusive( IrpContext, CurrentParentScb, TRUE );
                } else {
                    break;
                }
            } else {
                CurrentParentScb = NULL;
                break;
            }
        } else {
            break;
        } //  endif directory active
    } //  endwhile longname in currentparentscb

    //
    //   Release last node if it isn't the starting one
    //

    if (CurrentFcb != Fcb) {
        ASSERT( CurrentFcb != NULL );
        NtfsReleaseResource( IrpContext, CurrentFcb );
    }

    if (CurrentParentScb != NULL) {
        NtfsReleaseResource( IrpContext, CurrentParentScb );
    }

    return;

} // NtfsTrimNormalizedNames


//
//  Local support routine
//

LONG
NtfsCleanupExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    OUT PNTSTATUS Status
    )

/*++

Routine Description:

    Exception filter for errors during cleanup.  We want to raise if this is
    a retryable condition or fatal error, plow on as best we can if not.

Arguments:

    IrpContext  - IrpContext

    ExceptionPointer - Pointer to the exception context.

    Status - Address to store the error status.

Return Value:

    Exception status - EXCEPTION_CONTINUE_SEARCH if we want to raise to another handler,
        EXCEPTION_EXECUTE_HANDLER if we plan to proceed on.

--*/

{
    *Status = ExceptionPointer->ExceptionRecord->ExceptionCode;

    //
    //  For now break if we catch corruption errors on both free and checked
    //  TODO:  Remove this before we ship
    //

    if (NtfsBreakOnCorrupt &&
        ((*Status == STATUS_FILE_CORRUPT_ERROR) ||
         (*Status == STATUS_DISK_CORRUPT_ERROR))) {

        if (*KdDebuggerEnabled) {
            DbgPrint("*******************************************\n");
            DbgPrint("NTFS detected corruption on your volume\n");
            DbgPrint("IrpContext=0x%08x, VCB=0x%08x\n",IrpContext,IrpContext->Vcb);
            DbgPrint("Send email to NTFSDEV\n");
            DbgPrint("*******************************************\n");
            DbgBreakPoint();
        }
    }

//  ASSERT( *Status != STATUS_FILE_CORRUPT_ERROR );

    if ((*Status == STATUS_LOG_FILE_FULL) ||
        (*Status == STATUS_CANT_WAIT) ||
        !FsRtlIsNtstatusExpected( *Status )) {

        return EXCEPTION_CONTINUE_SEARCH;
    }

    NtfsMinimumExceptionProcessing( IrpContext );

#ifdef BRIANDBG
#ifndef LFS_CLUSTER_CHECK
    //
    //  Some errors are acceptable in this path.
    //

    if (*Status == STATUS_DISK_FULL) {

        NtfsCleanupDiskFull += 1;

    } else if (*Status == STATUS_INSUFFICIENT_RESOURCES) {

        NtfsCleanupNoPool += 1;

    } else {

        //
        //  Cluster systems can hit inpage errors here because of DEVICE_OFFLINE
        //  for log I/O.
        //
        
        ASSERT( FALSE );
    }
#endif
#endif

    return EXCEPTION_EXECUTE_HANDLER;
}

#ifdef BRIANDBG
LONG
NtfsFsdCleanupExceptionFilter (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )
{
    NTSTATUS ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;

    ASSERT( NT_SUCCESS( ExceptionCode ) ||
            (ExceptionCode == STATUS_CANT_WAIT) ||
            (ExceptionCode == STATUS_LOG_FILE_FULL) );

    return NtfsExceptionFilter( IrpContext, ExceptionPointer );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\colatsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ColatSup.c

Abstract:

    This module implements the collation routine callbacks for Ntfs

Author:

    Tom Miller      [TomM]          26-Nov-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_INDEXSUP)

FSRTL_COMPARISON_RESULT
NtfsFileCompareValues (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN FSRTL_COMPARISON_RESULT WildCardIs,
    IN BOOLEAN IgnoreCase
    );

BOOLEAN
NtfsFileIsInExpression (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    );

BOOLEAN
NtfsFileIsEqual (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    );

BOOLEAN
NtfsFileContainsWildcards (
    IN PVOID Value
    );

VOID
NtfsFileUpcaseValue (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN PVOID Value
    );

FSRTL_COMPARISON_RESULT
DummyCompareValues (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN FSRTL_COMPARISON_RESULT WildCardIs,
    IN BOOLEAN IgnoreCase
    );

BOOLEAN
DummyIsInExpression (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    );

BOOLEAN
DummyIsEqual (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    );

BOOLEAN
DummyContainsWildcards (
    IN PVOID Value
    );

VOID
DummyUpcaseValue (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN OUT PVOID Value
    );

PCOMPARE_VALUES NtfsCompareValues[COLLATION_NUMBER_RULES] = {&DummyCompareValues,
                                                             &NtfsFileCompareValues,
                                                             &DummyCompareValues};

PIS_IN_EXPRESSION NtfsIsInExpression[COLLATION_NUMBER_RULES] = {&DummyIsInExpression,
                                                                &NtfsFileIsInExpression,
                                                                &DummyIsInExpression};

PARE_EQUAL NtfsIsEqual[COLLATION_NUMBER_RULES] = {&DummyIsEqual,
                                                  &NtfsFileIsEqual,
                                                  &DummyIsEqual};

PCONTAINS_WILDCARD NtfsContainsWildcards[COLLATION_NUMBER_RULES] = {&DummyContainsWildcards,
                                                                    &NtfsFileContainsWildcards,
                                                                    &DummyContainsWildcards};

PUPCASE_VALUE NtfsUpcaseValue[COLLATION_NUMBER_RULES] = {&DummyUpcaseValue,
                                                         &NtfsFileUpcaseValue,
                                                         &DummyUpcaseValue};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DummyCompareValues)
#pragma alloc_text(PAGE, DummyContainsWildcards)
#pragma alloc_text(PAGE, DummyIsEqual)
#pragma alloc_text(PAGE, DummyIsInExpression)
#pragma alloc_text(PAGE, DummyUpcaseValue)
#pragma alloc_text(PAGE, NtfsFileCompareValues)
#pragma alloc_text(PAGE, NtfsFileContainsWildcards)
#pragma alloc_text(PAGE, NtfsFileIsEqual)
#pragma alloc_text(PAGE, NtfsFileIsInExpression)
#pragma alloc_text(PAGE, NtfsFileNameIsInExpression)
#pragma alloc_text(PAGE, NtfsFileNameIsEqual)
#pragma alloc_text(PAGE, NtfsFileUpcaseValue)
#endif


FSRTL_COMPARISON_RESULT
NtfsFileCompareValues (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN FSRTL_COMPARISON_RESULT WildCardIs,
    IN BOOLEAN IgnoreCase
    )

/*++

RoutineDescription:

    This routine is called to compare a file name expression (the value) with
    a file name from the index to see if it is less than, equal to or greater
    than.  If a wild card is encountered in the expression, WildCardIs is
    returned.

Arguments:

    Value - Pointer to the value expression, which is a FILE_NAME.

    IndexEntry - Pointer to the index entry being compared to.

    WildCardIs - Value to be returned if a wild card is encountered in the
                 expression.

    IgnoreCase - whether case should be ignored or not.

ReturnValue:

    Result of the comparison

--*/

{
    PFILE_NAME ValueName, IndexName;
    UNICODE_STRING ValueString, IndexString;

    PAGED_CODE();

    //
    //  Point to the file name attribute records.
    //

    ValueName = (PFILE_NAME)Value;
    IndexName = (PFILE_NAME)(IndexEntry + 1);

    //
    //  Build the unicode strings and call namesup.
    //

    ValueString.Length =
    ValueString.MaximumLength = (USHORT)ValueName->FileNameLength << 1;
    ValueString.Buffer = &ValueName->FileName[0];

    IndexString.Length =
    IndexString.MaximumLength = (USHORT)IndexName->FileNameLength << 1;
    IndexString.Buffer = &IndexName->FileName[0];

    return NtfsCollateNames( UnicodeTable,
                             UnicodeTableSize,
                             &ValueString,
                             &IndexString,
                             WildCardIs,
                             IgnoreCase );
}


BOOLEAN
NtfsFileIsInExpression (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    )

/*++

RoutineDescription:

    This routine is called to compare a file name expression (the value) with
    a file name from the index to see if the file name is a match in this expression.

Arguments:

    Value - Pointer to the value expression, which is a FILE_NAME.

    IndexEntry - Pointer to the index entry being compared to.

    IgnoreCase - whether case should be ignored or not.

ReturnValue:

    TRUE - if the file name is in the specified expression.

--*/

{
    PFILE_NAME ValueName, IndexName;
    UNICODE_STRING ValueString, IndexString;

    PAGED_CODE();

    if (NtfsSegmentNumber( &IndexEntry->FileReference ) < FIRST_USER_FILE_NUMBER &&
        NtfsProtectSystemFiles) {

        return FALSE;
    }

    //
    //  Point to the file name attribute records.
    //

    ValueName = (PFILE_NAME)Value;
    IndexName = (PFILE_NAME)(IndexEntry + 1);

    //
    //  Build the unicode strings and call namesup.
    //

    ValueString.Length =
    ValueString.MaximumLength = (USHORT)ValueName->FileNameLength << 1;
    ValueString.Buffer = &ValueName->FileName[0];

    IndexString.Length =
    IndexString.MaximumLength = (USHORT)IndexName->FileNameLength << 1;
    IndexString.Buffer = &IndexName->FileName[0];

    return NtfsIsNameInExpression( UnicodeTable,
                                   &ValueString,
                                   &IndexString,
                                   IgnoreCase );
}


BOOLEAN
NtfsFileIsEqual (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    )

/*++

RoutineDescription:

    This routine is called to compare a constant file name (the value) with
    a file name from the index to see if the file name is an exact match.

Arguments:

    Value - Pointer to the value expression, which is a FILE_NAME.

    IndexEntry - Pointer to the index entry being compared to.

    IgnoreCase - whether case should be ignored or not.

ReturnValue:

    TRUE - if the file name is a constant match.

--*/

{
    PFILE_NAME ValueName, IndexName;
    UNICODE_STRING ValueString, IndexString;

    PAGED_CODE();

    //
    //  Point to the file name attribute records.
    //

    ValueName = (PFILE_NAME)Value;
    IndexName = (PFILE_NAME)(IndexEntry + 1);

    //
    //  Build the unicode strings and call namesup.
    //

    ValueString.Length =
    ValueString.MaximumLength = (USHORT)ValueName->FileNameLength << 1;
    ValueString.Buffer = &ValueName->FileName[0];

    IndexString.Length =
    IndexString.MaximumLength = (USHORT)IndexName->FileNameLength << 1;
    IndexString.Buffer = &IndexName->FileName[0];

    return NtfsAreNamesEqual( UnicodeTable,
                              &ValueString,
                              &IndexString,
                              IgnoreCase );
}


BOOLEAN
NtfsFileContainsWildcards (
    IN PVOID Value
    )

/*++

RoutineDescription:

    This routine is called to see if a file name attribute contains wildcards.

Arguments:

    Value - Pointer to the value expression, which is a FILE_NAME.


ReturnValue:

    TRUE - if the file name contains a wild card.

--*/

{
    PFILE_NAME ValueName;
    UNICODE_STRING ValueString;

    PAGED_CODE();

    //
    //  Point to the file name attribute records.
    //

    ValueName = (PFILE_NAME)Value;

    //
    //  Build the unicode strings and call namesup.
    //

    ValueString.Length =
    ValueString.MaximumLength = (USHORT)ValueName->FileNameLength << 1;
    ValueString.Buffer = &ValueName->FileName[0];

    return FsRtlDoesNameContainWildCards( &ValueString );
}


VOID
NtfsFileUpcaseValue (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN PVOID Value
    )

/*++

RoutineDescription:

    This routine is called to upcase a file name attribute in place.

Arguments:

    Value - Pointer to the value expression, which is a FILE_NAME.

    ValueLength - Length of the value expression in bytes.

ReturnValue:

    None.

--*/

{
    PFILE_NAME ValueName;
    UNICODE_STRING ValueString;

    PAGED_CODE();

    //
    //  Point to the file name attribute records.
    //

    ValueName = (PFILE_NAME)Value;

    //
    //  Build the unicode strings and call namesup.
    //

    ValueString.Length =
    ValueString.MaximumLength = (USHORT)ValueName->FileNameLength << 1;
    ValueString.Buffer = &ValueName->FileName[0];

    NtfsUpcaseName( UnicodeTable, UnicodeTableSize, &ValueString );

    return;
}


//
//  The other collation rules are currently unused.
//

FSRTL_COMPARISON_RESULT
DummyCompareValues (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN FSRTL_COMPARISON_RESULT WildCardIs,
    IN BOOLEAN IgnoreCase
    )

{
    //
    //  Most parameters are ignored since this is a catch-all for
    //  a corrupt volume.  We simply raise to indicate the corruption
    //

    UNREFERENCED_PARAMETER( UnicodeTable );
    UNREFERENCED_PARAMETER( UnicodeTableSize );
    UNREFERENCED_PARAMETER( IgnoreCase );
    UNREFERENCED_PARAMETER( WildCardIs );
    UNREFERENCED_PARAMETER( IndexEntry );
    UNREFERENCED_PARAMETER( Value );

    PAGED_CODE();

    ASSERTMSG("Unused collation rule\n", FALSE);

    return EqualTo;
}

BOOLEAN
DummyIsInExpression (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    )

{
    //
    //  Most parameters are ignored since this is a catch-all for
    //  a corrupt volume.  We simply raise to indicate the corruption
    //

    UNREFERENCED_PARAMETER( UnicodeTable );
    UNREFERENCED_PARAMETER( Value );
    UNREFERENCED_PARAMETER( IndexEntry );
    UNREFERENCED_PARAMETER( IgnoreCase );

    PAGED_CODE();

    ASSERTMSG("Unused collation rule\n", FALSE);
    return EqualTo;
}

BOOLEAN
DummyIsEqual (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    )

{
    //
    //  Most parameters are ignored since this is a catch-all for
    //  a corrupt volume.  We simply raise to indicate the corruption
    //

    UNREFERENCED_PARAMETER( UnicodeTable );
    UNREFERENCED_PARAMETER( Value );
    UNREFERENCED_PARAMETER( IndexEntry );
    UNREFERENCED_PARAMETER( IgnoreCase );

    PAGED_CODE();

    ASSERTMSG("Unused collation rule\n", FALSE);
    return EqualTo;
}

BOOLEAN
DummyContainsWildcards (
    IN PVOID Value
    )

{
    //
    //  Most parameters are ignored since this is a catch-all for
    //  a corrupt volume.  We simply raise to indicate the corruption
    //

    UNREFERENCED_PARAMETER( Value );

    PAGED_CODE();

    ASSERTMSG("Unused collation rule\n", FALSE);
    return EqualTo;
}

VOID
DummyUpcaseValue (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN PVOID Value
    )

{
    //
    //  Most parameters are ignored since this is a catch-all for
    //  a corrupt volume.  We simply raise to indicate the corruption
    //

    UNREFERENCED_PARAMETER( UnicodeTable );
    UNREFERENCED_PARAMETER( UnicodeTableSize );
    UNREFERENCED_PARAMETER( Value );

    PAGED_CODE();

    ASSERTMSG("Unused collation rule\n", FALSE);
    return;
}

//
//  The following routines are not general index match functions, but rather
//  specific file name match functions used only for automatic Dos Name generation.
//


BOOLEAN
NtfsFileNameIsInExpression (
    IN PWCH UnicodeTable,
    IN PFILE_NAME ExpressionName,
    IN PFILE_NAME FileName,
    IN BOOLEAN IgnoreCase
    )

/*++

RoutineDescription:

    This is a special match routine for matching FILE_NAME attributes only,
    which is used only by the special code paths dealing with automatically
    generated short names.

    This routine is called to compare a file name expression (the value) with
    a file name from the index to see if the file name is a match in this expression.

Arguments:

    ExpressionName - pointer to the expression for file name.

    FileName - Pointer to the FileName to match.

    IgnoreCase - whether case should be ignored or not.

ReturnValue:

    TRUE - if the file name is in the specified expression.

--*/

{
    UNICODE_STRING ExpressionString, FileString;

    PAGED_CODE();

    //
    //  Build the unicode strings and call namesup.
    //

    ExpressionString.Length =
    ExpressionString.MaximumLength = (USHORT)ExpressionName->FileNameLength << 1;
    ExpressionString.Buffer = &ExpressionName->FileName[0];

    FileString.Length =
    FileString.MaximumLength = (USHORT)FileName->FileNameLength << 1;
    FileString.Buffer = &FileName->FileName[0];

    return NtfsIsNameInExpression( UnicodeTable,
                                   &ExpressionString,
                                   &FileString,
                                   IgnoreCase );
}


BOOLEAN
NtfsFileNameIsEqual (
    IN PWCH UnicodeTable,
    IN PFILE_NAME ExpressionName,
    IN PFILE_NAME FileName,
    IN BOOLEAN IgnoreCase
    )

/*++

RoutineDescription:

    This is a special match routine for matching FILE_NAME attributes only,
    which is used only by the special code paths dealing with automatically
    generated short names.

    This routine is called to compare a constant file name (the value) with
    a file name from the index to see if the file name is an exact match.

Arguments:

    ExpressionName - pointer to the expression for file name.

    FileName - Pointer to the FileName to match.

    IgnoreCase - whether case should be ignored or not.

ReturnValue:

    TRUE - if the file name is a constant match.

--*/

{
    UNICODE_STRING ExpressionString, FileString;

    PAGED_CODE();

    //
    //  Build the unicode strings and call namesup.
    //

    ExpressionString.Length =
    ExpressionString.MaximumLength = (USHORT)ExpressionName->FileNameLength << 1;
    ExpressionString.Buffer = &ExpressionName->FileName[0];

    FileString.Length =
    FileString.MaximumLength = (USHORT)FileName->FileNameLength << 1;
    FileString.Buffer = &FileName->FileName[0];

    return NtfsAreNamesEqual( UnicodeTable,
                              &ExpressionString,
                              &FileString,
                              IgnoreCase );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\create.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module implements the File Create routine for Ntfs called by the
    dispatch driver.

Author:

    Brian Andrew    [BrianAn]       10-Dec-1991

Revision History:

--*/

#include "NtfsProc.h"
#ifdef NTFSDBG
#include "lockorder.h"
#endif

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('CFtN')

//
//  Check for stack usage prior to the create call.
//

#ifdef _X86_
#define OVERFLOW_CREATE_THRESHHOLD         (0x1200)
#else
#define OVERFLOW_CREATE_THRESHHOLD         (0x1B00)
#endif // _X86_

#ifdef BRIANDBG
BOOLEAN NtfsCreateAllSparse = FALSE;
BOOLEAN NtfsTraverseAccessCheck = FALSE;

UNICODE_STRING NtfsTestName = {0x0,0x40,L"                               "};

VOID
NtfsTestOpenName (
    IN PFILE_OBJECT FileObject
    );
#endif

//
//  Local macros
//

//
//  VOID
//  NtfsPrepareForIrpCompletion (
//      IN PIRP_CONTEXT IrpContext,
//      IN PIRP Irp,
//      IN PNTFS_COMPLETION_CONTEXT Context
//      )
//

#define NtfsPrepareForIrpCompletion(IC,I,C) {               \
    (C)->IrpContext = (IC);                                 \
    IoCopyCurrentIrpStackLocationToNext( (I) );             \
    IoSetCompletionRoutine( (I),                            \
                            NtfsCreateCompletionRoutine,    \
                            (C),                            \
                            TRUE,                           \
                            TRUE,                           \
                            TRUE );                         \
    IoSetNextIrpStackLocation( (I) );                       \
}

//
//  BOOLEAN
//  NtfsVerifyNameIsDirectory (
//      IN PIRP_CONTEXT IrpContext,
//      IN PUNICODE_STRING AttrName,
//      IN PUNICODE_STRING AttrCodeName
//      )
//

#define NtfsVerifyNameIsDirectory( IC, AN, ACN )                        \
    ( ( ((ACN)->Length == 0)                                            \
        || NtfsAreNamesEqual( IC->Vcb->UpcaseTable, ACN, &NtfsIndexAllocation, TRUE ))    \
      &&                                                                \
      ( ((AN)->Length == 0)                                             \
        || NtfsAreNamesEqual( IC->Vcb->UpcaseTable, AN, &NtfsFileNameIndex, TRUE )))

//
//  BOOLEAN
//  NtfsVerifyNameIsBitmap (
//      IN PIRP_CONTEXT IrpContext,
//      IN PUNICODE_STRING AttrName,
//      IN PUNICODE_STRING AttrCodeName
//      )
//

#define NtfsVerifyNameIsBitmap( IC, AN, ACN )                                           \
    ( ( ((ACN)->Length == 0)                                                            \
        || NtfsAreNamesEqual( IC->Vcb->UpcaseTable, ACN, &NtfsBitmapString, TRUE ))     \
      &&                                                                                \
      ( ((AN)->Length == 0)                                                             \
        || NtfsAreNamesEqual( IC->Vcb->UpcaseTable, AN, &NtfsFileNameIndex, TRUE )))

//
//  BOOLEAN
//  NtfsVerifyNameIsAttributeList (
//      IN PIRP_CONTEXT IrpContext,
//      IN PUNICODE_STRING AttrName,
//      IN PUNICODE_STRING AttrCodeName
//      )
//

#define NtfsVerifyNameIsAttributeList( IC, AN, ACN )                                  \
    ( ((ACN)->Length != 0)                                                            \
        && NtfsAreNamesEqual( IC->Vcb->UpcaseTable, ACN, &NtfsAttrListString, TRUE ))

//
//  BOOLEAN
//  NtfsVerifyNameIsReparsePoint (
//      IN PIRP_CONTEXT IrpContext,
//      IN PUNICODE_STRING AttrName,
//      IN PUNICODE_STRING AttrCodeName
//      )
//

#define NtfsVerifyNameIsReparsePoint( IC, AN, ACN )                                       \
    ( ((ACN)->Length != 0)                                                                \
        && NtfsAreNamesEqual( IC->Vcb->UpcaseTable, ACN, &NtfsReparsePointString, TRUE ))

//
//  These are the flags used by the I/O system in deciding whether
//  to apply the share access modes.
//

#define NtfsAccessDataFlags     (   \
    FILE_EXECUTE                    \
    | FILE_READ_DATA                \
    | FILE_WRITE_DATA               \
    | FILE_APPEND_DATA              \
    | DELETE                        \
)

#define NtfsIsStreamNew( IrpInfo )     \
    ( (IrpInfo == FILE_CREATED) ||     \
      (IrpInfo == FILE_SUPERSEDED) ||  \
      (IrpInfo == FILE_OVERWRITTEN) )

//
//  Subset of flags used by IO system to determine whether user has used either
//  BACKUP or RESTORE privilege to get access to file.
//

#define NTFS_REQUIRES_BACKUP    (FILE_READ_DATA | FILE_READ_ATTRIBUTES)
#define NTFS_REQUIRES_RESTORE   (FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | DELETE)

//
//  Local definitions
//

typedef enum _SHARE_MODIFICATION_TYPE {

    CheckShareAccess,
    UpdateShareAccess,
    SetShareAccess,
    RecheckShareAccess

} SHARE_MODIFICATION_TYPE, *PSHARE_MODIFICATION_TYPE;

typedef struct _CREATE_CONTEXT {

    ULONG FileHashValue;
    ULONG FileHashLength;
    ULONG ParentHashValue;
    ULONG ParentHashLength;

} CREATE_CONTEXT, *PCREATE_CONTEXT;

UNICODE_STRING NtfsVolumeDasd = CONSTANT_UNICODE_STRING ( L"$Volume" );

LUID NtfsSecurityPrivilege = { SE_SECURITY_PRIVILEGE, 0 };

//
//  VOID
//  NtfsBackoutFailedOpens (
//    IN PIRP_CONTEXT IrpContext,
//      IN PFILE_OBJECT FileObject,
//      IN PFCB ThisFcb,
//      IN PSCB ThisScb OPTIONAL,
//      IN PCCB ThisCcb OPTIONAL
//      );
//

#define NtfsBackoutFailedOpens(IC,FO,F,S,C) {           \
    if (((S) != NULL) && ((C) != NULL)) {               \
                                                        \
        NtfsBackoutFailedOpensPriv( IC, FO, F, S, C );  \
    }                                                   \
}                                                       \

//
//  Local support routines.
//

NTSTATUS
NtfsOpenFcbById (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN PLCB ParentLcb OPTIONAL,
    IN OUT PFCB *CurrentFcb,
    IN BOOLEAN UseCurrentFcb,
    IN FILE_REFERENCE FileReference,
    IN UNICODE_STRING AttrName,
    IN UNICODE_STRING AttrCodeName,
    IN PVOID NetworkInfo OPTIONAL,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    );

NTSTATUS
NtfsOpenExistingPrefixFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB ThisFcb,
    IN PLCB Lcb OPTIONAL,
    IN ULONG FullPathNameLength,
    IN UNICODE_STRING AttrName,
    IN UNICODE_STRING AttrCodeName,
    IN ULONG CreateFlags,
    IN PVOID NetworkInfo OPTIONAL,
    IN PCREATE_CONTEXT CreateContext,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    );

NTSTATUS
NtfsOpenTargetDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB ThisFcb,
    IN PLCB ParentLcb OPTIONAL,
    IN OUT PUNICODE_STRING FullPathName,
    IN ULONG FinalNameLength,
    IN ULONG CreateFlags,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    );

NTSTATUS
NtfsOpenFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PSCB ParentScb,
    IN PINDEX_ENTRY IndexEntry,
    IN UNICODE_STRING FullPathName,
    IN UNICODE_STRING FinalName,
    IN UNICODE_STRING AttrName,
    IN UNICODE_STRING AttrCodeName,
    IN PQUICK_INDEX QuickIndex,
    IN ULONG CreateFlags,
    IN PVOID NetworkInfo OPTIONAL,
    IN PCREATE_CONTEXT CreateContext,
    OUT PFCB *CurrentFcb,
    OUT PLCB *LcbForTeardown,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    );

NTSTATUS
NtfsCreateNewFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PSCB ParentScb,
    IN PFILE_NAME FileNameAttr,
    IN UNICODE_STRING FullPathName,
    IN UNICODE_STRING FinalName,
    IN UNICODE_STRING AttrName,
    IN UNICODE_STRING AttrCodeName,
    IN ULONG CreateFlags,
    IN PINDEX_CONTEXT *IndexContext,
    IN PCREATE_CONTEXT CreateContext,
    OUT PFCB *CurrentFcb,
    OUT PLCB *LcbForTeardown,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    );

PLCB
NtfsOpenSubdirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN UNICODE_STRING Name,
    IN ULONG CreateFlags,
    OUT PFCB *CurrentFcb,
    OUT PLCB *LcbForTeardown,
    IN PINDEX_ENTRY IndexEntry
    );

NTSTATUS
NtfsOpenAttributeInExistingFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN ULONG CcbFlags,
    IN ULONG CreateFlags,
    IN PVOID NetworkInfo OPTIONAL,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    );

NTSTATUS
NtfsOpenExistingAttr (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN ULONG CcbFlags,
    IN ULONG CreateFlags,
    IN BOOLEAN DirectoryOpen,
    IN PVOID NetworkInfo OPTIONAL,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    );

NTSTATUS
NtfsOverwriteAttr (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN BOOLEAN Supersede,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN ULONG CcbFlags,
    IN ULONG CreateFlags,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    );

NTSTATUS
NtfsOpenNewAttr (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb,
    IN PFCB ThisFcb,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN LOGICAL CreateFile,
    IN ULONG CcbFlags,
    IN BOOLEAN LogIt,
    IN ULONG CreateFlags,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    );

BOOLEAN
NtfsParseNameForCreate (
    IN PIRP_CONTEXT IrpContext,
    IN UNICODE_STRING String,
    IN OUT PUNICODE_STRING FileObjectString,
    IN OUT PUNICODE_STRING OriginalString,
    IN OUT PUNICODE_STRING NewNameString,
    OUT PUNICODE_STRING AttrName,
    OUT PUNICODE_STRING AttrCodeName
    );

NTSTATUS
NtfsCheckValidAttributeAccess (
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN PDUPLICATED_INFORMATION Info OPTIONAL,
    IN OUT PUNICODE_STRING AttrName,
    IN UNICODE_STRING AttrCodeName,
    IN ULONG CreateFlags,
    OUT PATTRIBUTE_TYPE_CODE AttrTypeCode,
    OUT PULONG CcbFlags,
    OUT PBOOLEAN IndexedAttribute
    );

NTSTATUS
NtfsOpenAttributeCheck (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    OUT PSCB *ThisScb,
    OUT PSHARE_MODIFICATION_TYPE ShareModificationType
    );

VOID
NtfsAddEa (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB ThisFcb,
    IN PFILE_FULL_EA_INFORMATION EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PIO_STATUS_BLOCK Iosb
    );

VOID
NtfsCreateAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PFCB ThisFcb,
    IN OUT PSCB ThisScb,
    IN PLCB ThisLcb,
    IN LONGLONG AllocationSize,
    IN BOOLEAN LogIt,
    IN BOOLEAN ForceNonresident,
    IN PUSHORT PreviousFlags OPTIONAL
    );

VOID
NtfsRemoveDataAttributes (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ThisFcb,
    IN PLCB ThisLcb OPTIONAL,
    IN PFILE_OBJECT FileObject,
    IN ULONG LastFileNameOffset,
    IN ULONG CreateFlags
    );

VOID
NtfsRemoveReparsePoint (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ThisFcb
    );

VOID
NtfsReplaceAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB ThisFcb,
    IN PSCB ThisScb,
    IN PLCB ThisLcb,
    IN LONGLONG AllocationSize
    );

NTSTATUS
NtfsOpenAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN SHARE_MODIFICATION_TYPE ShareModificationType,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN LOGICAL CreateFile,
    IN ULONG CcbFlags,
    IN PVOID NetworkInfo OPTIONAL,
    IN OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    );

VOID
NtfsBackoutFailedOpensPriv (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PFCB ThisFcb,
    IN PSCB ThisScb,
    IN PCCB ThisCcb
    );

VOID
NtfsUpdateScbFromMemory (
    IN OUT PSCB Scb,
    IN POLD_SCB_SNAPSHOT ScbSizes
    );

VOID
NtfsOplockPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp
    );

NTSTATUS
NtfsCreateCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
NtfsCheckExistingFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN ULONG CcbFlags
    );

NTSTATUS
NtfsBreakBatchOplock (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB ThisFcb,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    OUT PSCB *ThisScb
    );

NTSTATUS
NtfsCompleteLargeAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PLCB Lcb,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN ULONG CreateFlags
    );

NTSTATUS
NtfsEncryptionCreateCallback (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PSCB ThisScb,
    IN PCCB ThisCcb,
    IN PFCB CurrentFcb,
    IN PFCB ParentFcb,
    IN BOOLEAN CreateNewFile
    );

VOID
NtfsPostProcessEncryptedCreate (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN ULONG EncryptionFileDirFlags,
    IN ULONG FailedInPostCreateOnly
    );

NTSTATUS
NtfsGetReparsePointValue (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN USHORT RemainingNameLength
    );

BOOLEAN
NtfsCheckValidFileAccess(
    IN PFCB ThisFcb,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NtfsLookupObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PUNICODE_STRING FileName,
    OUT PFILE_REFERENCE FileReference
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAddEa)
#pragma alloc_text(PAGE, NtfsBackoutFailedOpensPriv)
#pragma alloc_text(PAGE, NtfsBreakBatchOplock)
#pragma alloc_text(PAGE, NtfsCheckExistingFile)
#pragma alloc_text(PAGE, NtfsCheckValidAttributeAccess)
#pragma alloc_text(PAGE, NtfsCheckValidFileAccess)
#pragma alloc_text(PAGE, NtfsCommonCreate)
#pragma alloc_text(PAGE, NtfsCommonVolumeOpen)
#pragma alloc_text(PAGE, NtfsCompleteLargeAllocation)
#pragma alloc_text(PAGE, NtfsCreateAttribute)
#pragma alloc_text(PAGE, NtfsCreateCompletionRoutine)
#pragma alloc_text(PAGE, NtfsCreateNewFile)
#pragma alloc_text(PAGE, NtfsEncryptionCreateCallback)
#pragma alloc_text(PAGE, NtfsFsdCreate)
#pragma alloc_text(PAGE, NtfsGetReparsePointValue)
#pragma alloc_text(PAGE, NtfsInitializeFcbAndStdInfo)
#pragma alloc_text(PAGE, NtfsLookupObjectId)
#pragma alloc_text(PAGE, NtfsNetworkOpenCreate)
#pragma alloc_text(PAGE, NtfsOpenAttribute)
#pragma alloc_text(PAGE, NtfsOpenAttributeCheck)
#pragma alloc_text(PAGE, NtfsOpenAttributeInExistingFile)
#pragma alloc_text(PAGE, NtfsOpenExistingAttr)
#pragma alloc_text(PAGE, NtfsOpenExistingPrefixFcb)
#pragma alloc_text(PAGE, NtfsOpenFcbById)
#pragma alloc_text(PAGE, NtfsOpenFile)
#pragma alloc_text(PAGE, NtfsOpenNewAttr)
#pragma alloc_text(PAGE, NtfsOpenSubdirectory)
#pragma alloc_text(PAGE, NtfsOpenTargetDirectory)
#pragma alloc_text(PAGE, NtfsOplockPrePostIrp)
#pragma alloc_text(PAGE, NtfsOverwriteAttr)
#pragma alloc_text(PAGE, NtfsParseNameForCreate)
#pragma alloc_text(PAGE, NtfsPostProcessEncryptedCreate)
#pragma alloc_text(PAGE, NtfsRemoveDataAttributes)
#pragma alloc_text(PAGE, NtfsRemoveReparsePoint)
#pragma alloc_text(PAGE, NtfsReplaceAttribute)
#pragma alloc_text(PAGE, NtfsTryOpenFcb)
#pragma alloc_text(PAGE, NtfsUpdateScbFromMemory)
#endif


NTSTATUS
NtfsFsdCreate (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of Create.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext;
    LOGICAL CallPostCreate = FALSE;
    BOOLEAN Wait;
    OPLOCK_CLEANUP OplockCleanup;
    NTFS_COMPLETION_CONTEXT CompletionContext;
    LOGICAL PrevStackSwapEnable;
    LOGICAL ExitFileSystem;

    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS
    //

    if (VolumeDeviceObject->DeviceObject.Size == (USHORT)sizeof(DEVICE_OBJECT)) {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FILE_OPENED;

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );

        return STATUS_SUCCESS;
    }

    DebugTrace( +1, Dbg, ("NtfsFsdCreate\n") );

    if (NtfsData.EncryptionCallBackTable.PreCreate != NULL) {

        ASSERT( NtfsData.EncryptionCallBackTable.PostCreate != NULL );
        Status = NtfsData.EncryptionCallBackTable.PreCreate( (PDEVICE_OBJECT) VolumeDeviceObject,
                                                     Irp,
                                                     IoGetCurrentIrpStackLocation(Irp)->FileObject );

        //
        //  Raise the status if a failure.
        //

        if (Status != STATUS_SUCCESS) {

            NtfsCompleteRequest( NULL, Irp, Status );
            return Status;
        }

        //
        //  We have to pair up our PreCreates with PostCreates, so remember them.
        //

        CallPostCreate = TRUE;

    } else {

        //
        //  If we simply don't have a precreate routine registered, then the precreate
        //  routine can't fail.  Let's always remember to call post create in this case.
        //

        CallPostCreate = TRUE;
    }

    //
    //  Call the common Create routine
    //

    IrpContext = NULL;

    FsRtlEnterFileSystem();
    ExitFileSystem = TRUE;

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );
    RtlZeroMemory( &OplockCleanup, sizeof( OplockCleanup ) );

    do {

        try {

            if (IrpContext == NULL) {

                Wait = CanFsdWait( Irp ) || CallPostCreate;

                //
                //  Allocate and initialize the Irp.
                //

                NtfsInitializeIrpContext( Irp, Wait, &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

                if (Wait) {

                    KeInitializeEvent( &CompletionContext.Event, NotificationEvent, FALSE );
                    OplockCleanup.CompletionContext = &CompletionContext;
                }

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );
            }

            //
            //  Lest we complete the IRP without doing the appropriate PostCreate callouts...
            //  We'll complete the irp _unless_ we have an attached encryption driver with
            //  a post create callout registered. An unfortunate side effect here is that we
            //  have (inadvertently) called PreCreate on VolumeOpens as well...
            //

            if (CallPostCreate) {

                SetFlag( IrpContext->State,
                         IRP_CONTEXT_STATE_EFS_CREATE | IRP_CONTEXT_STATE_PERSISTENT );
            }

            if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DASD_OPEN )) {

                Status = NtfsCommonVolumeOpen( IrpContext, Irp );
                ASSERT( Status != STATUS_PENDING );

            } else {

                //
                //  Make sure there is sufficient stack to perform the create.
                //  If we don't, carefully post this request.
                //

                if (IoGetRemainingStackSize( ) >= OVERFLOW_CREATE_THRESHHOLD) {

                    Status = NtfsCommonCreate( IrpContext, Irp, &OplockCleanup, NULL );

                } else {

                    ASSERT( IrpContext->ExceptionStatus == 0 );

                    //
                    //  Use the next stack location with NtfsCreateCompletionRoutine
                    //  and post this to a worker thread.
                    //

                    if (OplockCleanup.CompletionContext != NULL) {

                        NtfsPrepareForIrpCompletion( IrpContext, Irp, OplockCleanup.CompletionContext );
                    }

                    //
                    //  If lock buffer call raises, this'll fall through to ProcessException below.
                    //  Normally, this'll just return PENDING and we wait for the IRP to complete.
                    //

                    Status = NtfsPostRequest( IrpContext, Irp );
                }
            }

            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  exception code
            //

            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    //
    //  Check if we need to have control of the Irp.
    //

    if (OplockCleanup.CompletionContext != NULL) {

        //
        //  If pending then wait on the event to take control of the Irp again.
        //

        if (Status == STATUS_PENDING) {

            KPROCESSOR_MODE WaitMode = UserMode;

            //
            //  Don't let the stack get swapped out in case we post.
            //

            PrevStackSwapEnable = KeSetKernelStackSwapEnable( FALSE );

            FsRtlExitFileSystem();
            ExitFileSystem = FALSE;

            //
            //  Retry the wait until it completes successfully.
            //

            while (TRUE) {

                //
                //  Test the wait status to see if someone is trying to rundown the current
                //  thread.
                //

                Status = KeWaitForSingleObject( &OplockCleanup.CompletionContext->Event,
                                                Executive,
                                                WaitMode,
                                                FALSE,
                                                NULL );

                if (Status == STATUS_SUCCESS) { break; }

                if (Status != STATUS_KERNEL_APC) {

                    //
                    //  In the (unlikely) event that the Irp we want to cancel is
                    //  waiting for the encryption driver to return from the post
                    //  create callout, we'll deadlock in here.  By signalling the
                    //  EncryptionPending event, we're certain that any threads
                    //  in that state will run, and check whether their irp has been
                    //  cancelled.  It's harmless to signal this event, since any
                    //  requests still actually waiting for the post create callout
                    //  to return will still see the encryption pending bit set
                    //  in their FCB and know to retry.
                    //

                    IoCancelIrp( Irp );
                    KeSetEvent( &NtfsEncryptionPendingEvent, 0, FALSE );
                    WaitMode = KernelMode;
                }
            }

            FsRtlEnterFileSystem();
            ExitFileSystem = TRUE;

            //
            //  Restore the previous value for the stack swap.
            //

            if (PrevStackSwapEnable) {

                KeSetKernelStackSwapEnable( TRUE );
            }

            Status = Irp->IoStatus.Status;

            if (CallPostCreate) {

                goto PreCreateComplete;
            }

            NtfsCompleteRequest( NULL, Irp, Status );

        } else if (CallPostCreate) {

            NTSTATUS PostCreateStatus;
            ULONG FailedInPostCreateOnly;

PreCreateComplete:

            if (NtfsData.EncryptionCallBackTable.PostCreate != NULL) {

                PIO_STACK_LOCATION IrpSp;

                //
                //  Restore the thread context pointer if associated with this IrpContext.
                //

                if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL )) {

                    NtfsRestoreTopLevelIrp();
                    ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL );
                }

                FsRtlExitFileSystem();
                ExitFileSystem = FALSE;

#ifdef NTFSDBG
                ASSERT( IrpContext->OwnershipState == None );
#endif

                IrpSp = IoGetCurrentIrpStackLocation( Irp );
                PostCreateStatus = NtfsData.EncryptionCallBackTable.PostCreate( (PDEVICE_OBJECT) VolumeDeviceObject,
                                                                                Irp,
                                                                                IrpSp->FileObject,
                                                                                Status,
                                                                                &IrpContext->EfsCreateContext );

                ASSERT( Status != STATUS_REPARSE || PostCreateStatus == STATUS_REPARSE );

                //
                //  If we got STATUS_ACCESS_DENIED and the user asked for MAXIMUM_ALLOWED then simply
                //  remove the references that allowed read or write access.
                //

                if ((PostCreateStatus == STATUS_ACCESS_DENIED) &&
                    FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->OriginalDesiredAccess, MAXIMUM_ALLOWED ) &&
                    (Irp->IoStatus.Information == FILE_OPENED)) {

                    PSCB Scb = (PSCB) IrpSp->FileObject->FsContext;
                    BOOLEAN CapturedDeleteAccess = IrpSp->FileObject->DeleteAccess;

                    //
                    //  Swallow the error status in this case.
                    //

                    PostCreateStatus = STATUS_SUCCESS;

                    //
                    //  Do all the work to reenter the file system.  We should never raise out of this block of
                    //  code.
                    //

                    FsRtlEnterFileSystem();
                    ExitFileSystem = TRUE;

                    NtfsAcquireResourceExclusive( IrpContext,
                                                  Scb,
                                                  TRUE );

                    IoRemoveShareAccess( IrpSp->FileObject,
                                         &Scb->ShareAccess );

                    //
                    //  Clear out the history in the file object.
                    //

                    IrpSp->FileObject->ReadAccess = FALSE;
                    IrpSp->FileObject->WriteAccess = FALSE;
                    IrpSp->FileObject->DeleteAccess = FALSE;

                    IrpSp->FileObject->SharedRead = FALSE;
                    IrpSp->FileObject->SharedWrite = FALSE;
                    IrpSp->FileObject->SharedDelete = FALSE;

                    ClearFlag( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                               (FILE_READ_DATA |
                                FILE_EXECUTE |
                                FILE_WRITE_DATA |
                                FILE_APPEND_DATA) );

                    //
                    //  If we already granted delete access then reapply.
                    //

                    if (CapturedDeleteAccess) {

                        PostCreateStatus = IoCheckShareAccess( DELETE,
                                                               IrpSp->Parameters.Create.ShareAccess,
                                                               IrpSp->FileObject,
                                                               &Scb->ShareAccess,
                                                               TRUE );
                    }

                    NtfsReleaseResource( IrpContext,
                                         Scb );

                    FsRtlExitFileSystem();
                    ExitFileSystem = FALSE;
                }

            } else {

                PostCreateStatus = STATUS_SUCCESS;
            }

            //
            //  We may have posted the create due to an oplock, in which case the IrpContext
            //  will look like we're in the FSP thread.  Let's clear the bit now since we're
            //  not in the FSP thread now.
            //

            ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP );

            //
            //  Do our final cleanup only if we created a new encrypted directory/file or
            //  we got an error from the encryption callback above.
            //

            FailedInPostCreateOnly = NT_SUCCESS( Status ) && !NT_SUCCESS( PostCreateStatus );
            if (FailedInPostCreateOnly ||
                FlagOn( IrpContext->EncryptionFileDirFlags, FILE_NEW | DIRECTORY_NEW )) {

                //
                //  Reenter the filesystem at this point.
                //

                if (!ExitFileSystem) {

                    FsRtlEnterFileSystem();
                    ExitFileSystem = TRUE;
                }

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

                //
                //  There's no fileobject to cleanup if the normal part of this create failed.
                //

                if (NT_SUCCESS( Status ) &&
                    (Status != STATUS_REPARSE)) {

                    NtfsPostProcessEncryptedCreate( IrpContext,
                                                    IoGetCurrentIrpStackLocation( Irp )->FileObject,
                                                    IrpContext->EncryptionFileDirFlags,
                                                    FailedInPostCreateOnly );
                }
            }

            //
            //  If the encryption driver came up with a new reason to fail this irp, return
            //  that status.
            //

            if (FailedInPostCreateOnly) { Status = PostCreateStatus; }

            //
            //  Now we're really done with both the irp context and the irp, so let's
            //  get rid of them.
            //

            ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT );
            NtfsCompleteRequest( IrpContext, Irp, Status );
        }
    }

    if (ExitFileSystem) {

        FsRtlExitFileSystem();
    }

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );

    //
    //  We should never return STATUS_CANT_WAIT or STATUS_PENDING
    //

    ASSERT( (Status != STATUS_CANT_WAIT) && (Status != STATUS_PENDING ) );

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdCreate -> %08lx\n", Status) );
    return Status;
}


BOOLEAN
NtfsNetworkOpenCreate (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine implements the fast open create for path-based queries.

Arguments:

    Irp - Supplies the Irp being processed

    Buffer - Buffer to return the network query information

    DeviceObject - Supplies the volume device object where the file exists

Return Value:

    BOOLEAN - Indicates whether or not the fast path could be taken.

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;
    BOOLEAN Result = TRUE;
    BOOLEAN DasdOpen = FALSE;
    OPLOCK_CLEANUP OplockCleanup;

    NTSTATUS Status;
    IRP_CONTEXT LocalIrpContext;
    PIRP_CONTEXT IrpContext = &LocalIrpContext;

    ASSERT_IRP( Irp );

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    //
    //
    //  Call the common Create routine
    //

    FsRtlEnterFileSystem();

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );
    RtlZeroMemory( &OplockCleanup, sizeof( OplockCleanup ) );

    try {

        //
        //  Allocate the Irp and update the top level storage.
        //

        NtfsInitializeIrpContext( Irp, TRUE, &IrpContext );
        NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

        Status = NtfsCommonCreate( IrpContext, Irp, &OplockCleanup, Buffer );

    } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  Catch the case where someone in attempting this on a DASD open.
        //

        if ((IrpContext != NULL) && (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DASD_OPEN ))) {

            DasdOpen = TRUE;
        }

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  exception code.  Since there is no Irp the exception package
        //  will always deallocate the IrpContext so we won't do
        //  any retry in this path.
        //

        Status = GetExceptionCode();

        //
        //  Don't pass a retryable error to ProcessException.  We want to
        //  force this request to the Irp path in any case.
        //

        if ((Status == STATUS_CANT_WAIT) || (Status == STATUS_LOG_FILE_FULL)) {

            Status = STATUS_FILE_LOCK_CONFLICT;
            IrpContext->ExceptionStatus = STATUS_FILE_LOCK_CONFLICT;
        }

        Status = NtfsProcessException( IrpContext, NULL, Status );

        //
        //  Always fail the DASD case.
        //

        if (DasdOpen) {

            Status = STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  STATUS_SUCCESS is the typical case.  Test for it first.
    //

    if (Status != STATUS_SUCCESS) {

        //
        //  Return STATUS_FILE_LOCK_CONFLICT for any retryable error.
        //

        ASSERT( (Status != STATUS_CANT_WAIT) && (Status != STATUS_LOG_FILE_FULL) );

        if ((Status == STATUS_REPARSE) || (Status == STATUS_FILE_LOCK_CONFLICT)) {

            Result = FALSE;
            Status = STATUS_FILE_LOCK_CONFLICT;
        }
    }

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    Irp->IoStatus.Status = Status;
    return Result;
}


NTSTATUS
NtfsCommonCreate (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN POPLOCK_CLEANUP OplockCleanup,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInfo OPTIONAL
    )

/*++

Routine Description:

    This is the common routine for Create called by both the fsd and fsp
    threads.  If this open has already been detected to be a volume open then
    take we will take the volume open path instead.

Arguments:

    Irp - Supplies the Irp to process

    CompletionContext - Event used to serialize waiting for the oplock break.

    NetworkInfo - Optional buffer to return the queried data for
        NetworkInformation.  Its presence indicates that we should not
        do a full open.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT RelatedFileObject;

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AcquireFlags = 0;

    UNICODE_STRING AttrName;
    UNICODE_STRING AttrCodeName;

    PVCB Vcb;

    //
    //  The following are used to teardown any Lcb/Fcb this
    //  routine is responsible for.
    //

    PLCB LcbForTeardown = NULL;

    //
    //  The following indicate how far down the tree we have scanned.
    //

    PFCB ParentFcb;
    PLCB CurrentLcb;
    PFCB CurrentFcb = NULL;
    PSCB LastScb = NULL;
    PSCB CurrentScb;
    PLCB NextLcb;

    //
    //  The following are the results of open operations.
    //

    PSCB ThisScb = NULL;
    PCCB ThisCcb = NULL;

    //
    //  The following are the in-memory structures associated with
    //  the relative file object.
    //

    TYPE_OF_OPEN RelatedFileObjectTypeOfOpen;
    PFCB RelatedFcb;
    PSCB RelatedScb;
    PCCB RelatedCcb;

    UCHAR CreateDisposition;

    PFILE_NAME FileNameAttr = NULL;
    USHORT FileNameAttrLength = 0;

    PINDEX_ENTRY IndexEntry;
    PBCB IndexEntryBcb = NULL;

    QUICK_INDEX QuickIndex;

#if defined(_WIN64)
    INDEX_CONTEXT IndexContextStruct;
#endif
    PINDEX_CONTEXT IndexContext = NULL;

    //
    //  The following unicode strings are used to track the names
    //  during the open operation.  They may point to the same
    //  buffer so careful checks must be done at cleanup.
    //
    //  OriginalFileName - This is the value to restore to the file
    //      object on error cleanup.  This will containg the
    //      attribute type codes and attribute names if present.
    //
    //  FullFileName - This is the constructed string which contains
    //      only the name components.  It may point to the same
    //      buffer as the original name but the length value is
    //      adjusted to cut off the attribute code and name.
    //
    //  ExactCaseName - This is the version of the full filename
    //      exactly as given by the caller.  Used to preserve the
    //      case given by the caller in the event we do a case
    //      insensitive lookup.  If the user is doing a relative open
    //      then we don't need to allocate a new buffer.  We can use
    //      the original name from above.
    //
    //  ExactCaseOffset - This is the offset in the FullFileName where
    //      the relative component begins.  This is where we position ourselves
    //      when restoring the correct case for this name.
    //
    //  RemainingName - This is the portion of the full name still
    //      to parse.
    //
    //  FinalName - This is the current component of the full name.
    //
    //  CaseInsensitiveIndex - This is the offset in the full file
    //      where we performed upcasing.  We need to restore the
    //      exact case on failures and if we are creating a file.
    //

    PUNICODE_STRING OriginalFileName = &OplockCleanup->OriginalFileName;
    PUNICODE_STRING FullFileName = &OplockCleanup->FullFileName;
    PUNICODE_STRING ExactCaseName = &OplockCleanup->ExactCaseName;
    USHORT ExactCaseOffset = 0;

    UNICODE_STRING RemainingName;
    UNICODE_STRING FinalName;
    ULONG CaseInsensitiveIndex = 0;

    CREATE_CONTEXT CreateContext;

    ULONG CreateFlags = 0;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Innitialize all the remaining fields in the OPLOCK_CLEANUP structure.
    //

    OplockCleanup->FileObject = IrpSp->FileObject;

    OplockCleanup->RemainingDesiredAccess = IrpSp->Parameters.Create.SecurityContext->AccessState->RemainingDesiredAccess;
    OplockCleanup->PreviouslyGrantedAccess = IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess;
    OplockCleanup->DesiredAccess = IrpSp->Parameters.Create.SecurityContext->DesiredAccess;
    OplockCleanup->AttributeNameLength = 0;
    OplockCleanup->AttributeCodeNameLength = 0;

#ifdef BRIANDBG
    if (NtfsTestName.Length != 0) {

        NtfsTestOpenName( IrpSp->FileObject );
    }
#endif

    //
    //  Initialize the attribute strings.
    //

    AttrName.Length = 0;
    AttrCodeName.Length = 0;

    DebugTrace( +1, Dbg, ("NtfsCommonCreate:  Entered\n") );
    DebugTrace( 0, Dbg, ("IrpContext                = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp                       = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("->Flags                   = %08lx\n", Irp->Flags) );
    DebugTrace( 0, Dbg, ("->FileObject              = %08lx\n", IrpSp->FileObject) );
    DebugTrace( 0, Dbg, ("->RelatedFileObject       = %08lx\n", IrpSp->FileObject->RelatedFileObject) );
    DebugTrace( 0, Dbg, ("->FileName                = %Z\n",    &IrpSp->FileObject->FileName) );
    DebugTrace( 0, Dbg, ("->AllocationSize          = %08lx %08lx\n", Irp->Overlay.AllocationSize.LowPart,
                                                                     Irp->Overlay.AllocationSize.HighPart ) );
    DebugTrace( 0, Dbg, ("->EaBuffer                = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );
    DebugTrace( 0, Dbg, ("->EaLength                = %08lx\n", IrpSp->Parameters.Create.EaLength) );
    DebugTrace( 0, Dbg, ("->DesiredAccess           = %08lx\n", IrpSp->Parameters.Create.SecurityContext->DesiredAccess) );
    DebugTrace( 0, Dbg, ("->Options                 = %08lx\n", IrpSp->Parameters.Create.Options) );
    DebugTrace( 0, Dbg, ("->FileAttributes          = %04x\n",  IrpSp->Parameters.Create.FileAttributes) );
    DebugTrace( 0, Dbg, ("->ShareAccess             = %04x\n",  IrpSp->Parameters.Create.ShareAccess) );
    DebugTrace( 0, Dbg, ("->Directory               = %04x\n",  FlagOn( IrpSp->Parameters.Create.Options,
                                                                       FILE_DIRECTORY_FILE )) );
    DebugTrace( 0, Dbg, ("->NonDirectoryFile        = %04x\n",  FlagOn( IrpSp->Parameters.Create.Options,
                                                                       FILE_NON_DIRECTORY_FILE )) );
    DebugTrace( 0, Dbg, ("->NoIntermediateBuffering = %04x\n",  FlagOn( IrpSp->Parameters.Create.Options,
                                                                       FILE_NO_INTERMEDIATE_BUFFERING )) );
    DebugTrace( 0, Dbg, ("->CreateDisposition       = %04x\n",  (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff) );
    DebugTrace( 0, Dbg, ("->IsPagingFile            = %04x\n",  FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE )) );
    DebugTrace( 0, Dbg, ("->OpenTargetDirectory     = %04x\n",  FlagOn( IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY )) );
    DebugTrace( 0, Dbg, ("->CaseSensitive           = %04x\n",  FlagOn( IrpSp->Flags, SL_CASE_SENSITIVE )) );
    DebugTrace( 0, Dbg, ("->NetworkInfo             = %08x\n",  NetworkInfo) );

    DebugTrace( 0, Dbg, ("->EntryRemainingDesiredAccess  = %08lx\n", OplockCleanup->RemainingDesiredAccess) );
    DebugTrace( 0, Dbg, ("->EntryPreviouslyGrantedAccess = %08lx\n", OplockCleanup->PreviouslyGrantedAccess) );


    //
    //  For NT5, the fact that the user has requested that the file be created
    //  encrypted means it will not be created compressed, regardless of the
    //  compression state of the parent directory.
    //

    if (FlagOn( IrpSp->Parameters.Create.FileAttributes, FILE_ATTRIBUTE_ENCRYPTED )) {

        SetFlag( IrpSp->Parameters.Create.Options, FILE_NO_COMPRESSION );
    }

    //
    //  Clear encryption flags in irpcontext
    //

    IrpContext->EncryptionFileDirFlags = 0;

    //
    //  Verify that we can wait and acquire the Vcb exclusively.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        DebugTrace( 0, Dbg, ("Can't wait in create\n") );

        Status = NtfsPostRequest( IrpContext, Irp );

        DebugTrace( -1, Dbg, ("NtfsCommonCreate:  Exit -> %08lx\n", Status) );
        return Status;
    }

    //
    //  If we're retrying this create because we're waiting for the key blob
    //  from the encryption driver, we want to wait for our notification
    //  event so we don't hog the cpu(s) and prevent the encryption driver
    //  from having a chance to give us the key blob.
    //

    if FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ENCRYPTION_RETRY ) {

        KeWaitForSingleObject( &NtfsEncryptionPendingEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        //
        //  While we were waiting for the encryption driver's post create callout
        //  to return, the create has been cancelled, most likely because the user's
        //  process is terminating.  In that case, let's complete and exit now.
        //

        if (Irp->Cancel) {

            Status = STATUS_CANCELLED;
            DebugTrace( -1, Dbg, ("NtfsCommonCreate:  Exit -> %08lx\n", Status) );

            if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_EFS_CREATE ) ||
                (ARGUMENT_PRESENT( NetworkInfo ))) {

                NtfsCompleteRequest( IrpContext,
                                     NULL,
                                     Status );

            } else {

                NtfsCompleteRequest( IrpContext,
                                     Irp,
                                     Status );
            }

            return Status;
        }

        ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_ENCRYPTION_RETRY );
    }

    //
    //  Update the IrpContext with the oplock cleanup structure.
    //

    IrpContext->Union.OplockCleanup = OplockCleanup;

    //
    //  Locate the volume device object and Vcb that we are trying to access.
    //

    Vcb = &((PVOLUME_DEVICE_OBJECT)IrpSp->DeviceObject)->Vcb;

    if (FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE )) {

        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Let's do some work here if the close lists have exceeded
        //  some threshold.  Cast 1 to a pointer to indicate who is calling
        //  FspClose.
        //

        if ((NtfsData.AsyncCloseCount + NtfsData.DelayedCloseCount) > NtfsThrottleCreates) {

            NtfsFspClose( (PVCB) 1 );
        }

        if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX )) {

            NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

        } else {

            NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
        }

        SetFlag( CreateFlags, CREATE_FLAG_ACQUIRED_VCB );

        //
        //  Set up local pointers to the file name.
        //

        *FullFileName = *OriginalFileName = OplockCleanup->FileObject->FileName;

        //
        //  Make sure that Darryl didn't send us a garbage name
        //

        ASSERT( OplockCleanup->FileObject->FileName.Length != 0 ||
                OplockCleanup->FileObject->FileName.Buffer == 0 );

        ExactCaseName->Buffer = NULL;

        //
        //  Check a few flags before we proceed.
        //

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE | FILE_NON_DIRECTORY_FILE ) ==
            (FILE_DIRECTORY_FILE | FILE_NON_DIRECTORY_FILE)) {

            Status = STATUS_INVALID_PARAMETER;
            try_return( Status );
        }

        //
        //  If the Vcb is locked then we cannot open another file.  If we have performed
        //  a dismount then make sure we have the Vcb acquired exclusive so we can
        //  check if we should dismount this volume.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_LOCKED | VCB_STATE_PERFORMED_DISMOUNT )) {

            DebugTrace( 0, Dbg, ("Volume is locked\n") );

            if (FlagOn( Vcb->VcbState, VCB_STATE_PERFORMED_DISMOUNT ) &&
                !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX )) {

                NtfsReleaseVcb( IrpContext, Vcb );

                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
            }

            //
            //  Either deny access or show the volume was dismounted.  Only show the dismount
            //  if the user is opening through a relative handle.
            //

            Status = STATUS_ACCESS_DENIED;
            if (FlagOn( Vcb->VcbState, VCB_STATE_EXPLICIT_DISMOUNT ) &&
                (OplockCleanup->FileObject->RelatedFileObject != NULL)) {

                Status = STATUS_VOLUME_DISMOUNTED;
            }
            try_return( NOTHING );
        }

        //
        //  Initialize local copies of the stack values.
        //

        RelatedFileObject = OplockCleanup->FileObject->RelatedFileObject;

        if (!FlagOn( IrpSp->Flags, SL_CASE_SENSITIVE )) {
            SetFlag( CreateFlags, CREATE_FLAG_IGNORE_CASE );
        }

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID)) {
            SetFlag( CreateFlags, CREATE_FLAG_OPEN_BY_ID );
        }

        CreateDisposition = (UCHAR) ((IrpSp->Parameters.Create.Options >> 24) & 0x000000ff);

        //
        //  We don't want any file modifications to go through if the volume is readonly.
        //  However, we don't want to fail any _opens_ for writes either, because that
        //  could potentially break many apps. So ignore the PreviouslyGrantedAccess,
        //  and just look at the CreateDisposition.
        //

        if (NtfsIsVolumeReadOnly( Vcb )) {

            if ((CreateDisposition == FILE_CREATE) ||
                (CreateDisposition == FILE_SUPERSEDE) ||
                (CreateDisposition == FILE_OVERWRITE) ||
                (CreateDisposition == FILE_OVERWRITE_IF)) {

                Status = STATUS_MEDIA_WRITE_PROTECTED;
                try_return( Status );
            }
        }

        //
        //  Acquire the paging io resource if we are superseding/overwriting a
        //  file or if we are opening for non-cached access.
        //

        if ((CreateDisposition == FILE_SUPERSEDE) ||
            (CreateDisposition == FILE_OVERWRITE) ||
            (CreateDisposition == FILE_OVERWRITE_IF) ||
            FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_INTERMEDIATE_BUFFERING )) {

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
        }

        //
        //  We don't allow an open for an existing paging file.  To insure that the
        //  delayed close Scb is not for this paging file we will unconditionally
        //  dereference it if this is a paging file open.
        //

        if (FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ) &&
            (!IsListEmpty( &NtfsData.AsyncCloseList ) ||
             !IsListEmpty( &NtfsData.DelayedCloseList ))) {

            NtfsFspClose( Vcb );
        }

        //
        //  Set up the file object's Vpb pointer in case anything happens.
        //  This will allow us to get a reasonable pop-up.
        //  Also set the flag to acquire the paging io resource if we might
        //  be creating a stream relative to a file.  We need to make
        //  sure to acquire the paging IO when we get the file.
        //

        if (RelatedFileObject != NULL) {

            OplockCleanup->FileObject->Vpb = RelatedFileObject->Vpb;

            if ((OriginalFileName->Length != 0) &&
                (OriginalFileName->Buffer[0] == L':') &&
                ((CreateDisposition == FILE_OPEN_IF) ||
                 (CreateDisposition == FILE_CREATE))) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
            }
        }

        //
        //  Ping the volume to make sure the Vcb is still mounted.  If we need
        //  to verify the volume then do it now, and if it comes out okay
        //  then clear the verify volume flag in the device object and continue
        //  on.  If it doesn't verify okay then dismount the volume and
        //  either tell the I/O system to try and create again (with a new mount)
        //  or that the volume is wrong. This later code is returned if we
        //  are trying to do a relative open and the vcb is no longer mounted.
        //

        if (!NtfsPingVolume( IrpContext, Vcb, NULL ) ||
            !FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX )) {

                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }

            if (!NtfsPerformVerifyOperation( IrpContext, Vcb )) {

                NtfsReleaseVcb( IrpContext, Vcb );
                NtfsAcquireCheckpointSynchronization( IrpContext, Vcb );
                NtfsAcquireExclusiveVcb( IrpContext, Vcb, FALSE );

                if (!NtfsPerformVerifyOperation( IrpContext, Vcb )) {
                    try {
                        NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );
                    } finally {
                        NtfsReleaseCheckpointSynchronization( IrpContext, Vcb );
                    }

                    if (RelatedFileObject == NULL) {

                        Irp->IoStatus.Information = IO_REMOUNT;
                        NtfsRaiseStatus( IrpContext, STATUS_REPARSE, NULL, NULL );

                    } else {

                        NtfsRaiseStatus( IrpContext, STATUS_WRONG_VOLUME, NULL, NULL );
                    }
                }
            }

            //
            //  The volume verified correctly so now clear the verify bit
            //  and continue with the create
            //

            ClearFlag( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME );
        }

        //
        //  Let's handle the open by Id case immediately.
        //

        if (FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID )) {

            FILE_REFERENCE FileReference;

            if (OriginalFileName->Length == sizeof( FILE_REFERENCE ) ||
                (OriginalFileName->Length == sizeof( FILE_REFERENCE ) + sizeof(WCHAR))) {

                //
                //  This is the regular open by file id case.
                //  Perform a safe copy of the data to our local variable.
                //  accept slash prefixed filerefs
                //

                if (OriginalFileName->Length == sizeof( FILE_REFERENCE )) {
                    RtlCopyMemory( &FileReference,
                                   OplockCleanup->FileObject->FileName.Buffer,
                                   sizeof( FILE_REFERENCE ));
                } else {
                    RtlCopyMemory( &FileReference,
                                   OplockCleanup->FileObject->FileName.Buffer + 1,
                                   sizeof( FILE_REFERENCE ));
                }

            //
            //  If it's 16 bytes long, it should be an object id.  It may
            //  also be one WCHAR longer for the Win32 double backslash.
            //  This code only works for 5.0 volumes with object id indices.
            //

            } else if (((OriginalFileName->Length == OBJECT_ID_KEY_LENGTH) ||
                        (OriginalFileName->Length == OBJECT_ID_KEY_LENGTH + sizeof(WCHAR))) &&

                       (Vcb->ObjectIdTableScb != NULL)) {

                //
                //  In the open by object id case, we need to do some
                //  more work to find the file reference.
                //

                Status = NtfsLookupObjectId( IrpContext, Vcb, OriginalFileName, &FileReference );
                if (!NT_SUCCESS( Status )) {

                    try_return( Status = STATUS_OBJECT_NAME_NOT_FOUND );
                }

            } else {

                Status = STATUS_INVALID_PARAMETER;

                try_return( Status );
            }

            //
            //  Clear the name in the file object.
            //

            OplockCleanup->FileObject->FileName.Buffer = NULL;
            OplockCleanup->FileObject->FileName.MaximumLength = OplockCleanup->FileObject->FileName.Length = 0;

            Status = NtfsOpenFcbById( IrpContext,
                                      Irp,
                                      IrpSp,
                                      Vcb,
                                      NULL,
                                      &CurrentFcb,
                                      FALSE,
                                      FileReference,
                                      NtfsEmptyString,
                                      NtfsEmptyString,
                                      NetworkInfo,
                                      &ThisScb,
                                      &ThisCcb );

            if (Status != STATUS_PENDING) {

                //
                //  Remember if we can let the user see the name for this file opened by id.
                //

                if (!FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->Flags,
                                                      TOKEN_HAS_TRAVERSE_PRIVILEGE )) {

                    SetFlag( CreateFlags, CREATE_FLAG_TRAVERSE_CHECK );
                } else {
                    ClearFlag( CreateFlags, CREATE_FLAG_TRAVERSE_CHECK );
                }

                //
                //  Put the name back into the file object so that the IO system doesn't
                //  think this is a dasd handle.  Leave the max length at zero so
                //  we know this is not a real name.
                //

                OplockCleanup->FileObject->FileName.Buffer = OriginalFileName->Buffer;
                OplockCleanup->FileObject->FileName.Length = OriginalFileName->Length;
            }

            try_return( Status );
        }

        //
        //  Test for double beginning backslashes from the Win32 layer. Apparently
        //  they can't test for this.
        //

        if ((OplockCleanup->FileObject->FileName.Length > sizeof( WCHAR )) &&
            (OplockCleanup->FileObject->FileName.Buffer[1] == L'\\') &&
            (OplockCleanup->FileObject->FileName.Buffer[0] == L'\\')) {

            OplockCleanup->FileObject->FileName.Length -= sizeof( WCHAR );

            RtlMoveMemory( &OplockCleanup->FileObject->FileName.Buffer[0],
                           &OplockCleanup->FileObject->FileName.Buffer[1],
                           OplockCleanup->FileObject->FileName.Length );

            *FullFileName = *OriginalFileName = OplockCleanup->FileObject->FileName;

            //
            //  If there are still two beginning backslashes, the name is bogus.
            //

            if ((OplockCleanup->FileObject->FileName.Length > sizeof( WCHAR )) &&
                (OplockCleanup->FileObject->FileName.Buffer[1] == L'\\')) {

                Status = STATUS_OBJECT_NAME_INVALID;
                try_return( Status );
            }
        }

        //
        //  If there is a related file object, we decode it to verify that this
        //  is a valid relative open.
        //

        if (RelatedFileObject != NULL) {

            PVCB DecodeVcb;

            //
            //  Check for a valid name.  The name can't begin with a backslash
            //  and can't end with two backslashes.
            //

            if (OriginalFileName->Length != 0) {

                //
                //  Check for a leading backslash.
                //

                if (OriginalFileName->Buffer[0] == L'\\') {

                    DebugTrace( 0, Dbg, ("Invalid name for relative open\n") );
                    try_return( Status = STATUS_INVALID_PARAMETER );
                }

                //
                //  Trim off any trailing backslash.
                //

                if (OriginalFileName->Buffer[ (OriginalFileName->Length / sizeof( WCHAR )) - 1 ] == L'\\') {

                    SetFlag( CreateFlags, CREATE_FLAG_TRAILING_BACKSLASH );
                    OplockCleanup->FileObject->FileName.Length -= sizeof( WCHAR );
                    *OriginalFileName = *FullFileName = OplockCleanup->FileObject->FileName;
                }

                //
                //  Now check if there is a trailing backslash.  Note that if
                //  there was already a trailing backslash then there must
                //  be at least one more character or we would have failed
                //  with the original test.
                //

                if (OriginalFileName->Buffer[ (OriginalFileName->Length / sizeof( WCHAR )) - 1 ] == L'\\') {

                    Status = STATUS_OBJECT_NAME_INVALID;
                    try_return( Status );
                }
            }

            RelatedFileObjectTypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                                                RelatedFileObject,
                                                                &DecodeVcb,
                                                                &RelatedFcb,
                                                                &RelatedScb,
                                                                &RelatedCcb,
                                                                TRUE );

            //
            //  Make sure the file object is one that we have seen
            //

            if (RelatedFileObjectTypeOfOpen == UnopenedFileObject) {

                DebugTrace( 0, Dbg, ("Can't use unopend file for relative open\n") );
                try_return( Status = STATUS_INVALID_PARAMETER );
            }

            //
            //  If the related file object was not opened as a file then we need to
            //  get the name and code if our caller passed a name length of zero.
            //  We need to fail this otherwise.
            //

            if (!FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

                //
                //  If the name length is zero then we want the attribute name and
                //  type code from the related file object.
                //

                if (OriginalFileName->Length == 0) {

                    PATTRIBUTE_DEFINITION_COLUMNS ThisAttribute;

                    AttrName = RelatedScb->AttributeName;
                    ThisAttribute = NtfsGetAttributeDefinition( Vcb, RelatedScb->AttributeTypeCode );

                    RtlInitUnicodeString( &AttrCodeName, ThisAttribute->AttributeName );

                //
                //  The relative file has to have been opened as a file.  We
                //  cannot do relative opens relative to an opened attribute.
                //

                } else {

                    DebugTrace( 0, Dbg, ("Invalid File object for relative open\n") );
                    try_return( Status = STATUS_INVALID_PARAMETER );
                }
            }

            //
            //  USN_V2  Remember the source info flags for this Ccb.
            //

            IrpContext->SourceInfo = RelatedCcb->UsnSourceInfo;

            //
            //  If the related Ccb is was opened by file Id, we will
            //  remember that for future use.
            //

            if (FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_FILE_ID )) {

                SetFlag( CreateFlags, CREATE_FLAG_OPEN_BY_ID);
            }

            //
            //  Remember if the related Ccb was opened through a Dos-Only
            //  component.
            //

            if (FlagOn( RelatedCcb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT )) {

                SetFlag( CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT );
            }

        } else {

            RelatedFileObjectTypeOfOpen = UnopenedFileObject;

            if ((OriginalFileName->Length > 2) &&
                (OriginalFileName->Buffer[ (OriginalFileName->Length / sizeof( WCHAR )) - 1 ] == L'\\')) {

                SetFlag( CreateFlags, CREATE_FLAG_TRAILING_BACKSLASH );
                OplockCleanup->FileObject->FileName.Length -= sizeof( WCHAR );
                *OriginalFileName = *FullFileName = OplockCleanup->FileObject->FileName;

                //
                //  If there is still a trailing backslash on the name then
                //  the name is invalid.
                //


                if ((OriginalFileName->Length > 2) &&
                    (OriginalFileName->Buffer[ (OriginalFileName->Length / sizeof( WCHAR )) - 1 ] == L'\\')) {

                    Status = STATUS_OBJECT_NAME_INVALID;
                    try_return( Status );
                }
            }
        }

        DebugTrace( 0, Dbg, ("Related File Object, TypeOfOpen -> %08lx\n", RelatedFileObjectTypeOfOpen) );

        //
        //  We check if this is a user volume open in that there is no name
        //  specified and the related file object is valid if present.  In that
        //  case set the correct flags in the IrpContext and raise so we can take
        //  the volume open path.
        //

        if ((OriginalFileName->Length == 0) &&
            ((RelatedFileObjectTypeOfOpen == UnopenedFileObject) ||
             (RelatedFileObjectTypeOfOpen == UserVolumeOpen))) {

            DebugTrace( 0, Dbg, ("Attempting to open entire volume\n") );

            SetFlag( IrpContext->State,
                     IRP_CONTEXT_STATE_ACQUIRE_EX | IRP_CONTEXT_STATE_DASD_OPEN );

            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
        }

        //
        //  If the related file object was a volume open, then this open is
        //  illegal.
        //

        if (RelatedFileObjectTypeOfOpen == UserVolumeOpen) {

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        //
        //  Remember if we need to perform any traverse access checks.
        //

        if (!FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->Flags,
                     TOKEN_HAS_TRAVERSE_PRIVILEGE )) {

            DebugTrace( 0, Dbg, ("Performing traverse access on this open\n") );

            SetFlag( CreateFlags, CREATE_FLAG_TRAVERSE_CHECK );

        } else {

            ClearFlag( CreateFlags, CREATE_FLAG_TRAVERSE_CHECK );

#ifdef BRIANDBG
            if (NtfsTraverseAccessCheck) {

                SetFlag( CreateFlags, CREATE_FLAG_TRAVERSE_CHECK );
            }
#endif
        }

        //
        //  We enter the loop that does the processing for the prefix lookup.
        //  We optimize the case where we can match a prefix hit.  If there is
        //  no hit we will check if the name is legal or might possibly require
        //  parsing to handle the case where there is a named data stream.
        //

        SetFlag( CreateFlags, CREATE_FLAG_CHECK_FOR_VALID_NAME | CREATE_FLAG_FIRST_PASS );

        while (TRUE) {

            PUNICODE_STRING FileObjectName;
            LONG Index;
            BOOLEAN ComplexName;

            //
            //  Lets make sure we have acquired the starting point for our
            //  name search.  If we have a relative file object then use
            //  that.  Otherwise we will start from the root.
            //

            if (RelatedFileObject != NULL) {

                CurrentFcb = RelatedFcb;

            } else {

                CurrentFcb = Vcb->RootIndexScb->Fcb;
            }

            //
            //  Init NextLcb
            //

            FileObjectName = &OplockCleanup->FileObject->FileName;
            NextLcb = NULL;

            //
            //  We would like to get the starting point shared, unless
            //  we know for certain we need it exclusively.
            //

            if (FlagOn( CreateFlags, CREATE_FLAG_TRAVERSE_CHECK | CREATE_FLAG_OPEN_BY_ID ) ||
                !FlagOn( CreateFlags, CREATE_FLAG_IGNORE_CASE) ||
                (FileObjectName->Length == 0) ||
                (FileObjectName->Buffer[0] == L':') ||
                ((RelatedFileObject == NULL) &&
                 ((FileObjectName->Length <= sizeof( WCHAR )) ||
                  (FileObjectName->Buffer[1] == L':'))) ||
                ((RelatedFileObject != NULL) &&
                 (RelatedFileObjectTypeOfOpen != UserDirectoryOpen))) {

                NtfsAcquireFcbWithPaging( IrpContext, CurrentFcb, 0);
                ClearFlag( CreateFlags, CREATE_FLAG_SHARED_PARENT_FCB );

            } else {

                NtfsAcquireSharedFcb( IrpContext, CurrentFcb, NULL, FALSE );
                SetFlag( CreateFlags, CREATE_FLAG_SHARED_PARENT_FCB );
            }

            if (!FlagOn( CreateFlags, CREATE_FLAG_FIRST_PASS )) {

                if (!NtfsParseNameForCreate( IrpContext,
                                             RemainingName,
                                             FileObjectName,
                                             OriginalFileName,
                                             FullFileName,
                                             &AttrName,
                                             &AttrCodeName )) {

                    try_return( Status = STATUS_OBJECT_NAME_INVALID );
                }

                //
                //  Upcase the AttributeCodeName if the user is IgnoreCase.
                //

                if (FlagOn( CreateFlags, CREATE_FLAG_IGNORE_CASE ) && (AttrCodeName.Length != 0)) {

                    NtfsUpcaseName( Vcb->UpcaseTable, Vcb->UpcaseTableSize, &AttrCodeName );
                }

                //
                //  If we might be creating a named stream acquire the
                //  paging IO as well.  This will keep anyone from peeking
                //  at the allocation size of any other streams we are converting
                //  to non-resident.
                //

                if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING ) &&
                    (AttrName.Length != 0) &&
                    ((CreateDisposition == FILE_OPEN_IF) ||
                     (CreateDisposition == FILE_CREATE))) {

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
                }

                ClearFlag( CreateFlags, CREATE_FLAG_CHECK_FOR_VALID_NAME );

            //
            //  Build up the full name if this is not the open by file Id case.
            //

            } else if (!FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID )) {

                //
                //  If we have a related file object, then we build up the
                //  combined name.
                //

                if (RelatedFileObject != NULL) {

                    WCHAR *CurrentPosition;
                    USHORT AddSeparator;
                    ULONG FullNameLengthTemp;

                    if ((FileObjectName->Length == 0) ||
                        (RelatedCcb->FullFileName.Length == 2) ||
                        (FileObjectName->Buffer[0] == L':')) {

                        AddSeparator = 0;

                    } else {

                        AddSeparator = sizeof( WCHAR );
                    }

                    ExactCaseOffset = RelatedCcb->FullFileName.Length + AddSeparator;

                    FullNameLengthTemp = (ULONG) RelatedCcb->FullFileName.Length + AddSeparator + FileObjectName->Length;

                    //
                    // A crude test to see if the total length exceeds a ushort.
                    //

                    if ((FullNameLengthTemp & 0xffff0000L) != 0) {

                        try_return( Status = STATUS_OBJECT_NAME_INVALID );
                    }

                    FullFileName->MaximumLength =
                    FullFileName->Length = (USHORT) FullNameLengthTemp;

                    //
                    //  We need to allocate a name buffer.
                    //

                    FullFileName->Buffer = FsRtlAllocatePoolWithTag(PagedPool, FullFileName->Length, MODULE_POOL_TAG);

                    CurrentPosition = (WCHAR *) FullFileName->Buffer;

                    RtlCopyMemory( CurrentPosition,
                                   RelatedCcb->FullFileName.Buffer,
                                   RelatedCcb->FullFileName.Length );

                    CurrentPosition = (WCHAR *) Add2Ptr( CurrentPosition, RelatedCcb->FullFileName.Length );

                    if (AddSeparator != 0) {

                        *CurrentPosition = L'\\';

                        CurrentPosition += 1;
                    }

                    if (FileObjectName->Length != 0) {

                        RtlCopyMemory( CurrentPosition,
                                       FileObjectName->Buffer,
                                       FileObjectName->Length );
                    }

                    //
                    //  If the user specified a case sensitive comparison, then the
                    //  case insensitive index is the full length of the resulting
                    //  string.  Otherwise it is the length of the string in
                    //  the related file object.  We adjust for the case when the
                    //  original file name length is zero.
                    //

                    if (!FlagOn( CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

                        CaseInsensitiveIndex = FullFileName->Length;

                    } else {

                        CaseInsensitiveIndex = RelatedCcb->FullFileName.Length +
                                               AddSeparator;
                    }

                //
                //  The entire name is in the FileObjectName.  We check the buffer for
                //  validity.
                //

                } else {

                    //
                    //  We look at the name string for detectable errors.  The
                    //  length must be non-zero and the first character must be
                    //  '\'
                    //

                    if (FileObjectName->Length == 0) {

                        DebugTrace( 0, Dbg, ("There is no name to open\n") );
                        try_return( Status = STATUS_OBJECT_PATH_NOT_FOUND );
                    }

                    if (FileObjectName->Buffer[0] != L'\\') {

                        DebugTrace( 0, Dbg, ("Name does not begin with a backslash\n") );
                        try_return( Status = STATUS_INVALID_PARAMETER );
                    }

                    //
                    //  If the user specified a case sensitive comparison, then the
                    //  case insensitive index is the full length of the resulting
                    //  string.  Otherwise it is zero.
                    //

                    if (!FlagOn( CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

                        CaseInsensitiveIndex = FullFileName->Length;

                    } else {

                        CaseInsensitiveIndex = 0;
                    }
                }

            } else if (FlagOn( CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

                CaseInsensitiveIndex = 0;

            } else {

                CaseInsensitiveIndex = FullFileName->Length;
            }

            //
            //  The remaining name is stored in the FullFileName variable.
            //  If we are doing a case-insensitive operation and have to
            //  upcase part of the remaining name then allocate a buffer
            //  now.  No need to allocate a buffer if we already allocated
            //  a new buffer for the full file name.
            //

            if (FlagOn( CreateFlags, CREATE_FLAG_IGNORE_CASE ) &&
                (CaseInsensitiveIndex < FullFileName->Length)) {

                UNICODE_STRING StringToUpcase;

                //
                //  Original file name and full file name better have the same buffer or there
                //  should be a related file object.  If there is already an allocated
                //  buffer for the ExactCaseName then it should already be big enough for us.
                //

                ASSERT( (RelatedFileObject != NULL) ||
                        (FullFileName->Buffer == OriginalFileName->Buffer) );

                //
                //  If there is a related name then we can use the original buffer
                //  unless the full name is using the same buffer.
                //

                if (OriginalFileName->Buffer != FullFileName->Buffer) {

                    //
                    //  We might have already used the original buffer for the case
                    //  where we are retrying the request.
                    //

                    ASSERT( (ExactCaseName->Buffer == NULL) ||
                            (ExactCaseName->Buffer == OriginalFileName->Buffer) );

                    ExactCaseName->Buffer = OriginalFileName->Buffer;

                    //
                    //  MaximumLength includes any stream descriptors.
                    //  Length is limited to the Length in the FullName.
                    //

                    ExactCaseName->MaximumLength = OriginalFileName->Length;
                    ExactCaseName->Length = FullFileName->Length - ExactCaseOffset;
                    ASSERT( FullFileName->Length >= ExactCaseOffset );

                //
                //  We need to store the exact case name away.
                //

                } else {

                    //
                    //  Allocate a buffer if we don't already have one.
                    //

                    ExactCaseName->MaximumLength = OriginalFileName->Length;

                    if (ExactCaseName->Buffer == NULL) {

                        ExactCaseName->Buffer = FsRtlAllocatePoolWithTag( PagedPool,
                                                                          OriginalFileName->MaximumLength,
                                                                          MODULE_POOL_TAG );
                    }

                    RtlCopyMemory( ExactCaseName->Buffer,
                                   FullFileName->Buffer,
                                   FullFileName->MaximumLength );

                    ExactCaseName->Length = FullFileName->Length - ExactCaseOffset;
                    ASSERT( FullFileName->Length >= ExactCaseOffset );
                }

                //
                //  Upcase the file name portion of the full name.
                //

                StringToUpcase.Buffer = Add2Ptr( FullFileName->Buffer,
                                                 CaseInsensitiveIndex );

                StringToUpcase.Length =
                StringToUpcase.MaximumLength = FullFileName->Length - (USHORT) CaseInsensitiveIndex;

                NtfsUpcaseName( Vcb->UpcaseTable, Vcb->UpcaseTableSize, &StringToUpcase );
            }

            RemainingName = *FullFileName;

            //
            //  Make it plain we don't have any hash values.
            //

            CreateContext.FileHashLength = CreateContext.ParentHashLength = 0;

            //
            //  If this is the traverse access case or the open by file id case we start
            //  relative to the file object we have or the root directory.
            //  This is also true for the case where the file name in the file object is
            //  empty.
            //

            if ((FileObjectName->Length == 0) ||
                (FlagOn( CreateFlags, CREATE_FLAG_TRAVERSE_CHECK ) &&
                 (FileObjectName->Buffer[0] != L':'))) {

                //
                //  We should already have the parent exclusive if we hit this path.
                //

                ASSERT( !FlagOn( CreateFlags, CREATE_FLAG_SHARED_PARENT_FCB ) );

                if (RelatedFileObject != NULL) {

                    CurrentLcb = RelatedCcb->Lcb;
                    CurrentScb = RelatedScb;

                    if (FileObjectName->Length == 0) {

                        RemainingName.Length = 0;

                    } else if (!FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID )) {

                        USHORT Increment;

                        Increment = RelatedCcb->FullFileName.Length
                                    + (RelatedCcb->FullFileName.Length == 2
                                       ? 0
                                       : 2);

                        RemainingName.Buffer = (WCHAR *) Add2Ptr( RemainingName.Buffer,
                                                                  Increment );

                        RemainingName.Length -= Increment;
                    }

                } else {

                    CurrentLcb = Vcb->RootLcb;
                    CurrentScb = Vcb->RootIndexScb;

                    RemainingName.Buffer = (WCHAR *) Add2Ptr( RemainingName.Buffer, sizeof( WCHAR ));
                    RemainingName.Length -= sizeof( WCHAR );
                }

            //
            //  Otherwise we will try a prefix lookup.
            //

            } else {

                if (RelatedFileObject != NULL) {

                    if (!FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID )) {

                        //
                        //  Skip over the characters in the related file object.
                        //

                        RemainingName.Buffer = (WCHAR *) Add2Ptr( RemainingName.Buffer,
                                                                  RelatedCcb->FullFileName.Length );
                        RemainingName.Length -= RelatedCcb->FullFileName.Length;

                        //
                        //  Step over the backslash if present.
                        //

                        if ((RemainingName.Length != 0) &&
                            (RemainingName.Buffer[0] == L'\\')) {

                            RemainingName.Buffer += 1;
                            RemainingName.Length -= sizeof( WCHAR );
                        }
                    }

                    CurrentLcb = RelatedCcb->Lcb;
                    CurrentScb = RelatedScb;

                } else {

                    CurrentLcb = Vcb->RootLcb;
                    CurrentScb = Vcb->RootIndexScb;

                    //
                    //  Skip over the lead-in '\' character.
                    //

                    RemainingName.Buffer = (WCHAR *) Add2Ptr( RemainingName.Buffer,
                                                              sizeof( WCHAR ));
                    RemainingName.Length -= sizeof( WCHAR );
                }

                LcbForTeardown = NULL;

                //
                //  If we don't have the starting Scb exclusively then let's try for
                //  a hash hit first.
                //

                if (FlagOn( CreateFlags, CREATE_FLAG_SHARED_PARENT_FCB )) {

                    NextLcb = NtfsFindPrefixHashEntry( IrpContext,
                                                       &Vcb->HashTable,
                                                       CurrentScb,
                                                       &CreateFlags,
                                                       &CurrentFcb,
                                                       &CreateContext.FileHashValue,
                                                       &CreateContext.FileHashLength,
                                                       &CreateContext.ParentHashValue,
                                                       &CreateContext.ParentHashLength,
                                                       &RemainingName );

                    //
                    //  If we didn't get an Lcb then release the starting Scb
                    //  and reacquire exclusively.
                    //

                    if (NextLcb == NULL) {

                        NtfsReleaseFcbWithPaging( IrpContext, CurrentFcb );
                        NtfsAcquireFcbWithPaging( IrpContext, CurrentFcb, 0 );

                    } else {

                        //
                        //  Remember the Lcb we found.  If there is still a
                        //  portion of the name remaining then check if there
                        //  is an existing $INDEX_ALLOCATION scb on the file.
                        //  It is possible that we aren't even at a directory
                        //  in the reparse case.
                        //

                        CurrentLcb = NextLcb;

                        //
                        //  We have progressed parsing the name. Mark it as one that needs to be inspected
                        //  for possible reparse behavior.
                        //

                        SetFlag( CreateFlags, CREATE_FLAG_INSPECT_NAME_FOR_REPARSE );

                        if (RemainingName.Length != 0) {

                            CurrentScb = NtfsCreateScb( IrpContext,
                                                        CurrentFcb,
                                                        $INDEX_ALLOCATION,
                                                        &NtfsFileNameIndex,
                                                        TRUE,
                                                        NULL );
                        }
                    }

                    //
                    //  In both cases here we own the Fcb exclusive.
                    //

                    ClearFlag( CreateFlags, CREATE_FLAG_SHARED_PARENT_FCB );
#ifdef NTFS_HASH_DATA
                } else {
                    Vcb->HashTable.SkipHashLookupCount += 1;
#endif
                }

                if ((RemainingName.Length != 0) &&
                    (CurrentScb != NULL)) {

                    NextLcb = NtfsFindPrefix( IrpContext,
                                              CurrentScb,
                                              &CurrentFcb,
                                              &LcbForTeardown,
                                              RemainingName,
                                              &CreateFlags,
                                              &RemainingName );
                }

                //
                //  If we found another link then update the CurrentLcb value.
                //

                if (NextLcb != NULL) {

                    CurrentLcb = NextLcb;

                    //
                    //  We have progressed parsing the name. Mark it as one that needs to be inspected
                    //  for possible reparse behavior.
                    //

                    SetFlag( CreateFlags, CREATE_FLAG_INSPECT_NAME_FOR_REPARSE );
                }
            }

            if ((RemainingName.Length == 0) || !FlagOn( CreateFlags, CREATE_FLAG_FIRST_PASS )) {

                break;
            }

            //
            //  If we get here, it means that this is the first pass and we didn't
            //  have a prefix match.  If there is a colon in the
            //  remaining name, then we need to analyze the name in more detail.
            //

            ComplexName = FALSE;

            for (Index = (RemainingName.Length / sizeof( WCHAR )) - 1, ComplexName = FALSE;
                 Index >= 0;
                 Index -= 1) {

                if (RemainingName.Buffer[Index] == L':') {

                    ComplexName = TRUE;
                    break;
                }
            }

            if (!ComplexName) {

                break;
            }

            ClearFlag( CreateFlags, CREATE_FLAG_FIRST_PASS);

            //
            //  Copy the exact name back to the full name.  In this case we want to
            //  restore the entire name including stream descriptors.
            //

            if (ExactCaseName->Buffer != NULL) {

                ASSERT( ExactCaseName->Length != 0 );
                ASSERT( FullFileName->MaximumLength >= ExactCaseName->Length );

                RtlCopyMemory( Add2Ptr( FullFileName->Buffer, ExactCaseOffset ),
                               ExactCaseName->Buffer,
                               ExactCaseName->MaximumLength );

                //
                //  Save the buffer for now but set the lengths to zero as a
                //  flag to indicate that we have already copied the data back.
                //

                ExactCaseName->Length = ExactCaseName->MaximumLength = 0;
            }

            //
            //  Let's release the Fcb we have currently acquired.
            //

            NtfsReleaseFcbWithPaging( IrpContext, CurrentFcb );
            LcbForTeardown = NULL;
        }

        //
        //  Check if the link or the Fcb is pending delete.
        //

        if (((CurrentLcb != NULL) && LcbLinkIsDeleted( CurrentLcb )) ||
            CurrentFcb->LinkCount == 0) {

            try_return( Status = STATUS_DELETE_PENDING );
        }

        //
        //  Put the new name into the file object.
        //

        OplockCleanup->FileObject->FileName = *FullFileName;

        //
        //  If the entire path was parsed, then we have access to the Fcb to
        //  open.  We either open the parent of the prefix match or the prefix
        //  match itself, depending on whether the user wanted to open
        //  the target directory.
        //

        if (RemainingName.Length == 0) {

            //
            //  Check the attribute name length.
            //

            if (AttrName.Length > (NTFS_MAX_ATTR_NAME_LEN * sizeof( WCHAR ))) {

                try_return( Status = STATUS_OBJECT_NAME_INVALID );
            }

            //
            //  If this is a target directory we check that the open is for the
            //  entire file.
            //  We assume that the final component can only have an attribute
            //  which corresponds to the type of file this is.  Meaning
            //  $INDEX_ALLOCATION for directory, $DATA (unnamed) for a file.
            //  We verify that the matching Lcb is not the root Lcb.
            //

            if (FlagOn( IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY )) {

                if (CurrentLcb == Vcb->RootLcb) {

                    DebugTrace( 0, Dbg, ("Can't open parent of root\n") );
                    try_return( Status = STATUS_INVALID_PARAMETER );
                }

                //
                //  We don't allow attribute names or attribute codes to
                //  be specified.
                //

                if (AttrName.Length != 0
                    || AttrCodeName.Length != 0) {

                    DebugTrace( 0, Dbg, ("Can't specify complex name for rename\n") );
                    try_return( Status = STATUS_OBJECT_NAME_INVALID );
                }

                //
                //  When SL_OPEN_TARGET_DIRECTORY is set, the directory should not be opened
                //  as a reparse point; FILE_OPEN_REPARSE_POINT should not be set.
                //

                if (FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_REPARSE_POINT )) {

                   //
                   //  Wrong open flag, invalid parameter.
                   //

                   DebugTrace( 0, Dbg, ("Can't open intermediate directory as reparse point 1.\n") );
                   Status = STATUS_INVALID_PARAMETER;
                   try_return( Status );
                }

                //
                //  We want to copy the exact case of the name back into the
                //  input buffer for this case.
                //

                if (ExactCaseName->Buffer != NULL) {

                    ASSERT( ExactCaseName->Length != 0 );
                    ASSERT( FullFileName->MaximumLength >= ExactCaseName->Length + ExactCaseOffset );

                    RtlCopyMemory( Add2Ptr( FullFileName->Buffer, ExactCaseOffset ),
                                   ExactCaseName->Buffer,
                                   ExactCaseName->MaximumLength );
                }

                //
                //  Acquire the parent of the last Fcb.  This is the actual file we
                //  are opening.
                //

                ParentFcb = CurrentLcb->Scb->Fcb;
                NtfsAcquireFcbWithPaging( IrpContext, ParentFcb, 0 );

                //
                //  Call our open target directory, remembering the target
                //  file existed.
                //

                SetFlag( CreateFlags, CREATE_FLAG_FOUND_ENTRY );

                Status = NtfsOpenTargetDirectory( IrpContext,
                                                  Irp,
                                                  IrpSp,
                                                  ParentFcb,
                                                  NULL,
                                                  &OplockCleanup->FileObject->FileName,
                                                  CurrentLcb->ExactCaseLink.LinkName.Length,
                                                  CreateFlags,
                                                  &ThisScb,
                                                  &ThisCcb );

                try_return( NOTHING );
            }

            //
            //  Otherwise we simply attempt to open the Fcb we matched.
            //

            if (FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID )) {

                Status = NtfsOpenFcbById( IrpContext,
                                          Irp,
                                          IrpSp,
                                          Vcb,
                                          CurrentLcb,
                                          &CurrentFcb,
                                          TRUE,
                                          CurrentFcb->FileReference,
                                          AttrName,
                                          AttrCodeName,
                                          NetworkInfo,
                                          &ThisScb,
                                          &ThisCcb );

                //
                //  If the status is pending, the irp or the file object may have gone
                //  away already.
                //

                if (Status != STATUS_PENDING) {

                    //
                    //  There should be no need to set TraverseAccessCheck now, it should
                    //  already be set correctly.
                    //

                    ASSERT( (!FlagOn( CreateFlags, CREATE_FLAG_TRAVERSE_CHECK ) &&
                             FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->Flags, TOKEN_HAS_TRAVERSE_PRIVILEGE )) ||

                            (FlagOn( CreateFlags, CREATE_FLAG_TRAVERSE_CHECK ) &&
                             !FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->Flags, TOKEN_HAS_TRAVERSE_PRIVILEGE )) );

                    //
                    //  Set the maximum length in the file object name to
                    //  zero so we know that this is not a full name.
                    //

                    OplockCleanup->FileObject->FileName.MaximumLength = 0;
                }

            } else {

                //
                //  The current Fcb is acquired.
                //

                Status = NtfsOpenExistingPrefixFcb( IrpContext,
                                                    Irp,
                                                    IrpSp,
                                                    CurrentFcb,
                                                    CurrentLcb,
                                                    FullFileName->Length,
                                                    AttrName,
                                                    AttrCodeName,
                                                    CreateFlags,
                                                    NetworkInfo,
                                                    &CreateContext,
                                                    &ThisScb,
                                                    &ThisCcb );
            }

            try_return( NOTHING );
        }

        //
        //  Check if the current Lcb is a Dos-Only Name.
        //

        if ((CurrentLcb != NULL) &&
            (CurrentLcb->FileNameAttr->Flags == FILE_NAME_DOS)) {

            SetFlag( CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT );
        }

        //
        //  We have a remaining portion of the file name which was unmatched in the
        //  prefix table.  We walk through these name components until we reach the
        //  last element.  If necessary, we add Fcb and Scb's into the graph as we
        //  walk through the names.
        //

        SetFlag( CreateFlags, CREATE_FLAG_FIRST_PASS);

        while (TRUE) {

            PFILE_NAME IndexFileName;

            //
            //  We check to see whether we need to inspect this name for possible reparse behavior
            //  and whether the CurrentFcb is a reparse point.
            //  Notice that if a directory is a reparse point, there should be no
            //  prefix match possible in NtfsFindPrefix beyond the directory name,
            //  as longer matches could bypass a reparse point.
            //

            if (FlagOn( CreateFlags, CREATE_FLAG_INSPECT_NAME_FOR_REPARSE ) &&
                FlagOn( CurrentFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

                USHORT AttributeNameLength = 0;

                //
                //  Traverse access is done before accessing the disk.
                //  For a directory we check for traverse access.
                //  For a file we check for read access.
                //

                if (FlagOn( CreateFlags, CREATE_FLAG_TRAVERSE_CHECK )) {

                    if (IsDirectory( &CurrentFcb->Info )) {

                        NtfsTraverseCheck( IrpContext,
                                           CurrentFcb,
                                           Irp );
                    } else {

                        NtfsAccessCheck ( IrpContext,
                                          CurrentFcb,
                                          NULL,
                                          Irp,
                                          FILE_GENERIC_READ,
                                          TRUE );
                    }
                }

                //
                //  Middle-of-name reparse point call.
                //  Notice that the FILE_OPEN_REPARSE_POINT flag only alters the behavior of
                //  a final element of a named path, not the intermediate components.
                //  Notice further that we need this check here prior to the directory check
                //  below as it is legal to have an intermediate name that is a file
                //  containing a symbolic link.
                //

                //
                //  When NetworkInfo is present, we are in the fast-I/O path to retrieve
                //  the attributes of a target file. The fast path does not process retries
                //  due to reparse points. We return indicating that a reparse point has
                //  been encountered without returning the reparse point data.
                //

                if (ARGUMENT_PRESENT( NetworkInfo )) {

                    DebugTrace( 0, Dbg, ("Reparse point encountered with NetworkInfo present.\n") );
                    Status = STATUS_REPARSE;

                    try_return( Status );
                }

                //
                //  We account for the byte size of the attribute name delimiter : (colon)
                //  in unicode.
                //  If the name of the code or type of the attribute has been passed on explicitly,
                //  like $DATA or $INDEX_ALLOCATION, we also account for it.
                //
                //  Notice that the code below ignores the case when no attribute name has been specified
                //  yet the name of its code, or type, has been specified.
                //

                ASSERT( OplockCleanup->AttributeNameLength == AttrName.Length );
                if (OplockCleanup->AttributeNameLength > 0) {

                    AttributeNameLength += OplockCleanup->AttributeNameLength + 2;
                }
                if (OplockCleanup->AttributeCodeNameLength > 0) {

                    AttributeNameLength += OplockCleanup->AttributeCodeNameLength + 2;
                }
                if (RemainingName.Length > 0) {

                    //
                    // Account for the backslash delimeter.
                    //

                    AttributeNameLength += 2;
                }

                DebugTrace( 0, Dbg, ("RemainingName.Length = %d OplockCleanup->AttributeNameLength = %d OplockCleanup->AttributeCodeNameLength = %d AttributeNameLength = %d sum = %d\n",
                            RemainingName.Length, OplockCleanup->AttributeNameLength, OplockCleanup->AttributeCodeNameLength, AttributeNameLength, (RemainingName.Length + AttributeNameLength)) );

                Status = NtfsGetReparsePointValue( IrpContext,
                                                   Irp,
                                                   IrpSp,
                                                   CurrentFcb,
                                                   (USHORT)(RemainingName.Length + AttributeNameLength) );

                try_return( Status );
            }

            //
            //  We check that the last Fcb we have is in fact a directory.
            //

            if (!IsDirectory( &CurrentFcb->Info )) {

                DebugTrace( 0, Dbg, ("Intermediate node is not a directory\n") );
                try_return( Status = STATUS_OBJECT_PATH_NOT_FOUND );
            }

            //
            //  We dissect the name into the next component and the remaining name string.
            //  We don't need to check for a valid name if we examined the name already.
            //

            NtfsDissectName( RemainingName,
                             &FinalName,
                             &RemainingName );

            DebugTrace( 0, Dbg, ("Final name     -> %Z\n", &FinalName) );
            DebugTrace( 0, Dbg, ("Remaining Name -> %Z\n", &RemainingName) );

            //
            //  If the final name is too long then either the path or the
            //  name is invalid.
            //

            if (FinalName.Length > (NTFS_MAX_FILE_NAME_LENGTH * sizeof( WCHAR ))) {

                if (RemainingName.Length == 0) {

                    try_return( Status = STATUS_OBJECT_NAME_INVALID );

                } else {

                    try_return( Status = STATUS_OBJECT_PATH_NOT_FOUND );
                }
            }

            //
            //  Catch single dot names (.) before scanning the index.  We don't
            //  want to allow someone to open the self entry in the root.
            //

            if ((FinalName.Length == 2) &&
                (FinalName.Buffer[0] == L'.')) {

                if (RemainingName.Length != 0) {

                    DebugTrace( 0, Dbg, ("Intermediate component in path doesn't exist\n") );
                    try_return( Status = STATUS_OBJECT_PATH_NOT_FOUND );

                //
                //  If the final component is illegal, then return the appropriate error.
                //

                } else {

                    try_return( Status = STATUS_OBJECT_NAME_INVALID );
                }
            }

            //
            //  Get the index allocation Scb for the current Fcb.
            //

            //
            //  We need to look for the next component in the name string in the directory
            //  we've reached.  We need to get a Scb to perform the index search.
            //  To do the search we need to build a filename attribute to perform the
            //  search with and then call the index package to perform the search.
            //

            CurrentScb = NtfsCreateScb( IrpContext,
                                        CurrentFcb,
                                        $INDEX_ALLOCATION,
                                        &NtfsFileNameIndex,
                                        FALSE,
                                        NULL );

            //
            //  If the CurrentScb does not have its normalized name and we have a valid
            //  parent, then update the normalized name.
            //

            if ((LastScb != NULL) &&
                (CurrentScb->ScbType.Index.NormalizedName.Length == 0) &&
                (LastScb->ScbType.Index.NormalizedName.Length != 0)) {

                NtfsUpdateNormalizedName( IrpContext, LastScb, CurrentScb, IndexFileName, FALSE );

            }

            //
            //  Release the parent Scb if we own it.
            //

            if (!FlagOn( CreateFlags, CREATE_FLAG_FIRST_PASS )) {

                NtfsReleaseFcbWithPaging( IrpContext, ParentFcb );
            }

            LastScb = CurrentScb;

            //
            //  If traverse access is required, we do so now before accessing the
            //  disk.
            //

            if (FlagOn( CreateFlags, CREATE_FLAG_TRAVERSE_CHECK )) {

                NtfsTraverseCheck( IrpContext,
                                   CurrentFcb,
                                   Irp );
            }

            //
            //  Look on the disk to see if we can find the last component on the path.
            //

            NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

            //
            //  Check that the name is valid before scanning the disk.
            //

            if (FlagOn( CreateFlags, CREATE_FLAG_CHECK_FOR_VALID_NAME ) &&
                !NtfsIsFileNameValid( &FinalName, FALSE )) {

                DebugTrace( 0, Dbg, ("Component name is invalid\n") );
                try_return( Status = STATUS_OBJECT_NAME_INVALID );
            }

            //
            //  Initialize or reinitialize the context as necessary.
            //

            if (IndexContext != NULL) {

                NtfsReinitializeIndexContext( IrpContext, IndexContext );

            } else {

#if defined(_WIN64)
                IndexContext = &IndexContextStruct;
#else
                IndexContext = NtfsAllocateFromStack( sizeof( INDEX_CONTEXT ));
#endif
                NtfsInitializeIndexContext( IndexContext );
            }

            if (NtfsLookupEntry( IrpContext,
                                 CurrentScb,
                                 BooleanFlagOn( CreateFlags, CREATE_FLAG_IGNORE_CASE ),
                                 &FinalName,
                                 &FileNameAttr,
                                 &FileNameAttrLength,
                                 &QuickIndex,
                                 &IndexEntry,
                                 &IndexEntryBcb,
                                 IndexContext )) {

                SetFlag( CreateFlags, CREATE_FLAG_FOUND_ENTRY );
            } else {
                ClearFlag( CreateFlags, CREATE_FLAG_FOUND_ENTRY );
            }

            //
            //  This call to NtfsLookupEntry may decide to push the root index.
            //  Create needs to free resources as it walks down the tree to prevent
            //  deadlocks.  If there is a transaction, commit it now so we will be
            //  able to free this resource.
            //

            if (IrpContext->TransactionId != 0) {

                NtfsCheckpointCurrentTransaction( IrpContext );

                //
                //  Go through and free any Scb's in the queue of shared
                //  Scb's for transactions.
                //

                if (IrpContext->SharedScb != NULL) {
                    NtfsReleaseSharedResources( IrpContext );
                    ASSERT( IrpContext->SharedScb == NULL );
                }

                //
                // Release the MftScb, if we acquired it in pushing the root index.
                //

                NtfsReleaseExclusiveScbIfOwned( IrpContext, Vcb->MftScb );
            }

            if (FlagOn( CreateFlags, CREATE_FLAG_FOUND_ENTRY )) {

                ASSERT( !FlagOn( CurrentFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT ) );

                //
                //  Get the file name attribute so we can get the name out of it.
                //

                IndexFileName = (PFILE_NAME) NtfsFoundIndexEntry( IndexEntry );

                if (FlagOn( CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

                    RtlCopyMemory( FinalName.Buffer,
                                   IndexFileName->FileName,
                                   FinalName.Length );
                }
            }

            //
            //  If we didn't find a matching entry in the index, we need to check if the
            //  name is illegal or simply isn't present on the disk.
            //

            if (!FlagOn( CreateFlags, CREATE_FLAG_FOUND_ENTRY )) {

                if (RemainingName.Length != 0) {

                    DebugTrace( 0, Dbg, ("Intermediate component in path doesn't exist\n") );
                    try_return( Status = STATUS_OBJECT_PATH_NOT_FOUND );
                }

                //
                //  We also need to fail when we have a reparse point. We do not allow the
                //  creation of subdirectories of a directory that is a reparse point.
                //

                if (FlagOn( CurrentFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

                    DebugTrace( 0, Dbg, ("For reparse points subdirectories are not allowed.\n") );
                    try_return( Status = STATUS_DIRECTORY_IS_A_REPARSE_POINT );
                }

                //
                //  Now copy the exact case of the name specified by the user back
                //  in the file name buffer and file name attribute in order to
                //  create the name.
                //

                if (FlagOn( CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

                    ASSERT( ExactCaseName->Length != 0 );
                    ASSERT( FullFileName->Length >= ExactCaseName->Length + ExactCaseOffset );

                    RtlCopyMemory( FinalName.Buffer,
                                   Add2Ptr( ExactCaseName->Buffer,
                                            ExactCaseName->Length - FinalName.Length ),
                                   FinalName.Length );

                    RtlCopyMemory( FileNameAttr->FileName,
                                   Add2Ptr( ExactCaseName->Buffer,
                                            ExactCaseName->Length - FinalName.Length ),
                                   FinalName.Length );
                }
            }

            //
            //  If we're at the last component in the path, then this is the file
            //  to open or create
            //

            if (RemainingName.Length == 0) {

                break;
            }

            //
            //  Otherwise we create an Fcb for the subdirectory and the link between
            //  it and its parent Scb.
            //

            //
            //  Discard any mapping information we have for the parent.
            //

            NtfsRemoveFromFileRecordCache( IrpContext,
                                           NtfsSegmentNumber( &CurrentScb->Fcb->FileReference ));

            //
            //  Remember that the current values will become the parent values.
            //

            ParentFcb = CurrentFcb;

            CurrentLcb = NtfsOpenSubdirectory( IrpContext,
                                               CurrentScb,
                                               FinalName,
                                               CreateFlags,
                                               &CurrentFcb,
                                               &LcbForTeardown,
                                               IndexEntry );

            //
            //  Check that this link is a valid existing link.
            //

            if (LcbLinkIsDeleted( CurrentLcb ) ||
                CurrentFcb->LinkCount == 0) {

                try_return( Status = STATUS_DELETE_PENDING );
            }

            //
            //  We have progressed parsing the name. Mark it as one that needs to be inspected
            //  for possible reparse behavior.
            //

            SetFlag( CreateFlags, CREATE_FLAG_INSPECT_NAME_FOR_REPARSE );

            //
            //  Go ahead and insert this link into the splay tree if it is not
            //  a system file.
            //

            if (!FlagOn( CurrentLcb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

                //
                //  See if we can insert the hash for the parent.
                //

                if ((CreateContext.ParentHashLength != 0) &&
                    (RemainingName.Length == CreateContext.FileHashLength - CreateContext.ParentHashLength - sizeof( WCHAR )) &&
                    !FlagOn( CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT ) &&
                    (CurrentLcb->FileNameAttr->Flags != FILE_NAME_DOS)) {

                    //
                    //  Remove any exising hash value.
                    //

                    if (FlagOn( CurrentLcb->LcbState, LCB_STATE_VALID_HASH_VALUE )) {

                        NtfsRemoveHashEntriesForLcb( CurrentLcb );
#ifdef NTFS_HASH_DATA
                        Vcb->HashTable.ParentConflict += 1;
#endif
                    }

                    NtfsInsertHashEntry( &Vcb->HashTable,
                                         CurrentLcb,
                                         CreateContext.ParentHashLength,
                                         CreateContext.ParentHashValue );
#ifdef NTFS_HASH_DATA
                    Vcb->HashTable.ParentInsert += 1;
#endif
                }

                NtfsInsertPrefix( CurrentLcb, CreateFlags );
            }

            //
            //  Since we have the location of this entry store the information into
            //  the Lcb.
            //

            RtlCopyMemory( &CurrentLcb->QuickIndex,
                           &QuickIndex,
                           sizeof( QUICK_INDEX ));

            //
            //  Check if the current Lcb is a Dos-Only Name.
            //

            if (CurrentLcb->FileNameAttr->Flags == FILE_NAME_DOS) {
                SetFlag( CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT );
            }

            ClearFlag( CreateFlags, CREATE_FLAG_FIRST_PASS);
        }

        //
        //  We now have the parent of the file to open and know whether the file exists on
        //  the disk.  At this point we either attempt to open the target directory or
        //  the file itself.
        //

        if (FlagOn( IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY )) {

            ASSERT( IndexContext != NULL );

            NtfsCleanupIndexContext( IrpContext, IndexContext );
            IndexContext = NULL;

            //
            //  We don't allow attribute names or attribute codes to
            //  be specified.
            //

            if (AttrName.Length != 0
                || AttrCodeName.Length != 0) {

                DebugTrace( 0, Dbg, ("Can't specify complex name for rename\n") );
                try_return( Status = STATUS_OBJECT_NAME_INVALID );
            }

            //
            //  When SL_OPEN_TARGET_DIRECTORY is set, the directory should not be opened
            //  as a reparse point; FILE_OPEN_REPARSE_POINT should not be set.
            //

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_REPARSE_POINT )) {

               //
               //  Wrong open flag, invalid parameter.
               //

               DebugTrace( 0, Dbg, ("Can't open intermediate directory as reparse point 2.\n") );
               Status = STATUS_INVALID_PARAMETER;
               try_return( Status );
            }

            //
            //  We want to copy the exact case of the name back into the
            //  input buffer for this case.
            //

            if (ExactCaseName->Buffer != NULL) {

                ASSERT( ExactCaseName->Length != 0 );
                ASSERT( FullFileName->MaximumLength >= ExactCaseName->MaximumLength + ExactCaseOffset );

                RtlCopyMemory( Add2Ptr( FullFileName->Buffer, ExactCaseOffset ),
                               ExactCaseName->Buffer,
                               ExactCaseName->MaximumLength );
            }

            //
            //  Call our open target directory, remembering the target
            //  file existed.
            //

            Status = NtfsOpenTargetDirectory( IrpContext,
                                              Irp,
                                              IrpSp,
                                              CurrentFcb,
                                              CurrentLcb,
                                              &OplockCleanup->FileObject->FileName,
                                              FinalName.Length,
                                              CreateFlags,
                                              &ThisScb,
                                              &ThisCcb );


            try_return( Status );
        }

        //
        //  If we didn't find an entry, we will try to create the file.
        //

        if (!FlagOn( CreateFlags, CREATE_FLAG_FOUND_ENTRY )) {

            //
            //  Update our pointers to reflect that we are at the
            //  parent of the file we want.
            //

            ParentFcb = CurrentFcb;

            //
            //  No point in going down the create path for a Network Query.
            //

            if (ARGUMENT_PRESENT( NetworkInfo )) {

                Status = STATUS_OBJECT_NAME_NOT_FOUND;

            } else {

                Status = NtfsCreateNewFile( IrpContext,
                                            Irp,
                                            IrpSp,
                                            CurrentScb,
                                            FileNameAttr,
                                            *FullFileName,
                                            FinalName,
                                            AttrName,
                                            AttrCodeName,
                                            CreateFlags,
                                            &IndexContext,
                                            &CreateContext,
                                            &CurrentFcb,
                                            &LcbForTeardown,
                                            &ThisScb,
                                            &ThisCcb );
            }

            SetFlag( CreateFlags, CREATE_FLAG_CREATE_FILE_CASE );

        //
        //  Otherwise we call our routine to open the file.
        //

        } else {

            ASSERT( IndexContext != NULL );

            NtfsCleanupIndexContext( IrpContext, IndexContext );
            IndexContext = NULL;

            ParentFcb = CurrentFcb;

            Status = NtfsOpenFile( IrpContext,
                                   Irp,
                                   IrpSp,
                                   CurrentScb,
                                   IndexEntry,
                                   *FullFileName,
                                   FinalName,
                                   AttrName,
                                   AttrCodeName,
                                   &QuickIndex,
                                   CreateFlags,
                                   NetworkInfo,
                                   &CreateContext,
                                   &CurrentFcb,
                                   &LcbForTeardown,
                                   &ThisScb,
                                   &ThisCcb );
        }

    try_exit:  NOTHING;

        //
        //  If we raise below then we need to back out any failed opens.
        //

        SetFlag( CreateFlags, CREATE_FLAG_BACKOUT_FAILED_OPENS );

        //
        //  Abort transaction on err by raising.
        //

        if (Status != STATUS_PENDING) {

            NtfsCleanupTransaction( IrpContext, Status, FALSE );
        }

    } finally {

        DebugUnwind( NtfsCommonCreate );

        //
        //  If we only have the current Fcb shared then simply give it up.
        //

        if (FlagOn( CreateFlags, CREATE_FLAG_SHARED_PARENT_FCB ) && (CurrentFcb != NULL)) {

            NtfsReleaseFcb( IrpContext, CurrentFcb );
            CurrentFcb = NULL;
        }

        //
        //  Unpin the index entry.
        //

        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        //
        //  Cleanup the index context if used.
        //

        if (IndexContext != NULL) {

            NtfsCleanupIndexContext( IrpContext, IndexContext );
        }

        //
        //  Free the file name attribute if we allocated it.
        //

        if (FileNameAttr != NULL) {

            NtfsFreePool( FileNameAttr );
        }

        //
        //  Capture the status code from the IrpContext if we are in the exception path.
        //

        if (AbnormalTermination()) {

            Status = IrpContext->ExceptionStatus;
        }

        //
        //  If this is the oplock completion path then don't do any of this completion work,
        //  The Irp may already have been posted to another thread.
        //

        if (Status != STATUS_PENDING) {

            //
            //  If we successfully opened the file, we need to update the in-memory
            //  structures.
            //

            if (NT_SUCCESS( Status ) && (Status != STATUS_REPARSE)) {

                //
                //  If the create completed, there's no reason why we shouldn't have
                //  a valid ThisScb now.
                //

                ASSERT( ThisScb != NULL );

                //
                //  If we modified the original file name, we can delete the original
                //  buffer.
                //

                if ((OriginalFileName->Buffer != NULL) &&
                    (OriginalFileName->Buffer != FullFileName->Buffer)) {

                    NtfsFreePool( OriginalFileName->Buffer );
                }

                //
                //  Do our normal processing if this is not a Network Info query.
                //

                if (!ARGUMENT_PRESENT( NetworkInfo )) {

                    //
                    //  Find the Lcb for this open.
                    //

                    CurrentLcb = ThisCcb->Lcb;

                    //
                    //  Check if we were opening a paging file and if so then make sure that
                    //  the internal attribute stream is all closed down
                    //

                    if (FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE )) {

                        NtfsDeleteInternalAttributeStream( ThisScb, TRUE, FALSE );
                    }

                    //
                    //  If we are not done with a large allocation for a new attribute,
                    //  then we must make sure that no one can open the file until we
                    //  try to get it extended.  Do this before dropping the Vcb.
                    //

                    if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_LARGE_ALLOCATION )) {

                        //
                        //  For a new file, we can clear the link count and mark the
                        //  Lcb (if there is one) delete on close.
                        //

                        if (FlagOn( CreateFlags, CREATE_FLAG_CREATE_FILE_CASE )) {

                            CurrentFcb->LinkCount = 0;

                            SetFlag( CurrentLcb->LcbState, LCB_STATE_DELETE_ON_CLOSE );

                        //
                        //  If we just created an attribute, then we will mark that attribute
                        //  delete on close to prevent it from being opened.
                        //

                        } else {

                            SetFlag( ThisScb->ScbState, SCB_STATE_DELETE_ON_CLOSE );
                        }
                    }

                    //
                    //  Remember the POSIX flag and whether we had to do any traverse
                    //  access checking.
                    //

                    if (FlagOn( CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

                        SetFlag( ThisCcb->Flags, CCB_FLAG_IGNORE_CASE );
                    }

                    //
                    //  Remember if this user needs to do traverse checks so we can show him the
                    //  name from the root.
                    //

                    if (FlagOn( CreateFlags, CREATE_FLAG_TRAVERSE_CHECK )) {

                        SetFlag( ThisCcb->Flags, CCB_FLAG_TRAVERSE_CHECK );
                    }

                    //
                    //  Remember who this user is so we know whether to allow
                    //  raw reads and writes of encrypted data.
                    //

                    {
                        PACCESS_STATE AccessState;
                        PRIVILEGE_SET PrivilegeSet;

                        AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

                        //
                        //  No flags should be preset
                        //

                        ASSERT( ThisCcb->AccessFlags == 0 );

                        //
                        //  This will set the READ_DATA_ACCESS, WRITE_DATA_ACCESS,
                        //  APPEND_DATA_ACCESS, and EXECUTE_ACCESS bits correctly.
                        //

                        SetFlag( ThisCcb->AccessFlags,
                                 FlagOn( AccessState->PreviouslyGrantedAccess, FILE_READ_DATA |
                                                                               FILE_WRITE_DATA |
                                                                               FILE_APPEND_DATA |
                                                                               FILE_EXECUTE |
                                                                               FILE_WRITE_ATTRIBUTES |
                                                                               FILE_READ_ATTRIBUTES ));

                        //
                        //  Here we're setting BACKUP_ACCESS and RESTORE_ACCESS.  We want to set
                        //  the Ccb flag if the user has the privilege AND they opened the file up
                        //  with an access that is interesting. For example backup or restore will give
                        //  you synchronize but if you open the file up only for that we don't want
                        //  to remember the privileges (its too ambiguous and you'll backup or restore
                        //  depending op whether you're local or remote))
                        //

                        if (FlagOn( AccessState->PreviouslyGrantedAccess, NTFS_REQUIRES_BACKUP ) &&
                            FlagOn( AccessState->Flags, TOKEN_HAS_BACKUP_PRIVILEGE )) {

                            SetFlag( ThisCcb->AccessFlags, BACKUP_ACCESS );
                        }

                        if (FlagOn( AccessState->PreviouslyGrantedAccess, NTFS_REQUIRES_RESTORE ) &&
                            FlagOn( AccessState->Flags, TOKEN_HAS_RESTORE_PRIVILEGE )) {

                            SetFlag( ThisCcb->AccessFlags, RESTORE_ACCESS );
                        }

                        PrivilegeSet.PrivilegeCount = 1;
                        PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
                        PrivilegeSet.Privilege[0].Luid = RtlConvertLongToLuid( SE_MANAGE_VOLUME_PRIVILEGE );
                        PrivilegeSet.Privilege[0].Attributes = 0;

                        if (SePrivilegeCheck( &PrivilegeSet,
                                              &AccessState->SubjectSecurityContext,
                                              Irp->RequestorMode )) {
                            SetFlag( ThisCcb->AccessFlags, MANAGE_VOLUME_ACCESS );
                        }
                    }

                    //
                    //  We don't do "delete on close" for directories or open
                    //  by ID files.
                    //

                    if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DELETE_ON_CLOSE ) &&
                        (!FlagOn( ThisCcb->Flags, CCB_FLAG_OPEN_BY_FILE_ID ) ||
                         !FlagOn( ThisCcb->Flags, CCB_FLAG_OPEN_AS_FILE ))) {

                        SetFlag( CreateFlags, CREATE_FLAG_DELETE_ON_CLOSE );

                        //
                        //  We modify the Scb and Lcb here only if we aren't in the
                        //  large allocation case.
                        //

                        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_LARGE_ALLOCATION )) {

                            SetFlag( ThisCcb->Flags, CCB_FLAG_DELETE_ON_CLOSE );
                        }
                    }

                    //
                    //  If this is a named stream open and we have set any of our notify
                    //  flags then report the changes.
                    //

                    if ((Vcb->NotifyCount != 0) &&
                        !FlagOn( ThisCcb->Flags, CCB_FLAG_OPEN_BY_FILE_ID ) &&
                        (ThisScb->AttributeName.Length != 0) &&
                        NtfsIsTypeCodeUserData( ThisScb->AttributeTypeCode ) &&
                        FlagOn( ThisScb->ScbState,
                                SCB_STATE_NOTIFY_ADD_STREAM |
                                SCB_STATE_NOTIFY_RESIZE_STREAM |
                                SCB_STATE_NOTIFY_MODIFY_STREAM )) {

                        ULONG Filter = 0;
                        ULONG Action;

                        //
                        //  Start by checking for an add.
                        //

                        if (FlagOn( ThisScb->ScbState, SCB_STATE_NOTIFY_ADD_STREAM )) {

                            Filter = FILE_NOTIFY_CHANGE_STREAM_NAME;
                            Action = FILE_ACTION_ADDED_STREAM;

                        } else {

                            //
                            //  Check if the file size changed.
                            //

                            if (FlagOn( ThisScb->ScbState, SCB_STATE_NOTIFY_RESIZE_STREAM )) {

                                Filter = FILE_NOTIFY_CHANGE_STREAM_SIZE;
                            }

                            //
                            //  Now check if the stream data was modified.
                            //

                            if (FlagOn( ThisScb->ScbState, SCB_STATE_NOTIFY_MODIFY_STREAM )) {

                                Filter |= FILE_NOTIFY_CHANGE_STREAM_WRITE;
                            }

                            Action = FILE_ACTION_MODIFIED_STREAM;
                        }

                        ASSERT( ThisScb && ThisCcb );
                        ASSERT( (ThisCcb->NodeTypeCode == NTFS_NTC_CCB_INDEX) || (ThisCcb->NodeTypeCode == NTFS_NTC_CCB_DATA) );

                        NtfsUnsafeReportDirNotify( IrpContext,
                                                   Vcb,
                                                   &ThisCcb->FullFileName,
                                                   ThisCcb->LastFileNameOffset,
                                                   &ThisScb->AttributeName,
                                                   ((FlagOn( ThisCcb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                                     (ThisCcb->Lcb != NULL) &&
                                                     (ThisCcb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                                    &ThisCcb->Lcb->Scb->ScbType.Index.NormalizedName :
                                                    NULL),
                                                   Filter,
                                                   Action,
                                                   NULL );
                    }

                    ClearFlag( ThisScb->ScbState,
                               SCB_STATE_NOTIFY_ADD_STREAM |
                               SCB_STATE_NOTIFY_REMOVE_STREAM |
                               SCB_STATE_NOTIFY_RESIZE_STREAM |
                               SCB_STATE_NOTIFY_MODIFY_STREAM );

                //
                //  Otherwise copy the data out of the Scb/Fcb and return to our caller.
                //

                } else {

                    NtfsFillNetworkOpenInfo( NetworkInfo, ThisScb );

                    //
                    //  Teardown the Fcb if we should. We're in a success path
                    //  here so we don't have to worry about aborting anymore and the
                    //  need to hold any resources
                    //

                    if (!ThisScb->CleanupCount && !ThisScb->Fcb->DelayedCloseCount) {
                        if (!NtfsAddScbToFspClose( IrpContext, ThisScb, TRUE )) {

                            if (NtfsIsExclusiveScb( Vcb->MftScb ) ||
                                (NtfsPerformQuotaOperation( CurrentFcb ) &&
                                 NtfsIsSharedScb( Vcb->QuotaTableScb ))) {

                                SetFlag( AcquireFlags, ACQUIRE_DONT_WAIT );
                            }

                            NtfsTeardownStructures( IrpContext,
                                                    CurrentFcb,
                                                    LcbForTeardown,
                                                    (BOOLEAN) (IrpContext->TransactionId != 0),
                                                    AcquireFlags,
                                                    NULL );
                        }
                    }

                    Irp->IoStatus.Information = sizeof( FILE_NETWORK_OPEN_INFORMATION );

                    Status = Irp->IoStatus.Status = STATUS_SUCCESS;
                }

            //
            //  Start a teardown on the last Fcb found and restore the name strings on
            //  a retryable error.
            //

            } else {

                //
                //  Perform the necessary cleanup if we raised writing a UsnJournal.
                //

                if (FlagOn( CreateFlags, CREATE_FLAG_BACKOUT_FAILED_OPENS )) {

                    NtfsBackoutFailedOpens( IrpContext, IrpSp->FileObject, CurrentFcb, ThisScb, ThisCcb );

                }

                //
                //  Start the cleanup process if we have looked at any Fcb's.
                //  We tell TeardownStructures not to remove any Scb's in
                //  the open attribute table if there is a transaction underway.
                //

                if (CurrentFcb != NULL) {

                    if (NtfsIsExclusiveScb( Vcb->MftScb ) ||
                        (NtfsPerformQuotaOperation( CurrentFcb ) &&
                         NtfsIsSharedScb( Vcb->QuotaTableScb ))) {

                        SetFlag( AcquireFlags, ACQUIRE_DONT_WAIT );
                    }

                    //
                    //  Someone may have tried to open the $Bitmap stream.  We catch that and
                    //  fail it but the Fcb won't be in the exclusive list to be released.
                    //

                    if (NtfsEqualMftRef( &CurrentFcb->FileReference, &BitmapFileReference )) {

                        NtfsReleaseFcb( IrpContext, CurrentFcb );

                    } else {

                        //
                        //  In transactions that don't own any system resources we must
                        //  make sure that we don't release all of the resources before
                        //  the transaction commits.  Otherwise we won't correctly serialize
                        //  with clean checkpoints who wants to know the transaction
                        //  table is empty.  Case in point is if we create the parent Scb
                        //  and file Fcb in this call and tear them down in Teardown below.
                        //  If there are no other resources held then we have an open
                        //  transaction but no serialization.
                        //
                        //  In general we can simply acquire a system resource and put it
                        //  in the exlusive list in the IrpContext.  The best choice is
                        //  the Mft.  HOWEVER there is a strange deadlock path if we
                        //  try to acquire this while owning the security mutext.  This
                        //  can happen in the CreateNewFile path if we are creating a
                        //  new security descriptor.  So we need to add this check
                        //  before we acquire the Mft, owning the security stream will
                        //  give us the transaction protection we need.
                        //
                        //  Possible future cleanup is to change how we acquire the security
                        //  file after the security mutex.  Ideally the security mutex would
                        //  be a true end resource.
                        //

                        if ((IrpContext->TransactionId != 0) &&
                            (CurrentFcb->CleanupCount == 0) &&
                            ((CreateDisposition == FILE_OVERWRITE_IF) ||
                             (CreateDisposition == FILE_OVERWRITE) ||
                             (CreateDisposition == FILE_SUPERSEDE)) &&
                            ((Vcb->SecurityDescriptorStream == NULL) ||
                             (!NtfsIsSharedScb( Vcb->SecurityDescriptorStream )))) {

                            NtfsAcquireExclusiveScb( IrpContext, Vcb->MftScb );
                            SetFlag( AcquireFlags, ACQUIRE_DONT_WAIT );
                        }

                        NtfsTeardownStructures( IrpContext,
                                                (ThisScb != NULL) ? (PVOID) ThisScb : CurrentFcb,
                                                LcbForTeardown,
                                                (BOOLEAN) (IrpContext->TransactionId != 0),
                                                AcquireFlags,
                                                NULL );
                    }
                }

                if ((Status == STATUS_LOG_FILE_FULL) ||
                    (Status == STATUS_CANT_WAIT) ||
                    (Status == STATUS_REPARSE)) {

                    //
                    //  Recover the exact case name if present for a retryable condition.
                    //  and we haven't already recopied it back (ExactCaseName->Length == 0)
                    //

                    if ((ExactCaseName->Buffer != OriginalFileName->Buffer) &&
                        (ExactCaseName->Buffer != NULL) &&
                        (ExactCaseName->Length != 0)) {

                        ASSERT( OriginalFileName->MaximumLength >= ExactCaseName->MaximumLength );

                        RtlCopyMemory( OriginalFileName->Buffer,
                                       ExactCaseName->Buffer,
                                       ExactCaseName->MaximumLength );
                    }

                    //
                    //  Restitute the access control state to what it was when we entered the request.
                    //

                    IrpSp->Parameters.Create.SecurityContext->AccessState->RemainingDesiredAccess = OplockCleanup->RemainingDesiredAccess;
                    IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess = OplockCleanup->PreviouslyGrantedAccess;
                    IrpSp->Parameters.Create.SecurityContext->DesiredAccess = OplockCleanup->DesiredAccess;
                }

                //
                //  Free any buffer we allocated.
                //

                if ((FullFileName->Buffer != NULL) &&
                    (OriginalFileName->Buffer != FullFileName->Buffer)) {

                    DebugTrace( 0, Dbg, ("FullFileName->Buffer will be de-allocated %x\n", FullFileName->Buffer) );
                    NtfsFreePool( FullFileName->Buffer );
                    DebugDoit( FullFileName->Buffer = NULL );
                }

                //
                //  Set the file name in the file object back to it's original value.
                //

                OplockCleanup->FileObject->FileName = *OriginalFileName;

                //
                //  Always clear the LARGE_ALLOCATION flag so we don't get
                //  spoofed by STATUS_REPARSE.
                //

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_LARGE_ALLOCATION );
            }
        }

        //
        //  Always free the exact case name if allocated and it doesn't match the original
        //  name buffer.
        //

        if ((ExactCaseName->Buffer != OriginalFileName->Buffer) &&
            (ExactCaseName->Buffer != NULL)) {

            DebugTrace( 0, Dbg, ("ExactCaseName->Buffer will be de-allocated %x\n", ExactCaseName->Buffer) );
            NtfsFreePool( ExactCaseName->Buffer );
            DebugDoit( ExactCaseName->Buffer = NULL );
        }

        //
        //  We always give up the Vcb.
        //

        if (FlagOn( CreateFlags, CREATE_FLAG_ACQUIRED_VCB )) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }
    }

    //
    //  If we didn't post this Irp then take action to complete the irp.
    //

    if (Status != STATUS_PENDING) {

        //
        //  If the current status is success and there is more allocation to
        //  allocate then complete the allocation.
        //

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_LARGE_ALLOCATION ) &&
            NT_SUCCESS( Status )) {

            //
            //  If the Create was successful, but we did not get all of the space
            //  allocated that we wanted, we have to complete the allocation now.
            //  Basically what we do is commit the current transaction and call
            //  NtfsAddAllocation to get the rest of the space.  Then if the log
            //  file fills up (or we are posting for other reasons) we turn the
            //  Irp into an Irp which is just trying to extend the file.  If we
            //  get any other kind of error, then we just delete the file and
            //  return with the error from create.
            //

            Status = NtfsCompleteLargeAllocation( IrpContext,
                                                  Irp,
                                                  CurrentLcb,
                                                  ThisScb,
                                                  ThisCcb,
                                                  CreateFlags );

//
//  **** TEMPCODE ****
//
//  The large allocation case is tricky.  The problem is that we don't
//  want to call the encryption driver to notify them of a create, and
//  then have the large allocation fail, since we don't have a good
//  way to call them back at this point to tell them the create failed.
//  Our normal cleanup callback passes them back their encryption
//  context, but in this case, we may not yet have their encryption
//  context stored in the scb, since they may not have created it yet.
//

#if 0
            //
            //  If we managed to do the large allocation, call the
            //  encryption driver if one is registered.
            //

            if ((NT_SUCCESS( Status ) && (Status != STATUS_REPARSE)) &&
                FlagOn( EncryptionFileDirFlags, FILE_DIR_TYPE_MASK )) {

                    ASSERT(!ARGUMENT_PRESENT( NetworkInfo ));

                    NtfsEncryptionCreateCallback( IrpContext,
                                                  Irp,
                                                  IrpSp,
                                                  ThisScb,
                                                  ThisCcb,
                                                  CurrentFcb,
                                                  ParentFcb,
                                                  FALSE );
            }
#endif

        }

        //
        //  If our caller told us not to complete the irp, or if this
        //  is a network open, we don't really complete the irp.
        //  EFS_CREATES have PostCreate callouts to do before the
        //  irp gets completed, and before the irp context gets deleted,
        //  and the caller will do that for us. We should at least
        //  cleanup the irp context if our caller won't.
        //

        if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_EFS_CREATE ) ||
            (ARGUMENT_PRESENT( NetworkInfo ))) {

            NtfsCompleteRequest( IrpContext,
                                 NULL,
                                 Status );
#ifdef NTFSDBG
            ASSERT( None == IrpContext->OwnershipState );
#endif

        } else {

            NtfsCompleteRequest( IrpContext,
                                 Irp,
                                 Status );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCommonCreate:  Exit -> %08lx\n", Status) );

    return Status;
}


NTSTATUS
NtfsCommonVolumeOpen (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is opening the Volume Dasd file.  We have already done all the
    checks needed to verify that the user is opening the $DATA attribute.
    We check the security attached to the file and take some special action
    based on a volume open.

Arguments:

Return Value:

    NTSTATUS - The result of this operation.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    PVCB Vcb;
    PFCB ThisFcb;
    PCCB ThisCcb;

    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN FcbAcquired = FALSE;

    BOOLEAN SharingViolation;
    BOOLEAN LockVolume = FALSE;
    BOOLEAN NotifyLockFailed = FALSE;

    PAGED_CODE();

    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    DebugTrace( +1, Dbg, ("NtfsCommonVolumeOpen:  Entered\n") );

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FileObject = IrpSp->FileObject;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Start by checking the create disposition.  We can only open this
        //  file.
        //

        {
            ULONG CreateDisposition;

            CreateDisposition = (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff;

            if (CreateDisposition != FILE_OPEN
                && CreateDisposition != FILE_OPEN_IF) {

                try_return( Status = STATUS_ACCESS_DENIED );
            }
        }

        //
        //  Make sure the directory flag isn't set for the volume open.
        //

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        //
        //  If this volume open is going to generate an implicit volume lock
        //  (a la autochk), notify anyone who wants to close their handles so
        //  the lock can happen.  We need to do this before we acquire any resources.
        //

        if (!FlagOn( IrpSp->Parameters.Create.ShareAccess,
                     FILE_SHARE_WRITE | FILE_SHARE_DELETE )) {

            DebugTrace( 0, Dbg, ("Sending lock notification\n") );
            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_LOCK );
            NotifyLockFailed = TRUE;
        }

        //
        //  Acquire the Vcb and verify the volume isn't locked.
        //

        Vcb = &((PVOLUME_DEVICE_OBJECT) IrpSp->DeviceObject)->Vcb;
        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
        VcbAcquired = TRUE;

        if (FlagOn( Vcb->VcbState, VCB_STATE_LOCKED | VCB_STATE_PERFORMED_DISMOUNT )) {

            try_return( Status = STATUS_ACCESS_DENIED );
        }

        //
        //  We do give READ-WRITE access to the volume even when
        //  it's actually write protected. This is just so that we won't break
        //  any apps. However, we don't let the user actually do any modifications.
        //

        // if ((NtfsIsVolumeReadOnly( Vcb )) &&
        //    (FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
        //             FILE_WRITE_DATA | FILE_APPEND_DATA | DELETE ))) {
        //
        //   try_return( Status = STATUS_MEDIA_WRITE_PROTECTED );
        //}

        //
        //  Ping the volume to make sure the Vcb is still mounted.  If we need
        //  to verify the volume then do it now, and if it comes out okay
        //  then clear the verify volume flag in the device object and continue
        //  on.  If it doesn't verify okay then dismount the volume and
        //  either tell the I/O system to try and create again (with a new mount)
        //  or that the volume is wrong. This later code is returned if we
        //  are trying to do a relative open and the vcb is no longer mounted.
        //

        if (!NtfsPingVolume( IrpContext, Vcb, NULL ) ||
            !FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            if (!NtfsPerformVerifyOperation( IrpContext, Vcb )) {

                NtfsReleaseVcb( IrpContext, Vcb );
                NtfsAcquireCheckpointSynchronization( IrpContext, Vcb );
                NtfsAcquireExclusiveVcb( IrpContext, Vcb, FALSE );

                if (!NtfsPerformVerifyOperation( IrpContext, Vcb )) {

                    try {
                        NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );
                    } finally {
                        NtfsReleaseCheckpointSynchronization( IrpContext, Vcb );
                    }

                    NtfsRaiseStatus( IrpContext, STATUS_WRONG_VOLUME, NULL, NULL );
                }
            }

            //
            //  The volume verified correctly so now clear the verify bit
            //  and continue with the create
            //

            ClearFlag( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME );
        }

        //
        //  Now acquire the Fcb for the VolumeDasd and verify the user has
        //  permission to open the volume.
        //

        ThisFcb = Vcb->VolumeDasdScb->Fcb;

        if (ThisFcb->PagingIoResource != NULL) {

            NtfsAcquireExclusivePagingIo( IrpContext, ThisFcb );
        }

        NtfsAcquireResourceExclusive( IrpContext, ThisFcb, TRUE );
        FcbAcquired = TRUE;

        NtfsOpenCheck( IrpContext, ThisFcb, NULL, Irp );

        //
        //  If the user does not want to share write or delete then we will try
        //  and take out a lock on the volume.
        //

        if (!FlagOn( IrpSp->Parameters.Create.ShareAccess,
                     FILE_SHARE_WRITE | FILE_SHARE_DELETE )) {

            //
            //  Do a quick test of the volume cleanup count if this opener won't
            //  share with anyone.  We can safely examine the cleanup count without
            //  further synchronization because we are guaranteed to have the
            //  Vcb exclusive at this point.
            //

#ifdef SYSCACHE_DEBUG
            if (!FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_READ) &&
                (Vcb->CleanupCount != 1)) {
#else
            if (!FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_READ) &&
                (Vcb->CleanupCount != 0)) {
#endif

                try_return( Status = STATUS_SHARING_VIOLATION );
#ifdef SYSCACHE_DEBUG
            }
#else
            }
#endif

            //
            //  Go ahead and flush and purge the volume.  Then test to see if all
            //  of the user file objects were closed.
            //

            Status = NtfsFlushVolume( IrpContext, Vcb, TRUE, TRUE, TRUE, FALSE );

            //
            //  We don't care about certain errors in the flush path.
            //

            if (!NT_SUCCESS( Status )) {

                //
                //  If there are no conflicts but the status indicates disk corruption
                //  or a section that couldn't be removed then ignore the error.  We
                //  allow this open to succeed so that chkdsk can open the volume to
                //  repair the damage.
                //

                if ((Status == STATUS_UNABLE_TO_DELETE_SECTION) ||
                    (Status == STATUS_DISK_CORRUPT_ERROR) ||
                    (Status == STATUS_FILE_CORRUPT_ERROR)) {

                    Status = STATUS_SUCCESS;
                }
            }

            //
            //  If the flush and purge was successful but there are still file objects
            //  that block this open it is possible that the FspClose thread is
            //  blocked behind the Vcb.  Drop the Fcb and Vcb to allow this thread
            //  to get in and then reacquire them.  This will give this Dasd open
            //  another chance to succeed on the first try.
            //

            SharingViolation = FALSE;

            if (FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_READ)) {

                if (Vcb->ReadOnlyCloseCount != (Vcb->CloseCount - Vcb->SystemFileCloseCount)) {

                    SharingViolation = TRUE;
                }

            } else if (Vcb->CloseCount != Vcb->SystemFileCloseCount) {

                SharingViolation = TRUE;
            }

            if (SharingViolation && NT_SUCCESS( Status )) {

                //
                //  We need to commit the current transaction and release any
                //  resources.  This will release the Fcb for the volume as
                //  well.  Explicitly release the Vcb.
                //

                NtfsCheckpointCurrentTransaction( IrpContext );

                while (!IsListEmpty(&IrpContext->ExclusiveFcbList)) {

                    NtfsReleaseFcbWithPaging( IrpContext,
                                    (PFCB)CONTAINING_RECORD(IrpContext->ExclusiveFcbList.Flink,
                                                            FCB,
                                                            ExclusiveFcbLinks ));
                }

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                              IRP_CONTEXT_FLAG_RELEASE_MFT );

                if (ThisFcb->PagingIoResource != NULL) {

                    NtfsReleasePagingIo( IrpContext, ThisFcb );
                }

                NtfsReleaseResource( IrpContext, ThisFcb );
                FcbAcquired = FALSE;

                NtfsReleaseVcb( IrpContext, Vcb );
                VcbAcquired = FALSE;

                CcWaitForCurrentLazyWriterActivity();

                //
                //  Now explicitly reacquire the Vcb and Fcb.  Test that no one
                //  else got in to lock the volume in the meantime.
                //

                NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
                VcbAcquired = TRUE;

                if (FlagOn( Vcb->VcbState, VCB_STATE_LOCKED | VCB_STATE_PERFORMED_DISMOUNT )) {

                    try_return( Status = STATUS_ACCESS_DENIED );
                }

                //
                //  Now acquire the Fcb for the VolumeDasd.
                //

                if (ThisFcb->PagingIoResource != NULL) {

                    NtfsAcquireExclusivePagingIo( IrpContext, ThisFcb );
                }

                NtfsAcquireResourceExclusive( IrpContext, ThisFcb, TRUE );
                FcbAcquired = TRUE;

                //
                //  Duplicate the flush/purge and test if there is no sharing
                //  violation.
                //

                Status = NtfsFlushVolume( IrpContext, Vcb, TRUE, TRUE, TRUE, FALSE );

                //
                //  We don't care about certain errors in the flush path.
                //

                if (!NT_SUCCESS( Status )) {

                    //
                    //  If there are no conflicts but the status indicates disk corruption
                    //  or a section that couldn't be removed then ignore the error.  We
                    //  allow this open to succeed so that chkdsk can open the volume to
                    //  repair the damage.
                    //

                    if ((Status == STATUS_UNABLE_TO_DELETE_SECTION) ||
                        (Status == STATUS_DISK_CORRUPT_ERROR) ||
                        (Status == STATUS_FILE_CORRUPT_ERROR)) {

                        Status = STATUS_SUCCESS;
                    }
                }

                SharingViolation = FALSE;

                if (FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_READ)) {

                    if (Vcb->ReadOnlyCloseCount != (Vcb->CloseCount - Vcb->SystemFileCloseCount)) {

                        SharingViolation = TRUE;
                    }

                } else if (Vcb->CloseCount != Vcb->SystemFileCloseCount) {

                    SharingViolation = TRUE;
                }
            }

            //
            //  Return an error if there are still conflicting file objects.
            //

            if (SharingViolation) {

                //
                //  If there was an error in the flush then return it.  Otherwise
                //  return SHARING_VIOLATION.
                //

                if (NT_SUCCESS( Status )) {

                    try_return( Status = STATUS_SHARING_VIOLATION );

                } else {

                    try_return( Status );
                }
            }

            if (!NT_SUCCESS( Status )) {

                //
                //  If there are no conflicts but the status indicates disk corruption
                //  or a section that couldn't be removed then ignore the error.  We
                //  allow this open to succeed so that chkdsk can open the volume to
                //  repair the damage.
                //

                if ((Status == STATUS_UNABLE_TO_DELETE_SECTION) ||
                    (Status == STATUS_DISK_CORRUPT_ERROR) ||
                    (Status == STATUS_FILE_CORRUPT_ERROR)) {

                    Status = STATUS_SUCCESS;

                //
                //  Fail this request on any other failures.
                //

                } else {

                    try_return( Status );
                }
            }

            //
            //  Remember that we want to lock the volume if the user plans to write.
            //  This is to allow autochk to fiddle with the volume.
            //

            if (FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                        FILE_WRITE_DATA | FILE_APPEND_DATA )) {

                LockVolume = TRUE;
            }

        //
        //  Just flush the volume data if the user requested read or write.
        //  No need to purge or lock the volume.
        //

        } else if (FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                           FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA )) {

            if (!NT_SUCCESS( Status = NtfsFlushVolume( IrpContext, Vcb, TRUE, FALSE, TRUE, FALSE ))) {

                //
                //  Swallow corruption errors because we want this open to succeed.
                //

                if ((Status == STATUS_DISK_CORRUPT_ERROR) ||
                    (Status == STATUS_FILE_CORRUPT_ERROR)) {

                    Status = STATUS_SUCCESS;

                } else {

                    //
                    //  Report the error that there is an data section blocking the open by returning
                    //  sharing violation.  Otherwise Win32 callers will get INVALID_PARAMETER.
                    //

                    if (Status == STATUS_UNABLE_TO_DELETE_SECTION) {

                        Status = STATUS_SHARING_VIOLATION;
                    }

                    try_return( Status );
                }
            }
        }

        //
        //  Put the Volume Dasd name in the file object.
        //

        {
            PVOID Temp = FileObject->FileName.Buffer;

            FileObject->FileName.Buffer =
                FsRtlAllocatePoolWithTag(PagedPool, 8 * sizeof( WCHAR ), MODULE_POOL_TAG );

            if (Temp != NULL) {

                NtfsFreePool( Temp );
            }

            RtlCopyMemory( FileObject->FileName.Buffer, L"\\$Volume", 8 * sizeof( WCHAR ));
            FileObject->FileName.MaximumLength =
            FileObject->FileName.Length = 8*2;
        }

        //
        //  We never allow cached access to the volume file.
        //

        ClearFlag( FileObject->Flags, FO_CACHE_SUPPORTED );
        SetFlag( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING );

        //
        //  Go ahead open the attribute.  This should only fail if there is an
        //  allocation failure or share access failure.
        //

        if (NT_SUCCESS( Status = NtfsOpenAttribute( IrpContext,
                                                    IrpSp,
                                                    Vcb,
                                                    NULL,
                                                    ThisFcb,
                                                    2,
                                                    NtfsEmptyString,
                                                    $DATA,
                                                    (ThisFcb->CleanupCount == 0 ?
                                                     SetShareAccess :
                                                     CheckShareAccess),
                                                    UserVolumeOpen,
                                                    FALSE,
                                                    CCB_FLAG_OPEN_AS_FILE,
                                                    NULL,
                                                    &Vcb->VolumeDasdScb,
                                                    &ThisCcb ))) {

            //
            //  Perform the final initialization.
            //

            //
            //  Check if we can administer the volume and note it in the ccb
            //

            //
            //  If the user was granted both read and write access then
            //  he can administer the volume.  This allows the interactive
            //  user to manage removable media if allowed by the access.
            //

            if (FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                        FILE_READ_DATA | FILE_WRITE_DATA ) == (FILE_READ_DATA | FILE_WRITE_DATA)) {

                SetFlag( ThisCcb->AccessFlags, MANAGE_VOLUME_ACCESS );

            //
            //  We can also grant it through our ACL.
            //

            } else if (NtfsCanAdministerVolume( IrpContext, Irp, ThisFcb, NULL, NULL )) {

                SetFlag( ThisCcb->AccessFlags, MANAGE_VOLUME_ACCESS );

            //
            //  We can also grant this through the MANAGE_VOLUME_PRIVILEGE.
            //

            } else {

                PRIVILEGE_SET PrivilegeSet;

                PrivilegeSet.PrivilegeCount = 1;
                PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
                PrivilegeSet.Privilege[0].Luid = RtlConvertLongToLuid( SE_MANAGE_VOLUME_PRIVILEGE );
                PrivilegeSet.Privilege[0].Attributes = 0;

                if (SePrivilegeCheck( &PrivilegeSet,
                                      &IrpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext,
                                      Irp->RequestorMode )) {

                    SetFlag( ThisCcb->AccessFlags, MANAGE_VOLUME_ACCESS );

                //
                //  Well nothing else worked.  Now we need to look at the security
                //  descriptor on the device.
                //

                } else {

                    NTSTATUS SeStatus;
                    BOOLEAN MemoryAllocated = FALSE;
                    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
                    ULONG RequestedAccess = FILE_READ_DATA | FILE_WRITE_DATA;

                    SeStatus = ObGetObjectSecurity( Vcb->Vpb->RealDevice,
                                                    &SecurityDescriptor,
                                                    &MemoryAllocated );

                    if (SeStatus == STATUS_SUCCESS) {

                        //
                        //  If there is a security descriptor then check the access.
                        //

                        if (SecurityDescriptor != NULL) {

                            if (NtfsCanAdministerVolume( IrpContext,
                                                         Irp,
                                                         ThisFcb,
                                                         SecurityDescriptor,
                                                         &RequestedAccess )) {

                                SetFlag( ThisCcb->AccessFlags, MANAGE_VOLUME_ACCESS );
                            }

                            //
                            //  Free up the descriptor.
                            //

                            ObReleaseObjectSecurity( SecurityDescriptor,
                                                     MemoryAllocated );
                        }
                    }
                }
            }

            //
            //  If we are locking the volume, do so now.
            //

            if (LockVolume) {

                SetFlag( Vcb->VcbState, VCB_STATE_LOCKED );
                Vcb->FileObjectWithVcbLocked = FileObject;

                //
                //  Looks like the lock succeeded, so we don't have to do the
                //  lock failed notification now.
                //

                NotifyLockFailed = FALSE;
            }

            //
            //  Report that we opened the volume.
            //

            Irp->IoStatus.Information = FILE_OPENED;
        }

    try_exit: NOTHING;

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

        //
        //  If we have a successful open then remove the name out of
        //  the file object.  The IO system gets confused when it
        //  is there.  We will deallocate the buffer with the Ccb
        //  when the handle is closed.
        //

        if (Status == STATUS_SUCCESS) {

            FileObject->FileName.Buffer = NULL;
            FileObject->FileName.MaximumLength =
            FileObject->FileName.Length = 0;

            SetFlag( ThisCcb->Flags, CCB_FLAG_ALLOCATED_FILE_NAME );
        }

    } finally {

        DebugUnwind( NtfsCommonVolumeOpen );

        if (FcbAcquired) { NtfsReleaseResource( IrpContext, ThisFcb ); }

        if (VcbAcquired) {
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        //
        //  Now that we aren't holding any resources, notify everyone
        //  who might want to reopen their handles. We want to do this
        //  before we complete the request because the FileObject might
        //  not exist beyond the life of the Irp.
        //

        if (NotifyLockFailed) {

            DebugTrace( 0, Dbg, ("Sending lock_failed notification\n") );
            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_LOCK_FAILED );
        }

        DebugTrace( -1, Dbg, ("NtfsCommonVolumeOpen:  Exit  ->  %08lx\n", Status) );
    }

    //
    //  If we have already done a PreCreate for this IRP (in FsdCreate),
    //  we should do the corresponding PostCreate before we complete the IRP. So,
    //  in that case, don't complete the IRP here -- just free the IrpContext.
    //  The IRP will be completed by the caller.
    //

    if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_EFS_CREATE )) {
         NtfsCompleteRequest( IrpContext, NULL, Status );
    } else {
         NtfsCompleteRequest( IrpContext, Irp, Status );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsOpenFcbById (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN PLCB ParentLcb OPTIONAL,
    IN OUT PFCB *CurrentFcb,
    IN BOOLEAN UseCurrentFcb,
    IN FILE_REFERENCE FileReference,
    IN UNICODE_STRING AttrName,
    IN UNICODE_STRING AttrCodeName,
    IN PVOID NetworkInfo OPTIONAL,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    )

/*++

Routine Description:

    This routine is called to open a file by its file Id.  We need to
    verify that this file Id exists and then compare the type of the
    file with the requested type of open.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the Irp stack pointer for the filesystem.

    Vcb - Vcb for this volume.

    ParentLcb - Lcb used to reach this Fcb.  Only specified when opening
        a file by name relative to a directory opened by file Id.

    CurrentFcb - Address of Fcb pointer.  It will either be the
        Fcb to open or we will store the Fcb we find here.

    UseCurrentFcb - Indicate in the CurrentFcb above points to the target
        Fcb or if we should find it here.

    FileReference - This is the file Id for the file to open.

    AttrName - This is the name of the attribute to open.

    AttrCodeName - This is the name of the attribute code to open.

    NetworkInfo - If specified then this call is a fast open call to query
        the network information.  We don't update any of the in-memory structures
        for this.

    ThisScb - This is the address to store the Scb from this open.

    ThisCcb - This is the address to store the Ccb from this open.

Return Value:

    NTSTATUS - Indicates the result of this create file operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    LONGLONG MftOffset;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PBCB Bcb = NULL;

    BOOLEAN IndexedAttribute;

    PFCB ThisFcb;
    BOOLEAN ExistingFcb = FALSE;

    ULONG CcbFlags = 0;
    ATTRIBUTE_TYPE_CODE AttrTypeCode;
    OLD_SCB_SNAPSHOT ScbSizes;
    BOOLEAN HaveScbSizes = FALSE;
    BOOLEAN DecrementCloseCount = FALSE;

    PSCB ParentScb = NULL;
    PLCB Lcb = ParentLcb;
    BOOLEAN AcquiredParentScb = FALSE;
    BOOLEAN AcquiredMft = FALSE;

    BOOLEAN AcquiredFcbTable = FALSE;
    BOOLEAN PreparedForUpdateDuplicate = FALSE;
    UCHAR CreateDisposition = (UCHAR) ((IrpSp->Parameters.Create.Options >> 24) & 0x000000ff);

    UNREFERENCED_PARAMETER( NetworkInfo );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenFcbById:  Entered\n") );

    //
    //  The next thing to do is to figure out what type
    //  of attribute the caller is trying to open.  This involves the
    //  directory/non-directory bits, the attribute name and code strings,
    //  the type of file, whether he passed in an ea buffer and whether
    //  there was a trailing backslash.
    //

    if (NtfsEqualMftRef( &FileReference,
                         &VolumeFileReference )) {

        if (AttrName.Length != 0
            || AttrCodeName.Length != 0) {

            Status = STATUS_INVALID_PARAMETER;
            DebugTrace( -1, Dbg, ("NtfsOpenFcbById:  Exit  ->  %08lx\n", Status) );

            return Status;
        }

        SetFlag( IrpContext->State,
                 IRP_CONTEXT_STATE_ACQUIRE_EX | IRP_CONTEXT_STATE_DASD_OPEN );

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If we don't already have the Fcb then look up the file record
        //  from the disk.
        //

        if (!UseCurrentFcb) {

            //
            //  We start by reading the disk and checking that the file record
            //  sequence number matches and that the file record is in use.
            //  We remember whether this is a directory.  We will only go to
            //  the file if the file Id will lie within the Mft File.
            //

            MftOffset = NtfsFullSegmentNumber( &FileReference );

            MftOffset = Int64ShllMod32(MftOffset, Vcb->MftShift);

            //
            //  Make sure we are serialized with access to the Mft.  Otherwise
            //  someone else could be deleting the file as we speak.
            //

            NtfsAcquireSharedFcb( IrpContext, Vcb->MftScb->Fcb, NULL, 0 );
            AcquiredMft = TRUE;

            if (MftOffset >= Vcb->MftScb->Header.FileSize.QuadPart) {

                DebugTrace( 0, Dbg, ("File Id doesn't lie within Mft\n") );

                try_return( Status = STATUS_INVALID_PARAMETER );
            }

            NtfsReadMftRecord( IrpContext,
                               Vcb,
                               &FileReference,
                               FALSE,
                               &Bcb,
                               &FileRecord,
                               NULL );

            //
            //  This file record better be in use, have a matching sequence number and
            //  be the primary file record for this file.
            //

            if ((FileRecord->SequenceNumber != FileReference.SequenceNumber) ||
                !FlagOn( FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE ) ||
                (*((PLONGLONG) &FileRecord->BaseFileRecordSegment) != 0) ||
                (*((PULONG) FileRecord->MultiSectorHeader.Signature) != *((PULONG) FileSignature))) {

                try_return( Status = STATUS_INVALID_PARAMETER );
            }

            //
            //  If indexed then use the name for the file name index.
            //

            if (FlagOn( FileRecord->Flags, FILE_FILE_NAME_INDEX_PRESENT )) {

                AttrName = NtfsFileNameIndex;
                AttrCodeName = NtfsIndexAllocation;
            }

            NtfsUnpinBcb( IrpContext, &Bcb );

        } else {

            ThisFcb = *CurrentFcb;
            ExistingFcb = TRUE;
        }

        Status = NtfsCheckValidAttributeAccess( IrpSp,
                                                Vcb,
                                                ExistingFcb ? &ThisFcb->Info : NULL,
                                                &AttrName,
                                                AttrCodeName,
                                                0,  //  no flags
                                                &AttrTypeCode,
                                                &CcbFlags,
                                                &IndexedAttribute );

        if (!NT_SUCCESS( Status )) {

            try_return( Status );
        }

        //
        //  If we don't have an Fcb then create one now.
        //

        if (!UseCurrentFcb) {

            NtfsAcquireFcbTable( IrpContext, Vcb );
            AcquiredFcbTable = TRUE;

            //
            //  We know that it is safe to continue the open.  We start by creating
            //  an Fcb for this file.  It is possible that the Fcb exists.
            //  We create the Fcb first, if we need to update the Fcb info structure
            //  we copy the one from the index entry.  We look at the Fcb to discover
            //  if it has any links, if it does then we make this the last Fcb we
            //  reached.  If it doesn't then we have to clean it up from here.
            //

            ThisFcb = NtfsCreateFcb( IrpContext,
                                     Vcb,
                                     FileReference,
                                     BooleanFlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ),
                                     TRUE,
                                     &ExistingFcb );

            ThisFcb->ReferenceCount += 1;

            //
            //  Try to do a fast acquire, otherwise we need to release
            //  the Fcb table, acquire the Fcb, acquire the Fcb table to
            //  dereference Fcb.  This should only be the case if the Fcb already
            //  existed.  In that case all of the flags indicating whether it
            //  has been deleted will be valid when we reacquire it.  We don't
            //  have to worry about Mft synchronization.
            //

            if (!NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, ACQUIRE_DONT_WAIT )) {

                NtfsReleaseFcbTable( IrpContext, Vcb );
                NtfsReleaseFcb( IrpContext, Vcb->MftScb->Fcb );
                AcquiredMft = FALSE;
                NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, 0 );
                NtfsAcquireFcbTable( IrpContext, Vcb );

            } else {

                NtfsReleaseFcb( IrpContext, Vcb->MftScb->Fcb );
                AcquiredMft = FALSE;
            }

            ThisFcb->ReferenceCount -= 1;

            NtfsReleaseFcbTable( IrpContext, Vcb );
            AcquiredFcbTable = FALSE;

            //
            //  Store this Fcb into our caller's parameter and remember to
            //  to show we acquired it.
            //

            *CurrentFcb = ThisFcb;
        }

        //
        //  We perform a check to see whether we will allow the system
        //  files to be opened.
        //
        //  No test to make if this is not a system file or it is the VolumeDasd file.
        //  The ACL will protect the volume file.
        //

        if (FlagOn( ThisFcb->FcbState, FCB_STATE_SYSTEM_FILE ) &&
            (NtfsSegmentNumber( &ThisFcb->FileReference ) != VOLUME_DASD_NUMBER) &&
            NtfsProtectSystemFiles) {

            if (!NtfsCheckValidFileAccess( ThisFcb, IrpSp )) {
                Status = STATUS_ACCESS_DENIED;
                DebugTrace( 0, Dbg, ("Invalid access to system files\n") );
                try_return( NOTHING );
            }
        }

        //
        //  If the Fcb existed and this is a paging file then either return
        //  sharing violation or force the Fcb and Scb's to go away.
        //  Do this for the case where the user is opening a paging file
        //  but the Fcb is non-paged or the user is opening a non-paging
        //  file and the Fcb is for a paging file.
        //

        if (ExistingFcb &&

            ((FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ) &&
              !FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE )) ||

             (FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE ) &&
              !FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE )))) {

            if (ThisFcb->CleanupCount != 0) {

                try_return( Status = STATUS_SHARING_VIOLATION );

            //
            //  If we have a persistent paging file then give up and
            //  return SHARING_VIOLATION.
            //

            } else if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP )) {

                try_return( Status = STATUS_SHARING_VIOLATION );

            //
            //  If there was an existing Fcb for a paging file we need to force
            //  all of the Scb's to be torn down.  The easiest way to do this
            //  is to flush and purge all of the Scb's (saving any attribute list
            //  for last) and then raise LOG_FILE_FULL to allow this request to
            //  be posted.
            //

            } else {

                //
                //  Reference the Fcb so it doesn't go away.
                //

                InterlockedIncrement( &ThisFcb->CloseCount );
                DecrementCloseCount = TRUE;

                //
                //  Flush and purge this Fcb.
                //

                NtfsFlushAndPurgeFcb( IrpContext, ThisFcb );

                InterlockedDecrement( &ThisFcb->CloseCount );
                DecrementCloseCount = FALSE;

                //
                //  Force this request to be posted and then raise
                //  CANT_WAIT.
                //

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );

                //
                //  If we are posting then we may want to use the next stack location.
                //

                if (IrpContext->Union.OplockCleanup->CompletionContext != NULL) {

                    NtfsPrepareForIrpCompletion( IrpContext, IrpContext->OriginatingIrp, IrpContext->Union.OplockCleanup->CompletionContext );
                    IrpContext->Union.OplockCleanup->CompletionContext = NULL;
                }

                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }
        }

        //
        //  If the Fcb Info field needs to be initialized, we do so now.
        //  We read this information from the disk.
        //

        if (!FlagOn( ThisFcb->FcbState, FCB_STATE_DUP_INITIALIZED )) {

            HaveScbSizes = NtfsUpdateFcbInfoFromDisk( IrpContext,
                                                      TRUE,
                                                      ThisFcb,
                                                      &ScbSizes );

            //
            //  Fix the quota for this file if necessary.
            //

            NtfsConditionallyFixupQuota( IrpContext, ThisFcb );

        }

        //
        //  Now that we have the dup info off disk recheck the create options
        //

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE ) &&
            !IsViewIndex( &ThisFcb->Info ) &&
            !IsDirectory( &ThisFcb->Info )) {

            NtfsRaiseStatus( IrpContext, STATUS_NOT_A_DIRECTORY, NULL, NULL );
        }

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE ) &&
            (IsViewIndex( &ThisFcb->Info ) || IsDirectory( &ThisFcb->Info ))) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_IS_A_DIRECTORY, NULL, NULL );
        }

        //
        //  If the link count is zero on this Fcb, then delete is pending.  Otherwise
        //  this might be an unused system file.
        //

        if (ThisFcb->LinkCount == 0) {

            if (NtfsSegmentNumber( &ThisFcb->FileReference ) >= FIRST_USER_FILE_NUMBER) {

                try_return( Status = STATUS_DELETE_PENDING );

            } else {

                try_return( Status = STATUS_INVALID_PARAMETER );
            }
        }

        //
        //  Make sure we acquire the parent directory now, before we do anything
        //  that might cause us to acquire the quota mutex.  If the caller only
        //  wants to open an existing file, we can skip this.
        //

        if (CreateDisposition != FILE_OPEN) {

            NtfsPrepareForUpdateDuplicate( IrpContext, ThisFcb, &Lcb, &ParentScb, FALSE );
            PreparedForUpdateDuplicate = TRUE;
        }

        //
        //  We now call the worker routine to open an attribute on an existing file.
        //

        Status = NtfsOpenAttributeInExistingFile( IrpContext,
                                                  Irp,
                                                  IrpSp,
                                                  ParentLcb,
                                                  ThisFcb,
                                                  0,
                                                  AttrName,
                                                  AttrTypeCode,
                                                  CcbFlags,
                                                  CREATE_FLAG_OPEN_BY_ID,
                                                  NULL,
                                                  ThisScb,
                                                  ThisCcb );

        //
        //  Check to see if we should update the last access time.
        //  We skip this for reparse points as *ThisScb and *ThisCcb may be NULL.
        //

        if (NT_SUCCESS( Status ) &&
            (Status != STATUS_PENDING) &&
            (Status != STATUS_REPARSE)) {

            PSCB Scb = *ThisScb;

            //
            //  Now look at whether we need to update the Fcb and on disk
            //  structures.
            //

            if (NtfsCheckLastAccess( IrpContext, ThisFcb )) {

                SetFlag( ThisFcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_LAST_ACCESS );
            }

            //
            //  Perform the last bit of work.  If this a user file open, we need
            //  to check if we initialize the Scb.
            //

            if (!IndexedAttribute) {

                if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                    //
                    //  We may have the sizes from our Fcb update call.
                    //

                    if (HaveScbSizes &&
                        (AttrTypeCode == $DATA) &&
                        (AttrName.Length == 0) &&
                        !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_CREATE_MOD_SCB )) {

                        NtfsUpdateScbFromMemory( Scb, &ScbSizes );

                    } else {

                        NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
                    }
                }

                //
                //  Let's check if we need to set the cache bit.
                //

                if (!FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_INTERMEDIATE_BUFFERING )) {

                    SetFlag( IrpSp->FileObject->Flags, FO_CACHE_SUPPORTED );
                }
            }

            //
            //  If everything has gone well so far, we may want to call the
            //  encryption callback if one is registered.  We do not do
            //  this for network opens or reparse points.  We have to pass
            //  FILE_EXISTING since we have no parent directory and the
            //  encryption callback needs a parent directory to handle a
            //  new file create.
            //

            if (!ARGUMENT_PRESENT( NetworkInfo )) {

                NtfsEncryptionCreateCallback( IrpContext,
                                              Irp,
                                              IrpSp,
                                              *ThisScb,
                                              *ThisCcb,
                                              ThisFcb,
                                              NULL,
                                              FALSE );
            }

            //
            //  If this operation was a supersede/overwrite or we created a new
            //  attribute stream then we want to perform the file record and
            //  directory update now.  Otherwise we will defer the updates until
            //  the user closes his handle.
            //

            if (NtfsIsStreamNew(Irp->IoStatus.Information)) {

                NtfsUpdateScbFromFileObject( IrpContext, IrpSp->FileObject, *ThisScb, TRUE );

                //
                //  Do the standard information, file sizes and then duplicate information
                //  if needed.
                //

                if (FlagOn( ThisFcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

                    NtfsUpdateStandardInformation( IrpContext, ThisFcb );
                }

                if (FlagOn( (*ThisScb)->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE )) {

                    NtfsWriteFileSizes( IrpContext,
                                        *ThisScb,
                                        &(*ThisScb)->Header.ValidDataLength.QuadPart,
                                        FALSE,
                                        TRUE,
                                        FALSE );
                }

                if (FlagOn( ThisFcb->InfoFlags, FCB_INFO_DUPLICATE_FLAGS )) {

                    ASSERT( PreparedForUpdateDuplicate );
                    NtfsUpdateDuplicateInfo( IrpContext, ThisFcb, NULL, NULL );
                    NtfsUpdateLcbDuplicateInfo( ThisFcb, Lcb );
                    ThisFcb->InfoFlags = 0;
                }

                ClearFlag( ThisFcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

                NtfsAcquireFsrtlHeader( *ThisScb );
                ClearFlag( (*ThisScb)->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
                NtfsReleaseFsrtlHeader( *ThisScb );
            }
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsOpenFcbById );

        if (AcquiredFcbTable) {

            NtfsReleaseFcbTable( IrpContext, Vcb );
        }

        if (AcquiredMft) {

            NtfsReleaseFcb( IrpContext, Vcb->MftScb->Fcb );
        }

        //
        //  If this operation was not totally successful we need to
        //  back out the following changes.
        //
        //      Modifications to the Info fields in the Fcb.
        //      Any changes to the allocation of the Scb.
        //      Any changes in the open counts in the various structures.
        //      Changes to the share access values in the Fcb.
        //

        if (!NT_SUCCESS( Status ) || AbnormalTermination()) {

            NtfsBackoutFailedOpens( IrpContext,
                                    IrpSp->FileObject,
                                    ThisFcb,
                                    *ThisScb,
                                    *ThisCcb );
        }

        if (DecrementCloseCount) {

            InterlockedDecrement( &ThisFcb->CloseCount );
        }

        NtfsUnpinBcb( IrpContext, &Bcb );

        DebugTrace( -1, Dbg, ("NtfsOpenFcbById:  Exit  ->  %08lx\n", Status) );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsOpenExistingPrefixFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB ThisFcb,
    IN PLCB Lcb OPTIONAL,
    IN ULONG FullPathNameLength,
    IN UNICODE_STRING AttrName,
    IN UNICODE_STRING AttrCodeName,
    IN ULONG CreateFlags,
    IN PVOID NetworkInfo OPTIONAL,
    IN PCREATE_CONTEXT CreateContext,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    )

/*++

Routine Description:

    This routine will open an attribute in a file whose Fcb was found
    with a prefix search.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the Irp stack pointer for the filesystem.

    ThisFcb - This is the Fcb to open.

    Lcb - This is the Lcb used to reach this Fcb.  Not specified if this is a volume open.

    FullPathNameLength - This is the length of the full path name.

    AttrName - This is the name of the attribute to open.

    AttrCodeName - This is the name of the attribute code to open.

    CreateFlags - Flags for create operation - we care about the dos only component and trailing back slash
        flag

    NetworkInfo - If specified then this call is a fast open call to query
        the network information.  We don't update any of the in-memory structures
        for this.

    CreateContext - Context with create variables.

    ThisScb - This is the address to store the Scb from this open.

    ThisCcb - This is the address to store the Ccb from this open.

Return Value:

    NTSTATUS - Indicates the result of this attribute based operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTRIBUTE_TYPE_CODE AttrTypeCode;
    ULONG CcbFlags;
    BOOLEAN IndexedAttribute;
    BOOLEAN DecrementCloseCount = FALSE;

    ULONG LastFileNameOffset;

    OLD_SCB_SNAPSHOT ScbSizes;
    BOOLEAN HaveScbSizes = FALSE;

    ULONG CreateDisposition;

    PSCB ParentScb = NULL;
    PFCB ParentFcb = NULL;
    BOOLEAN AcquiredParentScb = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenExistingPrefixFcb:  Entered\n") );

    if (FlagOn( CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT )) {

        CcbFlags = CCB_FLAG_PARENT_HAS_DOS_COMPONENT;

    } else {

        CcbFlags = 0;
    }

    //
    //  The first thing to do is to figure out what type
    //  of attribute the caller is trying to open.  This involves the
    //  directory/non-directory bits, the attribute name and code strings,
    //  the type of file, whether he passed in an ea buffer and whether
    //  there was a trailing backslash.
    //

    if (NtfsEqualMftRef( &ThisFcb->FileReference, &VolumeFileReference )) {

        if ((AttrName.Length != 0) || (AttrCodeName.Length != 0)) {

            Status = STATUS_INVALID_PARAMETER;
            DebugTrace( -1, Dbg, ("NtfsOpenExistingPrefixFcb:  Exit  ->  %08lx\n", Status) );

            return Status;
        }

        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX | IRP_CONTEXT_STATE_DASD_OPEN );

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    ParentScb = Lcb->Scb;

    LastFileNameOffset = FullPathNameLength - Lcb->ExactCaseLink.LinkName.Length;

    if (ParentScb != NULL) {

        ParentFcb = ParentScb->Fcb;
    }

    Status = NtfsCheckValidAttributeAccess( IrpSp,
                                            ThisFcb->Vcb,
                                            &ThisFcb->Info,
                                            &AttrName,
                                            AttrCodeName,
                                            CreateFlags,
                                            &AttrTypeCode,
                                            &CcbFlags,
                                            &IndexedAttribute );

    if (!NT_SUCCESS( Status )) {

        DebugTrace( -1, Dbg, ("NtfsOpenExistingPrefixFcb:  Exit  ->  %08lx\n", Status) );

        return Status;
    }

    CreateDisposition = (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If the Fcb existed and this is a paging file then either return
        //  sharing violation or force the Fcb and Scb's to go away.
        //  Do this for the case where the user is opening a paging file
        //  but the Fcb is non-paged or the user is opening a non-paging
        //  file and the Fcb is for a paging file.
        //

        if ((FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ) &&
             !FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE )) ||

            (FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE ) &&
             !FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ))) {

            if (ThisFcb->CleanupCount != 0) {

                try_return( Status = STATUS_SHARING_VIOLATION );

            //
            //  If we have a persistent paging file then give up and
            //  return SHARING_VIOLATION.
            //

            } else if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP )) {

                try_return( Status = STATUS_SHARING_VIOLATION );

            //
            //  If there was an existing Fcb for a paging file we need to force
            //  all of the Scb's to be torn down.  The easiest way to do this
            //  is to flush and purge all of the Scb's (saving any attribute list
            //  for last) and then raise LOG_FILE_FULL to allow this request to
            //  be posted.
            //

            } else {

                //
                //  Make sure this Fcb won't go away as a result of purging
                //  the Fcb.
                //

                InterlockedIncrement( &ThisFcb->CloseCount );
                DecrementCloseCount = TRUE;

                //
                //  Flush and purge this Fcb.
                //

                NtfsFlushAndPurgeFcb( IrpContext, ThisFcb );

                //
                //  Now decrement the close count we have already biased.
                //

                InterlockedDecrement( &ThisFcb->CloseCount );
                DecrementCloseCount = FALSE;

                //
                //  Force this request to be posted and then raise
                //  CANT_WAIT.
                //

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );

                //
                //  If we are posting then we may want to use the next stack location.
                //

                if (IrpContext->Union.OplockCleanup->CompletionContext != NULL) {

                    NtfsPrepareForIrpCompletion( IrpContext,
                                                 IrpContext->OriginatingIrp,
                                                 IrpContext->Union.OplockCleanup->CompletionContext );
                }

                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }
        }

        //
        //  This file might have been recently created, and we might have dropped the
        //  Fcb to call the PostCreate encryption callout, so the encryption driver
        //  hasn't yet called us back to set the encryption bit on the file.  If we're
        //  asked to open the file in this window, we would introduce corruption by
        //  writing plaintext now.  Let's just raise cant_wait and try again later.
        //

        if (FlagOn( ThisFcb->FcbState, FCB_STATE_ENCRYPTION_PENDING )) {

#ifdef KEITHKA
            EncryptionPendingCount += 1;
#endif

            //
            //  Raise CANT_WAIT so we can wait on the encryption event at the top.
            //

            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ENCRYPTION_RETRY );

            //
            //  Clear the pending event so we can wait for it when we retry.
            //

            KeClearEvent( &NtfsEncryptionPendingEvent );
            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
        }

        //
        //  If this is a directory, it's possible that we hav an existing Fcb
        //  in the prefix table which needs to be initialized from the disk.
        //  We look in the InfoInitialized flag to know whether to go to
        //  disk.
        //

        if (!FlagOn( ThisFcb->FcbState, FCB_STATE_DUP_INITIALIZED )) {

            //
            //  If we have a parent Fcb then make sure to acquire it.
            //

            if (ParentScb != NULL) {

                NtfsAcquireExclusiveScb( IrpContext, ParentScb );
                AcquiredParentScb = TRUE;
            }

            HaveScbSizes = NtfsUpdateFcbInfoFromDisk( IrpContext,
                                                      TRUE,
                                                      ThisFcb,
                                                      &ScbSizes );

            NtfsConditionallyFixupQuota( IrpContext, ThisFcb );
        }

        //
        //  Check now whether we will need to acquire the parent to
        //  perform a update duplicate info.  We need to acquire it
        //  now to enforce our locking order in case any of the
        //  routines below acquire the Mft Scb.  Acquire it if we
        //  are doing a supersede/overwrite or possibly creating
        //  a named data stream.
        //

        if ((CreateDisposition == FILE_SUPERSEDE) ||
            (CreateDisposition == FILE_OVERWRITE) ||
            (CreateDisposition == FILE_OVERWRITE_IF) ||
            ((AttrName.Length != 0) &&
             ((CreateDisposition == FILE_OPEN_IF) ||
              (CreateDisposition == FILE_CREATE)))) {

            NtfsPrepareForUpdateDuplicate( IrpContext,
                                           ThisFcb,
                                           &Lcb,
                                           &ParentScb,
                                           FALSE );
        }

        //
        //  Call to open an attribute on an existing file.
        //  Remember we need to restore the Fcb info structure
        //  on errors.
        //

        Status = NtfsOpenAttributeInExistingFile( IrpContext,
                                                  Irp,
                                                  IrpSp,
                                                  Lcb,
                                                  ThisFcb,
                                                  LastFileNameOffset,
                                                  AttrName,
                                                  AttrTypeCode,
                                                  CcbFlags,
                                                  CreateFlags,
                                                  NetworkInfo,
                                                  ThisScb,
                                                  ThisCcb );

        //
        //  Check to see if we should update the last access time.
        //  We skip this for reparse points as *ThisScb and *ThisCcb may be NULL.
        //

        if (NT_SUCCESS( Status ) &&
            (Status != STATUS_PENDING) &&
            (Status != STATUS_REPARSE)) {

            PSCB Scb = *ThisScb;

            //
            //  This is a rare case.  There must have been an allocation failure
            //  to cause this but make sure the normalized name is stored.
            //

            if ((SafeNodeType( Scb ) == NTFS_NTC_SCB_INDEX) &&
                (Scb->ScbType.Index.NormalizedName.Length == 0)) {

                //
                //  We may be able to use the parent.
                //

                if ((ParentScb != NULL) &&
                    (ParentScb->ScbType.Index.NormalizedName.Length != 0)) {

                    NtfsUpdateNormalizedName( IrpContext,
                                              ParentScb,
                                              Scb,
                                              NULL,
                                              FALSE );

                } else {

                    NtfsBuildNormalizedName( IrpContext,
                                             Scb->Fcb,
                                             Scb,
                                             &Scb->ScbType.Index.NormalizedName );
                }
            }

            //
            //  Perform the last bit of work.  If this a user file open, we need
            //  to check if we initialize the Scb.
            //

            if (!IndexedAttribute) {

                if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                    //
                    //  We may have the sizes from our Fcb update call.
                    //

                    if (HaveScbSizes &&
                        (AttrTypeCode == $DATA) &&
                        (AttrName.Length == 0) &&
                        !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_CREATE_MOD_SCB )) {

                        NtfsUpdateScbFromMemory( Scb, &ScbSizes );

                    } else {

                        NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
                    }
                }

                //
                //  Let's check if we need to set the cache bit.
                //

                if (!FlagOn( IrpSp->Parameters.Create.Options,
                             FILE_NO_INTERMEDIATE_BUFFERING )) {

                    SetFlag( IrpSp->FileObject->Flags, FO_CACHE_SUPPORTED );
                }
            }

            //
            //  If this is the paging file, we want to be sure the allocation
            //  is loaded.
            //

            if (FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE )
                && (Scb->Header.AllocationSize.QuadPart != 0)
                && !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                LCN Lcn;
                VCN Vcn;
                VCN AllocatedVcns;

                AllocatedVcns = Int64ShraMod32(Scb->Header.AllocationSize.QuadPart, Scb->Vcb->ClusterShift);

                //
                //  First make sure the Mcb is loaded.
                //

                NtfsPreloadAllocation( IrpContext, Scb, 0, AllocatedVcns );

                //
                //  Now make sure the allocation is correctly loaded.  The last
                //  Vcn should correspond to the allocation size for the file.
                //

                if (!NtfsLookupLastNtfsMcbEntry( &Scb->Mcb,
                                                 &Vcn,
                                                 &Lcn ) ||
                    (Vcn + 1) != AllocatedVcns) {

                    NtfsRaiseStatus( IrpContext,
                                     STATUS_FILE_CORRUPT_ERROR,
                                     NULL,
                                     ThisFcb );
                }
            }

            //
            //  If this open is for an executable image we will want to update the
            //  last access time.
            //

            if (FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess, FILE_EXECUTE ) &&
                (Scb->AttributeTypeCode == $DATA)) {

                SetFlag( IrpSp->FileObject->Flags, FO_FILE_FAST_IO_READ );
            }

            //
            //  If everything has gone well so far, we may want to call the
            //  encryption callback if one is registered.  We do not do
            //  this for network opens or reparse points.
            //

            if (!ARGUMENT_PRESENT( NetworkInfo )) {

                NtfsEncryptionCreateCallback( IrpContext,
                                              Irp,
                                              IrpSp,
                                              *ThisScb,
                                              *ThisCcb,
                                              ThisFcb,
                                              ParentFcb,
                                              FALSE );
            }

            //
            //  Check if should insert the hash entry.
            //

            if ((CreateContext->FileHashLength != 0) &&
                !FlagOn( CcbFlags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                (Lcb->FileNameAttr->Flags != FILE_NAME_DOS) ) {

                //
                //  Remove any exising hash value.
                //

                if (FlagOn( Lcb->LcbState, LCB_STATE_VALID_HASH_VALUE )) {

                    NtfsRemoveHashEntriesForLcb( Lcb );
#ifdef NTFS_HASH_DATA
                    ThisFcb->Vcb->HashTable.OpenExistingConflict += 1;
#endif
                }

                NtfsInsertHashEntry( &ThisFcb->Vcb->HashTable,
                                     Lcb,
                                     CreateContext->FileHashLength,
                                     CreateContext->FileHashValue );
#ifdef NTFS_HASH_DATA
                ThisFcb->Vcb->HashTable.OpenExistingInsert += 1;
#endif
            }

            //
            //  Check if should insert the hash entry.
            //

            if ((CreateContext->FileHashLength != 0) &&
                !FlagOn( CcbFlags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                (Lcb->FileNameAttr->Flags != FILE_NAME_DOS) ) {

                //
                //  Remove any exising hash value.
                //

                if (FlagOn( Lcb->LcbState, LCB_STATE_VALID_HASH_VALUE )) {

                    NtfsRemoveHashEntriesForLcb( Lcb );
#ifdef NTFS_HASH_DATA
                    ThisFcb->Vcb->HashTable.OpenExistingConflict += 1;
#endif
                }

                NtfsInsertHashEntry( &ThisFcb->Vcb->HashTable,
                                     Lcb,
                                     CreateContext->FileHashLength,
                                     CreateContext->FileHashValue );
#ifdef NTFS_HASH_DATA
                ThisFcb->Vcb->HashTable.OpenExistingInsert += 1;
#endif
            }

            //
            //  If this operation was a supersede/overwrite or we created a new
            //  attribute stream then we want to perform the file record and
            //  directory update now.  Otherwise we will defer the updates until
            //  the user closes his handle.
            //

            if (NtfsIsStreamNew(Irp->IoStatus.Information)) {

                NtfsUpdateScbFromFileObject( IrpContext, IrpSp->FileObject, *ThisScb, TRUE );

                //
                //  Do the standard information, file sizes and then duplicate information
                //  if needed.
                //

                if (FlagOn( ThisFcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

                    NtfsUpdateStandardInformation( IrpContext, ThisFcb );
                }

                if (FlagOn( (*ThisScb)->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE )) {

                    NtfsWriteFileSizes( IrpContext,
                                        *ThisScb,
                                        &(*ThisScb)->Header.ValidDataLength.QuadPart,
                                        FALSE,
                                        TRUE,
                                        FALSE );
                }

                if (FlagOn( ThisFcb->InfoFlags, FCB_INFO_DUPLICATE_FLAGS )) {

                    ULONG FilterMatch;

                    NtfsUpdateDuplicateInfo( IrpContext, ThisFcb, Lcb, ParentScb );

                    if (ThisFcb->Vcb->NotifyCount != 0) {

                        //
                        //  We map the Fcb info flags into the dir notify flags.
                        //

                        FilterMatch = NtfsBuildDirNotifyFilter( IrpContext,
                                                                ThisFcb->InfoFlags | Lcb->InfoFlags );

                        //
                        //  If the filter match is non-zero, that means we also need to do a
                        //  dir notify call.
                        //

                        if ((FilterMatch != 0) && (*ThisCcb != NULL)) {

                            NtfsReportDirNotify( IrpContext,
                                                 ThisFcb->Vcb,
                                                 &(*ThisCcb)->FullFileName,
                                                 (*ThisCcb)->LastFileNameOffset,
                                                 NULL,
                                                 ((FlagOn( (*ThisCcb)->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                                   (*ThisCcb)->Lcb != NULL &&
                                                   (*ThisCcb)->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0) ?
                                                  &(*ThisCcb)->Lcb->Scb->ScbType.Index.NormalizedName :
                                                  NULL),
                                                 FilterMatch,
                                                 FILE_ACTION_MODIFIED,
                                                 ParentFcb );
                        }
                    }

                    NtfsUpdateLcbDuplicateInfo( ThisFcb, Lcb );
                    ThisFcb->InfoFlags = 0;
                }

                ClearFlag( ThisFcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

                NtfsAcquireFsrtlHeader( *ThisScb );
                ClearFlag( (*ThisScb)->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
                NtfsReleaseFsrtlHeader( *ThisScb );
            }
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsOpenExistingPrefixFcb );

        if (DecrementCloseCount) {

            InterlockedDecrement( &ThisFcb->CloseCount );
        }

        //
        //  If this operation was not totally successful we need to
        //  back out the following changes.
        //
        //      Modifications to the Info fields in the Fcb.
        //      Any changes to the allocation of the Scb.
        //      Any changes in the open counts in the various structures.
        //      Changes to the share access values in the Fcb.
        //

        if (!NT_SUCCESS( Status ) || AbnormalTermination()) {

            NtfsBackoutFailedOpens( IrpContext,
                                    IrpSp->FileObject,
                                    ThisFcb,
                                    *ThisScb,
                                    *ThisCcb );
        }

        DebugTrace( -1, Dbg, ("NtfsOpenExistingPrefixFcb:  Exit  ->  %08lx\n", Status) );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsOpenTargetDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB ThisFcb,
    IN PLCB ParentLcb OPTIONAL,
    IN OUT PUNICODE_STRING FullPathName,
    IN ULONG FinalNameLength,
    IN ULONG CreateFlags,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    )

/*++

Routine Description:

    This routine will perform the work of opening a target directory.  When the
    open is complete the Ccb and Lcb for this file object will be identical
    to any other open.  We store the full name for the rename in the
    file object but set the 'Length' field to include only the
    name upto the parent directory.  We use the 'MaximumLength' field to
    indicate the full name.

Arguments:

    Irp - This is the Irp for this create operation.

    IrpSp - This is the Irp stack pointer for the filesystem.

    ThisFcb - This is the Fcb for the directory to open.

    ParentLcb - This is the Lcb used to reach the parent directory.  If not
        specified, we will have to find it here.  There will be no Lcb to
        find if this Fcb was opened by Id.

    FullPathName - This is the normalized string for open operation.  It now
        contains the full name as it appears on the disk for this open path.
        It may not reach all the way to the root if the relative file object
        was opened by Id.

    FinalNameLength - This is the length of the final component in the
        full path name.

    CreateFlags - Flags for create operation - we care about the dos only component flag

    ThisScb - This is the address to store the Scb from this open.

    ThisCcb - This is the address to store the Ccb from this open.

Return Value:

    NTSTATUS - Indicating the outcome of opening this target directory.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG CcbFlags = CCB_FLAG_OPEN_AS_FILE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenTargetDirectory:  Entered\n") );

    if (FlagOn( CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT )) {

        SetFlag( CcbFlags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT );
    }

    //
    //  If the name doesn't begin with a backslash, remember this as
    //  an open by file ID.
    //

    if (FullPathName->Buffer[0] != L'\\') {

        SetFlag( CcbFlags, CCB_FLAG_OPEN_BY_FILE_ID );
    }

    //
    //  Modify the full path name so that the Maximum length field describes
    //  the full name and the Length field describes the name for the
    //  parent.
    //

    FullPathName->MaximumLength = FullPathName->Length;

    //
    //  If we don't have an Lcb, we will find it now.  We look at each Lcb
    //  for the parent Fcb and find one which matches the component
    //  ahead of the last component of the full name.
    //

    FullPathName->Length -= (USHORT)FinalNameLength;

    //
    //  If we are not at the root then subtract the bytes for the '\\'
    //  separator.
    //

    if (FullPathName->Length > sizeof( WCHAR )) {

        FullPathName->Length -= sizeof( WCHAR );
    }

    if (!ARGUMENT_PRESENT( ParentLcb ) && (FullPathName->Length != 0)) {

        PLIST_ENTRY Links;
        PLCB NextLcb;

        //
        //  If the length is two then the parent Lcb is the root Lcb.
        //

        if (FullPathName->Length == sizeof( WCHAR )
            && FullPathName->Buffer[0] == L'\\') {

            ParentLcb = (PLCB) ThisFcb->Vcb->RootLcb;

        } else {

            for (Links = ThisFcb->LcbQueue.Flink;
                 Links != &ThisFcb->LcbQueue;
                 Links = Links->Flink) {

                SHORT NameOffset;

                NextLcb = CONTAINING_RECORD( Links,
                                             LCB,
                                             FcbLinks );

                NameOffset = (SHORT) FullPathName->Length - (SHORT) NextLcb->ExactCaseLink.LinkName.Length;

                if (NameOffset >= 0) {

                    if (RtlEqualMemory( Add2Ptr( FullPathName->Buffer,
                                                 NameOffset ),
                                        NextLcb->ExactCaseLink.LinkName.Buffer,
                                        NextLcb->ExactCaseLink.LinkName.Length )) {

                        //
                        //  We found a matching Lcb.  Remember this and exit
                        //  the loop.
                        //

                        ParentLcb = NextLcb;
                        break;
                    }
                }
            }
        }
    }

    //
    //  Check this open for security access.
    //

    NtfsOpenCheck( IrpContext, ThisFcb, NULL, Irp );

    //
    //  Now actually open the attribute.
    //

    Status = NtfsOpenAttribute( IrpContext,
                                IrpSp,
                                ThisFcb->Vcb,
                                ParentLcb,
                                ThisFcb,
                                (ARGUMENT_PRESENT( ParentLcb )
                                 ? FullPathName->Length - ParentLcb->ExactCaseLink.LinkName.Length
                                 : 0),
                                NtfsFileNameIndex,
                                $INDEX_ALLOCATION,
                                (ThisFcb->CleanupCount == 0 ? SetShareAccess : CheckShareAccess),
                                UserDirectoryOpen,
                                FALSE,
                                CcbFlags,
                                NULL,
                                ThisScb,
                                ThisCcb );

    if (NT_SUCCESS( Status )) {

        //
        //  If the Scb does not have a normalized name then update it now.
        //

        if ((*ThisScb)->ScbType.Index.NormalizedName.Length == 0) {

            NtfsBuildNormalizedName( IrpContext,
                                     (*ThisScb)->Fcb,
                                     *ThisScb,
                                     &(*ThisScb)->ScbType.Index.NormalizedName );
        }

        //
        //  If the file object name is not from the root then use the normalized name
        //  to obtain the full name.
        //

        if (FlagOn( CcbFlags, CCB_FLAG_OPEN_BY_FILE_ID )) {

            USHORT BytesNeeded;
            USHORT Index;
            ULONG ComponentCount;
            ULONG NormalizedComponentCount;
            PWCHAR NewBuffer;
            PWCHAR NextChar;

            //
            //  Count the number of components in the directory portion of the
            //  name in the file object.
            //

            ComponentCount = 0;

            if (FullPathName->Length != 0) {

                ComponentCount = 1;
                Index = (FullPathName->Length / sizeof( WCHAR )) - 1;

                do {

                    if (FullPathName->Buffer[Index] == L'\\') {

                        ComponentCount += 1;
                    }

                    Index -= 1;

                } while (Index != 0);
            }

            //
            //  Count back this number of components in the normalized name.
            //

            NormalizedComponentCount = 0;
            Index = (*ThisScb)->ScbType.Index.NormalizedName.Length / sizeof( WCHAR );

            //
            //  Special case the root to point directory to the leading backslash.
            //

            if (Index == 1) {

                Index = 0;
            }

            while (NormalizedComponentCount < ComponentCount) {

                Index -= 1;
                while ((*ThisScb)->ScbType.Index.NormalizedName.Buffer[Index] != L'\\') {

                    Index -= 1;
                }

                NormalizedComponentCount += 1;
            }

            //
            //  Compute the size of the buffer needed for the full name.  This
            //  will be:
            //
            //      - Portion of normalized name used plus a separator
            //      - MaximumLength currently in FullPathName
            //

            BytesNeeded = (Index + 1) * sizeof( WCHAR );

            if (MAXUSHORT - FullPathName->MaximumLength < BytesNeeded) {

                NtfsRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER, NULL, NULL );
            }

            BytesNeeded += FullPathName->MaximumLength;

            NextChar =
            NewBuffer = NtfsAllocatePool( PagedPool, BytesNeeded );

            //
            //  Copy over the portion of the name from the normalized name.
            //

            if (Index != 0) {

                RtlCopyMemory( NextChar,
                               (*ThisScb)->ScbType.Index.NormalizedName.Buffer,
                               Index * sizeof( WCHAR ));

                NextChar += Index;
            }

            *NextChar = L'\\';
            NextChar += 1;

            //
            //  Now copy over the remaining part of the name from the file object.
            //

            RtlCopyMemory( NextChar,
                           FullPathName->Buffer,
                           FullPathName->MaximumLength );

            //
            //  Now free the pool from the file object and update with the newly
            //  allocated pool.  Don't forget to update the Ccb to point to this new
            //  buffer.
            //

            NtfsFreePool( FullPathName->Buffer );

            FullPathName->Buffer = NewBuffer;
            FullPathName->MaximumLength =
            FullPathName->Length = BytesNeeded;
            FullPathName->Length -= (USHORT) FinalNameLength;

            if (FullPathName->Length > sizeof( WCHAR )) {

                FullPathName->Length -= sizeof( WCHAR );
            }

            (*ThisCcb)->FullFileName = *FullPathName;
            (*ThisCcb)->LastFileNameOffset = FullPathName->MaximumLength - (USHORT) FinalNameLength;
        }

        Irp->IoStatus.Information = (FlagOn( CreateFlags, CREATE_FLAG_FOUND_ENTRY ) ? FILE_EXISTS : FILE_DOES_NOT_EXIST);
    }

    DebugTrace( -1, Dbg, ("NtfsOpenTargetDirectory:  Exit -> %08lx\n", Status) );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsOpenFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PSCB ParentScb,
    IN PINDEX_ENTRY IndexEntry,
    IN UNICODE_STRING FullPathName,
    IN UNICODE_STRING FinalName,
    IN UNICODE_STRING AttrName,
    IN UNICODE_STRING AttrCodeName,
    IN PQUICK_INDEX QuickIndex,
    IN ULONG CreateFlags,
    IN PVOID NetworkInfo OPTIONAL,
    IN PCREATE_CONTEXT CreateContext,
    OUT PFCB *CurrentFcb,
    OUT PLCB *LcbForTeardown,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    )

/*++

Routine Description:

    This routine is called when we need to open an attribute on a file
    which currently exists.  We have the ParentScb and the file reference
    for the existing file.  We will create the Fcb for this file and the
    link between it and its parent directory.  We will add this link to the
    prefix table as well as the link for its parent Scb if specified.

    On entry the caller owns the parent Scb.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the Irp stack pointer for the filesystem.

    ParentScb - This is the Scb for the parent directory.

    IndexEntry - This is the index entry from the disk for this file.

    FullPathName - This is the string containing the full path name of
        this Fcb.  Meaningless for an open by Id call.

    FinalName - This is the string for the final component only.  If the length
        is zero then this is an open by Id call.

    AttrName - This is the name of the attribute to open.

    AttriCodeName - This is the name of the attribute code to open.

    CreateFlags - Flags for create option - we use open by id / ignore case / trailing backslash and
        dos only component

    NetworkInfo - If specified then this call is a fast open call to query
        the network information.  We don't update any of the in-memory structures
        for this.

    CreateContext - Context with create variables.

    CurrentFcb - This is the address to store the Fcb if we successfully find
        one in the Fcb/Scb tree.

    LcbForTeardown - This is the Lcb to use in teardown if we add an Lcb
        into the tree.

    ThisScb - This is the address to store the Scb from this open.

    ThisCcb - This is the address to store the Ccb from this open.

Return Value:

    NTSTATUS - Indicates the result of this create file operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTRIBUTE_TYPE_CODE AttrTypeCode;
    ULONG CcbFlags = 0;
    BOOLEAN IndexedAttribute;
    PFILE_NAME IndexFileName;
    BOOLEAN UpdateFcbInfo = FALSE;

    OLD_SCB_SNAPSHOT ScbSizes;
    BOOLEAN HaveScbSizes = FALSE;

    PVCB Vcb = ParentScb->Vcb;

    PFCB LocalFcbForTeardown = NULL;
    PFCB ThisFcb;
    PLCB ThisLcb;
    BOOLEAN DecrementCloseCount = FALSE;
    BOOLEAN ExistingFcb;
    BOOLEAN AcquiredFcbTable = FALSE;

    FILE_REFERENCE PreviousFileReference;
    BOOLEAN DroppedParent = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenFile:  Entered\n") );

    IndexFileName = (PFILE_NAME) NtfsFoundIndexEntry( IndexEntry );

    if (FlagOn( CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT )) {

        SetFlag( CcbFlags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT );
    }

    //
    //  The first thing to do is to figure out what type
    //  of attribute the caller is trying to open.  This involves the
    //  directory/non-directory bits, the attribute name and code strings,
    //  the type of file, whether he passed in an ea buffer and whether
    //  there was a trailing backslash.
    //

    if (NtfsEqualMftRef( &IndexEntry->FileReference,
                         &VolumeFileReference )) {

        if (AttrName.Length != 0
            || AttrCodeName.Length != 0) {

            Status = STATUS_INVALID_PARAMETER;
            DebugTrace( -1, Dbg, ("NtfsOpenFile:  Exit  ->  %08lx\n", Status) );

            return Status;
        }

        SetFlag( IrpContext->State,
                 IRP_CONTEXT_STATE_ACQUIRE_EX | IRP_CONTEXT_STATE_DASD_OPEN );

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    Status = NtfsCheckValidAttributeAccess( IrpSp,
                                            Vcb,
                                            &IndexFileName->Info,
                                            &AttrName,
                                            AttrCodeName,
                                            CreateFlags,
                                            &AttrTypeCode,
                                            &CcbFlags,
                                            &IndexedAttribute );

    if (!NT_SUCCESS( Status )) {

        DebugTrace( -1, Dbg, ("NtfsOpenFile:  Exit  ->  %08lx\n", Status) );

        return Status;
    }

    NtfsAcquireFcbTable( IrpContext, Vcb );
    AcquiredFcbTable = TRUE;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We know that it is safe to continue the open.  We start by creating
        //  an Fcb and Lcb for this file.  It is possible that the Fcb and Lcb
        //  both exist.  If the Lcb exists, then the Fcb must definitely exist.
        //  We create the Fcb first, if we need to update the Fcb info structure
        //  we copy the one from the index entry.  We look at the Fcb to discover
        //  if it has any links, if it does then we make this the last Fcb we
        //  reached.  If it doesn't then we have to clean it up from here.
        //

        ThisFcb = NtfsCreateFcb( IrpContext,
                                 ParentScb->Vcb,
                                 IndexEntry->FileReference,
                                 BooleanFlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ),
                                 BooleanFlagOn( IndexFileName->Info.FileAttributes,
                                                DUP_FILE_NAME_INDEX_PRESENT ),
                                 &ExistingFcb );

        ThisFcb->ReferenceCount += 1;

        //
        //  If we created this Fcb we must make sure to start teardown
        //  on it.
        //

        if (!ExistingFcb) {

            LocalFcbForTeardown = ThisFcb;

        } else {

            *LcbForTeardown = NULL;
            *CurrentFcb = ThisFcb;
        }

        //
        //  Try to do a fast acquire, otherwise we need to release
        //  the Fcb table, acquire the Fcb, acquire the Fcb table to
        //  dereference Fcb.
        //

        if (FlagOn( ThisFcb->FcbState, FCB_STATE_SYSTEM_FILE) &&
            (NtfsSegmentNumber( &ParentScb->Fcb->FileReference ) == ROOT_FILE_NAME_INDEX_NUMBER)) {

            ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) );

            NtfsReleaseFcbTable( IrpContext, Vcb );
            NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, 0 );
            NtfsAcquireFcbTable( IrpContext, Vcb );

        } else if (!NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, ACQUIRE_DONT_WAIT )) {

            //
            //  Remember the current file reference in the index entry.
            //  We want to be able to detect whether an entry is removed.
            //

            PreviousFileReference = IndexEntry->FileReference;
            DroppedParent = TRUE;

            ParentScb->Fcb->ReferenceCount += 1;
            InterlockedIncrement( &ParentScb->CleanupCount );

            //
            //  Set the IrpContext to acquire paging io resources if our target
            //  has one.  This will lock the MappedPageWriter out of this file.
            //

            if (ThisFcb->PagingIoResource != NULL) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
            }

            NtfsReleaseScbWithPaging( IrpContext, ParentScb );
            NtfsReleaseFcbTable( IrpContext, Vcb );
            NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, 0 );
            NtfsAcquireExclusiveScb( IrpContext, ParentScb );
            NtfsAcquireFcbTable( IrpContext, Vcb );
            InterlockedDecrement( &ParentScb->CleanupCount );
            ParentScb->Fcb->ReferenceCount -= 1;
        }

        ThisFcb->ReferenceCount -= 1;

        NtfsReleaseFcbTable( IrpContext, Vcb );
        AcquiredFcbTable = FALSE;

        //
        //  Check if something happened to this file in the window where
        //  we dropped the parent.
        //

        if (DroppedParent) {

            //
            //  Check if the file has been deleted.
            //

            if (ExistingFcb && (ThisFcb->LinkCount == 0)) {

                try_return( Status = STATUS_DELETE_PENDING );

            //
            //  Check if the link may have been deleted.
            //

            } else if (!NtfsEqualMftRef( &IndexEntry->FileReference,
                                         &PreviousFileReference )) {

                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }
        }

        //
        //  If the Fcb existed and this is a paging file then either return
        //  sharing violation or force the Fcb and Scb's to go away.
        //  Do this for the case where the user is opening a paging file
        //  but the Fcb is non-paged or the user is opening a non-paging
        //  file and the Fcb is for a paging file.
        //

        if (ExistingFcb &&

            ((FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ) &&
              !FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE )) ||

             (FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE ) &&
              !FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE )))) {

            if (ThisFcb->CleanupCount != 0) {

                try_return( Status = STATUS_SHARING_VIOLATION );

            //
            //  If we have a persistent paging file then give up and
            //  return SHARING_VIOLATION.
            //

            } else if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP )) {

                try_return( Status = STATUS_SHARING_VIOLATION );

            //
            //  If there was an existing Fcb for a paging file we need to force
            //  all of the Scb's to be torn down.  The easiest way to do this
            //  is to flush and purge all of the Scb's (saving any attribute list
            //  for last) and then raise LOG_FILE_FULL to allow this request to
            //  be posted.
            //

            } else {

                //
                //  Reference the Fcb so it won't go away on any flushes.
                //

                InterlockedIncrement( &ThisFcb->CloseCount );
                DecrementCloseCount = TRUE;

                //
                //  Flush and purge this Fcb.
                //

                NtfsFlushAndPurgeFcb( IrpContext, ThisFcb );

                InterlockedDecrement( &ThisFcb->CloseCount );
                DecrementCloseCount = FALSE;

                //
                //  Force this request to be posted and then raise
                //  CANT_WAIT.  The Fcb should be torn down in the finally
                //  clause below.
                //

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );

                //
                //  If we are posting then we may want to use the next stack location.
                //

                if (IrpContext->Union.OplockCleanup->CompletionContext != NULL) {

                    NtfsPrepareForIrpCompletion( IrpContext,
                                                 IrpContext->OriginatingIrp,
                                                 IrpContext->Union.OplockCleanup->CompletionContext );
                }

                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }
        }

        //
        //  We perform a check to see whether we will allow the system
        //  files to be opened.
        //
        //  No test to make if this is not a system file or it is the VolumeDasd file.
        //  The ACL will protect the volume file.
        //

        if (FlagOn( ThisFcb->FcbState, FCB_STATE_SYSTEM_FILE ) &&
            (NtfsSegmentNumber( &ThisFcb->FileReference ) != VOLUME_DASD_NUMBER) &&
            NtfsProtectSystemFiles) {

            if (!NtfsCheckValidFileAccess( ThisFcb, IrpSp )) {

                Status = STATUS_ACCESS_DENIED;
                DebugTrace( 0, Dbg, ("Invalid access to system files\n") );
                try_return( NOTHING );
            }
        }

        //
        //  If the Fcb Info field needs to be initialized, we do so now.
        //  We read this information from the disk as the duplicate information
        //  in the index entry is not guaranteed to be correct.
        //

        if (!FlagOn( ThisFcb->FcbState, FCB_STATE_DUP_INITIALIZED )) {

            HaveScbSizes = NtfsUpdateFcbInfoFromDisk( IrpContext,
                                                      TRUE,
                                                      ThisFcb,
                                                      &ScbSizes );

            //
            //  Remember the last access time in the directory entry.
            //

            ThisFcb->Info.LastAccessTime = IndexFileName->Info.LastAccessTime;

            NtfsConditionallyFixupQuota( IrpContext, ThisFcb );
        }

        //
        //  We have the actual data from the disk stored in the duplicate
        //  information in the Fcb.  We compare this with the duplicate
        //  information in the DUPLICATE_INFORMATION structure in the
        //  filename attribute.  If they don't match, we remember that
        //  we need to update the duplicate information.
        //

        if (!RtlEqualMemory( &ThisFcb->Info,
                             &IndexFileName->Info,
                             FIELD_OFFSET( DUPLICATED_INFORMATION, LastAccessTime ))) {

            UpdateFcbInfo = TRUE;

            //
            //  We expect this to be very rare but let's find the ones being changed.
            //

            if (ThisFcb->Info.CreationTime != IndexFileName->Info.CreationTime) {

                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_CREATE );
            }

            if (ThisFcb->Info.LastModificationTime != IndexFileName->Info.LastModificationTime) {

                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_LAST_MOD );
            }

            if (ThisFcb->Info.LastChangeTime != IndexFileName->Info.LastChangeTime) {

                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_LAST_CHANGE );
            }
        }

        if (!RtlEqualMemory( &ThisFcb->Info.AllocatedLength,
                             &IndexFileName->Info.AllocatedLength,
                             FIELD_OFFSET( DUPLICATED_INFORMATION, Reserved ) -
                                FIELD_OFFSET( DUPLICATED_INFORMATION, AllocatedLength ))) {

            UpdateFcbInfo = TRUE;

            if (ThisFcb->Info.AllocatedLength != IndexFileName->Info.AllocatedLength) {

                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
            }

            if (ThisFcb->Info.FileSize != IndexFileName->Info.FileSize) {

                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_FILE_SIZE );
            }

            if (ThisFcb->Info.FileAttributes != IndexFileName->Info.FileAttributes) {

                ASSERTMSG( "conflict with flush",
                           NtfsIsSharedFcb( ThisFcb ) ||
                           (ThisFcb->PagingIoResource != NULL &&
                            NtfsIsSharedFcbPagingIo( ThisFcb )) );

                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
            }

            if (ThisFcb->Info.PackedEaSize != IndexFileName->Info.PackedEaSize) {

                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_EA_SIZE );
            }
        }

        //
        //  Don't update last access unless more than an hour.
        //

        if (NtfsCheckLastAccess( IrpContext, ThisFcb )) {

            SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_LAST_ACCESS );
            UpdateFcbInfo = TRUE;
        }

        //
        //  Now get the link for this traversal.
        //

        ThisLcb = NtfsCreateLcb( IrpContext,
                                 ParentScb,
                                 ThisFcb,
                                 FinalName,
                                 IndexFileName->Flags,
                                 NULL );

        //
        //  We now know the Fcb is linked into the tree.
        //

        LocalFcbForTeardown = NULL;

        *LcbForTeardown = ThisLcb;
        *CurrentFcb = ThisFcb;

        //
        //  If the link has been deleted, we cut off the open.
        //

        if (LcbLinkIsDeleted( ThisLcb )) {

            try_return( Status = STATUS_DELETE_PENDING );
        }

        //
        //  We now call the worker routine to open an attribute on an existing file.
        //

        Status = NtfsOpenAttributeInExistingFile( IrpContext,
                                                  Irp,
                                                  IrpSp,
                                                  ThisLcb,
                                                  ThisFcb,
                                                  (FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID )
                                                   ? 0
                                                   : FullPathName.Length - FinalName.Length),
                                                  AttrName,
                                                  AttrTypeCode,
                                                  CcbFlags,
                                                  CreateFlags,
                                                  NetworkInfo,
                                                  ThisScb,
                                                  ThisCcb );

        //
        //  Check to see if we should insert any prefix table entries
        //  and update the last access time.
        //  We skip this for reparse points as *ThisScb and *ThisCcb may be NULL.
        //

        if (NT_SUCCESS( Status ) &&
            (Status != STATUS_PENDING) &&
            (Status != STATUS_REPARSE)) {

            PSCB Scb = *ThisScb;

            //
            //  Go ahead and insert this link into the splay tree if it is not
            //  a system file.
            //

            if (!FlagOn( ThisLcb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

                if ((CreateContext->FileHashLength != 0) &&
                    !FlagOn( CcbFlags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                    (ThisLcb->FileNameAttr->Flags != FILE_NAME_DOS) ) {

                    //
                    //  Remove any exising hash value.
                    //

                    if (FlagOn( ThisLcb->LcbState, LCB_STATE_VALID_HASH_VALUE )) {

                        NtfsRemoveHashEntriesForLcb( ThisLcb );
#ifdef NTFS_HASH_DATA
                        ThisFcb->Vcb->HashTable.OpenFileConflict += 1;
#endif
                    }

                    NtfsInsertHashEntry( &Vcb->HashTable,
                                         ThisLcb,
                                         CreateContext->FileHashLength,
                                         CreateContext->FileHashValue );
#ifdef NTFS_HASH_DATA
                    Vcb->HashTable.OpenFileInsert += 1;
#endif
                }

                NtfsInsertPrefix( ThisLcb, CreateFlags );
            }

            //
            //  If this is a directory open and the normalized name is not in
            //  the Scb then do so now.
            //

            if ((SafeNodeType( *ThisScb ) == NTFS_NTC_SCB_INDEX) &&
                ((*ThisScb)->ScbType.Index.NormalizedName.Length == 0)) {

                //
                //  We may be able to use the parent.
                //

                if (ParentScb->ScbType.Index.NormalizedName.Length != 0) {

                    NtfsUpdateNormalizedName( IrpContext,
                                              ParentScb,
                                              *ThisScb,
                                              IndexFileName,
                                              FALSE );

                } else {

                    NtfsBuildNormalizedName( IrpContext,
                                             (*ThisScb)->Fcb,
                                             *ThisScb,
                                             &(*ThisScb)->ScbType.Index.NormalizedName );
                }
            }

            //
            //  Perform the last bit of work.  If this a user file open, we need
            //  to check if we initialize the Scb.
            //

            if (!IndexedAttribute) {

                if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                    //
                    //  We may have the sizes from our Fcb update call.
                    //

                    if (HaveScbSizes &&
                        (AttrTypeCode == $DATA) &&
                        (AttrName.Length == 0) &&
                        !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_CREATE_MOD_SCB )) {

                        NtfsUpdateScbFromMemory( Scb, &ScbSizes );

                    } else {

                        NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
                    }
                }

                //
                //  Let's check if we need to set the cache bit.
                //

                if (!FlagOn( IrpSp->Parameters.Create.Options,
                             FILE_NO_INTERMEDIATE_BUFFERING )) {

                    SetFlag( IrpSp->FileObject->Flags, FO_CACHE_SUPPORTED );
                }
            }

            //
            //  If this is the paging file, we want to be sure the allocation
            //  is loaded.
            //

            if (FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE ) &&
                (Scb->Header.AllocationSize.QuadPart != 0) &&
                !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                LCN Lcn;
                VCN Vcn;
                VCN AllocatedVcns;

                AllocatedVcns = Int64ShraMod32(Scb->Header.AllocationSize.QuadPart, Scb->Vcb->ClusterShift);

                NtfsPreloadAllocation( IrpContext, Scb, 0, AllocatedVcns );

                //
                //  Now make sure the allocation is correctly loaded.  The last
                //  Vcn should correspond to the allocation size for the file.
                //

                if (!NtfsLookupLastNtfsMcbEntry( &Scb->Mcb,
                                                 &Vcn,
                                                 &Lcn ) ||
                    (Vcn + 1) != AllocatedVcns) {

                    NtfsRaiseStatus( IrpContext,
                                     STATUS_FILE_CORRUPT_ERROR,
                                     NULL,
                                     ThisFcb );
                }
            }

            //
            //  If this open is for an executable image we update the last
            //  access time.
            //

            if (FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess, FILE_EXECUTE ) &&
                (Scb->AttributeTypeCode == $DATA)) {

                SetFlag( IrpSp->FileObject->Flags, FO_FILE_FAST_IO_READ );
            }

            //
            //  Let's update the quick index information in the Lcb.
            //

            RtlCopyMemory( &ThisLcb->QuickIndex,
                           QuickIndex,
                           sizeof( QUICK_INDEX ));

            //
            //  If everything has gone well so far, we may want to call the
            //  encryption callback if one is registered.  We do not do
            //  this for network opens or reparse points.
            //

            if (!ARGUMENT_PRESENT( NetworkInfo )) {

                NtfsEncryptionCreateCallback( IrpContext,
                                              Irp,
                                              IrpSp,
                                              *ThisScb,
                                              *ThisCcb,
                                              ThisFcb,
                                              ParentScb->Fcb,
                                              FALSE );
            }

            //
            //  If this operation was a supersede/overwrite or we created a new
            //  attribute stream then we want to perform the file record and
            //  directory update now.  Otherwise we will defer the updates until
            //  the user closes his handle.
            //

            if (UpdateFcbInfo ||
                NtfsIsStreamNew(Irp->IoStatus.Information)) {

                NtfsUpdateScbFromFileObject( IrpContext, IrpSp->FileObject, *ThisScb, TRUE );

                //
                //  Do the standard information, file sizes and then duplicate information
                //  if needed.
                //

                if (FlagOn( ThisFcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

                    NtfsUpdateStandardInformation( IrpContext, ThisFcb );
                }

                if (FlagOn( (*ThisScb)->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE )) {

                    NtfsWriteFileSizes( IrpContext,
                                        *ThisScb,
                                        &(*ThisScb)->Header.ValidDataLength.QuadPart,
                                        FALSE,
                                        TRUE,
                                        FALSE );
                }

                if (FlagOn( ThisFcb->InfoFlags, FCB_INFO_DUPLICATE_FLAGS )) {

                    ULONG FilterMatch;

                    NtfsUpdateDuplicateInfo( IrpContext, ThisFcb, *LcbForTeardown, ParentScb );

                    if (Vcb->NotifyCount != 0) {

                        //
                        //  We map the Fcb info flags into the dir notify flags.
                        //

                        FilterMatch = NtfsBuildDirNotifyFilter( IrpContext,
                                                                ThisFcb->InfoFlags | ThisLcb->InfoFlags );

                        //
                        //  If the filter match is non-zero, that means we also need to do a
                        //  dir notify call.
                        //

                        if ((FilterMatch != 0) && (*ThisCcb != NULL)) {

                            NtfsReportDirNotify( IrpContext,
                                                 ThisFcb->Vcb,
                                                 &(*ThisCcb)->FullFileName,
                                                 (*ThisCcb)->LastFileNameOffset,
                                                 NULL,
                                                 ((FlagOn( (*ThisCcb)->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                                   ((*ThisCcb)->Lcb != NULL) &&
                                                   ((*ThisCcb)->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                                  &(*ThisCcb)->Lcb->Scb->ScbType.Index.NormalizedName :
                                                  NULL),
                                                 FilterMatch,
                                                 FILE_ACTION_MODIFIED,
                                                 ParentScb->Fcb );
                        }
                    }

                    NtfsUpdateLcbDuplicateInfo( ThisFcb, *LcbForTeardown );
                    ThisFcb->InfoFlags = 0;
                }

                ClearFlag( ThisFcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

                NtfsAcquireFsrtlHeader( *ThisScb );
                ClearFlag( (*ThisScb)->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
                NtfsReleaseFsrtlHeader( *ThisScb );
            }
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsOpenFile );

        if (AcquiredFcbTable) {

            NtfsReleaseFcbTable( IrpContext, Vcb );
        }

        //
        //  If this operation was not totally successful we need to
        //  back out the following changes.
        //
        //      Modifications to the Info fields in the Fcb.
        //      Any changes to the allocation of the Scb.
        //      Any changes in the open counts in the various structures.
        //      Changes to the share access values in the Fcb.
        //

        if (!NT_SUCCESS( Status ) || AbnormalTermination()) {

            NtfsBackoutFailedOpens( IrpContext,
                                    IrpSp->FileObject,
                                    ThisFcb,
                                    *ThisScb,
                                    *ThisCcb );

        }

        if (DecrementCloseCount) {

            InterlockedDecrement( &ThisFcb->CloseCount );
        }

        //
        //  If we are to cleanup the Fcb we, look to see if we created it.
        //  If we did we can call our teardown routine.  Otherwise we
        //  leave it alone.
        //

        if ((LocalFcbForTeardown != NULL) &&
            (Status != STATUS_PENDING)) {

            NtfsTeardownStructures( IrpContext,
                                    ThisFcb,
                                    NULL,
                                    (BOOLEAN) (IrpContext->TransactionId != 0),
                                    0,
                                    NULL );
        }

        DebugTrace( -1, Dbg, ("NtfsOpenFile:  Exit  ->  %08lx\n", Status) );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsCreateNewFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PSCB ParentScb,
    IN PFILE_NAME FileNameAttr,
    IN UNICODE_STRING FullPathName,
    IN UNICODE_STRING FinalName,
    IN UNICODE_STRING AttrName,
    IN UNICODE_STRING AttrCodeName,
    IN ULONG CreateFlags,
    IN PINDEX_CONTEXT *IndexContext,
    IN PCREATE_CONTEXT CreateContext,
    OUT PFCB *CurrentFcb,
    OUT PLCB *LcbForTeardown,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    )

/*++

Routine Description:

    This routine is called when we need to open an attribute on a file
    which does not exist yet.  We have the ParentScb and the name to use
    for this create.  We will attempt to create the file and necessary
    attributes.  This will cause us to create an Fcb and the link between
    it and its parent Scb.  We will add this link to the prefix table as
    well as the link for its parent Scb if specified.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the Irp stack pointer for the filesystem.

    ParentScb - This is the Scb for the parent directory.

    FileNameAttr - This is the file name attribute we used to perform the
        search.  The file name is correct but the other fields need to
        be initialized.

    FullPathName - This is the string containing the full path name of
        this Fcb.

    FinalName - This is the string for the final component only.

    AttrName - This is the name of the attribute to open.

    AttriCodeName - This is the name of the attribute code to open.

    CreateFlags - Flags for create - we care about ignore case, dos only component,
        trailingbackslashes and open by id

    IndexContext - If this contains a non-NULL value then this is the result of a
        lookup which did not find the file.  It can be used to insert the name into the index.
        We will clean it up here in the error path to prevent a deadlock if we call
        TeardownStructures within this routine.

    CreateContext - Context with create variables.

    CurrentFcb - This is the address to store the Fcb if we successfully find
        one in the Fcb/Scb tree.

    LcbForTeardown - This is the Lcb to use in teardown if we add an Lcb
        into the tree.

    ThisScb - This is the address to store the Scb from this open.

    ThisCcb - This is the address to store the Ccb from this open.

    Tunnel - This is the property tunnel to search for restoration

Return Value:

    NTSTATUS - Indicates the result of this create file operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PVCB Vcb;

    ULONG CcbFlags = 0;
    ULONG UsnReasons = 0;
    BOOLEAN IndexedAttribute;
    ATTRIBUTE_TYPE_CODE AttrTypeCode;

    BOOLEAN CleanupAttrContext = FALSE;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PBCB FileRecordBcb = NULL;
    LONGLONG FileRecordOffset;
    FILE_REFERENCE ThisFileReference;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;

    PSCB Scb;
    PLCB ThisLcb = NULL;
    PFCB ThisFcb = NULL;
    BOOLEAN AcquiredFcbTable = FALSE;
    BOOLEAN RemovedFcb = FALSE;
    BOOLEAN DecrementCloseCount = FALSE;

    PACCESS_STATE AccessState;
    BOOLEAN ReturnedExistingFcb;

    BOOLEAN LoggedFileRecord = FALSE;

    BOOLEAN HaveTunneledInformation = FALSE;

    NAME_PAIR NamePair;
    NTFS_TUNNELED_DATA TunneledData;
    ULONG TunneledDataSize;
    ULONG OwnerId;
    PQUOTA_CONTROL_BLOCK QuotaControl = NULL;

    PSHARED_SECURITY SharedSecurity = NULL;

    ULONG CreateDisposition;

    VCN Cluster;
    LCN Lcn;
    VCN Vcn;

    UCHAR FileNameFlags;
#if (DBG || defined( NTFS_FREE_ASSERTS ))
    BOOLEAN Acquired;
#endif

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCreateNewFile:  Entered\n") );

    NtfsInitializeNamePair(&NamePair);

    if (FlagOn( CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT )) {

        SetFlag( CcbFlags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT );
    }

    //
    //  We will do all the checks to see if this open can fail.
    //  This includes checking the specified attribute names, checking
    //  the security access and checking the create disposition.
    //

    CreateDisposition = (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff;

    if ((CreateDisposition == FILE_OPEN) ||
        (CreateDisposition == FILE_OVERWRITE)) {

        Status = STATUS_OBJECT_NAME_NOT_FOUND;

        DebugTrace( -1, Dbg, ("NtfsCreateNewFile:  Exit -> %08lx\n", Status) );
        return Status;

    } else if (FlagOn( IrpSp->Parameters.Create.Options,
                       FILE_DIRECTORY_FILE ) &&
               (CreateDisposition == FILE_OVERWRITE_IF)) {

        Status = STATUS_OBJECT_NAME_INVALID;

        DebugTrace( -1, Dbg, ("NtfsCreateNewFile:  Exit -> %08lx\n", Status) );
        return Status;
    }

    Vcb = ParentScb->Vcb;

    //
    //  Catch the case where the volume is read-only and the user wanted to create a file
    //  if it didn't already exist.
    //

    if (NtfsIsVolumeReadOnly( Vcb ) &&
        (CreateDisposition == FILE_OPEN_IF)) {

        Status = STATUS_MEDIA_WRITE_PROTECTED;
        DebugTrace( -1, Dbg, ("NtfsCreateNewFile:  Exit -> %08lx\n", Status) );
        return Status;
    }

    //
    //  Better have caught all cases now.
    //

    ASSERT( !NtfsIsVolumeReadOnly( Vcb ));

    Status = NtfsCheckValidAttributeAccess( IrpSp,
                                            Vcb,
                                            NULL,
                                            &AttrName,
                                            AttrCodeName,
                                            CreateFlags,
                                            &AttrTypeCode,
                                            &CcbFlags,
                                            &IndexedAttribute );

    if (!NT_SUCCESS( Status )) {

        DebugTrace( -1, Dbg, ("NtfsCreateNewFile:  Exit  ->  %08lx\n", Status) );

        return Status;
    }

    //
    //  Fail this request if this is an indexed attribute and the TEMPORARY
    //  bit is set.
    //

    if (IndexedAttribute &&
        FlagOn( IrpSp->Parameters.Create.FileAttributes, FILE_ATTRIBUTE_TEMPORARY )) {

        DebugTrace( -1, Dbg, ("NtfsCreateNewFile:  Exit -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We won't allow someone to create a read-only file with DELETE_ON_CLOSE.
    //

    if (FlagOn( IrpSp->Parameters.Create.FileAttributes, FILE_ATTRIBUTE_READONLY ) &&
        FlagOn( IrpSp->Parameters.Create.Options, FILE_DELETE_ON_CLOSE )) {

        DebugTrace( -1, Dbg, ("NtfsCreateNewFile:  Exit -> %08lx\n", STATUS_CANNOT_DELETE) );
        return STATUS_CANNOT_DELETE;
    }

    //
    //  We do not allow that anything be created in a directory that is a reparse
    //  point. We verify that the parent is not in this category.
    //

    if (IsDirectory( &ParentScb->Fcb->Info ) &&
        (FlagOn( ParentScb->Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT ))) {

        DebugTrace( -1, Dbg, ("NtfsCreateNewFile:  Exit -> %08lx\n", STATUS_DIRECTORY_IS_A_REPARSE_POINT) );
        return STATUS_DIRECTORY_IS_A_REPARSE_POINT;
    }

    //
    //  We do not allow anything to be created in a system directory (unless it is the root directory).
    //  we only allow creates for indices and data streams
    //

    if ((FlagOn( ParentScb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE ) &&
         (ParentScb != Vcb->RootIndexScb)) ||
        !((AttrTypeCode == $DATA) || (AttrTypeCode == $INDEX_ALLOCATION))) {

        DebugTrace( -1, Dbg, ("NtfsCreateNewFile:  Exit -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Now perform the security checks.  The first is to check if we
        //  may create a file in the parent.  The second checks if the user
        //  desires ACCESS_SYSTEM_SECURITY and has the required privilege.
        //

        AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;
        if (!FlagOn( AccessState->Flags, TOKEN_HAS_RESTORE_PRIVILEGE )) {

            NtfsCreateCheck( IrpContext, ParentScb->Fcb, Irp );
        }

        //
        //  Check if the remaining privilege includes ACCESS_SYSTEM_SECURITY.
        //  This is only the case if we skipped the NtfsCreateCheck because of restore
        //  privileges above.  We still need to get this bit in or set sacl security won't work
        //  Normally NtfsCreateCheck calls SeAccessCheck which does this implicitly
        //

        if (FlagOn( AccessState->RemainingDesiredAccess, ACCESS_SYSTEM_SECURITY )) {

            if (!SeSinglePrivilegeCheck( NtfsSecurityPrivilege,
                                         UserMode )) {

                NtfsRaiseStatus( IrpContext, STATUS_PRIVILEGE_NOT_HELD, NULL, NULL );
            }

            //
            //  Move this privilege from the Remaining access to Granted access.
            //

            ClearFlag( AccessState->RemainingDesiredAccess, ACCESS_SYSTEM_SECURITY );
            SetFlag( AccessState->PreviouslyGrantedAccess, ACCESS_SYSTEM_SECURITY );
        }

        //
        //  We want to allow this user maximum access to this file.  We will
        //  use his desired access and check if he specified MAXIMUM_ALLOWED.
        //

        SetFlag( AccessState->PreviouslyGrantedAccess,
                 AccessState->RemainingDesiredAccess );

        if (FlagOn( AccessState->PreviouslyGrantedAccess, MAXIMUM_ALLOWED )) {

            SetFlag( AccessState->PreviouslyGrantedAccess, FILE_ALL_ACCESS );
            ClearFlag( AccessState->PreviouslyGrantedAccess, MAXIMUM_ALLOWED );
        }

        AccessState->RemainingDesiredAccess = 0;

        //
        //  Find/cache the security descriptor being passed in.  This call may
        //  create new data in the security indexes/stream and commits
        //  before any subsequent disk modifications occur.
        //

        SharedSecurity = NtfsCacheSharedSecurityForCreate( IrpContext, ParentScb->Fcb );

        //
        //  Make sure the parent has a normalized name.  We want to construct it now
        //  while we can still walk up the Lcb queue.  Otherwise we can deadlock
        //  on the Mft and other resources.
        //

        if ((AttrTypeCode == $INDEX_ALLOCATION) &&
            (ParentScb->ScbType.Index.NormalizedName.Length == 0)) {

            NtfsBuildNormalizedName( IrpContext,
                                     ParentScb->Fcb,
                                     ParentScb,
                                     &ParentScb->ScbType.Index.NormalizedName );
        }

        //
        //  Decide whether there's anything in the tunnel cache for this create.
        //  We don't do tunnelling in POSIX mode, hence the test for IgnoreCase.
        //

        if (!IndexedAttribute && FlagOn( CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

            TunneledDataSize = sizeof(NTFS_TUNNELED_DATA);

            if (FsRtlFindInTunnelCache( &Vcb->Tunnel,
                                        *(PULONGLONG)&ParentScb->Fcb->FileReference,
                                        &FinalName,
                                        &NamePair.Short,
                                        &NamePair.Long,
                                        &TunneledDataSize,
                                        &TunneledData)) {

                ASSERT( TunneledDataSize == sizeof(NTFS_TUNNELED_DATA) );

                HaveTunneledInformation = TRUE;

                //
                //  If we have tunneled data and there's an object in the
                //  tunnel cache for this file, we need to acquire the object
                //  id index now (before acquiring any quota resources) to
                //  prevent a deadlock.  If there's no object id, then we
                //  won't try to set the object id later, and there's no
                //  deadlock to worry about.
                //

                if (TunneledData.HasObjectId) {

                    NtfsAcquireExclusiveScb( IrpContext, Vcb->ObjectIdTableScb );

                    ASSERT( !FlagOn( CreateFlags, CREATE_FLAG_ACQUIRED_OBJECT_ID_INDEX ) );
                    SetFlag( CreateFlags, CREATE_FLAG_ACQUIRED_OBJECT_ID_INDEX );

                    //
                    //  The object id package won't post the Usn reason if it
                    //  sees it's been called in the create path, since the
                    //  file name is not yet in the file record, so it's unsafe
                    //  to call the Usn package.  When we post the create to the
                    //  Usn package below, we'll remember to post this one, too.
                    //

                    UsnReasons |= USN_REASON_OBJECT_ID_CHANGE;
                }
            }
        }

        //
        //  If quota tracking is enabled then get a owner id for the file.
        //

        if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_ENABLED )) {

            PSID Sid;
            BOOLEAN OwnerDefaulted;

            //
            //  The quota index must be acquired before the MFT SCB is acquired.
            //

            ASSERT( !NtfsIsExclusiveScb( Vcb->MftScb ) || NtfsIsExclusiveScb( Vcb->QuotaTableScb ));

            //
            //  Extract the security id from the security descriptor.
            //

            Status = RtlGetOwnerSecurityDescriptor( SharedSecurity->SecurityDescriptor,
                                                    &Sid,
                                                    &OwnerDefaulted );

            if (!NT_SUCCESS( Status )) {
                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
            }

            //
            // Generate a owner id.
            //

            OwnerId = NtfsGetOwnerId( IrpContext, Sid, TRUE, NULL );

            QuotaControl = NtfsInitializeQuotaControlBlock( Vcb, OwnerId );

            //
            //  Acquire the quota control block.  This is done here since it
            //  must be acquired before the MFT.
            //

            NtfsAcquireQuotaControl( IrpContext, QuotaControl );
        }

        //
        //  We will now try to do all of the on-disk operations.  This means first
        //  allocating and initializing an Mft record.  After that we create
        //  an Fcb to use to access this record.
        //

        ThisFileReference = NtfsAllocateMftRecord( IrpContext,
                                                   Vcb,
                                                   FALSE );

        //
        //  Pin the file record we need.
        //

        NtfsPinMftRecord( IrpContext,
                          Vcb,
                          &ThisFileReference,
                          TRUE,
                          &FileRecordBcb,
                          &FileRecord,
                          &FileRecordOffset );

        //
        //  Initialize the file record header.
        //

        NtfsInitializeMftRecord( IrpContext,
                                 Vcb,
                                 &ThisFileReference,
                                 FileRecord,
                                 FileRecordBcb,
                                 IndexedAttribute );

        NtfsAcquireFcbTable( IrpContext, Vcb );
        AcquiredFcbTable = TRUE;

        ThisFcb = NtfsCreateFcb( IrpContext,
                                 Vcb,
                                 ThisFileReference,
                                 BooleanFlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ),
                                 IndexedAttribute,
                                 &ReturnedExistingFcb );

        ASSERT( !ReturnedExistingFcb );

        //
        //  Set the flag indicating we want to acquire the paging io resource
        //  if it doesn't already exist. Use acquire don't wait for lock order
        //  package. Since this is a new file and we haven't dropped the fcb table
        //  mutex yet, no one else can own it. So this will always succeed.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
        Acquired =
#endif
        NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, ACQUIRE_DONT_WAIT );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
        ASSERT( Acquired );
#endif

        NtfsReleaseFcbTable( IrpContext, Vcb );
        AcquiredFcbTable = FALSE;

        //
        //  Reference the Fcb so it won't go away.
        //

        InterlockedIncrement( &ThisFcb->CloseCount );
        DecrementCloseCount = TRUE;

        //
        //  The first thing to create is the Ea's for the file.  This will
        //  update the Ea length field in the Fcb.
        //  We test here that the opener is opening the entire file and
        //  is not Ea blind.
        //

        if (Irp->AssociatedIrp.SystemBuffer != NULL) {

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_EA_KNOWLEDGE ) ||
                !FlagOn( CcbFlags, CCB_FLAG_OPEN_AS_FILE )) {

                try_return( Status = STATUS_ACCESS_DENIED );
            }
        }

        SetFlag( ThisFcb->FcbState, FCB_STATE_LARGE_STD_INFO );

        //
        //  Set up the security Id (if we've found one earlier).
        //  We need to be careful so that this works on upgraded and
        //  non-upgraded volumes.
        //

        if (ThisFcb->Vcb->SecurityDescriptorStream != NULL) {
            ThisFcb->SecurityId = SharedSecurity->Header.HashKey.SecurityId;
            ThisFcb->SharedSecurity = SharedSecurity;
            DebugTrace(0, (DEBUG_TRACE_SECURSUP | DEBUG_TRACE_ACLINDEX),
                       ( "SetFcbSecurity( %08x, %08x )\n", ThisFcb, SharedSecurity ));
            SharedSecurity = NULL;

        } else {

            ASSERT( ThisFcb->SecurityId == SECURITY_ID_INVALID );
        }

        ASSERT( SharedSecurity == NULL );

        //
        //  Assign the owner Id and quota control block to the fcb.  Once the
        //  quota control block is in the FCB this routine is not responsible
        //  for the reference to the quota control block.
        //

        if (QuotaControl != NULL) {

            //
            //  Assign the onwer Id and quota control block to the fcb.  Once the
            //  quota control block is in the FCB this routine is not responsible
            //  for the reference to the quota control block.
            //

            ThisFcb->OwnerId = OwnerId;
            ThisFcb->QuotaControl = QuotaControl;
            QuotaControl = NULL;
        }

        //
        //  Update the FileAttributes with the state of the CONTENT_INDEXED bit from the
        //  parent.
        //

        if (!FlagOn( ParentScb->Fcb->FcbState, FCB_STATE_DUP_INITIALIZED )) {

            NtfsUpdateFcbInfoFromDisk( IrpContext, FALSE, ParentScb->Fcb, NULL );
        }

        ClearFlag( IrpSp->Parameters.Create.FileAttributes, FILE_ATTRIBUTE_NOT_CONTENT_INDEXED );
        SetFlag( IrpSp->Parameters.Create.FileAttributes,
                 (ParentScb->Fcb->Info.FileAttributes & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED) );

        //
        //  The changes to make on disk are first to create a standard information
        //  attribute.  We start by filling the Fcb with the information we
        //  know and creating the attribute on disk.
        //

        NtfsInitializeFcbAndStdInfo( IrpContext,
                                     ThisFcb,
                                     IndexedAttribute,
                                     FALSE,
                                     (BOOLEAN) (!FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_COMPRESSION ) &&
                                                !FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ) &&
                                                FlagOn( ParentScb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )),
                                     IrpSp->Parameters.Create.FileAttributes,
                                     (HaveTunneledInformation ? &TunneledData : NULL) );

        //
        //  Next we create the Index for a directory or the unnamed data for
        //  a file if they are not explicitly being opened.
        //

        if (!IndexedAttribute) {

            if (!FlagOn( CcbFlags, CCB_FLAG_OPEN_AS_FILE )) {

                //
                //  Update the quota
                //

                LONGLONG Delta = NtfsResidentStreamQuota( ThisFcb->Vcb );

                NtfsConditionallyUpdateQuota( IrpContext,
                                              ThisFcb,
                                              &Delta,
                                              FALSE,
                                              TRUE );

                //
                //  Create the attribute
                //

                NtfsInitializeAttributeContext( &AttrContext );
                CleanupAttrContext = TRUE;

                NtfsCreateAttributeWithValue( IrpContext,
                                              ThisFcb,
                                              $DATA,
                                              NULL,
                                              NULL,
                                              0,
                                              (USHORT) ((!FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE ) &&
                                                         !FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_COMPRESSION )) ?
                                                        (ParentScb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) :
                                                        0),
                                              NULL,
                                              FALSE,
                                              &AttrContext );

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                CleanupAttrContext = FALSE;

                ThisFcb->Info.AllocatedLength = 0;
                ThisFcb->Info.FileSize = 0;
            }

        } else {

            NtfsCreateIndex( IrpContext,
                             ThisFcb,
                             $FILE_NAME,
                             COLLATION_FILE_NAME,
                             Vcb->DefaultBytesPerIndexAllocationBuffer,
                             (UCHAR)Vcb->DefaultBlocksPerIndexAllocationBuffer,
                             NULL,
                             (USHORT) (!FlagOn( IrpSp->Parameters.Create.Options,
                                                FILE_NO_COMPRESSION ) ?
                                       (ParentScb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) :
                                       0),
                             TRUE,
                             FALSE );
        }

        //
        //  Now we create the Lcb, this means that this Fcb is in the graph.
        //

        ThisLcb = NtfsCreateLcb( IrpContext,
                                 ParentScb,
                                 ThisFcb,
                                 FinalName,
                                 0,
                                 NULL );

        ASSERT( ThisLcb != NULL );

        //
        //  Finally we create and open the desired attribute for the user.
        //

        if (AttrTypeCode == $INDEX_ALLOCATION) {

            Status = NtfsOpenAttribute( IrpContext,
                                        IrpSp,
                                        Vcb,
                                        ThisLcb,
                                        ThisFcb,
                                        (FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID )
                                         ? 0
                                         : FullPathName.Length - FinalName.Length),
                                        NtfsFileNameIndex,
                                        $INDEX_ALLOCATION,
                                        SetShareAccess,
                                        UserDirectoryOpen,
                                        TRUE,
                                        (FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID )
                                         ? CcbFlags | CCB_FLAG_OPEN_BY_FILE_ID
                                         : CcbFlags),
                                        NULL,
                                        ThisScb,
                                        ThisCcb );

        } else {

            Status = NtfsOpenNewAttr( IrpContext,
                                      Irp,
                                      IrpSp,
                                      ThisLcb,
                                      ThisFcb,
                                      (FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID )
                                       ? 0
                                       : FullPathName.Length - FinalName.Length),
                                      AttrName,
                                      AttrTypeCode,
                                      TRUE,
                                      CcbFlags,
                                      FALSE,
                                      CreateFlags,
                                      ThisScb,
                                      ThisCcb );
        }

        //
        //  If we are successful, we add the parent Lcb to the prefix table if
        //  desired.  We will always add our link to the prefix queue.
        //

        if (NT_SUCCESS( Status )) {

            Scb = *ThisScb;

            //
            //  Initialize the Scb if we need to do so.
            //

            if (!IndexedAttribute) {

                if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                    NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
                }

                if (!FlagOn( IrpSp->Parameters.Create.Options,
                             FILE_NO_INTERMEDIATE_BUFFERING )) {

                    SetFlag( IrpSp->FileObject->Flags, FO_CACHE_SUPPORTED );
                }

                //
                //  If this is the unnamed data attribute, we store the sizes
                //  in the Fcb.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                    ThisFcb->Info.AllocatedLength = Scb->TotalAllocated;
                    ThisFcb->Info.FileSize = Scb->Header.FileSize.QuadPart;
                }
            }

            //
            //  Next add this entry to parent.  It is possible that this is a link,
            //  an Ntfs name, a DOS name or Ntfs/Dos name.  We use the filename
            //  attribute structure from earlier, but need to add more information.
            //

            NtfsAddLink( IrpContext,
                         (BOOLEAN) !BooleanFlagOn( IrpSp->Flags, SL_CASE_SENSITIVE ),
                         ParentScb,
                         ThisFcb,
                         FileNameAttr,
                         &LoggedFileRecord,
                         &FileNameFlags,
                         &ThisLcb->QuickIndex,
                         (HaveTunneledInformation? &NamePair : NULL),
                         *IndexContext );

            //
            //  We created the Lcb without knowing the correct value for the
            //  flags.  We update it now.
            //

            ThisLcb->FileNameAttr->Flags = FileNameFlags;
            FileNameAttr->Flags = FileNameFlags;

            //
            //  We also have to fix up the ExactCaseLink of the Lcb since we may have had
            //  a short name create turned into a tunneled long name create, meaning that
            //  it should be full uppercase. And the filename in the IRP.
            //

            if (FileNameFlags == FILE_NAME_DOS) {

                RtlUpcaseUnicodeString(&ThisLcb->ExactCaseLink.LinkName, &ThisLcb->ExactCaseLink.LinkName, FALSE);
                RtlUpcaseUnicodeString(&IrpSp->FileObject->FileName, &IrpSp->FileObject->FileName, FALSE);
            }

            //
            //  Clear the flags in the Fcb that indicate we need to update on
            //  disk structures.  Also clear any file object and Ccb flags
            //  which also indicate we may need to do an update.
            //

            ThisFcb->InfoFlags = 0;
            ClearFlag( ThisFcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

            ClearFlag( IrpSp->FileObject->Flags,
                       FO_FILE_MODIFIED | FO_FILE_FAST_IO_READ | FO_FILE_SIZE_CHANGED );

            ClearFlag( (*ThisCcb)->Flags,
                       (CCB_FLAG_UPDATE_LAST_MODIFY |
                        CCB_FLAG_UPDATE_LAST_CHANGE |
                        CCB_FLAG_SET_ARCHIVE) );

            //
            //  This code is still necessary for non-upgraded volumes.
            //

            NtfsAssignSecurity( IrpContext,
                                ParentScb->Fcb,
                                Irp,
                                ThisFcb,
                                FileRecord,
                                FileRecordBcb,
                                FileRecordOffset,
                                &LoggedFileRecord );

            //
            //  Log the file record.
            //

            FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                            Vcb->MftScb,
                                            FileRecordBcb,
                                            InitializeFileRecordSegment,
                                            FileRecord,
                                            FileRecord->FirstFreeByte,
                                            Noop,
                                            NULL,
                                            0,
                                            FileRecordOffset,
                                            0,
                                            0,
                                            Vcb->BytesPerFileRecordSegment );

            //
            //  Now add the eas for the file.  We need to add them now because
            //  they are logged and we have to make sure we don't modify the
            //  attribute record after adding them.
            //

            if (Irp->AssociatedIrp.SystemBuffer != NULL) {

                NtfsAddEa( IrpContext,
                           Vcb,
                           ThisFcb,
                           (PFILE_FULL_EA_INFORMATION) Irp->AssociatedIrp.SystemBuffer,
                           IrpSp->Parameters.Create.EaLength,
                           &Irp->IoStatus );
            }

            //
            //  Change the last modification time and last change time for the
            //  parent.
            //

            NtfsUpdateFcb( ParentScb->Fcb,
                           (FCB_INFO_CHANGED_LAST_CHANGE |
                            FCB_INFO_CHANGED_LAST_MOD |
                            FCB_INFO_UPDATE_LAST_ACCESS) );

            //
            //  If this is the paging file, we want to be sure the allocation
            //  is loaded.
            //

            if (FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE )) {

                Cluster = Int64ShraMod32(Scb->Header.AllocationSize.QuadPart, Scb->Vcb->ClusterShift);

                NtfsPreloadAllocation( IrpContext, Scb, 0, Cluster );

                //
                //  Now make sure the allocation is correctly loaded.  The last
                //  Vcn should correspond to the allocation size for the file.
                //

                if (!NtfsLookupLastNtfsMcbEntry( &Scb->Mcb,
                                                 &Vcn,
                                                 &Lcn ) ||
                    (Vcn + 1) != Cluster) {

                    NtfsRaiseStatus( IrpContext,
                                     STATUS_FILE_CORRUPT_ERROR,
                                     NULL,
                                     ThisFcb );
                }
            }

            //
            //  If everything has gone well so far, we may want to call the
            //  encryption callback if one is registered.
            //
            //  We need to do this now because the encryption driver may fail
            //  the create, and we don't want that to happen _after_ we've
            //  added the entry to the prefix table.
            //

            NtfsEncryptionCreateCallback( IrpContext,
                                          Irp,
                                          IrpSp,
                                          *ThisScb,
                                          *ThisCcb,
                                          ThisFcb,
                                          ParentScb->Fcb,
                                          TRUE );

            //
            //  Now that there are no other failures, but *before* inserting the prefix
            //  entry and returning to code that assumes it cannot fail, we will post the
            //  UsnJournal change and actually attempt to write the UsnJournal.  Then we
            //  actually commit the transaction in order to reduce UsnJournal contention.
            //  This call must be made _after_ the call to NtfsInitializeFcbAndStdInfo,
            //  since that's where the object id gets set from the tunnel cache, and we
            //  wouldn't want to post the usn reason for the object id change if we
            //  haven't actually set the object id yet.
            //

            NtfsPostUsnChange( IrpContext, ThisFcb, (UsnReasons | USN_REASON_FILE_CREATE) );

            //
            //  If this is a directory open and the normalized name is not in
            //  the Scb then do so now.  We should always have a normalized name in the
            //  parent to build from.
            //

            if ((SafeNodeType( *ThisScb ) == NTFS_NTC_SCB_INDEX) &&
                ((*ThisScb)->ScbType.Index.NormalizedName.Length == 0)) {

                //
                //  We may be able to use the parent.
                //

                if (ParentScb->ScbType.Index.NormalizedName.Length != 0) {

                    NtfsUpdateNormalizedName( IrpContext,
                                              ParentScb,
                                              *ThisScb,
                                              FileNameAttr,
                                              FALSE );

                }
            }

            //
            //  Now, if anything at all is posted to the Usn Journal, we must write it now
            //  so that we do not get a log file full later.
            //

            ASSERT( IrpContext->Usn.NextUsnFcb == NULL );
            if (IrpContext->Usn.CurrentUsnFcb != NULL) {

                //
                //  Now write the journal, checkpoint the transaction, and free the UsnJournal to
                //  reduce contention.
                //

                NtfsWriteUsnJournalChanges( IrpContext );
                NtfsCheckpointCurrentTransaction( IrpContext );
            }

            //
            //  We report to our parent that we created a new file.
            //

            if (!FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID ) && (Vcb->NotifyCount != 0)) {

                NtfsReportDirNotify( IrpContext,
                                     ThisFcb->Vcb,
                                     &(*ThisCcb)->FullFileName,
                                     (*ThisCcb)->LastFileNameOffset,
                                     NULL,
                                     ((FlagOn( (*ThisCcb)->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                       ((*ThisCcb)->Lcb != NULL) &&
                                       ((*ThisCcb)->Lcb->Scb->ScbType.Index.NormalizedName.Buffer != 0)) ?
                                      &(*ThisCcb)->Lcb->Scb->ScbType.Index.NormalizedName :
                                      NULL),
                                     (IndexedAttribute
                                      ? FILE_NOTIFY_CHANGE_DIR_NAME
                                      : FILE_NOTIFY_CHANGE_FILE_NAME),
                                     FILE_ACTION_ADDED,
                                     ParentScb->Fcb );
            }

            ThisFcb->InfoFlags = 0;

            //
            //  Insert the hash entry for this as well.
            //

            if ((CreateContext->FileHashLength != 0) &&
                !FlagOn( CcbFlags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                (ThisLcb->FileNameAttr->Flags != FILE_NAME_DOS) ) {

                //
                //  Remove any exising hash value.
                //

                if (FlagOn( ThisLcb->LcbState, LCB_STATE_VALID_HASH_VALUE )) {

                    NtfsRemoveHashEntriesForLcb( ThisLcb );
                }

                NtfsInsertHashEntry( &Vcb->HashTable,
                                     ThisLcb,
                                     CreateContext->FileHashLength,
                                     CreateContext->FileHashValue );

#ifdef NTFS_HASH_DATA
                Vcb->HashTable.CreateNewFileInsert += 1;
#endif
            }


            //
            //  Now we insert the Lcb for this Fcb.
            //

            NtfsInsertPrefix( ThisLcb, CreateFlags );

            Irp->IoStatus.Information = FILE_CREATED;

            //
            //  If we'll be calling a post create callout, make sure
            //  NtfsEncryptionCreateCallback set this Fcb bit.
            //

            if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_EFS_CREATE ) &&
                FlagOn( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT ) &&
                FlagOn( IrpContext->EncryptionFileDirFlags, FILE_NEW )) {

                ASSERT( FlagOn( ThisFcb->FcbState, FCB_STATE_ENCRYPTION_PENDING ) );
            }
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsCreateNewFile );

        if (AcquiredFcbTable) {

            NtfsReleaseFcbTable( IrpContext, Vcb );
        }

        NtfsUnpinBcb( IrpContext, &FileRecordBcb );

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        if (DecrementCloseCount) {

            InterlockedDecrement( &ThisFcb->CloseCount );
        }

        if (FlagOn( CreateFlags, CREATE_FLAG_ACQUIRED_OBJECT_ID_INDEX )) {

            NtfsReleaseScb( IrpContext, Vcb->ObjectIdTableScb );
            ClearFlag( CreateFlags, CREATE_FLAG_ACQUIRED_OBJECT_ID_INDEX );
        }

        if (NamePair.Long.Buffer != NamePair.LongBuffer) {

            NtfsFreePool(NamePair.Long.Buffer);
        }

        if (SharedSecurity != NULL) {
            ASSERT( ThisFcb == NULL || ThisFcb->SharedSecurity == NULL );
            NtfsAcquireFcbSecurity( Vcb );
            RemoveReferenceSharedSecurityUnsafe( &SharedSecurity );
            NtfsReleaseFcbSecurity( Vcb );
        }

        //
        //  We need to cleanup any changes to the in memory
        //  structures if there is an error.
        //

        if (!NT_SUCCESS( Status ) || AbnormalTermination()) {

            ASSERT( !(AbnormalTermination()) || IrpContext->ExceptionStatus != STATUS_SUCCESS );

            if (*IndexContext != NULL) {

                NtfsCleanupIndexContext( IrpContext, *IndexContext );
                *IndexContext = NULL;
            }

            NtfsBackoutFailedOpens( IrpContext,
                                    IrpSp->FileObject,
                                    ThisFcb,
                                    *ThisScb,
                                    *ThisCcb );

            //
            //  Derefence the quota control block if it was not assigned
            //  to the FCB.
            //

            if (QuotaControl != NULL) {
                NtfsDereferenceQuotaControlBlock( Vcb, &QuotaControl );
            }

            //
            //  Always force the Fcb to reinitialized.
            //

            if (ThisFcb != NULL) {

                PSCB Scb;
                PLIST_ENTRY Links;

                ClearFlag( ThisFcb->FcbState, FCB_STATE_DUP_INITIALIZED );

                //
                //  Mark the Fcb and all Scb's as deleted to force all subsequent
                //  operations to fail.
                //

                SetFlag( ThisFcb->FcbState, FCB_STATE_FILE_DELETED );

                //
                //  We need to mark all of the Scbs as gone.
                //

                for (Links = ThisFcb->ScbQueue.Flink;
                     Links != &ThisFcb->ScbQueue;
                     Links = Links->Flink) {

                    Scb = CONTAINING_RECORD( Links, SCB, FcbLinks );

                    Scb->ValidDataToDisk =
                    Scb->Header.AllocationSize.QuadPart =
                    Scb->Header.FileSize.QuadPart =
                    Scb->Header.ValidDataLength.QuadPart = 0;

                    SetFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
                }

                //
                //  Clear the Scb field so our caller doesn't try to teardown
                //  from this point.
                //

                *ThisScb = NULL;

                //
                //  If we created an Fcb then we want to check if we need to
                //  unwind any structure allocation.  We don't want to remove any
                //  structures needed for the coming AbortTransaction.  This
                //  includes the parent Scb as well as the current Fcb if we
                //  logged the ACL creation.
                //

                //
                //  Make sure the parent Fcb doesn't go away.  Then
                //  start a teardown from the Fcb we just found.
                //

                InterlockedIncrement( &ParentScb->CleanupCount );

                NtfsTeardownStructures( IrpContext,
                                    ThisFcb,
                                    NULL,
                                    LoggedFileRecord,
                                    0,
                                    &RemovedFcb );

                //
                //  If the Fcb was removed then both the Fcb and Lcb are gone.
                //

                if (RemovedFcb) {

                    ThisFcb = NULL;
                    ThisLcb = NULL;
                }

                InterlockedDecrement( &ParentScb->CleanupCount );
            }
        }

        //
        //  If the new Fcb is still present then either return it as the
        //  deepest Fcb encountered in this open or release it.
        //

        if (ThisFcb != NULL) {

            //
            //  If the Lcb is present then this is part of the tree.  Our
            //  caller knows to release it.
            //

            if (ThisLcb != NULL) {

                *LcbForTeardown = ThisLcb;
                *CurrentFcb = ThisFcb;
            }
        }

        ASSERT( QuotaControl == NULL );
        DebugTrace( -1, Dbg, ("NtfsCreateNewFile:  Exit  ->  %08lx\n", Status) );
    }

    return Status;
}


//
//  Local support routine
//

PLCB
NtfsOpenSubdirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN UNICODE_STRING Name,
    IN ULONG CreateFlags,
    OUT PFCB *CurrentFcb,
    OUT PLCB *LcbForTeardown,
    IN PINDEX_ENTRY IndexEntry
    )

/*++

Routine Description:

    This routine will create an Fcb for an intermediate node on an open path.
    We use the ParentScb and the information in the FileName attribute returned
    from the disk to create the Fcb and create a link between the Scb and Fcb.
    It's possible that the Fcb and Lcb already exist but the 'CreateXcb' calls
    handle that already.  This routine does not expect to fail.

Arguments:

    ParentScb - This is the Scb for the parent directory.

    Name - This is the name for the entry.

    CreateFlags - Indicates if this open is using traverse access checking.

    CurrentFcb - This is the address to store the Fcb if we successfully find
        one in the Fcb/Scb tree.

    LcbForTeardown - This is the Lcb to use in teardown if we add an Lcb
        into the tree.

    IndexEntry - This is the entry found in searching the parent directory.

Return Value:

    PLCB - Pointer to the Link control block between the Fcb and its parent.

--*/

{
    PFCB ThisFcb;
    PLCB ThisLcb;
    PFCB LocalFcbForTeardown = NULL;

    BOOLEAN AcquiredFcbTable = FALSE;
    BOOLEAN ExistingFcb;

    PVCB Vcb = ParentScb->Vcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenSubdirectory:  Entered\n") );
    DebugTrace( 0, Dbg, ("ParentScb     ->  %08lx\n") );
    DebugTrace( 0, Dbg, ("IndexEntry    ->  %08lx\n") );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        NtfsAcquireFcbTable( IrpContext, Vcb );
        AcquiredFcbTable = TRUE;

        //
        //  The steps here are very simple create the Fcb, remembering if it
        //  already existed.  We don't update the information in the Fcb as
        //  we can't rely on the information in the duplicated information.
        //  A subsequent open of this Fcb will need to perform that work.
        //

        ThisFcb = NtfsCreateFcb( IrpContext,
                                 ParentScb->Vcb,
                                 IndexEntry->FileReference,
                                 FALSE,
                                 TRUE,
                                 &ExistingFcb );

        ThisFcb->ReferenceCount += 1;

        //
        //  If we created this Fcb we must make sure to start teardown
        //  on it.
        //

        if (!ExistingFcb) {

            LocalFcbForTeardown = ThisFcb;

        } else {

            *CurrentFcb = ThisFcb;
            *LcbForTeardown = NULL;
        }

        //
        //  Try to do a fast acquire, otherwise we need to release
        //  the Fcb table, acquire the Fcb, acquire the Fcb table to
        //  dereference Fcb. Just do an acquire for system files under the root i.e $Extend - this will match
        //  their canonical order
        //

        if (FlagOn( ThisFcb->FcbState, FCB_STATE_SYSTEM_FILE) &&
            (NtfsSegmentNumber( &ParentScb->Fcb->FileReference ) == ROOT_FILE_NAME_INDEX_NUMBER)) {

            ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) );

            NtfsReleaseFcbTable( IrpContext, Vcb );
            NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, 0 );
            NtfsAcquireFcbTable( IrpContext, Vcb );

        } else if (!NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, ACQUIRE_DONT_WAIT )) {

            ParentScb->Fcb->ReferenceCount += 1;
            InterlockedIncrement( &ParentScb->CleanupCount );

            //
            //  Set the IrpContext to acquire paging io resources if our target
            //  has one.  This will lock the MappedPageWriter out of this file.
            //

            if (ThisFcb->PagingIoResource != NULL) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
            }

            //
            //  Release the fcb table first because its an end resource and release
            //  scb with paging might reacquire a fast mutex if freeing snapshots
            //

            NtfsReleaseFcbTable( IrpContext, Vcb );
            NtfsReleaseScbWithPaging( IrpContext, ParentScb );
            NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, 0 );
            NtfsAcquireExclusiveScb( IrpContext, ParentScb );
            NtfsAcquireFcbTable( IrpContext, Vcb );
            InterlockedDecrement( &ParentScb->CleanupCount );
            ParentScb->Fcb->ReferenceCount -= 1;
        }

        ThisFcb->ReferenceCount -= 1;

        NtfsReleaseFcbTable( IrpContext, Vcb );
        AcquiredFcbTable = FALSE;

        //
        //  If this is a directory, it's possible that we hav an existing Fcb
        //  in the prefix table which needs to be initialized from the disk.
        //  We look in the InfoInitialized flag to know whether to go to
        //  disk.
        //

        ThisLcb = NtfsCreateLcb( IrpContext,
                                 ParentScb,
                                 ThisFcb,
                                 Name,
                                 ((PFILE_NAME) NtfsFoundIndexEntry( IndexEntry ))->Flags,
                                 NULL );

        LocalFcbForTeardown = NULL;

        *LcbForTeardown = ThisLcb;
        *CurrentFcb = ThisFcb;

        if (!FlagOn( ThisFcb->FcbState, FCB_STATE_DUP_INITIALIZED )) {

            NtfsUpdateFcbInfoFromDisk( IrpContext,
                                       BooleanFlagOn( CreateFlags, CREATE_FLAG_TRAVERSE_CHECK ),
                                       ThisFcb,
                                       NULL );

            NtfsConditionallyFixupQuota( IrpContext, ThisFcb );
        }

    } finally {

        DebugUnwind( NtfsOpenSubdirectory );

        if (AcquiredFcbTable) {

            NtfsReleaseFcbTable( IrpContext, Vcb );
        }

        //
        //  If we are to cleanup the Fcb we, look to see if we created it.
        //  If we did we can call our teardown routine.  Otherwise we
        //  leave it alone.
        //

        if (LocalFcbForTeardown != NULL) {

            NtfsTeardownStructures( IrpContext,
                                    ThisFcb,
                                    NULL,
                                    FALSE,
                                    0,
                                    NULL );
        }

        DebugTrace( -1, Dbg, ("NtfsOpenSubdirectory:  Lcb  ->  %08lx\n", ThisLcb) );
    }

    return ThisLcb;
}


//
//  Local support routine.
//

NTSTATUS
NtfsOpenAttributeInExistingFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN ULONG CcbFlags,
    IN ULONG CreateFlags,
    IN PVOID NetworkInfo OPTIONAL,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    )

/*++

Routine Description:

    This routine is the worker routine for opening an attribute on an
    existing file.  It will handle volume opens, indexed opens, opening
    or overwriting existing attributes as well as creating new attributes.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the stack location for this open.

    ThisLcb - This is the Lcb we used to reach this Fcb.

    ThisFcb - This is the Fcb for the file being opened.

    LastFileNameOffset - This is the offset in the full path name of the
        final component.

    AttrName - This is the attribute name in case we need to create
        an Scb.

    AttrTypeCode - This is the attribute type code to use to create
        the Scb.

    CcbFlags - This is the flag field for the Ccb.

    CreateFlags - Indicates if this open is an open by Id.

    NetworkInfo - If specified then this call is a fast open call to query
        the network information.  We don't update any of the in-memory structures
        for this.

    ThisScb - This is the address to store the Scb from this open.

    ThisCcb - This is the address to store the Ccb from this open.

Return Value:

    NTSTATUS - The result of opening this indexed attribute.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG CreateDisposition;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN FoundAttribute;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenAttributeInExistingFile:  Entered\n") );

    //
    //  When the Fcb denotes a reparse point, it will be retrieved below by one of
    //  NtfsOpenExistingAttr, NtfsOverwriteAttr or this routine prior to calling
    //  NtfsOpenNewAttr.
    //
    //  We do not retrieve the reparse point here, as we could, because in
    //  NtfsOpenExistingAttr and in NtfsOverwriteAttr there are extensive access
    //  control checks that need to be preserved. NtfsOpenNewAttr has no access
    //  checks.
    //

    //
    //  If the caller is ea blind, let's check the need ea count on the
    //  file.  We skip this check if he is accessing a named data stream.
    //

    if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_EA_KNOWLEDGE )
        && FlagOn( CcbFlags, CCB_FLAG_OPEN_AS_FILE )) {

        PEA_INFORMATION ThisEaInformation;
        ATTRIBUTE_ENUMERATION_CONTEXT EaInfoAttrContext;

        NtfsInitializeAttributeContext( &EaInfoAttrContext );

        //
        //  Use a try-finally to facilitate cleanup.
        //

        try {

            //
            //  If we find the Ea information attribute we look in there for
            //  Need ea count.
            //

            if (NtfsLookupAttributeByCode( IrpContext,
                                           ThisFcb,
                                           &ThisFcb->FileReference,
                                           $EA_INFORMATION,
                                           &EaInfoAttrContext )) {

                ThisEaInformation = (PEA_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &EaInfoAttrContext ));

                if (ThisEaInformation->NeedEaCount != 0) {

                    Status = STATUS_ACCESS_DENIED;
                }
            }

        } finally {

            NtfsCleanupAttributeContext( IrpContext, &EaInfoAttrContext );
        }

        if (Status != STATUS_SUCCESS) {

            DebugTrace( -1, Dbg, ("NtfsOpenAttributeInExistingFile:  Exit - %x\n", Status) );

            return Status;
        }
    }

    CreateDisposition = (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff;

    //
    //  If the result is a directory operation, then we know the attribute
    //  must exist.
    //

    if (AttrTypeCode == $INDEX_ALLOCATION) {

        //
        //  If this is not a file name index then we need to verify that the specified index
        //  exists.  We need to look for the $INDEX_ROOT attribute though not the
        //  $INDEX_ALLOCATION attribute.
        //

        if ((AttrName.Buffer != NtfsFileNameIndex.Buffer) || FlagOn( ThisFcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

            NtfsInitializeAttributeContext( &AttrContext );

            //
            //  Use a try-finally to facilitate cleanup.
            //

            try {

                FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                            ThisFcb,
                                                            &ThisFcb->FileReference,
                                                            $INDEX_ROOT,
                                                            &AttrName,
                                                            NULL,
                                                            (BOOLEAN) !BooleanFlagOn( IrpSp->Flags, SL_CASE_SENSITIVE ),
                                                            &AttrContext );
            } finally {

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            }

            //
            //  If we didn't find the name then we want to fail the request.
            //

            if (!FoundAttribute) {

                if ((CreateDisposition == FILE_OPEN) || (CreateDisposition == FILE_OVERWRITE)) {

                    Status = STATUS_OBJECT_NAME_NOT_FOUND;

                } else {

                    Status = STATUS_ACCESS_DENIED;
                }

                DebugTrace( -1, Dbg, ("NtfsOpenAttributeInExistingFile:  Exit - %x\n", Status) );
                return Status;
            }
        }

        //
        //  Check the create disposition.
        //

        if ((CreateDisposition != FILE_OPEN) && (CreateDisposition != FILE_OPEN_IF)) {

            Status = (ThisLcb == ThisFcb->Vcb->RootLcb
                      ? STATUS_ACCESS_DENIED
                      : STATUS_OBJECT_NAME_COLLISION);

        } else {

            Status = NtfsOpenExistingAttr( IrpContext,
                                           Irp,
                                           IrpSp,
                                           ThisLcb,
                                           ThisFcb,
                                           LastFileNameOffset,
                                           AttrName,
                                           $INDEX_ALLOCATION,
                                           CcbFlags,
                                           CreateFlags,
                                           TRUE,
                                           NetworkInfo,
                                           ThisScb,
                                           ThisCcb );

            //
            //  The IsEncrypted test below is meaningless for an uninitialized Fcb.
            //

            ASSERT( FlagOn( ThisFcb->FcbState, FCB_STATE_DUP_INITIALIZED ) );

            if ((Status == STATUS_SUCCESS) &&
                ARGUMENT_PRESENT( NetworkInfo ) &&
                IsEncrypted( &ThisFcb->Info )) {

                //
                //  We need to initialize the Scb now, otherwise we won't have set the
                //  encryption bit in the index Scb's attribute flags, and we will not
                //  return the right file attributes to the network opener.
                //

                if ((*ThisScb)->ScbType.Index.BytesPerIndexBuffer == 0) {

                    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

                    NtfsInitializeAttributeContext( &AttrContext );

                    //
                    //  Use a try-finally to facilitate cleanup.
                    //

                    try {

                        if (NtfsLookupAttributeByCode( IrpContext,
                                                       ThisFcb,
                                                       &ThisFcb->FileReference,
                                                       $INDEX_ROOT,
                                                       &AttrContext )) {

                            NtfsUpdateIndexScbFromAttribute( IrpContext,
                                                             *ThisScb,
                                                             NtfsFoundAttribute( &AttrContext ),
                                                             FALSE );

                        } else {

                            Status = STATUS_FILE_CORRUPT_ERROR;
                        }

                    } finally {

                        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                    }

                    if (Status != STATUS_SUCCESS) {

                        DebugTrace( -1, Dbg, ("NtfsOpenAttributeInExistingFile:  Exit - %x\n", Status) );

                        return Status;
                    }
                }
            }
        }

    } else {

        //
        //  If it exists, we first check if the caller wanted to open that attribute.
        //  If the open is for a system file then look for that attribute explicitly.
        //

        if ((AttrName.Length == 0) &&
            (AttrTypeCode == $DATA) &&
            !FlagOn( ThisFcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

            FoundAttribute = TRUE;

        //
        //  Otherwise we see if the attribute exists.
        //

        } else {

            //
            //  Check that we own the paging io resource.  If we are creating the stream and
            //  need to break up the allocation then we must own the paging IO resource.
            //

            ASSERT( !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING ) ||
                    (IrpContext->CleanupStructure != NULL) ||
                    (ThisFcb->PagingIoResource == NULL) ||
                    (ThisFcb == ThisFcb->Vcb->RootIndexScb->Fcb) );

            NtfsInitializeAttributeContext( &AttrContext );

            //
            //  Use a try-finally to facilitate cleanup.
            //

            try {

                FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                            ThisFcb,
                                                            &ThisFcb->FileReference,
                                                            AttrTypeCode,
                                                            &AttrName,
                                                            NULL,
                                                            (BOOLEAN) !BooleanFlagOn( IrpSp->Flags, SL_CASE_SENSITIVE ),
                                                            &AttrContext );

                if (FoundAttribute && ($DATA == AttrTypeCode)) {

                    //
                    //  If there is an attribute name, we will copy the case of the name
                    //  to the input attribute name for data streams. For others the storage is common read-only regions.
                    //

                    PATTRIBUTE_RECORD_HEADER FoundAttribute;

                    FoundAttribute = NtfsFoundAttribute( &AttrContext );

                    RtlCopyMemory( AttrName.Buffer,
                                   Add2Ptr( FoundAttribute, FoundAttribute->NameOffset ),
                                   AttrName.Length );
                }

            } finally {

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            }
        }

        if (FoundAttribute) {

            //
            //  In this case we call our routine to open this attribute.
            //

            if ((CreateDisposition == FILE_OPEN) ||
                (CreateDisposition == FILE_OPEN_IF)) {

                Status = NtfsOpenExistingAttr( IrpContext,
                                               Irp,
                                               IrpSp,
                                               ThisLcb,
                                               ThisFcb,
                                               LastFileNameOffset,
                                               AttrName,
                                               AttrTypeCode,
                                               CcbFlags,
                                               CreateFlags,
                                               FALSE,
                                               NetworkInfo,
                                               ThisScb,
                                               ThisCcb );

                if ((Status != STATUS_PENDING) &&
                    (*ThisScb != NULL)) {

                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CREATE_MOD_SCB );
                }

            //
            //  If he wanted to overwrite this attribute, we call our overwrite routine.
            //

            } else if ((CreateDisposition == FILE_SUPERSEDE) ||
                       (CreateDisposition == FILE_OVERWRITE) ||
                       (CreateDisposition == FILE_OVERWRITE_IF)) {

                if (!NtfsIsVolumeReadOnly( IrpContext->Vcb )) {

                    //
                    //  Check if mm will allow us to modify this file.
                    //

                    Status = NtfsOverwriteAttr( IrpContext,
                                                Irp,
                                                IrpSp,
                                                ThisLcb,
                                                ThisFcb,
                                                (BOOLEAN) (CreateDisposition == FILE_SUPERSEDE),
                                                LastFileNameOffset,
                                                AttrName,
                                                AttrTypeCode,
                                                CcbFlags,
                                                CreateFlags,
                                                ThisScb,
                                                ThisCcb );

                    //
                    //  Remember that this Scb was modified.
                    //

                    if ((Status != STATUS_PENDING) &&
                        (*ThisScb != NULL)) {

                        SetFlag( IrpSp->FileObject->Flags, FO_FILE_MODIFIED );
                        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CREATE_MOD_SCB );
                    }

                } else {

                    //
                    //  We can't do any overwrite/supersede on R/O media.
                    //

                    Status = STATUS_MEDIA_WRITE_PROTECTED;
                }

            //
            //  Otherwise he is trying to create the attribute.
            //

            } else {

                Status = STATUS_OBJECT_NAME_COLLISION;
            }

        //
        //  The attribute doesn't exist.  If the user expected it to exist, we fail.
        //  Otherwise we call our routine to create an attribute.
        //

        } else if ((CreateDisposition == FILE_OPEN) ||
                   (CreateDisposition == FILE_OVERWRITE)) {

            Status = STATUS_OBJECT_NAME_NOT_FOUND;

        } else {

            //
            //  Perform the open check for this existing file.
            //

            Status = NtfsCheckExistingFile( IrpContext,
                                            IrpSp,
                                            ThisLcb,
                                            ThisFcb,
                                            CcbFlags );

            //
            //  End-of-name call to retrieve a reparse point.
            //  As NtfsOpenNewAttr has not access checks, we see whether we need to
            //  retrieve the reparse point here, prior to calling NtfsOpenNewAttr.
            //  The file information in ThisFcb tells whether this is a reparse point.
            //
            //  If we have succeded in the previous check and we do not have
            //  FILE_OPEN_REPARSE_POINT set, we retrieve the reparse point.
            //

            if (NT_SUCCESS( Status ) &&
                FlagOn( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT ) &&
                !FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_REPARSE_POINT )) {

                USHORT AttributeNameLength = 0;

                //
                //  We exclude the case when we get the $I30 name and $INDEX_ALLOCATION type
                //  as this is the standard manner of opening a directory.
                //

                if (!((AttrName.Length == NtfsFileNameIndex.Length) &&
                      (AttrTypeCode == $INDEX_ALLOCATION) &&
                      (RtlEqualMemory( AttrName.Buffer, NtfsFileNameIndex.Buffer, AttrName.Length )))) {

                    if (AttrName.Length > 0) {
                        ASSERT( AttrName.Length == ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeNameLength );
                        AttributeNameLength += AttrName.Length + 2;
                    }
                    if (((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength > 0) {
                        AttributeNameLength += ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength + 2;
                    }
                }
                DebugTrace( 0, Dbg, ("AttrTypeCode %x AttrName.Length (1) = %d AttributeCodeNameLength %d LastFileNameOffset %d\n",
                           AttrTypeCode, AttrName.Length, ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength, LastFileNameOffset) );

                Status = NtfsGetReparsePointValue( IrpContext,
                                                   Irp,
                                                   IrpSp,
                                                   ThisFcb,
                                                   AttributeNameLength );
            }

            //
            //  If this didn't fail and we did not encounter a reparse point,
            //  then attempt to create the stream.
            //

            if (NT_SUCCESS( Status ) &&
                (Status != STATUS_REPARSE)) {

                //
                //  Don't allow this operation on a system file (except the root directory which can have user data streams)
                //  or for anything other than user data streams
                //

                if ((FlagOn( ThisFcb->FcbState, FCB_STATE_SYSTEM_FILE ) &&
                     (NtfsSegmentNumber( &ThisFcb->FileReference ) != ROOT_FILE_NAME_INDEX_NUMBER)) ||
                    (!NtfsIsTypeCodeUserData( AttrTypeCode ))) {

                    Status = STATUS_ACCESS_DENIED;

                } else if (!NtfsIsVolumeReadOnly( IrpContext->Vcb )) {

                    NtfsPostUsnChange( IrpContext, ThisFcb, USN_REASON_STREAM_CHANGE );
                    Status = NtfsOpenNewAttr( IrpContext,
                                              Irp,
                                              IrpSp,
                                              ThisLcb,
                                              ThisFcb,
                                              LastFileNameOffset,
                                              AttrName,
                                              AttrTypeCode,
                                              FALSE,
                                              CcbFlags,
                                              TRUE,
                                              CreateFlags,
                                              ThisScb,
                                              ThisCcb );
                } else {

                    Status = STATUS_MEDIA_WRITE_PROTECTED;

                }
            }

            if (*ThisScb != NULL) {

                if (*ThisCcb != NULL) {

                    SetFlag( (*ThisCcb)->Flags,
                             CCB_FLAG_UPDATE_LAST_CHANGE | CCB_FLAG_SET_ARCHIVE );
                }

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CREATE_MOD_SCB );
            }
        }
    }

    DebugTrace( -1, Dbg, ("NtfsOpenAttributeInExistingFile:  Exit - %x\n", Status) );

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
NtfsOpenExistingAttr (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN ULONG CcbFlags,
    IN ULONG CreateFlags,
    IN BOOLEAN DirectoryOpen,
    IN PVOID NetworkInfo OPTIONAL,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    )

/*++

Routine Description:

    This routine is called to open an existing attribute.  We check the
    requested file access, the existance of
    an Ea buffer and the security on this file.  If these succeed then
    we check the batch oplocks and regular oplocks on the file.
    We also verify whether we need to retrieve a reparse point or not.
    If we have gotten this far, we simply call our routine to open the
    attribute.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the Irp stack pointer for the filesystem.

    ThisLcb - This is the Lcb used to reach this Fcb.

    ThisFcb - This is the Fcb to open.

    LastFileNameOffset - This is the offset in the full path name of the
        final component.

    AttrName - This is the attribute name in case we need to create
        an Scb.

    AttrTypeCode - This is the attribute type code to use to create
        the Scb.

    CcbFlags - This is the flag field for the Ccb.

    CreateFlags - Indicates if this open is by file Id.

    DirectoryOpen - Indicates whether this open is a directory open or a data stream.

    NetworkInfo - If specified then this call is a fast open call to query
        the network information.  We don't update any of the in-memory structures
        for this.

    ThisScb - This is the address to store the address of the Scb.

    ThisCcb - This is the address to store the address of the Ccb.

Return Value:

    NTSTATUS - The result of opening this indexed attribute.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS OplockStatus;

    SHARE_MODIFICATION_TYPE ShareModificationType;
    TYPE_OF_OPEN TypeOfOpen;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenExistingAttr:  Entered\n") );

    //
    //  For data streams we need to do a check that includes an oplock check.
    //  For directories we just need to figure the share modification type.
    //
    //  We also figure the type of open and the node type code based on the
    //  directory flag.
    //

    if (DirectoryOpen) {

        //
        //  Check for valid access on an existing file.
        //

        Status = NtfsCheckExistingFile( IrpContext,
                                        IrpSp,
                                        ThisLcb,
                                        ThisFcb,
                                        CcbFlags );

        ShareModificationType = (ThisFcb->CleanupCount == 0 ? SetShareAccess : CheckShareAccess);
        TypeOfOpen = UserDirectoryOpen;

    } else {

        //
        //  Don't break the batch oplock if opening to query the network info.
        //

        if (!ARGUMENT_PRESENT( NetworkInfo )) {

            Status = NtfsBreakBatchOplock( IrpContext,
                                           Irp,
                                           IrpSp,
                                           ThisFcb,
                                           AttrName,
                                           AttrTypeCode,
                                           ThisScb );

            if (Status != STATUS_PENDING) {

                if (NT_SUCCESS( Status = NtfsCheckExistingFile( IrpContext,
                                                                IrpSp,
                                                                ThisLcb,
                                                                ThisFcb,
                                                                CcbFlags ))) {

                    Status = NtfsOpenAttributeCheck( IrpContext,
                                                     Irp,
                                                     IrpSp,
                                                     ThisScb,
                                                     &ShareModificationType );

                    TypeOfOpen = UserFileOpen ;
                }
            }

        //
        //  We want to perform the ACL check but not break any oplocks for the
        //  NetworkInformation query.
        //

        } else {

            Status = NtfsCheckExistingFile( IrpContext,
                                            IrpSp,
                                            ThisLcb,
                                            ThisFcb,
                                            CcbFlags );

            TypeOfOpen = UserFileOpen;

            ASSERT( NtfsIsTypeCodeUserData( AttrTypeCode ));
        }
    }

    //
    //  End-of-name call to retrieve a reparse point.
    //  The file information in ThisFcb tells whether this is a reparse point.
    //
    //  In three cases we proceed with the normal open for the file:
    //
    //  (1) When FILE_OPEN_REPARSE_POINT is set, as the caller wants a handle on the
    //      reparse point itself.
    //  (2) When we are retrieving the NetworkInfo, as then the caller can identify
    //      the reparse points and decide what to do, without having the need of apriori
    //      knowledge of where they are in the system.
    //      Note: when we retrieve NetworkInfo we can have FILE_OPEN_REPARSE_POINT set.
    //  (3) The data manipulation aspect of the DesiredAccess for this request was, exactly,
    //      FILE_READ_ATTRIBUTES, in which case we give a handle to the local entity.
    //
    //  Otherwise, we retrieve the value of the $REPARSE_POINT attribute.
    //
    //  Note: The logic in the if was re-arranged for performance. It used to read:
    //
    //        NT_SUCCESS( Status ) &&
    //        (Status != STATUS_PENDING) &&
    //        !ARGUMENT_PRESENT( NetworkInfo ) &&
    //        FlagOn( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT ) &&
    //        !FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_REPARSE_POINT )
    //

    if ((Status != STATUS_PENDING) &&
        FlagOn( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT ) &&
        NT_SUCCESS( Status ) &&
        !FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_REPARSE_POINT )) {

        USHORT AttributeNameLength = 0;

        //
        //  We exclude the case when we get the $I30 name and $INDEX_ALLOCATION type
        //  as this is the standard manner of opening a directory.
        //

        if (!((AttrName.Length == NtfsFileNameIndex.Length) &&
              (AttrTypeCode == $INDEX_ALLOCATION) &&
              (RtlEqualMemory( AttrName.Buffer, NtfsFileNameIndex.Buffer, AttrName.Length )))) {

             if (AttrName.Length > 0) {
                 ASSERT( AttrName.Length == ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeNameLength );
                 AttributeNameLength += AttrName.Length + 2;
             }
             if (((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength > 0) {
                AttributeNameLength += ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength + 2;
             }
        }
        DebugTrace( 0, Dbg, ("AttrTypeCode %x AttrName.Length (2) = %d AttributeCodeNameLength %d LastFileNameOffset %d\n",
                   AttrTypeCode, AttrName.Length, ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength, LastFileNameOffset) );

        Status = NtfsGetReparsePointValue( IrpContext,
                                           Irp,
                                           IrpSp,
                                           ThisFcb,
                                           AttributeNameLength );
    }

    //
    //  If we didn't post the Irp and we did not retrieve a reparse point
    //  and the operations above were successful, we proceed with the open.
    //

    if (NT_SUCCESS( Status ) &&
        (Status != STATUS_PENDING) &&
        (Status != STATUS_REPARSE)) {

        //
        //  Now actually open the attribute.
        //

        OplockStatus = Status;

        Status = NtfsOpenAttribute( IrpContext,
                                    IrpSp,
                                    ThisFcb->Vcb,
                                    ThisLcb,
                                    ThisFcb,
                                    LastFileNameOffset,
                                    AttrName,
                                    AttrTypeCode,
                                    ShareModificationType,
                                    TypeOfOpen,
                                    FALSE,
                                    (FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID )
                                     ? CcbFlags | CCB_FLAG_OPEN_BY_FILE_ID
                                     : CcbFlags),
                                    NetworkInfo,
                                    ThisScb,
                                    ThisCcb );

        //
        //  If there are no errors at this point, we set the caller's Iosb.
        //

        if (NT_SUCCESS( Status )) {

            //
            //  We need to remember if the oplock break is in progress.
            //

            Status = OplockStatus;
            Irp->IoStatus.Information = FILE_OPENED;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsOpenExistingAttr:  Exit -> %08lx\n", Status) );

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
NtfsOverwriteAttr (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN BOOLEAN Supersede,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN ULONG CcbFlags,
    IN ULONG CreateFlags,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    )

/*++

Routine Description:

    This routine is called to overwrite an existing attribute.  We do all of
    the same work as opening an attribute except that we can change the
    allocation of a file.  This routine will handle the case where a
    file is being overwritten and the case where just an attribute is
    being overwritten.  In the case of the former, we may change the
    file attributes of the file as well as modify the Ea's on the file.
    After doing all the access checks, we also verify whether we need to
    retrieve a reparse point or not.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the stack location for this open.

    ThisLcb - This is the Lcb we used to reach this Fcb.

    ThisFcb - This is the Fcb for the file being opened.

    Supersede - This indicates whether this is a supersede or overwrite
        operation.

    LastFileNameOffset - This is the offset in the full path name of the
        final component.

    AttrName - This is the attribute name in case we need to create
        an Scb.

    AttrTypeCode - This is the attribute type code to use to create
        the Scb.

    CcbFlags - This is the flag field for the Ccb.

    CreateFlags - Indicates if this open is by file Id.

    ThisScb - This is the address to store the address of the Scb.

    ThisCcb - This is the address to store the address of the Ccb.

Return Value:

    NTSTATUS - The result of opening this indexed attribute.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS OplockStatus;

    ULONG FileAttributes;
    ULONG PreviousFileAttributes;
    PACCESS_MASK DesiredAccess;
    ACCESS_MASK AddedAccess = 0;
    BOOLEAN MaximumRequested = FALSE;

    SHARE_MODIFICATION_TYPE ShareModificationType;

    PFILE_FULL_EA_INFORMATION FullEa = NULL;
    ULONG FullEaLength = 0;

    ULONG IncomingFileAttributes = 0;                               //  invalid value
    ULONG IncomingReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;   //  invalid value

    BOOLEAN DecrementScbCloseCount = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOverwriteAttr:  Entered\n") );

    DesiredAccess = &IrpSp->Parameters.Create.SecurityContext->DesiredAccess;

    if (FlagOn( *DesiredAccess, MAXIMUM_ALLOWED )) {

        MaximumRequested = TRUE;
    }

    //
    //  Check the oplock state of this file.
    //

    Status = NtfsBreakBatchOplock( IrpContext,
                                   Irp,
                                   IrpSp,
                                   ThisFcb,
                                   AttrName,
                                   AttrTypeCode,
                                   ThisScb );

    if (Status == STATUS_PENDING) {

        DebugTrace( -1, Dbg, ("NtfsOverwriteAttr:  Exit  ->  %08lx\n", Status) );
        return Status;
    }

    //
    //  Remember the value of the file attribute flags and of the reparse point.
    //  If we succeed in NtfsRemoveReparsePoint but fail afterwards, we leave the duplicate
    //  information in an inconsistent state.
    //

    IncomingFileAttributes = ThisFcb->Info.FileAttributes;
    IncomingReparsePointTag = ThisFcb->Info.ReparsePointTag;

    //
    //  We first want to check that the caller's desired access and specified
    //  file attributes are compatible with the state of the file.  There
    //  are the two overwrite cases to consider.
    //
    //      OverwriteFile - The hidden and system bits passed in by the
    //          caller must match the current values.
    //
    //      OverwriteAttribute - We also modify the requested desired access
    //          to explicitly add the implicit access needed by overwrite.
    //
    //  We also check that for the overwrite attribute case, there isn't
    //  an Ea buffer specified.
    //

    if (FlagOn( CcbFlags, CCB_FLAG_OPEN_AS_FILE )) {

        BOOLEAN Hidden;
        BOOLEAN System;

        //
        //  Get the file attributes and clear any unsupported bits.
        //

        FileAttributes = (ULONG) IrpSp->Parameters.Create.FileAttributes;

        //
        //  Always set the archive bit in this operation.
        //

        SetFlag( FileAttributes, FILE_ATTRIBUTE_ARCHIVE );
        ClearFlag( FileAttributes,
                   ~FILE_ATTRIBUTE_VALID_SET_FLAGS | FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED );

        if (IsEncrypted( &ThisFcb->Info )) {

            SetFlag( FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
        }

        DebugTrace( 0, Dbg, ("Checking hidden/system for overwrite/supersede\n") );

        Hidden = BooleanIsHidden( &ThisFcb->Info );
        System = BooleanIsSystem( &ThisFcb->Info );

        if ((Hidden && !FlagOn(FileAttributes, FILE_ATTRIBUTE_HIDDEN)
            ||
            System && !FlagOn(FileAttributes, FILE_ATTRIBUTE_SYSTEM))

                &&

            !FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE )) {

            DebugTrace( 0, Dbg, ("The hidden and/or system bits do not match\n") );

            Status = STATUS_ACCESS_DENIED;

            DebugTrace( -1, Dbg, ("NtfsOverwriteAttr:  Exit  ->  %08lx\n", Status) );
            return Status;
        }

        //
        //  If the user specified an Ea buffer and they are Ea blind, we deny
        //  access.
        //

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_EA_KNOWLEDGE ) &&
            (Irp->AssociatedIrp.SystemBuffer != NULL)) {

            DebugTrace( 0, Dbg, ("This opener cannot create Ea's\n") );

            Status = STATUS_ACCESS_DENIED;

            DebugTrace( -1, Dbg, ("NtfsOverwriteAttr:  Exit  ->  %08lx\n", Status) );
            return Status;
        }

        //
        //  Add in the extra required access bits if we don't have restore privilege
        //  which would automatically grant them to us
        //

        if (!FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ) &&
            !FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->Flags, TOKEN_HAS_RESTORE_PRIVILEGE )) {

            SetFlag( AddedAccess,
                     (FILE_WRITE_EA | FILE_WRITE_ATTRIBUTES) & ~(*DesiredAccess) );

            SetFlag( *DesiredAccess, FILE_WRITE_EA | FILE_WRITE_ATTRIBUTES );
        }

    } else if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        DebugTrace( 0, Dbg, ("Can't specifiy an Ea buffer on an attribute overwrite\n") );

        Status = STATUS_INVALID_PARAMETER;

        DebugTrace( -1, Dbg, ("NtfsOverwriteAttr:  Exit  ->  %08lx\n", Status) );
        return Status;
    }

    //
    //  Supersede or overwrite require specific access. We skip this step if we have the restore privilege
    //  which already grants these to us
    //

    if (!FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE ) &&
        !FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->Flags, TOKEN_HAS_RESTORE_PRIVILEGE )) {

        ULONG NewAccess = FILE_WRITE_DATA;

        if (Supersede) {

            NewAccess = DELETE;
        }

        //
        //  Check if the user already has this new access.
        //

        if (!FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                     NewAccess )) {

            SetFlag( AddedAccess,
                     NewAccess & ~(*DesiredAccess) );

            SetFlag( *DesiredAccess, NewAccess );
        }
    }

    //
    //  Check whether we can open this existing file.
    //

    Status = NtfsCheckExistingFile( IrpContext,
                                    IrpSp,
                                    ThisLcb,
                                    ThisFcb,
                                    CcbFlags );

    //
    //  If we have a success status then proceed with the oplock check and
    //  open the attribute.
    //

    if (NT_SUCCESS( Status )) {

        Status = NtfsOpenAttributeCheck( IrpContext,
                                         Irp,
                                         IrpSp,
                                         ThisScb,
                                         &ShareModificationType );

        //
        //  End-of-name call to retrieve a reparse point.
        //  The file information in ThisFcb tells whether this is a reparse point.
        //
        //  If we didn't post the Irp and the check operation was successful, and
        //  we do not have FILE_OPEN_REPARSE_POINT set, we retrieve the reparse point.
        //

        if (NT_SUCCESS( Status ) &&
            (Status != STATUS_PENDING)) {

            //
            //  If we can't truncate the file size then return now.  Since
            //  NtfsRemoveDataAttributes will be truncating all the data
            //  streams for this file, we need to loop through any existing
            //  scbs we have to make sure they are all truncatable.
            //

            PSCB Scb = NULL;

            //
            //  We need to reset the share access once we open the file.  This is because
            //  we may have added WRITE or DELETE access into the granted bits and
            //  they may be reflected in the file object.  We don't want them
            //  present after the create.
            //

            if (ShareModificationType == UpdateShareAccess) {

                ShareModificationType = RecheckShareAccess;
            }

            //
            //  If we biased the desired access we need to remove the same
            //  bits from the granted access.  If maximum allowed was
            //  requested then we can skip this.
            //

            if (!MaximumRequested) {

                ClearFlag( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                           AddedAccess );
            }

            //
            //  Also remove the bits from the desired access field so we won't
            //  see them if this request gets posted for any reason.
            //

            ClearFlag( *DesiredAccess, AddedAccess );

            if (FlagOn( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT ) &&
                !FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_REPARSE_POINT )) {

                USHORT AttributeNameLength = 0;

                //
                //  We exclude the case when we get the $I30 name and $INDEX_ALLOCATION type
                //  as this is the standard manner of opening a directory.
                //

                if (!((AttrName.Length == NtfsFileNameIndex.Length) &&
                      (AttrTypeCode == $INDEX_ALLOCATION) &&
                      (RtlEqualMemory( AttrName.Buffer, NtfsFileNameIndex.Buffer, AttrName.Length )))) {

                    if (AttrName.Length > 0) {
                        ASSERT( AttrName.Length == ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeNameLength );
                        AttributeNameLength += AttrName.Length + 2;
                    }
                    if (((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength > 0) {
                        AttributeNameLength += ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength + 2;
                    }
                }
                DebugTrace( 0, Dbg, ("AttrTypeCode %x AttrName.Length (3) = %d AttributeCodeNameLength %d LastFileNameOffset %d\n",
                           AttrTypeCode, AttrName.Length, ((POPLOCK_CLEANUP)(IrpContext->Union.OplockCleanup))->AttributeCodeNameLength, LastFileNameOffset) );

                Status = NtfsGetReparsePointValue( IrpContext,
                                                   Irp,
                                                   IrpSp,
                                                   ThisFcb,
                                                   AttributeNameLength );

                //
                //  Exit if we failed or this is a reparse point.
                //

                if (!NT_SUCCESS( Status ) || (Status == STATUS_REPARSE)) {

                    return Status;
                }
            }

            //
            //  Reference the Fcb so it doesn't go away.
            //

            InterlockedIncrement( &ThisFcb->CloseCount );

            //
            //  Use a try-finally to restore the close count correctly.
            //

            try {

                //
                //  Make sure the current Scb doesn't get deallocated in the test below.
                //

                if (*ThisScb != NULL) {

                    InterlockedIncrement( &(*ThisScb)->CloseCount );
                    DecrementScbCloseCount = TRUE;
                }

                while (TRUE) {

                    Scb = NtfsGetNextChildScb( ThisFcb, Scb );

                    if (Scb == NULL) { break; }

                    InterlockedIncrement( &Scb->CloseCount );
                    if (!MmCanFileBeTruncated( &(Scb)->NonpagedScb->SegmentObject,
                                               &Li0 )) {

                        Status = STATUS_USER_MAPPED_FILE;
                        DebugTrace( -1, Dbg, ("NtfsOverwriteAttr:  Exit  ->  %08lx\n", Status) );

                        //
                        //  The Scb close count will get decremented when we test
                        //  for Scb != NULL below.
                        //

                        try_return( Status );
                    }
                    InterlockedDecrement( &Scb->CloseCount );
                }

                //
                //  Remember the status from the oplock check.
                //

                OplockStatus = Status;

                //
                //  We perform the on-disk changes.  For a file overwrite, this includes
                //  the Ea changes and modifying the file attributes.  For an attribute,
                //  this refers to modifying the allocation size.  We need to keep the
                //  Fcb updated and remember which values we changed.
                //

                if (Irp->AssociatedIrp.SystemBuffer != NULL) {

                    //
                    //  Remember the values in the Irp.
                    //

                    FullEa = (PFILE_FULL_EA_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
                    FullEaLength = IrpSp->Parameters.Create.EaLength;
                }

                //
                //  Now do the file attributes and either remove or mark for
                //  delete all of the other $DATA attributes on the file.
                //

                if (FlagOn( CcbFlags, CCB_FLAG_OPEN_AS_FILE )) {

                    //
                    //  When appropriate, delete the reparse point attribute.
                    //  This needs to be done prior to any modification to the Fcb, as we use
                    //  the value of the reparse point tag stored in ThisFcb.Info
                    //

                    if (FlagOn( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

                        //
                        //  Verify that the volume is of the appropriate kind.
                        //  Otherwise access a non-existing index.
                        //

                        if (!NtfsVolumeVersionCheck( ThisFcb->Vcb, NTFS_REPARSE_POINT_VERSION )) {

                            //
                            //  Return a volume not upgraded error.
                            //

                            Status = STATUS_VOLUME_NOT_UPGRADED;
                            DebugTrace( 0, Dbg, ("Trying to delete a reparse point in a back-level volume.\n") );
                            DebugTrace( -1, Dbg, ("NtfsOverwriteAttr:  Exit  ->  %08lx\n", Status) );

                            try_return( Status );
                        }

                        //
                        //  Remove the reparse point attribute.
                        //

                        NtfsRemoveReparsePoint( IrpContext,
                                                ThisFcb );

                        //
                        //  NtfsRemoveReparsPoint will commit if it removes the reparse point.  Update our
                        //  captured info values if there is no transaction.
                        //

                        if (IrpContext->TransactionId == 0) {

                            IncomingFileAttributes = ThisFcb->Info.FileAttributes;
                            IncomingReparsePointTag = ThisFcb->Info.ReparsePointTag;
                        }
                    }

                    //
                    //  This needs to happen after we delete the reparse point attribute to not
                    //  alter the value of the reparse point tag stored in ThisFcb.Info
                    //  Replace the current Ea's on the file.  This operation will update
                    //  the Fcb for the file.
                    //

                    NtfsAddEa( IrpContext,
                               ThisFcb->Vcb,
                               ThisFcb,
                               FullEa,
                               FullEaLength,
                               &Irp->IoStatus );

                    //
                    //  Copy the directory bit from the current Info structure.
                    //

                    if (IsDirectory( &ThisFcb->Info)) {

                        SetFlag( FileAttributes, DUP_FILE_NAME_INDEX_PRESENT );
                    }

                    //
                    //  Copy the view index bit from the current Info structure.
                    //

                    if (IsViewIndex( &ThisFcb->Info)) {

                        SetFlag( FileAttributes, DUP_VIEW_INDEX_PRESENT );
                    }

                    //
                    //  Remember the previous file attribute to capture the
                    //  state of the CONTENT_INDEX flag.
                    //

                    PreviousFileAttributes = ThisFcb->Info.FileAttributes;

                    //
                    //  Now either add to the current attributes or replace them.
                    //

                    if (Supersede) {

                        ThisFcb->Info.FileAttributes = FileAttributes;

                    } else {

                        ThisFcb->Info.FileAttributes |= FileAttributes;
                    }

                    //
                    //  Get rid of any named $DATA attributes in the file.
                    //

                    NtfsRemoveDataAttributes( IrpContext,
                                              ThisFcb,
                                              ThisLcb,
                                              IrpSp->FileObject,
                                              LastFileNameOffset,
                                              CreateFlags );

                    //
                    //  Check if the CONTENT_INDEX bit changed.
                    //

                    ASSERT( *ThisScb != NULL );

                    if (FlagOn( PreviousFileAttributes ^ ThisFcb->Info.FileAttributes,
                                FILE_ATTRIBUTE_NOT_CONTENT_INDEXED )) {

                        NtfsPostUsnChange( IrpContext, *ThisScb, USN_REASON_INDEXABLE_CHANGE );
                    }
                }
// **** CONSIDER SETTING SCB ENCRYPTED FLAG HERE??? ****
                //
                //  Now we perform the operation of opening the attribute.
                //

                NtfsReplaceAttribute( IrpContext,
                                      IrpSp,
                                      ThisFcb,
                                      *ThisScb,
                                      ThisLcb,
                                      *(PLONGLONG)&Irp->Overlay.AllocationSize );

                NtfsPostUsnChange( IrpContext, *ThisScb, USN_REASON_DATA_TRUNCATION );

                //
                //  If we are overwriting a fle and the user doesn't want it marked as
                //  compressed, then change the attribute flag.
                //  If we are overwriting a file and its previous state was sparse
                //  then also clear the sparse flag.
                //

                if (FlagOn( CcbFlags, CCB_FLAG_OPEN_AS_FILE )) {

                    if (!FlagOn( (*ThisScb)->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                        ClearFlag( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
                    }

                    if (!FlagOn( (*ThisScb)->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                        ClearFlag( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE );
                    }
                }

                //
                //  Now attempt to open the attribute.
                //

                ASSERT( NtfsIsTypeCodeUserData( AttrTypeCode ));

                Status = NtfsOpenAttribute( IrpContext,
                                            IrpSp,
                                            ThisFcb->Vcb,
                                            ThisLcb,
                                            ThisFcb,
                                            LastFileNameOffset,
                                            AttrName,
                                            AttrTypeCode,
                                            ShareModificationType,
                                            UserFileOpen,
                                            FALSE,
                                            (FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID )
                                             ? CcbFlags | CCB_FLAG_OPEN_BY_FILE_ID
                                             : CcbFlags),
                                            NULL,
                                            ThisScb,
                                            ThisCcb );

            try_exit:  NOTHING;
            } finally {

                //
                //  Roll back any temporary changes to the close counts.
                //

                if (DecrementScbCloseCount) {

                    InterlockedDecrement( &(*ThisScb)->CloseCount );
                }

                if (Scb != NULL) {

                    InterlockedDecrement( &Scb->CloseCount );
                }
                InterlockedDecrement( &ThisFcb->CloseCount );

                //
                //  Need to roll-back the value of the reparse point flag in case of
                //  problems.
                //

                if (AbnormalTermination()) {

                   ThisFcb->Info.FileAttributes = IncomingFileAttributes;
                   ThisFcb->Info.ReparsePointTag = IncomingReparsePointTag;
                }
            }

            if (NT_SUCCESS( Status )) {

                //
                //  Set the flag in the Scb to indicate that the size of the
                //  attribute has changed.
                //

                SetFlag( (*ThisScb)->ScbState, SCB_STATE_NOTIFY_RESIZE_STREAM );

                //
                //  Since this is an supersede/overwrite, purge the section
                //  so that mappers will see zeros.
                //

                CcPurgeCacheSection( IrpSp->FileObject->SectionObjectPointer,
                                     NULL,
                                     0,
                                     FALSE );

                //
                //  Remember the status of the oplock in the success code.
                //

                Status = OplockStatus;

                //
                //  Now update the Iosb information.
                //

                if (Supersede) {

                    Irp->IoStatus.Information = FILE_SUPERSEDED;

                } else {

                    Irp->IoStatus.Information = FILE_OVERWRITTEN;
                }
            }
        }
    }

    DebugTrace( -1, Dbg, ("NtfsOverwriteAttr:  Exit  ->  %08lx\n", Status) );

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
NtfsOpenNewAttr (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb,
    IN PFCB ThisFcb,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN LOGICAL CreateFile,
    IN ULONG CcbFlags,
    IN BOOLEAN LogIt,
    IN ULONG CreateFlags,
    OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    )

/*++

Routine Description:

    This routine is called to create a new attribute on the disk.
    All access and security checks have been done outside of this
    routine, all we do is create the attribute and open it.
    We test if the attribute will fit in the Mft record.  If so we
    create it there.  Otherwise we call the create attribute through
    allocation.

    We then open the attribute with our common routine.  In the
    resident case the Scb will have all file values set to
    the allocation size.  We set the valid data size back to zero
    and mark the Scb as truncate on close.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the stack location for this open.

    ThisLcb - This is the Lcb we used to reach this Fcb.

    ThisFcb - This is the Fcb for the file being opened.

    LastFileNameOffset - This is the offset in the full path name of the
        final component.

    AttrName - This is the attribute name in case we need to create
        an Scb.

    AttrTypeCode - This is the attribute type code to use to create
        the Scb.

    CreateFile - Indicates if we are in the create file path.

    CcbFlags - This is the flag field for the Ccb.

    LogIt - Indicates if we need to log the create operations.

    CreateFlags - Indicates if this open is related to a OpenByFile open.

    ThisScb - This is the address to store the address of the Scb.

    ThisCcb - This is the address to store the address of the Ccb.

Return Value:

    NTSTATUS - The result of opening this indexed attribute.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    BOOLEAN ScbExisted;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenNewAttr:  Entered\n") );

    //
    //  Check that the attribute name is legal.  The only restriction is the name length.
    //

    if (AttrName.Length > NTFS_MAX_ATTR_NAME_LEN * sizeof( WCHAR )) {

        DebugTrace( -1, Dbg, ("NtfsOpenNewAttr:  Exit -> %08lx\n", Status) );
        return STATUS_OBJECT_NAME_INVALID;
    }

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We create the Scb because we will use it.
        //

        *ThisScb = NtfsCreateScb( IrpContext,
                                  ThisFcb,
                                  AttrTypeCode,
                                  &AttrName,
                                  FALSE,
                                  &ScbExisted );

        //
        //  An attribute has gone away but the Scb hasn't left yet.
        //  Also mark the header as unitialized.
        //

        ClearFlag( (*ThisScb)->ScbState, SCB_STATE_HEADER_INITIALIZED |
                                         SCB_STATE_ATTRIBUTE_RESIDENT |
                                         SCB_STATE_FILE_SIZE_LOADED );

        //
        //  If we're creating an alternate stream in an encrypted file, and the
        //  loaded encryption driver wants the stream to be encrypted and uncompressed,
        //  we need to make sure the new stream is indeed created uncompressed.
        //

        if (IsEncrypted( &ThisFcb->Info ) &&
            (FlagOn( NtfsData.EncryptionCallBackTable.ImplementationFlags, ENCRYPTION_ALL_STREAMS | ENCRYPTION_ALLOW_COMPRESSION ) == ENCRYPTION_ALL_STREAMS)) {

            DebugTrace( 0, Dbg, ("Encrypted file, creating alternate stream uncompressed") );
            SetFlag( IrpSp->Parameters.Create.Options, FILE_NO_COMPRESSION );
        }

        //
        //  Create the attribute on disk and update the Scb and Fcb.
        //

        NtfsCreateAttribute( IrpContext,
                             IrpSp,
                             ThisFcb,
                             *ThisScb,
                             ThisLcb,
                             *(PLONGLONG)&Irp->Overlay.AllocationSize,
                             LogIt,
                             FALSE,
                             NULL );

        //
        //  Now actually open the attribute.
        //

        ASSERT( NtfsIsTypeCodeUserData( AttrTypeCode ));

        Status = NtfsOpenAttribute( IrpContext,
                                    IrpSp,
                                    ThisFcb->Vcb,
                                    ThisLcb,
                                    ThisFcb,
                                    LastFileNameOffset,
                                    AttrName,
                                    AttrTypeCode,
                                    (ThisFcb->CleanupCount != 0 ? CheckShareAccess : SetShareAccess),
                                    UserFileOpen,
                                    CreateFile,
                                    (CcbFlags | (FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID ) ? CCB_FLAG_OPEN_BY_FILE_ID : 0)),
                                    NULL,
                                    ThisScb,
                                    ThisCcb );

        //
        //  If there are no errors at this point, we set the caller's Iosb.
        //

        if (NT_SUCCESS( Status )) {

            //
            //  Read the attribute information from the disk.
            //

            NtfsUpdateScbFromAttribute( IrpContext, *ThisScb, NULL );

            //
            //  Set the flag to indicate that we created a stream and also remember to
            //  to check if we need to truncate on close.
            //

            NtfsAcquireFsrtlHeader( *ThisScb );
            SetFlag( (*ThisScb)->ScbState,
                     SCB_STATE_TRUNCATE_ON_CLOSE | SCB_STATE_NOTIFY_ADD_STREAM );

            //
            //  If we created a temporary stream then mark the Scb.
            //

            if (FlagOn( IrpSp->Parameters.Create.FileAttributes, FILE_ATTRIBUTE_TEMPORARY )) {

                SetFlag( (*ThisScb)->ScbState, SCB_STATE_TEMPORARY );
                SetFlag( IrpSp->FileObject->Flags, FO_TEMPORARY_FILE );
            }

            NtfsReleaseFsrtlHeader( *ThisScb );

            Irp->IoStatus.Information = FILE_CREATED;
        }

    } finally {

        DebugUnwind( NtfsOpenNewAttr );

        //
        //  Uninitialize the attribute context.
        //

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsOpenNewAttr:  Exit -> %08lx\n", Status) );
    }

    return Status;
}


//
//  Local support routine
//

BOOLEAN
NtfsParseNameForCreate (
    IN PIRP_CONTEXT IrpContext,
    IN UNICODE_STRING String,
    IN OUT PUNICODE_STRING FileObjectString,
    IN OUT PUNICODE_STRING OriginalString,
    IN OUT PUNICODE_STRING NewNameString,
    OUT PUNICODE_STRING AttrName,
    OUT PUNICODE_STRING AttrCodeName
    )

/*++

Routine Description:

    This routine parses the input string and remove any intermediate
    named attributes from intermediate nodes.  It verifies that all
    intermediate nodes specify the file name index attribute if any
    at all.  On output it will store the modified string which contains
    component names only, into the file object name pointer pointer.  It is legal
    for the last component to have attribute strings.  We pass those
    back via the attribute name strings.  We also construct the string to be stored
    back in the file object if we need to post this request.

Arguments:

    String - This is the string to normalize.

    FileObjectString - We store the normalized string into this pointer, removing the
        attribute and attribute code strings from all component.

    OriginalString - This is the same as the file object string except we append the
        attribute name and attribute code strings.  We assume that the buffer for this
        string is the same as the buffer for the FileObjectString.

    NewNameString - This is the string which contains the full name being parsed.
        If the buffer is different than the buffer for the Original string then any
        character shifts will be duplicated here.

    AttrName - We store the attribute name specified in the last component
        in this string.

    AttrCodeName - We store the attribute code name specified in the last
        component in this string.

Return Value:

    BOOLEAN - TRUE if the path is legal, FALSE otherwise.

--*/

{
    PARSE_TERMINATION_REASON TerminationReason;
    UNICODE_STRING ParsedPath;

    NTFS_NAME_DESCRIPTOR NameDescript;

    BOOLEAN RemovedComplexName = FALSE;

    LONG FileObjectIndex;
    LONG NewNameIndex;

    BOOLEAN SameBuffers = (OriginalString->Buffer == NewNameString->Buffer);

    PCUNICODE_STRING TestAttrName;
    PCUNICODE_STRING TestAttrCodeName;

    POPLOCK_CLEANUP OplockCleanup = IrpContext->Union.OplockCleanup;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsParseNameForCreate:  Entered\n") );

    //
    //  We loop through the input string calling ParsePath to swallow the
    //  biggest chunk we can.  The main case we want to deal with is
    //  when we encounter a non-simple name.  If this is not the
    //  final component, the attribute name and code type better
    //  indicate that this is a directory.  The only other special
    //  case we consider is the case where the string is an
    //  attribute only.  This is legal only for the first component
    //  of the file, and then only if there is no leading backslash.
    //

    //
    //  Initialize some return values.
    //

    AttrName->Length = 0;
    AttrCodeName->Length = 0;

    //
    //  Set up the indexes into our starting file object string.
    //

    FileObjectIndex = (LONG) FileObjectString->Length - (LONG) String.Length;
    NewNameIndex = (LONG) NewNameString->Length - (LONG) String.Length;

    //
    //  We don't allow trailing colons.
    //

    if (String.Buffer[(String.Length / sizeof( WCHAR )) - 1] == L':') {

        return FALSE;
    }

    if (String.Length != 0) {

        while (TRUE) {

            //
            //  Parse the next chunk in the input string.
            //

            TerminationReason = NtfsParsePath( String,
                                               FALSE,
                                               &ParsedPath,
                                               &NameDescript,
                                               &String );

            //
            //  Analyze the termination reason to discover if we can abort the
            //  parse process.
            //

            switch (TerminationReason) {

            case NonSimpleName :

                //
                //  We will do the work below.
                //

                break;

            case IllegalCharacterInName :
            case VersionNumberPresent :
            case MalFormedName :

                //
                //  We simply return an error.
                //

                DebugTrace( -1, Dbg, ("NtfsParseNameForCreate:  Illegal character\n") );
                return FALSE;

            case AttributeOnly :

                //
                //  This is legal only if it is the only component of a relative open.  We
                //  test this by checking that we are at the end of string and the file
                //  object name has a lead in ':' character or this is the root directory
                //  and the lead in characters are '\:'.
                //

                if ((String.Length != 0) ||
                    RemovedComplexName ||
                    (FileObjectString->Buffer[0] == L'\\' ?
                     FileObjectString->Buffer[1] != L':' :
                     FileObjectString->Buffer[0] != L':')) {

                    DebugTrace( -1, Dbg, ("NtfsParseNameForCreate:  Illegal character\n") );
                    return FALSE;
                }

                //
                //  We can drop down to the EndOfPath case as it will copy over
                //  the parsed path portion.
                //

            case EndOfPathReached :

                NOTHING;
            }

            //
            //  We add the filename part of the non-simple name to the parsed
            //  path.  Check if we can include the separator.
            //

            if ((TerminationReason != EndOfPathReached)
                && (FlagOn( NameDescript.FieldsPresent, FILE_NAME_PRESENT_FLAG ))) {

                if (ParsedPath.Length > sizeof( WCHAR )
                    || (ParsedPath.Length == sizeof( WCHAR )
                        && ParsedPath.Buffer[0] != L'\\')) {

                    ParsedPath.Length += sizeof( WCHAR );
                }

                ParsedPath.Length += NameDescript.FileName.Length;
            }

            FileObjectIndex += ParsedPath.Length;
            NewNameIndex += ParsedPath.Length;

            //
            //  If the remaining string is empty, then we remember any attributes and
            //  exit now.
            //

            if (String.Length == 0) {

                //
                //  If the name specified either an attribute or attribute
                //  name, we remember them.
                //

                if (FlagOn( NameDescript.FieldsPresent, ATTRIBUTE_NAME_PRESENT_FLAG )) {

                    *AttrName = NameDescript.AttributeName;
                }

                if (FlagOn( NameDescript.FieldsPresent, ATTRIBUTE_TYPE_PRESENT_FLAG )) {

                    *AttrCodeName = NameDescript.AttributeType;
                }

                break;
            }

            //
            //  This can only be the non-simple case.  If there is more to the
            //  name, then the attributes better describe a directory.  We also shift the
            //  remaining bytes of the string down.
            //

            ASSERT( FlagOn( NameDescript.FieldsPresent, ATTRIBUTE_NAME_PRESENT_FLAG | ATTRIBUTE_TYPE_PRESENT_FLAG ));

            TestAttrName = FlagOn( NameDescript.FieldsPresent,
                                   ATTRIBUTE_NAME_PRESENT_FLAG )
                           ? &NameDescript.AttributeName
                           : &NtfsEmptyString;

            TestAttrCodeName = FlagOn( NameDescript.FieldsPresent,
                                       ATTRIBUTE_TYPE_PRESENT_FLAG )
                               ? &NameDescript.AttributeType
                               : &NtfsEmptyString;

            //
            //  Valid Complex names are [$I30]:$INDEX_ALLOCATION
            //                          [$I30]:$BITMAP
            //                          :$ATTRIBUTE_LIST
            //                          :$REPARSE_POINT
            //

            if (!NtfsVerifyNameIsDirectory( IrpContext,
                                            TestAttrName,
                                            TestAttrCodeName ) &&

                !NtfsVerifyNameIsBitmap( IrpContext,
                                         TestAttrName,
                                         TestAttrCodeName ) &&

                !NtfsVerifyNameIsAttributeList( IrpContext,
                                                TestAttrName,
                                                TestAttrCodeName ) &&

                !NtfsVerifyNameIsReparsePoint( IrpContext,
                                                TestAttrName,
                                                TestAttrCodeName )) {

                DebugTrace( -1, Dbg, ("NtfsParseNameForCreate:  Invalid intermediate component\n") );
                return FALSE;
            }

            RemovedComplexName = TRUE;

            //
            //  We need to insert a separator and then move the rest of the string
            //  down.
            //

            FileObjectString->Buffer[FileObjectIndex / sizeof( WCHAR )] = L'\\';

            if (!SameBuffers) {

                NewNameString->Buffer[NewNameIndex / sizeof( WCHAR )] = L'\\';
            }

            FileObjectIndex += sizeof( WCHAR );
            NewNameIndex += sizeof( WCHAR );

            RtlMoveMemory( &FileObjectString->Buffer[FileObjectIndex / sizeof( WCHAR )],
                           String.Buffer,
                           String.Length );

            if (!SameBuffers) {

                RtlMoveMemory( &NewNameString->Buffer[NewNameIndex / sizeof( WCHAR )],
                               String.Buffer,
                               String.Length );
            }

            String.Buffer = &NewNameString->Buffer[NewNameIndex / sizeof( WCHAR )];
        }
    }

    //
    //  At this point the original string is the same as the file object string.
    //

    FileObjectString->Length = (USHORT) FileObjectIndex;
    NewNameString->Length = (USHORT) NewNameIndex;

    OriginalString->Length = FileObjectString->Length;

    //
    //  We want to store the attribute index values in the original name
    //  string.  We just need to extend the original name length.
    //

    if (AttrName->Length != 0
        || AttrCodeName->Length != 0) {

        OriginalString->Length += (2 + AttrName->Length);

        if (AttrCodeName->Length != 0) {

            OriginalString->Length += (2 + AttrCodeName->Length);
        }
    }

    //
    //  Store in the OPLOCK_CLEANUP structure the lengths of the names of the attribute and
    //  of the code.
    //

    OplockCleanup->AttributeNameLength = AttrName->Length;
    OplockCleanup->AttributeCodeNameLength = AttrCodeName->Length;

    DebugTrace( 0, Dbg, ("AttrName->Length %d AttrCodeName->Length %d\n", OplockCleanup->AttributeNameLength, OplockCleanup->AttributeCodeNameLength) );
    DebugTrace( -1, Dbg, ("NtfsParseNameForCreate:  Exit\n") );

    return TRUE;
}


//
//  Local support routine.
//

BOOLEAN
NtfsCheckValidFileAccess(
    IN PFCB ThisFcb,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    Common routine used to rule out access to files in open path. This only disallows
    always invalid open reqests / acl checks, oplocks sharing are done elsewhere

              Fail immediately if this is a special system file or the user wants an illegal access.

              We allow READ_ATTRIBUTES and some ACL access to a subset of system files.  Deny all
              access to the following files.

                USN Journal
                Volume Log File
                Volume Bitmap
                Boot File
                Bad Cluster File
                As of now undefined system files

             Check for supersede/overwrite first.


Arguments:

    Fcb - Address of the Fcb pointer where the $REPARSE_POINT attribute is located.

    IrpSp - This is the Irp stack pointer for the filesystem.

Return Value:

    TRUE if access is allowed

--*/
{
    ULONG CreateDisposition = (UCHAR) ((IrpSp->Parameters.Create.Options >> 24) & 0x000000ff);
    ULONG InvalidAccess;
    BOOLEAN Result = TRUE;

    PAGED_CODE()

    //
    //  Verify we don't have the system flag set on the root.
    //

    ASSERT( NtfsSegmentNumber( &ThisFcb->FileReference ) != ROOT_FILE_NAME_INDEX_NUMBER );

    if ((CreateDisposition == FILE_SUPERSEDE) ||
        (CreateDisposition == FILE_OVERWRITE) ||
        (CreateDisposition == FILE_OVERWRITE_IF) ||

        //
        //  Check for special system files.
        //

        (NtfsSegmentNumber( &ThisFcb->FileReference ) == LOG_FILE_NUMBER) ||
        (NtfsSegmentNumber( &ThisFcb->FileReference ) == BIT_MAP_FILE_NUMBER) ||
        (NtfsSegmentNumber( &ThisFcb->FileReference ) == BOOT_FILE_NUMBER) ||
        (NtfsSegmentNumber( &ThisFcb->FileReference ) == BAD_CLUSTER_FILE_NUMBER) ||
        FlagOn( ThisFcb->FcbState, FCB_STATE_USN_JOURNAL ) ||

        //
        //  Check for currently undefined system files.
        //

        ((NtfsSegmentNumber( &ThisFcb->FileReference ) < FIRST_USER_FILE_NUMBER) &&
         (NtfsSegmentNumber( &ThisFcb->FileReference ) > LAST_SYSTEM_FILE_NUMBER))) {

        Result = FALSE;

    } else {

        //
        //  If we are beyond the reserved range then use the ACL to protect the file.
        //

        if (NtfsSegmentNumber( &ThisFcb->FileReference ) >= FIRST_USER_FILE_NUMBER) {

            InvalidAccess = 0;

        //
        //  If we are looking at the $Extend directory then permit the ACL operations.
        //

        } else if (NtfsSegmentNumber( &ThisFcb->FileReference ) == EXTEND_NUMBER) {

            InvalidAccess = ~(FILE_READ_ATTRIBUTES | SYNCHRONIZE | READ_CONTROL | WRITE_DAC | WRITE_OWNER);

        //
        //  Otherwise restrict access severely.
        //

        } else {

            InvalidAccess = ~(FILE_READ_ATTRIBUTES | SYNCHRONIZE);
        }

        if (FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess, InvalidAccess )) {

            Result = FALSE;
        }
    }

    return Result;
}


NTSTATUS
NtfsCheckValidAttributeAccess (
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN PDUPLICATED_INFORMATION Info OPTIONAL,
    IN OUT PUNICODE_STRING AttrName,
    IN UNICODE_STRING AttrCodeName,
    IN ULONG CreateFlags,
    OUT PATTRIBUTE_TYPE_CODE AttrTypeCode,
    OUT PULONG CcbFlags,
    OUT PBOOLEAN IndexedAttribute
    )

/*++

Routine Description:

    This routine looks at the file, the specified attribute name and
    code to determine if an attribute of this file may be opened
    by this user.  If there is a conflict between the file type
    and the attribute name and code, or the specified type of attribute
    (directory/nondirectory) we will return FALSE.
    We also check that the attribute code string is defined for the
    volume at this time.

    The final check of this routine is just whether a user is allowed
    to open the particular attribute or if Ntfs will guard them.

Arguments:

    IrpSp - This is the stack location for this open.

    Vcb - This is the Vcb for this volume.

    Info - If specified, this is the duplicated information for this file.

    AttrName - This is the attribute name specified.

    AttrCodeName - This is the attribute code name to use to open the attribute.

    AttrTypeCode - Used to store the attribute type code determined here.

    CreateFlags - Create flags - we care about the trailing backslash

    CcbFlags - We set the Ccb flags here to store in the Ccb later.

    IndexedAttribute - Set to indicate the type of open.

Return Value:

    NTSTATUS - STATUS_SUCCESS if access is allowed, the status code indicating
        the reason for denial otherwise.

--*/

{
    BOOLEAN Indexed;
    ATTRIBUTE_TYPE_CODE AttrType;
    ULONG  CreateDisposition =  ((IrpSp->Parameters.Create.Options >> 24) & 0x000000ff);

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCheckValidAttributeAccess:  Entered\n") );

    //
    //  If the user specified a attribute code string, we find the
    //  corresponding attribute.  If there is no matching attribute
    //  type code then we report that this access is invalid.
    //

    if (AttrCodeName.Length != 0) {

        AttrType = NtfsGetAttributeTypeCode( Vcb, &AttrCodeName );

        if (AttrType == $UNUSED) {

            DebugTrace( -1, Dbg, ("NtfsCheckValidAttributeAccess:  Bad attribute name for index\n") );
            return STATUS_INVALID_PARAMETER;

        //
        //  If the type code is Index allocation, and this isn't a view index,
        //  then the name better be the filename index.  If so then we clear the
        //  name length value to make our other tests work.
        //

        } else if (AttrType == $INDEX_ALLOCATION) {

            if (AttrName->Length != 0) {

                if (NtfsAreNamesEqual( Vcb->UpcaseTable, AttrName, &NtfsFileNameIndex, TRUE )) {

                    AttrName->Length = 0;

                } else {

                    //
                    //  This isn't a filename index, so it better be a view index.
                    //

                    if (!ARGUMENT_PRESENT(Info) || !IsViewIndex( Info )) {

                        DebugTrace( -1, Dbg, ("NtfsCheckValidAttributeAccess:  Bad name for index allocation\n") );
                        return STATUS_INVALID_PARAMETER;
                    }
                }
            }

        } else if (AttrType != $DATA) {

            //
            //  never allow supersede  on any other name attributes
            //

            if ((CreateDisposition == FILE_SUPERSEDE) ||
                (CreateDisposition == FILE_OVERWRITE) ||
                (CreateDisposition == FILE_OVERWRITE_IF))  {

                return STATUS_ACCESS_DENIED;
            }
        }

        DebugTrace( 0, Dbg, ("Attribute type code  ->  %04x\n", AttrType) );

    } else {

        AttrType = $UNUSED;
    }

    //
    //  Pull some values out of the Irp and IrpSp.
    //

    Indexed = BooleanFlagOn( IrpSp->Parameters.Create.Options,
                             FILE_DIRECTORY_FILE );

    //
    //  We need to determine whether the user expects to open an
    //  indexed or non-indexed attribute.  If either of the
    //  directory/non-directory flags in the Irp stack are set,
    //  we will use those.
    //
    //  Otherwise we need to examine some of the other input parameters.
    //  We have the following information:
    //
    //      1 - We may have a duplicated information structure for the file.
    //          (Not present on a create).
    //      2 - The user specified the name with a trailing backslash.
    //      3 - The user passed in an attribute name.
    //      4 - The user passed in an attribute type.
    //
    //  We first look at the attribute type code and name.  If they are
    //  both unspecified we determine the type of access by following
    //  the following steps.
    //
    //      1 - If there is a duplicated information structure we
    //          set the code to $INDEX_ALLOCATION and remember
    //          this is indexed.  Otherwise this is a $DATA
    //          attribute.
    //
    //      2 - If there is a trailing backslash we assume this is
    //          an indexed attribute.
    //
    //  If have an attribute code type or name, then if the code type is
    //  $INDEX_ALLOCATION without a name this is an indexed attribute.
    //  Otherwise we assume a non-indexed attribute.
    //

    if (!FlagOn( IrpSp->Parameters.Create.Options,
                    FILE_NON_DIRECTORY_FILE | FILE_DIRECTORY_FILE) &&
        (AttrName->Length == 0)) {

        if (AttrType == $UNUSED) {

            if (ARGUMENT_PRESENT( Info )) {

                Indexed = BooleanIsDirectory( Info );

            } else {

                Indexed = FALSE;
            }

        } else if (AttrType == $INDEX_ALLOCATION) {

            Indexed = TRUE;
        }

    } else if (AttrType == $INDEX_ALLOCATION) {

        Indexed = TRUE;
    }

    //
    //  If the type code was unspecified, we can assume it from the attribute
    //  name and the type of the file.  If the file is a directory and
    //  there is no attribute name, we assume this is an indexed open.
    //  Otherwise it is a non-indexed open.
    //

    if (AttrType == $UNUSED) {

        if (Indexed && AttrName->Length == 0) {

            AttrType = $INDEX_ALLOCATION;

        } else {

            AttrType = $DATA;
        }
    }

    //
    //  If the user specified directory all we need to do is check the
    //  following condition.
    //
    //      1 - If the file was specified, it must be a directory.
    //      2 - The attribute type code must be $INDEX_ALLOCATION with either:
    //             no attribute name
    //                    or
    //             duplicate info present & view index bit set in dupe info
    //      3 - The user isn't trying to open the volume.
    //

    if (Indexed) {

        if ((AttrType != $INDEX_ALLOCATION) ||

                ((AttrName->Length != 0) &&
                 ((!ARGUMENT_PRESENT( Info )) || !IsViewIndex( Info )))) {

            DebugTrace( -1, Dbg, ("NtfsCheckValidAttributeAccess:  Conflict in directory\n") );
            return STATUS_NOT_A_DIRECTORY;

        //
        //  If there is a current file and it is not a directory and
        //  the caller wanted to perform a create.  We return
        //  STATUS_OBJECT_NAME_COLLISION, otherwise we return STATUS_NOT_A_DIRECTORY.
        //

        } else if (ARGUMENT_PRESENT( Info ) &&
                   !IsDirectory( Info ) &&
                   !IsViewIndex( Info)) {

            if (((IrpSp->Parameters.Create.Options >> 24) & 0x000000ff) == FILE_CREATE) {

                return STATUS_OBJECT_NAME_COLLISION;

            } else {

                return STATUS_NOT_A_DIRECTORY;
            }
        }

        SetFlag( *CcbFlags, CCB_FLAG_OPEN_AS_FILE );

    //
    //  If the user specified a non-directory that means he is opening a non-indexed
    //  attribute.  We check for the following condition.
    //
    //      1 - Only the unnamed data attribute may be opened for a volume.
    //      2 - We can't be opening an unnamed $INDEX_ALLOCATION attribute.
    //

    } else {

        //
        //  Now determine if we are opening the entire file.
        //

        if (AttrType == $DATA) {

            if (AttrName->Length == 0) {
                SetFlag( *CcbFlags, CCB_FLAG_OPEN_AS_FILE );
            }

        } else {

            //
            //  For all other attributes only support read attributes access
            //

            if (IrpSp->Parameters.Create.SecurityContext->AccessState->OriginalDesiredAccess & ~(FILE_READ_ATTRIBUTES | SYNCHRONIZE)) {

                return STATUS_ACCESS_DENIED;
            }
        }

        if (ARGUMENT_PRESENT( Info ) &&
            IsDirectory( Info ) &&
            FlagOn( *CcbFlags, CCB_FLAG_OPEN_AS_FILE )) {

            DebugTrace( -1, Dbg, ("NtfsCheckValidAttributeAccess:  Can't open directory as file\n") );
            return STATUS_FILE_IS_A_DIRECTORY;
        }
    }

    //
    //  If we make it this far, lets check that we will allow access to
    //  the attribute specified.  Typically we only allow the user to
    //  access non system files.  Also only the Data attributes and
    //  attributes created by the user may be opened.  We will protect
    //  these with boolean flags to allow the developers to enable
    //  reading any attributes.
    //

    if (NtfsProtectSystemAttributes) {

        if (!NtfsIsTypeCodeUserData( AttrType ) &&
            ((AttrType != $INDEX_ALLOCATION) || !Indexed) &&
            (AttrType != $BITMAP) &&
            (AttrType != $ATTRIBUTE_LIST) &&
            (AttrType != $REPARSE_POINT) &&
            (AttrType < $FIRST_USER_DEFINED_ATTRIBUTE)) {

            DebugTrace( -1, Dbg, ("NtfsCheckValidAttributeAccess:  System attribute code\n") );
            return STATUS_ACCESS_DENIED;
        }

    }

    //
    //  Now check if the trailing backslash is compatible with the
    //  file being opened.
    //

    if (FlagOn( CreateFlags, CREATE_FLAG_TRAILING_BACKSLASH )) {

        if (!Indexed ||
            FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE )) {

            return STATUS_OBJECT_NAME_INVALID;

        } else {

            Indexed = TRUE;
            AttrType = $INDEX_ALLOCATION;
        }
    }

    //
    //  If we are opening the default index allocation stream, set its attribute
    //  name appropriately.
    //

    if ((AttrType == $INDEX_ALLOCATION || AttrType == $BITMAP) &&
        AttrName->Length == 0) {

        *AttrName = NtfsFileNameIndex;
    }

    *IndexedAttribute = Indexed;
    *AttrTypeCode = AttrType;

    DebugTrace( -1, Dbg, ("NtfsCheckValidAttributeAccess:  Exit\n") );

    return STATUS_SUCCESS;
}


//
//  Local support routine.
//

NTSTATUS
NtfsOpenAttributeCheck (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    OUT PSCB *ThisScb,
    OUT PSHARE_MODIFICATION_TYPE ShareModificationType
    )

/*++

Routine Description:

    This routine is a general routine which checks if an existing
    non-indexed attribute may be opened.  It considers only the oplock
    state of the file and the current share access.  In the course of
    performing these checks, the Scb for the attribute may be
    created and the share modification for the actual OpenAttribute
    call is determined.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the stack location for this open.

    ThisScb - Address to store the Scb if found or created.

    ShareModificationType - Address to store the share modification type
        for a subsequent OpenAttribute call.

Return Value:

    NTSTATUS - The result of opening this indexed attribute.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN DeleteOnClose;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenAttributeCheck:  Entered\n") );

    //
    //  We should already have the Scb for this file.
    //

    ASSERT_SCB( *ThisScb );

    //
    //  If there are other opens on this file, we need to check the share
    //  access before we check the oplocks.  We remember that
    //  we did the share access check by simply updating the share
    //  access we open the attribute.
    //

    if ((*ThisScb)->CleanupCount != 0) {

        //
        //  We check the share access for this file without updating it.
        //

        Status = IoCheckShareAccess( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                                     IrpSp->Parameters.Create.ShareAccess,
                                     IrpSp->FileObject,
                                     &(*ThisScb)->ShareAccess,
                                     FALSE );

        if (!NT_SUCCESS( Status )) {

            DebugTrace( -1, Dbg, ("NtfsOpenAttributeCheck:  Exit -> %08lx\n", Status) );
            return Status;
        }

        DebugTrace( 0, Dbg, ("Check oplock state of existing Scb\n") );

        if (SafeNodeType( *ThisScb ) == NTFS_NTC_SCB_DATA) {

            //
            //  If the handle count is greater than 1 then fail this
            //  open now if the caller wants a filter oplock.
            //

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_RESERVE_OPFILTER ) &&
                ((*ThisScb)->CleanupCount > 1)) {

                NtfsRaiseStatus( IrpContext, STATUS_OPLOCK_NOT_GRANTED, NULL, NULL );
            }

            Status = FsRtlCheckOplock( &(*ThisScb)->ScbType.Data.Oplock,
                                       Irp,
                                       IrpContext,
                                       NtfsOplockComplete,
                                       NtfsOplockPrePostIrp );

            //
            //  Update the FastIoField.
            //

            NtfsAcquireFsrtlHeader( *ThisScb );
            (*ThisScb)->Header.IsFastIoPossible = NtfsIsFastIoPossible( *ThisScb );
            NtfsReleaseFsrtlHeader( *ThisScb );

            //
            //  If the return value isn't success or oplock break in progress
            //  the irp has been posted.  We return right now.
            //

            if (Status == STATUS_PENDING) {

                DebugTrace( 0, Dbg, ("Irp posted through oplock routine\n") );

                DebugTrace( -1, Dbg, ("NtfsOpenAttributeCheck:  Exit -> %08lx\n", Status) );
                return Status;
            }
        }

        *ShareModificationType = UpdateShareAccess;

    //
    //  If the unclean count in the Fcb is 0, we will simply set the
    //  share access.
    //

    } else {

        *ShareModificationType = SetShareAccess;
    }

    DeleteOnClose = BooleanFlagOn( IrpSp->Parameters.Create.Options,
                                   FILE_DELETE_ON_CLOSE );

    //
    //  Can't do DELETE_ON_CLOSE on read only volumes.
    //

    if (DeleteOnClose && NtfsIsVolumeReadOnly( (*ThisScb)->Vcb )) {

        DebugTrace( -1, Dbg, ("NtfsOpenAttributeCheck:  Exit -> %08lx\n", STATUS_CANNOT_DELETE) );
        return STATUS_CANNOT_DELETE;
    }

    //
    //  If the user wants write access access to the file make sure there
    //  is process mapping this file as an image.  Any attempt to delete
    //  the file will be stopped in fileinfo.c
    //

    if (FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                FILE_WRITE_DATA )
        || DeleteOnClose) {

        //
        //  Use a try-finally to decrement the open count.  This is a little
        //  bit of trickery to keep the scb around while we are doing the
        //  flush call.
        //

        InterlockedIncrement( &(*ThisScb)->CloseCount );

        try {

            //
            //  If there is an image section then we better have the file
            //  exclusively.
            //

            if ((*ThisScb)->NonpagedScb->SegmentObject.ImageSectionObject != NULL) {

                if (!MmFlushImageSection( &(*ThisScb)->NonpagedScb->SegmentObject,
                                          MmFlushForWrite )) {

                    DebugTrace( 0, Dbg, ("Couldn't flush image section\n") );

                    Status = DeleteOnClose ? STATUS_CANNOT_DELETE :
                                             STATUS_SHARING_VIOLATION;
                }
            }

        } finally {

            InterlockedDecrement( &(*ThisScb)->CloseCount );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsOpenAttributeCheck:  Exit  ->  %08lx\n", Status) );

    return Status;
}


//
//  Local support routine.
//

VOID
NtfsAddEa (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB ThisFcb,
    IN PFILE_FULL_EA_INFORMATION EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PIO_STATUS_BLOCK Iosb
    )

/*++

Routine Description:

    This routine will add an ea set to the file.  It writes the attributes
    to disk and updates the Fcb info structure with the packed ea size.

Arguments:

    Vcb - This is the volume being opened.

    ThisFcb - This is the Fcb for the file being opened.

    EaBuffer - This is the buffer passed by the user.

    EaLength - This is the stated length of the buffer.

    Iosb - This is the Status Block to use to fill in the offset of an
        offending Ea.

Return Value:

    None - This routine will raise on error.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    EA_LIST_HEADER EaList;
    ULONG Length;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddEa:  Entered\n") );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Initialize the EaList header.
        //

        EaList.PackedEaSize = 0;
        EaList.NeedEaCount = 0;
        EaList.UnpackedEaSize = 0;
        EaList.BufferSize = 0;
        EaList.FullEa = NULL;

        if (ARGUMENT_PRESENT( EaBuffer )) {

            //
            //  Check the user's buffer for validity.
            //

            Status = IoCheckEaBufferValidity( EaBuffer,
                                              EaLength,
                                              &Length );

            if (!NT_SUCCESS( Status )) {

                DebugTrace( -1, Dbg, ("NtfsAddEa:  Invalid ea list\n") );
                Iosb->Information = Length;
                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
            }

            //
            //  ****    Maybe this routine should raise.
            //

            Status = NtfsBuildEaList( IrpContext,
                                      Vcb,
                                      &EaList,
                                      EaBuffer,
                                      &Iosb->Information );

            if (!NT_SUCCESS( Status )) {

                DebugTrace( -1, Dbg, ("NtfsAddEa: Couldn't build Ea list\n") );
                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
            }
        }

        //
        //  Now replace the existing EAs.
        //

        NtfsReplaceFileEas( IrpContext, ThisFcb, &EaList );

    } finally {

        DebugUnwind( NtfsAddEa );

        //
        //  Free the in-memory copy of the Eas.
        //

        if (EaList.FullEa != NULL) {

            NtfsFreePool( EaList.FullEa );
        }

        DebugTrace( -1, Dbg, ("NtfsAddEa:  Exit -> %08lx\n", Status) );
    }

    return;
}


VOID
NtfsInitializeFcbAndStdInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ThisFcb,
    IN BOOLEAN Directory,
    IN BOOLEAN ViewIndex,
    IN BOOLEAN Compressed,
    IN ULONG FileAttributes,
    IN PNTFS_TUNNELED_DATA SetTunneledData OPTIONAL
    )

/*++

Routine Description:

    This routine will initialize an Fcb for a newly created file and create
    the standard information attribute on disk.  We assume that some information
    may already have been placed in the Fcb so we don't zero it out.  We will
    initialize the allocation size to zero, but that may be changed later in
    the create process.

Arguments:

    ThisFcb - This is the Fcb for the file being opened.

    Directory - Indicates if this is a directory file.

    ViewIndex - Indicates if this is a view index.

    Compressed - Indicates if this is a compressed file.

    FileAttributes - These are the attributes the user wants to attach to
        the file.  We will just clear any unsupported bits.

    SetTunneledData - Optionally force the creation time and/or object id
        to a given value

Return Value:

    None - This routine will raise on error.

--*/

{
    STANDARD_INFORMATION StandardInformation;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInitializeFcbAndStdInfo:  Entered\n") );

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Mask out the invalid bits of the file atributes.  Then set the
        //  file name index bit if this is a directory.
        //

        if (!Directory) {

            SetFlag( FileAttributes, FILE_ATTRIBUTE_ARCHIVE );
        }

        ClearFlag( FileAttributes, ~FILE_ATTRIBUTE_VALID_SET_FLAGS | FILE_ATTRIBUTE_NORMAL );

        if (Directory) {

            SetFlag( FileAttributes, DUP_FILE_NAME_INDEX_PRESENT );
        }

        if (ViewIndex) {

            SetFlag( FileAttributes, DUP_VIEW_INDEX_PRESENT );
        }

        if (Compressed) {

            SetFlag( FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
        }

        ThisFcb->Info.FileAttributes = FileAttributes;

        //
        //  Fill in the rest of the Fcb Info structure.
        //

        if (SetTunneledData == NULL) {

            NtfsGetCurrentTime( IrpContext, ThisFcb->Info.CreationTime );

            ThisFcb->Info.LastModificationTime = ThisFcb->Info.CreationTime;
            ThisFcb->Info.LastChangeTime = ThisFcb->Info.CreationTime;
            ThisFcb->Info.LastAccessTime = ThisFcb->Info.CreationTime;

            ThisFcb->CurrentLastAccess = ThisFcb->Info.CreationTime;

        } else {

            NtfsSetTunneledData( IrpContext,
                                 ThisFcb,
                                 SetTunneledData );

            NtfsGetCurrentTime( IrpContext, ThisFcb->Info.LastModificationTime );

            ThisFcb->Info.LastChangeTime = ThisFcb->Info.LastModificationTime;
            ThisFcb->Info.LastAccessTime = ThisFcb->Info.LastModificationTime;

            ThisFcb->CurrentLastAccess = ThisFcb->Info.LastModificationTime;
        }

        //
        //  We assume these sizes are zero.
        //

        ThisFcb->Info.AllocatedLength = 0;
        ThisFcb->Info.FileSize = 0;

        //
        //  Copy the standard information fields from the Fcb and create the
        //  attribute.
        //

        RtlZeroMemory( &StandardInformation, sizeof( STANDARD_INFORMATION ));

        StandardInformation.CreationTime = ThisFcb->Info.CreationTime;
        StandardInformation.LastModificationTime = ThisFcb->Info.LastModificationTime;
        StandardInformation.LastChangeTime = ThisFcb->Info.LastChangeTime;
        StandardInformation.LastAccessTime = ThisFcb->Info.LastAccessTime;
        StandardInformation.FileAttributes = ThisFcb->Info.FileAttributes;

        StandardInformation.ClassId = 0;
        StandardInformation.OwnerId = ThisFcb->OwnerId;
        StandardInformation.SecurityId = ThisFcb->SecurityId;
        StandardInformation.Usn = ThisFcb->Usn;

        SetFlag(ThisFcb->FcbState, FCB_STATE_LARGE_STD_INFO);

        NtfsCreateAttributeWithValue( IrpContext,
                                      ThisFcb,
                                      $STANDARD_INFORMATION,
                                      NULL,
                                      &StandardInformation,
                                      sizeof( STANDARD_INFORMATION ),
                                      0,
                                      NULL,
                                      FALSE,
                                      &AttrContext );

        //
        //  We know that the open call will generate a single link.
        //  (Remember that a separate 8.3 name is not considered a link)
        //

        ThisFcb->LinkCount =
        ThisFcb->TotalLinks = 1;

        //
        //  Now set the header initialized flag in the Fcb.
        //

        SetFlag( ThisFcb->FcbState, FCB_STATE_DUP_INITIALIZED );

    } finally {

        DebugUnwind( NtfsInitializeFcbAndStdInfo );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsInitializeFcbAndStdInfo:  Exit\n") );
    }

    return;
}


//
//  Local support routine.
//

VOID
NtfsCreateAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PFCB ThisFcb,
    IN OUT PSCB ThisScb,
    IN PLCB ThisLcb,
    IN LONGLONG AllocationSize,
    IN BOOLEAN LogIt,
    IN BOOLEAN ForceNonresident,
    IN PUSHORT PreviousFlags OPTIONAL
    )

/*++

Routine Description:

    This routine is called to create an attribute of a given size on the
    disk.  This path will only create non-resident attributes unless the
    allocation size is zero.

    The Scb will contain the attribute name and type code on entry.

Arguments:

    IrpSp - Stack location in the Irp for this request.

    ThisFcb - This is the Fcb for the file to create the attribute in.

    ThisScb - This is the Scb for the attribute to create.

    ThisLcb - This is the Lcb for propagating compression parameters

    AllocationSize - This is the size of the attribute to create.

    LogIt - Indicates whether we should log the creation of the attribute.
        Also indicates if this is a create file operation.

    ForceNonresident - Indicates that we want to create this stream non-resident.
        This is the case if this is a supersede of a previously non-resident
        stream.  Once a stream is non-resident it can't go back to resident.

    PreviousFlags - If specified then this is a supersede operation and
        this is the previous compression flags for the file.

Return Value:

    None - This routine will raise on error.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PATTRIBUTE_RECORD_HEADER ThisAttribute = NULL;

    USHORT AttributeFlags = 0;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCreateAttribute:  Entered\n") );

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        if (FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE )) {

            //
            //  Always force this to be non-resident.
            //

            ForceNonresident = TRUE;

        } else if (!FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_COMPRESSION )) {

            //
            //  If this is the root directory then use the Scb from the Vcb.
            //

            if (ARGUMENT_PRESENT( PreviousFlags)) {

                AttributeFlags = *PreviousFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK;

            } else if (ThisLcb == ThisFcb->Vcb->RootLcb) {

                AttributeFlags = (USHORT)(ThisFcb->Vcb->RootIndexScb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK);

            } else if (ThisLcb != NULL) {

                AttributeFlags = (USHORT)(ThisLcb->Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK);

            } else if (IsCompressed( &ThisFcb->Info )) {

                AttributeFlags = COMPRESSION_FORMAT_LZNT1 - 1;
            }
        }

        //
        //  If this is a supersede we need to check whether to propagate
        //  the sparse bit.
        //

        if ((AllocationSize != 0) && ARGUMENT_PRESENT( PreviousFlags )) {

            SetFlag( AttributeFlags, FlagOn( *PreviousFlags, ATTRIBUTE_FLAG_SPARSE ));
        }

#ifdef BRIANDBG
        if (!ARGUMENT_PRESENT( PreviousFlags ) &&
            !FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE ) &&
            (ThisScb->AttributeTypeCode == $DATA) &&
            (NtfsCreateAllSparse)) {

            SetFlag( AttributeFlags, ATTRIBUTE_FLAG_SPARSE );

            if (!FlagOn( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE )) {

                ASSERTMSG( "conflict with flush",
                           NtfsIsSharedFcb( ThisFcb ) ||
                           (ThisFcb->PagingIoResource != NULL &&
                            NtfsIsSharedFcbPagingIo( ThisFcb )) );

                SetFlag( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE );
                SetFlag( ThisFcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
                SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
            }

            //
            //  Set the FastIo state.
            //

            NtfsAcquireFsrtlHeader( ThisScb );
            ThisScb->Header.IsFastIoPossible = NtfsIsFastIoPossible( ThisScb );
            NtfsReleaseFsrtlHeader( ThisScb );
        }
#endif

        //
        //  If we are creating a sparse or compressed stream then set the size to a
        //  compression unit boundary.
        //

        if (FlagOn( AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

            ULONG CompressionUnit = BytesFromClusters( ThisScb->Vcb, 1 << NTFS_CLUSTERS_PER_COMPRESSION );

            if (ThisScb->Vcb->SparseFileUnit < CompressionUnit) {

                CompressionUnit = ThisScb->Vcb->SparseFileUnit;
            }

            AllocationSize += (CompressionUnit - 1);
            ((PLARGE_INTEGER) &AllocationSize)->LowPart &= ~(CompressionUnit - 1);
        }

        //
        //  We lookup that attribute again and it better not be there.
        //  We need the file record in order to know whether the attribute
        //  is resident or not.
        //

        if (ForceNonresident || (AllocationSize != 0)) {

            DebugTrace( 0, Dbg, ("Create non-resident attribute\n") );

            //
            //  If the file is sparse then set the allocation size to zero
            //  and add a sparse range after this call.
            //

            if (!NtfsAllocateAttribute( IrpContext,
                                        ThisScb,
                                        ThisScb->AttributeTypeCode,
                                        &ThisScb->AttributeName,
                                        AttributeFlags,
                                        FALSE,
                                        LogIt,
                                        (FlagOn( AttributeFlags, ATTRIBUTE_FLAG_SPARSE ) ?
                                         0 :
                                         AllocationSize),
                                        NULL )) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_LARGE_ALLOCATION );
            }

            //
            //  Now add the sparse allocation for a sparse file if the size is
            //  non-zero.
            //

            if (FlagOn( AttributeFlags, ATTRIBUTE_FLAG_SPARSE ) &&
                (AllocationSize != 0)) {

                //
                //  If the sparse flag is set then we better be doing a supersede
                //  with logging enabled.
                //

                ASSERT( LogIt );
                NtfsAddSparseAllocation( IrpContext,
                                         NULL,
                                         ThisScb,
                                         0,
                                         AllocationSize );
            }

            SetFlag( ThisScb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );

        } else {

            //
            //  Update the quota if this is a user stream.
            //

            if (FlagOn( ThisScb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA )) {

                LONGLONG Delta = NtfsResidentStreamQuota( ThisFcb->Vcb );

                NtfsConditionallyUpdateQuota( IrpContext,
                                              ThisFcb,
                                              &Delta,
                                              LogIt,
                                              TRUE );
            }

            NtfsCreateAttributeWithValue( IrpContext,
                                          ThisFcb,
                                          ThisScb->AttributeTypeCode,
                                          &ThisScb->AttributeName,
                                          NULL,
                                          (ULONG) AllocationSize,
                                          AttributeFlags,
                                          NULL,
                                          LogIt,
                                          &AttrContext );

            ThisAttribute = NtfsFoundAttribute( &AttrContext );

        }

        //
        //  Clear the header initialized bit and read the sizes from the
        //  disk.
        //

        ClearFlag( ThisScb->ScbState, SCB_STATE_HEADER_INITIALIZED );
        NtfsUpdateScbFromAttribute( IrpContext,
                                    ThisScb,
                                    ThisAttribute );

    } finally {

        DebugUnwind( NtfsCreateAttribute );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsCreateAttribute:  Exit\n") );
    }

    return;

    UNREFERENCED_PARAMETER( PreviousFlags );
}


//
//  Local support routine
//

VOID
NtfsRemoveDataAttributes (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ThisFcb,
    IN PLCB ThisLcb OPTIONAL,
    IN PFILE_OBJECT FileObject,
    IN ULONG LastFileNameOffset,
    IN ULONG CreateFlags
    )

/*++

Routine Description:

    This routine is called to remove (or mark for delete) all of the named
    data attributes on a file.  This is done during an overwrite
    or supersede operation.

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    ThisFcb - This is the Fcb for the file in question.

    ThisLcb - This is the Lcb used to reach this Fcb (if specified).

    FileObject - This is the file object for the file.

    LastFileNameOffset - This is the offset of the file in the full name.

    CreateFlags - Indicates if this open is being performed by file id.

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PATTRIBUTE_RECORD_HEADER Attribute;
    ATTRIBUTE_TYPE_CODE TypeCode = $DATA;

    UNICODE_STRING AttributeName;
    PSCB ThisScb;

    BOOLEAN MoreToGo;

    ASSERT_EXCLUSIVE_FCB( ThisFcb );

    PAGED_CODE();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        NtfsInitializeAttributeContext( &Context );

        //
        //  Enumerate all of the attributes with the matching type code
        //

        MoreToGo = NtfsLookupAttributeByCode( IrpContext,
                                              ThisFcb,
                                              &ThisFcb->FileReference,
                                              TypeCode,
                                              &Context );

        while (MoreToGo) {

            //
            //  Point to the current attribute.
            //

            Attribute = NtfsFoundAttribute( &Context );

            //
            //  We only look at named data attributes.
            //

            if (Attribute->NameLength != 0) {

                //
                //  Construct the name and find the Scb for the attribute.
                //

                AttributeName.Buffer = (PWSTR) Add2Ptr( Attribute, Attribute->NameOffset );
                AttributeName.MaximumLength = AttributeName.Length = Attribute->NameLength * sizeof( WCHAR );

                ThisScb = NtfsCreateScb( IrpContext,
                                         ThisFcb,
                                         TypeCode,
                                         &AttributeName,
                                         FALSE,
                                         NULL );

                //
                //  If there is an open handle on this file, we simply mark
                //  the Scb as delete pending.
                //

                if (ThisScb->CleanupCount != 0) {

                    SetFlag( ThisScb->ScbState, SCB_STATE_DELETE_ON_CLOSE );

                //
                //  Otherwise we remove the attribute and mark the Scb as
                //  deleted.  The Scb will be cleaned up when the Fcb is
                //  cleaned up.
                //

                } else {

                    NtfsDeleteAttributeRecord( IrpContext,
                                               ThisFcb,
                                               (DELETE_LOG_OPERATION |
                                                DELETE_RELEASE_FILE_RECORD |
                                                DELETE_RELEASE_ALLOCATION),
                                               &Context );

                    SetFlag( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );

                    //
                    //  If this is a named stream, then report this to the dir notify
                    //  package.
                    //

                    if (!FlagOn( CreateFlags, CREATE_FLAG_OPEN_BY_ID ) &&
                        (ThisScb->Vcb->NotifyCount != 0) &&
                        (ThisScb->AttributeName.Length != 0) &&
                        (ThisScb->AttributeTypeCode == TypeCode)) {

                        NtfsReportDirNotify( IrpContext,
                                             ThisFcb->Vcb,
                                             &FileObject->FileName,
                                             LastFileNameOffset,
                                             &ThisScb->AttributeName,
                                             ((ARGUMENT_PRESENT( ThisLcb ) &&
                                               (ThisLcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                              &ThisLcb->Scb->ScbType.Index.NormalizedName :
                                              NULL),
                                             FILE_NOTIFY_CHANGE_STREAM_NAME,
                                             FILE_ACTION_REMOVED_STREAM,
                                             NULL );
                    }

                    //
                    //  Since we have marked this stream as deleted then we need to checkpoint so
                    //  that we can uninitialize the Scb.  Otherwise some stray operation may
                    //  attempt to operate on the Scb.
                    //

                    ThisScb->ValidDataToDisk =
                    ThisScb->Header.AllocationSize.QuadPart =
                    ThisScb->Header.FileSize.QuadPart =
                    ThisScb->Header.ValidDataLength.QuadPart = 0;

                    NtfsCheckpointCurrentTransaction( IrpContext );
                    ThisScb->AttributeTypeCode = $UNUSED;
                }
            }

            //
            //  Get the next attribute.
            //

            MoreToGo = NtfsLookupNextAttributeByCode( IrpContext,
                                                      ThisFcb,
                                                      TypeCode,
                                                      &Context );
        }


    } finally {

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    return;
}


//
//  Local support routine
//

VOID
NtfsRemoveReparsePoint (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ThisFcb
    )

/*++

Routine Description:

    This routine is called to remove the reparse point that exists in a file.

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    ThisFcb - This is the Fcb for the file in question.

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PATTRIBUTE_RECORD_HEADER Attribute;

    PSCB ThisScb = NULL;
    PVCB Vcb = ThisFcb->Vcb;

    MAP_HANDLE MapHandle;

    BOOLEAN ThisScbAcquired = FALSE;
    BOOLEAN CleanupAttributeContext = FALSE;
    BOOLEAN IndexAcquired = FALSE;
    BOOLEAN InitializedMapHandle = FALSE;

    ULONG IncomingFileAttributes = 0;                               //  invalid value
    ULONG IncomingReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;   //  invalid value

    ASSERT_EXCLUSIVE_FCB( ThisFcb );

    PAGED_CODE();

    //
    //  Remember the values of the file attribute flags and of the reparse tag
    //  for abnormal termination recovery.
    //

    IncomingFileAttributes = ThisFcb->Info.FileAttributes;
    IncomingReparsePointTag = ThisFcb->Info.ReparsePointTag;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {
        NtfsInitializeAttributeContext( &Context );
        CleanupAttributeContext = TRUE;

        //
        //  Lookup the reparse point attribute.
        //

        if (NtfsLookupAttributeByCode( IrpContext,
                                       ThisFcb,
                                       &ThisFcb->FileReference,
                                       $REPARSE_POINT,
                                       &Context )) {

            //
            //  Delete the record from the reparse point index.
            //

            {
                NTSTATUS Status = STATUS_SUCCESS;
                INDEX_KEY IndexKey;
                INDEX_ROW IndexRow;
                REPARSE_INDEX_KEY KeyValue;

                //
                //  Acquire the mount table index so that the following two operations on it
                //  are atomic for this call.
                //

                NtfsAcquireExclusiveScb( IrpContext, Vcb->ReparsePointTableScb );
                IndexAcquired = TRUE;

                //
                //  Verify that this file is in the reparse point index and delete it.
                //

                KeyValue.FileReparseTag = ThisFcb->Info.ReparsePointTag;
                KeyValue.FileId = *(PLARGE_INTEGER)&ThisFcb->FileReference;

                IndexKey.Key = (PVOID)&KeyValue;
                IndexKey.KeyLength = sizeof(KeyValue);

                NtOfsInitializeMapHandle( &MapHandle );
                InitializedMapHandle = TRUE;

                //
                //  NtOfsFindRecord will return an error status if the key is not found.
                //

                Status = NtOfsFindRecord( IrpContext,
                                          Vcb->ReparsePointTableScb,
                                          &IndexKey,
                                          &IndexRow,
                                          &MapHandle,
                                          NULL );

                if (!NT_SUCCESS(Status)) {

                    //
                    //  Should not happen. The reparse point should be in the index.
                    //

                    DebugTrace( 0, Dbg, ("Record not found in the reparse point index.\n") );
                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, ThisFcb );
                }

                //
                //  Remove the entry from the reparse point index.
                //

                NtOfsDeleteRecords( IrpContext,
                                    Vcb->ReparsePointTableScb,
                                    1,            // deleting one record from the index
                                    &IndexKey );
            }

            //
            //  Point to the current attribute.
            //

            Attribute = NtfsFoundAttribute( &Context );

            //
            //  If the stream is non-resident, then get a hold of an Scb for it.
            //

            if (!NtfsIsAttributeResident( Attribute )) {

                ThisScb = NtfsCreateScb( IrpContext,
                                         ThisFcb,
                                         $REPARSE_POINT,
                                         &NtfsEmptyString,
                                         FALSE,
                                         NULL );

                NtfsAcquireExclusiveScb( IrpContext, ThisScb );
                ThisScbAcquired = TRUE;
            }

            //
            //  Post the change to the Usn Journal (on errors change is backed out)
            //

            NtfsPostUsnChange( IrpContext, ThisFcb, USN_REASON_REPARSE_POINT_CHANGE );

            NtfsDeleteAttributeRecord( IrpContext,
                                       ThisFcb,
                                       DELETE_LOG_OPERATION |
                                        DELETE_RELEASE_FILE_RECORD |
                                        DELETE_RELEASE_ALLOCATION,
                                       &Context );

            //
            //  Set the change attribute flag.
            //

            ASSERTMSG( "conflict with flush",
                       NtfsIsSharedFcb( ThisFcb ) ||
                       (ThisFcb->PagingIoResource != NULL &&
                        NtfsIsSharedFcbPagingIo( ThisFcb )) );

            SetFlag( ThisFcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );

            //
            //  Clear the reparse point bit in the duplicate file attribute.
            //

            ClearFlag( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT );

            //
            //  Clear the ReparsePointTag field in the duplicate file attribute.
            //

            ThisFcb->Info.ReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;

            //
            //  Put the reparse point deletion and the attribute flag into the
            //  the same transaction.
            //

            NtfsUpdateStandardInformation( IrpContext, ThisFcb );

            //
            //  If we have acquired the Scb then set the sizes back to zero.
            //  Flag that the attribute has been deleted.
            //  Always commit this change since we update the field in the Fcb.
            //

            if (ThisScbAcquired) {

                ThisScb->Header.FileSize =
                ThisScb->Header.ValidDataLength =
                ThisScb->Header.AllocationSize = Li0;
            }

            //
            //  Since we've been called from NtfsOverwriteAttr before
            //  NtfsRemoveDataAttributes gets called, we need to make sure
            //  that if we're holding the Mft, we drop itwhen we checkpoint.
            //  Otherwise we have a potential deadlock when
            //  NtfsRemoveDataAttributes tries to acquire the quota index
            //  while holding the Mft.
            //

            if ((Vcb->MftScb != NULL) &&
                (Vcb->MftScb->Fcb->ExclusiveFcbLinks.Flink != NULL) &&
                NtfsIsExclusiveScb( Vcb->MftScb )) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_MFT );
            }

            //
            //  Checkpoint the Txn to commit the changes.
            //

            NtfsCheckpointCurrentTransaction( IrpContext );
            ClearFlag( ThisFcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

            if (ThisScbAcquired) {

                //
                //  Set the Scb flag to indicate that the attribute is gone.
                //

                ThisScb->AttributeTypeCode = $UNUSED;
                SetFlag( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
            }
        }

    } finally {

        if (ThisScbAcquired) {

            NtfsReleaseScb( IrpContext, ThisScb );
        }

        if (CleanupAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &Context );
        }

        //
        //  Release the reparse point index Scb and the map handle.
        //

        if (IndexAcquired) {

            NtfsReleaseScb( IrpContext, Vcb->ReparsePointTableScb );
        }

        if (InitializedMapHandle) {

            NtOfsReleaseMap( IrpContext, &MapHandle );
        }

        //
        //  Need to roll-back the value of the file attributes and the reparse point
        //  flag in case of problems.
        //

        if (AbnormalTermination()) {

            ThisFcb->Info.FileAttributes = IncomingFileAttributes;
            ThisFcb->Info.ReparsePointTag = IncomingReparsePointTag;
        }
    }

    return;
}

//
//  Local support routine.
//

VOID
NtfsReplaceAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB ThisFcb,
    IN PSCB ThisScb,
    IN PLCB ThisLcb,
    IN LONGLONG AllocationSize
    )

/*++

Routine Description:

    This routine is called to replace an existing attribute with
    an attribute of the given allocation size.  This routine will
    handle the case whether the existing attribute is resident
    or non-resident and the resulting attribute is resident or
    non-resident.

    There are two cases to consider.  The first is the case where the
    attribute is currently non-resident.  In this case we will always
    leave the attribute non-resident regardless of the new allocation
    size.  The argument being that the file will probably be used
    as it was before.  In this case we will add or delete allocation.
    The second case is where the attribute is currently resident.  In
    This case we will remove the old attribute and add a new one.

Arguments:

    IrpSp - This is the Irp stack location for this request.

    ThisFcb - This is the Fcb for the file being opened.

    ThisScb - This is the Scb for the given attribute.

    ThisLcb - This is the Lcb via which this file is created.  It
              is used to propagate compression info.

    AllocationSize - This is the new allocation size.

Return Value:

    None.  This routine will raise.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReplaceAttribute:  Entered\n") );

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Initialize the Scb if needed.
        //

        if (!FlagOn( ThisScb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

            NtfsUpdateScbFromAttribute( IrpContext, ThisScb, NULL );
        }

        NtfsSnapshotScb( IrpContext, ThisScb );

        //
        //  If the attribute is resident, simply remove the old attribute and create
        //  a new one.
        //

        if (FlagOn( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            USHORT AttributeFlags;

            //
            //  Find the attribute on the disk.
            //

            NtfsLookupAttributeForScb( IrpContext,
                                       ThisScb,
                                       NULL,
                                       &AttrContext );

            AttributeFlags = ThisScb->AttributeFlags;

            NtfsDeleteAttributeRecord( IrpContext,
                                       ThisFcb,
                                       DELETE_LOG_OPERATION |
                                        DELETE_RELEASE_FILE_RECORD |
                                        DELETE_RELEASE_ALLOCATION,
                                       &AttrContext );

            //
            //  Set all the attribute sizes to zero.
            //

            ThisScb->ValidDataToDisk =
            ThisScb->Header.AllocationSize.QuadPart =
            ThisScb->Header.ValidDataLength.QuadPart =
            ThisScb->Header.FileSize.QuadPart = 0;
            ThisScb->TotalAllocated = 0;

            //
            //  Create a stream file for the attribute in order to
            //  truncate the cache.  Set the initialized bit in
            //  the Scb so we don't go to disk, but clear it afterwords.
            //

            if ((ThisScb->NonpagedScb->SegmentObject.DataSectionObject != NULL) ||
#ifdef  COMPRESS_ON_WIRE
                (ThisScb->Header.FileObjectC != NULL))
#else
                FALSE
#endif
                ) {

                NtfsCreateInternalAttributeStream( IrpContext,
                                                   ThisScb,
                                                   FALSE,
                                                   &NtfsInternalUseFile[REPLACEATTRIBUTE_FILE_NUMBER] );

                NtfsSetBothCacheSizes( ThisScb->FileObject,
                                       (PCC_FILE_SIZES)&ThisScb->Header.AllocationSize,
                                       ThisScb );
            }

            //
            //  Call our create attribute routine.
            //

            NtfsCreateAttribute( IrpContext,
                                 IrpSp,
                                 ThisFcb,
                                 ThisScb,
                                 ThisLcb,
                                 AllocationSize,
                                 TRUE,
                                 FALSE,
                                 &AttributeFlags );

        //
        //  Otherwise the attribute will stay non-resident, we simply need to
        //  add or remove allocation.
        //

        } else {

            ULONG AllocationUnit;

            //
            //  Create an internal attribute stream for the file.
            //

            if ((ThisScb->NonpagedScb->SegmentObject.DataSectionObject != NULL) ||
#ifdef  COMPRESS_ON_WIRE
                (ThisScb->Header.FileObjectC != NULL)
#else
                FALSE
#endif
                ) {

                NtfsCreateInternalAttributeStream( IrpContext,
                                                   ThisScb,
                                                   FALSE,
                                                   &NtfsInternalUseFile[REPLACEATTRIBUTE2_FILE_NUMBER] );
            }

            //
            //  If the file is sparse or compressed then always round the
            //  new size to a compression unit boundary.  Otherwise round
            //  to a cluster boundary.
            //

            AllocationUnit = ThisScb->Vcb->BytesPerCluster;

            if (FlagOn( ThisScb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                ASSERT( ThisScb->CompressionUnit != 0 );
                AllocationUnit = ThisScb->CompressionUnit;
            }

            AllocationSize += (LONGLONG) (AllocationUnit - 1);
            ((PLARGE_INTEGER) &AllocationSize)->LowPart &= ~(AllocationUnit - 1);

            //
            //  Set the file size and valid data size to zero.
            //

            ThisScb->ValidDataToDisk = 0;
            ThisScb->Header.ValidDataLength = Li0;
            ThisScb->Header.FileSize = Li0;

            DebugTrace( 0, Dbg, ("AllocationSize -> %016I64x\n", AllocationSize) );

            //
            //  Write these changes to the file
            //

            //
            //  If the attribute is currently compressed or sparse then go ahead and discard
            //  all of the allocation.
            //

            if (FlagOn( ThisScb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                NtfsDeleteAllocation( IrpContext,
                                      ThisScb->FileObject,
                                      ThisScb,
                                      0,
                                      MAXLONGLONG,
                                      TRUE,
                                      TRUE );

                //
                //  Checkpoint the current transaction so we have these clusters
                //  available again.
                //

                NtfsCheckpointCurrentTransaction( IrpContext );

                //
                //  If the user doesn't want this stream to be compressed then
                //  remove the entire stream and recreate it non-compressed.  If
                //  the stream is currently sparse and the new file size
                //  is zero then also create the stream non-sparse.
                //

                if (FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE ) ||
                    (FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_COMPRESSION ) &&
                     !FlagOn( ThisScb->ScbState, SCB_STATE_COMPRESSION_CHANGE )) ||
                    (FlagOn( ThisScb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ) &&
                     (AllocationSize == 0))) {

                    //
                    //  We may need to preserve one or the other of the sparse/compressed
                    //  flags.
                    //

                    USHORT PreviousFlags = ThisScb->AttributeFlags;

                    if (FlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE )) {

                        PreviousFlags = 0;

                    } else {

                        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_COMPRESSION )) {

                            ClearFlag( PreviousFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK );
                        }

                        if ((AllocationSize == 0) &&
                            FlagOn( ThisScb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                            ClearFlag( PreviousFlags, ATTRIBUTE_FLAG_SPARSE );
                        }
                    }

                    NtfsLookupAttributeForScb( IrpContext,
                                               ThisScb,
                                               NULL,
                                               &AttrContext );

                    NtfsDeleteAttributeRecord( IrpContext,
                                               ThisFcb,
                                               DELETE_LOG_OPERATION |
                                                DELETE_RELEASE_FILE_RECORD |
                                                DELETE_RELEASE_ALLOCATION,
                                               &AttrContext );

                    //
                    //  Call our create attribute routine.
                    //

                    NtfsCreateAttribute( IrpContext,
                                         IrpSp,
                                         ThisFcb,
                                         ThisScb,
                                         ThisLcb,
                                         AllocationSize,
                                         TRUE,
                                         TRUE,
                                         &PreviousFlags );

                    //
                    //  Since the attribute may have changed state we need to
                    //  checkpoint.
                    //

                    NtfsCheckpointCurrentTransaction( IrpContext );
                }
            }

            //
            //  Now if the file allocation is being increased then we need to only add allocation
            //  to the attribute
            //

            if (ThisScb->Header.AllocationSize.QuadPart < AllocationSize) {

                NtfsAddAllocation( IrpContext,
                                   ThisScb->FileObject,
                                   ThisScb,
                                   LlClustersFromBytes( ThisScb->Vcb, ThisScb->Header.AllocationSize.QuadPart ),
                                   LlClustersFromBytes( ThisScb->Vcb, AllocationSize - ThisScb->Header.AllocationSize.QuadPart ),
                                   FALSE,
                                   NULL );
            //
            //  Otherwise the allocation is being decreased so we need to delete some allocation
            //

            } else if (ThisScb->Header.AllocationSize.QuadPart > AllocationSize) {

                NtfsDeleteAllocation( IrpContext,
                                      ThisScb->FileObject,
                                      ThisScb,
                                      LlClustersFromBytes( ThisScb->Vcb, AllocationSize ),
                                      MAXLONGLONG,
                                      TRUE,
                                      TRUE );
            }

            //
            //  We always unitialize the cache size to zero and write the new
            //  file size to disk.
            //

            NtfsWriteFileSizes( IrpContext,
                                ThisScb,
                                &ThisScb->Header.ValidDataLength.QuadPart,
                                FALSE,
                                TRUE,
                                TRUE );

            NtfsCheckpointCurrentTransaction( IrpContext );

            if (ThisScb->FileObject != NULL) {

                NtfsSetBothCacheSizes( ThisScb->FileObject,
                                       (PCC_FILE_SIZES)&ThisScb->Header.AllocationSize,
                                       ThisScb );
            }

            //
            //  Make sure the reservation bitmap shows no reserved bits.
            //

            if (ThisScb->ScbType.Data.ReservedBitMap != NULL) {

                NtfsDeleteReservedBitmap( ThisScb );
                ThisScb->ScbType.Data.TotalReserved = 0;
            }

            //
            //  Set the FastIo state.
            //

            NtfsAcquireFsrtlHeader( ThisScb );
            ThisScb->Header.IsFastIoPossible = NtfsIsFastIoPossible( ThisScb );
            NtfsReleaseFsrtlHeader( ThisScb );
        }

    } finally {

        DebugUnwind( NtfsReplaceAttribute );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsReplaceAttribute:  Exit\n") );
    }

    return;
}


//
//  Local support routine
//

NTSTATUS
NtfsOpenAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN ULONG LastFileNameOffset,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    IN SHARE_MODIFICATION_TYPE ShareModificationType,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN LOGICAL CreateFile,
    IN ULONG CcbFlags,
    IN PVOID NetworkInfo OPTIONAL,
    IN OUT PSCB *ThisScb,
    OUT PCCB *ThisCcb
    )

/*++

Routine Description:

    This routine does the work of creating the Scb and updating the
    ShareAccess in the Fcb.  It also initializes the Scb if neccessary
    and creates Ccb.  Its final job is to set the file object type of
    open.

Arguments:

    IrpSp - This is the stack location for this volume.  We use it to get the
        file object, granted access and share access for this open.

    Vcb - Vcb for this volume.

    ThisLcb - This is the Lcb to the Fcb for the file being opened.  Not present
          if this is an open by id.

    ThisFcb - This is the Fcb for this file.

    LastFileNameOffset - This is the offset in the full path of the final component.

    AttrName - This is the attribute name to open.

    AttrTypeCode - This is the type code for the attribute being opened.

    ShareModificationType - This indicates how we should modify the
        current share modification on the Fcb.

    TypeOfOpen - This indicates how this attribute is being opened.

    CreateFile - Indicates if we are in the create file path.

    CcbFlags - This is the flag field for the Ccb.

    NetworkInfo - If specified then this open is on behalf of a fast query
        and we don't want to increment the counts or modify the share
        access on the file.

    ThisScb - If this points to a non-NULL value, it is the Scb to use.  Otherwise we
        store the Scb we create here.

    ThisCcb - Address to store address of created Ccb.

Return Value:

    NTSTATUS - Indicating the outcome of opening this attribute.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN RemoveShareAccess = FALSE;
    ACCESS_MASK GrantedAccess;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenAttribute:  Entered\n") );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Remember the granted access.
        //

        GrantedAccess = IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess;

        //
        //  Create the Scb for this attribute if it doesn't exist.
        //

        if (*ThisScb == NULL) {

            DebugTrace( 0, Dbg, ("Looking for Scb\n") );

            *ThisScb = NtfsCreateScb( IrpContext,
                                      ThisFcb,
                                      AttrTypeCode,
                                      &AttrName,
                                      FALSE,
                                      NULL );
        }

        DebugTrace( 0, Dbg, ("ThisScb -> %08lx\n", *ThisScb) );
        DebugTrace( 0, Dbg, ("ThisLcb -> %08lx\n", ThisLcb) );

        //
        //  If this Scb is delete pending, we return an error.
        //

        if (FlagOn( (*ThisScb)->ScbState, SCB_STATE_DELETE_ON_CLOSE )) {

            DebugTrace( 0, Dbg, ("Scb delete is pending\n") );

            Status = STATUS_DELETE_PENDING;
            try_return( NOTHING );
        }

        //
        //  Skip all of the operations below if the user is doing a fast
        //  path open.
        //

        if (!ARGUMENT_PRESENT( NetworkInfo )) {

            //
            //  If this caller wanted a filter oplock and the cleanup count
            //  is non-zero then fail the request.
            //

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_RESERVE_OPFILTER )) {

                if (SafeNodeType( *ThisScb ) != NTFS_NTC_SCB_DATA) {

                    Status = STATUS_INVALID_PARAMETER;
                    try_return( NOTHING );

                //
                //  This must be the only open on the file and the requested
                //  access must be FILE_READ/WRITE_ATTRIBUTES and the
                //  share access must share with everyone.
                //

                } else if (((*ThisScb)->CleanupCount != 0) ||
                           (FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                                    ~(FILE_READ_ATTRIBUTES))) ||
                           ((IrpSp->Parameters.Create.ShareAccess &
                             (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)) !=
                            (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE))) {

                    Status = STATUS_OPLOCK_NOT_GRANTED;
                    try_return( NOTHING );
                }
            }

            //
            //  Update the share access structure.
            //

            //
            //  Case on the requested share modification value.
            //

            switch (ShareModificationType) {

            case UpdateShareAccess :

                DebugTrace( 0, Dbg, ("Updating share access\n") );

                IoUpdateShareAccess( IrpSp->FileObject,
                                     &(*ThisScb)->ShareAccess );
                break;

            case SetShareAccess :

                DebugTrace( 0, Dbg, ("Setting share access\n") );

                //
                //  This case is when this is the first open for the file
                //  and we simply set the share access.
                //

                IoSetShareAccess( GrantedAccess,
                                  IrpSp->Parameters.Create.ShareAccess,
                                  IrpSp->FileObject,
                                  &(*ThisScb)->ShareAccess );
                break;

#if (DBG || defined( NTFS_FREE_ASSERTS ))
            case RecheckShareAccess :

                DebugTrace( 0, Dbg, ("Rechecking share access\n") );

                ASSERT( NT_SUCCESS( IoCheckShareAccess( GrantedAccess,
                                                        IrpSp->Parameters.Create.ShareAccess,
                                                        IrpSp->FileObject,
                                                        &(*ThisScb)->ShareAccess,
                                                        FALSE )));
#endif
            default:

                DebugTrace( 0, Dbg, ("Checking share access\n") );

                //
                //  For this case we need to check the share access and
                //  fail this request if access is denied.
                //

                if (!NT_SUCCESS( Status = IoCheckShareAccess( GrantedAccess,
                                                              IrpSp->Parameters.Create.ShareAccess,
                                                              IrpSp->FileObject,
                                                              &(*ThisScb)->ShareAccess,
                                                              TRUE ))) {

                    try_return( NOTHING );
                }
            }

            RemoveShareAccess = TRUE;

            //
            //  If this happens to be the first time we see write access on this
            //  Scb, then we need to remember it, and check if we have a disk full
            //  condition.
            //

            if (IrpSp->FileObject->WriteAccess &&
                !FlagOn((*ThisScb)->ScbState, SCB_STATE_WRITE_ACCESS_SEEN) &&
                (SafeNodeType( (*ThisScb) ) == NTFS_NTC_SCB_DATA)) {

                if ((*ThisScb)->ScbType.Data.TotalReserved != 0) {

                    NtfsAcquireReservedClusters( Vcb );

                    //
                    //  Does this Scb have reserved space that causes us to exceed the free
                    //  space on the volume?
                    //

                    if (((LlClustersFromBytes(Vcb, (*ThisScb)->ScbType.Data.TotalReserved) + Vcb->TotalReserved) >
                         Vcb->FreeClusters)) {

                        NtfsReleaseReservedClusters( Vcb );

                        try_return( Status = STATUS_DISK_FULL );
                    }

                    //
                    //  Otherwise tally in the reserved space now for this Scb, and
                    //  remember that we have seen write access.
                    //

                    Vcb->TotalReserved += LlClustersFromBytes(Vcb, (*ThisScb)->ScbType.Data.TotalReserved);
                    NtfsReleaseReservedClusters( Vcb );
                }

                SetFlag( (*ThisScb)->ScbState, SCB_STATE_WRITE_ACCESS_SEEN );
            }

            //
            //  Create the Ccb and put the remaining name in it.
            //

            *ThisCcb = NtfsCreateCcb( IrpContext,
                                      ThisFcb,
                                      *ThisScb,
                                      (BOOLEAN)(AttrTypeCode == $INDEX_ALLOCATION),
                                      ThisFcb->EaModificationCount,
                                      CcbFlags,
                                      IrpSp->FileObject,
                                      LastFileNameOffset );

            if (FlagOn( ThisFcb->Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_ENABLED ) &&
                FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_FOR_FREE_SPACE_QUERY )) {

                //
                //  Get the owner id of the calling thread.  This must be done at
                //  create time since that is the only time the owner is valid.
                //

                (*ThisCcb)->OwnerId = NtfsGetCallersUserId( IrpContext );
            }

            //
            //  Link the Ccb into the Lcb.
            //

            if (ARGUMENT_PRESENT( ThisLcb )) {

                NtfsLinkCcbToLcb( IrpContext, *ThisCcb, ThisLcb );
            }

            //
            //  Update the Fcb delete counts if necessary.
            //

            if (RemoveShareAccess) {

                //
                //  Update the count in the Fcb and store a flag in the Ccb
                //  if the user is not sharing the file for deletes.  We only
                //  set these values if the user is accessing the file
                //  for read/write/delete access.  The I/O system ignores
                //  the sharing mode unless the file is opened with one
                //  of these accesses.
                //

                if (FlagOn( GrantedAccess, NtfsAccessDataFlags )
                    && !FlagOn( IrpSp->Parameters.Create.ShareAccess,
                                FILE_SHARE_DELETE )) {

                    ThisFcb->FcbDenyDelete += 1;
                    SetFlag( (*ThisCcb)->Flags, CCB_FLAG_DENY_DELETE );
                }

                //
                //  Do the same for the file delete count for any user
                //  who opened the file as a file and requested delete access.
                //

                if (FlagOn( (*ThisCcb)->Flags, CCB_FLAG_OPEN_AS_FILE )
                    && FlagOn( GrantedAccess,
                               DELETE )) {

                    ThisFcb->FcbDeleteFile += 1;
                    SetFlag( (*ThisCcb)->Flags, CCB_FLAG_DELETE_FILE | CCB_FLAG_DELETE_ACCESS );
                }
            }

            //
            //  Let our cleanup routine undo the share access change now.
            //

            RemoveShareAccess = FALSE;

            //
            //  Increment the cleanup and close counts
            //

            NtfsIncrementCleanupCounts( *ThisScb,
                                        ThisLcb,
                                        BooleanFlagOn( IrpSp->FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ));

            NtfsIncrementCloseCounts( *ThisScb,
                                      BooleanFlagOn( ThisFcb->FcbState, FCB_STATE_PAGING_FILE ),
                                      (BOOLEAN) IsFileObjectReadOnly( IrpSp->FileObject ));

            //
            //  If this is a user view index open, we want to set TypeOfOpen in
            //  time to get it copied into the Ccb.
            //

            if (FlagOn( (*ThisScb)->ScbState, SCB_STATE_VIEW_INDEX )) {

                TypeOfOpen = UserViewIndexOpen;
            }

            if (TypeOfOpen != UserDirectoryOpen) {

                DebugTrace( 0, Dbg, ("Updating Vcb and File object for user open\n") );

                //
                //  Set the section object pointer if this is a data Scb
                //

                IrpSp->FileObject->SectionObjectPointer = &(*ThisScb)->NonpagedScb->SegmentObject;

            } else {

                //
                //  Set the Scb encrypted bit from the Fcb.
                //

                if (FlagOn( ThisFcb->FcbState, FCB_STATE_DIRECTORY_ENCRYPTED )) {

                    SetFlag( (*ThisScb)->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED );
                }
            }

            //
            //  Set the file object type.
            //

            NtfsSetFileObject( IrpSp->FileObject,
                               TypeOfOpen,
                               *ThisScb,
                               *ThisCcb );

            //
            //  If this is a non-cached open and  there are only non-cached opens
            //  then go ahead and try to delete the section. We may go through here
            //  twice due to a logfile full and on the 2nd time no longer have a section
            //  The filesize then is updated in the close path
            //  We will never flush and purge system files like the mft in this path
            //

            if (FlagOn( IrpSp->FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) &&
                !CreateFile &&
                ((*ThisScb)->AttributeTypeCode == $DATA) &&
                ((*ThisScb)->CleanupCount == (*ThisScb)->NonCachedCleanupCount) &&
                ((*ThisScb)->NonpagedScb->SegmentObject.ImageSectionObject == NULL) &&
                ((*ThisScb)->CompressionUnit == 0) &&
                MmCanFileBeTruncated( &(*ThisScb)->NonpagedScb->SegmentObject, NULL ) &&
                FlagOn( (*ThisScb)->ScbState, SCB_STATE_HEADER_INITIALIZED ) &&
                !FlagOn( (*ThisScb)->Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

                //
                //  Only do this in the Fsp so we have enough stack space for the flush.
                //  Also only call if we really have a datasection
                //

                if (((*ThisScb)->NonpagedScb->SegmentObject.DataSectionObject != NULL) &&
                    !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP )) {

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );

                    //
                    //  If we are posting then we may want to use the next stack location.
                    //

                    if (IrpContext->Union.OplockCleanup->CompletionContext != NULL) {

                        NtfsPrepareForIrpCompletion( IrpContext,
                                                     IrpContext->OriginatingIrp,
                                                     IrpContext->Union.OplockCleanup->CompletionContext );
                    }

                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }


                //
                //  Flush and purge the stream.
                //

                NtfsFlushAndPurgeScb( IrpContext,
                                      *ThisScb,
                                      (ARGUMENT_PRESENT( ThisLcb ) ?
                                       ThisLcb->Scb :
                                       NULL) );
            }

            //
            //  Check if we should request a filter oplock.
            //

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_RESERVE_OPFILTER )) {

                FsRtlOplockFsctrl( &(*ThisScb)->ScbType.Data.Oplock,
                                   IrpContext->OriginatingIrp,
                                   1 );
            }
        }

        //
        //  Mark the Scb if this is a temporary file.
        //

        if (FlagOn( ThisFcb->Info.FileAttributes, FILE_ATTRIBUTE_TEMPORARY )) {

            SetFlag( (*ThisScb)->ScbState, SCB_STATE_TEMPORARY );
            SetFlag( IrpSp->FileObject->Flags, FO_TEMPORARY_FILE );
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsOpenAttribute );

        //
        //  Back out local actions on error.
        //

        if (AbnormalTermination()
            && RemoveShareAccess) {

            IoRemoveShareAccess( IrpSp->FileObject, &(*ThisScb)->ShareAccess );
        }

        DebugTrace( -1, Dbg, ("NtfsOpenAttribute:  Status -> %08lx\n", Status) );
    }

    return Status;
}


//
//  Local support routine.
//

VOID
NtfsBackoutFailedOpensPriv (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PFCB ThisFcb,
    IN PSCB ThisScb,
    IN PCCB ThisCcb
    )

/*++

Routine Description:

    This routine is called during an open that has failed after
    modifying in-memory structures.  We will repair the following
    structures.

        Vcb - Decrement the open counts.  Check if we locked the volume.

        ThisFcb - Restore he Share Access fields and decrement open counts.

        ThisScb - Decrement the open counts.

        ThisCcb - Remove from the Lcb and delete.

Arguments:

    FileObject - This is the file object for this open.

    ThisFcb - This is the Fcb for the file being opened.

    ThisScb - This is the Scb for the given attribute.

    ThisCcb - This is the Ccb for this open.

Return Value:

    None.

--*/

{
    PLCB Lcb;
    PVCB Vcb = ThisFcb->Vcb;
    PSCB CurrentParentScb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsBackoutFailedOpens:  Entered\n") );

    //
    //  If there is an Scb and Ccb, we remove the share access from the
    //  Fcb.  We also remove all of the open and unclean counts incremented
    //  by us.
    //

    //
    //  Remove this Ccb from the Lcb.
    //

    Lcb = ThisCcb->Lcb;
    NtfsUnlinkCcbFromLcb( IrpContext, ThisCcb );

    //
    //  Check if we need to remove the share access for this open.
    //

    IoRemoveShareAccess( FileObject, &ThisScb->ShareAccess );

    //
    //  Modify the delete counts in the Fcb.
    //

    if (FlagOn( ThisCcb->Flags, CCB_FLAG_DELETE_FILE )) {

        ThisFcb->FcbDeleteFile -= 1;
        ClearFlag( ThisCcb->Flags, CCB_FLAG_DELETE_FILE );
    }

    if (FlagOn( ThisCcb->Flags, CCB_FLAG_DENY_DELETE )) {

        ThisFcb->FcbDenyDelete -= 1;
        ClearFlag( ThisCcb->Flags, CCB_FLAG_DENY_DELETE );
    }

    //
    //  Decrement the cleanup and close counts
    //

    NtfsDecrementCleanupCounts( ThisScb,
                                Lcb,
                                BooleanFlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ));

    //
    //  Trim any normalized names created in this open if no cleanup counts left
    //

    if (0 == ThisScb->CleanupCount ) {

        switch (ThisCcb->TypeOfOpen) {

        case UserDirectoryOpen :

            //
            //  Cleanup the current scb node if it has a name
            //

            if (ThisScb->ScbType.Index.NormalizedName.MaximumLength > LONGNAME_THRESHOLD) {

                NtfsDeleteNormalizedName( ThisScb );
            }

            //
            //  Fallthrough to deal with parents - in some case the current node failed to get a name
            //  but we populated a tree of long names on the way down
            //

        case UserFileOpen :

            if (Lcb != NULL) {
                CurrentParentScb = Lcb->Scb;
            } else {
                CurrentParentScb = NULL;
            }

            //
            //  Try to trim normalized names if the name is suff. long and we don't own the mft
            //  which would cause a deadlock
            //

            if ((CurrentParentScb != NULL) &&
                (CurrentParentScb->ScbType.Index.NormalizedName.MaximumLength > LONGNAME_THRESHOLD) &&
                !NtfsIsSharedScb( Vcb->MftScb )) {

                NtfsTrimNormalizedNames( IrpContext, ThisFcb, CurrentParentScb);
            }
            break;

        }  //  endif switch
    }

    NtfsDecrementCloseCounts( IrpContext,
                              ThisScb,
                              Lcb,
                              (BOOLEAN) BooleanFlagOn(ThisFcb->FcbState, FCB_STATE_PAGING_FILE),
                              (BOOLEAN) IsFileObjectReadOnly( FileObject ),
                              TRUE );

    //
    //  Now clean up the Ccb.
    //

    NtfsDeleteCcb( ThisFcb, &ThisCcb );

    DebugTrace( -1, Dbg, ("NtfsBackoutFailedOpens:  Exit\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsUpdateScbFromMemory (
    IN OUT PSCB Scb,
    IN POLD_SCB_SNAPSHOT ScbSizes
    )

/*++

Routine Description:

    All of the information from the attribute is stored in the snapshot.  We process
    this data identically to NtfsUpdateScbFromAttribute.

Arguments:

    Scb - This is the Scb to update.

    ScbSizes - This contains the sizes to store in the scb.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateScbFromMemory:  Entered\n") );

    //
    //  Check whether this is resident or nonresident
    //

    if (ScbSizes->Resident) {

        Scb->Header.AllocationSize.QuadPart = ScbSizes->FileSize;

        if (!FlagOn(Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED)) {

            Scb->Header.ValidDataLength =
            Scb->Header.FileSize = Scb->Header.AllocationSize;
        }

#ifdef SYSCACHE_DEBUG
        if (ScbIsBeingLogged( Scb )) {
            FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_UPDATE_FROM_DISK, Scb->Header.ValidDataLength.QuadPart, 0, 0 );
        }
#endif

        Scb->Header.AllocationSize.LowPart =
          QuadAlign( Scb->Header.AllocationSize.LowPart );

        Scb->TotalAllocated = Scb->Header.AllocationSize.QuadPart;

        NtfsVerifySizes( &Scb->Header );

        //
        //  Set the resident flag in the Scb.
        //

        SetFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT );

    } else {

        VCN FileClusters;
        VCN AllocationClusters;

        if (!FlagOn(Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED)) {

            Scb->Header.ValidDataLength.QuadPart = ScbSizes->ValidDataLength;
            Scb->Header.FileSize.QuadPart = ScbSizes->FileSize;

            if (FlagOn( ScbSizes->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {
                Scb->ValidDataToDisk = ScbSizes->ValidDataLength;
            }
        }

        Scb->TotalAllocated = ScbSizes->TotalAllocated;
        Scb->Header.AllocationSize.QuadPart = ScbSizes->AllocationSize;


#ifdef SYSCACHE_DEBUG
        if (ScbIsBeingLogged( Scb )) {
            FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_UPDATE_FROM_DISK, Scb->Header.ValidDataLength.QuadPart, 1, 0 );
        }
#endif

        ClearFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT );

        //
        //  Get the size of the compression unit.
        //

        ASSERT( (ScbSizes->CompressionUnit == 0) ||
                (ScbSizes->CompressionUnit == NTFS_CLUSTERS_PER_COMPRESSION) ||
                FlagOn( ScbSizes->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ));

        if ((ScbSizes->CompressionUnit != 0) &&
            (ScbSizes->CompressionUnit < 31)) {
            Scb->CompressionUnit = BytesFromClusters( Scb->Vcb,
                                                      1 << ScbSizes->CompressionUnit );
            Scb->CompressionUnitShift = ScbSizes->CompressionUnit;
        }

        ASSERT( (Scb->CompressionUnit == 0) ||
                (Scb->AttributeTypeCode == $INDEX_ALLOCATION) ||
                NtfsIsTypeCodeCompressible( Scb->AttributeTypeCode ));

        //
        //  Compute the clusters for the file and its allocation.
        //

        AllocationClusters = LlClustersFromBytes( Scb->Vcb, Scb->Header.AllocationSize.QuadPart );

        if (Scb->CompressionUnit == 0) {

            FileClusters = LlClustersFromBytes(Scb->Vcb, Scb->Header.FileSize.QuadPart);

        } else {

            FileClusters = Scb->Header.FileSize.QuadPart + Scb->CompressionUnit - 1;
            FileClusters &= ~((ULONG_PTR)Scb->CompressionUnit - 1);
        }

        //
        //  If allocated clusters are greater than file clusters, mark
        //  the Scb to truncate on close.
        //

        if (AllocationClusters > FileClusters) {

            SetFlag( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );
        }
    }

    Scb->AttributeFlags = ScbSizes->AttributeFlags;

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

        //
        //  If sparse CC should flush and purge when the file is mapped to
        //  keep reservations accurate
        //

        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {
            SetFlag( Scb->Header.Flags2, FSRTL_FLAG2_PURGE_WHEN_MAPPED );
        }

        if (NtfsIsTypeCodeCompressible( Scb->AttributeTypeCode )) {

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                SetFlag( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );
            }

            //
            //  If the attribute is resident, then we will use our current
            //  default.
            //

            if (Scb->CompressionUnit == 0) {

                Scb->CompressionUnit = BytesFromClusters( Scb->Vcb, 1 << NTFS_CLUSTERS_PER_COMPRESSION );
                Scb->CompressionUnitShift = NTFS_CLUSTERS_PER_COMPRESSION;

                //
                //  Trim the compression unit for large sparse clusters.
                //

                while (Scb->CompressionUnit > Scb->Vcb->SparseFileUnit) {

                    Scb->CompressionUnit >>= 1;
                    Scb->CompressionUnitShift -= 1;
                }
            }
        }
    }

    //
    //  If the compression unit is non-zero or this is a resident file
    //  then set the flag in the common header for the Modified page writer.
    //

    NtfsAcquireFsrtlHeader( Scb );
    Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
    NtfsReleaseFsrtlHeader( Scb );

    SetFlag( Scb->ScbState,
             SCB_STATE_UNNAMED_DATA | SCB_STATE_FILE_SIZE_LOADED | SCB_STATE_HEADER_INITIALIZED );

    DebugTrace( -1, Dbg, ("NtfsUpdateScbFromMemory:  Exit\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsOplockPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs any neccessary work before STATUS_PENDING is
    returned with the Fsd thread.  This routine is called within the
    filesystem and by the oplock package.  This routine will update
    the originating Irp in the IrpContext and release all of the Fcbs and
    paging io resources in the IrpContext.

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PIRP_CONTEXT IrpContext;
    POPLOCK_CLEANUP OplockCleanup;

    PAGED_CODE();

    IrpContext = (PIRP_CONTEXT) Context;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_FROM_POOL ));

    IrpContext->OriginatingIrp = Irp;
    OplockCleanup = IrpContext->Union.OplockCleanup;

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Adjust the filename strings as needed.
    //

    if ((OplockCleanup->ExactCaseName.Buffer != OplockCleanup->OriginalFileName.Buffer) &&
        (OplockCleanup->ExactCaseName.Buffer != NULL)) {

        ASSERT( OplockCleanup->ExactCaseName.Length != 0 );
        ASSERT( OplockCleanup->OriginalFileName.MaximumLength >= OplockCleanup->ExactCaseName.MaximumLength );

        RtlCopyMemory( OplockCleanup->OriginalFileName.Buffer,
                       OplockCleanup->ExactCaseName.Buffer,
                       OplockCleanup->ExactCaseName.MaximumLength );
    }

    //
    //  Restitute the access control state to what it was when we entered the request.
    //

    IrpSp->Parameters.Create.SecurityContext->AccessState->RemainingDesiredAccess = OplockCleanup->RemainingDesiredAccess;
    IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess = OplockCleanup->PreviouslyGrantedAccess;
    IrpSp->Parameters.Create.SecurityContext->DesiredAccess = OplockCleanup->DesiredAccess;

    //
    //  Free any buffer we allocated.
    //

    if ((OplockCleanup->FullFileName.Buffer != NULL) &&
        (OplockCleanup->OriginalFileName.Buffer != OplockCleanup->FullFileName.Buffer)) {

        NtfsFreePool( OplockCleanup->FullFileName.Buffer );
        OplockCleanup->FullFileName.Buffer = NULL;
    }

    //
    //  Set the file name in the file object back to it's original value.
    //

    OplockCleanup->FileObject->FileName = OplockCleanup->OriginalFileName;

    //
    //  Cleanup the IrpContext.
    //  Restore the thread context pointer if associated with this IrpContext.
    //

    if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL )) {

        NtfsRestoreTopLevelIrp();
        ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL );
    }

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE );
    NtfsCleanupIrpContext( IrpContext, FALSE );

    //
    //  Set the event for synchronous IO and set the IrpCompletion routine.
    //

    if (OplockCleanup->CompletionContext != NULL) {

        NtfsPrepareForIrpCompletion( IrpContext,
                                     IrpContext->OriginatingIrp,
                                     IrpContext->Union.OplockCleanup->CompletionContext );
    }

    //
    //  Make sure to clear this field since the OplockCleanup structure is on the stack and
    //  we don't want anyone else to access this.
    //

    IrpContext->Union.OplockCleanup = NULL;

    //
    //  Mark that we've already returned pending to the user
    //

    IoMarkIrpPending( Irp );

    return;
}


//
//  Local support routine.
//

NTSTATUS
NtfsCreateCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for synchronous creates.  It is only called if
    STATUS_PENDING was returned.  We return MORE_PROCESSING_REQUIRED to take
    control of the Irp again and also clear the top level thread storage.  We have to
    do this because we could be calling this routine in an Fsp thread and are
    waiting for the event in an Fsd thread.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
        be accessible after this routine returns.)

    Contxt - This is the event to signal.

Return Value:

    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can take
    control of the Irp in the original thread.

--*/

{
    PAGED_CODE();

    ASSERT_IRP_CONTEXT( ((PNTFS_COMPLETION_CONTEXT) Contxt)->IrpContext );

    //
    //  Restore the thread context pointer if associated with this IrpContext.
    //  It is important for the create irp because we we might be completing
    //  the irp but take control of it again in a separate thread.
    //

    if (FlagOn( ((PNTFS_COMPLETION_CONTEXT) Contxt)->IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL )) {

        NtfsRestoreTopLevelIrp();
        ClearFlag( ((PNTFS_COMPLETION_CONTEXT) Contxt)->IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL );
    }

    KeSetEvent( &((PNTFS_COMPLETION_CONTEXT) Contxt)->Event, 0, FALSE );
    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
}


//
//  Local support routine.
//

NTSTATUS
NtfsCheckExistingFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PLCB ThisLcb OPTIONAL,
    IN PFCB ThisFcb,
    IN ULONG CcbFlags
    )

/*++

Routine Description:

    This routine is called to check the desired access on an existing file
    against the ACL's and the read-only status of the file.  If we fail on
    the access check, that routine will raise.  Otherwise we will return a
    status to indicate success or the failure cause.  This routine will access
    and update the PreviouslyGrantedAccess field in the security context.

Arguments:

    IrpSp - This is the Irp stack location for this open.

    ThisLcb - This is the Lcb used to reach the Fcb to open.

    ThisFcb - This is the Fcb where the open will occur.

    CcbFlags - This is the flag field for the Ccb.

Return Value:

    None.

--*/

{
    BOOLEAN MaximumAllowed = FALSE;

    PACCESS_STATE AccessState;

    PAGED_CODE();

    //
    //  Save a pointer to the access state for convenience.
    //

    AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

    //
    //  Start by checking that there are no bits in the desired access that
    //  conflict with the read-only state of the file.
    //

    if (IsReadOnly( &ThisFcb->Info )) {

        if (FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                    FILE_WRITE_DATA
                    | FILE_APPEND_DATA
                    | FILE_ADD_SUBDIRECTORY
                    | FILE_DELETE_CHILD )) {

            return STATUS_ACCESS_DENIED;
        }
    }

    //
    //  If the volume itself is mounted readonly, we still let open-for-writes
    //  go through for legacy reasons. DELETE_ON_CLOSE is an exception.
    //

    if ((IsReadOnly( &ThisFcb->Info )) ||
        (NtfsIsVolumeReadOnly( ThisFcb->Vcb ))) {

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DELETE_ON_CLOSE )) {

            return STATUS_CANNOT_DELETE;
        }
    }

    //
    //  Otherwise we need to check the requested access vs. the allowable
    //  access in the ACL on the file.  We will want to remember if
    //  MAXIMUM_ALLOWED was requested and remove the invalid bits for
    //  a read-only file.
    //

    //
    //  Remember if maximum allowed was requested.
    //

    if (FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                MAXIMUM_ALLOWED )) {

        MaximumAllowed = TRUE;
    }

    NtfsOpenCheck( IrpContext,
                   ThisFcb,
                   (((ThisLcb != NULL) && (ThisLcb != ThisFcb->Vcb->RootLcb))
                    ? ThisLcb->Scb->Fcb
                    : NULL),
                   IrpContext->OriginatingIrp );

    //
    //  If this is a read-only file and we requested maximum allowed then
    //  remove the invalid bits. Ditto for readonly volumes.
    //

    if (MaximumAllowed &&
        (IsReadOnly( &ThisFcb->Info ) ||
         NtfsIsVolumeReadOnly( ThisFcb->Vcb ))) {

        ClearFlag( AccessState->PreviouslyGrantedAccess,
                   FILE_WRITE_DATA
                   | FILE_APPEND_DATA
                   | FILE_ADD_SUBDIRECTORY
                   | FILE_DELETE_CHILD );
    }

    //
    //  We do a check here to see if we conflict with the delete status on the
    //  file.  Right now we check if there is already an opener who has delete
    //  access on the file and this opener doesn't allow delete access.
    //  We can skip this test if the opener is not requesting read, write or
    //  delete access.
    //

    if (ThisFcb->FcbDeleteFile != 0
        && FlagOn( AccessState->PreviouslyGrantedAccess, NtfsAccessDataFlags )
        && !FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_DELETE )) {

        DebugTrace( -1, Dbg, ("NtfsCheckExistingFile:  Exit\n") );
        return STATUS_SHARING_VIOLATION;
    }

    //
    //  We do a check here to see if we conflict with the delete status on the
    //  file.  If we are opening the file and requesting delete, then there can
    //  be no current handles which deny delete.
    //

    if (ThisFcb->FcbDenyDelete != 0
        && FlagOn( AccessState->PreviouslyGrantedAccess, DELETE )
        && FlagOn( CcbFlags, CCB_FLAG_OPEN_AS_FILE )) {

        return STATUS_SHARING_VIOLATION;
    }

    return STATUS_SUCCESS;
}


//
//  Local support routine.
//

NTSTATUS
NtfsBreakBatchOplock (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB ThisFcb,
    IN UNICODE_STRING AttrName,
    IN ATTRIBUTE_TYPE_CODE AttrTypeCode,
    OUT PSCB *ThisScb
    )

/*++

Routine Description:

    This routine is called for each open of an existing attribute to
    check for current batch oplocks on the file.  We will also check
    whether we will want to flush and purge this stream in the case
    where only non-cached handles remain on the file.  We only want
    to do that in an Fsp thread because we will require every bit
    of stack we can get.

Arguments:

    Irp - This is the Irp for this open operation.

    IrpSp - This is the stack location for this open.

    ThisFcb - This is the Fcb for the file being opened.

    AttrName - This is the attribute name in case we need to create
        an Scb.

    AttrTypeCode - This is the attribute type code to use to create
        the Scb.

    ThisScb - Address to store the Scb if found or created.

Return Value:

    NTSTATUS - Will be either STATUS_SUCCESS or STATUS_PENDING.

--*/

{
    BOOLEAN ScbExisted;
    PSCB NextScb;
    PLIST_ENTRY Links;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsBreakBatchOplock:  Entered\n") );

    //
    //  In general we will just break the batch oplock for the stream we
    //  are trying to open.  However if we are trying to delete the file
    //  and someone has a batch oplock on a different stream which
    //  will cause our open to fail then we need to try to break those
    //  batch oplocks.  Likewise if we are opening a stream and won't share
    //  with a file delete then we need to break any batch oplocks on the main
    //  stream of the file.
    //

    //
    //  Consider the case where we are opening a stream and there is a
    //  batch oplock on the main data stream.
    //

    if (AttrName.Length != 0) {

        if (ThisFcb->FcbDeleteFile != 0 &&
            !FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_DELETE )) {

            Links = ThisFcb->ScbQueue.Flink;

            while (Links != &ThisFcb->ScbQueue) {

                NextScb = CONTAINING_RECORD( Links, SCB, FcbLinks );

                if (NextScb->AttributeTypeCode == $DATA &&
                    NextScb->AttributeName.Length == 0) {

                    if (FsRtlCurrentBatchOplock( &NextScb->ScbType.Data.Oplock )) {

                        //
                        //  We remember if a batch oplock break is underway for the
                        //  case where the sharing check fails.
                        //

                        Irp->IoStatus.Information = FILE_OPBATCH_BREAK_UNDERWAY;

                        //
                        //  We wait on the oplock.
                        //

                        if (FsRtlCheckOplock( &NextScb->ScbType.Data.Oplock,
                                              Irp,
                                              (PVOID) IrpContext,
                                              NtfsOplockComplete,
                                              NtfsOplockPrePostIrp ) == STATUS_PENDING) {

                            return STATUS_PENDING;
                        }
                    }

                    break;
                }

                Links = Links->Flink;
            }
        }

    //
    //  Now consider the case where we are opening the main stream and want to
    //  delete the file but an opener on a stream is preventing us.
    //

    } else if (ThisFcb->FcbDenyDelete != 0 &&
               FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->RemainingDesiredAccess,
                       MAXIMUM_ALLOWED | DELETE )) {

        //
        //  Find all of the other data Scb and check their oplock status.
        //

        Links = ThisFcb->ScbQueue.Flink;

        while (Links != &ThisFcb->ScbQueue) {

            NextScb = CONTAINING_RECORD( Links, SCB, FcbLinks );

            if (NextScb->AttributeTypeCode == $DATA &&
                NextScb->AttributeName.Length != 0) {

                if (FsRtlCurrentBatchOplock( &NextScb->ScbType.Data.Oplock )) {

                    //
                    //  We remember if a batch oplock break is underway for the
                    //  case where the sharing check fails.
                    //

                    Irp->IoStatus.Information = FILE_OPBATCH_BREAK_UNDERWAY;

                    //
                    //  We wait on the oplock.
                    //

                    if (FsRtlCheckOplock( &NextScb->ScbType.Data.Oplock,
                                          Irp,
                                          (PVOID) IrpContext,
                                          NtfsOplockComplete,
                                          NtfsOplockPrePostIrp ) == STATUS_PENDING) {

                        return STATUS_PENDING;
                    }

                    Irp->IoStatus.Information = 0;
                }
            }

            Links = Links->Flink;
        }
    }

    //
    //  We try to find the Scb for this file.
    //

    *ThisScb = NtfsCreateScb( IrpContext,
                              ThisFcb,
                              AttrTypeCode,
                              &AttrName,
                              FALSE,
                              &ScbExisted );

    //
    //  If there was a previous Scb, we examine the oplocks.
    //

    if (ScbExisted &&
        (SafeNodeType( *ThisScb ) == NTFS_NTC_SCB_DATA)) {

        //
        //  If we have to flush and purge then we want to be in the Fsp.
        //

        if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ) &&
            FlagOn( IrpSp->FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) &&
            ((*ThisScb)->CleanupCount == (*ThisScb)->NonCachedCleanupCount) &&
            ((*ThisScb)->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );

            //
            //  If we are posting then we may want to use the next stack location.
            //

            if (IrpContext->Union.OplockCleanup->CompletionContext != NULL) {

                NtfsPrepareForIrpCompletion( IrpContext,
                                             IrpContext->OriginatingIrp,
                                             IrpContext->Union.OplockCleanup->CompletionContext );
            }

            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
        }

        if (FsRtlCurrentBatchOplock( &(*ThisScb)->ScbType.Data.Oplock )) {

            //
            //  If the handle count is greater than 1 then fail this
            //  open now.
            //

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_RESERVE_OPFILTER ) &&
                ((*ThisScb)->CleanupCount > 1)) {

                NtfsRaiseStatus( IrpContext, STATUS_OPLOCK_NOT_GRANTED, NULL, NULL );
            }

            DebugTrace( 0, Dbg, ("Breaking batch oplock\n") );

            //
            //  We remember if a batch oplock break is underway for the
            //  case where the sharing check fails.
            //

            Irp->IoStatus.Information = FILE_OPBATCH_BREAK_UNDERWAY;

            if (FsRtlCheckOplock( &(*ThisScb)->ScbType.Data.Oplock,
                                  Irp,
                                  (PVOID) IrpContext,
                                  NtfsOplockComplete,
                                  NtfsOplockPrePostIrp ) == STATUS_PENDING) {

                return STATUS_PENDING;
            }

            Irp->IoStatus.Information = 0;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsBreakBatchOplock:  Exit  -  %08lx\n", STATUS_SUCCESS) );

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
NtfsCompleteLargeAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PLCB Lcb OPTIONAL,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN ULONG CreateFlags
    )

/*++

Routine Description:

    This routine is called when we need to add more allocation to a stream
    being opened.  This stream could have been reallocated or created with
    this call but we didn't allocate all of the space in the main path.

Arguments:

    Irp - This is the Irp for this open operation.

    Lcb - This is the Lcb used to reach the stream being opened.  Won't be
        specified in the open by ID case.

    Scb - This is the Scb for the stream being opened.

    Ccb - This is the Ccb for the this user handle.

    CreateFlags - Indicates if this handle requires delete on close and
        if we created or reallocated this stream.

Return Value:

    NTSTATUS - the result of this operation.

--*/

{
    NTSTATUS Status;
    FILE_ALLOCATION_INFORMATION AllInfo;

    PAGED_CODE();

    //
    //  Commit the current transaction and free all resources.
    //

    NtfsCheckpointCurrentTransaction( IrpContext );
    NtfsReleaseAllResources( IrpContext );

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CALL_SELF );
    AllInfo.AllocationSize = Irp->Overlay.AllocationSize;

    Status = IoSetInformation( IoGetCurrentIrpStackLocation( Irp )->FileObject,
                               FileAllocationInformation,
                               sizeof( FILE_ALLOCATION_INFORMATION ),
                               &AllInfo );

    ASSERT( (Scb->CompressionUnit == 0) || (Scb->Header.AllocationSize.QuadPart % Scb->CompressionUnit == 0) );

    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CALL_SELF );

    //
    //  Success!  We will reacquire the Vcb quickly to undo the
    //  actions taken above to block access to the new file/attribute.
    //

    if (NT_SUCCESS( Status )) {

        NtfsAcquireExclusiveVcb( IrpContext, Scb->Vcb, TRUE );

        //
        //  Enable access to new file.
        //

        if (FlagOn( CreateFlags, CREATE_FLAG_CREATE_FILE_CASE )) {

            Scb->Fcb->LinkCount = 1;

            if (ARGUMENT_PRESENT( Lcb )) {

                ClearFlag( Lcb->LcbState, LCB_STATE_DELETE_ON_CLOSE );

                if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS )) {

                    ClearFlag( Scb->Fcb->FcbState, FCB_STATE_PRIMARY_LINK_DELETED );
                }
            }

        //
        //  Enable access to new attribute.
        //

        } else {

            ClearFlag( Scb->ScbState, SCB_STATE_DELETE_ON_CLOSE );
        }

        //
        //  If this is the DeleteOnClose case, we mark the Scb and Lcb
        //  appropriately.
        //

        if (FlagOn( CreateFlags, CREATE_FLAG_DELETE_ON_CLOSE )) {

            SetFlag( Ccb->Flags, CCB_FLAG_DELETE_ON_CLOSE );
        }

        NtfsReleaseVcb( IrpContext, Scb->Vcb );

    //
    //  Else there was some sort of error, and we need to let cleanup
    //  and close execute, since when we complete Create with an error
    //  cleanup and close would otherwise never occur.  Cleanup will
    //  delete or truncate a file or attribute as appropriate, based on
    //  how we left the Fcb/Lcb or Scb above.
    //

    } else {

        NtfsIoCallSelf( IrpContext,
                        IoGetCurrentIrpStackLocation( Irp )->FileObject,
                        IRP_MJ_CLEANUP );

        NtfsIoCallSelf( IrpContext,
                        IoGetCurrentIrpStackLocation( Irp )->FileObject,
                        IRP_MJ_CLOSE );
    }

    return Status;
}


//
//  Local support routine
//

ULONG
NtfsOpenExistingEncryptedStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ThisScb,
    IN PFCB CurrentFcb
    )

/*++

Routine Description:

    This routine determines with which FileDirFlags, if any, we should call
    the encryption driver's create callback.

Arguments:

    ThisScb - This is the Scb for the file being opened.

    CurrentFcb - This is the Fcb for the file being opened.

Return Value:

    ULONG - The set of flags, such as FILE_EXISTING or DIRECTORY_EXISTING that
            should be passed to the encryption driver.  If 0 is returned, there
            is no need to call the encryption driver for this create.

--*/

{
    ULONG EncryptionFileDirFlags = 0;

    //
    //  If we don't have an encryption driver then raise ACCESS_DENIED unless
    //  this is a directory, in which case there really isn't any encrypted data
    //  that we need to worry about.  Consider the case where the user has
    //  marked a directory as encrypted and then removed the encryption driver.
    //  There may be unencrypted files in that directory, and there's no reason
    //  to prevent the user from getting to them.
    //

    if (!FlagOn( NtfsData.Flags, NTFS_FLAGS_ENCRYPTION_DRIVER ) &&
        !IsDirectory( &CurrentFcb->Info )) {

        NtfsRaiseStatus( IrpContext, STATUS_ACCESS_DENIED, NULL, NULL );
    }

    //
    //  In NT5, we have not tested with encrypted compressed files, so if we
    //  encounter one (perhaps NT6 created it and the user has gone back to
    //  an NT5 safe build) let's not allow opening it for read/write access.
    //  Like the test above, this is only an issue for files, not directories.
    //

    if (FlagOn( ThisScb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
        !IsDirectory( &CurrentFcb->Info )) {

        NtfsRaiseStatus( IrpContext, STATUS_ACCESS_DENIED, NULL, NULL );
    }

    //
    //  Set the appropriate flags for the 3 existing stream cases.
    //

    if (IsDirectory( &CurrentFcb->Info )) {

        EncryptionFileDirFlags = DIRECTORY_EXISTING | STREAM_EXISTING;

    } else if (IsEncrypted( &CurrentFcb->Info )) {

        EncryptionFileDirFlags = FILE_EXISTING | STREAM_EXISTING | EXISTING_FILE_ENCRYPTED ;

    } else {

        EncryptionFileDirFlags = FILE_EXISTING | STREAM_EXISTING;
    }

    return EncryptionFileDirFlags;
}


//
//  Local support routine
//

NTSTATUS
NtfsEncryptionCreateCallback (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PSCB ThisScb,
    IN PCCB ThisCcb,
    IN PFCB CurrentFcb,
    IN PFCB ParentFcb,
    IN BOOLEAN CreateNewFile
    )

/*++

Routine Description:

    This routine performs the create callback to the encryption driver if one
    is registered, and it is appropriate to do the callback.  We do the
    callback for the open of an existing stream that is marked as encrypted,
    and for the creation of a new file/stream that will be encrypted.

    There are a number of interesting cases, each of which requires its own
    set of flags to be passed to the encryption engine.  Some optimization may
    be possible by setting and clearing individual bits for certain semi-general
    cases, but at a massive cost in readability/maintainability.

Arguments:

    Irp - Supplies the Irp to process.

    ThisScb - This is the Scb for the file being opened.

    ThisCcb - This is the Ccb for the file being opened

    CurrentFcb - This is the Fcb for the file being opened.

    ParentFcb - This is the Fcb for the parent of the file being opened.
                Although not truly optional, it may be NULL for an
                existing file being opened, such as an open by id.

    CreateNewFile - TRUE if we're being called from NtfsCreateNewFile, FALSE otherwise.

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    NTSTATUS EncryptionStatus = STATUS_SUCCESS;
    ULONG FileAttributes = (ULONG) IrpSp->Parameters.Create.FileAttributes;
    ULONG EncryptionFileDirFlags = 0;

    PAGED_CODE();

    //
    //  If this is an existing stream and the encryption bit is set then either
    //  call the driver or fail the request.  We have to test CreateNewFile
    //  also in case our caller has not set the Information field of the Irp yet.
    //

    if (!NtfsIsStreamNew( Irp->IoStatus.Information ) &&
        !CreateNewFile) {

        if (FlagOn( ThisScb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED ) &&
            FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                    FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA | FILE_EXECUTE)) {

            EncryptionFileDirFlags = NtfsOpenExistingEncryptedStream( IrpContext, ThisScb, CurrentFcb );
        } // else EncryptionFileDirFlags = 0;

    //
    //  We need the encryption driver for new creates.  We may be dealing with a
    //  new file create or a supersede/overwrite.
    //

    } else if (FlagOn( NtfsData.Flags, NTFS_FLAGS_ENCRYPTION_DRIVER )) {

        if (CreateNewFile) {

            //
            //  This is a new stream in a new file.
            //

            ASSERT( (ParentFcb == NULL) ||
                    FlagOn( ParentFcb->FcbState, FCB_STATE_DUP_INITIALIZED ));

            //
            //  We want this new file/directory to be created encrypted if
            //  its parent directory is encrypted, or our caller has asked
            //  to have it created encrypted.
            //

            if (((ParentFcb != NULL) &&
                 (IsEncrypted( &ParentFcb->Info ))) ||

                FlagOn( FileAttributes, FILE_ATTRIBUTE_ENCRYPTED )) {

                if (IsDirectory( &CurrentFcb->Info )) {

                    EncryptionFileDirFlags = DIRECTORY_NEW | STREAM_NEW;

                } else {

                    EncryptionFileDirFlags = FILE_NEW | STREAM_NEW;
                }
            } // else EncryptionFileDirFlags = 0;

        } else {

            //
            //  This is a supersede/overwrite or else a new stream being created
            //  in an existing file.
            //

            ASSERT( CurrentFcb != NULL );
            ASSERT( NtfsIsStreamNew( Irp->IoStatus.Information ) );

            if ((Irp->IoStatus.Information == FILE_SUPERSEDED) ||
                (Irp->IoStatus.Information == FILE_OVERWRITTEN)) {

                if (FlagOn( FileAttributes, FILE_ATTRIBUTE_ENCRYPTED )) {

                    //
                    //  This is a supersede/overwrite where the caller set the encrypted flag.
                    //

                    if (IsDirectory( &CurrentFcb->Info )) {

                        EncryptionFileDirFlags = DIRECTORY_NEW | STREAM_NEW;

                    } else if (FlagOn( ThisScb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                        //
                        //  When superseding/overwriting the unnamed stream, the flags we
                        //  pass depend on the encrypted state of the old file.
                        //

                        if (IsEncrypted( &CurrentFcb->Info )) {

                            EncryptionFileDirFlags = FILE_EXISTING | STREAM_NEW | EXISTING_FILE_ENCRYPTED;

                        } else {

                            //
                            //  If there are open handles to this or any other stream, and the
                            //  encryption engine will wish it could encrypt all streams, we
                            //  may as well just fail the create now.
                            //

                            if ((CurrentFcb->CleanupCount > 1) &&
                                FlagOn( NtfsData.EncryptionCallBackTable.ImplementationFlags, ENCRYPTION_ALL_STREAMS )) {

                                NtfsRaiseStatus( IrpContext, STATUS_SHARING_VIOLATION, NULL, NULL );
                            }

                            EncryptionFileDirFlags = FILE_NEW | STREAM_NEW;
                        }

                    } else if (!FlagOn( NtfsData.EncryptionCallBackTable.ImplementationFlags, ENCRYPTION_ALL_STREAMS )) {

                        //
                        //  We're superseding a named stream; if the encryption engine allows individual
                        //  streams to be encrypted, notify it.
                        //

                        EncryptionFileDirFlags = FILE_EXISTING | STREAM_NEW | EXISTING_FILE_ENCRYPTED;
                    } // else EncryptionFileDirFlags = 0;

                } else if (!FlagOn( ThisScb->ScbState, SCB_STATE_UNNAMED_DATA ) &&
                           IsEncrypted( &CurrentFcb->Info )) {

                    //
                    //  This is a supersede/overwrite of a named stream within an encrypted file.
                    //

                    if (IsDirectory( &CurrentFcb->Info )) {

                        EncryptionFileDirFlags = DIRECTORY_EXISTING | STREAM_NEW;

                    } else {

                        EncryptionFileDirFlags = FILE_EXISTING | STREAM_NEW | EXISTING_FILE_ENCRYPTED;
                    }

                } else {

                    //
                    //  We're superseding/overwriting the unnamed stream, and it's retaining
                    //  its encryption from before the overwrite.
                    //

                    if (FlagOn( ThisScb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED ) &&
                        FlagOn( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                                FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA | FILE_EXECUTE)) {

                        EncryptionFileDirFlags = NtfsOpenExistingEncryptedStream( IrpContext, ThisScb, CurrentFcb );
                    }
                }

            } else if (IsEncrypted( &CurrentFcb->Info )) {

                ASSERT( Irp->IoStatus.Information == FILE_CREATED );

                //
                //  This is a new stream being created in an existing encrypted file.
                //

                if (IsDirectory( &CurrentFcb->Info )) {

                    EncryptionFileDirFlags = DIRECTORY_EXISTING | STREAM_NEW;

                } else {

                    EncryptionFileDirFlags = FILE_EXISTING | STREAM_NEW | EXISTING_FILE_ENCRYPTED;
                }
            } // else EncryptionFileDirFlags = 0;
        }
    } // else EncryptionFileDirFlags = 0;

    //
    //  Remember the EncryptionFileDirFlags in case we need to use them to
    //  cleanup later.
    //

    ASSERT( IrpContext->EncryptionFileDirFlags == 0 ||
            IrpContext->EncryptionFileDirFlags == EncryptionFileDirFlags );

    IrpContext->EncryptionFileDirFlags = EncryptionFileDirFlags;

    //
    //  Perform the update if we have encryption flags and there is a callback.
    //

    if (EncryptionFileDirFlags != 0) {

        if (FlagOn( EncryptionFileDirFlags, FILE_NEW | DIRECTORY_NEW )) {

            //
            //  While we're still holding the fcb, set the bit that reminds us
            //  to block other creates until the encryption engine has had its
            //  chance to set the key context for this stream.
            //

            ASSERT_EXCLUSIVE_FCB( CurrentFcb );
            SetFlag( CurrentFcb->FcbState, FCB_STATE_ENCRYPTION_PENDING );
        }

        if (NtfsData.EncryptionCallBackTable.FileCreate != NULL) {

            //
            //  Find the parent, if we can't find a parent (most likely in
            //  the supersede by id case) just pass the current fcb as the
            //  parent.
            //

            if ((ParentFcb == NULL)) {

                if ((ThisCcb->Lcb != NULL) &&
                    (ThisCcb->Lcb->Scb != NULL )) {

                    ParentFcb = ThisCcb->Lcb->Scb->Fcb;

                } else {

                    ParentFcb = CurrentFcb;
                }
            }

            ASSERT( ParentFcb != NULL );

            EncryptionStatus = NtfsData.EncryptionCallBackTable.FileCreate(
                                    CurrentFcb,
                                    ParentFcb,
                                    IrpSp,
                                    EncryptionFileDirFlags,
                                    (NtfsIsVolumeReadOnly( CurrentFcb->Vcb )) ? READ_ONLY_VOLUME : 0,
                                    IrpContext,
                                    (PDEVICE_OBJECT) CONTAINING_RECORD( CurrentFcb->Vcb,
                                                                        VOLUME_DEVICE_OBJECT,
                                                                        Vcb ),
                                    NULL,
                                    &ThisScb->EncryptionContext,
                                    &ThisScb->EncryptionContextLength,
                                    &IrpContext->EfsCreateContext,
                                    NULL );

            if (EncryptionStatus != STATUS_SUCCESS) {

                NtfsRaiseStatus( IrpContext, EncryptionStatus, NULL, NULL );
            }
        }
    }

    return EncryptionStatus;
}


//
//  Local support routine
//

VOID
NtfsPostProcessEncryptedCreate (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN ULONG EncryptionFileDirFlags,
    IN ULONG FailedInPostCreateOnly
    )

/*++

Routine Description:

    This routine is called after the encryption driver's post create callout
    returns.  If we failed a create in the post create callout that had been
    successful before the post create callout, we have to cleanup the file.
    If we just created the file, we need to clear the encryption_pending bit
    safely.

Arguments:

    FileObject - Supplies the FileObject being created.

    EncryptionFileDirFlags - Some combination of FILE_NEW, FILE_EXISTING, etc.

    FailedInPostCreateOnly - Pass TRUE if the create operation had succeeded
                             until the PostCreate callout.

Return Value:

    None.

--*/

{
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PLCB Lcb;

    BOOLEAN FcbStillExists = TRUE;

    PAGED_CODE();

    //
    //  In some failure cases, we'll have no FileObject, in which case we have
    //  no cleanup to do.  We can't do much without a FileObject anyway.
    //

    if (FileObject == NULL) {

        return;
    }

    NtfsDecodeFileObject( IrpContext,
                          FileObject,
                          &Vcb,
                          &Fcb,
                          &Scb,
                          &Ccb,
                          FALSE );

    //
    //  If we failed only in the post create, backout this create.
    //

    if (FailedInPostCreateOnly) {

        if (FlagOn( EncryptionFileDirFlags, FILE_NEW | DIRECTORY_NEW ) ||

            (FlagOn( EncryptionFileDirFlags, STREAM_NEW ) &&
             FlagOn( EncryptionFileDirFlags, FILE_EXISTING ))) {

            //
            //  Delete the stream if we still can.  First acquire
            //  the Scb so we can safely test some bits in it.
            //

            NtfsAcquireExclusiveScb( IrpContext, Scb );

            //
            //  If a dismount happened while we weren't holding the Scb,
            //  we should just do the cleanup & close and get out of here.
            //

            if (!FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                //
                //  See if we can still delete the stream.  N.B. If we're
                //  working with the unnamed data stream, deleting the
                //  stream will delete the file.
                //

                Lcb = Ccb->Lcb;

                if (!FlagOn( Scb->ScbState, SCB_STATE_MULTIPLE_OPENS ) &&
                    (Lcb != NULL)) {

                    //
                    //  Now see if the file is really deleteable according to indexsup
                    //

                    if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

                        BOOLEAN LastLink;
                        BOOLEAN NonEmptyIndex = FALSE;

                        //
                        //  If the link is not deleted, we check if it can be deleted.
                        //  Since we dropped all our resources for the PostCreate callout,
                        //  this might be a nonempty index or a file with multiple
                        //  links already.
                        //

                        if ((BOOLEAN)!LcbLinkIsDeleted( Lcb )
                            && (BOOLEAN)NtfsIsLinkDeleteable( IrpContext, Scb->Fcb, &NonEmptyIndex, &LastLink )) {

                            //
                            //  It is ok to get rid of this guy.  All we need to do is
                            //  mark this Lcb for delete and decrement the link count
                            //  in the Fcb.  If this is a primary link, then we
                            //  indicate that the primary link has been deleted.
                            //

                            SetFlag( Lcb->LcbState, LCB_STATE_DELETE_ON_CLOSE );

                            ASSERTMSG( "Link count should not be 0\n", Scb->Fcb->LinkCount != 0 );
                            Scb->Fcb->LinkCount -= 1;

                            if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS )) {

                                SetFlag( Scb->Fcb->FcbState, FCB_STATE_PRIMARY_LINK_DELETED );
                            }

                            //
                            //  Indicate in the file object that a delete is pending
                            //

                            FileObject->DeletePending = TRUE;
                        }

                    } else {

                        //
                        //  Otherwise we are simply removing the attribute.
                        //

                        SetFlag( Scb->ScbState, SCB_STATE_DELETE_ON_CLOSE );

                        //
                        //  Indicate in the file object that a delete is pending
                        //

                        FileObject->DeletePending = TRUE;
                    }
                }
            }

            //
            //  We can clear the pending bit now that we're done handling the
            //  failure.
            //

            if (FlagOn( EncryptionFileDirFlags, FILE_NEW | DIRECTORY_NEW )) {

                ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) );
                NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );
                ASSERT( (Scb->EncryptionContext != NULL) || FailedInPostCreateOnly );
                ClearFlag( Fcb->FcbState, FCB_STATE_ENCRYPTION_PENDING );
                KeSetEvent( &NtfsEncryptionPendingEvent, 0, FALSE );
                NtfsReleaseFcb( IrpContext, Fcb );
            }

            //
            //  We need to release the Scb now, since the close may
            //  result in the Scb getting freed.
            //

            NtfsReleaseScb( IrpContext, Scb );

            NtfsIoCallSelf( IrpContext,
                            FileObject,
                            IRP_MJ_CLEANUP );

            FcbStillExists = FALSE;

            NtfsIoCallSelf( IrpContext,
                            FileObject,
                            IRP_MJ_CLOSE );

        } else if ((FlagOn( EncryptionFileDirFlags, FILE_EXISTING ) &&
                    FlagOn( EncryptionFileDirFlags, STREAM_EXISTING )) ||

                   FlagOn( EncryptionFileDirFlags, DIRECTORY_EXISTING )) {

#ifdef NTFSDBG
            ASSERT( None == IrpContext->OwnershipState );
#endif

            //
            //  All we have to do in this case is a cleanup and a close.
            //

            NtfsIoCallSelf( IrpContext,
                            FileObject,
                            IRP_MJ_CLEANUP );

            FcbStillExists = FALSE;

            NtfsIoCallSelf( IrpContext,
                            FileObject,
                            IRP_MJ_CLOSE );
        }
    }

    //
    //  If we've done a cleanup & close, the Fcb may have been freed already,
    //  in which case we should just set the pending event and get out of here.
    //  If we still have the Fcb, let's make sure we've cleared the pending bit.
    //

    if (FlagOn( EncryptionFileDirFlags, FILE_NEW | DIRECTORY_NEW )) {

        if (FcbStillExists) {

            ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) );
            NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );
            ClearFlag( Fcb->FcbState, FCB_STATE_ENCRYPTION_PENDING );
            KeSetEvent( &NtfsEncryptionPendingEvent, 0, FALSE );
            NtfsReleaseFcb( IrpContext, Fcb );

        } else {

            KeSetEvent( &NtfsEncryptionPendingEvent, 0, FALSE );
        }
    }
}


NTSTATUS
NtfsTryOpenFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PFCB *CurrentFcb,
    IN FILE_REFERENCE FileReference
    )

/*++

Routine Description:

    This routine is called to open a file by its file segment number.
    We need to verify that this file Id exists.  This code is
    patterned after open by Id.

Arguments:

    Vcb - Vcb for this volume.

    CurrentFcb - Address of Fcb pointer.  Store the Fcb we find here.

    FileReference - This is the file Id for the file to open the
                    sequence number is ignored.

Return Value:

    NTSTATUS - Indicates the result of this create file operation.

Note:

    If the status is successful then the FCB is returned with its reference
    count incremented and the FCB held exclusive.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    LONGLONG MftOffset;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PBCB Bcb = NULL;

    PFCB ThisFcb;

    BOOLEAN AcquiredFcbTable = FALSE;
    BOOLEAN AcquiredMft = TRUE;
    BOOLEAN ThisFcbFree = TRUE;

    PAGED_CODE();

    ASSERT( *CurrentFcb == NULL );

    //
    //  Do not bother with system files.
    //

    //
    //  If this is a system fcb then return.
    //

    if (NtfsFullSegmentNumber( &FileReference ) < FIRST_USER_FILE_NUMBER &&
        NtfsFullSegmentNumber( &FileReference ) != ROOT_FILE_NAME_INDEX_NUMBER) {

        return STATUS_NOT_FOUND;
    }

    //
    //  Calculate the offset in the MFT. Use the full segment number since the user
    //  can specify any 48-bit value.
    //

    MftOffset = NtfsFullSegmentNumber( &FileReference );

    MftOffset = Int64ShllMod32(MftOffset, Vcb->MftShift);

    //
    //  Acquire the MFT shared so it cannot shrink on us.
    //

    NtfsAcquireSharedScb( IrpContext, Vcb->MftScb );

    try {

        if (MftOffset >= Vcb->MftScb->Header.FileSize.QuadPart) {

            DebugTrace( 0, Dbg, ("File Id doesn't lie within Mft\n") );

             Status = STATUS_END_OF_FILE;
             leave;
        }

        NtfsReadMftRecord( IrpContext,
                           Vcb,
                           &FileReference,
                           FALSE,
                           &Bcb,
                           &FileRecord,
                           NULL );

        //
        //  This file record better be in use, better not be one of the other system files,
        //  and have a matching sequence number and be the primary file record for this file.
        //

        if (!FlagOn( FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE ) ||
            FlagOn( FileRecord->Flags, FILE_SYSTEM_FILE ) ||
            (*((PLONGLONG) &FileRecord->BaseFileRecordSegment) != 0) ||
            (*((PULONG) FileRecord->MultiSectorHeader.Signature) != *((PULONG) FileSignature))) {

            Status = STATUS_NOT_FOUND;
            leave;
        }

        //
        //  Get the current sequence number.
        //

        FileReference.SequenceNumber = FileRecord->SequenceNumber;

        NtfsUnpinBcb( IrpContext, &Bcb );

        NtfsAcquireFcbTable( IrpContext, Vcb );
        AcquiredFcbTable = TRUE;

        //
        //  We know that it is safe to continue the open.  We start by creating
        //  an Fcb for this file.  It is possible that the Fcb exists.
        //  We create the Fcb first, if we need to update the Fcb info structure
        //  we copy the one from the index entry.  We look at the Fcb to discover
        //  if it has any links, if it does then we make this the last Fcb we
        //  reached.  If it doesn't then we have to clean it up from here.
        //

        ThisFcb = NtfsCreateFcb( IrpContext,
                                 Vcb,
                                 FileReference,
                                 FALSE,
                                 TRUE,
                                 NULL );

        //
        //  ReferenceCount the fcb so it does no go away.
        //

        ThisFcb->ReferenceCount += 1;

        //
        //  Release the mft and fcb table before acquiring the FCB exclusive.
        //

        NtfsReleaseScb( IrpContext, Vcb->MftScb );
        NtfsReleaseFcbTable( IrpContext, Vcb );
        AcquiredMft = FALSE;
        AcquiredFcbTable = FALSE;

        NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, 0 );
        ThisFcbFree = FALSE;

        //
        //  Repin the file record with synchronization to the fcb
        //

        NtfsReadMftRecord( IrpContext,
                           Vcb,
                           &FileReference,
                           FALSE,
                           &Bcb,
                           &FileRecord,
                           NULL );

        //
        //  Skip any deleted files.
        //

        if (FlagOn( ThisFcb->FcbState, FCB_STATE_FILE_DELETED ) ||
            !FlagOn( FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE )) {

            NtfsUnpinBcb( IrpContext, &Bcb );

#ifdef QUOTADBG
            DbgPrint( "NtfsTryOpenFcb: Deleted fcb found. Fcb = %lx\n", ThisFcb );
#endif
            NtfsAcquireFcbTable( IrpContext, Vcb );
            ASSERT( ThisFcb->ReferenceCount > 0 );
            ThisFcb->ReferenceCount--;
            NtfsReleaseFcbTable( IrpContext, Vcb );

            NtfsTeardownStructures( IrpContext,
                                    ThisFcb,
                                    NULL,
                                    FALSE,
                                    0,
                                    &ThisFcbFree );

            //
            //  Release the fcb if it has not been deleted.
            //

            if (!ThisFcbFree) {
                NtfsReleaseFcb( IrpContext, ThisFcb );
                ThisFcbFree = TRUE;
            }

            //
            //  Teardown may generate a transaction, clean it up.
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE | IRP_CONTEXT_FLAG_RETAIN_FLAGS );
            NtfsCompleteRequest( IrpContext, NULL, Status );

            Status = STATUS_NOT_FOUND;
            leave;
        }

        NtfsUnpinBcb( IrpContext, &Bcb );

        //
        //  Store this Fcb into our caller's parameter and remember to
        //  to show we acquired it.
        //

        *CurrentFcb = ThisFcb;
        ThisFcbFree = TRUE;


        //
        //  If the Fcb Info field needs to be initialized, we do so now.
        //  We read this information from the disk.
        //

        if (!FlagOn( ThisFcb->FcbState, FCB_STATE_DUP_INITIALIZED )) {

            NtfsUpdateFcbInfoFromDisk( IrpContext,
                                       TRUE,
                                       ThisFcb,
                                       NULL );

        }

    } finally {

        if (AcquiredFcbTable) {

            NtfsReleaseFcbTable( IrpContext, Vcb );
        }

        NtfsUnpinBcb( IrpContext, &Bcb );

        if (AcquiredMft) {
            NtfsReleaseScb( IrpContext, Vcb->MftScb );
        }

        if (!ThisFcbFree) {
            NtfsReleaseFcb( IrpContext, ThisFcb );
        }
    }

    return Status;

}


//
//  Worker routine.
//

NTSTATUS
NtfsGetReparsePointValue (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN USHORT RemainingNameLength
    )

/*++

Routine Description:

    This routine retrieves the value of the specified reparse point and returns it to
    the caller.

    The user-controlled data in the reparse point is returned in a new buffer pointed
    from  Irp->Tail.Overlay.AuxiliaryBuffer. When the request traverses the stack of
    layered drivers and not one operates on it, it is freed by the I/O subsystem in
    IoCompleteRequest.

    To provide callers with an indication of where in the name the parsing stoped, in
    the Reserved field of the REPARSE_DATA_BUFFER structure we return the length of the
    portion of the name that remains to be parsed by NTFS. We account for the file
    delimiter in our value to make the paste of names easy in IopParseDevice.

    The name offset arithmetic is correct only if:
    (1) All the intermediate names in the path are simple, that is, they do not contain
        any : (colon) in them.
    (2) The RemainingNameLength includes all the parts present in the last name component.

    When this function succeeds, it sets in Irp->IoStatus.Information the Tag of the
    reparse point that we have just copied out. In this case we return STATUS_REPARSE
    and set Irp->IoStatus.Status to STATUS_REPARSE.

Arguments:

    IrpContext - Supplies the Irp context of the call.

    Irp - Supplies the Irp being processed

    IrpSp - This is the Irp stack pointer for the filesystem.

    Fcb - Address of the Fcb pointer where the $REPARSE_POINT attribute is located.

    RemainingNameLength - Length of the part of the name that still needs to be parsed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_REPARSE;
    PREPARSE_DATA_BUFFER ReparseBuffer = NULL;

    POPLOCK_CLEANUP OplockCleanup = IrpContext->Union.OplockCleanup;

    BOOLEAN CleanupAttributeContext = FALSE;
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    PATTRIBUTE_RECORD_HEADER AttributeHeader = NULL;
    ULONG AttributeLengthInBytes = 0;    //  Invalid value
    PVOID AttributeData = NULL;

    PBCB Bcb = NULL;

    PAGED_CODE( );

    DebugTrace( +1, Dbg, ("NtfsGetReparsePointValue,  Fcb %08lx\n", Fcb) );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    DebugTrace( 0, Dbg, ("OplockCleanup->OriginalFileName %x %Z\n", OplockCleanup->OriginalFileName.Buffer, &OplockCleanup->OriginalFileName) );
    DebugTrace( 0, Dbg, ("OplockCleanup->FullFileName     %x %Z\n", OplockCleanup->FullFileName.Buffer, &OplockCleanup->FullFileName) );
    DebugTrace( 0, Dbg, ("OplockCleanup->ExactCaseName    %x %Z\n", OplockCleanup->ExactCaseName.Buffer, &OplockCleanup->ExactCaseName) );
    DebugTrace( 0, Dbg, ("IrpSP...->FileName              %x %Z\n", IrpSp->FileObject->FileName.Buffer, &IrpSp->FileObject->FileName) );
#endif

    DebugTrace( 0,
                Dbg,
                ("Length of remaining name [d] %04ld %04lx OriginalFileName.Length [d] %04ld %04lx\n",
                 RemainingNameLength,
                 RemainingNameLength,
                 OplockCleanup->OriginalFileName.Length,
                 OplockCleanup->OriginalFileName.Length) );

    ASSERT( FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT ));
    ASSERT( Irp->Tail.Overlay.AuxiliaryBuffer == NULL );

    //
    //  Now it is time to use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Find the reparse point attribute in the file.
        //

        CleanupAttributeContext = TRUE;
        NtfsInitializeAttributeContext( &AttributeContext );

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $REPARSE_POINT,
                                        &AttributeContext )) {

            DebugTrace( 0, Dbg, ("Can't find the $REPARSE_POINT attribute.\n") );

            //
            //  Should not happen. Raise an exeption as we are in an
            //  inconsistent state. The attribute flag says that
            //  $REPARSE_POINT has to be present.
            //

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        //
        //  Find the size of the attribute and map its value to AttributeData.
        //

        AttributeHeader = NtfsFoundAttribute( &AttributeContext );

        if (NtfsIsAttributeResident( AttributeHeader )) {

            AttributeLengthInBytes = AttributeHeader->Form.Resident.ValueLength;
            DebugTrace( 0, Dbg, ("Attribute is resident with length %08lx\n", AttributeLengthInBytes) );

            if (AttributeLengthInBytes > MAXIMUM_REPARSE_DATA_BUFFER_SIZE) {

                //
                //  Return STATUS_IO_REPARSE_DATA_INVALID
                //

                Status = STATUS_IO_REPARSE_DATA_INVALID;
                leave;
            }

            //
            // Point to the value of the attribute.
            //

            AttributeData = NtfsAttributeValue( AttributeHeader );

        } else {

            ULONG Length;

            if (AttributeHeader->Form.Nonresident.FileSize > MAXIMUM_REPARSE_DATA_BUFFER_SIZE) {

                //
                //  Return STATUS_IO_REPARSE_DATA_INVALID
                //

                Status = STATUS_IO_REPARSE_DATA_INVALID;
                DebugTrace( 0, Dbg, ("Nonresident.FileSize is too long.\n") );

                leave;
            }

            //
            // Note that we coerse different LENGTHS
            //

            AttributeLengthInBytes = (ULONG)AttributeHeader->Form.Nonresident.FileSize;
            DebugTrace( 0, Dbg, ("Attribute is non-resident with length %05lx\n", AttributeLengthInBytes) );

            NtfsMapAttributeValue( IrpContext,
                                   Fcb,
                                   &AttributeData,
                                   &Length,
                                   &Bcb,
                                   &AttributeContext );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
            if (AttributeLengthInBytes != Length) {
                DebugTrace( 0, Dbg, ("AttributeLengthInBytes [d]%05ld and Length [d]%05ld differ.\n", AttributeLengthInBytes, Length) );
            }
            ASSERT( AttributeLengthInBytes == Length );
#endif
        }

        //
        //  Reference the reparse point data.
        //  It is appropriate to use this cast, and not concern ourselves with the GUID
        //  buffer, because we only read the common fields.
        //

        ReparseBuffer = (PREPARSE_DATA_BUFFER)AttributeData;
        DebugTrace( 0, Dbg, ("ReparseDataLength [d]%08ld %08lx\n",
                    ReparseBuffer->ReparseDataLength, ReparseBuffer->ReparseDataLength) );

        //
        //  Verify that the length of the reparse point data is within our legal bound.
        //
        //  Over time, this length can become illegal due to:
        //  (1) A decrease of the maximum legal value of the reparse point data.
        //  (2) A corruption of the data stored in the attribute.
        //

        if (ReparseBuffer->ReparseDataLength > MAXIMUM_REPARSE_DATA_BUFFER_SIZE) {

            //
            //  Return STATUS_IO_REPARSE_DATA_INVALID
            //

            Status = STATUS_IO_REPARSE_DATA_INVALID;
            DebugTrace( 0, Dbg, ("ReparseDataLength is (now) too long.\n") );

            leave;
        }

        //
        //  We leave all the names in their original state.
        //  Return the complete reparse point data buffer off
        //  Irp->Tail.Overlay.AuxiliaryBuffer, already including the ReparseDataLength.
        //

        Irp->Tail.Overlay.AuxiliaryBuffer = NtfsAllocatePool( NonPagedPool,
                                                              AttributeLengthInBytes );
        DebugTrace( 0, Dbg, ("Irp->Tail.Overlay.AuxiliaryBuffer %08lx\n", Irp->Tail.Overlay.AuxiliaryBuffer) );
        RtlCopyMemory( (PCHAR)Irp->Tail.Overlay.AuxiliaryBuffer,
                       (PCHAR)AttributeData,
                       AttributeLengthInBytes );

        //
        //  We also return the length of the portion of the name that remains to be parsed using the
        //  Reserved field in the REPARSE_DATA_BUFFER structure.
        //
        //  The \ (backslash) in a multi-component name is always accounted for by the code before
        //  calling this routine.
        //  The : (colon) in a complex name is always accounted for by the code before calling this
        //  routine.
        //

        ReparseBuffer = (PREPARSE_DATA_BUFFER)Irp->Tail.Overlay.AuxiliaryBuffer;

        ReparseBuffer->Reserved = RemainingNameLength;

        //
        //  Better not have a non-zero length if opened by file id.
        //

        ASSERT( (RemainingNameLength == 0) ||
                !FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID ));

        DebugTrace( 0, Dbg, ("Final value for ReparseBuffer->Reserved = %d\n", ReparseBuffer->Reserved) );

        //
        //  When the Reserved field is positive, the offset should always denote the backslash character
        //  or the colon character.
        //
        //  Assert this here.
        //

        if (ReparseBuffer->Reserved) {

            DebugTrace( 0, Dbg, ("NameOffset = %d\n", (OplockCleanup->OriginalFileName.Length - ReparseBuffer->Reserved)) );

            ASSERT( (*((PCHAR)(OplockCleanup->OriginalFileName.Buffer) + (OplockCleanup->OriginalFileName.Length - ReparseBuffer->Reserved)) == L'\\') ||
                    (*((PCHAR)(OplockCleanup->OriginalFileName.Buffer) + (OplockCleanup->OriginalFileName.Length - ReparseBuffer->Reserved)) == L':') );

            ASSERT( (OplockCleanup->OriginalFileName.Buffer[(OplockCleanup->OriginalFileName.Length - ReparseBuffer->Reserved)/sizeof(WCHAR)] == L'\\') ||
                    (OplockCleanup->OriginalFileName.Buffer[(OplockCleanup->OriginalFileName.Length - ReparseBuffer->Reserved)/sizeof(WCHAR)] == L':') );
        }

        //
        //  Set the Information field to the ReparseTag.
        //

        Irp->IoStatus.Information = ReparseBuffer->ReparseTag;

    } finally {

        DebugUnwind( NtfsGetReparsePointValue );

        if (CleanupAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }

        //
        //  Unpin the Bcb ... in case you needed to pin it above.
        //  The unpin routine checks for NULL.
        //

        NtfsUnpinBcb( IrpContext, &Bcb );
    }

    DebugTrace( -1, Dbg, ("NtfsGetReparsePointValue -> IoStatus.Information %08lx  Status %08lx\n", Irp->IoStatus.Information, Status) );

    return Status;

    UNREFERENCED_PARAMETER( IrpSp );
}

NTSTATUS
NtfsLookupObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PUNICODE_STRING FileName,
    OUT PFILE_REFERENCE FileReference
    )

/*++

Routine Description:

    This routine retrieves the value of the specified objectid and returns it to
    the caller.

Arguments:

    IrpContext - Supplies the Irp context of the call.

    Vcb - the volume to look it up in

    FileName - Contains the objectid embedded in the unicode string

    FileReference - on success contains the file that this objectid refers to


Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    INDEX_KEY IndexKey;
    INDEX_ROW IndexRow;
    UCHAR ObjectId[OBJECT_ID_KEY_LENGTH];
    NTFS_OBJECTID_INFORMATION ObjectIdInfo;
    MAP_HANDLE MapHandle;

    BOOLEAN CleanupMapHandle = FALSE;

    PAGED_CODE();

    //
    //  Copy the object id out of the file name, optionally skipping
    //  over the Win32 backslash at the start of the buffer.
    //

    if (FileName->Length == OBJECT_ID_KEY_LENGTH) {

        RtlCopyMemory( &ObjectId,
                       &FileName->Buffer[0],
                       sizeof( ObjectId ) );

    } else {

        RtlCopyMemory( &ObjectId,
                       &FileName->Buffer[1],
                       sizeof( ObjectId ) );
    }

    //
    //  Acquire the object id index for the volume.
    //

    NtfsAcquireSharedScb( IrpContext, Vcb->ObjectIdTableScb );

    //
    //  Find the ObjectId.
    //

    try {
        IndexKey.Key = &ObjectId;
        IndexKey.KeyLength = sizeof( ObjectId );

        NtOfsInitializeMapHandle( &MapHandle );
        CleanupMapHandle = TRUE;

        Status = NtOfsFindRecord( IrpContext,
                                  Vcb->ObjectIdTableScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  NULL );

        if (!NT_SUCCESS( Status )) {
            leave;
        }

        ASSERT( IndexRow.DataPart.DataLength == sizeof( NTFS_OBJECTID_INFORMATION ) );

        RtlZeroMemory( &ObjectIdInfo,
                       sizeof( NTFS_OBJECTID_INFORMATION ) );

        RtlCopyMemory( &ObjectIdInfo,
                       IndexRow.DataPart.Data,
                       sizeof( NTFS_OBJECTID_INFORMATION ) );

        RtlCopyMemory( FileReference,
                       &ObjectIdInfo.FileSystemReference,
                       sizeof( FILE_REFERENCE ) );

        //
        //  Now we have a file reference number, we're ready to proceed
        //  normally and open the file.  There's no point in holding the
        //  object id index anymore, we've looked up all we needed in there.
        //

    } finally {
        NtfsReleaseScb( IrpContext, Vcb->ObjectIdTableScb );

        if (CleanupMapHandle) {
            NtOfsReleaseMap( IrpContext, &MapHandle );
        }
    }

    return Status;
}


#ifdef BRIANDBG
VOID
NtfsTestOpenName (
    IN PFILE_OBJECT FileObject
    )
{
    ULONG Count = NtfsTestName.Length;

    //
    //  This will let us catch particular opens through the debugger.
    //

    if ((Count != 0) &&
        (FileObject->FileName.Length >= Count)) {

        PWCHAR TestChar;
        PWCHAR SourceChar = &FileObject->FileName.Buffer[ FileObject->FileName.Length / sizeof( WCHAR ) ];

        Count = Count / sizeof( WCHAR );
        TestChar = &NtfsTestName.Buffer[ Count ];

        do {
            TestChar -= 1;
            SourceChar -= 1;

            if ((*TestChar | 0x20) != (*SourceChar | 0x20)) {

                break;
            }

            Count -= 1;

        } while (Count != 0);

        ASSERT( Count != 0 );
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\close.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Close.c

Abstract:

    This module implements the File Close routine for Ntfs called by the
    dispatch driver.

Author:

    Your Name       [Email]         dd-Mon-Year

Revision History:

--*/

#include "NtfsProc.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLOSE)

ULONG NtfsAsyncPassCount = 0;

//
//  Local procedure prototypes
//

NTSTATUS
NtfsCommonClose (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN PCCB *Ccb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN BOOLEAN ReadOnly,
    IN BOOLEAN CalledFromFsp
    );

VOID
NtfsQueueClose (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN DelayClose
    );

PIRP_CONTEXT
NtfsRemoveClose (
    IN PVCB Vcb OPTIONAL,
    IN BOOLEAN ThrottleCreate
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonClose)
#pragma alloc_text(PAGE, NtfsFsdClose)
#pragma alloc_text(PAGE, NtfsFspClose)
#endif


NTSTATUS
NtfsFsdClose (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of Close.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext = NULL;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    BOOLEAN IsSystemFile;
    BOOLEAN IsReadOnly;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    ASSERT_IRP( Irp );

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS
    //

    if (VolumeDeviceObject->DeviceObject.Size == (USHORT)sizeof(DEVICE_OBJECT)) {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FILE_OPENED;

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );

        return STATUS_SUCCESS;
    }

    DebugTrace( +1, Dbg, ("NtfsFsdClose\n") );

    //
    //  Extract and decode the file object, we are willing to handle the unmounted
    //  file object.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    //
    //  Special case the unopened file object
    //

    if (TypeOfOpen == UnopenedFileObject) {

        DebugTrace( 0, Dbg, ("Close unopened file object\n") );

        Status = STATUS_SUCCESS;
        NtfsCompleteRequest( NULL, Irp, Status );

        DebugTrace( -1, Dbg, ("NtfsFsdClose -> %08lx\n", Status) );
        return Status;
    }

    //
    //  If this is the log file object for the Vcb then clear the field in the Vcb and
    //  return.  We don't need to synchronize here since there is only one file object
    //  and it is closed only once.
    //

    if (FileObject == Vcb->LogFileObject) {

        //
        //  Clear the internal file name constant
        //

        NtfsClearInternalFilename( Vcb->LogFileObject );

        Vcb->LogFileObject = NULL;

        Status = STATUS_SUCCESS;
        NtfsCompleteRequest( NULL, Irp, Status );

        DebugTrace( -1, Dbg, ("NtfsFsdClose -> %08lx\n", Status) );
        return Status;
    }

    //
    //  Call the common Close routine
    //

    FsRtlEnterFileSystem();

    //
    //  Remember if this Ccb has gone through close.
    //

    if (Ccb != NULL) {

        //
        //  We are not synchronized with the file resources at this point.
        //  It is possible that NtfsUpdateFileDupInfo or the rename path may want to
        //  update the name in the CCB. Our intention here is to mark this CCB_FLAG_CLOSE
        //  so that these other operations know to skip this CCB.  We need to deal with the
        //  race condition where these other operations don't see the CLOSE flag but
        //  then access the CCB name (which points back to the file object) after we
        //  return the file object to the object manager (but put the CCB on the delayed
        //  close queue).
        //
        //  We will use the Fcb mutex to close the hole where DupInfo and rename need to look
        //  at a CCB that might be in the close path.
        //

        NtfsLockFcb( NULL, Fcb );
        SetFlag( Ccb->Flags, CCB_FLAG_CLOSE );
        NtfsUnlockFcb( NULL, Fcb );
        ASSERT( FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE ));
    }

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );
    IsSystemFile = FlagOn(Fcb->FcbState, FCB_STATE_PAGING_FILE) || (TypeOfOpen == StreamFileOpen);
    IsReadOnly = (BOOLEAN)IsFileObjectReadOnly( FileObject );

    do {

        try {

            //
            //  Jam Wait to FALSE when we create the IrpContext, to avoid
            //  deadlocks when coming in from cleanup.
            //

            if (IrpContext == NULL) {

                //
                //  Allocate and initialize the Irp.
                //

                NtfsInitializeIrpContext( Irp, FALSE, &IrpContext );

                //
                //  Set the level structure on the stack.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

                //
                //  If this is a top level request and we are not in the
                //  system process, then we can wait.  If it is a top level
                //  request and we are in the system process then we would
                //  rather not block this thread at all.  If the number of pending
                //  async closes is not too large we will post this immediately.
                //

                if (NtfsIsTopLevelRequest( IrpContext )) {

                    if (PsGetCurrentProcess() != NtfsData.OurProcess) {

                        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

                    //
                    //  This close is within the system process.  It could be
                    //  the segment derefernce thread.  We want to be careful
                    //  about processing the close in this thread.  If we
                    //  process the close too slowly we can eventually
                    //  cause a large backlog of file objects within
                    //  MM.  We will consider posting under the following conditions.
                    //
                    //      - There are more that four times as many file objects as handles (AND)
                    //      - The number of excess file objects (CloseCount - CleanupCount) is
                    //          over our async post threshold for this size system.
                    //

                    } else {

                        NtfsAsyncPassCount += 1;

                        if (FlagOn( NtfsAsyncPassCount, 3 ) &&
                            (Vcb->CleanupCount * 4 < Vcb->CloseCount) &&
                            (Vcb->CloseCount - Vcb->CleanupCount > NtfsAsyncPostThreshold + NtfsMaxDelayedCloseCount)) {

                            Status = STATUS_PENDING;
                            break;
                        }
                    }

                //
                //  This is a recursive Ntfs call.  Post this unless we already
                //  own this file.  Otherwise we could deadlock walking
                //  up the tree. Also if there was any error in the top level post it to
                //  preserve stack
                //

                } else if (!NtfsIsExclusiveScb( Scb ) ||
                           (IrpContext->TopLevelIrpContext->ExceptionStatus != STATUS_SUCCESS )) {

                    Status = STATUS_PENDING;
                    break;
                }

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );
            }

            //
            //  If this Scb should go on the delayed close queue then
            //  status is STATUS_PENDING;
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_DELAY_CLOSE ) &&
                (Scb->Fcb->DelayedCloseCount == 0)) {

                Status = STATUS_PENDING;

            } else {

                Status = NtfsCommonClose( IrpContext,
                                          Scb,
                                          Fcb,
                                          Vcb,
                                          &Ccb,
                                          TypeOfOpen,
                                          IsReadOnly,
                                          FALSE );
            }

            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  exception code.
            //

            if (IrpContext == NULL) {

                //
                //  We could've hit insufficient resources in trying to allocate
                //  the IrpContext. Make sure we don't leave a reference
                //  hanging around in this case. ProcessException will complete
                //  the IRP for us.
                //

                PLCB Lcb;

                ASSERT( GetExceptionCode() == STATUS_INSUFFICIENT_RESOURCES );

                if (Ccb != NULL) {

                    Lcb = Ccb->Lcb;
                    NtfsUnlinkCcbFromLcb( NULL, Ccb );
                    NtfsDeleteCcb( Fcb, &Ccb );

                } else {

                    Lcb = NULL;
                }

                NtfsDecrementCloseCounts( NULL,
                                       Scb,
                                       Lcb,
                                       IsSystemFile,
                                       IsReadOnly,
                                       TRUE );
            }

            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

        ASSERT( NT_SUCCESS( Status ) || (IrpContext == NULL) || IsListEmpty(&IrpContext->ExclusiveFcbList) );

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    //
    //  Io believes that it needs to free the FileObject->FileName.Buffer ONLY
    //  if FileObject->FileName.Length != 0.  Ntfs hides the attribute name
    //  between FileObject->FileName.Length and FileObject->Filename.MaximumLength
    //  and for a attribute-name-open relative to a file opened by Id, the Length
    //  field will be zero.  This, alas, causes Io to leak names.  So...
    //
    //  If we have a buffer allocated, make sure that the length is not zero when
    //  Io gets to see it.
    //

    if (FileObject->FileName.Buffer != NULL) {

        FileObject->FileName.Length = 1;
    }

    //
    //  Trigger an assert on any unexpected cases.
    //

    ASSERT( (Status == STATUS_SUCCESS) || (Status == STATUS_PENDING) ||
             (Status == STATUS_INSUFFICIENT_RESOURCES) );

    //
    //  Post the request to the close queue on PENDING.
    //

    if (Status == STATUS_PENDING) {

        BOOLEAN DelayCloseQueue = FALSE;

        //
        //  If the status is can't wait, then let's get the information we
        //  need into the IrpContext, complete the request,
        //  and post the IrpContext.
        //

        //
        //  Restore the thread context pointer if associated with this IrpContext.
        //

        if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL )) {

            NtfsRestoreTopLevelIrp();
            ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL );
        }

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        Status = STATUS_SUCCESS;

        IrpContext->OriginatingIrp = (PIRP) Scb;
        IrpContext->Union.SubjectContext = (PSECURITY_SUBJECT_CONTEXT) Ccb;
        IrpContext->TransactionId = (TRANSACTION_ID) TypeOfOpen;

        //
        //  At this point the file is effectively readonly - by changing it
        //  here we remove a race with implict locking through volume opens and
        //  the async close queue. Note: we have NO synchroniation here other
        //  than the interlocked operation. The vcb will not go away until
        //  this close is done
        //  

        if (Ccb != NULL)  {

            if (!IsFileObjectReadOnly( FileObject )) {
                FileObject->WriteAccess = 0;
                FileObject->DeleteAccess = 0;
                InterlockedIncrement( &Vcb->ReadOnlyCloseCount );
            }
            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_READ_ONLY_FO );
        
        } else {

            //
            //  System files should never be read-only. There will be 
            //  a ccb for all user fileobjects. Internal fileobjects are
            //  also always marked as system
            //  

            ASSERT( !IsFileObjectReadOnly( FileObject ));
        }

        //
        //  Decide which close queue this will go on.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_DELAY_CLOSE )) {

            NtfsAcquireFsrtlHeader( Scb );
            ClearFlag( Scb->ScbState, SCB_STATE_DELAY_CLOSE );
            NtfsReleaseFsrtlHeader( Scb );

            if (Scb->Fcb->DelayedCloseCount == 0) {

                DelayCloseQueue = TRUE;
            }
        }

        NtfsQueueClose( IrpContext, DelayCloseQueue );

    //
    //  Succeed in all other cases.
    //

    } else {

        if (Status == STATUS_SUCCESS) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        }

        //
        //  INSUFFICIENT_RESOURCES is the only other status that
        //  we can hit at this point. We would've completed the IRP in
        //  the except clause above in this case, so don't try doing it again.
        //

        ASSERT( Status == STATUS_SUCCESS || Status == STATUS_INSUFFICIENT_RESOURCES );
    }

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdClose -> %08lx\n", Status) );

    return Status;
}


VOID
NtfsFspClose (
    IN PVCB ThisVcb OPTIONAL
    )

/*++

Routine Description:

    This routine implements the FSP part of Close.

Arguments:

    ThisVcb - If specified then we want to remove all closes for a given Vcb.
        Otherwise this routine will close all of the async closes and as many
        of the delayed closes as possible.

Return Value:

    None.

--*/

{
    PIRP_CONTEXT IrpContext;
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    TYPE_OF_OPEN TypeOfOpen;
    PSCB Scb;
    PCCB Ccb;
    BOOLEAN ReadOnly;

    NTSTATUS Status = STATUS_SUCCESS;

    PVCB CurrentVcb = NULL;

    BOOLEAN ThrottleCreate = FALSE;
    ULONG ClosedCount = 0;

    DebugTrace( +1, Dbg, ("NtfsFspClose\n") );

    PAGED_CODE();

    FsRtlEnterFileSystem();

    //
    //  Occasionally we are called from some other routine to try to
    //  reduce the backlog of closes.  This is indicated by a pointer
    //  value of 1.
    //

    if (ThisVcb == (PVCB) 1) {

        ThisVcb = NULL;
        ThrottleCreate = TRUE;
    }

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, FALSE );
    ASSERT( ThreadTopLevelContext == &TopLevelContext );

    //
    //  Extract and decode the file object, we are willing to handle the unmounted
    //  file object.  Note we normally get here via an IrpContext which really
    //  just points to a file object.  We should never see an Irp, unless it can
    //  happen for verify or some other reason.
    //

    while (IrpContext = NtfsRemoveClose( ThisVcb, ThrottleCreate )) {

        ASSERT_IRP_CONTEXT( IrpContext );

        //
        //  Recover the information about the file object being closed from
        //  the data stored in the IrpContext.  The following fields are
        //  used for this.
        //
        //  OriginatingIrp - Contains the Scb
        //  SubjectContext - Contains the Ccb
        //  TransactionId - Contains the TypeOfOpen
        //  Flags - Has bit for read-only file.
        //

        Scb = (PSCB) IrpContext->OriginatingIrp;
        IrpContext->OriginatingIrp = NULL;

        Ccb = (PCCB) IrpContext->Union.SubjectContext;
        IrpContext->Union.SubjectContext = NULL;

        TypeOfOpen = (TYPE_OF_OPEN) IrpContext->TransactionId;
        IrpContext->TransactionId = 0;

        if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_READ_ONLY_FO )) {

            ReadOnly = TRUE;
            ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_READ_ONLY_FO );

        } else {

            ReadOnly = FALSE;
        }

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAGS_CLEAR_ON_POST );
        SetFlag( IrpContext->State,
                 IRP_CONTEXT_STATE_IN_FSP | IRP_CONTEXT_STATE_WAIT );

        //
        //  Loop for retryable errors.
        //

        Status = STATUS_SUCCESS;

        do {

            //
            //  Set the TopLevel structure.
            //

            NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            //
            //  Call the common Close routine.
            //

            try {

                //
                //  Do logfile full checkpointing
                //

                if (Status == STATUS_LOG_FILE_FULL) {
                    NtfsCheckpointForLogFileFull( IrpContext );
                }

                CurrentVcb = IrpContext->Vcb;

                Status = NtfsCommonClose( IrpContext,
                                          Scb,
                                          Scb->Fcb,
                                          IrpContext->Vcb,
                                          &Ccb,
                                          TypeOfOpen,
                                          ReadOnly,
                                          TRUE );

                ASSERT(Status == STATUS_SUCCESS);

            } except( NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

                Status = NtfsProcessException( IrpContext, NULL, GetExceptionCode() );
            }

            ASSERT( NT_SUCCESS(Status) || IsListEmpty(&IrpContext->ExclusiveFcbList) );

            //
            //  If we got a log file full, and our caller may have something
            //  acquired, then clean up and raise again.
            //

            if (((Status == STATUS_LOG_FILE_FULL) ||
                 (Status == STATUS_CANT_WAIT)) &&
                 ARGUMENT_PRESENT( ThisVcb )) {

                //
                //  If the status is can't wait, then let's get the information we
                //  need into the IrpContext, complete the request,
                //  and post the IrpContext.
                //

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE );
                NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

                //
                //  Restore the information on the file object being closed.
                //

                IrpContext->OriginatingIrp = (PIRP)Scb;
                IrpContext->Union.SubjectContext = (PVOID)Ccb;
                IrpContext->TransactionId = TypeOfOpen;
                if (ReadOnly) {
                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_READ_ONLY_FO );
                }

                //
                //  Now queue the close as an async close and get out.
                //

                if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL )) {

                    NtfsRestoreTopLevelIrp();
                    ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL );
                }

                NtfsQueueClose( IrpContext, FALSE );

                FsRtlExitFileSystem();
                ExRaiseStatus( Status );
            }

        } while ((Status == STATUS_LOG_FILE_FULL) || (Status == STATUS_CANT_WAIT));

        //
        //  No more for us to do.  Clean up the IrpContext in any case.
        //

        NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

        //
        //  If we were just throttling creates and we made our last pass
        //  then exit.
        //

        if (ThrottleCreate) {
            break;
        }
    }


    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFspClose -> NULL\n") );

    return;
}


BOOLEAN
NtfsAddScbToFspClose (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN DelayClose
    )

/*++

Routine Description:

    This routine is called to add an entry for the current Scb onto one
    of the Fsp close queues.  This is used when we want to guarantee that
    a teardown will be called on an Scb or Fcb when the current operation
    can't begin the operation.

Arguments:

    Scb - Scb to add to the queue.

    DelayClose - Indicates which queue this should go into.

Return Value:

    BOOLEAN - Indicates whether or not the SCB was added to the delayed
        close queue

--*/

{
    PIRP_CONTEXT NewIrpContext = NULL;
    BOOLEAN Result = TRUE;

    PAGED_CODE();

    //
    //  Use a try-except to catch any allocation failures.  The only valid
    //  error here is an allocation failure for the new irp context.
    //

    try {

        NtfsInitializeIrpContext( NULL, TRUE, &NewIrpContext );

        //
        //  Set the necessary fields to post this to the workqueue.
        //

        NewIrpContext->Vcb = Scb->Vcb;
        NewIrpContext->MajorFunction = IRP_MJ_CLOSE;

        NewIrpContext->OriginatingIrp = (PIRP) Scb;
        NewIrpContext->TransactionId = (TRANSACTION_ID) StreamFileOpen;

        //
        //  Now increment the close counts for this Scb.
        //

        NtfsIncrementCloseCounts( Scb, TRUE, FALSE );

        //
        //  Move the Scb to the end of the Fcb queue.  We don't want to
        //  keep other Scb's from being deleted because this one is on
        //  the delayed close queue.
        //

        if (Scb->FcbLinks.Flink != &Scb->Fcb->ScbQueue) {

            NtfsLockFcb( IrpContext, Scb->Fcb );
            RemoveEntryList( &Scb->FcbLinks );
            InsertTailList( &Scb->Fcb->ScbQueue, &Scb->FcbLinks );
            ASSERT( Scb->FcbLinks.Flink == &Scb->Fcb->ScbQueue );
            NtfsUnlockFcb( IrpContext, Scb->Fcb );
        }

        //
        //  Now add this to the correct queue.
        //

        NtfsQueueClose( NewIrpContext, DelayClose );

    } except( FsRtlIsNtstatusExpected( GetExceptionCode() ) ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH ) {

        NtfsMinimumExceptionProcessing( IrpContext );
        Result = FALSE;
    }

    return Result;

    UNREFERENCED_PARAMETER( IrpContext );
}


//
//  Internal support routine
//

NTSTATUS
NtfsCommonClose (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN PCCB *Ccb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN BOOLEAN ReadOnly,
    IN BOOLEAN CalledFromFsp
    )

/*++

Routine Description:

    This is the common routine for Close called by both the fsd and fsp
    threads.  Key for this routine is how to acquire the Vcb and whether to
    leave the Vcb acquired on exit.

Arguments:

    Scb - Scb for this stream.

    Fcb - Fcb for this stream.

    Vcb - Vcb for this volume.

    Ccb - User's Ccb for user files.

    TypeOfOpen - Indicates the type of open for this stream.

    ReadOnly - Indicates if the file object was for read-only access.

    CalledFromFsp - Indicates whether this function was called from NtfsFspClose.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    BOOLEAN ExclusiveVcb = FALSE;
    BOOLEAN AcquiredFcb = FALSE;

    BOOLEAN SystemFile;
    BOOLEAN RemovedFcb = FALSE;
    ULONG AcquireFlags = ACQUIRE_NO_DELETE_CHECK | ACQUIRE_HOLD_BITMAP;
    BOOLEAN NeedVcbExclusive = FALSE;
    BOOLEAN WriteFileSize;

    NTSTATUS Status = STATUS_SUCCESS;

    PLCB Lcb;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    //
    //  Get the current Irp stack location
    //

    DebugTrace( +1, Dbg, ("NtfsCommonClose\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        SetFlag( AcquireFlags, ACQUIRE_DONT_WAIT );
    }

    //
    //  Loop here to acquire both the Vcb and Fcb.  We want to acquire
    //  the Vcb exclusively if the file has multiple links.
    //

    while (TRUE) {

        WriteFileSize = FALSE;

        //
        //  Perform an unsafe test and optimistically acquire Vcb.
        //

        if (NeedVcbExclusive ||
            (Fcb->LcbQueue.Flink != Fcb->LcbQueue.Blink) ||
            FlagOn( Vcb->VcbState, VCB_STATE_PERFORMED_DISMOUNT )) {

            if (!NtfsAcquireExclusiveVcb( IrpContext, Vcb, FALSE )) {
                return STATUS_PENDING;
            }
            ExclusiveVcb = TRUE;

        } else {

            if (!NtfsAcquireSharedVcb( IrpContext, Vcb, FALSE )) {
                return STATUS_PENDING;
            }
        }

        //
        //  Now try to acquire the Fcb.  If we are unable to acquire it then
        //  release the Vcb and return.  This can only be from the Fsd path
        //  since otherwise Wait will be TRUE.
        //

        if (!NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, AcquireFlags )) {

            //
            //  Always release the Vcb.  This can only be from the Fsd thread.
            //

            NtfsReleaseVcb( IrpContext, Vcb );
            return STATUS_PENDING;
        }
        AcquiredFcb = TRUE;

        //
        //  Recheck scbstate now that we own the fcb exclusive to see if we need
        //  to write the filesize at this point
        //

        if ((!FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) &&
            (!FlagOn( Vcb->VcbState, VCB_STATE_LOCKED )) &&
            (FlagOn( Scb->ScbState, SCB_STATE_WRITE_FILESIZE_ON_CLOSE )) &&
            (Fcb->LinkCount > 0) &&
            (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED ))) {

            WriteFileSize = TRUE;
            NtfsReleaseFcb( IrpContext, Fcb );
            AcquiredFcb = FALSE;

            //
            //  NtfsAcquireWithPaging only  gets the paging if the irpcontext
            //  flag is set. Also it assumes no delete check which we explictly
            //  want here anyway.
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
            if (!NtfsAcquireFcbWithPaging( IrpContext, Fcb, AcquireFlags )) {

                NtfsReleaseVcb( IrpContext, Vcb );
                return STATUS_PENDING;
            }
            AcquiredFcb = TRUE;

            //
            //  Recapture whether we need to write file size since dropping
            //

            if ((!FlagOn( Scb->ScbState, SCB_STATE_WRITE_FILESIZE_ON_CLOSE )) ||
                (Fcb->LinkCount == 0) ||
                (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED ))) {

                WriteFileSize = FALSE;
            }
        }

        if (ExclusiveVcb) {
            break;
        }

        //
        //  Otherwise we need to confirm that our unsafe test above was correct.
        //

        if ((Fcb->LcbQueue.Flink != Fcb->LcbQueue.Blink) ||
            FlagOn( Vcb->VcbState, VCB_STATE_PERFORMED_DISMOUNT )) {

            NeedVcbExclusive = TRUE;
            NtfsReleaseFcb( IrpContext, Fcb );
            NtfsReleaseVcb( IrpContext, Vcb );
            AcquiredFcb = FALSE;

        } else {

            break;
        }
    }

    //
    //  Set the wait flag in the IrpContext so we can acquire any other files
    //  we encounter.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    try {

        //
        //  See if we possibly have to do any Usn processing
        //

        if (Fcb->FcbUsnRecord != NULL) {

            //
            //  If the file has no more user handles, but there is a pending Usn
            //  update (this should normally only happen if a stream was mapped
            //  by the user), then scan the streams to see if there are any
            //  remaining datasections, and if not then post the close.
            //

            if ((Fcb->CleanupCount == 0) &&
                (Fcb->FcbUsnRecord->UsnRecord.Reason != 0)) {

                if (!FlagOn( Vcb->VcbState, VCB_STATE_LOCKED ) &&
                    !FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED ) &&
                    !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_FAILED_CLOSE )) {

                    PSCB TempScb;

                    //
                    //  Leave if there are any streams with user-mapped files.
                    //

                    TempScb = (PSCB)CONTAINING_RECORD( Fcb->ScbQueue.Flink,
                                                       SCB,
                                                       FcbLinks );

                    while (&TempScb->FcbLinks != &Fcb->ScbQueue) {

                        if ((TempScb->NonpagedScb->SegmentObject.DataSectionObject != NULL) &&
                            !MmCanFileBeTruncated( &TempScb->NonpagedScb->SegmentObject, &Li0)) {
                            goto NoPost;
                        }

                        TempScb = (PSCB)CONTAINING_RECORD( TempScb->FcbLinks.Flink,
                                                           SCB,
                                                           FcbLinks );
                    }

                    //
                    //  If we are not supposed to wait, then we should force this request to
                    //  be posted. All recursive closes will go here since they are async
                    //

                    if (FlagOn( AcquireFlags, ACQUIRE_DONT_WAIT )) {
                        Status = STATUS_PENDING;
                        leave;
                    }

                    //
                    //  We cannot generate logfile fulls in a regular thread with a recursive close
                    //  safely without deadlocking
                    //

                    ASSERT( NtfsIsTopLevelRequest( IrpContext ) ||
                            FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ) );

                    //
                    //  Protect the call to the Usn routines with a try-except.  If we hit
                    //  any non-fatal error then set the IrpContext flag which indicates
                    //  not to bother with the Usn and force a retry.
                    //

                    try {

                        //
                        //  Now try to actually post the change.
                        //

                        NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_CLOSE );

                        //
                        //  Now write the journal, checkpoint the transaction, and free the UsnJournal to
                        //  reduce contention.  We force the write now, because the Fcb may get deleted
                        //  before we normally would write the changes when the transaction commits.
                        //

                        NtfsWriteUsnJournalChanges( IrpContext );
                        NtfsCheckpointCurrentTransaction( IrpContext );

                    } except( (!FsRtlIsNtstatusExpected( Status = GetExceptionCode() ) ||
                               (Status == STATUS_LOG_FILE_FULL) ||
                               (Status == STATUS_CANT_WAIT)) ?
                              EXCEPTION_CONTINUE_SEARCH :
                              EXCEPTION_EXECUTE_HANDLER ) {

                        //
                        //  We got some sort of error processing the Usn journal.  We can't
                        //  handle it in the close path.  Let's retry this request but don't
                        //  try to do the Usn operation.
                        //

                        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_FAILED_CLOSE );
                        IrpContext->ExceptionStatus = STATUS_SUCCESS;
                        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                    }

                    //
                    //  Free any remaining resources before decrementing close counts below,
                    //  except for our Fcb.  This reduces contention via the Usn Journal and
                    //  prevents deadlocks since the Usn Journal is acquired last.
                    //

                    ASSERT(Fcb->ExclusiveFcbLinks.Flink != NULL);
                    while (!IsListEmpty(&IrpContext->ExclusiveFcbList)) {

                        if (&Fcb->ExclusiveFcbLinks == IrpContext->ExclusiveFcbList.Flink) {

                            RemoveEntryList( &Fcb->ExclusiveFcbLinks );
                            Fcb->ExclusiveFcbLinks.Flink = NULL;

                        } else {

                            NtfsReleaseFcb( IrpContext,
                                            (PFCB)CONTAINING_RECORD(IrpContext->ExclusiveFcbList.Flink,
                                                                    FCB,
                                                                    ExclusiveFcbLinks ));
                        }
                    }
                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                                  IRP_CONTEXT_FLAG_RELEASE_MFT );

                    //
                    //  Now reinsert our Fcb if we removed it from the list.  Check the Flink
                    //  field to know if this is the case.  Otherwise a higher level IrpContext
                    //  will own this.
                    //

                    if (Fcb->ExclusiveFcbLinks.Flink == NULL) {

                        InsertTailList( &IrpContext->ExclusiveFcbList, &Fcb->ExclusiveFcbLinks );
                    }

                    //
                    //  Escape here if we are not posting the close due to a user-mapped file.
                    //

                NoPost: NOTHING;
                }
            }
        }

        //
        //  Now rewrite the filesizes if we have to
        //

        if (WriteFileSize) {

            ASSERT( IrpContext->CleanupStructure != NULL );

            //
            //  If the call to write the file size or the commit  produces a logfile full
            //  we must retry in the fsp thread  to prevent deadlocking from
            //  a recursive caller's already owning the vcb and an attempt to
            //  checkpoint
            //

            try {

                NtfsWriteFileSizes( IrpContext, Scb, &Scb->Header.ValidDataLength.QuadPart, TRUE, TRUE, FALSE );
                NtfsCheckpointCurrentTransaction( IrpContext );
                ClearFlag( Scb->ScbState, SCB_STATE_WRITE_FILESIZE_ON_CLOSE );

            } except( (Status = GetExceptionCode()), (Status != STATUS_LOG_FILE_FULL || FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP )) ?
                      EXCEPTION_CONTINUE_SEARCH :
                      EXCEPTION_EXECUTE_HANDLER ) {

                NtfsMinimumExceptionProcessing( IrpContext );
                Status = STATUS_PENDING;
            }

            if (Status == STATUS_PENDING) {
                leave;
            }

        }  //  endif writing filesize

        //
        //  We take the same action for all open files.  We
        //  delete the Ccb if present, and we decrement the close
        //  file counts.
        //

        if ((*Ccb) != NULL) {

            Lcb = (*Ccb)->Lcb;
            NtfsUnlinkCcbFromLcb( IrpContext, (*Ccb) );
            NtfsDeleteCcb( Fcb, Ccb );

        } else {

            Lcb = NULL;
        }

        SystemFile = FlagOn(Fcb->FcbState, FCB_STATE_PAGING_FILE) || (TypeOfOpen == StreamFileOpen);
        RemovedFcb = NtfsDecrementCloseCounts( IrpContext,
                                               Scb,
                                               Lcb,
                                               SystemFile,
                                               ReadOnly,
                                               FALSE );

        //
        //  Now that we're holding the Vcb, and we're past the point where we might
        //  raise log file full, we can safely adjust this field.
        //

        if (CalledFromFsp) {

            InterlockedDecrement( &Vcb->QueuedCloseCount );
        }

        //
        //  If we had to write a log record for close, it can only be for duplicate
        //  information.  We will commit that transaction here and remove
        //  the entry from the transaction table.  We do it here so we won't
        //  fail inside the 'except' of a 'try-except'.
        //

        if (IrpContext->TransactionId != 0) {

            try {

                NtfsCommitCurrentTransaction( IrpContext );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                NtfsMinimumExceptionProcessing( IrpContext );
                if (IrpContext->TransactionId != 0) {

                    NtfsCleanupFailedTransaction( IrpContext );
                }
            }
        }

    } finally {

        DebugUnwind( NtfsCommonClose );

        //
        //  Manage fcb explictly because we recursively come into this path
        //  and its cleaner to release the fcb at the same level in which you acquire it
        //

        if (AcquiredFcb && !RemovedFcb) {
            NtfsReleaseFcb( IrpContext, Fcb );
        }

        if (ExclusiveVcb) {
            NtfsReleaseVcbCheckDelete( IrpContext, Vcb, IRP_MJ_CLOSE, NULL );
        } else {
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        DebugTrace( -1, Dbg, ("NtfsCommonClose -> returning\n") );
    }

    return Status;
}


//
//  Internal support routine, spinlock wrapper.
//

VOID
NtfsQueueClose (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN DelayClose
    )
{
    KIRQL SavedIrql;
    BOOLEAN StartWorker = FALSE;

    InterlockedIncrement( &(IrpContext->Vcb->QueuedCloseCount) );

    if (DelayClose) {

        //
        //  Increment the delayed close count for the Fcb for this
        //  file.
        //

        InterlockedIncrement( &((PSCB) IrpContext->OriginatingIrp)->Fcb->DelayedCloseCount );

        SavedIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );

        InsertTailList( &NtfsData.DelayedCloseList,
                        &IrpContext->WorkQueueItem.List );

        NtfsData.DelayedCloseCount += 1;

        if (NtfsData.DelayedCloseCount > NtfsMaxDelayedCloseCount) {

            NtfsData.ReduceDelayedClose = TRUE;

            if (!NtfsData.AsyncCloseActive) {

                NtfsData.AsyncCloseActive = TRUE;
                StartWorker = TRUE;
            }
        }

    } else {

        SavedIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );

        InsertTailList( &NtfsData.AsyncCloseList,
                        &IrpContext->WorkQueueItem.List );

        NtfsData.AsyncCloseCount += 1;

        if (!NtfsData.AsyncCloseActive) {

            NtfsData.AsyncCloseActive = TRUE;

            StartWorker = TRUE;
        }
    }

    KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, SavedIrql );

    if (StartWorker) {

        ExQueueWorkItem( &NtfsData.NtfsCloseItem, CriticalWorkQueue );
    }
}


//
//  Internal support routine, spinlock wrapper.
//

PIRP_CONTEXT
NtfsRemoveClose (
    IN PVCB Vcb OPTIONAL,
    IN BOOLEAN ThrottleCreate
    )
{

    PLIST_ENTRY Entry;
    KIRQL SavedIrql;
    PIRP_CONTEXT IrpContext = NULL;
    BOOLEAN FromDelayedClose = FALSE;

    SavedIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );

    //
    //  First check the list of async closes.
    //

    if (!IsListEmpty( &NtfsData.AsyncCloseList )) {

        Entry = NtfsData.AsyncCloseList.Flink;

        while (Entry != &NtfsData.AsyncCloseList) {

            //
            //  Extract the IrpContext.
            //

            IrpContext = CONTAINING_RECORD( Entry,
                                            IRP_CONTEXT,
                                            WorkQueueItem.List );

            //
            //  If no Vcb was specified or this Vcb is for our volume
            //  then perform the close.
            //

            if (!ARGUMENT_PRESENT( Vcb ) ||
                IrpContext->Vcb == Vcb) {

                RemoveEntryList( Entry );
                NtfsData.AsyncCloseCount -= 1;

                break;

            } else {

                IrpContext = NULL;
                Entry = Entry->Flink;
            }
        }
    }

    //
    //  If we didn't find anything look through the delayed close
    //  queue.
    //

    if (IrpContext == NULL) {

        //
        //  Now check our delayed close list.
        //

        if (ARGUMENT_PRESENT( Vcb )) {

            Entry = NtfsData.DelayedCloseList.Flink;
            IrpContext = NULL;

            //
            //  If we were given a Vcb, only do the closes for this volume.
            //

            while (Entry != &NtfsData.DelayedCloseList) {

                //
                //  Extract the IrpContext.
                //

                IrpContext = CONTAINING_RECORD( Entry,
                                                IRP_CONTEXT,
                                                WorkQueueItem.List );

                //
                //  Is this close on our volume?
                //

                if (IrpContext->Vcb == Vcb) {

                    RemoveEntryList( Entry );
                    NtfsData.DelayedCloseCount -= 1;
                    FromDelayedClose = TRUE;
                    break;

                } else {

                    IrpContext = NULL;
                    Entry = Entry->Flink;
                }
            }

        //
        //  Check if need to reduce the delayed close count.
        //

        } else if (NtfsData.ReduceDelayedClose) {

            if (NtfsData.DelayedCloseCount > NtfsMinDelayedCloseCount) {

                //
                //  Do any closes over the limit.
                //

                Entry = RemoveHeadList( &NtfsData.DelayedCloseList );

                NtfsData.DelayedCloseCount -= 1;

                //
                //  Extract the IrpContext.
                //

                IrpContext = CONTAINING_RECORD( Entry,
                                                IRP_CONTEXT,
                                                WorkQueueItem.List );
                FromDelayedClose = TRUE;

            } else {

                NtfsData.ReduceDelayedClose = FALSE;
            }

#if (DBG || defined( NTFS_FREE_ASSERTS ))
        } else {

            ASSERT( NtfsData.DelayedCloseCount <= NtfsMaxDelayedCloseCount );
#endif
        }
    }

    //
    //  If this is the delayed close case then decrement the delayed close count
    //  on this Fcb.
    //

    if (FromDelayedClose) {

        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, SavedIrql );

        InterlockedDecrement( &((PSCB) IrpContext->OriginatingIrp)->Fcb->DelayedCloseCount );

    //
    //  If we are returning NULL, show that we are done.
    //

    } else {

        if (!ARGUMENT_PRESENT( Vcb ) &&
            (IrpContext == NULL) &&
            !ThrottleCreate) {

            NtfsData.AsyncCloseActive = FALSE;
        }

        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, SavedIrql );
    }

    ASSERT( (Vcb == NULL) || NtfsIsExclusiveVcb( Vcb ) || (IrpContext == NULL) );
    return IrpContext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\dirctrl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    DirCtrl.c

Abstract:

    This module implements the File Directory Control routine for Ntfs called
    by the dispatch driver.

Author:

    Tom Miller      [TomM]          1-Jan-1992

        (Based heavily on GaryKi's dirctrl.c for pinball.)

Revision History:

--*/

#include "NtfsProc.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DIRCTRL)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('dFtN')

NTSTATUS
NtfsQueryDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb
    );

NTSTATUS
NtfsNotifyChangeDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonDirectoryControl)
#pragma alloc_text(PAGE, NtfsFsdDirectoryControl)
#pragma alloc_text(PAGE, NtfsNotifyChangeDirectory)
#pragma alloc_text(PAGE, NtfsReportViewIndexNotify)
#pragma alloc_text(PAGE, NtfsQueryDirectory)
#endif


NTSTATUS
NtfsFsdDirectoryControl (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of Directory Control.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext = NULL;
    IRP_CONTEXT LocalIrpContext;

    BOOLEAN Wait;

    ASSERT_IRP( Irp );

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFsdDirectoryControl\n") );

    //
    //  Call the common Directory Control routine
    //

    FsRtlEnterFileSystem();

    //
    //  Always make these requests look top level.
    //

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, TRUE );

    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {

                //
                //  Allocate and initialize the IrpContext.
                //

                Wait = FALSE;
                if (CanFsdWait( Irp )) {

                    Wait = TRUE;
                    IrpContext = &LocalIrpContext;
                }

                NtfsInitializeIrpContext( Irp, Wait, &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );
            }

            Status = NtfsCommonDirectoryControl( IrpContext, Irp );
            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code
            //

            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdDirectoryControl -> %08lx\n", Status) );

    return Status;
}


NTSTATUS
NtfsCommonDirectoryControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Directory Control called by both the fsd
    and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PSCB Scb;
    PCCB Ccb;
    PFCB Fcb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonDirectoryControl\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  We know this is a directory control so we'll case on the
    //  minor function, and call an internal worker routine to complete
    //  the irp.
    //

    switch ( IrpSp->MinorFunction ) {

    case IRP_MN_QUERY_DIRECTORY:

        //
        //  Decide if this is a view or filename index.
        //

        if ((UserViewIndexOpen == TypeOfOpen) &&
            FlagOn( Scb->ScbState, SCB_STATE_VIEW_INDEX )) {

            Status = NtfsQueryViewIndex( IrpContext, Irp, Vcb, Scb, Ccb );

        } else if ((UserDirectoryOpen == TypeOfOpen) &&
                   !FlagOn( Scb->ScbState, SCB_STATE_VIEW_INDEX )) {

            Status = NtfsQueryDirectory( IrpContext, Irp, Vcb, Scb, Ccb );

        } else {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

            DebugTrace( -1, Dbg, ("NtfsCommonDirectoryControl -> STATUS_INVALID_PARAMETER\n") );
            return STATUS_INVALID_PARAMETER;
        }

        break;

    case IRP_MN_NOTIFY_CHANGE_DIRECTORY:

        //
        //  We can't perform this operation on open by Id or if the caller has
        //  closed his handle.  Make sure the handle is for either a view index
        //  or file name index.
        //

        if (((TypeOfOpen != UserDirectoryOpen) &&
             (TypeOfOpen != UserViewIndexOpen)) ||
            FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID ) ||
            FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE )) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

            DebugTrace( -1, Dbg, ("NtfsCommonDirectoryControl -> STATUS_INVALID_PARAMETER\n") );
            return STATUS_INVALID_PARAMETER;
        }

        Status = NtfsNotifyChangeDirectory( IrpContext, Irp, Vcb, Scb, Ccb );
        break;

    default:

        DebugTrace( 0, Dbg, ("Invalid Minor Function %08lx\n", IrpSp->MinorFunction) );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );

        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsCommonDirectoryControl -> %08lx\n", Status) );

    return Status;
}


VOID
NtfsReportViewIndexNotify (
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN ULONG FilterMatch,
    IN ULONG Action,
    IN PVOID ChangeInfoBuffer,
    IN USHORT ChangeInfoBufferLength
    )

/*++

Routine Description:

    This function notifies processes that there has been a change to a
    view index they are watching.  It is analogous to the NtfsReportDirNotify
    macro, which is used only for directories, while this function is used
    only for view indices.

Arguments:

    Vcb - The volume on which the change is taking place.

    Fcb - The file on which the change is taking place.

    FilterMatch  -  This flag field is compared with the completion filter
        in the notify structure.  If any of the corresponding bits in the
        completion filter are set, then a notify condition exists.

    Action  -  This is the action code to store in the user's buffer if
        present.

    ChangeInfoBuffer - Pointer to a buffer of information related to the
        change being reported.  This information is returned to the
        process that owns the notify handle.

    ChangeInfoBufferLength - The length, in bytes, of the buffer passed
        in ChangeInfoBuffer.


Return Value:

    None.

--*/

{
    STRING ChangeInfo;

    PAGED_CODE( );

    ChangeInfo.Length = ChangeInfo.MaximumLength = ChangeInfoBufferLength;
    ChangeInfo.Buffer = ChangeInfoBuffer;

    FsRtlNotifyFilterReportChange( Vcb->NotifySync,
                                   &Vcb->ViewIndexNotifyList,
                                   NULL,
                                   0,
                                   &ChangeInfo,
                                   &ChangeInfo,
                                   FilterMatch,
                                   Action,
                                   Fcb,
                                   NULL );
}


//
//  Local Support Routine
//

NTSTATUS
NtfsQueryDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the query directory operation.  It is responsible
    for either completing or enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

    Vcb - Supplies its Vcb

    Scb - Supplies its Scb

    Ccb - Supplies its Ccb

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;

    PUCHAR Buffer;
    CLONG UserBufferLength;

    ULONG BaseLength;

    PUNICODE_STRING UniFileName;
    FILE_INFORMATION_CLASS FileInformationClass;
    ULONG FileIndex;
    BOOLEAN RestartScan;
    BOOLEAN ReturnSingleEntry;
    BOOLEAN IndexSpecified;
    BOOLEAN AccessingUserBuffer = FALSE;

    BOOLEAN IgnoreCase;

    BOOLEAN NextFlag;

    BOOLEAN GotEntry;

    BOOLEAN CallRestart;

    ULONG NextEntry;
    ULONG LastEntry;

    PFILE_DIRECTORY_INFORMATION DirInfo;
    PFILE_FULL_DIR_INFORMATION FullDirInfo;
    PFILE_BOTH_DIR_INFORMATION BothDirInfo;
    PFILE_NAMES_INFORMATION NamesInfo;

    PFILE_NAME FileNameBuffer;
    PVOID UnwindFileNameBuffer = NULL;
    ULONG FileNameLength;

    ULONG SizeOfFileName = FIELD_OFFSET( FILE_NAME, FileName );

    INDEX_CONTEXT OtherContext;

    PFCB AcquiredFcb = NULL;

    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN CcbAcquired = FALSE;

    BOOLEAN ScbAcquired = FALSE;
    BOOLEAN FirstQuery = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT_VCB( Vcb );
    ASSERT_CCB( Ccb );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    //
    //  Get the current Stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsQueryDirectory...\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, (" ->Length               = %08lx\n", IrpSp->Parameters.QueryDirectory.Length) );
    DebugTrace( 0, Dbg, (" ->FileName             = %08lx\n", IrpSp->Parameters.QueryDirectory.FileName) );
    DebugTrace( 0, Dbg, (" ->FileInformationClass = %08lx\n", IrpSp->Parameters.QueryDirectory.FileInformationClass) );
    DebugTrace( 0, Dbg, (" ->FileIndex            = %08lx\n", IrpSp->Parameters.QueryDirectory.FileIndex) );
    DebugTrace( 0, Dbg, (" ->SystemBuffer         = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );
    DebugTrace( 0, Dbg, (" ->RestartScan          = %08lx\n", FlagOn(IrpSp->Flags, SL_RESTART_SCAN)) );
    DebugTrace( 0, Dbg, (" ->ReturnSingleEntry    = %08lx\n", FlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY)) );
    DebugTrace( 0, Dbg, (" ->IndexSpecified       = %08lx\n", FlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED)) );
    DebugTrace( 0, Dbg, ("Vcb        = %08lx\n", Vcb) );
    DebugTrace( 0, Dbg, ("Scb        = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Ccb        = %08lx\n", Ccb) );

#if DBG
    //
    //  Enable debug port displays when certain enumeration strings are given
    //

#if NTFSPOOLCHECK
    if (IrpSp->Parameters.QueryDirectory.FileName != NULL) {
        if (IrpSp->Parameters.QueryDirectory.FileName->Length >= 10 &&
            RtlEqualMemory( IrpSp->Parameters.QueryDirectory.FileName->Buffer, L"$HEAP", 10 )) {

            NtfsDebugHeapDump( (PUNICODE_STRING) IrpSp->Parameters.QueryDirectory.FileName );

        }
    }
#endif  //  NTFSPOOLCHECK
#endif  //  DBG

    //
    //  Because we probably need to do the I/O anyway we'll reject any request
    //  right now that cannot wait for I/O.  We do not want to abort after
    //  processing a few index entries.
    //

    if (!FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT)) {

        DebugTrace( 0, Dbg, ("Automatically enqueue Irp to Fsp\n") );

        Status = NtfsPostRequest( IrpContext, Irp );

        DebugTrace( -1, Dbg, ("NtfsQueryDirectory -> %08lx\n", Status) );
        return Status;
    }

    //
    //  Reference our input parameters to make things easier
    //

    UserBufferLength = IrpSp->Parameters.QueryDirectory.Length;

    FileInformationClass = IrpSp->Parameters.QueryDirectory.FileInformationClass;
    FileIndex = IrpSp->Parameters.QueryDirectory.FileIndex;

    //
    //  Look in the Ccb to see the type of search.
    //

    IgnoreCase = BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE );

    RestartScan = BooleanFlagOn(IrpSp->Flags, SL_RESTART_SCAN);
    ReturnSingleEntry = BooleanFlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY);
    IndexSpecified = BooleanFlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED);

    //
    //  Determine the size of the constant part of the structure.
    //

    switch (FileInformationClass) {

    case FileDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_DIRECTORY_INFORMATION,
                                   FileName[0] );
        break;

    case FileFullDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_FULL_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileIdFullDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_ID_FULL_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileNamesInformation:

        BaseLength = FIELD_OFFSET( FILE_NAMES_INFORMATION,
                                   FileName[0] );
        break;

    case FileBothDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileIdBothDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_ID_BOTH_DIR_INFORMATION,
                                   FileName[0] );
        break;

    default:

        Status = STATUS_INVALID_INFO_CLASS;
        NtfsCompleteRequest( IrpContext, Irp, Status );
        DebugTrace( -1, Dbg, ("NtfsQueryDirectory -> %08lx\n", Status) );
        return Status;
    }

    NtfsInitializeIndexContext( &OtherContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We only allow one active request in this handle at a time.  If this is
        //  not a synchronous request then wait on the handle.
        //

        if (!FlagOn( IrpSp->FileObject->Flags, FO_SYNCHRONOUS_IO )) {

            EOF_WAIT_BLOCK WaitBlock;
            NtfsAcquireIndexCcb( Scb, Ccb, &WaitBlock );
            CcbAcquired = TRUE;
        }

        //
        //  We have to create a File Name string for querying if there is either
        //  one specified in this request, or we do not already have a value
        //  in the Ccb.  If we already have one then we will ignore the input
        //  name in this case unless the INDEX_SPECIFIED bit is set.
        //

        if ((Ccb->QueryBuffer == NULL) ||
            ((IrpSp->Parameters.QueryDirectory.FileName != NULL) && IndexSpecified)) {

            //
            //  Now, if the input string is NULL, we have to create the default
            //  string "*".
            //

            if (IrpSp->Parameters.QueryDirectory.FileName == NULL) {

                FileNameLength = SizeOfFileName + sizeof(WCHAR);
                FileNameBuffer = NtfsAllocatePool(PagedPool, FileNameLength );

                //
                //  Initialize it.
                //

                FileNameBuffer->ParentDirectory = Scb->Fcb->FileReference;
                FileNameBuffer->FileNameLength = 1;
                FileNameBuffer->Flags = 0;
                FileNameBuffer->FileName[0] = '*';

            //
            //  We know we have an input file name, and we may or may not already
            //  have one in the Ccb.  Allocate space for it, initialize it, and
            //  set up to deallocate on the way out if we already have a pattern
            //  in the Ccb.
            //

            } else {

                UniFileName = (PUNICODE_STRING) IrpSp->Parameters.QueryDirectory.FileName;

                if (!NtfsIsFileNameValid(UniFileName, TRUE)) {

                    if (Ccb->QueryBuffer == NULL
                        || UniFileName->Length > 4
                        || UniFileName->Length == 0
                        || UniFileName->Buffer[0] != L'.'
                        || (UniFileName->Length == 4
                            && UniFileName->Buffer[1] != L'.')) {

                        try_return( Status = STATUS_OBJECT_NAME_INVALID );
                    }
                }

                FileNameLength = (USHORT)IrpSp->Parameters.QueryDirectory.FileName->Length;

                FileNameBuffer = NtfsAllocatePool(PagedPool, SizeOfFileName + FileNameLength );

                RtlCopyMemory( FileNameBuffer->FileName,
                               UniFileName->Buffer,
                               FileNameLength );

                FileNameLength += SizeOfFileName;

                FileNameBuffer->ParentDirectory = Scb->Fcb->FileReference;
                FileNameBuffer->FileNameLength = (UCHAR)((FileNameLength - SizeOfFileName) / sizeof( WCHAR ));
                FileNameBuffer->Flags = 0;
            }

            //
            //  If we already have a query buffer, deallocate this on the way
            //  out.
            //

            if (Ccb->QueryBuffer != NULL) {

                //
                //  If we have a name to resume from then override the restart
                //  scan boolean.
                //

                if ((UnwindFileNameBuffer = FileNameBuffer) != NULL) {

                    RestartScan = FALSE;
                }

            //
            //  Otherwise, store this one in the Ccb.
            //

            } else {

                UNICODE_STRING Expression;

                Ccb->QueryBuffer = (PVOID)FileNameBuffer;
                Ccb->QueryLength = (USHORT)FileNameLength;
                FirstQuery = TRUE;

                //
                //  If the search expression contains a wild card then remember this in
                //  the Ccb.
                //

                Expression.MaximumLength =
                Expression.Length = FileNameBuffer->FileNameLength * sizeof( WCHAR );
                Expression.Buffer = FileNameBuffer->FileName;

                //
                //  When we establish the search pattern, we must also establish
                //  whether the user wants to see "." and "..".  This code does
                //  not necessarily have to be perfect (he said), but should be
                //  good enough to catch the common cases.  Dos does not have
                //  perfect semantics for these cases, and the following determination
                //  will mimic what FastFat does exactly.
                //

                if (Scb != Vcb->RootIndexScb) {
                    static UNICODE_STRING DotString = CONSTANT_UNICODE_STRING( L"." );

                    if (FsRtlDoesNameContainWildCards(&Expression)) {

                        if (FsRtlIsNameInExpression( &Expression,
                                                     &DotString,
                                                     FALSE,
                                                     NULL )) {


                            SetFlag( Ccb->Flags, CCB_FLAG_RETURN_DOT | CCB_FLAG_RETURN_DOTDOT );
                        }
                    } else {
                        if (NtfsAreNamesEqual( Vcb->UpcaseTable, &Expression, &DotString, FALSE )) {

                            SetFlag( Ccb->Flags, CCB_FLAG_RETURN_DOT | CCB_FLAG_RETURN_DOTDOT );
                        }
                    }
                }
            }

        //
        //  Otherwise we are just restarting the query from the Ccb.
        //

        } else {

            FileNameBuffer = (PFILE_NAME)Ccb->QueryBuffer;
            FileNameLength = Ccb->QueryLength;
        }

        Irp->IoStatus.Information = 0;

        //
        //  Use a try-except to handle errors accessing the user buffer.
        //

        try {

            ULONG BytesToCopy;

            FCB_TABLE_ELEMENT Key;
            PFCB_TABLE_ELEMENT Entry;

            BOOLEAN MatchAll = FALSE;

            //
            //  See if we are supposed to try to acquire an Fcb on this
            //  resume.
            //

            if (Ccb->FcbToAcquire.LongValue != 0) {

                //
                //  First we need to acquire the Vcb shared, since we will
                //  acquire two Fcbs.
                //

                NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
                VcbAcquired = TRUE;

                //
                //  Now look up the Fcb, and if it is there, reference it
                //  and remember it.
                //

                Key.FileReference = Ccb->FcbToAcquire.FileReference;
                NtfsAcquireFcbTable( IrpContext, Vcb );
                Entry = RtlLookupElementGenericTable( &Vcb->FcbTable, &Key );
                if (Entry != NULL) {
                    AcquiredFcb = Entry->Fcb;
                    AcquiredFcb->ReferenceCount += 1;
                }
                NtfsReleaseFcbTable( IrpContext, Vcb );

                //
                //  Now that it cannot go anywhere, acquire it.
                //

                if (AcquiredFcb != NULL) {
                    NtfsAcquireSharedFcb( IrpContext, AcquiredFcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                }

                //
                //  Now that we actually acquired it, we may as well clear this
                //  field.
                //

                Ccb->FcbToAcquire.LongValue = 0;
            }

            //
            //  Acquire shared access to the Scb.
            //

            NtfsAcquireSharedScb( IrpContext, Scb );
            ScbAcquired = TRUE;

            //
            //  Now that we have both files acquired, we can free the Vcb.
            //

            if (VcbAcquired) {
                NtfsReleaseVcb( IrpContext, Vcb );
                VcbAcquired = FALSE;
            }

            //
            //  If the volume is no longer mounted, we should fail this
            //  request.  Since we have the Scb shared now, we know that
            //  a dismount request can't sneak in.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                try_return( Status = STATUS_VOLUME_DISMOUNTED );
            }

            //
            // If we are in the Fsp now because we had to wait earlier,
            // we must map the user buffer, otherwise we can use the
            // user's buffer directly.
            //

            Buffer = NtfsMapUserBuffer( Irp );

            //
            //  Check if this is the first call to query directory for this file
            //  object.  It is the first call if the enumeration context field of
            //  the ccb is null.  Also check if we are to restart the scan.
            //

            if (FirstQuery || RestartScan) {

                CallRestart = TRUE;
                NextFlag = FALSE;

                //
                //  On first/restarted scan, note that we have not returned either
                //  of these guys.
                //

                ClearFlag( Ccb->Flags, CCB_FLAG_DOT_RETURNED | CCB_FLAG_DOTDOT_RETURNED );

            //
            //  Otherwise check to see if we were given a file name to restart from
            //

            } else if (UnwindFileNameBuffer != NULL) {

                CallRestart = TRUE;
                NextFlag = TRUE;

                //
                //  The guy could actually be asking to return to one of the dot
                //  file positions, so we must handle that correctly.
                //

                if ((FileNameBuffer->FileNameLength <= 2) &&
                    (FileNameBuffer->FileName[0] == L'.')) {

                    if (FileNameBuffer->FileNameLength == 1) {

                        //
                        //  He wants to resume after ".", so we set to return
                        //  ".." again, and change the temporary pattern to
                        //  rewind our context to the front.
                        //

                        ClearFlag( Ccb->Flags, CCB_FLAG_DOTDOT_RETURNED );
                        SetFlag( Ccb->Flags, CCB_FLAG_DOT_RETURNED );

                        FileNameBuffer->FileName[0] = L'*';
                        NextFlag = FALSE;

                    } else if (FileNameBuffer->FileName[1] == L'.') {

                        //
                        //  He wants to resume after "..", so we the change
                        //  the temporary pattern to rewind our context to the
                        //  front.
                        //

                        SetFlag( Ccb->Flags, CCB_FLAG_DOT_RETURNED | CCB_FLAG_DOTDOT_RETURNED );
                        FileNameBuffer->FileName[0] =
                        FileNameBuffer->FileName[1] = L'*';
                        NextFlag = FALSE;
                    }

                //
                //  Always return the entry after the user's file name.
                //

                } else {

                    SetFlag( Ccb->Flags, CCB_FLAG_DOT_RETURNED | CCB_FLAG_DOTDOT_RETURNED );
                }

            //
            //  Otherwise we're simply continuing a previous enumeration from
            //  where we last left off.  And we always leave off one beyond the
            //  last entry we returned.
            //

            } else {

                CallRestart = FALSE;
                NextFlag = FALSE;
            }

            //
            //  At this point we are about to enter our query loop.  We have
            //  already decided if we need to call restart or continue when we
            //  go after an index entry.  The variables LastEntry and NextEntry are
            //  used to index into the user buffer.  LastEntry is the last entry
            //  we added to the user buffer, and NextEntry is the current
            //  one we're working on.
            //

            LastEntry = 0;
            NextEntry = 0;

            //
            //  Remember if we are matching everything by checking these two common
            //  cases.
            //

            MatchAll = (FileNameBuffer->FileName[0] == L'*')

                        &&

                       ((FileNameBuffer->FileNameLength == 1) ||

                        ((FileNameBuffer->FileNameLength == 3) &&
                         (FileNameBuffer->FileName[1] == L'.') &&
                         (FileNameBuffer->FileName[2] == L'*')));

            while (TRUE) {

                PINDEX_ENTRY IndexEntry;
                PFILE_NAME NtfsFileName;
                PDUPLICATED_INFORMATION DupInfo;
                PFILE_NAME DosFileName;
                FILE_REFERENCE FileId;

                ULONG BytesRemainingInBuffer;
                ULONG FoundFileNameLength;

                struct {

                    FILE_NAME FileName;
                    WCHAR LastChar;
                } DotDotName;

                BOOLEAN SynchronizationError;

                DebugTrace( 0, Dbg, ("Top of Loop\n") );
                DebugTrace( 0, Dbg, ("LastEntry = %08lx\n", LastEntry) );
                DebugTrace( 0, Dbg, ("NextEntry = %08lx\n", NextEntry) );

                //
                //  If a previous pass through the loop acquired the Fcb table then
                //  release it now.  We don't want to be holding it if we take a fault
                //  on the directory stream.  Otherwise we can get into a circular
                //  deadlock if we need to acquire the mutex for this file while
                //  holding the mutex for the Fcb Table.
                //

                if (FlagOn( OtherContext.Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED )) {
                    NtfsReleaseFcbTable( IrpContext, IrpContext->Vcb );
                    ClearFlag( OtherContext.Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED );
                }
                DosFileName = NULL;

                //
                //  Lookup the next index entry.  Check if we need to do the lookup
                //  by calling restart or continue.  If we do need to call restart
                //  check to see if we have a real AnsiFileName.  And set ourselves
                //  up for subsequent iternations through the loop
                //

                if (CallRestart) {

                    GotEntry = NtfsRestartIndexEnumeration( IrpContext,
                                                            Ccb,
                                                            Scb,
                                                            (PVOID)FileNameBuffer,
                                                            IgnoreCase,
                                                            NextFlag,
                                                            &IndexEntry,
                                                            AcquiredFcb );
                    CallRestart = FALSE;

                } else {

                    GotEntry = NtfsContinueIndexEnumeration( IrpContext,
                                                             Ccb,
                                                             Scb,
                                                             NextFlag,
                                                             &IndexEntry );
                }

                //
                //  Check to see if we should quit the loop because we are only
                //  returning a single entry.  We actually want to spin around
                //  the loop top twice so that our enumeration has has us left off
                //  at the last entry we didn't return.  We know this is now our
                //  second time though the loop if NextEntry is not zero.
                //

                if ((ReturnSingleEntry) && (NextEntry != 0)) {

                    break;
                }

                //
                //  Assume we won't be returning the file id.
                //

                *((PLONGLONG) &FileId) = 0;

                //
                //  Assume we are to return one of the names "." or "..".
                //  We should not search farther in the index so we set
                //  NextFlag to FALSE.
                //

                RtlZeroMemory( &DotDotName, sizeof(DotDotName) );
                NtfsFileName = &DotDotName.FileName;
                NtfsFileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;
                NtfsFileName->FileName[0] =
                NtfsFileName->FileName[1] = L'.';
                DupInfo = &Scb->Fcb->Info;
                NextFlag = FALSE;

                //
                //  Handle "." first.
                //

                if (!FlagOn(Ccb->Flags, CCB_FLAG_DOT_RETURNED) &&
                    FlagOn(Ccb->Flags, CCB_FLAG_RETURN_DOT)) {

                    FoundFileNameLength = 2;
                    GotEntry = TRUE;
                    SetFlag( Ccb->Flags, CCB_FLAG_DOT_RETURNED );

                    FileId = Scb->Fcb->FileReference;

                //
                //  Handle ".." next.
                //

                } else if (!FlagOn(Ccb->Flags, CCB_FLAG_DOTDOT_RETURNED) &&
                           FlagOn(Ccb->Flags, CCB_FLAG_RETURN_DOTDOT)) {

                    FoundFileNameLength = 4;
                    GotEntry = TRUE;
                    SetFlag( Ccb->Flags, CCB_FLAG_DOTDOT_RETURNED );

                } else {

                    //
                    //  Compute the length of the name we found.
                    //

                    if (GotEntry) {

                        FileId = IndexEntry->FileReference;

                        NtfsFileName = (PFILE_NAME)(IndexEntry + 1);

                        FoundFileNameLength = NtfsFileName->FileNameLength * sizeof( WCHAR );

                        //
                        //  Verify the index entry is valid.
                        //

                        if (FoundFileNameLength != IndexEntry->AttributeLength - SizeOfFileName) {

                            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                        }

                        DupInfo = &NtfsFileName->Info;
                        NextFlag = TRUE;

                        //
                        //  Don't return any system files.
                        //

                        if (NtfsSegmentNumber( &IndexEntry->FileReference ) < FIRST_USER_FILE_NUMBER &&
                            NtfsProtectSystemFiles) {

                            continue;
                        }

                    }
                }

                //
                //  Now check to see if we actually got another index entry.  If
                //  we didn't then we also need to check if we never got any
                //  or if we just ran out.  If we just ran out then we break out
                //  of the main loop and finish the Irp after the loop
                //

                if (!GotEntry) {

                    DebugTrace( 0, Dbg, ("GotEntry is FALSE\n") );

                    if (NextEntry == 0) {

                        if (FirstQuery) {

                            try_return( Status = STATUS_NO_SUCH_FILE );
                        }

                        try_return( Status = STATUS_NO_MORE_FILES );
                    }

                    break;
                }

                //
                //  Cleanup and reinitialize context from previous loop.
                //

                NtfsReinitializeIndexContext( IrpContext, &OtherContext );

                //
                //  We may have matched a Dos-Only name.  If so we will save
                //  it and go get the Ntfs name.
                //

                if (!FlagOn(NtfsFileName->Flags, FILE_NAME_NTFS) &&
                    FlagOn(NtfsFileName->Flags, FILE_NAME_DOS)) {

                    //
                    //  If we are returning everything, then we can skip
                    //  the Dos-Only names and save some cycles.
                    //

                    if (MatchAll) {
                        continue;
                    }

                    DosFileName = NtfsFileName;

                    NtfsFileName = NtfsRetrieveOtherFileName( IrpContext,
                                                              Ccb,
                                                              Scb,
                                                              IndexEntry,
                                                              &OtherContext,
                                                              AcquiredFcb,
                                                              &SynchronizationError );

                    //
                    //  If we got an Ntfs name, then we need to list this entry now
                    //  iff the Ntfs name is not in the expression.  If the Ntfs
                    //  name is in the expression, we can just continue and print
                    //  this name when we encounter it by the Ntfs name.
                    //

                    if (NtfsFileName != NULL) {

                        if (FlagOn(Ccb->Flags, CCB_FLAG_WILDCARD_IN_EXPRESSION)) {

                            if (NtfsFileNameIsInExpression( Vcb->UpcaseTable,
                                                            (PFILE_NAME)Ccb->QueryBuffer,
                                                            NtfsFileName,
                                                            IgnoreCase )) {

                                continue;
                            }

                        } else {

                            if (NtfsFileNameIsEqual( Vcb->UpcaseTable,
                                                     (PFILE_NAME)Ccb->QueryBuffer,
                                                     NtfsFileName,
                                                     IgnoreCase )) {

                                continue;
                            }
                        }

                        FoundFileNameLength = NtfsFileName->FileNameLength * sizeof( WCHAR );

                    } else if (SynchronizationError) {

                        if (Irp->IoStatus.Information != 0) {
                            try_return( Status = STATUS_SUCCESS );
                        } else {
                            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                        }

                    } else {

                        continue;
                    }
                }

                //
                //  Here are the rules concerning filling up the buffer:
                //
                //  1.  The Io system garentees that there will always be
                //      enough room for at least one base record.
                //
                //  2.  If the full first record (including file name) cannot
                //      fit, as much of the name as possible is copied and
                //      STATUS_BUFFER_OVERFLOW is returned.
                //
                //  3.  If a subsequent record cannot completely fit into the
                //      buffer, none of it (as in 0 bytes) is copied, and
                //      STATUS_SUCCESS is returned.  A subsequent query will
                //      pick up with this record.
                //

                BytesRemainingInBuffer = UserBufferLength - NextEntry;

                if ( (NextEntry != 0) &&
                     ( (BaseLength + FoundFileNameLength > BytesRemainingInBuffer) ||
                       (UserBufferLength < NextEntry) ) ) {

                    DebugTrace( 0, Dbg, ("Next entry won't fit\n") );

                    try_return( Status = STATUS_SUCCESS );
                }

                ASSERT( BytesRemainingInBuffer >= BaseLength );

                //
                //  Zero the base part of the structure.
                //

                AccessingUserBuffer = TRUE;
                RtlZeroMemory( &Buffer[NextEntry], BaseLength );
                AccessingUserBuffer = FALSE;

                //
                //  Now we have an entry to return to our caller. we'll
                //  case on the type of information requested and fill up the
                //  user buffer if everything fits
                //

                switch (FileInformationClass) {

                case FileIdFullDirectoryInformation:

                    ((PFILE_ID_FULL_DIR_INFORMATION)&Buffer[NextEntry])->FileId.QuadPart = *((PLONGLONG) &FileId);
                    goto FillFullDirectoryInformation;

                case FileIdBothDirectoryInformation:

                    ((PFILE_ID_BOTH_DIR_INFORMATION)&Buffer[NextEntry])->FileId.QuadPart = *((PLONGLONG) &FileId);
                    //  Fall thru

                case FileBothDirectoryInformation:

                    BothDirInfo = (PFILE_BOTH_DIR_INFORMATION)&Buffer[NextEntry];

                    //
                    //  If this is not also a Dos name, and the Ntfs flag is set
                    //  (meaning there is a separate Dos name), then call the
                    //  routine to get the short name, if we do not already have
                    //  it from above.
                    //

                    if (!FlagOn(NtfsFileName->Flags, FILE_NAME_DOS) &&
                        FlagOn(NtfsFileName->Flags, FILE_NAME_NTFS)) {

                        if (DosFileName == NULL) {

                            DosFileName = NtfsRetrieveOtherFileName( IrpContext,
                                                                     Ccb,
                                                                     Scb,
                                                                     IndexEntry,
                                                                     &OtherContext,
                                                                     AcquiredFcb,
                                                                     &SynchronizationError );
                        }

                        if (DosFileName != NULL) {

                            AccessingUserBuffer = TRUE;
                            BothDirInfo->ShortNameLength = DosFileName->FileNameLength * sizeof( WCHAR );
                            RtlCopyMemory( BothDirInfo->ShortName,
                                           DosFileName->FileName,
                                           BothDirInfo->ShortNameLength );
                        } else if (SynchronizationError) {

                            if (Irp->IoStatus.Information != 0) {
                                try_return( Status = STATUS_SUCCESS );
                            } else {
                                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                            }
                        }
                    }

                    //  Fallthru

                case FileFullDirectoryInformation:

FillFullDirectoryInformation:

                    DebugTrace( 0, Dbg, ("Getting file full Unicode directory information\n") );

                    FullDirInfo = (PFILE_FULL_DIR_INFORMATION)&Buffer[NextEntry];

                    //
                    //  EAs and reparse points cannot both be in a file at the same
                    //  time. We return different information for each case.
                    //

                    AccessingUserBuffer = TRUE;
                    if (FlagOn( DupInfo->FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT)) {

                        FullDirInfo->EaSize = DupInfo->ReparsePointTag;
                    } else {

                        FullDirInfo->EaSize = DupInfo->PackedEaSize;

                        //
                        //  Add 4 bytes for the CbListHeader.
                        //

                        if (DupInfo->PackedEaSize != 0) {

                            FullDirInfo->EaSize += 4;
                        }
                    }

                    //  Fallthru

                case FileDirectoryInformation:

                    DebugTrace( 0, Dbg, ("Getting file Unicode directory information\n") );

                    DirInfo = (PFILE_DIRECTORY_INFORMATION)&Buffer[NextEntry];

                    AccessingUserBuffer = TRUE;
                    DirInfo->CreationTime.QuadPart = DupInfo->CreationTime;
                    DirInfo->LastAccessTime.QuadPart = DupInfo->LastAccessTime;
                    DirInfo->LastWriteTime.QuadPart = DupInfo->LastModificationTime;
                    DirInfo->ChangeTime.QuadPart = DupInfo->LastChangeTime;

                    DirInfo->FileAttributes = DupInfo->FileAttributes & FILE_ATTRIBUTE_VALID_FLAGS;

                    if (IsDirectory( DupInfo ) || IsViewIndex( DupInfo )) {
                        DirInfo->FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
                    }
                    if (DirInfo->FileAttributes == 0) {
                        DirInfo->FileAttributes = FILE_ATTRIBUTE_NORMAL;
                    }

                    DirInfo->FileNameLength = FoundFileNameLength;

                    DirInfo->EndOfFile.QuadPart = DupInfo->FileSize;
                    DirInfo->AllocationSize.QuadPart = DupInfo->AllocatedLength;

                    break;

                case FileNamesInformation:

                    DebugTrace( 0, Dbg, ("Getting file Unicode names information\n") );

                    AccessingUserBuffer = TRUE;
                    NamesInfo = (PFILE_NAMES_INFORMATION)&Buffer[NextEntry];

                    NamesInfo->FileNameLength = FoundFileNameLength;

                    break;

                default:

                    try_return( Status = STATUS_INVALID_INFO_CLASS );
                }

                //
                //  Compute how many bytes we can copy.  This should only be less
                //  than the file name length if we are only returning a single
                //  entry.
                //

                if (BytesRemainingInBuffer >= BaseLength + FoundFileNameLength) {

                    BytesToCopy = FoundFileNameLength;

                } else {

                    BytesToCopy = BytesRemainingInBuffer - BaseLength;

                    Status = STATUS_BUFFER_OVERFLOW;
                }

                ASSERT( AccessingUserBuffer );
                RtlCopyMemory( &Buffer[NextEntry + BaseLength],
                               NtfsFileName->FileName,
                               BytesToCopy );

                //
                //  If/when we actually emit a record for the Fcb acquired,
                //  then we can release that file now.  Note we do not just
                //  do it on the first time through the loop, because some of
                //  our callers back up a bit when they give us the resume point.
                //

                if ((AcquiredFcb != NULL) &&
                    (DupInfo != &Scb->Fcb->Info) &&
                    NtfsEqualMftRef(&IndexEntry->FileReference, &Ccb->FcbToAcquire.FileReference)) {

                    //
                    //  Now look up the Fcb, and if it is there, reference it
                    //  and remember it.
                    //
                    //  It is pretty inconvenient here to see if the ReferenceCount
                    //  goes to zero and try to do a TearDown, we do not have the
                    //  right resources.  Note that the window is small, and the Fcb
                    //  will go away if either someone opens the file again, someone
                    //  tries to delete the directory, or someone tries to lock the
                    //  volume.
                    //

                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    AcquiredFcb->ReferenceCount -= 1;
                    NtfsReleaseFcbTable( IrpContext, Vcb );
                    NtfsReleaseFcb( IrpContext, AcquiredFcb );
                    AcquiredFcb = NULL;
                }

                //
                //  Set up the previous next entry offset
                //

                *((PULONG)(&Buffer[LastEntry])) = NextEntry - LastEntry;
                AccessingUserBuffer = FALSE;

                //
                //  And indicate how much of the user buffer we have currently
                //  used up.  We must compute this value before we long align
                //  ourselves for the next entry.  This is the point where we
                //  quad-align the length of the previous entry.
                //

                Irp->IoStatus.Information = QuadAlign( Irp->IoStatus.Information) +
                                            BaseLength + BytesToCopy;

                //
                //  If we weren't able to copy the whole name, then we bail here.
                //

                if ( !NT_SUCCESS( Status ) ) {

                    try_return( Status );
                }

                //
                //  Set ourselves up for the next iteration
                //

                LastEntry = NextEntry;
                NextEntry += (ULONG)QuadAlign( BaseLength + BytesToCopy );
            }

            //
            //  At this point we've successfully filled up some of the buffer so
            //  now is the time to set our status to success.
            //

            Status = STATUS_SUCCESS;

        } except( (!FsRtlIsNtstatusExpected( GetExceptionCode() ) && AccessingUserBuffer) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_USER_BUFFER, NULL, NULL );
        }

    try_exit:

        //
        //  Abort transaction on error by raising.
        //

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

        //
        //  Set the last access flag in the Fcb if the caller
        //  didn't set it explicitly.
        //

        if (!FlagOn( Ccb->Flags, CCB_FLAG_USER_SET_LAST_ACCESS_TIME ) &&
            !FlagOn( NtfsData.Flags, NTFS_FLAGS_DISABLE_LAST_ACCESS )) {

            NtfsGetCurrentTime( IrpContext, Scb->Fcb->CurrentLastAccess );
            SetFlag( Scb->Fcb->InfoFlags, FCB_INFO_UPDATE_LAST_ACCESS );
        }

    } finally {

        DebugUnwind( NtfsQueryDirectory );

        if (VcbAcquired) {
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        NtfsCleanupIndexContext( IrpContext, &OtherContext );

        if (AcquiredFcb != NULL) {

            //
            //  Now look up the Fcb, and if it is there, reference it
            //  and remember it.
            //
            //  It is pretty inconvenient here to see if the ReferenceCount
            //  goes to zero and try to do a TearDown, we do not have the
            //  right resources.  Note that the window is small, and the Fcb
            //  will go away if either someone opens the file again, someone
            //  tries to delete the directory, or someone tries to lock the
            //  volume.
            //

            NtfsAcquireFcbTable( IrpContext, Vcb );
            AcquiredFcb->ReferenceCount -= 1;
            NtfsReleaseFcbTable( IrpContext, Vcb );
            NtfsReleaseFcb( IrpContext, AcquiredFcb );
        }

        if (ScbAcquired) {
            NtfsReleaseScb( IrpContext, Scb );
        }

        NtfsCleanupAfterEnumeration( IrpContext, Ccb );

        if (CcbAcquired) {

            NtfsReleaseIndexCcb( Scb, Ccb );
        }

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

        if (UnwindFileNameBuffer != NULL) {

            NtfsFreePool(UnwindFileNameBuffer);
        }
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsQueryDirectory -> %08lx\n", Status) );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsNotifyChangeDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the notify change directory operation.  It is
    responsible for either completing or enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

    Vcb - Supplies its Vcb

    Scb - Supplies its Scb

    Ccb - Supplies its Ccb

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ULONG CompletionFilter;
    BOOLEAN WatchTree;
    BOOLEAN ViewIndex;

    PSECURITY_SUBJECT_CONTEXT SubjectContext = NULL;
    BOOLEAN FreeSubjectContext = FALSE;

    PCHECK_FOR_TRAVERSE_ACCESS CallBack = NULL;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT_VCB( Vcb );
    ASSERT_CCB( Ccb );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    //
    //  Get the current Stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsNotifyChangeDirectory...\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, (" ->CompletionFilter = %08lx\n", IrpSp->Parameters.NotifyDirectory.CompletionFilter) );
    DebugTrace( 0, Dbg, (" ->WatchTree        = %08lx\n", FlagOn( IrpSp->Flags, SL_WATCH_TREE )) );
    DebugTrace( 0, Dbg, ("Vcb        = %08lx\n", Vcb) );
    DebugTrace( 0, Dbg, ("Ccb        = %08lx\n", Ccb) );
    DebugTrace( 0, Dbg, ("Scb        = %08lx\n", Scb) );

    //
    //  Reference our input parameter to make things easier
    //

    CompletionFilter = IrpSp->Parameters.NotifyDirectory.CompletionFilter;
    WatchTree = BooleanFlagOn( IrpSp->Flags, SL_WATCH_TREE );

    //
    //  Always set the wait bit in the IrpContext so the initial wait can't fail.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  We will only acquire the Vcb to perform the dirnotify task.  The dirnotify
    //  package will provide synchronization between this operation and cleanup.
    //  We need the Vcb to synchronize with any rename or link operations underway.
    //

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    try {

        //
        //  If the Link count is zero on this Fcb then complete this request
        //  with STATUS_DELETE_PENDING.
        //

        if (Scb->Fcb->LinkCount == 0) {

            NtfsRaiseStatus( IrpContext, STATUS_DELETE_PENDING, NULL, NULL );
        }

        ViewIndex = BooleanFlagOn( Scb->ScbState, SCB_STATE_VIEW_INDEX );

        //
        //  If we need to verify traverse access for this caller then allocate and
        //  capture the subject context to pass to the dir notify package.  That
        //  package will be responsible for deallocating it.
        //

        if (FlagOn( Ccb->Flags, CCB_FLAG_TRAVERSE_CHECK )) {

            //
            //  We only use the subject context for directories 
            //    

            if (!ViewIndex) {
                SubjectContext = NtfsAllocatePool( PagedPool,
                                                    sizeof( SECURITY_SUBJECT_CONTEXT ));

                FreeSubjectContext = TRUE;
                SeCaptureSubjectContext( SubjectContext );

                FreeSubjectContext = FALSE;
            }
            CallBack = NtfsNotifyTraverseCheck;
        } 

        //
        //  Call the Fsrtl package to process the request.  We cast the
        //  unicode strings to ansi strings as the dir notify package
        //  only deals with memory matching.
        //

        if (ViewIndex) {

            //
            //  View indices use different values for the overloaded inputs
            //  to FsRtlNotifyFilterChangeDirectory.
            //

            FsRtlNotifyFilterChangeDirectory( Vcb->NotifySync,
                                              &Vcb->ViewIndexNotifyList,
                                              Ccb,
                                              NULL,
                                              WatchTree,
                                              FALSE,
                                              CompletionFilter,
                                              Irp,
                                              CallBack,
                                              (PSECURITY_SUBJECT_CONTEXT) Scb->Fcb,
                                              NULL );
        } else {

            FsRtlNotifyFilterChangeDirectory( Vcb->NotifySync,
                                              &Vcb->DirNotifyList,
                                              Ccb,
                                              (PSTRING) &Scb->ScbType.Index.NormalizedName,
                                              WatchTree,
                                              FALSE,
                                              CompletionFilter,
                                              Irp,
                                              CallBack,
                                              SubjectContext,
                                              NULL );
        }

        Status = STATUS_PENDING;

        if (!FlagOn( Ccb->Flags, CCB_FLAG_DIR_NOTIFY )) {

            SetFlag( Ccb->Flags, CCB_FLAG_DIR_NOTIFY );

            if (ViewIndex) {

                InterlockedIncrement( &Vcb->ViewIndexNotifyCount );

            } else {

                InterlockedIncrement( &Vcb->NotifyCount );
            }
        }

    } finally {

        DebugUnwind( NtfsNotifyChangeDirectory );

        NtfsReleaseVcb( IrpContext, Vcb );

        //
        //  Since the dir notify package is holding the Irp, we discard the
        //  the IrpContext.
        //

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, NULL, 0 );

        } else if (FreeSubjectContext) {

            NtfsFreePool( SubjectContext );
        }
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsNotifyChangeDirectory -> %08lx\n", Status) );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fieldoff.c ===
#include "NtfsProc.h"
#include <stdio.h>

#define doit(a,b) { printf("%s %04lx %4lx %s\n", #a, FIELD_OFFSET(a,b), sizeof(d.b), #b); }

void __cdecl main()
{
    printf("<Record>  <offset>  <size>  <field>\n\n");
    {
        NTFS_DATA d;
        doit( NTFS_DATA, NodeTypeCode );
        doit( NTFS_DATA, NodeByteSize );
        doit( NTFS_DATA, DriverObject );
        doit( NTFS_DATA, VcbQueue );
        doit( NTFS_DATA, Resource );
        doit( NTFS_DATA, AsyncCloseList );
        doit( NTFS_DATA, AsyncCloseActive );
        doit( NTFS_DATA, ReduceDelayedClose );
        doit( NTFS_DATA, AsyncCloseCount );
        doit( NTFS_DATA, OurProcess );
        doit( NTFS_DATA, DelayedCloseCount );
        doit( NTFS_DATA, DelayedCloseList );
        doit( NTFS_DATA, NtfsCloseItem );
        doit( NTFS_DATA, FreeFcbTableSize );
        doit( NTFS_DATA, UnusedUchar );
        doit( NTFS_DATA, FreeFcbTableArray );
        doit( NTFS_DATA, FreeEresourceSize );
        doit( NTFS_DATA, FreeEresourceTotal );
        doit( NTFS_DATA, FreeEresourceMiss );
        doit( NTFS_DATA, FreeEresourceArray );
        doit( NTFS_DATA, CacheManagerCallbacks );
        doit( NTFS_DATA, CacheManagerVolumeCallbacks );
        doit( NTFS_DATA, VolumeCheckpointDpc );
        doit( NTFS_DATA, VolumeCheckpointTimer );
        doit( NTFS_DATA, VolumeCheckpointItem );
        doit( NTFS_DATA, Flags );
        doit( NTFS_DATA, ReadAheadThreads );
    }
    printf("\n");
    {
        RECORD_ALLOCATION_CONTEXT d;
        doit( RECORD_ALLOCATION_CONTEXT, DataScb             );
        doit( RECORD_ALLOCATION_CONTEXT, BitmapScb           );
        doit( RECORD_ALLOCATION_CONTEXT, CurrentBitmapSize   );
        doit( RECORD_ALLOCATION_CONTEXT, NumberOfFreeBits    );
        doit( RECORD_ALLOCATION_CONTEXT, IndexOfLastSetBit   );
        doit( RECORD_ALLOCATION_CONTEXT, BytesPerRecord      );
        doit( RECORD_ALLOCATION_CONTEXT, ExtendGranularity   );
        doit( RECORD_ALLOCATION_CONTEXT, TruncateGranularity );
    }
    printf("\n");
    {
        RESTART_POINTERS d;
        doit( RESTART_POINTERS, Resource                     );
        doit( RESTART_POINTERS, Table                        );
        doit( RESTART_POINTERS, SpinLock                     );
        doit( RESTART_POINTERS, ResourceInitialized          );
        doit( RESTART_POINTERS, Unused                       );
    }
    printf("\n");
    {
        NTFS_MCB_ENTRY d;
        doit( NTFS_MCB_ENTRY, LruLinks                       );
        doit( NTFS_MCB_ENTRY, NtfsMcb                        );
        doit( NTFS_MCB_ENTRY, NtfsMcbArray                   );
        doit( NTFS_MCB_ENTRY, LargeMcb                       );
    }
    printf("\n");
    {
        NTFS_MCB_ARRAY d;
        doit( NTFS_MCB_ARRAY, StartingVcn                    );
        doit( NTFS_MCB_ARRAY, EndingVcn                      );
        doit( NTFS_MCB_ARRAY, NtfsMcbEntry                   );
        doit( NTFS_MCB_ARRAY, Unused                         );
    }
    printf("\n");
    {
        NTFS_MCB d;
        doit( NTFS_MCB, FcbHeader             );
        doit( NTFS_MCB, PoolType              );
        doit( NTFS_MCB, NtfsMcbArraySizeInUse );
        doit( NTFS_MCB, NtfsMcbArraySize      );
        doit( NTFS_MCB, NtfsMcbArray          );
        doit( NTFS_MCB, FastMutex             );
    }
    printf("\n");
    {
        DEALLOCATED_CLUSTERS d;
        doit( DEALLOCATED_CLUSTERS, Mcb );
        doit( DEALLOCATED_CLUSTERS, Lsn );
        doit( DEALLOCATED_CLUSTERS, ClusterCount );
    }
    printf("\n");
    {
        VCB d;
        doit( VCB, NodeTypeCode );
        doit( VCB, NodeByteSize );
        doit( VCB, TargetDeviceObject );
        doit( VCB, VcbLinks );
        doit( VCB, MftScb );
        doit( VCB, Mft2Scb );
        doit( VCB, LogFileScb );
        doit( VCB, VolumeDasdScb );
        doit( VCB, RootIndexScb );
        doit( VCB, BitmapScb );
        doit( VCB, AttributeDefTableScb );
        doit( VCB, UpcaseTableScb );
        doit( VCB, BadClusterFileScb );
        doit( VCB, QuotaTableScb );
        doit( VCB, MftBitmapScb );
        doit( VCB, LogFileObject );
        doit( VCB, MftReserveFlags );
        doit( VCB, MftDefragState );
        doit( VCB, VcbState );
        doit( VCB, Statistics );
        doit( VCB, CleanupCount );
        doit( VCB, CloseCount );
        doit( VCB, ReadOnlyCloseCount );
        doit( VCB, SystemFileCloseCount );
        doit( VCB, TotalClusters );
        doit( VCB, FreeClusters );
        doit( VCB, DeallocatedClusters );
        doit( VCB, TotalReserved );
        doit( VCB, FreeSpaceMcb );
        doit( VCB, FreeSpaceMcbMaximumSize );
        doit( VCB, FreeSpaceMcbTrimToSize );
        doit( VCB, LastBitmapHint );
        doit( VCB, RootLcb );
        doit( VCB, Vpb );
        doit( VCB, BigEnoughToMove );
        doit( VCB, DefaultBlocksPerIndexAllocationBuffer );
        doit( VCB, DefaultBytesPerIndexAllocationBuffer );
        doit( VCB, BytesPerSector );
        doit( VCB, BytesPerCluster );
        doit( VCB, BytesPerFileRecordSegment );
        doit( VCB, ClustersPerFileRecordSegment );
        doit( VCB, FileRecordsPerCluster );
        doit( VCB, MftStartLcn );
        doit( VCB, Mft2StartLcn );
        doit( VCB, NumberSectors );
        doit( VCB, VolumeSerialNumber );
        doit( VCB, VolumeCreationTime );
        doit( VCB, VolumeLastModificationTime );
        doit( VCB, VolumeLastChangeTime );
        doit( VCB, VolumeLastAccessTime );
        doit( VCB, ClusterMask );
        doit( VCB, InverseClusterMask );
        doit( VCB, ClusterShift );
        doit( VCB, MftShift );
        doit( VCB, MftToClusterShift );
        doit( VCB, ClustersPerPage );
        doit( VCB, MftReserved );
        doit( VCB, MftCushion );
        doit( VCB, FcbTableMutex );
        doit( VCB, FcbSecurityMutex );
        doit( VCB, CheckpointMutex );
        doit( VCB, CheckpointNotifyEvent );
        doit( VCB, CheckpointFlags );
        doit( VCB, AttributeFlagsMask );
        doit( VCB, UnusedUshort );
        doit( VCB, MftHoleGranularity );
        doit( VCB, MftFreeRecords );
        doit( VCB, MftHoleRecords );
        doit( VCB, LogHandle );
        doit( VCB, MftHoleMask );
        doit( VCB, MftHoleInverseMask );
        doit( VCB, MftClustersPerHole );
        doit( VCB, MftHoleClusterMask );
        doit( VCB, MftHoleClusterInverseMask );
        doit( VCB, LastRestartArea );
        doit( VCB, OpenAttributeTable );
        doit( VCB, LastBaseLsn );
        doit( VCB, TransactionTable );
        doit( VCB, EndOfLastCheckpoint );
        doit( VCB, DeviceName );
        doit( VCB, UpcaseTable );
        doit( VCB, UpcaseTableSize );
        doit( VCB, FcbTable );
        doit( VCB, DirNotifyList );
        doit( VCB, NotifySync );
        doit( VCB, FileObjectWithVcbLocked );
        doit( VCB, MftZoneStart );
        doit( VCB, MftZoneEnd );
        doit( VCB, PriorDeallocatedClusters );
        doit( VCB, ActiveDeallocatedClusters );
        doit( VCB, DeallocatedClusters1 );
        doit( VCB, DeallocatedClusters2 );
        doit( VCB, MftBitmapAllocationContext );
        doit( VCB, Resource );
        doit( VCB, AttributeDefinitions );
        doit( VCB, LogHeaderReservation );
        doit( VCB, Tunnel );
    }
    printf("\n");
    {
        VOLUME_DEVICE_OBJECT d;
        doit( VOLUME_DEVICE_OBJECT, DeviceObject );
        doit( VOLUME_DEVICE_OBJECT, PostedRequestCount );
        doit( VOLUME_DEVICE_OBJECT, OverflowQueueCount );
        doit( VOLUME_DEVICE_OBJECT, OverflowQueue );
        doit( VOLUME_DEVICE_OBJECT, OverflowQueueSpinLock );
        doit( VOLUME_DEVICE_OBJECT, Vcb );
    }
    printf("\n");
    {
        QUICK_INDEX d;
        doit( QUICK_INDEX, ChangeCount );
        doit( QUICK_INDEX, BufferOffset );
        doit( QUICK_INDEX, CapturedLsn );
        doit( QUICK_INDEX, IndexBlock );
    }
    printf("\n");
    {
        NAME_LINK d;
        doit( NAME_LINK, LinkName );
        doit( NAME_LINK, Links );
    }
    printf("\n");
    {
        LCB d;
        doit( LCB, NodeTypeCode );
        doit( LCB, NodeByteSize );
        doit( LCB, LcbState );

        doit( LCB, ScbLinks );
        doit( LCB, Scb );
        doit( LCB, CleanupCount );

        doit( LCB, FcbLinks );
        doit( LCB, Fcb );
        doit( LCB, ReferenceCount );

        doit( LCB, IgnoreCaseLink );
        doit( LCB, InfoFlags );

        doit( LCB, OverlayParentDirectory );
        doit( LCB, CcbQueue );

        doit( LCB, ExactCaseLink );
        doit( LCB, FileNameAttr );

        doit( LCB, QuickIndex );

        doit( LCB, OverlayFileNameLength );
        doit( LCB, OverlayFlags );
        doit( LCB, OverlayFileName );
    }
    printf("\n");
    {
        FCB d;
        doit( FCB, NodeTypeCode );
        doit( FCB, NodeByteSize );
        doit( FCB, FcbState );
        doit( FCB, FileReference );
        doit( FCB, CleanupCount );
        doit( FCB, CloseCount );
        doit( FCB, ReferenceCount );
        doit( FCB, FcbDenyDelete );
        doit( FCB, FcbDeleteFile );
        doit( FCB, BaseExclusiveCount );
        doit( FCB, EaModificationCount );
        doit( FCB, LcbQueue );
        doit( FCB, ScbQueue );
        doit( FCB, ExclusiveFcbLinks );
        doit( FCB, Vcb );
        doit( FCB, FcbMutex );
        doit( FCB, Resource );
        doit( FCB, PagingIoResource );
        doit( FCB, Info );
        doit( FCB, InfoFlags );
        doit( FCB, LinkCount );
        doit( FCB, TotalLinks );
        doit( FCB, CurrentLastAccess );
        doit( FCB, SharedSecurity );
        doit( FCB, QuotaControl );
        doit( FCB, UpdateLsn );
        doit( FCB, ClassId );
        doit( FCB, OwnerId );
        doit( FCB, DelayedCloseCount );
        doit( FCB, SecurityId );
        doit( FCB, Usn );
        doit( FCB, FcbUsnRecord );
    }
    printf("\n");
    {
        SCB_DATA d;
        doit( SCB_DATA, TotalReserved );
        doit( SCB_DATA, Oplock );
        doit( SCB_DATA, FileLock );
        doit( SCB_DATA, ReservedBitMap );
        doit( SCB_DATA, PadUlong );
    }
    printf("\n");
    {
        SCB_INDEX d;
        doit( SCB_INDEX, RecentlyDeallocatedQueue );
        doit( SCB_INDEX, LcbQueue );
        doit( SCB_INDEX, RecordAllocationContext );
        doit( SCB_INDEX, ExactCaseNode );
        doit( SCB_INDEX, IgnoreCaseNode );
        doit( SCB_INDEX, NormalizedName );
        doit( SCB_INDEX, ChangeCount );
        doit( SCB_INDEX, AttributeBeingIndexed );
        doit( SCB_INDEX, CollationRule );
        doit( SCB_INDEX, BytesPerIndexBuffer );
        doit( SCB_INDEX, BlocksPerIndexBuffer );
        doit( SCB_INDEX, IndexBlockByteShift );
        doit( SCB_INDEX, AllocationInitialized );
        doit( SCB_INDEX, PadUchar );
        doit( SCB_INDEX, IndexDepthHint );
        doit( SCB_INDEX, PadUshort );
    }
    printf("\n");
    {
        SCB_MFT d;
        doit( SCB_MFT, RecentlyDeallocatedQueue );
        doit( SCB_MFT, AddedClusters );
        doit( SCB_MFT, RemovedClusters );
        doit( SCB_MFT, FreeRecordChange );
        doit( SCB_MFT, HoleRecordChange );
        doit( SCB_MFT, ReservedIndex );
        doit( SCB_MFT, PadUlong );
    }
    printf("\n");
    {
        SCB_NONPAGED d;
        doit( SCB_NONPAGED, NodeTypeCode );
        doit( SCB_NONPAGED, NodeByteSize );
        doit( SCB_NONPAGED, OpenAttributeTableIndex );
        doit( SCB_NONPAGED, SegmentObject );
        doit( SCB_NONPAGED, Vcb );
    }
    printf("\n");
    {
        SCB d;
        doit( SCB, Header );

        doit( SCB, FcbLinks );
        doit( SCB, Fcb );
        doit( SCB, Vcb );
        doit( SCB, ScbState );
        doit( SCB, NonCachedCleanupCount );
        doit( SCB, CleanupCount );
        doit( SCB, CloseCount );
        doit( SCB, ShareAccess );
        doit( SCB, AttributeTypeCode );
        doit( SCB, AttributeName );
        doit( SCB, FileObject );
        doit( SCB, LazyWriteThread );
        doit( SCB, NonpagedScb );
        doit( SCB, Mcb );
        doit( SCB, McbStructs );
        doit( SCB, CompressionUnit );
        doit( SCB, AttributeFlags );
        doit( SCB, CompressionUnitShift );
        doit( SCB, PadUchar );
        doit( SCB, ValidDataToDisk );
        doit( SCB, TotalAllocated );
        doit( SCB, EofListHead );
        doit( SCB, Union );
        doit( SCB, ScbSnapshot );
        doit( SCB, PadUlong );
        doit( SCB, ScbType.Data );
        doit( SCB, ScbType.Index );
        doit( SCB, ScbType.Mft );
    }
    printf("\n");
    {
        SCB_SNAPSHOT d;
        doit( SCB_SNAPSHOT, SnapshotLinks );
        doit( SCB_SNAPSHOT, AllocationSize );
        doit( SCB_SNAPSHOT, FileSize );
        doit( SCB_SNAPSHOT, ValidDataLength );
        doit( SCB_SNAPSHOT, ValidDataToDisk );
        doit( SCB_SNAPSHOT, TotalAllocated );
        doit( SCB_SNAPSHOT, LowestModifiedVcn );
        doit( SCB_SNAPSHOT, HighestModifiedVcn );
        doit( SCB_SNAPSHOT, Scb );
        doit( SCB_SNAPSHOT, Unused );
    }
    printf("\n");
    {
        CCB d;
        doit( CCB, NodeTypeCode );
        doit( CCB, NodeByteSize );
        doit( CCB, Flags );

        doit( CCB, FullFileName );
        doit( CCB, LastFileNameOffset );
        doit( CCB, EaModificationCount );
        doit( CCB, NextEaOffset );

        doit( CCB, LcbLinks );
        doit( CCB, Lcb );

        doit( CCB, TypeOfOpen );
        doit( CCB, PadBytes );

        doit( CCB, IndexContext );

        doit( CCB, QueryLength );
        doit( CCB, QueryBuffer );
        doit( CCB, IndexEntryLength );
        doit( CCB, IndexEntry );

        doit( CCB, FcbToAcquire.LongValue );
        doit( CCB, FcbToAcquire.FileReference );
    }
    printf("\n");
    {
        CCB_DATA d;
        doit( CCB_DATA, Opaque );
    }
    printf("\n");
    {
        FCB_DATA d;
        doit( FCB_DATA, Fcb );
        doit( FCB_DATA, Scb );
        doit( FCB_DATA, Ccb );
        doit( FCB_DATA, Lcb );
        doit( FCB_DATA, FileName );
    }
    printf("\n");
    {
        FCB_INDEX d;
        doit( FCB_INDEX, Fcb );
        doit( FCB_INDEX, Scb );
        doit( FCB_INDEX, Ccb );
        doit( FCB_INDEX, Lcb );
        doit( FCB_INDEX, FileName );
    }
    printf("\n");
    {
        IRP_CONTEXT d;
        doit( IRP_CONTEXT, NodeTypeCode );
        doit( IRP_CONTEXT, NodeByteSize );
        doit( IRP_CONTEXT, Flags );
        doit( IRP_CONTEXT, State );
        doit( IRP_CONTEXT, ExceptionStatus );
        doit( IRP_CONTEXT, TransactionId );
        doit( IRP_CONTEXT, MajorFunction );
        doit( IRP_CONTEXT, MinorFunction );
        doit( IRP_CONTEXT, SharedScbSize );
        doit( IRP_CONTEXT, SharedScb );
        doit( IRP_CONTEXT, CleanupStructure );
        doit( IRP_CONTEXT, Vcb );
        doit( IRP_CONTEXT, OriginatingIrp );
        doit( IRP_CONTEXT, TopLevelIrpContext );
        doit( IRP_CONTEXT, TopLevelContext );
        doit( IRP_CONTEXT, ExclusiveFcbList );
        doit( IRP_CONTEXT, RecentlyDeallocatedQueue );
        doit( IRP_CONTEXT, DeallocatedClusters );
        doit( IRP_CONTEXT, LastRestartArea );
        doit( IRP_CONTEXT, FreeClusterChange );
        doit( IRP_CONTEXT, Union.NtfsIoContext );
        doit( IRP_CONTEXT, Union.AuxiliaryBuffer );
        doit( IRP_CONTEXT, Union.SubjectContext );
        doit( IRP_CONTEXT, Union.OplockCleanup );
        doit( IRP_CONTEXT, Union.PostSpecialCallout );
        doit( IRP_CONTEXT, CheckNewLength );
        doit( IRP_CONTEXT, Usn );
        doit( IRP_CONTEXT, SourceInfo );
        doit( IRP_CONTEXT, ScbSnapshot );
        doit( IRP_CONTEXT, EncryptionFileDirFlags );
        doit( IRP_CONTEXT, EfsCreateContext );
        doit( IRP_CONTEXT, CacheCount );
        doit( IRP_CONTEXT, FileRecordCache );
        doit( IRP_CONTEXT, WorkQueueItem );
    }
    printf("\n");
    {
        TOP_LEVEL_CONTEXT d;
        doit( TOP_LEVEL_CONTEXT, TopLevelRequest );
        doit( TOP_LEVEL_CONTEXT, ValidSavedTopLevel );
        doit( TOP_LEVEL_CONTEXT, OverflowReadThread );
        doit( TOP_LEVEL_CONTEXT, Ntfs );
        doit( TOP_LEVEL_CONTEXT, VboBeingHotFixed );
        doit( TOP_LEVEL_CONTEXT, ScbBeingHotFixed );
        doit( TOP_LEVEL_CONTEXT, SavedTopLevelIrp );
        doit( TOP_LEVEL_CONTEXT, TopLevelIrpContext );
    }
    printf("\n");
    {
        FOUND_ATTRIBUTE d;
        doit( FOUND_ATTRIBUTE, MftFileOffset );
        doit( FOUND_ATTRIBUTE, Attribute );
        doit( FOUND_ATTRIBUTE, FileRecord );
        doit( FOUND_ATTRIBUTE, Bcb );
        doit( FOUND_ATTRIBUTE, AttributeDeleted );
    }
    printf("\n");
    {
        ATTRIBUTE_LIST_CONTEXT d;
        doit( ATTRIBUTE_LIST_CONTEXT, Entry );
        doit( ATTRIBUTE_LIST_CONTEXT, Bcb );
        doit( ATTRIBUTE_LIST_CONTEXT, AttributeList );
        doit( ATTRIBUTE_LIST_CONTEXT, FirstEntry );
        doit( ATTRIBUTE_LIST_CONTEXT, BeyondFinalEntry );
        doit( ATTRIBUTE_LIST_CONTEXT, NonresidentListBcb );
    }
    printf("\n");
    {
        ATTRIBUTE_ENUMERATION_CONTEXT d;
        doit( ATTRIBUTE_ENUMERATION_CONTEXT, FoundAttribute );
        doit( ATTRIBUTE_ENUMERATION_CONTEXT, AttributeList );
    }
    printf("\n");
    {
        INDEX_LOOKUP_STACK d;
        doit( INDEX_LOOKUP_STACK, Bcb );
        doit( INDEX_LOOKUP_STACK, StartOfBuffer );
        doit( INDEX_LOOKUP_STACK, IndexHeader );
        doit( INDEX_LOOKUP_STACK, IndexEntry );
        doit( INDEX_LOOKUP_STACK, IndexBlock );
        doit( INDEX_LOOKUP_STACK, CapturedLsn );
    }
    printf("\n");
    {
        INDEX_CONTEXT d;
        doit( INDEX_CONTEXT, AttributeContext );
        doit( INDEX_CONTEXT, Base );
        doit( INDEX_CONTEXT, Top );
        doit( INDEX_CONTEXT, LookupStack );
        doit( INDEX_CONTEXT, Current );
        doit( INDEX_CONTEXT, ScbChangeCount );
        doit( INDEX_CONTEXT, OldAttribute );
        doit( INDEX_CONTEXT, NumberEntries );
        doit( INDEX_CONTEXT, Flags );
        doit( INDEX_CONTEXT, AcquiredFcb );
        doit( INDEX_CONTEXT, Unused );
    }
    printf("\n");
    {
        NTFS_IO_CONTEXT d;
        doit( NTFS_IO_CONTEXT, IrpCount );
        doit( NTFS_IO_CONTEXT, MasterIrp );
        doit( NTFS_IO_CONTEXT, IrpSpFlags );
        doit( NTFS_IO_CONTEXT, AllocatedContext );
        doit( NTFS_IO_CONTEXT, PagingIo );
        doit( NTFS_IO_CONTEXT, Wait.Async.Resource );
        doit( NTFS_IO_CONTEXT, Wait.Async.ResourceThreadId );
        doit( NTFS_IO_CONTEXT, Wait.Async.RequestedByteCount );
        doit( NTFS_IO_CONTEXT, Wait.SyncEvent );
    }
    printf("\n");
    {
        IO_RUN d;
        doit( IO_RUN, StartingVbo );
        doit( IO_RUN, StartingLbo );
        doit( IO_RUN, BufferOffset );
        doit( IO_RUN, ByteCount );
        doit( IO_RUN, SavedIrp );
        doit( IO_RUN, Unused );
    }
    printf("\n");
    {
        NTFS_NAME_DESCRIPTOR d;
        doit( NTFS_NAME_DESCRIPTOR, FieldsPresent );
        doit( NTFS_NAME_DESCRIPTOR, FileName );
        doit( NTFS_NAME_DESCRIPTOR, AttributeType );
        doit( NTFS_NAME_DESCRIPTOR, AttributeName );
        doit( NTFS_NAME_DESCRIPTOR, VersionNumber );
    }
    printf("\n");
    {
        EA_LIST_HEADER d;
        doit( EA_LIST_HEADER, PackedEaSize );
        doit( EA_LIST_HEADER, NeedEaCount );
        doit( EA_LIST_HEADER, UnpackedEaSize );
        doit( EA_LIST_HEADER, BufferSize );
        doit( EA_LIST_HEADER, FullEa );
    }
    printf("\n");
    {
        DEALLOCATED_RECORDS d;
        doit( DEALLOCATED_RECORDS, ScbLinks );
        doit( DEALLOCATED_RECORDS, IrpContextLinks );
        doit( DEALLOCATED_RECORDS, Scb );
        doit( DEALLOCATED_RECORDS, NumberOfEntries );
        doit( DEALLOCATED_RECORDS, NextFreeEntry );
        doit( DEALLOCATED_RECORDS, Index );
    }
    printf("\n");
    {
        FCB_TABLE_ELEMENT d;
        doit( FCB_TABLE_ELEMENT, FileReference );
        doit( FCB_TABLE_ELEMENT, Fcb );
    }
    printf("\n");
    {
        SHARED_SECURITY d;
        doit( SHARED_SECURITY, ParentFcb );
        doit( SHARED_SECURITY, ReferenceCount );
        doit( SHARED_SECURITY, SecurityDescriptor );
    }
    printf("\n");
    {
        OLD_SCB_SNAPSHOT d;
        doit( OLD_SCB_SNAPSHOT, AllocationSize );
        doit( OLD_SCB_SNAPSHOT, FileSize );
        doit( OLD_SCB_SNAPSHOT, ValidDataLength );
        doit( OLD_SCB_SNAPSHOT, TotalAllocated );
        doit( OLD_SCB_SNAPSHOT, CompressionUnit );
        doit( OLD_SCB_SNAPSHOT, Resident );
        doit( OLD_SCB_SNAPSHOT, AttributeFlags );
    }
    printf("\n");
    {
        READ_AHEAD_THREAD d;
        doit( READ_AHEAD_THREAD, Links );
        doit( READ_AHEAD_THREAD, Thread );
    }
    printf("\n");
    {
        DEFRAG_MFT d;
        doit( DEFRAG_MFT, WorkQueueItem );
        doit( DEFRAG_MFT, Vcb );
        doit( DEFRAG_MFT, DeallocateWorkItem );
    }
    printf("\n");
    {
        NUKEM d;
        doit( NUKEM, Next );
        doit( NUKEM, RecordNumbers );
    }
    printf("\n");
    {
        NAME_PAIR d;
        doit( NAME_PAIR, Short );
        doit( NAME_PAIR, Long );
        doit( NAME_PAIR, ShortBuffer );
        doit( NAME_PAIR, LongBuffer );
    }
    printf("\n");
    {
        OPLOCK_CLEANUP d;
        doit( OPLOCK_CLEANUP, OriginalFileName );
        doit( OPLOCK_CLEANUP, FullFileName );
        doit( OPLOCK_CLEANUP, ExactCaseName );
        doit( OPLOCK_CLEANUP, FileObject );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\ea.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Ea.c

Abstract:

    This module implements the File set and query Ea routines for Ntfs called
    by the dispatch driver.

Author:

    Your Name       [Email]         dd-Mon-Year

Revision History:

--*/

#include "NtfsProc.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_EA)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('EFtN')

//
//  Local definitions
//

//
//  The following gives us an empty name string.
//

UNICODE_STRING AttrNoName = CONSTANT_UNICODE_STRING( L"" );

#define MAXIMUM_EA_SIZE             0x0000ffff

//
//  The following macros compute the packed and unpacked size of the EAs.
//  We use the 1 char defined in the structure for the NULL terminator of
//  the name.
//

#define SizeOfEaInformation                                         \
    (sizeof( ULONG ) + sizeof( USHORT ) + 3 * sizeof( UCHAR ))

#define PackedEaSize(EA)                                            \
    ((SizeOfEaInformation - 4)                                      \
     + ((PFILE_FULL_EA_INFORMATION) EA)->EaNameLength               \
     + ((PFILE_FULL_EA_INFORMATION) EA)->EaValueLength)

#define RawUnpackedEaSize(EA)                                       \
    (SizeOfEaInformation                                            \
     + ((PFILE_FULL_EA_INFORMATION) EA)->EaNameLength               \
     + ((PFILE_FULL_EA_INFORMATION) EA)->EaValueLength)             \

#define AlignedUnpackedEaSize(EA)                                   \
    (((PFILE_FULL_EA_INFORMATION) EA)->NextEntryOffset != 0         \
     ? ((PFILE_FULL_EA_INFORMATION) EA)->NextEntryOffset            \
     : (LongAlign( RawUnpackedEaSize( EA ))))                       \

//
//  BOOLEAN
//  NtfsAreEaNamesEqual (
//      IN PIRP_CONTEXT IrpContext,
//      IN PSTRING NameA,
//      IN PSTRING NameB
//      );
//

#define NtfsAreEaNamesEqual(NAMEA, NAMEB ) ((BOOLEAN)              \
    ((NAMEA)->Length == (NAMEB)->Length                            \
     && RtlEqualMemory( (NAMEA)->Buffer,                           \
                        (NAMEB)->Buffer,                           \
                        (NAMEA)->Length ) )                        \
)

//
//  VOID
//  NtfsUpcaseEaName (
//      IN PSTRING EaName,
//      OUT PSTRING UpcasedEaName
//      );
//

#define NtfsUpcaseEaName( NAME, UPCASEDNAME )   \
    RtlUpperString( UPCASEDNAME, NAME )

BOOLEAN
NtfsIsEaNameValid (
    IN STRING Name
    );

//
//  Local procedure prototypes
//

VOID
NtfsAppendEa (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PEA_LIST_HEADER EaListHeader,
    IN PFILE_FULL_EA_INFORMATION FullEa,
    IN PVCB Vcb
    );

VOID
NtfsDeleteEa (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PEA_LIST_HEADER EaListHeader,
    IN ULONG Offset
    );

BOOLEAN
NtfsLocateEaByName (
    IN PFILE_FULL_EA_INFORMATION FullEa,
    IN ULONG EaBufferLength,
    IN PSTRING EaName,
    OUT PULONG Offset
    );

IO_STATUS_BLOCK
NtfsQueryEaUserEaList (
    IN PFILE_FULL_EA_INFORMATION CurrentEas,
    IN PEA_INFORMATION EaInformation,
    OUT PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG UserBufferLength,
    IN PFILE_GET_EA_INFORMATION UserEaList,
    IN BOOLEAN ReturnSingleEntry
    );

IO_STATUS_BLOCK
NtfsQueryEaIndexSpecified (
    OUT PCCB Ccb,
    IN PFILE_FULL_EA_INFORMATION CurrentEas,
    IN PEA_INFORMATION EaInformation,
    OUT PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG UserBufferLength,
    IN ULONG UserEaIndex,
    IN BOOLEAN ReturnSingleEntry
    );

IO_STATUS_BLOCK
NtfsQueryEaSimpleScan (
    OUT PCCB Ccb,
    IN PFILE_FULL_EA_INFORMATION CurrentEas,
    IN PEA_INFORMATION EaInformation,
    OUT PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG UserBufferLength,
    IN BOOLEAN ReturnSingleEntry,
    IN ULONG StartingOffset
    );

BOOLEAN
NtfsIsDuplicateGeaName (
    IN PFILE_GET_EA_INFORMATION CurrentGea,
    IN PFILE_GET_EA_INFORMATION UserGeaBuffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAppendEa)
#pragma alloc_text(PAGE, NtfsBuildEaList)
#pragma alloc_text(PAGE, NtfsCommonQueryEa)
#pragma alloc_text(PAGE, NtfsCommonSetEa)
#pragma alloc_text(PAGE, NtfsDeleteEa)
#pragma alloc_text(PAGE, NtfsIsDuplicateGeaName)
#pragma alloc_text(PAGE, NtfsIsEaNameValid)
#pragma alloc_text(PAGE, NtfsLocateEaByName)
#pragma alloc_text(PAGE, NtfsMapExistingEas)
#pragma alloc_text(PAGE, NtfsQueryEaIndexSpecified)
#pragma alloc_text(PAGE, NtfsQueryEaSimpleScan)
#pragma alloc_text(PAGE, NtfsQueryEaUserEaList)
#pragma alloc_text(PAGE, NtfsReplaceFileEas)
#endif


NTSTATUS
NtfsCommonQueryEa (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for query Ea called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    PFILE_FULL_EA_INFORMATION MappedEaBuffer = NULL;
    ULONG UserBufferLength;
    PFILE_GET_EA_INFORMATION UserEaList;
    ULONG UserEaListLength;
    ULONG UserEaIndex;
    ULONG EaLength;
    BOOLEAN RestartScan;
    BOOLEAN ReturnSingleEntry;
    BOOLEAN IndexSpecified;
    BOOLEAN TempBufferAllocated = FALSE;
    
    PFILE_FULL_EA_INFORMATION CurrentEas;
    PBCB EaBcb;

    ATTRIBUTE_ENUMERATION_CONTEXT EaInfoAttr;
    BOOLEAN CleanupEaInfoAttr;
    PEA_INFORMATION EaInformation;
    EA_INFORMATION DummyEaInformation;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonQueryEa\n") );
    DebugTrace( 0, Dbg, ("IrpContext         = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp                = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("SystemBuffer       = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );
    DebugTrace( 0, Dbg, ("Length             = %08lx\n", IrpSp->Parameters.QueryEa.Length) );
    DebugTrace( 0, Dbg, ("EaList             = %08lx\n", IrpSp->Parameters.QueryEa.EaList) );
    DebugTrace( 0, Dbg, ("EaListLength       = %08lx\n", IrpSp->Parameters.QueryEa.EaListLength) );
    DebugTrace( 0, Dbg, ("EaIndex            = %08lx\n", IrpSp->Parameters.QueryEa.EaIndex) );
    DebugTrace( 0, Dbg, ("RestartScan        = %08lx\n", FlagOn(IrpSp->Flags, SL_RESTART_SCAN)) );
    DebugTrace( 0, Dbg, ("ReturnSingleEntry  = %08lx\n", FlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY)) );
    DebugTrace( 0, Dbg, ("IndexSpecified     = %08lx\n", FlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED)) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  This must be a user file or directory and the Ccb must indicate that
    //  the caller opened the entire file.
    //

    if ((TypeOfOpen != UserFileOpen && TypeOfOpen != UserDirectoryOpen) ||
        !FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsCommonQueryEa -> %08lx\n", STATUS_INVALID_PARAMETER) );

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire the Fcb exclusively.
    //

    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

    //
    //  If this file is a reparse point it cannot support EAs.
    //  Return to caller STATUS_EAS_NOT_SUPPORTED.
    //

    if (FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

        DebugTrace( 0, Dbg, ("Reparse point present. EAs not supported.\n") );
        Status = STATUS_EAS_NOT_SUPPORTED;

        //
        //  Release the Fcb and return to caller.
        //

        NtfsReleaseFcb( IrpContext, Fcb );

        NtfsCompleteRequest( IrpContext, Irp, Status );
        DebugTrace( -1, Dbg, ("NtfsCommonQueryEa -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Make sure the volume is still mounted.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

        DebugTrace( 0, Dbg, ("Volume dismounted.\n") );
        Status = STATUS_VOLUME_DISMOUNTED;

        //
        //  Release the Fcb and return to caller.
        //

        NtfsReleaseFcb( IrpContext, Fcb );

        NtfsCompleteRequest( IrpContext, Irp, Status );
        DebugTrace( -1, Dbg, ("NtfsCommonQueryEa -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Reference our input parameters to make things easier
        //

        UserBufferLength = IrpSp->Parameters.QueryEa.Length;
        UserEaList = (PFILE_GET_EA_INFORMATION) IrpSp->Parameters.QueryEa.EaList;
        UserEaListLength = IrpSp->Parameters.QueryEa.EaListLength;
        UserEaIndex = IrpSp->Parameters.QueryEa.EaIndex;
        RestartScan = BooleanFlagOn(IrpSp->Flags, SL_RESTART_SCAN);
        ReturnSingleEntry = BooleanFlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY);
        IndexSpecified = BooleanFlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED);

        //
        //  Initialize our local variables.
        //

        Status = STATUS_SUCCESS;
        CleanupEaInfoAttr = FALSE;
        EaBcb = NULL;

        //
        //  Map the user's buffer.
        //

        if (UserBufferLength != 0) {

            EaBuffer = NtfsMapUserBuffer( Irp );

            // 
            // Allocate a system buffer to work on, out of paranoia.
            // This buffer will get zeroed later before we actually use it.
            //

            if (Irp->RequestorMode != KernelMode) {

                MappedEaBuffer = EaBuffer;
                EaBuffer = NtfsAllocatePool( PagedPool, UserBufferLength );
                TempBufferAllocated = TRUE;
            } 

            //
            //  Let's clear the output buffer.
            //
    
            RtlZeroMemory( EaBuffer, UserBufferLength );
        }

        //
        //  Verify that the Ea file is in a consistant state.  If the
        //  Ea modification count in the Fcb doesn't match that in
        //  the CCB, then the Ea file has been changed from under
        //  us.  If we are not starting the search from the beginning
        //  of the Ea set, we return an error.
        //

        if ((UserEaList == NULL) && 
            (Ccb->NextEaOffset != 0) &&
            !IndexSpecified &&
            !RestartScan && 
            (Fcb->EaModificationCount != Ccb->EaModificationCount)) {

            DebugTrace( 0, Dbg, ("NtfsCommonQueryEa:  Ea file in unknown state\n") );

            Status = STATUS_EA_CORRUPT_ERROR;

            try_return( Status );
        }

        //
        //  Show that the Ea's for this file are consistant for this
        //  file handle.
        //

        Ccb->EaModificationCount = Fcb->EaModificationCount;

        //
        //  We need to look up the attribute for the Ea information.
        //  If we don't find the attribute, then there are no EA's for
        //  this file.  In that case we dummy up an ea list to use below.
        //

        NtfsInitializeAttributeContext( &EaInfoAttr );

        CleanupEaInfoAttr = TRUE;

        {
            BOOLEAN EasOnFile;

            EasOnFile = FALSE;

            if (NtfsLookupAttributeByCode( IrpContext,
                                           Fcb,
                                           &Fcb->FileReference,
                                           $EA_INFORMATION,
                                           &EaInfoAttr)) {

                //
                //  As a sanity check we will check that the unpacked length is
                //  non-zero.  It should always be so.
                //

                EaInformation = (PEA_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &EaInfoAttr ));

                if (EaInformation->UnpackedEaSize != 0) {

                    EasOnFile = TRUE;
                }
            }

            if (EasOnFile) {

                //
                //  We obtain a pointer to the start of the existing Ea's for the file.
                //

                CurrentEas = NtfsMapExistingEas( IrpContext,
                                                 Fcb,
                                                 &EaBcb,
                                                 &EaLength );

            } else {

                CurrentEas = NULL;
                EaLength = 0;

                DummyEaInformation.PackedEaSize = 0;
                DummyEaInformation.NeedEaCount = 0;
                DummyEaInformation.UnpackedEaSize = 0;

                EaInformation = &DummyEaInformation;
            }
        }

        //
        //  We now satisfy the user's request depending on whether he
        //  specified an Ea name list, an Ea index or restarting the
        //  search.
        //

        //
        //  The user has supplied a list of Ea names.
        //

        if (UserEaList != NULL) {

            Irp->IoStatus = NtfsQueryEaUserEaList( CurrentEas,
                                                   EaInformation,
                                                   EaBuffer,
                                                   UserBufferLength,
                                                   UserEaList,
                                                   ReturnSingleEntry );

        //
        //  The user supplied an index into the Ea list.
        //

        } else if (IndexSpecified) {

            Irp->IoStatus = NtfsQueryEaIndexSpecified( Ccb,
                                                       CurrentEas,
                                                       EaInformation,
                                                       EaBuffer,
                                                       UserBufferLength,
                                                       UserEaIndex,
                                                       ReturnSingleEntry );

        //
        //  Else perform a simple scan, taking into account the restart
        //  flag and the position of the next Ea stored in the Ccb.
        //

        } else {

            Irp->IoStatus = NtfsQueryEaSimpleScan( Ccb,
                                                   CurrentEas,
                                                   EaInformation,
                                                   EaBuffer,
                                                   UserBufferLength,
                                                   ReturnSingleEntry,
                                                   RestartScan
                                                   ? 0
                                                   : Ccb->NextEaOffset );
        }

        Status = Irp->IoStatus.Status;

        //
        // Copy the data onto the user buffer if we ended up allocating
        // a temporary buffer to work on.
        //

        if ((UserBufferLength != 0) && (MappedEaBuffer != NULL)) {

            try {
        
                RtlCopyMemory( MappedEaBuffer, EaBuffer, UserBufferLength );
                
            } except( EXCEPTION_EXECUTE_HANDLER ) {

                try_return( Status = STATUS_INVALID_USER_BUFFER );
            }
        }

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsCommonQueryEa );

        //
        //  We cleanup any attribute contexts.
        //

        if (CleanupEaInfoAttr) {

            NtfsCleanupAttributeContext( IrpContext, &EaInfoAttr );
        }

        //
        //  Unpin the stream file if pinned.
        //

        NtfsUnpinBcb( IrpContext, &EaBcb );

        //
        //  Release the Fcb.
        //

        NtfsReleaseFcb( IrpContext, Fcb );

        if (TempBufferAllocated) {

            NtfsFreePool( EaBuffer );
        }
        
        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

        //
        //  And return to our caller
        //

        DebugTrace( -1, Dbg, ("NtfsCommonQueryEa -> %08lx\n", Status) );
    }

    return Status;
}


NTSTATUS
NtfsCommonSetEa (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for set Ea called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ULONG Offset;

    ATTRIBUTE_ENUMERATION_CONTEXT EaInfoAttr;
    PEA_INFORMATION EaInformation;
    PFILE_FULL_EA_INFORMATION SafeBuffer = NULL;
    
    BOOLEAN PreviousEas;

    EA_LIST_HEADER EaList;

    PBCB EaBcb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    NtfsInitializeAttributeContext( &EaInfoAttr );

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonSetEa\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  Initialize the IoStatus values.
    //

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    //  Check that the file object is associated with either a user file or
    //  user directory open or an open by file ID.
    //

    if ((Ccb == NULL) ||
        !FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE ) ||
        ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen))) {

        DebugTrace( 0, Dbg, ("Invalid file object\n") );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsCommonSetEa -> %08lx\n", STATUS_INVALID_PARAMETER) );

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We must be writable.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        Status = STATUS_MEDIA_WRITE_PROTECTED;
        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( -1, Dbg, ("NtfsCommonSetEa -> %08lx\n", Status) );

        return Status;
    }

    //
    //  We must be waitable.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        Status = NtfsPostRequest( IrpContext, Irp );

        DebugTrace( -1, Dbg, ("NtfsCommonSetEa -> %08lx\n", Status) );
        return Status;
    }

    //
    //  Acquire the paging file resource.  We need to protect ourselves against collided
    //  page waits in the case where we need to do a ConvertToNonresident in this path.
    //  If we acquire the main and then take the fault we can see the deadlock.  Acquire
    //  the paging io resource to lock everyone else out.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
    NtfsAcquireFcbWithPaging( IrpContext, Fcb, 0 );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        ULONG UserBufferLength;
        PFILE_FULL_EA_INFORMATION Buffer;

        PFILE_FULL_EA_INFORMATION CurrentEas;

        //
        //  Reference the input parameters and initialize our local variables.
        //

        UserBufferLength = IrpSp->Parameters.SetEa.Length;

        EaBcb = NULL;
        Offset = 0;

        EaList.FullEa = NULL;

        
        //
        //  If this file is a reparse point one cannot establish an EA in it.
        //  Return to caller STATUS_EAS_NOT_SUPPORTED.
        //
    
        if (FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {
    
            DebugTrace( 0, Dbg, ("Reparse point present, cannot set EA.\n") );
            Status = STATUS_EAS_NOT_SUPPORTED;
            leave;
        }
    
        //
        //  Make sure the volume is still mounted.
        //
    
        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {
    
            DebugTrace( 0, Dbg, ("Volume dismounted.\n") );
            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }
    
        //
        //  Map the user's Ea buffer.
        //

        Buffer = NtfsMapUserBuffer( Irp );

        if (UserBufferLength != 0) {

            // 
            // Be paranoid and copy the user buffer into kernel space.
            //

            if (Irp->RequestorMode != KernelMode) {

                SafeBuffer = NtfsAllocatePool( PagedPool, UserBufferLength );

                try {

                    RtlCopyMemory( SafeBuffer, Buffer, UserBufferLength );

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    try_return( Status = STATUS_INVALID_USER_BUFFER );
                }

                Buffer = SafeBuffer;
            }
        }

        //
        //  Check the user's buffer for validity.
        //

        {
            ULONG ErrorOffset;

            Status = IoCheckEaBufferValidity( Buffer,
                                              UserBufferLength,
                                              &ErrorOffset );

            if (!NT_SUCCESS( Status )) {

                Irp->IoStatus.Information = ErrorOffset;
                try_return( Status );
            }
        }

        //
        //  Check if the file has existing Ea's.
        //

        if (NtfsLookupAttributeByCode( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       $EA_INFORMATION,
                                       &EaInfoAttr)) {

            PreviousEas = TRUE;

            EaInformation = (PEA_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &EaInfoAttr ));

        } else {

            PreviousEas = FALSE;
        }

        //
        //  Sanity check.
        //

        ASSERT( !PreviousEas || EaInformation->UnpackedEaSize != 0 );

        //
        //  Initialize our Ea list structure depending on whether there
        //  were previous Ea's or not.
        //

        if (PreviousEas) {

            //
            //  Copy the information out of the Ea information attribute.
            //

            EaList.PackedEaSize = (ULONG) EaInformation->PackedEaSize;
            EaList.NeedEaCount = EaInformation->NeedEaCount;
            EaList.UnpackedEaSize = EaInformation->UnpackedEaSize;

            CurrentEas = NtfsMapExistingEas( IrpContext,
                                             Fcb,
                                             &EaBcb,
                                             &EaList.BufferSize );

            //
            //  The allocated size of the Ea buffer is the Unpacked length.
            //

            EaList.FullEa = NtfsAllocatePool(PagedPool, EaList.BufferSize );

            //
            //  Now copy the mapped Eas.
            //

            RtlCopyMemory( EaList.FullEa,
                           CurrentEas,
                           EaList.BufferSize );

            //
            //  Upin the stream file.
            //

            NtfsUnpinBcb( IrpContext, &EaBcb );

        } else {

            //
            //  Set this up as an empty list.
            //

            EaList.PackedEaSize = 0;
            EaList.NeedEaCount = 0;
            EaList.UnpackedEaSize = 0;
            EaList.BufferSize = 0;
            EaList.FullEa = NULL;
        }

        //
        //  Build the new ea list.
        //

        Status = NtfsBuildEaList( IrpContext,
                                  Vcb,
                                  &EaList,
                                  Buffer,
                                  &Irp->IoStatus.Information );

        if (!NT_SUCCESS( Status )) {

            try_return( Status );
        }

        //
        //  Replace the existing Eas.
        //

        NtfsReplaceFileEas( IrpContext, Fcb, &EaList );

        //
        //  Increment the Modification count for the Eas.
        //

        Fcb->EaModificationCount++;

        //
        //  Update the information in the duplicate information and mark
        //  the Fcb as info modified.
        //

        if (EaList.UnpackedEaSize == 0) {

            Fcb->Info.PackedEaSize = 0;

        } else {

            Fcb->Info.PackedEaSize = (USHORT) EaList.PackedEaSize;
        }

        //
        //  Update the caller's Iosb.
        //

        Irp->IoStatus.Information = 0;
        Status = STATUS_SUCCESS;

    try_exit:  NOTHING;

        //
        //  Check if there are transactions to cleanup.
        //

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

        //
        //  Show that we changed the Ea's and also set the Ccb flag so we will
        //  update the time stamps.
        //

        SetFlag( Ccb->Flags,
                 CCB_FLAG_UPDATE_LAST_CHANGE | CCB_FLAG_SET_ARCHIVE );

    } finally {

        DebugUnwind( NtfsCommonSetEa );

        //
        //  Free the in-memory copy of the Eas.
        //

        if (EaList.FullEa != NULL) {

            NtfsFreePool( EaList.FullEa );
        }

        //
        //  Unpin the Bcb.
        //

        NtfsUnpinBcb( IrpContext, &EaBcb );

        //
        //  Cleanup any attribute contexts used.
        //

        NtfsCleanupAttributeContext( IrpContext, &EaInfoAttr );

        //
        // If we allocated a temporary buffer, free it.
        //

        if (SafeBuffer != NULL) {

            NtfsFreePool( SafeBuffer );
        }

        DebugTrace( -1, Dbg, ("NtfsCommonSetEa -> %08lx\n", Status) );
    }
    
    //
    //  Complete the Irp.
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

VOID
NtfsAppendEa (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PEA_LIST_HEADER EaListHeader,
    IN PFILE_FULL_EA_INFORMATION FullEa,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine appends a new packed ea onto an existing ea list,
    it also will allocate/dealloate pool as necessary to hold the ea list.

Arguments:

    EaListHeader - Supplies a pointer the Ea list header structure.

    FullEa - Supplies a pointer to the new full ea that is to be appended
             to the ea list.

    Vcb - Vcb for this volume.

Return Value:

    None.

--*/

{
    ULONG UnpackedEaLength;
    STRING EaName;
    PFILE_FULL_EA_INFORMATION ThisEa;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAppendEa...\n") );

    UnpackedEaLength = AlignedUnpackedEaSize( FullEa );

    //
    //  As a quick check see if the computed packed ea size plus the
    //  current ea list size will overflow the buffer.
    //

    if (UnpackedEaLength + EaListHeader->UnpackedEaSize > EaListHeader->BufferSize) {

        //
        //  We will overflow our current work buffer so allocate a larger
        //  one and copy over the current buffer
        //

        PVOID Temp;
        ULONG NewAllocationSize;

        DebugTrace( 0, Dbg, ("Allocate a new ea list buffer\n") );

        //
        //  Compute a new size and allocate space.  Always increase the
        //  allocation in cluster increments.
        //

        NewAllocationSize = ClusterAlign( Vcb,
                                          UnpackedEaLength
                                          + EaListHeader->UnpackedEaSize );

        Temp = NtfsAllocatePool(PagedPool, NewAllocationSize );

        //
        //  Move over the existing ea list and zero the remaining space.
        //

        RtlCopyMemory( Temp,
                       EaListHeader->FullEa,
                       EaListHeader->BufferSize );

        RtlZeroMemory( Add2Ptr( Temp, EaListHeader->BufferSize ),
                       NewAllocationSize - EaListHeader->BufferSize );

        //
        //  Deallocate the current Ea list and use the freshly allocated list.
        //

        if (EaListHeader->FullEa != NULL) {

            NtfsFreePool( EaListHeader->FullEa );
        }

        EaListHeader->FullEa = Temp;

        EaListHeader->BufferSize = NewAllocationSize;
    }

    //
    //  Determine if we need to increment our need ea changes count
    //

    if (FlagOn( FullEa->Flags, FILE_NEED_EA )) {

        EaListHeader->NeedEaCount += 1;
    }

    //
    //  Now copy over the ea.
    //
    //  Before:
    //             UsedSize                     Allocated
    //                |                             |
    //                V                             V
    //      +xxxxxxxx+-----------------------------+
    //
    //  After:
    //                              UsedSize    Allocated
    //                                 |            |
    //                                 V            V
    //      +xxxxxxxx+yyyyyyyyyyyyyyyy+------------+
    //

    ThisEa = (PFILE_FULL_EA_INFORMATION) Add2Ptr( EaListHeader->FullEa,
                                                  EaListHeader->UnpackedEaSize );

    RtlCopyMemory( ThisEa,
                   FullEa,
                   UnpackedEaLength );

    //
    //  We always store the offset of this Ea in the next entry offset field.
    //

    ThisEa->NextEntryOffset = UnpackedEaLength;

    //
    //  Upcase the name.
    //

    EaName.MaximumLength = EaName.Length = ThisEa->EaNameLength;
    EaName.Buffer = &ThisEa->EaName[0];

    NtfsUpcaseEaName( &EaName, &EaName );

    //
    //  Increment the used size in the ea list structure
    //

    EaListHeader->UnpackedEaSize += UnpackedEaLength;
    EaListHeader->PackedEaSize += PackedEaSize( FullEa );

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsAppendEa -> VOID\n") );

    return;

    UNREFERENCED_PARAMETER( IrpContext );
}


//
//  Local support routine
//

VOID
NtfsDeleteEa (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PEA_LIST_HEADER EaListHeader,
    IN ULONG Offset
    )

/*++

Routine Description:

    This routine deletes an individual packed ea from the supplied
    ea list.

Arguments:

    EaListHeader - Supplies a pointer to the Ea list header structure.

    Offset - Supplies the offset to the individual ea in the list to delete

Return Value:

    None.

--*/

{
    PFILE_FULL_EA_INFORMATION ThisEa;
    ULONG UnpackedEaLength;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeletePackedEa, Offset = %08lx\n", Offset) );

    //
    //  Get a reference to the Ea to delete.
    //

    ThisEa = Add2Ptr( EaListHeader->FullEa, Offset );

    //
    //  Determine if we need to decrement our need ea changes count
    //

    if (FlagOn( ThisEa->Flags, FILE_NEED_EA )) {

        EaListHeader->NeedEaCount--;
    }

    //
    //  Decrement the Ea size values.
    //

    EaListHeader->PackedEaSize -= PackedEaSize( ThisEa );

    UnpackedEaLength = AlignedUnpackedEaSize( ThisEa );
    EaListHeader->UnpackedEaSize -= UnpackedEaLength;

    //
    //  Shrink the ea list over the deleted ea.  The amount to copy is the
    //  total size of the ea list minus the offset to the end of the ea
    //  we're deleting.
    //
    //  Before:
    //              Offset    Offset+UnpackedEaLength  UsedSize    Allocated
    //                |                |                  |            |
    //                V                V                  V            V
    //      +xxxxxxxx+yyyyyyyyyyyyyyyy+zzzzzzzzzzzzzzzzzz+------------+
    //
    //  After
    //              Offset            UsedSize                     Allocated
    //                |                  |                             |
    //                V                  V                             V
    //      +xxxxxxxx+zzzzzzzzzzzzzzzzzz+-----------------------------+
    //

    RtlMoveMemory( ThisEa,
                   Add2Ptr( ThisEa, ThisEa->NextEntryOffset ),
                   EaListHeader->UnpackedEaSize - Offset );

    //
    //  And zero out the remaing part of the ea list, to make things
    //  nice and more robust
    //

    RtlZeroMemory( Add2Ptr( EaListHeader->FullEa, EaListHeader->UnpackedEaSize ),
                   UnpackedEaLength );

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsDeleteEa -> VOID\n") );

    return;

    UNREFERENCED_PARAMETER( IrpContext );
}


//
//  Local support routine
//

BOOLEAN
NtfsLocateEaByName (
    IN PFILE_FULL_EA_INFORMATION FullEa,
    IN ULONG EaBufferLength,
    IN PSTRING EaName,
    OUT PULONG Offset
    )

/*++

Routine Description:

    This routine locates the offset for the next individual packed ea
    inside of a ea list, given the name of the ea to locate.

Arguments:

    FullEa - Pointer to the first Ea to look at.

    EaBufferLength - This is the ulong-aligned size of the Ea buffer.

    EaName - Supplies the name of the ea search for

    Offset - Receives the offset to the located individual ea in the list
        if one exists.

Return Value:

    BOOLEAN - TRUE if the named ea exists in the list and FALSE
        otherwise.

--*/

{
    PFILE_FULL_EA_INFORMATION ThisEa;
    STRING Name;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsLocateEaByName, EaName = %Z\n", EaName) );

    //
    //  If the Ea list is NULL, there is nothing to do.
    //

    if (FullEa == NULL) {

        DebugTrace( -1, Dbg, ("NtfsLocateEaByName:  No work to do\n") );
        return FALSE;
    }

    //
    //  For each ea in the list check its name against the
    //  ea name we're searching for
    //

    *Offset = 0;

    //
    //  We assume there is at least one Ea in the list.
    //

    do {

        ThisEa = Add2Ptr( FullEa, *Offset );

        //
        //  Make a string out of the name in the Ea and compare it to the
        //  given string.
        //

        RtlInitString( &Name, &ThisEa->EaName[0] );

        if ( RtlCompareString( EaName, &Name, TRUE ) == 0 ) {

            DebugTrace( -1, Dbg, ("NtfsLocateEaByName -> TRUE, *Offset = %08lx\n", *Offset) );
            return TRUE;
        }

        //
        //  Update the offset to get to the next Ea.
        //

        *Offset += AlignedUnpackedEaSize( ThisEa );

    } while ( *Offset < EaBufferLength );

    //
    //  We've exhausted the ea list without finding a match so return false
    //

    DebugTrace( -1, Dbg, ("NtfsLocateEaByName -> FALSE\n") );
    return FALSE;
}


//
//  Local support routine.
//

PFILE_FULL_EA_INFORMATION
NtfsMapExistingEas (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    OUT PBCB *EaBcb,
    OUT PULONG EaLength
    )

/*++

Routine Description:

    This routine maps the current Eas for the file, either through the
    Mft record for the file if resident or the Scb for the non-resident
    Eas.

Arguments:

    Fcb - Pointer to the Fcb for the file whose Ea's are being queried.

    EaBcb - Pointer to the Bcb to use if we are mapping data in the
        Ea attribute stream file.

    EaLength - Returns the length of the unpacked Eas in bytes.

Return Value:

    PFILE_FULL_EA_INFORMATION - Pointer to the mapped attributes.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PFILE_FULL_EA_INFORMATION CurrentEas;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsMapExistingEas:  Entered\n") );

    //
    //  We start by looking up the Ea attribute.  It better be there.
    //

    NtfsInitializeAttributeContext( &Context );

    if (!NtfsLookupAttributeByCode( IrpContext,
                                    Fcb,
                                    &Fcb->FileReference,
                                    $EA,
                                    &Context )) {

        //
        //  This is a disk corrupt error.
        //

        DebugTrace( -1, Dbg, ("NtfsMapExistingEas:  Corrupt disk\n") );

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
    }

    try {

        NtfsMapAttributeValue( IrpContext,
                               Fcb,
                               (PVOID *)&CurrentEas,
                               EaLength,
                               EaBcb,
                               &Context );

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    DebugTrace( -1, Dbg, ("NtfsMapExistingEas:  Exit\n") );

    return CurrentEas;
}


//
//  Local support routine.
//

IO_STATUS_BLOCK
NtfsQueryEaUserEaList (
    IN PFILE_FULL_EA_INFORMATION CurrentEas,
    IN PEA_INFORMATION EaInformation,
    OUT PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG UserBufferLength,
    IN PFILE_GET_EA_INFORMATION UserEaList,
    IN BOOLEAN ReturnSingleEntry
    )

/*++

Routine Description:

    This routine is the work routine for querying EAs given a list
    of Ea's to search for.

Arguments:

    CurrentEas - This is a pointer to the current Eas for the file

    EaInformation - This is a pointer to an Ea information attribute.

    EaBuffer - Supplies the buffer to receive the full eas

    UserBufferLength - Supplies the length, in bytes, of the user buffer

    UserEaList - Supplies the user specified ea name list

    ReturnSingleEntry - Indicates if we are to return a single entry or not

Return Value:

    IO_STATUS_BLOCK - Receives the completion status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;

    ULONG GeaOffset;
    ULONG FeaOffset;
    ULONG Offset;

    PFILE_FULL_EA_INFORMATION LastFullEa;
    PFILE_FULL_EA_INFORMATION NextFullEa;

    PFILE_GET_EA_INFORMATION GetEa;

    BOOLEAN Overflow;
    ULONG PrevEaPadding;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryEaUserEaList:  Entered\n") );

    //
    //  Setup pointer in the output buffer so we can track the Ea being
    //  written to it and the last Ea written.
    //

    LastFullEa = NULL;

    Overflow = FALSE;

    //
    //  Initialize our next offset value.
    //

    GeaOffset = 0;
    Offset = 0;
    PrevEaPadding = 0;

    //
    //  Loop through all the entries in the user's ea list.
    //

    while (TRUE) {

        STRING GeaName;
        STRING OutputEaName;
        ULONG RawEaSize;

        //
        //  Get the next entry in the user's list.
        //

        GetEa = (PFILE_GET_EA_INFORMATION) Add2Ptr( UserEaList, GeaOffset );

        //
        //  Make a string reference to the name and see if we can locate
        //  the ea by name.
        //

        GeaName.MaximumLength = GeaName.Length = GetEa->EaNameLength;
        GeaName.Buffer = &GetEa->EaName[0];

        //
        //  Upcase the name so we can do a case-insensitive compare.
        //

        NtfsUpcaseEaName( &GeaName, &GeaName );

        //
        //  Check for a valid name.
        //

        if (!NtfsIsEaNameValid( GeaName )) {

            DebugTrace( -1, Dbg, ("NtfsQueryEaUserEaList:  Invalid Ea Name\n") );

            Iosb.Information = GeaOffset;
            Iosb.Status = STATUS_INVALID_EA_NAME;
            return Iosb;
        }

        GeaOffset += GetEa->NextEntryOffset;

        //
        //  If this is a duplicate name, then step over this entry.
        //

        if (NtfsIsDuplicateGeaName( GetEa, UserEaList )) {

            //
            //  If we've exhausted the entries in the Get Ea list, then we are
            //  done.
            //

            if (GetEa->NextEntryOffset == 0) {
                break;
            } else {
                continue;
            }
        }

        //
        //  Generate a pointer in the Ea buffer.
        //

        NextFullEa = (PFILE_FULL_EA_INFORMATION) Add2Ptr( EaBuffer, Offset + PrevEaPadding );

        //
        //  Try to find a matching Ea.
        //  If we couldn't, let's dummy up an Ea to give to the user.
        //

        if (!NtfsLocateEaByName( CurrentEas,
                                 EaInformation->UnpackedEaSize,
                                 &GeaName,
                                 &FeaOffset )) {

            //
            //  We were not able to locate the name therefore we must
            //  dummy up a entry for the query.  The needed Ea size is
            //  the size of the name + 4 (next entry offset) + 1 (flags)
            //  + 1 (name length) + 2 (value length) + the name length +
            //  1 (null byte).
            //

            RawEaSize = 4+1+1+2+GetEa->EaNameLength+1;

            if ((RawEaSize + PrevEaPadding) > UserBufferLength) {

                Overflow = TRUE;
                break;
            }

            //
            //  Everything is going to work fine, so copy over the name,
            //  set the name length and zero out the rest of the ea.
            //

            NextFullEa->NextEntryOffset = 0;
            NextFullEa->Flags = 0;
            NextFullEa->EaNameLength = GetEa->EaNameLength;
            NextFullEa->EaValueLength = 0;
            RtlCopyMemory( &NextFullEa->EaName[0],
                           &GetEa->EaName[0],
                           GetEa->EaNameLength );

            //
            //  Upcase the name in the buffer.
            //

            OutputEaName.MaximumLength = OutputEaName.Length = GeaName.Length;
            OutputEaName.Buffer = NextFullEa->EaName;

            NtfsUpcaseEaName( &OutputEaName, &OutputEaName );

            NextFullEa->EaName[GetEa->EaNameLength] = 0;

        //
        //  Otherwise return the Ea we found back to the user.
        //

        } else {

            PFILE_FULL_EA_INFORMATION ThisEa;

            //
            //  Reference this ea.
            //

            ThisEa = (PFILE_FULL_EA_INFORMATION) Add2Ptr( CurrentEas, FeaOffset );

            //
            //  Check if this Ea can fit in the user's buffer.
            //

            RawEaSize = RawUnpackedEaSize( ThisEa );

            if (RawEaSize > (UserBufferLength - PrevEaPadding)) {

                Overflow = TRUE;
                break;
            }

            //
            //  Copy this ea to the user's buffer.
            //

            RtlCopyMemory( NextFullEa,
                           ThisEa,
                           RawEaSize);

            NextFullEa->NextEntryOffset = 0;
        }

        //
        //  Compute the next offset in the user's buffer.
        //

        Offset += (RawEaSize + PrevEaPadding);

        //
        //  If we were to return a single entry then break out of our loop
        //  now
        //

        if (ReturnSingleEntry) {

            break;
        }

        //
        //  If we have a new Ea entry, go back and update the offset field
        //  of the previous Ea entry.
        //

        if (LastFullEa != NULL) {

            LastFullEa->NextEntryOffset = PtrOffset( LastFullEa, NextFullEa );
        }

        //
        //  If we've exhausted the entries in the Get Ea list, then we are
        //  done.
        //

        if (GetEa->NextEntryOffset == 0) {

            break;
        }

        //
        //  Remember this as the previous ea value.  Also update the buffer
        //  length values and the buffer offset values.
        //

        LastFullEa = NextFullEa;
        UserBufferLength -= (RawEaSize + PrevEaPadding);

        //
        //  Now remember the padding bytes needed for this call.
        //

        PrevEaPadding = LongAlign( RawEaSize ) - RawEaSize;
    }

    //
    //  If the Ea information won't fit in the user's buffer, then return
    //  an overflow status.
    //

    if (Overflow) {

        Iosb.Information = 0;
        Iosb.Status = STATUS_BUFFER_OVERFLOW;

    //
    //  Otherwise return the length of the data returned.
    //

    } else {

        //
        //  Return the length of the buffer filled and a success
        //  status.
        //

        Iosb.Information = Offset;
        Iosb.Status = STATUS_SUCCESS;
    }

    DebugTrace( 0, Dbg, ("Status        -> %08lx\n", Iosb.Status) );
    DebugTrace( 0, Dbg, ("Information   -> %08lx\n", Iosb.Information) );
    DebugTrace( -1, Dbg, ("NtfsQueryEaUserEaList:  Exit\n") );

    return Iosb;
}


//
//  Local support routine
//

IO_STATUS_BLOCK
NtfsQueryEaIndexSpecified (
    OUT PCCB Ccb,
    IN PFILE_FULL_EA_INFORMATION CurrentEas,
    IN PEA_INFORMATION EaInformation,
    OUT PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG UserBufferLength,
    IN ULONG UserEaIndex,
    IN BOOLEAN ReturnSingleEntry
    )

/*++

Routine Description:

    This routine is the work routine for querying EAs given an ea index

Arguments:

    Ccb - This is the Ccb for the caller.

    CurrentEas - This is a pointer to the current Eas for the file.

    EaInformation - This is a pointer to an Ea information attribute.

    EaBuffer - Supplies the buffer to receive the full eas

    UserBufferLength - Supplies the length, in bytes, of the user buffer

    UserEaIndex - This is the Index for the first ea to return.  The value
        1 indicates the first ea of the file.

    ReturnSingleEntry - Indicates if we are to return a single entry or not

Return Value:

    IO_STATUS_BLOCK - Receives the completion status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;

    ULONG i;
    ULONG Offset;
    PFILE_FULL_EA_INFORMATION ThisEa;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryEaIndexSpecified:  Entered\n") );

    i = 1;
    Offset = 0;
    ThisEa = NULL;

    //
    //  If the index value is zero, there are no Eas to return.
    //

    if (UserEaIndex == 0
        || EaInformation->UnpackedEaSize == 0) {

        DebugTrace( -1, Dbg, ("NtfsQueryEaIndexSpecified: Non-existant entry\n") );

        Iosb.Information = 0;
        Iosb.Status = STATUS_NONEXISTENT_EA_ENTRY;

        return Iosb;
    }

    //
    //  Walk through the CurrentEas until we find the starting Ea offset.
    //

    while (i < UserEaIndex
           && Offset < EaInformation->UnpackedEaSize) {

        ThisEa = (PFILE_FULL_EA_INFORMATION) Add2Ptr( CurrentEas, Offset );

        Offset += AlignedUnpackedEaSize( ThisEa );

        i += 1;
    }

    if (Offset >= EaInformation->UnpackedEaSize) {

        //
        //  If we just passed the last Ea, we will return STATUS_NO_MORE_EAS.
        //  This is for the caller who may be enumerating the Eas.
        //

        if (i == UserEaIndex) {

            Iosb.Status = STATUS_NO_MORE_EAS;

        //
        //  Otherwise we report that this is a bad ea index.
        //

        } else {

            Iosb.Status = STATUS_NONEXISTENT_EA_ENTRY;
        }

        DebugTrace( -1, Dbg, ("NtfsQueryEaIndexSpecified -> %08lx\n", Iosb.Status) );
        return Iosb;
    }

    //
    //  We now have the offset of the first Ea to return to the user.
    //  We simply call our EaSimpleScan routine to do the actual work.
    //

    Iosb = NtfsQueryEaSimpleScan( Ccb,
                                  CurrentEas,
                                  EaInformation,
                                  EaBuffer,
                                  UserBufferLength,
                                  ReturnSingleEntry,
                                  Offset );

    DebugTrace( -1, Dbg, ("NtfsQueryEaIndexSpecified:  Exit\n") );

    return Iosb;
}


//
//  Local support routine
//

IO_STATUS_BLOCK
NtfsQueryEaSimpleScan (
    OUT PCCB Ccb,
    IN PFILE_FULL_EA_INFORMATION CurrentEas,
    IN PEA_INFORMATION EaInformation,
    OUT PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG UserBufferLength,
    IN BOOLEAN ReturnSingleEntry,
    IN ULONG StartingOffset
    )

/*++

Routine Description:

    This routine is the work routine for querying EAs starting from a given
    offset within the Ea attribute.

Arguments:

    Ccb - This is the Ccb for the caller.

    CurrentEas - This is a pointer to the current Eas for the file.

    EaInformation - This is a pointer to an Ea information attribute.

    EaBuffer - Supplies the buffer to receive the full eas

    UserBufferLength - Supplies the length, in bytes, of the user buffer

    ReturnSingleEntry - Indicates if we are to return a single entry or not

    StartingOffset - Supplies the offset of the first Ea to return

Return Value:

    IO_STATUS_BLOCK - Receives the completion status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;

    PFILE_FULL_EA_INFORMATION LastFullEa;
    PFILE_FULL_EA_INFORMATION NextFullEa;
    PFILE_FULL_EA_INFORMATION ThisEa;

    BOOLEAN BufferOverflow = FALSE;

    ULONG BufferOffset;
    ULONG PrevEaPadding;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryEaSimpleScan:  Entered\n") );

    //
    //  Initialize our Ea pointers and the offsets into the user buffer
    //  and our Ea buffer.
    //

    LastFullEa = NULL;
    BufferOffset = 0;
    PrevEaPadding = 0;

    //
    //  Loop until the Ea offset is beyond the valid range of Eas.
    //

    while (StartingOffset < EaInformation->UnpackedEaSize) {

        ULONG EaSize;

        //
        //  Reference the next EA to return.
        //

        ThisEa = (PFILE_FULL_EA_INFORMATION) Add2Ptr( CurrentEas, StartingOffset);

        //
        //  If the size of this Ea is greater than the remaining buffer size,
        //  we exit the loop.  We need to remember to include any padding bytes
        //  from the previous Eas.
        //

        EaSize = RawUnpackedEaSize( ThisEa );

        if ((EaSize + PrevEaPadding) > UserBufferLength) {

            BufferOverflow = TRUE;
            break;
        }

        //
        //  Copy the Ea into the user's buffer.
        //

        BufferOffset += PrevEaPadding;

        NextFullEa = (PFILE_FULL_EA_INFORMATION) Add2Ptr( EaBuffer, BufferOffset );

        RtlCopyMemory( NextFullEa, ThisEa, EaSize );

        //
        //  Move to the next Ea.
        //

        LastFullEa = NextFullEa;
        UserBufferLength -= (EaSize + PrevEaPadding);
        BufferOffset += EaSize;

        StartingOffset += LongAlign( EaSize );

        //
        //  Remember the padding needed for this entry.
        //

        PrevEaPadding = LongAlign( EaSize ) - EaSize;

        //
        //  If the user only wanted one entry, exit now.
        //

        if (ReturnSingleEntry) {

            break;
        }
    }

    //
    //  If we didn't find any entries, it could be because there were no
    //  more to find or that we ran out of buffer space.
    //

    if (LastFullEa == NULL) {

        Iosb.Information = 0;

        //
        //  We were not able to return a single ea entry, now we need to find
        //  out if it is because we didn't have an entry to return or the
        //  buffer is too small.  If the Offset variable is less than
        //  the size of the Ea attribute, then the user buffer is too small.
        //

        if (EaInformation->UnpackedEaSize == 0) {

            Iosb.Status = STATUS_NO_EAS_ON_FILE;

        } else if (StartingOffset >= EaInformation->UnpackedEaSize) {

            Iosb.Status = STATUS_NO_MORE_EAS;

        } else {

            Iosb.Status = STATUS_BUFFER_TOO_SMALL;
        }

    //
    //  Otherwise we have returned some Ea's.  Update the Iosb to return.
    //

    } else {

        //
        //  Update the Ccb to show where to start the next search.
        //

        Ccb->NextEaOffset = StartingOffset;

        //
        //  Zero the next entry field of the last Ea.
        //

        LastFullEa->NextEntryOffset = 0;

        //
        //  Now update the Iosb.
        //

        Iosb.Information = BufferOffset;

        //
        //  If there are more to return, report the buffer was too small.
        //  Otherwise return STATUS_SUCCESS.
        //

        if (BufferOverflow) {

            Iosb.Status = STATUS_BUFFER_OVERFLOW;

        } else {

            Iosb.Status = STATUS_SUCCESS;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsQueryEaSimpleScan:  Exit\n") );

    return Iosb;
}


//
//  Local support routine
//

BOOLEAN
NtfsIsDuplicateGeaName (
    IN PFILE_GET_EA_INFORMATION GetEa,
    IN PFILE_GET_EA_INFORMATION UserGeaBuffer
    )

/*++

Routine Description:

    This routine walks through a list of Gea names to find a duplicate name.
    'GetEa' is an actual position in the list, 'UserGeaBuffer' is the beginning
    of the list.  We are only interested in
    previous matching ea names, as the ea information for that ea name
    would have been returned with the previous instance.

Arguments:

    GetEa - Supplies the Ea name structure for the ea name to match.

    UserGeaBuffer - Supplies a pointer to the user buffer with the list
        of ea names to search for.

Return Value:

    BOOLEAN - TRUE if a previous match is found, FALSE otherwise.

--*/

{
    BOOLEAN DuplicateFound;
    STRING GeaString;

    PFILE_GET_EA_INFORMATION ThisGetEa;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsIsDuplicateGeaName:  Entered\n") );

    //
    //  Set up the string structure.
    //

    GeaString.MaximumLength = GeaString.Length = GetEa->EaNameLength;
    GeaString.Buffer = &GetEa->EaName[0];

    DuplicateFound = FALSE;

    ThisGetEa = UserGeaBuffer;

    //
    //  We loop until we reach the given Gea or a match is found.
    //

    while (ThisGetEa != GetEa) {

        STRING ThisGea;

        //
        //  Create a string structure for the current Gea.
        //

        ThisGea.MaximumLength = ThisGea.Length = ThisGetEa->EaNameLength;
        ThisGea.Buffer = &ThisGetEa->EaName[0];

        //
        //  Check if the Gea names match, exit if they do.
        //

        if (NtfsAreEaNamesEqual( &GeaString,
                                 &ThisGea )) {

                DuplicateFound = TRUE;
                break;
        }

        //
        //  Move to the next Gea entry.
        //

        ThisGetEa = (PFILE_GET_EA_INFORMATION) Add2Ptr( ThisGetEa,
                                                        ThisGetEa->NextEntryOffset );
    }

    DebugTrace( -1, Dbg, ("NtfsIsDuplicateGeaName:  Exit\n") );

    return DuplicateFound;
}


//
//  Local support routine
//

NTSTATUS
NtfsBuildEaList (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PEA_LIST_HEADER EaListHeader,
    IN PFILE_FULL_EA_INFORMATION UserEaList,
    OUT PULONG_PTR ErrorOffset
    )

/*++

Routine Description:

    This routine is called to build an up-to-date Ea list based on the
    given existing Ea list and the user-specified Ea list.

Arguments:

    Vcb - The Vcb for the volume.

    EaListHeader - This is the Ea list to modify.

    UserEaList - This is the user specified Ea list.

    ErrorOffset - Supplies the address to store the offset of an invalid
        Ea in the user's list.

Return Value:

    NTSTATUS - The result of modifying the Ea list.

--*/

{
    NTSTATUS Status;
    BOOLEAN MoreEas;
    ULONG Offset;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsBuildEaList:  Entered\n") );

    Status = STATUS_SUCCESS;
    Offset = 0;

    //
    //  Now for each full ea in the input user buffer we do the specified operation
    //  on the ea.
    //

    do {

        STRING EaName;
        ULONG EaOffset;

        PFILE_FULL_EA_INFORMATION ThisEa;

        ThisEa = (PFILE_FULL_EA_INFORMATION) Add2Ptr( UserEaList, Offset );

        //
        //  Create a string out of the name in the user's Ea.
        //

        EaName.MaximumLength = EaName.Length = ThisEa->EaNameLength;
        EaName.Buffer = &ThisEa->EaName[0];

        //
        //  If the Ea isn't valid, return error offset to caller.
        //

        if (!NtfsIsEaNameValid( EaName )) {

            *ErrorOffset = Offset;
            Status = STATUS_INVALID_EA_NAME;

            break;
        }

        //
        //  Verify that no invalid ea flags are set.
        //

        if (ThisEa->Flags != 0
            && ThisEa->Flags != FILE_NEED_EA) {

            *ErrorOffset = Offset;
            Status = STATUS_INVALID_EA_NAME;

            break;
        }

        //
        //  If we can find the name in the Ea set, we remove it.
        //

        if (NtfsLocateEaByName( EaListHeader->FullEa,
                                EaListHeader->UnpackedEaSize,
                                &EaName,
                                &EaOffset )) {

            NtfsDeleteEa( IrpContext,
                          EaListHeader,
                          EaOffset );
        }

        //
        //  If the user specified a non-zero value length, we add this
        //  ea to the in memory Ea list.
        //

        if (ThisEa->EaValueLength != 0) {

            NtfsAppendEa( IrpContext,
                          EaListHeader,
                          ThisEa,
                          Vcb );
        }

        //
        //  Move to the next Ea in the list.
        //

        Offset += AlignedUnpackedEaSize( ThisEa );

        MoreEas = (BOOLEAN) (ThisEa->NextEntryOffset != 0);

    } while( MoreEas );

    //
    //  First we check that the packed size of the Eas does not exceed the
    //  maximum value.  We have to reserve the 4 bytes for the OS/2 list
    //  header.
    //

    if (NT_SUCCESS( Status )) {

        if (EaListHeader->PackedEaSize > (MAXIMUM_EA_SIZE - 4)) {

            Status = STATUS_EA_TOO_LARGE;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsBuildEaList:  Exit\n") );

    return Status;
}


//
//  Local support routine
//

VOID
NtfsReplaceFileEas (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PEA_LIST_HEADER EaList
    )

/*++

Routine Description:

    This routine will replace an existing Ea list with a new Ea list.  It
    correctly handles the case where there was no previous Eas and where we
    are removing all of the previous EAs.

Arguments:

    Fcb - Fcb for the file with the EAs

    EaList - This contains the modified Ea list.

Return Value:

    None.

--*/

{
    EA_INFORMATION ThisEaInformation;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PSCB EaScb;
    BOOLEAN EaChange = FALSE;
    BOOLEAN EaScbAcquired = FALSE;


    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReplaceFileEas:  Entered\n") );

    ThisEaInformation.PackedEaSize = (USHORT) EaList->PackedEaSize;
    ThisEaInformation.UnpackedEaSize = EaList->UnpackedEaSize;
    ThisEaInformation.NeedEaCount = EaList->NeedEaCount;

    NtfsInitializeAttributeContext( &Context );

    //
    //  First we handle $EA_INFORMATION and then the $EA attribute in the
    //  same fashion.
    //

    try {

        //
        //  Lookup the $EA_INFORMATION attribute.  If it does not exist then we
        //  will need to create one.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $EA_INFORMATION,
                                        &Context )) {

            if (EaList->UnpackedEaSize != 0) {

                DebugTrace( 0, Dbg, ("Create a new $EA_INFORMATION attribute\n") );

                NtfsCleanupAttributeContext( IrpContext, &Context );
                NtfsInitializeAttributeContext( &Context );

                NtfsCreateAttributeWithValue( IrpContext,
                                              Fcb,
                                              $EA_INFORMATION,
                                              NULL,                          // attribute name
                                              &ThisEaInformation,
                                              sizeof(EA_INFORMATION),
                                              0,                             // attribute flags
                                              NULL,                          // where indexed
                                              TRUE,                          // logit
                                              &Context );

                EaChange = TRUE;
            }

        } else {

            //
            //  If it exists, and we are writing an EA, then we have to update it.
            //

            if (EaList->UnpackedEaSize != 0) {

                DebugTrace( 0, Dbg, ("Change an existing $EA_INFORMATION attribute\n") );

                NtfsChangeAttributeValue( IrpContext,
                                          Fcb,
                                          0,                                 // Value offset
                                          &ThisEaInformation,
                                          sizeof(EA_INFORMATION),
                                          TRUE,                              // SetNewLength
                                          TRUE,                              // LogNonResidentToo
                                          FALSE,                             // CreateSectionUnderway
                                          FALSE,
                                          &Context );

            //
            //  If it exists, but our new length is zero, then delete it.
            //

            } else {

                DebugTrace( 0, Dbg, ("Delete existing $EA_INFORMATION attribute\n") );

                NtfsDeleteAttributeRecord( IrpContext,
                                           Fcb,
                                           DELETE_LOG_OPERATION |
                                            DELETE_RELEASE_FILE_RECORD |
                                            DELETE_RELEASE_ALLOCATION,
                                           &Context );
            }

            EaChange = TRUE;
        }

        //
        //  Now we will cleanup and reinitialize the context for reuse.
        //

        NtfsCleanupAttributeContext( IrpContext, &Context );
        NtfsInitializeAttributeContext( &Context );

        //
        //  Lookup the $EA attribute.  If it does not exist then we will need to create
        //  one.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $EA,
                                        &Context )) {

            if (EaList->UnpackedEaSize != 0) {

                DebugTrace( 0, Dbg, ("Create a new $EA attribute\n") );

                NtfsCleanupAttributeContext( IrpContext, &Context );
                NtfsInitializeAttributeContext( &Context );

                NtfsCreateAttributeWithValue( IrpContext,
                                              Fcb,
                                              $EA,
                                              NULL,                          // attribute name
                                              EaList->FullEa,
                                              EaList->UnpackedEaSize,
                                              0,                             // attribute flags
                                              NULL,                          // where indexed
                                              TRUE,                          // logit
                                              &Context );
                EaChange = TRUE;
            }

        } else {

            //
            //  If it exists, and we are writing an EA, then we have to update it.
            //

            if (EaList->UnpackedEaSize != 0) {

                DebugTrace( 0, Dbg, ("Change an existing $EA attribute\n") );

                NtfsChangeAttributeValue( IrpContext,
                                          Fcb,
                                          0,                                 // Value offset
                                          EaList->FullEa,
                                          EaList->UnpackedEaSize,
                                          TRUE,                              // SetNewLength
                                          TRUE,                              // LogNonResidentToo
                                          FALSE,                             // CreateSectionUnderway
                                          FALSE,
                                          &Context );

            //
            //  If it exists, but our new length is zero, then delete it.
            //

            } else {

                DebugTrace( 0, Dbg, ("Delete existing $EA attribute\n") );

                //
                //  If the stream is non-resident then get hold of an
                //  Scb for this.
                //

                if (!NtfsIsAttributeResident( NtfsFoundAttribute( &Context ))) {

                    EaScb = NtfsCreateScb( IrpContext,
                                           Fcb,
                                           $EA,
                                           &NtfsEmptyString,
                                           FALSE,
                                           NULL );

                    NtfsAcquireExclusiveScb( IrpContext, EaScb );
                    EaScbAcquired = TRUE;
                }

                NtfsDeleteAttributeRecord( IrpContext,
                                           Fcb,
                                           DELETE_LOG_OPERATION |
                                            DELETE_RELEASE_FILE_RECORD |
                                            DELETE_RELEASE_ALLOCATION,
                                           &Context );

                //
                //  If we have acquired the Scb then knock the sizes back
                //  to zero.
                //

                if (EaScbAcquired) {

                    EaScb->Header.FileSize =
                    EaScb->Header.ValidDataLength =
                    EaScb->Header.AllocationSize = Li0;

                    SetFlag( EaScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
                }
            }
            EaChange = TRUE;
        }

        //
        //  Increment the Modification count for the Eas.
        //

        Fcb->EaModificationCount++;

        if (EaList->UnpackedEaSize == 0) {

            Fcb->Info.PackedEaSize = 0;

        } else {

            Fcb->Info.PackedEaSize = (USHORT) EaList->PackedEaSize;
        }

        //
        //  Post a USN journal record for this change
        //

        if (EaChange) {

            NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_EA_CHANGE );
        }

        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_EA_SIZE );

    } finally {

        DebugUnwind( NtfsReplaceFileEas );

        if (EaScbAcquired) {

            NtfsReleaseScb( IrpContext, EaScb );
        }

        //
        //  Cleanup our attribute enumeration context
        //

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    DebugTrace( -1, Dbg, ("NtfsReplaceFileEas:  Exit\n") );

    return;
}


BOOLEAN
NtfsIsEaNameValid (
    IN STRING Name
    )

/*++

Routine Description:

    This routine simple returns whether the specified file names conforms
    to the file system specific rules for legal Ea names.

    For Ea names, the following rules apply:

    A. An Ea name may not contain any of the following characters:

       0x0000 - 0x001F  \ / : * ? " < > | , + = [ ] ;

Arguments:

    Name - Supllies the name to check.

Return Value:

    BOOLEAN - TRUE if the name is legal, FALSE otherwise.

--*/

{
    ULONG Index;

    UCHAR Char;

    PAGED_CODE();

    //
    //  Empty names are not valid.
    //

    if ( Name.Length == 0 ) { return FALSE; }

    //
    //  At this point we should only have a single name, which can't have
    //  more than 254 characters
    //

    if ( Name.Length > 254 ) { return FALSE; }

    for ( Index = 0; Index < (ULONG)Name.Length; Index += 1 ) {

        Char = Name.Buffer[ Index ];

        //
        //  Skip over and Dbcs chacters
        //

        if ( FsRtlIsLeadDbcsCharacter( Char ) ) {

            ASSERT( Index != (ULONG)(Name.Length - 1) );

            Index += 1;

            continue;
        }

        //
        //  Make sure this character is legal, and if a wild card, that
        //  wild cards are permissible.
        //

        if ( !FsRtlIsAnsiCharacterLegalFat(Char, FALSE) ) {

            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\devctrl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    DevCtrl.c

Abstract:

    This module implements the Device Control routines for Ntfs called by
    the dispatch driver.

Author:

    Gary Kimura     [GaryKi]        28-May-1991

Revision History:

--*/

#include "NtfsProc.h"
#include <ntddsnap.h>

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DEVCTRL)

//
//  Local procedure prototypes
//

NTSTATUS
DeviceControlCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonDeviceControl)
#endif


NTSTATUS
NtfsCommonDeviceControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Device Control called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    TYPE_OF_OPEN TypeOfOpen;
    PIO_STACK_LOCATION IrpSp;
    NTFS_COMPLETION_CONTEXT Context;
    PNTFS_COMPLETION_CONTEXT CompletionContext = NULL;
    LOGICAL ReleaseResources = FALSE;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCommonDeviceControl\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );
    
    //
    //  Extract and decode the file object
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, 
                                       IrpSp->FileObject,
                                       &Vcb, 
                                       &Fcb, 
                                       &Scb, 
                                       &Ccb, 
                                       TRUE );

    //
    //  The only type of opens we accept are user volume opens.
    //

    if (TypeOfOpen != UserVolumeOpen) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        DebugTrace( -1, Dbg, ("NtfsCommonDeviceControl -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }
    
    try {

        //
        //  A few IOCTLs actually require some intervention on our part
        //

        switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES:

            //
            //  This is sent by the Volume Snapshot driver (Lovelace).
            //  We flush the volume, and hold all file resources
            //  to make sure that nothing more gets dirty. Then we wait
            //  for the IRP to complete or cancel.
            //
                     
            Status =  NtfsCheckpointForVolumeSnapshot( IrpContext );
            
            if (NT_SUCCESS( Status )) {

                ReleaseResources = TRUE;
            }
            
            KeInitializeEvent( &Context.Event, NotificationEvent, FALSE );
            Context.IrpContext = IrpContext;
            CompletionContext = &Context;
            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
            
            break;

        case IOCTL_VOLSNAP_RELEASE_WRITES:

            //
            //  No-op for filesystems.
            //
            
            break;
            
        default:

            break;
        }

        //
        //  If error, complete the irp, free the IrpContext
        //  and return to the caller.
        //

        if (!NT_SUCCESS( Status )) {

            NtfsCompleteRequest( NULL, Irp, Status );
            leave;
        }
    
        //
        //  Get the next stack location, and copy over the stack parameter
        //  information
        //
        
        IoCopyCurrentIrpStackLocationToNext( Irp );

        //
        //  Set up the completion routine
        //

        IoSetCompletionRoutine( Irp,
                                DeviceControlCompletionRoutine,
                                CompletionContext,
                                TRUE,
                                TRUE,
                                TRUE );

        //
        //  Send the request. And wait.
        //

        Status = IoCallDriver( Vcb->TargetDeviceObject, Irp );

        if ((Status == STATUS_PENDING) && 
            (CompletionContext != NULL)) {

            KeWaitForSingleObject( &CompletionContext->Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );
        }
        
    } finally {
        
        //
        //  Release all the resources that we held because of a
        //  VOLSNAP_FLUSH_AND_HOLD. 
        //

        if (ReleaseResources && !NtfsIsVolumeReadOnly( IrpContext->Vcb )) {
        
            NtfsReleaseAllFiles( IrpContext, IrpContext->Vcb, FALSE );
            NtfsReleaseVcb( IrpContext, Vcb );
        }
#ifdef SUPW_DBG
        if (AbnormalTermination()) {

            DbgPrint("CommonDevControl Raised: Status %8lx\n", Status);
        }
#endif
    }

    NtfsCleanupIrpContext( IrpContext, TRUE );
    
    DebugTrace( -1, Dbg, ("NtfsCommonDeviceControl -> %08lx\n", Status) );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
DeviceControlCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

{
    
    //
    //  Add the hack-o-ramma to fix formats.
    //

    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );
    }
    
    if (Contxt) {
        
        PNTFS_COMPLETION_CONTEXT CompletionContext = (PNTFS_COMPLETION_CONTEXT)Contxt;

        KeSetEvent( &CompletionContext->Event, 0, FALSE );
    }

    //
    //  Return success always, because we want this IRP to go away for good
    //  irrespective of the IRP completion status.
    //
    
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fileinfo.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    FileInfo.c

Abstract:

    This module implements the set and query file information routines for Ntfs
    called by the dispatch driver.

Author:

    Brian Andrew    [BrianAn]       15-Jan-1992

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_FILEINFO)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('FFtN')

#define SIZEOF_FILE_NAME_INFORMATION (FIELD_OFFSET( FILE_NAME_INFORMATION, FileName[0]) \
                                      + sizeof( WCHAR ))

//
//  Local flags for rename and set link
//

#define TRAVERSE_MATCH              (0x00000001)
#define EXACT_CASE_MATCH            (0x00000002)
#define ACTIVELY_REMOVE_SOURCE_LINK (0x00000004)
#define REMOVE_SOURCE_LINK          (0x00000008)
#define REMOVE_TARGET_LINK          (0x00000010)
#define ADD_TARGET_LINK             (0x00000020)
#define REMOVE_TRAVERSE_LINK        (0x00000040)
#define REUSE_TRAVERSE_LINK         (0x00000080)
#define MOVE_TO_NEW_DIR             (0x00000100)
#define ADD_PRIMARY_LINK            (0x00000200)
#define OVERWRITE_SOURCE_LINK       (0x00000400)

//
//  Additional local flags for set link
//

#define CREATE_IN_NEW_DIR           (0x00000400)

//
//  Local procedure prototypes
//

//
//  VOID
//  NtfsBuildLastFileName (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFILE_OBJECT FileObject,
//      IN ULONG FileNameOffset,
//      OUT PUNICODE_STRING FileName
//      );
//

#define NtfsBuildLastFileName(IC,FO,OFF,FN) {                           \
    (FN)->MaximumLength = (FN)->Length = (FO)->FileName.Length - OFF;   \
    (FN)->Buffer = (PWSTR) Add2Ptr( (FO)->FileName.Buffer, OFF );       \
}

VOID
NtfsQueryBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
NtfsQueryStandardInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN PCCB Ccb OPTIONAL
    );

VOID
NtfsQueryInternalInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
NtfsQueryEaInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_EA_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
NtfsQueryAttributeTagInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN OUT PFILE_ATTRIBUTE_TAG_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
NtfsQueryPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_POSITION_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN PCCB Ccb
    );

NTSTATUS
NtfsQueryAlternateNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PLCB Lcb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryStreamsInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_STREAM_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryCompressedFileSize (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PFILE_COMPRESSION_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
NtfsQueryNetworkOpenInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsSetBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb
    );

NTSTATUS
NtfsSetDispositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb
    );

NTSTATUS
NtfsSetRenameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN OUT PBOOLEAN VcbAcquired
    );

NTSTATUS
NtfsSetLinkInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN OUT PBOOLEAN VcbAcquired
    );

NTSTATUS
NtfsSetShortNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb
    );

NTSTATUS
NtfsSetPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb
    );

NTSTATUS
NtfsSetAllocationInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb
    );

NTSTATUS
NtfsSetEndOfFileInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb OPTIONAL,
    IN BOOLEAN VcbAcquired
    );

NTSTATUS
NtfsSetValidDataLengthInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb
    );

NTSTATUS
NtfsCheckScbForLinkRemoval (
    IN PSCB Scb,
    OUT PSCB *BatchOplockScb,
    OUT PULONG BatchOplockCount
    );

VOID
NtfsFindTargetElements (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT TargetFileObject,
    IN PSCB ParentScb,
    OUT PSCB *TargetParentScb,
    OUT PUNICODE_STRING FullTargetFileName,
    OUT PUNICODE_STRING TargetFileName
    );

BOOLEAN
NtfsCheckLinkForNewLink (
    IN PFCB Fcb,
    IN PFILE_NAME FileNameAttr,
    IN FILE_REFERENCE FileReference,
    IN PUNICODE_STRING NewLinkName,
    OUT PULONG LinkFlags
    );

VOID
NtfsCheckLinkForRename (
    IN PFCB Fcb,
    IN PLCB Lcb,
    IN PFILE_NAME FileNameAttr,
    IN FILE_REFERENCE FileReference,
    IN PUNICODE_STRING TargetFileName,
    IN BOOLEAN IgnoreCase,
    IN OUT PULONG RenameFlags
    );

VOID
NtfsCleanupLinkForRemoval (
    IN PFCB PreviousFcb,
    IN PSCB ParentScb,
    IN BOOLEAN ExistingFcb
    );

VOID
NtfsUpdateFcbFromLinkRemoval (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN UNICODE_STRING FileName,
    IN UCHAR FileNameFlags
    );

VOID
NtfsReplaceLinkInDir (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN PUNICODE_STRING NewLinkName,
    IN UCHAR FileNameFlags,
    IN PUNICODE_STRING PrevLinkName,
    IN UCHAR PrevLinkNameFlags
    );

VOID
NtfsMoveLinkToNewDir (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING NewFullLinkName,
    IN PUNICODE_STRING NewLinkName,
    IN UCHAR NewLinkNameFlags,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN OUT PLCB Lcb,
    IN ULONG RenameFlags,
    IN PUNICODE_STRING PrevLinkName,
    IN UCHAR PrevLinkNameFlags
    );

VOID
NtfsRenameLinkInDir (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN OUT PLCB Lcb,
    IN PUNICODE_STRING NewLinkName,
    IN UCHAR FileNameFlags,
    IN ULONG RenameFlags,
    IN PUNICODE_STRING PrevLinkName,
    IN UCHAR PrevLinkNameFlags
    );

VOID
NtfsUpdateFileDupInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb OPTIONAL
    );

NTSTATUS
NtfsStreamRename(
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN BOOLEAN ReplaceIfExists,
    IN PUNICODE_STRING NewStreamName
    );

NTSTATUS
NtfsPrepareToShrinkFileSize (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    LONGLONG NewFileSize
    );

NTSTATUS
NtfsCheckTreeForBatchOplocks (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB DirectoryScb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCheckLinkForNewLink)
#pragma alloc_text(PAGE, NtfsCheckLinkForRename)
#pragma alloc_text(PAGE, NtfsCheckScbForLinkRemoval)
#pragma alloc_text(PAGE, NtfsCheckTreeForBatchOplocks)
#pragma alloc_text(PAGE, NtfsCleanupLinkForRemoval)
#pragma alloc_text(PAGE, NtfsCommonQueryInformation)
#pragma alloc_text(PAGE, NtfsCommonSetInformation)
#pragma alloc_text(PAGE, NtfsFindTargetElements)
#pragma alloc_text(PAGE, NtfsMoveLinkToNewDir)
#pragma alloc_text(PAGE, NtfsPrepareToShrinkFileSize)
#pragma alloc_text(PAGE, NtfsQueryAlternateNameInfo)
#pragma alloc_text(PAGE, NtfsQueryBasicInfo)
#pragma alloc_text(PAGE, NtfsQueryEaInfo)
#pragma alloc_text(PAGE, NtfsQueryAttributeTagInfo)
#pragma alloc_text(PAGE, NtfsQueryInternalInfo)
#pragma alloc_text(PAGE, NtfsQueryNameInfo)
#pragma alloc_text(PAGE, NtfsQueryPositionInfo)
#pragma alloc_text(PAGE, NtfsQueryStandardInfo)
#pragma alloc_text(PAGE, NtfsQueryStreamsInfo)
#pragma alloc_text(PAGE, NtfsQueryCompressedFileSize)
#pragma alloc_text(PAGE, NtfsQueryNetworkOpenInfo)
#pragma alloc_text(PAGE, NtfsRenameLinkInDir)
#pragma alloc_text(PAGE, NtfsReplaceLinkInDir)
#pragma alloc_text(PAGE, NtfsSetAllocationInfo)
#pragma alloc_text(PAGE, NtfsSetBasicInfo)
#pragma alloc_text(PAGE, NtfsSetDispositionInfo)
#pragma alloc_text(PAGE, NtfsSetEndOfFileInfo)
#pragma alloc_text(PAGE, NtfsSetLinkInfo)
#pragma alloc_text(PAGE, NtfsSetPositionInfo)
#pragma alloc_text(PAGE, NtfsSetRenameInfo)
#pragma alloc_text(PAGE, NtfsSetShortNameInfo)
#pragma alloc_text(PAGE, NtfsSetValidDataLengthInfo)
#pragma alloc_text(PAGE, NtfsStreamRename)
#pragma alloc_text(PAGE, NtfsUpdateFcbFromLinkRemoval)
#pragma alloc_text(PAGE, NtfsUpdateFileDupInfo)
#endif


NTSTATUS
NtfsFsdSetInformation (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of set file information.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext = NULL;

    ULONG LogFileFullCount = 0;

    ASSERT_IRP( Irp );

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    DebugTrace( +1, Dbg, ("NtfsFsdSetInformation\n") );

    //
    //  Call the common set Information routine
    //

    FsRtlEnterFileSystem();

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );

    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {

                //
                //  Allocate and initialize the Irp.
                //

                NtfsInitializeIrpContext( Irp, CanFsdWait( Irp ), &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );

                LogFileFullCount += 1;

                if (LogFileFullCount >= 2) {

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_EXCESS_LOG_FULL );
                }
            }

            Status = NtfsCommonSetInformation( IrpContext, Irp );
            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            NTSTATUS ExceptionCode;
            PIO_STACK_LOCATION IrpSp;

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code
            //

            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            ExceptionCode = GetExceptionCode();

            if ((ExceptionCode == STATUS_FILE_DELETED) &&
                (IrpSp->Parameters.SetFile.FileInformationClass == FileEndOfFileInformation)) {

                IrpContext->ExceptionStatus = ExceptionCode = STATUS_SUCCESS;
            }

            Status = NtfsProcessException( IrpContext, Irp, ExceptionCode );
        }

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdSetInformation -> %08lx\n", Status) );

    return Status;
}


NTSTATUS
NtfsCommonQueryInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for query file information called by both the
    fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ULONG Length;
    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID Buffer;

    BOOLEAN FcbAcquired = FALSE;
    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN FsRtlHeaderLocked = FALSE;
    PFILE_ALL_INFORMATION AllInfo;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonQueryInformation\n") );
    DebugTrace( 0, Dbg, ("IrpContext           = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp                  = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("Length               = %08lx\n", IrpSp->Parameters.QueryFile.Length) );
    DebugTrace( 0, Dbg, ("FileInformationClass = %08lx\n", IrpSp->Parameters.QueryFile.FileInformationClass) );
    DebugTrace( 0, Dbg, ("Buffer               = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryFile.Length;
    FileInformationClass = IrpSp->Parameters.QueryFile.FileInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    try {

        //
        //  Case on the type of open we're dealing with
        //

        switch (TypeOfOpen) {

        case UserVolumeOpen:

            //
            //  We cannot query the user volume open.
            //

            Status = STATUS_INVALID_PARAMETER;
            break;

        case UserFileOpen:
        case UserDirectoryOpen:
        case UserViewIndexOpen:

            if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID )) {

                //
                //  We don't allow this operation on with open by file id.
                //

                if ((Ccb->Lcb == NULL) &&
                    (FileInformationClass == FileAlternateNameInformation)) {

                    Status = STATUS_INVALID_PARAMETER;
                    break;

                } else if ((FileInformationClass == FileAllInformation) ||
                           (FileInformationClass == FileNameInformation)) {

                    if (FlagOn( Ccb->Flags, CCB_FLAG_TRAVERSE_CHECK )) {

                        //
                        //  If this file was opened by Id by a user without traversal privilege,
                        //  we can't return any info level that includes a file or path name
                        //  unless this open is relative to a directory by file id.
                        //  Look at the file name in the Ccb in that case.  We'll return
                        //  only that portion of the name.
                        //
                        if (Ccb->FullFileName.MaximumLength == 0) {

                            Status = STATUS_INVALID_PARAMETER;
                            break;
                        }
                    }

                    //
                    //  We'll need to hold the Vcb exclusively through the filename
                    //  synthesis, since it walks up the directory tree.
                    //

                    NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
                    VcbAcquired = TRUE;
                }
            }

        //
        //  Deliberate fall through to StreamFileOpen case.
        //

        case StreamFileOpen:

            //
            //  Acquire the Vcb if there is no Ccb.  This is for the
            //  case where the cache manager is querying the name.
            //

            if (Ccb == NULL) {

                NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
                VcbAcquired = TRUE;
            }

            if ((Scb->Header.PagingIoResource != NULL) &&

                ((FileInformationClass == FileAllInformation) ||
                 (FileInformationClass == FileStandardInformation) ||
                 (FileInformationClass == FileCompressionInformation))) {

                ExAcquireResourceSharedLite( Scb->Header.PagingIoResource, TRUE );

                FsRtlLockFsRtlHeader( &Scb->Header );
                FsRtlHeaderLocked = TRUE;
            }

            NtfsAcquireSharedFcb( IrpContext, Fcb, Scb, 0 );
            FcbAcquired = TRUE;

            //
            //  Fail this request if the volume has been dismounted.
            //  System files may not have the scbstate flag set - so we test the vcb as well
            //  Holding any file's main resource lets us test the vcb since we call acquireallfiles
            //  before doing a dismount
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED ) ||
                !FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
            }

            //
            //  Based on the information class we'll do different
            //  actions.  Each of hte procedures that we're calling fills
            //  up the output buffer, if possible.  They will raise the
            //  status STATUS_BUFFER_OVERFLOW for an insufficient buffer.
            //  This is considered a somewhat unusual case and is handled
            //  more cleanly with the exception mechanism rather than
            //  testing a return status value for each call.
            //

            switch (FileInformationClass) {

            case FileAllInformation:

                //
                //  For the all information class we'll typecast a local
                //  pointer to the output buffer and then call the
                //  individual routines to fill in the buffer.
                //

                AllInfo = Buffer;
                Length -= (sizeof(FILE_ACCESS_INFORMATION)
                           + sizeof(FILE_MODE_INFORMATION)
                           + sizeof(FILE_ALIGNMENT_INFORMATION));

                NtfsQueryBasicInfo(    IrpContext, FileObject, Scb, &AllInfo->BasicInformation,    &Length );
                NtfsQueryStandardInfo( IrpContext, FileObject, Scb, &AllInfo->StandardInformation, &Length, Ccb );
                NtfsQueryInternalInfo( IrpContext, FileObject, Scb, &AllInfo->InternalInformation, &Length );
                NtfsQueryEaInfo(       IrpContext, FileObject, Scb, &AllInfo->EaInformation,       &Length );
                NtfsQueryPositionInfo( IrpContext, FileObject, Scb, &AllInfo->PositionInformation, &Length );
                Status =
                NtfsQueryNameInfo(     IrpContext, FileObject, Scb, &AllInfo->NameInformation,     &Length, Ccb );
                break;

            case FileBasicInformation:

                NtfsQueryBasicInfo( IrpContext, FileObject, Scb, Buffer, &Length );
                break;

            case FileStandardInformation:

                NtfsQueryStandardInfo( IrpContext, FileObject, Scb, Buffer, &Length, Ccb );
                break;

            case FileInternalInformation:

                NtfsQueryInternalInfo( IrpContext, FileObject, Scb, Buffer, &Length );
                break;

            case FileEaInformation:

                NtfsQueryEaInfo( IrpContext, FileObject, Scb, Buffer, &Length );
                break;

            case FileAttributeTagInformation:

                NtfsQueryAttributeTagInfo( IrpContext, FileObject, Scb, Ccb, Buffer, &Length );
                break;

            case FilePositionInformation:

                NtfsQueryPositionInfo( IrpContext, FileObject, Scb, Buffer, &Length );
                break;

            case FileNameInformation:

                Status = NtfsQueryNameInfo( IrpContext, FileObject, Scb, Buffer, &Length, Ccb );
                break;

            case FileAlternateNameInformation:

                Status = NtfsQueryAlternateNameInfo( IrpContext, Scb, Ccb->Lcb, Buffer, &Length );
                break;

            case FileStreamInformation:

                Status = NtfsQueryStreamsInfo( IrpContext, Fcb, Buffer, &Length );
                break;

            case FileCompressionInformation:

                Status = NtfsQueryCompressedFileSize( IrpContext, Scb, Buffer, &Length );
                break;

            case FileNetworkOpenInformation:

                NtfsQueryNetworkOpenInfo( IrpContext, FileObject, Scb, Buffer, &Length );
                break;

            default:

                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
        }

        //
        //  Set the information field to the number of bytes actually filled in
        //  and then complete the request
        //

        Irp->IoStatus.Information = IrpSp->Parameters.QueryFile.Length - Length;

        //
        //  Abort transaction on error by raising.
        //

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

    } finally {

        DebugUnwind( NtfsCommonQueryInformation );

        if (FsRtlHeaderLocked) {
            FsRtlUnlockFsRtlHeader( &Scb->Header );
            ExReleaseResourceLite( Scb->Header.PagingIoResource );
        }

        if (FcbAcquired) { NtfsReleaseFcb( IrpContext, Fcb ); }
        if (VcbAcquired) { NtfsReleaseVcb( IrpContext, Vcb ); }

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace( -1, Dbg, ("NtfsCommonQueryInformation -> %08lx\n", Status) );
    }

    return Status;
}


NTSTATUS
NtfsCommonSetInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for set file information called by both the
    fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    FILE_INFORMATION_CLASS FileInformationClass;
    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN ReleaseScbPaging = FALSE;
    BOOLEAN LazyWriterCallback = FALSE;
    ULONG WaitState;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonSetInformation\n") );
    DebugTrace( 0, Dbg, ("IrpContext           = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp                  = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("Length               = %08lx\n", IrpSp->Parameters.SetFile.Length) );
    DebugTrace( 0, Dbg, ("FileInformationClass = %08lx\n", IrpSp->Parameters.SetFile.FileInformationClass) );
    DebugTrace( 0, Dbg, ("FileObject           = %08lx\n", IrpSp->Parameters.SetFile.FileObject) );
    DebugTrace( 0, Dbg, ("ReplaceIfExists      = %08lx\n", IrpSp->Parameters.SetFile.ReplaceIfExists) );
    DebugTrace( 0, Dbg, ("Buffer               = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );

    //
    //  Reference our input parameters to make things easier
    //

    FileInformationClass = IrpSp->Parameters.SetFile.FileInformationClass;

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  We can reject volume opens immediately.
    //

    if (TypeOfOpen == UserVolumeOpen ||
        TypeOfOpen == UnopenedFileObject ||
        TypeOfOpen == UserViewIndexOpen ||
        ((TypeOfOpen != UserFileOpen) &&
         (FileInformationClass == FileValidDataLengthInformation))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsCommonSetInformation -> STATUS_INVALID_PARAMETER\n") );
        return STATUS_INVALID_PARAMETER;
    }

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );

        DebugTrace( -1, Dbg, ("NtfsCommonSetInformation -> STATUS_MEDIA_WRITE_PROTECTED\n") );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    try {

        //
        //  The typical path here is for the lazy writer callback.  Go ahead and
        //  remember this first.
        //

        if (FileInformationClass == FileEndOfFileInformation) {

            LazyWriterCallback = IrpSp->Parameters.SetFile.AdvanceOnly;
        }

        //
        //  Perform the oplock check for changes to allocation or EOF if called
        //  by the user.
        //

        if (!LazyWriterCallback &&
            ((FileInformationClass == FileEndOfFileInformation) ||
             (FileInformationClass == FileAllocationInformation) ||
             (FileInformationClass == FileValidDataLengthInformation)) &&
            (TypeOfOpen == UserFileOpen) &&
            !FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

            //
            //  We check whether we can proceed based on the state of the file oplocks.
            //  This call might block this request.
            //

            Status = FsRtlCheckOplock( &Scb->ScbType.Data.Oplock,
                                       Irp,
                                       IrpContext,
                                       NULL,
                                       NULL );

            if (Status != STATUS_SUCCESS) {

                try_return( NOTHING );
            }

            //
            //  Update the FastIoField.
            //

            NtfsAcquireFsrtlHeader( Scb );
            Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
            NtfsReleaseFsrtlHeader( Scb );
        }

        //
        //  If this call is for EOF then we need to acquire the Vcb if we may
        //  have to perform an update duplicate call.  Don't block waiting for
        //  the Vcb in the Valid data callback case.
        //  We don't want to block the lazy write threads in the clean checkpoint
        //  case.
        //

        switch (FileInformationClass) {

        case FileEndOfFileInformation:

            //
            //  If this is not a system file then we will need to update duplicate info.
            //

            if (!FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

                WaitState = FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
                ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

                //
                //  Only acquire the Vcb for the Lazy writer if we know the file size in the Fcb
                //  is out of date or can compare the Scb with that in the Fcb.  An unsafe comparison
                //  is OK because if they are changing then someone else can do the work.
                //  We also want to update the duplicate information if the total allocated
                //  has changed and there are no user handles remaining to perform the update.
                //

                if (LazyWriterCallback) {

                    if ((FlagOn( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_SIZE ) ||
                         ((Scb->Header.FileSize.QuadPart != Fcb->Info.FileSize) &&
                          FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA ))) ||
                        (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
                         (Scb->CleanupCount == 0) &&
                         (Scb->ValidDataToDisk >= Scb->Header.ValidDataLength.QuadPart) &&
                         (FlagOn( Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE ) ||
                          (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA ) &&
                           (Scb->TotalAllocated != Fcb->Info.AllocatedLength))))) {

                        //
                        //  Go ahead and try to acquire the Vcb without waiting.
                        //

                        if (NtfsAcquireSharedVcb( IrpContext, Vcb, FALSE )) {

                            VcbAcquired = TRUE;

                        } else {

                            SetFlag( IrpContext->State, WaitState );

                            //
                            //  If we could not get the Vcb for any reason then return.  Let's
                            //  not block an essential thread waiting for the Vcb.  Typically
                            //  we will only be blocked during a clean checkpoint.  The Lazy
                            //  Writer will periodically come back and retry this call.
                            //

                            try_return( Status = STATUS_FILE_LOCK_CONFLICT );
                        }
                    }

                //
                //  Otherwise we always want to wait for the Vcb except if we were called from
                //  MM extending a section.  We will try to get this without waiting and test
                //  if called from MM if unsuccessful.
                //

                } else {

                    if (NtfsAcquireSharedVcb( IrpContext, Vcb, FALSE )) {

                        VcbAcquired = TRUE;

                    } else if ((Scb->Header.PagingIoResource == NULL) ||
                               !NtfsIsExclusiveScbPagingIo( Scb )) {

                        SetFlag( IrpContext->State, WaitState );

                        NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
                        VcbAcquired = TRUE;
                    }
                }

                SetFlag( IrpContext->State, WaitState );
            }

            break;
        //
        //  Acquire the Vcb shared for changes to allocation or basic
        //  information.
        //

        case FileAllocationInformation:
        case FileBasicInformation:
        case FileDispositionInformation:

            NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
            VcbAcquired = TRUE;

            break;

        //
        //  If this is a rename or link operation then we need to make sure
        //  we have the user's context and acquire the Vcb.
        //

        case FileRenameInformation:
        case FileLinkInformation:

            if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_SECURITY )) {

                IrpContext->Union.SubjectContext = NtfsAllocatePool( PagedPool,
                                                                      sizeof( SECURITY_SUBJECT_CONTEXT ));

                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_SECURITY );

                SeCaptureSubjectContext( IrpContext->Union.SubjectContext );
            }

            //  Fall thru

        //
        //  For the two above plus the shortname we might need the Vcb exclusive for either directories
        //  or possible deadlocks.
        //

        case FileShortNameInformation:

            if (IsDirectory( &Fcb->Info )) {

                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
            }

            if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX )) {

                NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

            } else {

                NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
            }

            VcbAcquired = TRUE;

            break;

        default:

            NOTHING;
        }

        //
        //  The Lazy Writer must still synchronize with Eof to keep the
        //  stream sizes from changing.  This will be cleaned up when we
        //  complete.
        //

        if (LazyWriterCallback) {

            //
            //  Acquire either the paging io resource shared to serialize with
            //  the flush case where the main resource is acquired before IoAtEOF
            //

            if (Scb->Header.PagingIoResource != NULL) {

                ExAcquireResourceSharedLite( Scb->Header.PagingIoResource, TRUE );
                ReleaseScbPaging = TRUE;
            }

            FsRtlLockFsRtlHeader( &Scb->Header );
            IrpContext->CleanupStructure = Scb;

        //
        //  Anyone potentially shrinking/deleting allocation must get the paging I/O
        //  resource first.  Special cases are the rename path and SetBasicInfo.  The
        //  rename path to lock the mapped page writer out of this file for deadlock
        //  prevention.  SetBasicInfo since we may call WriteFileSizes and we
        //  don't want to bump up the file size on disk from the value in the Scb
        //  if a write to EOF is underway.
        //

        } else if ((Scb->Header.PagingIoResource != NULL) &&
                   ((FileInformationClass == FileEndOfFileInformation) ||
                    (FileInformationClass == FileAllocationInformation) ||
                    (FileInformationClass == FileRenameInformation) ||
                    (FileInformationClass == FileBasicInformation) ||
                    (FileInformationClass == FileLinkInformation) ||
                    (FileInformationClass == FileValidDataLengthInformation))) {

            NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
        }

        //
        //  Acquire exclusive access to the Fcb,  We use exclusive
        //  because it is probable that one of the subroutines
        //  that we call will need to monkey with file allocation,
        //  create/delete extra fcbs.  So we're willing to pay the
        //  cost of exclusive Fcb access.
        //

        NtfsAcquireExclusiveFcb( IrpContext, Fcb, Scb, 0 );

        //
        //  Make sure the Scb state test we're about to do is properly synchronized.
        //  There's no point in testing the SCB_STATE_VOLUME_DISMOUNTED flag below
        //  if the volume can still get dismounted below us during this operation.
        //

        ASSERT( NtfsIsExclusiveScb( Scb ) || NtfsIsSharedScb( Scb ) );

        //
        //  The lazy writer callback is the only caller who can get this far if the
        //  volume has been dismounted.  We know that there are no user handles or
        //  writeable file objects or dirty pages.  Make one last check to see
        //  if this stream is on a dismounted or locked volume. Note the
        //  vcb tests are unsafe
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED ) ||
            FlagOn( Vcb->VcbState, VCB_STATE_LOCK_IN_PROGRESS ) ||
           !(FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ))) {

            NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
        }

        //
        //  Based on the information class we'll do different
        //  actions.  We will perform checks, when appropriate
        //  to insure that the requested operation is allowed.
        //

        switch (FileInformationClass) {

        case FileBasicInformation:

            Status = NtfsSetBasicInfo( IrpContext, FileObject, Irp, Scb, Ccb );
            break;

        case FileDispositionInformation:

            Status = NtfsSetDispositionInfo( IrpContext, FileObject, Irp, Scb, Ccb );
            break;

        case FileRenameInformation:

            Status = NtfsSetRenameInfo( IrpContext, FileObject, Irp, Vcb, Scb, Ccb, &VcbAcquired );
            break;

        case FilePositionInformation:

            Status = NtfsSetPositionInfo( IrpContext, FileObject, Irp, Scb );
            break;

        case FileLinkInformation:

            Status = NtfsSetLinkInfo( IrpContext, Irp, Vcb, Scb, Ccb, &VcbAcquired );
            break;

        case FileAllocationInformation:

            if (TypeOfOpen == UserDirectoryOpen ||
                TypeOfOpen == UserViewIndexOpen) {

                Status = STATUS_INVALID_PARAMETER;

            } else {

                Status = NtfsSetAllocationInfo( IrpContext, FileObject, Irp, Scb, Ccb );
            }

            break;

        case FileEndOfFileInformation:

            if (TypeOfOpen == UserDirectoryOpen ||
                TypeOfOpen == UserViewIndexOpen) {

                Status = STATUS_INVALID_PARAMETER;

            } else {

                Status = NtfsSetEndOfFileInfo( IrpContext, FileObject, Irp, Scb, Ccb, VcbAcquired );
            }

            break;

        case FileValidDataLengthInformation:

            Status = NtfsSetValidDataLengthInfo( IrpContext, Irp, Scb, Ccb );
            break;

        case FileShortNameInformation:

            //
            //  Disallow setshortname on the root - its meaningless anyway
            //

            if (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_ROOT_INDEX) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
                Status = NtfsSetShortNameInfo( IrpContext, FileObject, Irp, Vcb, Scb, Ccb );
            }
            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        //  Abort transaction on error by raising.
        //

        if (Status != STATUS_PENDING) {

            NtfsCleanupTransaction( IrpContext, Status, FALSE );
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsCommonSetInformation );

        //
        //  Release the paging io resource if acquired shared.
        //

        if (ReleaseScbPaging) {

            ExReleaseResourceLite( Scb->Header.PagingIoResource );
        }

        if (VcbAcquired) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }

        DebugTrace( -1, Dbg, ("NtfsCommonSetInformation -> %08lx\n", Status) );
    }

    //
    //  Complete the request unless it is being done in the oplock
    //  package.
    //

    if (Status != STATUS_PENDING) {
        NtfsCompleteRequest( IrpContext, Irp, Status );
    }

    return Status;
}


//
//  Internal Support Routine
//

VOID
NtfsQueryBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query basic information function.

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryBasicInfo...\n") );

    //
    //  Update the length used.
    //

    *Length -= sizeof( FILE_BASIC_INFORMATION );

    //
    //  Copy over the time information
    //

    NtfsFillBasicInfo( Buffer, Scb );

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
    DebugTrace( -1, Dbg, ("NtfsQueryBasicInfo -> VOID\n") );

    return;
}


//
//  Internal Support Routine
//

VOID
NtfsQueryStandardInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN PCCB Ccb OPTIONAL
    )

/*++

Routine Description:

    This routine performs the query standard information function.

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb being queried

    Ccb - Optionally supplies the ccb for the opened file object.

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryStandardInfo...\n") );

    //
    //  Update the length field.
    //

    *Length -= sizeof( FILE_STANDARD_INFORMATION );

    //
    //  If the Scb is uninitialized, we initialize it now.
    //

    if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED ) &&
        (Scb->AttributeTypeCode != $INDEX_ALLOCATION)) {

        DebugTrace( 0, Dbg, ("Initializing Scb  ->  %08lx\n", Scb) );
        NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
    }

    //
    //  Call the common routine to fill the output buffer.
    //

    NtfsFillStandardInfo( Buffer, Scb, Ccb );

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
    DebugTrace( -1, Dbg, ("NtfsQueryStandardInfo -> VOID\n") );

    return;
}


//
//  Internal Support Routine
//

VOID
NtfsQueryInternalInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query internal information function.

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryInternalInfo...\n") );

    RtlZeroMemory( Buffer, sizeof(FILE_INTERNAL_INFORMATION) );

    *Length -= sizeof( FILE_INTERNAL_INFORMATION );

    //
    //  Copy over the entire file reference including the sequence number
    //

    Buffer->IndexNumber = *(PLARGE_INTEGER)&Scb->Fcb->FileReference;

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
    DebugTrace( -1, Dbg, ("NtfsQueryInternalInfo -> VOID\n") );

    return;
}


//
//  Internal Support Routine
//

VOID
NtfsQueryEaInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_EA_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query EA information function.

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryEaInfo...\n") );

    RtlZeroMemory( Buffer, sizeof(FILE_EA_INFORMATION) );

    *Length -= sizeof( FILE_EA_INFORMATION );

    //
    //  EAs and reparse points cannot both be in a file at the same
    //  time. We return different information for each case.
    //

    if (FlagOn( Scb->Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT)) {

        Buffer->EaSize = 0;

    } else {

        Buffer->EaSize = Scb->Fcb->Info.PackedEaSize;

        //
        //  Add 4 bytes for the CbListHeader.
        //

        if (Buffer->EaSize != 0) {

            Buffer->EaSize += 4;
        }
    }

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
    DebugTrace( -1, Dbg, ("NtfsQueryEaInfo -> VOID\n") );

    return;
}


//
//  Internal Support Routine
//

VOID
NtfsQueryAttributeTagInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN OUT PFILE_ATTRIBUTE_TAG_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query of attributes and tag information function.

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PFCB Fcb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryAttributeTagInfo...\n") );

    Fcb = Scb->Fcb;

    //
    //  Zero the output buffer and update the length.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_ATTRIBUTE_TAG_INFORMATION) );

    *Length -= sizeof( FILE_ATTRIBUTE_TAG_INFORMATION );

    //
    // Load the file attributes as in NtfsQueryBasicInfo.
    //
    //  For the file attribute information if the flags in the attribute are zero then we
    //  return the file normal attribute otherwise we return the mask of the set attribute
    //  bits.  Note that only the valid attribute bits are returned to the user.
    //

    Buffer->FileAttributes = Fcb->Info.FileAttributes;

    ClearFlag( Buffer->FileAttributes,
               (~FILE_ATTRIBUTE_VALID_FLAGS |
                FILE_ATTRIBUTE_TEMPORARY |
                FILE_ATTRIBUTE_SPARSE_FILE |
                FILE_ATTRIBUTE_ENCRYPTED) );

    //
    //  Pick up the sparse bit for this stream from the Scb.
    //

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE );
    }

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
    }

    //
    //  If this is the main steam then the compression flag is correct but
    //  we need to test if this is a directory.
    //

    if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

        if (IsDirectory( &Fcb->Info ) || IsViewIndex( &Fcb->Info )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_DIRECTORY );
        }

    //
    //  If this is not the main stream on the file then use the stream based
    //  compressed bit.
    //

    } else {

        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_COMPRESSED );

        } else {

            ClearFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
        }
    }

    //
    //  If the temporary flag is set, then return it to the caller.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_TEMPORARY )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY );
    }

    //
    //  If there are no flags set then explicitly set the NORMAL flag.
    //

    if (Buffer->FileAttributes == 0) {

        Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;
    }

    //
    //  Load the reparse point tag.
    //  As EAs and reparse points cannot both be in a file at the same time, we return
    //  the appropriate information for each case.
    //

    if (FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT)) {

        Buffer->ReparseTag = Fcb->Info.ReparsePointTag;

    } else {

        Buffer->ReparseTag = IO_REPARSE_TAG_RESERVED_ZERO;
    }

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
    DebugTrace( -1, Dbg, ("NtfsQueryAttributeTagInfo -> VOID\n") );

    return;
}


//
//  Internal Support Routine
//

VOID
NtfsQueryPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_POSITION_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query position information function.

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryPositionInfo...\n") );

    RtlZeroMemory( Buffer, sizeof(FILE_POSITION_INFORMATION) );

    *Length -= sizeof( FILE_POSITION_INFORMATION );

    //
    //  Get the current position found in the file object.
    //

    Buffer->CurrentByteOffset = FileObject->CurrentByteOffset;

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
    DebugTrace( -1, Dbg, ("NtfsQueryPositionInfo -> VOID\n") );

    return;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the query name information function.

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

    Ccb - This is the Ccb for this file object.  If NULL then this request
        is from the Lazy Writer.

Return Value:

    NTSTATUS - STATUS_SUCCESS if the whole name would fit into the user buffer,
        STATUS_BUFFER_OVERFLOW otherwise.

--*/

{
    ULONG BytesToCopy;
    NTSTATUS Status;
    UNICODE_STRING NormalizedName;
    PUNICODE_STRING SourceName;
    ULONG AvailableNameLength;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryNameInfo...\n") );

    NormalizedName.Buffer = NULL;

    //
    //  Reduce the buffer length by the size of the fixed part of the structure.
    //

    RtlZeroMemory( Buffer, SIZEOF_FILE_NAME_INFORMATION );

    *Length -= FIELD_OFFSET(FILE_NAME_INFORMATION, FileName[0]);

    //
    //  If the name length in this file object is zero, then we try to
    //  construct the name with the Lcb chain.  This means we have been
    //  called by the system for a lazy write that failed.
    //

    if (Ccb == NULL) {

        FILE_REFERENCE FileReference;

        NtfsSetSegmentNumber( &FileReference, 0, UPCASE_TABLE_NUMBER );

        //
        //  If this is a system file with a known name then just use our constant names.
        //

        if (NtfsLeqMftRef( &Scb->Fcb->FileReference, &FileReference )) {

            SourceName =
                (PUNICODE_STRING) &NtfsSystemFiles[ Scb->Fcb->FileReference.SegmentNumberLowPart ];

        } else {

            NtfsBuildNormalizedName( IrpContext, Scb->Fcb, FALSE, &NormalizedName );
            SourceName = &NormalizedName;
        }

    } else {

        if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID ) &&
            !FlagOn( Ccb->Flags, CCB_FLAG_TRAVERSE_CHECK)) {

            //
            //  If the file was opened by id, the Ccb doesn't
            //  have a full file name in it.
            //

            NtfsBuildNormalizedName( IrpContext, Scb->Fcb, FALSE, &NormalizedName );
            SourceName = &NormalizedName;

        } else {

            //
            //  Use the name in the Ccb.  This may be a relative name for
            //  some of the open by ID relative cases.
            //

            SourceName = &Ccb->FullFileName;
        }
    }

    Buffer->FileNameLength = SourceName->Length;

    if ((Scb->AttributeName.Length != 0) &&
        NtfsIsTypeCodeUserData( Scb->AttributeTypeCode )) {

        Buffer->FileNameLength += sizeof( WCHAR ) + Scb->AttributeName.Length;
    }

    //
    //  Figure out how many bytes we can copy.
    //

    AvailableNameLength = Buffer->FileNameLength;

    if (*Length >= Buffer->FileNameLength) {

        Status = STATUS_SUCCESS;

    } else {

        //
        //  If we don't have enough for the entire buffer then make sure we only
        //  return full characters (characters are UNICODE).
        //

        Status = STATUS_BUFFER_OVERFLOW;
        AvailableNameLength = *Length & 0xfffffffe;
    }

    //
    //  Update the Length
    //

    *Length -= AvailableNameLength;

    //
    //  Copy over the file name
    //

    if (SourceName->Length <= AvailableNameLength) {

        BytesToCopy = SourceName->Length;

    } else {

        BytesToCopy = AvailableNameLength;
    }

    if (BytesToCopy) {

        RtlCopyMemory( &Buffer->FileName[0],
                       SourceName->Buffer,
                       BytesToCopy );
    }

    BytesToCopy = AvailableNameLength - BytesToCopy;

    if (BytesToCopy) {

        PWCHAR DestBuffer;

        DestBuffer = (PWCHAR) Add2Ptr( &Buffer->FileName, SourceName->Length );

        *DestBuffer = L':';
        DestBuffer += 1;

        BytesToCopy -= sizeof( WCHAR );

        if (BytesToCopy) {

            RtlCopyMemory( DestBuffer,
                           Scb->AttributeName.Buffer,
                           BytesToCopy );
        }
    }

    if ((SourceName == &NormalizedName) &&
        (SourceName->Buffer != NULL)) {

        NtfsFreePool( SourceName->Buffer );
    }

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
    DebugTrace( -1, Dbg, ("NtfsQueryNameInfo -> 0x%8lx\n", Status) );

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryAlternateNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PLCB Lcb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query alternate name information function.
    We will return the alternate name as long as this opener has opened
    a primary link.  We don't return the alternate name if the user
    has opened a hard link because there is no reason to expect that
    the primary link has any relationship to a hard link.

Arguments:

    Scb - Supplies the Scb being queried

    Lcb - Supplies the link the user traversed to open this file.

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    ****    We need a status code for the case where there is no alternate name
            or the caller isn't allowed to see it.

    NTSTATUS - STATUS_SUCCESS if the whole name would fit into the user buffer,
        STATUS_OBJECT_NAME_NOT_FOUND if we can't return the name,
        STATUS_BUFFER_OVERFLOW otherwise.

        ****    A code like STATUS_NAME_NOT_FOUND would be good.

--*/

{
    ULONG BytesToCopy;
    NTSTATUS Status;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN MoreToGo;

    UNICODE_STRING AlternateName;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_LCB( Lcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryAlternateNameInfo...\n") );

    //
    //  If the Lcb is not a primary link we can return immediately.
    //

    if (!FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS )) {

        DebugTrace( -1, Dbg, ("NtfsQueryAlternateNameInfo:  Lcb not a primary link\n") );
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    //  Reduce the buffer length by the size of the fixed part of the structure.
    //

    if (*Length < SIZEOF_FILE_NAME_INFORMATION ) {

        *Length = 0;
        NtfsRaiseStatus( IrpContext, STATUS_BUFFER_OVERFLOW, NULL, NULL );
    }

    RtlZeroMemory( Buffer, SIZEOF_FILE_NAME_INFORMATION );

    *Length -= FIELD_OFFSET(FILE_NAME_INFORMATION, FileName[0]);

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to cleanup the attribut structure if we need it.
    //

    try {

        //
        //  We can special case for the case where the name is in the Lcb.
        //

        if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS )) {

            AlternateName = Lcb->ExactCaseLink.LinkName;

        } else {

            //
            //  We will walk through the file record looking for a file name
            //  attribute with the 8.3 bit set.  It is not guaranteed to be
            //  present.
            //

            MoreToGo = NtfsLookupAttributeByCode( IrpContext,
                                                  Scb->Fcb,
                                                  &Scb->Fcb->FileReference,
                                                  $FILE_NAME,
                                                  &AttrContext );

            while (MoreToGo) {

                PFILE_NAME FileName;

                FileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                //
                //  See if the 8.3 flag is set for this name.
                //

                if (FlagOn( FileName->Flags, FILE_NAME_DOS )) {

                    AlternateName.Length = (USHORT)(FileName->FileNameLength * sizeof( WCHAR ));
                    AlternateName.Buffer = (PWSTR) FileName->FileName;

                    break;
                }

                //
                //  The last one wasn't it.  Let's try again.
                //

                MoreToGo = NtfsLookupNextAttributeByCode( IrpContext,
                                                          Scb->Fcb,
                                                          $FILE_NAME,
                                                          &AttrContext );
            }

            //
            //  If we didn't find a match, return to the caller.
            //

            if (!MoreToGo) {

                DebugTrace( 0, Dbg, ("NtfsQueryAlternateNameInfo:  No Dos link\n") );
                try_return( Status = STATUS_OBJECT_NAME_NOT_FOUND );

                //
                //  ****    Get a better status code.
                //
            }
        }

        //
        //  The name is now in alternate name.
        //  Figure out how many bytes we can copy.
        //

        if ( *Length >= (ULONG)AlternateName.Length ) {

            Status = STATUS_SUCCESS;

            BytesToCopy = AlternateName.Length;

        } else {

            Status = STATUS_BUFFER_OVERFLOW;

            BytesToCopy = *Length;
        }

        //
        //  Copy over the file name
        //

        RtlCopyMemory( Buffer->FileName, AlternateName.Buffer, BytesToCopy);

        //
        //  Copy the number of bytes (not characters) and update the Length
        //

        Buffer->FileNameLength = BytesToCopy;

        *Length -= BytesToCopy;

    try_exit:  NOTHING;
    } finally {

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        //
        //  And return to our caller
        //

        DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
        DebugTrace( -1, Dbg, ("NtfsQueryAlternateNameInfo -> 0x%8lx\n", Status) );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsQueryStreamsInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_STREAM_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine will return the attribute name and code name for as
    many attributes in the file as will fit in the user buffer.  We return
    a string which can be appended to the end of the file name to
    open the string.

    For example, for the unnamed data stream we will return the string:

            "::$DATA"

    For a user data stream with the name "Authors", we return the string

            ":Authors:$DATA"

Arguments:

    Fcb - This is the Fcb for the file.

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    NTSTATUS - STATUS_SUCCESS if all of the names would fit into the user buffer,
        STATUS_BUFFER_OVERFLOW otherwise.

        ****    We need a code indicating that they didn't all fit but
                some of them got in.

--*/

{
    NTSTATUS Status;
    BOOLEAN MoreToGo;

    PUCHAR UserBuffer;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PATTRIBUTE_DEFINITION_COLUMNS AttrDefinition;
    UNICODE_STRING AttributeCodeString;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    ATTRIBUTE_TYPE_CODE TypeCode = $DATA;

    ULONG NextEntry;
    ULONG LastEntry;
    ULONG ThisLength;
    ULONG NameLength;
    ULONG LastQuadAlign;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryStreamsInfo...\n") );

    Status = STATUS_SUCCESS;

    LastEntry = 0;
    NextEntry = 0;
    LastQuadAlign = 0;

    //
    //  Zero the entire buffer.
    //

    UserBuffer = (PUCHAR) Buffer;

    RtlZeroMemory( UserBuffer, *Length );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        NtfsInitializeAttributeContext( &AttrContext );

        //
        //  There should always be at least one attribute.
        //

        MoreToGo = NtfsLookupAttribute( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        &AttrContext );

        Attribute = NtfsFoundAttribute( &AttrContext );

        //
        //  Walk through all of the entries, checking if we can return this
        //  entry to the user and if it will fit in the buffer.
        //

        while (MoreToGo) {

            //
            //  If we can return this entry to the user, compute it's size.
            //  We only return user defined attributes or data streams
            //  unless we are allowing access to all attributes for
            //  debugging.
            //

            if ((Attribute->TypeCode == TypeCode)

                    &&

                (NtfsIsAttributeResident(Attribute) ||
                 (Attribute->Form.Nonresident.LowestVcn == 0))) {

                PWCHAR StreamName;

                //
                //  Lookup the attribute definition for this attribute code.
                //

                AttrDefinition = NtfsGetAttributeDefinition( Fcb->Vcb,
                                                             Attribute->TypeCode );

                //
                //  Generate a unicode string for the attribute code name.
                //

                RtlInitUnicodeString( &AttributeCodeString, AttrDefinition->AttributeName );

                //
                //
                //  The size is a combination of the length of the attribute
                //  code name and the attribute name plus the separating
                //  colons plus the size of the structure.  We first compute
                //  the name length.
                //

                NameLength = ((2 + Attribute->NameLength) * sizeof( WCHAR ))
                             + AttributeCodeString.Length;

                ThisLength = FIELD_OFFSET( FILE_STREAM_INFORMATION, StreamName[0] ) + NameLength;

                //
                //  If the entry doesn't fit, we return buffer overflow.
                //
                //  ****    This doesn't seem like a good scheme.  Maybe we should
                //          let the user know how much buffer was needed.
                //

                if (ThisLength + LastQuadAlign > *Length) {

                    DebugTrace( 0, Dbg, ("Next entry won't fit in the buffer \n") );

                    Status = STATUS_BUFFER_OVERFLOW ;
                    leave;
                }

                //
                //  Now store the stream information into the user's buffer.
                //  The name starts with a colon, following by the attribute name
                //  and another colon, followed by the attribute code name.
                //

                if (NtfsIsAttributeResident( Attribute )) {

                    Buffer->StreamSize.QuadPart =
                        Attribute->Form.Resident.ValueLength;
                    Buffer->StreamAllocationSize.QuadPart =
                        QuadAlign( Attribute->Form.Resident.ValueLength );

                } else {

                    Buffer->StreamSize.QuadPart = Attribute->Form.Nonresident.FileSize;
                    Buffer->StreamAllocationSize.QuadPart = Attribute->Form.Nonresident.AllocatedLength;
                }

                Buffer->StreamNameLength = NameLength;

                StreamName = (PWCHAR) Buffer->StreamName;

                *StreamName = L':';
                StreamName += 1;

                RtlCopyMemory( StreamName,
                               Add2Ptr( Attribute, Attribute->NameOffset ),
                               Attribute->NameLength * sizeof( WCHAR ));

                StreamName += Attribute->NameLength;

                *StreamName = L':';
                StreamName += 1;

                RtlCopyMemory( StreamName,
                               AttributeCodeString.Buffer,
                               AttributeCodeString.Length );

                //
                //  Set up the previous next entry offset to point to this entry.
                //

                *((PULONG)(&UserBuffer[LastEntry])) = NextEntry - LastEntry;

                //
                //  Subtract the number of bytes used from the number of bytes
                //  available in the buffer.
                //

                *Length -= (ThisLength + LastQuadAlign);

                //
                //  Compute the number of bytes needed to quad-align this entry
                //  and the offset of the next entry.
                //

                LastQuadAlign = QuadAlign( ThisLength ) - ThisLength;

                LastEntry = NextEntry;
                NextEntry += (ThisLength + LastQuadAlign);

                //
                //  Generate a pointer at the next entry offset.
                //

                Buffer = (PFILE_STREAM_INFORMATION) Add2Ptr( UserBuffer, NextEntry );
            }

            //
            //  Look for the next attribute in the file.
            //

            MoreToGo = NtfsLookupNextAttribute( IrpContext,
                                                Fcb,
                                                &AttrContext );

            Attribute = NtfsFoundAttribute( &AttrContext );
        }

    } finally {

        DebugUnwind( NtfsQueryStreamsInfo );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        //
        //  And return to our caller
        //

        DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
        DebugTrace( -1, Dbg, ("NtfsQueryStreamInfo -> 0x%8lx\n", Status) );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsQueryCompressedFileSize (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PFILE_COMPRESSION_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    //
    //  Lookup the attribute and pin it so that we can modify it.
    //

    //
    //  Reduce the buffer length by the size of the fixed part of the structure.
    //

    if (*Length < sizeof(FILE_COMPRESSION_INFORMATION) ) {

        *Length = 0;
        NtfsRaiseStatus( IrpContext, STATUS_BUFFER_OVERFLOW, NULL, NULL );
    }

    if ((Scb->Header.NodeTypeCode == NTFS_NTC_SCB_INDEX) ||
        (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_ROOT_INDEX)) {

        Buffer->CompressedFileSize = Li0;

    } else {

        Buffer->CompressedFileSize.QuadPart = Scb->TotalAllocated;
    }

    //
    //  Do not return more than FileSize.
    //

    if (Buffer->CompressedFileSize.QuadPart > Scb->Header.FileSize.QuadPart) {

        Buffer->CompressedFileSize = Scb->Header.FileSize;
    }

    //
    //  Start off saying that the file/directory isn't comressed
    //

    Buffer->CompressionFormat = 0;

    //
    //  If this is the index allocation Scb and it has not been initialized then
    //  lookup the index root and perform the initialization.
    //

    if ((Scb->AttributeTypeCode == $INDEX_ALLOCATION) &&
        (Scb->ScbType.Index.BytesPerIndexBuffer == 0)) {

        ATTRIBUTE_ENUMERATION_CONTEXT Context;

        NtfsInitializeAttributeContext( &Context );

        //
        //  Use a try-finally to perform cleanup.
        //

        try {

            if (!NtfsLookupAttributeByName( IrpContext,
                                            Scb->Fcb,
                                            &Scb->Fcb->FileReference,
                                            $INDEX_ROOT,
                                            &Scb->AttributeName,
                                            NULL,
                                            FALSE,
                                            &Context )) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }

            NtfsUpdateIndexScbFromAttribute( IrpContext,
                                             Scb,
                                             NtfsFoundAttribute( &Context ),
                                             FALSE );

        } finally {

            NtfsCleanupAttributeContext( IrpContext, &Context );
        }
    }

    //
    //  Return the compression state and the size of the returned data.
    //

    Buffer->CompressionFormat = (USHORT)(Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK);

    if (Buffer->CompressionFormat != 0) {
        Buffer->CompressionFormat += 1;
        Buffer->ClusterShift = (UCHAR)Scb->Vcb->ClusterShift;
        Buffer->CompressionUnitShift = (UCHAR)(Scb->CompressionUnitShift + Buffer->ClusterShift);
        Buffer->ChunkShift = NTFS_CHUNK_SHIFT;
    }

    *Length -= sizeof(FILE_COMPRESSION_INFORMATION);

    return  STATUS_SUCCESS;
}


//
//  Internal Support Routine
//

VOID
NtfsQueryNetworkOpenInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query network open information function.

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PFCB Fcb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryNetworkOpenInfo...\n") );

    Fcb = Scb->Fcb;

    //
    //  If the Scb is uninitialized, we initialize it now.
    //

    if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED ) &&
        (Scb->AttributeTypeCode != $INDEX_ALLOCATION)) {

        DebugTrace( 0, Dbg, ("Initializing Scb -> %08lx\n", Scb) );
        NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
    }

    //
    //  Update the length.
    //

    *Length -= sizeof( FILE_NETWORK_OPEN_INFORMATION );

    //
    //  Copy over the data.
    //

    NtfsFillNetworkOpenInfo( Buffer, Scb );

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
    DebugTrace( -1, Dbg, ("NtfsQueryNetworkOpenInfo -> VOID\n") );

    return;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the set basic information function.

Arguments:

    FileObject - Supplies the file object being processed

    Irp - Supplies the Irp being processed

    Scb - Supplies the Scb for the file/directory being modified

    Ccb - Supplies the Ccb for this operation

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    NTSTATUS Status;
    PFCB Fcb;
    ULONG UsnReason = 0;
    ULONG NewCcbFlags = 0;

    PFILE_BASIC_INFORMATION Buffer;
    ULONG PreviousFileAttributes = Scb->Fcb->Info.FileAttributes;

    BOOLEAN LeaveChangeTime = BooleanFlagOn( Ccb->Flags, CCB_FLAG_USER_SET_LAST_CHANGE_TIME );

    LONGLONG CurrentTime;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_IRP( Irp );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSetBasicInfo...\n") );

    Fcb = Scb->Fcb;

    //
    //  Reference the system buffer containing the user specified basic
    //  information record
    //

    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Remember the source info flags in the Ccb.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  If the user is specifying -1 for a field, that means
    //  we should leave that field unchanged, even if we might
    //  have otherwise set it ourselves.  We'll set the
    //  Ccb flag saying the user set the field so that we
    //  don't do our default updating.
    //
    //  We set the field to 0 then so we know not to actually
    //  set the field to the user-specified (and in this case,
    //  illegal) value.
    //

    if (Buffer->ChangeTime.QuadPart == -1) {

        SetFlag( NewCcbFlags, CCB_FLAG_USER_SET_LAST_CHANGE_TIME );
        Buffer->ChangeTime.QuadPart = 0;

        //
        //  This timestamp is special -- sometimes even this very
        //  function wants to update the ChangeTime, but if the
        //  user is asking us not to, we shouldn't.
        //

        LeaveChangeTime = TRUE;
    }

    if (Buffer->LastAccessTime.QuadPart == -1) {

        SetFlag( NewCcbFlags, CCB_FLAG_USER_SET_LAST_ACCESS_TIME );
        Buffer->LastAccessTime.QuadPart = 0;
    }

    if (Buffer->LastWriteTime.QuadPart == -1) {

        SetFlag( NewCcbFlags, CCB_FLAG_USER_SET_LAST_MOD_TIME );
        Buffer->LastWriteTime.QuadPart = 0;
    }

    if (Buffer->CreationTime.QuadPart == -1) {

        //
        //  We only set the creation time at creation time anyway (how
        //  appropriate), so we don't need to set a Ccb flag in this
        //  case.  In fact, there isn't even a Ccb flag to signify
        //  that the user set the creation time.
        //

        Buffer->CreationTime.QuadPart = 0;
    }

    //
    //  Do a quick check to see there are any illegal time stamps being set.
    //  Ntfs supports all values of Nt time as long as the uppermost bit
    //  isn't set.
    //

    if (FlagOn( Buffer->ChangeTime.HighPart, 0x80000000 ) ||
        FlagOn( Buffer->CreationTime.HighPart, 0x80000000 ) ||
        FlagOn( Buffer->LastAccessTime.HighPart, 0x80000000 ) ||
        FlagOn( Buffer->LastWriteTime.HighPart, 0x80000000 )) {

        DebugTrace( -1, Dbg, ("NtfsSetBasicInfo -> %08lx\n", STATUS_INVALID_PARAMETER) );

        return STATUS_INVALID_PARAMETER;
    }

    NtfsGetCurrentTime( IrpContext, CurrentTime );

    //
    //  Pick up any changes from the fast Io path now while we have the
    //  file exclusive.
    //

    NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );

    //
    //  If the user specified a non-zero file attributes field then
    //  we need to change the file attributes.  This code uses the
    //  I/O supplied system buffer to modify the file attributes field
    //  before changing its value on the disk.
    //

    if (Buffer->FileAttributes != 0) {

        //
        //  Check for valid flags being passed in.  We fail if this is
        //  a directory and the TEMPORARY bit is used.  Also fail if this
        //  is a file and the DIRECTORY bit is used.
        //

        if (Scb->AttributeTypeCode == $DATA) {

            if (FlagOn( Buffer->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

                DebugTrace( -1, Dbg, ("NtfsSetBasicInfo -> %08lx\n", STATUS_INVALID_PARAMETER) );

                return STATUS_INVALID_PARAMETER;
            }

        } else if (IsDirectory( &Fcb->Info )) {

            if (FlagOn( Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY )) {

                DebugTrace( -1, Dbg, ("NtfsSetBasicInfo -> %08lx\n", STATUS_INVALID_PARAMETER) );

                return STATUS_INVALID_PARAMETER;
            }
        }

        //
        //  Clear out the normal bit and the directory bit as well as any unsupported
        //  bits.
        //

        ClearFlag( Buffer->FileAttributes,
                   ~FILE_ATTRIBUTE_VALID_SET_FLAGS | FILE_ATTRIBUTE_NORMAL );

        //
        //  Update the attributes in the Fcb if this is a change to the file.
        //  We want to keep the flags that the user can't set.
        //

        Fcb->Info.FileAttributes = (Fcb->Info.FileAttributes & ~FILE_ATTRIBUTE_VALID_SET_FLAGS) |
                                   Buffer->FileAttributes;

        ASSERTMSG( "conflict with flush",
                   NtfsIsSharedFcb( Fcb ) ||
                   (Fcb->PagingIoResource != NULL &&
                    NtfsIsSharedFcbPagingIo( Fcb )) );

        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );

        //
        //  If this is the root directory then keep the hidden and system flags.
        //

        if (Fcb == Fcb->Vcb->RootIndexScb->Fcb) {

            SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN );

        //
        //  Mark the file object temporary flag correctly.
        //

        } else if (FlagOn(Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY)) {

            SetFlag( Scb->ScbState, SCB_STATE_TEMPORARY );
            SetFlag( FileObject->Flags, FO_TEMPORARY_FILE );

        } else {

            ClearFlag( Scb->ScbState, SCB_STATE_TEMPORARY );
            ClearFlag( FileObject->Flags, FO_TEMPORARY_FILE );
        }

        if (!LeaveChangeTime) {

            Fcb->Info.LastChangeTime = CurrentTime;

            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_CHANGE );
            LeaveChangeTime = TRUE;
        }

        //
        //  Post a Usn change if the file attribute change.
        //

        if (PreviousFileAttributes != Fcb->Info.FileAttributes) {

            UsnReason = USN_REASON_BASIC_INFO_CHANGE;
        }
    }

    //
    //  Propagate the new Ccb flags to the Ccb now that we know we won't fail.
    //

    SetFlag( Ccb->Flags, NewCcbFlags );

    //
    //  If the user specified a non-zero change time then change
    //  the change time on the record.  Then do the exact same
    //  for the last acces time, last write time, and creation time
    //

    if (Buffer->ChangeTime.QuadPart != 0) {

        if (Fcb->Info.LastChangeTime != Buffer->ChangeTime.QuadPart) {
            UsnReason = USN_REASON_BASIC_INFO_CHANGE;
        }

        Fcb->Info.LastChangeTime = Buffer->ChangeTime.QuadPart;

        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_CHANGE );
        SetFlag( Ccb->Flags, CCB_FLAG_USER_SET_LAST_CHANGE_TIME );

        LeaveChangeTime = TRUE;
    }

    if (Buffer->CreationTime.QuadPart != 0) {

        if (Fcb->Info.CreationTime != Buffer->CreationTime.QuadPart) {
            UsnReason = USN_REASON_BASIC_INFO_CHANGE;
        }

        Fcb->Info.CreationTime = Buffer->CreationTime.QuadPart;

        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_CREATE );

        if (!LeaveChangeTime) {

            Fcb->Info.LastChangeTime = CurrentTime;

            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_CHANGE );
            LeaveChangeTime = TRUE;
        }
    }

    if (Buffer->LastAccessTime.QuadPart != 0) {

        if (Fcb->CurrentLastAccess != Buffer->LastAccessTime.QuadPart) {
            UsnReason = USN_REASON_BASIC_INFO_CHANGE;
        }

        Fcb->CurrentLastAccess = Fcb->Info.LastAccessTime = Buffer->LastAccessTime.QuadPart;

        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_ACCESS );
        SetFlag( Ccb->Flags, CCB_FLAG_USER_SET_LAST_ACCESS_TIME );

        if (!LeaveChangeTime) {

            Fcb->Info.LastChangeTime = CurrentTime;

            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_CHANGE );
            LeaveChangeTime = TRUE;
        }
    }

    if (Buffer->LastWriteTime.QuadPart != 0) {

        if (Fcb->Info.LastModificationTime != Buffer->LastWriteTime.QuadPart) {
            UsnReason = USN_REASON_BASIC_INFO_CHANGE;
        }

        Fcb->Info.LastModificationTime = Buffer->LastWriteTime.QuadPart;

        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_MOD );
        SetFlag( Ccb->Flags, CCB_FLAG_USER_SET_LAST_MOD_TIME );

        if (!LeaveChangeTime) {

            Fcb->Info.LastChangeTime = CurrentTime;

            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_CHANGE );
            LeaveChangeTime = TRUE;
        }
    }

    //
    //  Now indicate that we should not be updating the standard information attribute anymore
    //  on cleanup.
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

        //
        //  Check if the index bit changed.
        //

        if (FlagOn( PreviousFileAttributes ^ Fcb->Info.FileAttributes,
                    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED )) {

            SetFlag( UsnReason, USN_REASON_INDEXABLE_CHANGE );
        }

        //
        //  Post the change to the Usn Journal
        //

        if (UsnReason != 0) {

            NtfsPostUsnChange( IrpContext, Scb, UsnReason );
        }

        NtfsUpdateStandardInformation( IrpContext, Fcb  );

        if (FlagOn( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE )) {

            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &Scb->Header.ValidDataLength.QuadPart,
                                FALSE,
                                TRUE,
                                FALSE );

            ClearFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
        }

        ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

        if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID )) {

            NtfsCheckpointCurrentTransaction( IrpContext );
            NtfsUpdateFileDupInfo( IrpContext, Fcb, Ccb );
        }
    }

    Status = STATUS_SUCCESS;

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsSetBasicInfo -> %08lx\n", Status) );

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetDispositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the set disposition information function.

Arguments:

    FileObject - Supplies the file object being processed

    Irp - Supplies the Irp being processed

    Scb - Supplies the Scb for the file/directory being modified

    Ccb - Supplies the Ccb for this handle

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    NTSTATUS Status;
    PLCB Lcb;
    BOOLEAN GenerateOnClose = FALSE;
    PIO_STACK_LOCATION IrpSp;
    HANDLE FileHandle = NULL;

    PFILE_DISPOSITION_INFORMATION Buffer;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_IRP( Irp );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSetDispositionInfo...\n") );

    //
    // First pull the file handle out of the irp
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FileHandle = IrpSp->Parameters.SetFile.DeleteHandle;

    //
    //  We get the Lcb for this open.  If there is no link then we can't
    //  set any disposition information if this is a file.
    //

    Lcb = Ccb->Lcb;

    if ((Lcb == NULL) &&
        FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

        DebugTrace( -1, Dbg, ("NtfsSetDispositionInfo:  Exit -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference the system buffer containing the user specified disposition
    //  information record
    //

    Buffer = Irp->AssociatedIrp.SystemBuffer;

    try {

        if (Buffer->DeleteFile) {

            //
            //  Check if the file is marked read only
            //

            if (IsReadOnly( &Scb->Fcb->Info )) {

                DebugTrace( 0, Dbg, ("File fat flags indicates read only\n") );

                try_return( Status = STATUS_CANNOT_DELETE );
            }

            //
            //  Make sure there is no process mapping this file as an image
            //

            if (!MmFlushImageSection( &Scb->NonpagedScb->SegmentObject,
                                      MmFlushForDelete )) {

                DebugTrace( 0, Dbg, ("Failed to flush image section\n") );

                try_return( Status = STATUS_CANNOT_DELETE );
            }

            //
            //  Check that we are not trying to delete one of the special
            //  system files.
            //

            if (FlagOn( Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

                DebugTrace( 0, Dbg, ("Scb is one of the special system files\n") );

                try_return( Status = STATUS_CANNOT_DELETE );
            }

            //
            //  Only do the auditing if we have a user handle.  We verify that the FileHandle
            //  is still valid and hasn't gone through close.  Note we first check the CCB state
            //  to see if the cleanup has been issued.  If the CCB state is valid then we are
            //  guaranteed the handle couldn't have been reused by the object manager even if
            //  the user close in another thread has gone through OB.  This is because this request
            //  is serialized with Ntfs cleanup.
            //

            if (FileHandle != NULL) {

                //
                //  Check for serialization with Ntfs cleanup first.
                //

                if (FlagOn( Ccb->Flags, CCB_FLAG_CLEANUP )) {

                    DebugTrace( 0, Dbg, ("This call issued after cleanup\n") );
                    try_return( Status = STATUS_INVALID_HANDLE );
                }

                Status = ObQueryObjectAuditingByHandle( FileHandle,
                                                        &GenerateOnClose );

                //
                //  Fail the request if the object manager doesn't recognize the handle.
                //

                if (!NT_SUCCESS( Status )) {

                    DebugTrace( 0, Dbg, ("Object manager fails to recognize handle\n") );
                    try_return( Status );
                }
            }

            //
            //  Now check that the file is really deleteable according to indexsup
            //

            if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

                BOOLEAN LastLink;
                BOOLEAN NonEmptyIndex = FALSE;

                //
                //  If the link is not deleted, we check if it can be deleted.
                //

                if (!LcbLinkIsDeleted( Lcb )) {

                    if (NtfsIsLinkDeleteable( IrpContext, Scb->Fcb, &NonEmptyIndex, &LastLink )) {

                        //
                        //  It is ok to get rid of this guy.  All we need to do is
                        //  mark this Lcb for delete and decrement the link count
                        //  in the Fcb.  If this is a primary link, then we
                        //  indicate that the primary link has been deleted.
                        //

                        SetFlag( Lcb->LcbState, LCB_STATE_DELETE_ON_CLOSE );

                        ASSERTMSG( "Link count should not be 0\n", Scb->Fcb->LinkCount != 0 );
                        Scb->Fcb->LinkCount -= 1;

                        if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS )) {

                            SetFlag( Scb->Fcb->FcbState, FCB_STATE_PRIMARY_LINK_DELETED );
                        }

                        //
                        //  Call into the notify package to close any handles on
                        //  a directory being deleted.
                        //

                        if (IsDirectory( &Scb->Fcb->Info )) {

                            FsRtlNotifyFilterChangeDirectory( Scb->Vcb->NotifySync,
                                                              &Scb->Vcb->DirNotifyList,
                                                              FileObject->FsContext,
                                                              NULL,
                                                              FALSE,
                                                              FALSE,
                                                              0,
                                                              NULL,
                                                              NULL,
                                                              NULL,
                                                              NULL );
                        }

                    } else if (NonEmptyIndex) {

                        DebugTrace( 0, Dbg, ("Index attribute has entries\n") );
                        try_return( Status = STATUS_DIRECTORY_NOT_EMPTY );

                    } else {

                        DebugTrace( 0, Dbg, ("File is not deleteable\n") );
                        try_return( Status = STATUS_CANNOT_DELETE );
                    }
                }

            //
            //  Otherwise we are simply removing the attribute.
            //

            } else {

                SetFlag( Scb->ScbState, SCB_STATE_DELETE_ON_CLOSE );
            }

            //
            //  Indicate in the file object that a delete is pending
            //

            FileObject->DeletePending = TRUE;

            //
            //  Now do the audit.
            //

            if ((FileHandle != NULL) && GenerateOnClose) {

                SeDeleteObjectAuditAlarm( FileObject, FileHandle );
            }

        } else {

            if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

                if (LcbLinkIsDeleted( Lcb )) {

                    //
                    //  The user doesn't want to delete the link so clear any delete bits
                    //  we have laying around
                    //

                    DebugTrace( 0, Dbg, ("File is being marked as do not delete on close\n") );

                    ClearFlag( Lcb->LcbState, LCB_STATE_DELETE_ON_CLOSE );

                    Scb->Fcb->LinkCount += 1;
                    ASSERTMSG( "Link count should not be 0\n", Scb->Fcb->LinkCount != 0 );

                    if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS )) {

                        ClearFlag( Scb->Fcb->FcbState, FCB_STATE_PRIMARY_LINK_DELETED );
                    }
                }

            //
            //  Otherwise we are undeleting an attribute.
            //

            } else {

                ClearFlag( Scb->ScbState, SCB_STATE_DELETE_ON_CLOSE );
            }

            FileObject->DeletePending = FALSE;
        }

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsSetDispositionInfo );

        NOTHING;
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsSetDispositionInfo -> %08lx\n", Status) );

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetRenameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN OUT PBOOLEAN VcbAcquired
    )

/*++

Routine Description:

    This routine performs the set rename function.

Arguments:

    FileObject - Supplies the file object being processed

    Irp - Supplies the Irp being processed

    Vcb - Supplies the Vcb for the Volume

    Scb - Supplies the Scb for the file/directory being modified

    Ccb - Supplies the Ccb for this file object

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PLCB Lcb = Ccb->Lcb;
    PFCB Fcb = Scb->Fcb;
    PSCB ParentScb;
    USHORT FcbLinkCountAdj = 0;

    BOOLEAN AcquiredParentScb = TRUE;
    BOOLEAN AcquiredObjectIdIndex = FALSE;
    BOOLEAN AcquiredReparsePointIndex = FALSE;

    PFCB TargetLinkFcb = NULL;
    BOOLEAN ExistingTargetLinkFcb;
    BOOLEAN AcquiredTargetLinkFcb = FALSE;
    USHORT TargetLinkFcbCountAdj = 0;

    BOOLEAN AcquiredFcbTable = FALSE;
    PFCB FcbWithPagingToRelease = NULL;

    PFILE_OBJECT TargetFileObject;
    PSCB TargetParentScb;

    UNICODE_STRING NewLinkName;
    UNICODE_STRING NewFullLinkName;
    PWCHAR NewFullLinkNameBuffer = NULL;
    UCHAR NewLinkNameFlags;

    PFILE_NAME FileNameAttr = NULL;
    USHORT FileNameAttrLength = 0;

    UNICODE_STRING PrevLinkName;
    UNICODE_STRING PrevFullLinkName;
    UCHAR PrevLinkNameFlags;

    UNICODE_STRING SourceFullLinkName;
    USHORT SourceLinkLastNameOffset;

    BOOLEAN FoundLink;
    PINDEX_ENTRY IndexEntry;
    PBCB IndexEntryBcb = NULL;
    PWCHAR NextChar;

    BOOLEAN ReportDirNotify = FALSE;

    ULONG RenameFlags = ACTIVELY_REMOVE_SOURCE_LINK | REMOVE_SOURCE_LINK | ADD_TARGET_LINK;

    PLIST_ENTRY Links;
    PSCB ThisScb;

    PFCB_USN_RECORD SavedFcbUsnRecord = NULL;
    ULONG SavedUsnReason = 0;

    NAME_PAIR NamePair;
    NTFS_TUNNELED_DATA TunneledData;
    ULONG TunneledDataSize;
    BOOLEAN HaveTunneledInformation = FALSE;
    PFCB LockedFcb = NULL;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_IRP( Irp );
    ASSERT_SCB( Scb );

    PAGED_CODE ();

    DebugTrace( +1, Dbg, ("NtfsSetRenameInfo...\n") );

    //
    //  See if we are doing a stream rename.  The allowed inputs are:
    //      No associated file object.
    //      Rename Name begins with a colon
    //  If so, perform the rename
    //

    TargetFileObject = IrpSp->Parameters.SetFile.FileObject;

    if (TargetFileObject == NULL) {
        PFILE_RENAME_INFORMATION FileRename;

        FileRename = IrpContext->OriginatingIrp->AssociatedIrp.SystemBuffer;

        if (FileRename->FileNameLength >= sizeof( WCHAR ) &&
            FileRename->FileName[0] == L':') {

            NewLinkName.Buffer = FileRename->FileName;
            NewLinkName.MaximumLength =
                NewLinkName.Length = (USHORT) FileRename->FileNameLength;

            Status = NtfsStreamRename( IrpContext, FileObject, Fcb, Scb, Ccb, FileRename->ReplaceIfExists, &NewLinkName );
            DebugTrace( -1, Dbg, ("NtfsSetRenameInfo:  Exit -> %08lx\n", Status) );
            return Status;
        }
    }

    //
    //  Do a quick check that the caller is allowed to do the rename.
    //  The opener must have opened the main data stream by name and this can't be
    //  a system file.
    //

    if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE ) ||
        (Lcb == NULL) ||
        FlagOn(Fcb->FcbState, FCB_STATE_SYSTEM_FILE)) {

        DebugTrace( -1, Dbg, ("NtfsSetRenameInfo:  Exit -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  If this link has been deleted, then we don't allow this operation.
    //

    if (LcbLinkIsDeleted( Lcb )) {

        DebugTrace( -1, Dbg, ("NtfsSetRenameInfo:  Exit -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Verify that we can wait.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        Status = NtfsPostRequest( IrpContext, Irp );

        DebugTrace( -1, Dbg, ("NtfsSetRenameInfo:  Can't wait\n") );
        return Status;
    }

    //
    //  Remember the source info flags in the Ccb.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Initialize the local variables.
        //

        ParentScb = Lcb->Scb;
        NtfsInitializeNamePair( &NamePair );

        if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID ) &&
            (Vcb->NotifyCount != 0)) {

            ReportDirNotify = TRUE;
        }

        PrevFullLinkName.Buffer = NULL;
        SourceFullLinkName.Buffer = NULL;

        //
        //  If this is a directory file, we need to examine its descendents.
        //  We may not remove a link which may be an ancestor path
        //  component of any open file.
        //

        if (IsDirectory( &Fcb->Info )) {

            Status = NtfsCheckTreeForBatchOplocks( IrpContext, Irp, Scb );

            if (Status != STATUS_SUCCESS) { leave; }
        }

        //
        //  We now assemble the names and in memory-structures for both the
        //  source and target links and check if the target link currently
        //  exists.
        //

        NtfsFindTargetElements( IrpContext,
                                TargetFileObject,
                                ParentScb,
                                &TargetParentScb,
                                &NewFullLinkName,
                                &NewLinkName );

        //
        //  Check that the new name is not invalid.
        //

        if ((NewLinkName.Length > (NTFS_MAX_FILE_NAME_LENGTH * sizeof( WCHAR ))) ||
            !NtfsIsFileNameValid( &NewLinkName, FALSE )) {

            Status = STATUS_OBJECT_NAME_INVALID;
            leave;
        }

        //
        //  Acquire the current parent in order to synchronize removing the current name.
        //

        NtfsAcquireExclusiveScb( IrpContext, ParentScb );

        //
        //  If this Scb does not have a normalized name then provide it with one now.
        //

        if (ParentScb->ScbType.Index.NormalizedName.Length == 0) {

            NtfsBuildNormalizedName( IrpContext,
                                     ParentScb->Fcb,
                                     ParentScb,
                                     &ParentScb->ScbType.Index.NormalizedName );
        }

        //
        //  If this is a directory then make sure it has a normalized name.
        //

        if (IsDirectory( &Fcb->Info ) &&
            (Scb->ScbType.Index.NormalizedName.Length == 0)) {

            NtfsUpdateNormalizedName( IrpContext,
                                      ParentScb,
                                      Scb,
                                      NULL,
                                      FALSE );
        }

        //
        //  Check if we are renaming to the same directory with the exact same name.
        //

        if (TargetParentScb == ParentScb) {

            if (NtfsAreNamesEqual( Vcb->UpcaseTable, &NewLinkName, &Lcb->ExactCaseLink.LinkName, FALSE )) {

                DebugTrace( 0, Dbg, ("Renaming to same name and directory\n") );
                leave;
            }

        //
        //  Otherwise we want to acquire the target directory.
        //

        } else {

            //
            //  We need to do the acquisition carefully since we may only have the Vcb shared.
            //

            if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX )) {

                if (!NtfsAcquireExclusiveFcb( IrpContext,
                                              TargetParentScb->Fcb,
                                              TargetParentScb,
                                              ACQUIRE_DONT_WAIT )) {

                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

                //
                //  Now snapshot the Scb.
                //

                if (FlagOn( TargetParentScb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

                    NtfsSnapshotScb( IrpContext, TargetParentScb );
                }

            } else {

                NtfsAcquireExclusiveScb( IrpContext, TargetParentScb );
            }

            SetFlag( RenameFlags, MOVE_TO_NEW_DIR );
        }

        //
        //  We also determine which type of link to
        //  create.  We create a hard link only unless the source link is
        //  a primary link and the user is an IgnoreCase guy.
        //

        if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS ) &&
            FlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE )) {

            SetFlag( RenameFlags, ADD_PRIMARY_LINK );
        }

        //
        //  Lookup the entry for this filename in the target directory.
        //  We look in the Ccb for the type of case match for the target
        //  name.
        //

        FoundLink = NtfsLookupEntry( IrpContext,
                                     TargetParentScb,
                                     BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ),
                                     &NewLinkName,
                                     &FileNameAttr,
                                     &FileNameAttrLength,
                                     NULL,
                                     &IndexEntry,
                                     &IndexEntryBcb,
                                     NULL );

        //
        //  This call to NtfsLookupEntry may decide to push the root index,
        //  in which case we might be holding the Mft now.  If there is a
        //  transaction, commit it now so we will be able to free the Mft to
        //  eliminate a potential deadlock with the ObjectId index when we
        //  look up the object id for the rename source to add it to the
        //  tunnel cache.
        //

        if (IrpContext->TransactionId != 0) {

            NtfsCheckpointCurrentTransaction( IrpContext );

            //
            //  Go through and free any Scb's in the queue of shared
            //  Scb's for transactions.
            //

            if (IrpContext->SharedScb != NULL) {

                NtfsReleaseSharedResources( IrpContext );
                ASSERT( IrpContext->SharedScb == NULL );
            }

            //
            //  Release the mft, if we acquired it in pushing the root index.
            //

            NtfsReleaseExclusiveScbIfOwned( IrpContext, Vcb->MftScb );
        }

        //
        //  If we found a matching link, we need to check how we want to operate
        //  on the source link and the target link.  This means whether we
        //  have any work to do, whether we need to remove the target link
        //  and whether we need to remove the source link.
        //

        if (FoundLink) {

            PFILE_NAME IndexFileName;

            //
            //  Assume we will remove this link.
            //

            SetFlag( RenameFlags, REMOVE_TARGET_LINK );

            IndexFileName = (PFILE_NAME) NtfsFoundIndexEntry( IndexEntry );

            NtfsCheckLinkForRename( Fcb,
                                    Lcb,
                                    IndexFileName,
                                    IndexEntry->FileReference,
                                    &NewLinkName,
                                    BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ),
                                    &RenameFlags );

            //
            //  Assume we will use the existing name flags on the link found.  This
            //  will be the case where the file was opened with the 8.3 name and
            //  the new name is exactly the long name for the same file.
            //

            PrevLinkNameFlags =
            NewLinkNameFlags = IndexFileName->Flags;

            //
            //  If we didn't have an exact match, then we need to check if we
            //  can remove the found link and then remove it from the disk.
            //

            if (FlagOn( RenameFlags, REMOVE_TARGET_LINK )) {

                //
                //  We need to check that the user wanted to remove that link.
                //

                if (!FlagOn( RenameFlags, TRAVERSE_MATCH ) &&
                    !IrpSp->Parameters.SetFile.ReplaceIfExists) {

                    Status = STATUS_OBJECT_NAME_COLLISION;
                    leave;
                }

                //
                //  We want to preserve the case and the flags of the matching
                //  link found.  We also want to preserve the case of the
                //  name being created.  The following variables currently contain
                //  the exact case for the target to remove and the new name to
                //  apply.
                //
                //      Link to remove - In 'IndexEntry'.
                //          The link's flags are also in 'IndexEntry'.  We copy
                //          these flags to 'PrevLinkNameFlags'
                //
                //      New Name - Exact case is stored in 'NewLinkName'
                //               - It is also in 'FileNameAttr
                //
                //  We modify this so that we can use the FileName attribute
                //  structure to create the new link.  We copy the linkname being
                //  removed into 'PrevLinkName'.   The following is the
                //  state after the switch.
                //
                //      'FileNameAttr' - contains the name for the link being
                //          created.
                //
                //      'PrevLinkFileName' - Contains the link name for the link being
                //          removed.
                //
                //      'PrevLinkFileNameFlags' - Contains the name flags for the link
                //          being removed.
                //

                //
                //  Allocate a buffer for the name being removed.  It should be
                //  large enough for the entire directory name.
                //

                PrevFullLinkName.MaximumLength = TargetParentScb->ScbType.Index.NormalizedName.Length +
                                                 sizeof( WCHAR ) +
                                                 (IndexFileName->FileNameLength * sizeof( WCHAR ));

                PrevFullLinkName.Buffer = NtfsAllocatePool( PagedPool,
                                                            PrevFullLinkName.MaximumLength );

                RtlCopyMemory( PrevFullLinkName.Buffer,
                               TargetParentScb->ScbType.Index.NormalizedName.Buffer,
                               TargetParentScb->ScbType.Index.NormalizedName.Length );

                NextChar = Add2Ptr( PrevFullLinkName.Buffer,
                                    TargetParentScb->ScbType.Index.NormalizedName.Length );

                if (TargetParentScb != Vcb->RootIndexScb) {

                    *NextChar = L'\\';
                    NextChar += 1;
                }

                RtlCopyMemory( NextChar,
                               IndexFileName->FileName,
                               IndexFileName->FileNameLength * sizeof( WCHAR ));

                //
                //  Copy the name found in the Index Entry to 'PrevLinkName'
                //

                PrevLinkName.Buffer = NextChar;
                PrevLinkName.MaximumLength =
                PrevLinkName.Length = IndexFileName->FileNameLength * sizeof( WCHAR );

                //
                //  Update the full name length with the final component.
                //

                PrevFullLinkName.Length = (USHORT) PtrOffset( PrevFullLinkName.Buffer, NextChar ) + PrevLinkName.Length;

                //
                //  We only need this check if the link is for a different file.
                //

                if (!FlagOn( RenameFlags, TRAVERSE_MATCH )) {

                    //
                    //  We check if there is an existing Fcb for the target link.
                    //  If there is, the unclean count better be 0.
                    //

                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    AcquiredFcbTable = TRUE;

                    TargetLinkFcb = NtfsCreateFcb( IrpContext,
                                                   Vcb,
                                                   IndexEntry->FileReference,
                                                   FALSE,
                                                   BooleanFlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_INDEX ),
                                                   &ExistingTargetLinkFcb );

                    //
                    //  Before we go on, make sure we aren't about to rename over a system file.
                    //

                    if (FlagOn( TargetLinkFcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

                        Status = STATUS_ACCESS_DENIED;
                        leave;
                    }

                    //
                    //  Add a paging resource to the target - this is not supplied if its created
                    //  from scratch. We need this (acquired in the proper order) for the delete
                    //  to work correctly if there are any data streams. It's not going to harm a
                    //  directory del and because of the teardown in the finally clause its difficult
                    //  to retry again without looping.
                    //

                    NtfsLockFcb( IrpContext, TargetLinkFcb );
                    LockedFcb = TargetLinkFcb;
                    if (TargetLinkFcb->PagingIoResource == NULL) {
                        TargetLinkFcb->PagingIoResource = NtfsAllocateEresource();
                    }
                    NtfsUnlockFcb( IrpContext, LockedFcb );
                    LockedFcb = NULL;

                    //
                    //  We need to acquire this file carefully in the event that we don't hold
                    //  the Vcb exclusively.
                    //

                    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX )) {

                        if (!ExAcquireResourceExclusiveLite( TargetLinkFcb->PagingIoResource, FALSE )) {

                            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                        }

                        FcbWithPagingToRelease = TargetLinkFcb;

                        if (!NtfsAcquireExclusiveFcb( IrpContext, TargetLinkFcb, NULL, ACQUIRE_DONT_WAIT )) {

                            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                        }

                        NtfsReleaseFcbTable( IrpContext, Vcb );
                        AcquiredFcbTable = FALSE;

                    } else {

                        NtfsReleaseFcbTable( IrpContext, Vcb );
                        AcquiredFcbTable = FALSE;

                        //
                        //  Acquire the paging Io resource for this file before the main
                        //  resource in case we need to delete.
                        //

                        FcbWithPagingToRelease = TargetLinkFcb;
                        ExAcquireResourceExclusiveLite( FcbWithPagingToRelease->PagingIoResource, TRUE );

                        NtfsAcquireExclusiveFcb( IrpContext, TargetLinkFcb, NULL, 0 );
                    }

                    AcquiredTargetLinkFcb = TRUE;

                    //
                    //  If the Fcb Info field needs to be initialized, we do so now.
                    //  We read this information from the disk as the duplicate information
                    //  in the index entry is not guaranteed to be correct.
                    //

                    if (!FlagOn( TargetLinkFcb->FcbState, FCB_STATE_DUP_INITIALIZED )) {

                        NtfsUpdateFcbInfoFromDisk( IrpContext,
                                                   TRUE,
                                                   TargetLinkFcb,
                                                   NULL );
                        NtfsConditionallyFixupQuota( IrpContext, TargetLinkFcb );

                        if (IrpContext->TransactionId != 0) {

                            NtfsCheckpointCurrentTransaction( IrpContext );
                            ASSERTMSG( "Ntfs: we should not own the mftscb\n", !NtfsIsSharedScb( Vcb->MftScb ) );
                        }
                    }

                    //
                    //  We are adding a link to the source file which already
                    //  exists as a link to a different file in the target directory.
                    //
                    //  We need to check whether we permitted to delete this
                    //  link.  If not then it is possible that the problem is
                    //  an existing batch oplock on the file.  In that case
                    //  we want to delete the batch oplock and try this again.
                    //

                    Status = NtfsCheckFileForDelete( IrpContext,
                                                     TargetParentScb,
                                                     TargetLinkFcb,
                                                     ExistingTargetLinkFcb,
                                                     IndexEntry );

                    if (!NT_SUCCESS( Status )) {

                        PSCB NextScb = NULL;

                        //
                        //  We are going to either fail this request or pass
                        //  this on to the oplock package.  Test if there is
                        //  a batch oplock on any streams on this file.
                        //

                        while ((NextScb = NtfsGetNextChildScb( TargetLinkFcb,
                                                               NextScb )) != NULL) {

                            if ((NextScb->AttributeTypeCode == $DATA) &&
                                (NextScb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA) &&
                                FsRtlCurrentBatchOplock( &NextScb->ScbType.Data.Oplock )) {

                                if (*VcbAcquired) {
                                    NtfsReleaseVcb( IrpContext, Vcb );
                                    *VcbAcquired = FALSE;
                                }

                                Status = FsRtlCheckOplock( &NextScb->ScbType.Data.Oplock,
                                                           Irp,
                                                           IrpContext,
                                                           NtfsOplockComplete,
                                                           NtfsPrePostIrp );
                                break;
                            }
                        }

                        leave;
                    }

                    NtfsCleanupLinkForRemoval( TargetLinkFcb, TargetParentScb, ExistingTargetLinkFcb );

                    //
                    //  DeleteFile might need to get the reparse index to remove a reparse
                    //  point.  We may need the object id index later to deal with the
                    //  tunnel cache.  Let's acquire them in the right order now.
                    //

                    if (HasReparsePoint( &TargetLinkFcb->Info ) &&
                        (Vcb->ReparsePointTableScb != NULL)) {

                        NtfsAcquireExclusiveScb( IrpContext, Vcb->ReparsePointTableScb );
                        AcquiredReparsePointIndex = TRUE;
                    }

                    if (Vcb->ObjectIdTableScb != NULL) {

                        NtfsAcquireExclusiveScb( IrpContext, Vcb->ObjectIdTableScb );
                        AcquiredObjectIdIndex = TRUE;
                    }

                    if (TargetLinkFcb->LinkCount == 1) {

                        PFCB TempFcb;

                        //
                        //  Fixup the IrpContext CleanupStructure so deletefile logs correctly
                        //

                        TempFcb = (PFCB) IrpContext->CleanupStructure;
                        IrpContext->CleanupStructure = FcbWithPagingToRelease;

                        ASSERT( (NULL == TempFcb) || (NTFS_NTC_FCB == SafeNodeType( TempFcb )) );

                        FcbWithPagingToRelease = TempFcb;

                        NtfsDeleteFile( IrpContext,
                                        TargetLinkFcb,
                                        TargetParentScb,
                                        &AcquiredParentScb,
                                        NULL,
                                        NULL );

                        FcbWithPagingToRelease = IrpContext->CleanupStructure;
                        IrpContext->CleanupStructure = TempFcb;

                        //
                        //  Make sure to force the close record out to disk.
                        //

                        TargetLinkFcbCountAdj += 1;

                    } else {
                        NtfsPostUsnChange( IrpContext, TargetLinkFcb, USN_REASON_HARD_LINK_CHANGE | USN_REASON_CLOSE );
                        NtfsRemoveLink( IrpContext,
                                        TargetLinkFcb,
                                        TargetParentScb,
                                        PrevLinkName,
                                        NULL,
                                        NULL );

                        ClearFlag( TargetLinkFcb->FcbState, FCB_STATE_VALID_USN_NAME );

                        TargetLinkFcbCountAdj += 1;
                        NtfsUpdateFcb( TargetLinkFcb, FCB_INFO_CHANGED_LAST_CHANGE );
                    }

                //
                //  The target link is for the same file as the source link.  No security
                //  checks need to be done.  Go ahead and remove it.
                //

                } else {

                    NtfsPostUsnChange( IrpContext, Scb, USN_REASON_RENAME_OLD_NAME );

                    TargetLinkFcb = Fcb;
                    NtfsRemoveLink( IrpContext,
                                    Fcb,
                                    TargetParentScb,
                                    PrevLinkName,
                                    NULL,
                                    NULL );

                    FcbLinkCountAdj += 1;
                }
            }
        }

        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        //
        //  Post the Usn record for the old name.  Don't write it until after
        //  we check if we need to remove an object ID due to tunnelling.
        //  Otherwise we might deadlock between the journal/mft resources
        //  and the object id resources.
        //

        NtfsPostUsnChange( IrpContext, Scb, USN_REASON_RENAME_OLD_NAME );

        //
        //  See if we need to remove the current link.
        //

        if (FlagOn( RenameFlags, REMOVE_SOURCE_LINK )) {

            //
            //  Now we want to remove the source link from the file.  We need to
            //  remember if we deleted a two part primary link.
            //

            if (FlagOn( RenameFlags, ACTIVELY_REMOVE_SOURCE_LINK )) {

                TunneledData.HasObjectId = FALSE;
                NtfsRemoveLink( IrpContext,
                                Fcb,
                                ParentScb,
                                Lcb->ExactCaseLink.LinkName,
                                &NamePair,
                                &TunneledData );

                //
                //  Remember the full name for the original filename and some
                //  other information to pass to the dirnotify package.
                //

                if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID )) {

                    if (!IsDirectory( &Fcb->Info ) &&
                        !FlagOn( FileObject->Flags, FO_OPENED_CASE_SENSITIVE )) {

                        //
                        //  Tunnel property information for file links
                        //

                        NtfsGetTunneledData( IrpContext,
                                             Fcb,
                                             &TunneledData );

                        FsRtlAddToTunnelCache(  &Vcb->Tunnel,
                                                *(PULONGLONG)&ParentScb->Fcb->FileReference,
                                                &NamePair.Short,
                                                &NamePair.Long,
                                                BooleanFlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS ),
                                                sizeof( NTFS_TUNNELED_DATA ),
                                                &TunneledData );
                    }
                }

                FcbLinkCountAdj += 1;
            }

            if (ReportDirNotify) {

                SourceFullLinkName.Buffer = NtfsAllocatePool( PagedPool, Ccb->FullFileName.Length );

                RtlCopyMemory( SourceFullLinkName.Buffer,
                               Ccb->FullFileName.Buffer,
                               Ccb->FullFileName.Length );

                SourceFullLinkName.MaximumLength = SourceFullLinkName.Length = Ccb->FullFileName.Length;
                SourceLinkLastNameOffset = Ccb->LastFileNameOffset;
            }
        }

        //
        //  See if we need to add the target link.
        //

        if (FlagOn( RenameFlags, ADD_TARGET_LINK )) {

            //
            //  Check that we have permission to add a file to this directory.
            //

            NtfsCheckIndexForAddOrDelete( IrpContext,
                                          TargetParentScb->Fcb,
                                          (IsDirectory( &Fcb->Info ) ?
                                           FILE_ADD_SUBDIRECTORY :
                                           FILE_ADD_FILE),
                                          Ccb->AccessFlags >> 2 );

            //
            //  Grunge the tunnel cache for property restoration
            //

            if (!IsDirectory( &Fcb->Info ) &&
                !FlagOn( FileObject->Flags, FO_OPENED_CASE_SENSITIVE )) {

                NtfsResetNamePair( &NamePair );
                TunneledDataSize = sizeof( NTFS_TUNNELED_DATA );

                if (FsRtlFindInTunnelCache( &Vcb->Tunnel,
                                            *(PULONGLONG)&TargetParentScb->Fcb->FileReference,
                                            &NewLinkName,
                                            &NamePair.Short,
                                            &NamePair.Long,
                                            &TunneledDataSize,
                                            &TunneledData)) {

                    ASSERT( TunneledDataSize == sizeof( NTFS_TUNNELED_DATA ));
                    HaveTunneledInformation = TRUE;
                }
            }

            //
            //  We now want to add the new link into the target directory.
            //  We create a hard link only if the source name was a hard link
            //  or this is a case-sensitive open.  This means that we can
            //  replace a primary link pair with a hard link only.
            //

            NtfsAddLink( IrpContext,
                         BooleanFlagOn( RenameFlags, ADD_PRIMARY_LINK ),
                         TargetParentScb,
                         Fcb,
                         FileNameAttr,
                         NULL,
                         &NewLinkNameFlags,
                         NULL,
                         HaveTunneledInformation ? &NamePair : NULL,
                         NULL );

            //
            //  Restore timestamps on tunneled files
            //

            if (HaveTunneledInformation) {

                NtfsSetTunneledData( IrpContext,
                                     Fcb,
                                     &TunneledData );

                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_CREATE );
                SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

                //
                //  If we have tunneled information then copy the correct case of the
                //  name into the new link pointer.
                //

                if (NewLinkNameFlags == FILE_NAME_DOS) {

                    RtlCopyMemory( NewLinkName.Buffer,
                                   NamePair.Short.Buffer,
                                   NewLinkName.Length );
                }
            }

            //
            //  Update the flags field in the target file name.  We will use this
            //  below if we are updating the normalized name.
            //

            FileNameAttr->Flags = NewLinkNameFlags;

            if (ParentScb != TargetParentScb) {

                NtfsUpdateFcb( TargetParentScb->Fcb,
                               (FCB_INFO_CHANGED_LAST_CHANGE |
                                FCB_INFO_CHANGED_LAST_MOD |
                                FCB_INFO_UPDATE_LAST_ACCESS) );
            }

            //
            //  If we need a full buffer for the new name for notify and don't already
            //  have one then construct the full name now.  This will only happen if
            //  we are renaming within the same directory.
            //

            if (ReportDirNotify &&
                (NewFullLinkName.Buffer == NULL)) {

                NewFullLinkName.MaximumLength = Ccb->LastFileNameOffset + NewLinkName.Length;

                NewFullLinkNameBuffer = NtfsAllocatePool( PagedPool,
                                                          NewFullLinkName.MaximumLength );

                RtlCopyMemory( NewFullLinkNameBuffer,
                               Ccb->FullFileName.Buffer,
                               Ccb->LastFileNameOffset );

                RtlCopyMemory( Add2Ptr( NewFullLinkNameBuffer, Ccb->LastFileNameOffset ),
                               NewLinkName.Buffer,
                               NewLinkName.Length );

                NewFullLinkName.Buffer = NewFullLinkNameBuffer;
                NewFullLinkName.Length = NewFullLinkName.MaximumLength;
            }

            FcbLinkCountAdj -= 1;
        }

        //
        //  Now write the Usn record for the old name if it exists.  Since this call
        //  needs to acquire the usn journal and/or mft, we need to do this after the
        //  NtfsSetTunneledData call, since that may acquire the object id index.
        //

        if (IrpContext->Usn.CurrentUsnFcb != NULL) {
            NtfsWriteUsnJournalChanges( IrpContext );
        }

        //
        //  We need to update the names in the Lcb for this file as well as any subdirectories
        //  or files.  We will do this in two passes.  The first pass is just to reserve enough
        //  space in all of the file objects and Lcb's.  We update the names in the second pass.
        //

        if (FlagOn( RenameFlags, TRAVERSE_MATCH )) {

            if (FlagOn( RenameFlags, REMOVE_TARGET_LINK )) {

                SetFlag( RenameFlags, REMOVE_TRAVERSE_LINK );

            } else {

                SetFlag( RenameFlags, REUSE_TRAVERSE_LINK );
            }
        }

        //
        //  If this is a directory and we added a target link it means that the
        //  normalized name has changed.  Make sure the buffer in the Scb will hold
        //  the larger name.
        //

        if (IsDirectory( &Fcb->Info ) && FlagOn( RenameFlags, ADD_TARGET_LINK )) {

            NtfsUpdateNormalizedName( IrpContext,
                                      TargetParentScb,
                                      Scb,
                                      FileNameAttr,
                                      TRUE );
        }

        //
        //  Now post a rename change on the Fcb.  We delete the old Usn record first,
        //  since it has the wrong name.  No need to get the mutex since we have the
        //  file exclusive.
        //

        if (Fcb->FcbUsnRecord != NULL) {

            SavedFcbUsnRecord = Fcb->FcbUsnRecord;
            SavedUsnReason = SavedFcbUsnRecord->UsnRecord.Reason;
            if (SavedFcbUsnRecord->ModifiedOpenFilesLinks.Flink != NULL) {
                NtfsLockFcb( IrpContext, Vcb->UsnJournal->Fcb );
                RemoveEntryList( &SavedFcbUsnRecord->ModifiedOpenFilesLinks );

                if (SavedFcbUsnRecord->TimeOutLinks.Flink != NULL) {

                    RemoveEntryList( &SavedFcbUsnRecord->TimeOutLinks );
                    SavedFcbUsnRecord->ModifiedOpenFilesLinks.Flink = NULL;
                }

                NtfsUnlockFcb( IrpContext, Vcb->UsnJournal->Fcb );
            }
            Fcb->FcbUsnRecord = NULL;

            //
            //  Note - Fcb is unlocked immediately below in the finally clause.
            //
        }

        //
        //  Post the rename to the Usn Journal.  We wait until the end, in order to
        //  reduce resource contention on the UsnJournal, in the event that we already
        //  posted a change when we deleted the target file.
        //

        NtfsPostUsnChange( IrpContext,
                           Scb,
                           (SavedUsnReason & ~USN_REASON_RENAME_OLD_NAME) | USN_REASON_RENAME_NEW_NAME );

        //
        //  Now, if anything at all is posted to the Usn Journal, we must write it now
        //  so that we do not get a log file full later.  But do not checkpoint until
        //  any failure cases are behind us.
        //

        if (IrpContext->Usn.CurrentUsnFcb != NULL) {
            NtfsWriteUsnJournalChanges( IrpContext );
        }

        //
        //  We have now modified the on-disk structures.  We now need to
        //  modify the in-memory structures.  This includes the Fcb and Lcb's
        //  for any links we superseded, and the source Fcb and it's Lcb's.
        //
        //  We will do this in two passes.  The first pass will guarantee that all of the
        //  name buffers will be large enough for the names.  The second pass will store the
        //  names into the buffers.
        //

        if (FlagOn( RenameFlags, MOVE_TO_NEW_DIR )) {

            NtfsMoveLinkToNewDir( IrpContext,
                                  &NewFullLinkName,
                                  &NewLinkName,
                                  NewLinkNameFlags,
                                  TargetParentScb,
                                  Fcb,
                                  Lcb,
                                  RenameFlags,
                                  &PrevLinkName,
                                  PrevLinkNameFlags );

        //
        //  Otherwise we will rename in the current directory.  We need to remember
        //  if we have merged with an existing link on this file.
        //

        } else {

            NtfsRenameLinkInDir( IrpContext,
                                 ParentScb,
                                 Fcb,
                                 Lcb,
                                 &NewLinkName,
                                 NewLinkNameFlags,
                                 RenameFlags,
                                 &PrevLinkName,
                                 PrevLinkNameFlags );
        }

        //
        //  Now, checkpoint the transaction to free resources if we are holding on
        //  to the Usn Journal.  No more failures can occur.
        //

        if (IrpContext->Usn.CurrentUsnFcb != NULL) {
            NtfsCheckpointCurrentTransaction( IrpContext );
        }

        //
        //  Nothing should fail from this point forward.
        //
        //  Now make the change to the normalized name.  The buffer should be
        //  large enough.
        //

        if (IsDirectory( &Fcb->Info ) && FlagOn( RenameFlags, ADD_TARGET_LINK )) {

            NtfsUpdateNormalizedName( IrpContext,
                                      TargetParentScb,
                                      Scb,
                                      FileNameAttr,
                                      FALSE );
        }

        //
        //  Now look at the link we superseded.  If we deleted the file then go through and
        //  mark everything as deleted.
        //

        if (FlagOn( RenameFlags, REMOVE_TARGET_LINK | TRAVERSE_MATCH ) == REMOVE_TARGET_LINK) {

            NtfsUpdateFcbFromLinkRemoval( IrpContext,
                                          TargetParentScb,
                                          TargetLinkFcb,
                                          PrevLinkName,
                                          PrevLinkNameFlags );

            //
            //  If the link count is going to 0, we need to perform the work of
            //  removing the file.
            //

            if (TargetLinkFcb->LinkCount == 1) {

                SetFlag( TargetLinkFcb->FcbState, FCB_STATE_FILE_DELETED );

                //
                //  We need to mark all of the Scbs as gone.
                //

                for (Links = TargetLinkFcb->ScbQueue.Flink;
                     Links != &TargetLinkFcb->ScbQueue;
                     Links = Links->Flink) {

                    ThisScb = CONTAINING_RECORD( Links,
                                                 SCB,
                                                 FcbLinks );

                    SetFlag( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
                }
            }
        }

        //
        //  Change the time stamps in the parent if we modified the links in this directory.
        //

        if (FlagOn( RenameFlags, REMOVE_SOURCE_LINK )) {

            NtfsUpdateFcb( ParentScb->Fcb,
                           (FCB_INFO_CHANGED_LAST_CHANGE |
                            FCB_INFO_CHANGED_LAST_MOD |
                            FCB_INFO_UPDATE_LAST_ACCESS) );
        }

        //
        //  We always set the last change time on the file we renamed unless
        //  the caller explicitly set this.
        //

        SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );

        //
        //  Don't set the archive bit on a directory.  Otherwise we break existing
        //  apps that don't expect to see this flag.
        //

        if (!IsDirectory( &Fcb->Info )) {

            SetFlag( Ccb->Flags, CCB_FLAG_SET_ARCHIVE );
        }

        //
        //  Report the changes to the affected directories.  We defer reporting
        //  until now so that all of the on disk changes have been made.
        //  We have already preserved the original file name for any changes
        //  associated with it.
        //
        //  Note that we may have to make a call to notify that we are removing
        //  a target if there is only a case change.  This could make for
        //  a third notify call.
        //
        //  Now that we have the new name we need to decide whether to report
        //  this as a change in the file or adding a file to a new directory.
        //

        if (ReportDirNotify) {

            ULONG FilterMatch = 0;
            ULONG Action;

            //
            //  If we are deleting a target link in order to make a case change then
            //  report that.
            //

            if ((PrevFullLinkName.Buffer != NULL) &&
                FlagOn( RenameFlags,
                        OVERWRITE_SOURCE_LINK | REMOVE_TARGET_LINK | EXACT_CASE_MATCH ) == REMOVE_TARGET_LINK) {

                NtfsReportDirNotify( IrpContext,
                                     Vcb,
                                     &PrevFullLinkName,
                                     PrevFullLinkName.Length - PrevLinkName.Length,
                                     NULL,
                                     ((TargetParentScb->ScbType.Index.NormalizedName.Length != 0) ?
                                      &TargetParentScb->ScbType.Index.NormalizedName :
                                      NULL),
                                     (IsDirectory( &TargetLinkFcb->Info ) ?
                                      FILE_NOTIFY_CHANGE_DIR_NAME :
                                      FILE_NOTIFY_CHANGE_FILE_NAME),
                                     FILE_ACTION_REMOVED,
                                     TargetParentScb->Fcb );
            }

            //
            //  If we stored the original name then we report the changes
            //  associated with it.
            //

            if (FlagOn( RenameFlags, REMOVE_SOURCE_LINK )) {

                NtfsReportDirNotify( IrpContext,
                                     Vcb,
                                     &SourceFullLinkName,
                                     SourceLinkLastNameOffset,
                                     NULL,
                                     ((ParentScb->ScbType.Index.NormalizedName.Length != 0) ?
                                      &ParentScb->ScbType.Index.NormalizedName :
                                      NULL),
                                     (IsDirectory( &Fcb->Info ) ?
                                      FILE_NOTIFY_CHANGE_DIR_NAME :
                                      FILE_NOTIFY_CHANGE_FILE_NAME),
                                     ((FlagOn( RenameFlags, MOVE_TO_NEW_DIR ) ||
                                       !FlagOn( RenameFlags, ADD_TARGET_LINK ) ||
                                       (FlagOn( RenameFlags, REMOVE_TARGET_LINK | EXACT_CASE_MATCH ) == (REMOVE_TARGET_LINK | EXACT_CASE_MATCH))) ?
                                      FILE_ACTION_REMOVED :
                                      FILE_ACTION_RENAMED_OLD_NAME),
                                     ParentScb->Fcb );
            }

            //
            //  Check if a new name will appear in the directory.
            //

            if (!FoundLink ||
                (FlagOn( RenameFlags, OVERWRITE_SOURCE_LINK | EXACT_CASE_MATCH) == OVERWRITE_SOURCE_LINK) ||
                (FlagOn( RenameFlags, REMOVE_TARGET_LINK | EXACT_CASE_MATCH ) == REMOVE_TARGET_LINK)) {

                FilterMatch = IsDirectory( &Fcb->Info)
                              ? FILE_NOTIFY_CHANGE_DIR_NAME
                              : FILE_NOTIFY_CHANGE_FILE_NAME;

                //
                //  If we moved to a new directory, remember the
                //  action was a create operation.
                //

                if (FlagOn( RenameFlags, MOVE_TO_NEW_DIR )) {

                    Action = FILE_ACTION_ADDED;

                } else {

                    Action = FILE_ACTION_RENAMED_NEW_NAME;
                }

            //
            //  There was an entry with the same case.  If this isn't the
            //  same file then we report a change to all the file attributes.
            //

            } else if (FlagOn( RenameFlags, REMOVE_TARGET_LINK | TRAVERSE_MATCH ) == REMOVE_TARGET_LINK) {

                FilterMatch = (FILE_NOTIFY_CHANGE_ATTRIBUTES |
                               FILE_NOTIFY_CHANGE_SIZE |
                               FILE_NOTIFY_CHANGE_LAST_WRITE |
                               FILE_NOTIFY_CHANGE_LAST_ACCESS |
                               FILE_NOTIFY_CHANGE_CREATION |
                               FILE_NOTIFY_CHANGE_SECURITY |
                               FILE_NOTIFY_CHANGE_EA);

                //
                //  The file name isn't changing, only the properties of the
                //  file.
                //

                Action = FILE_ACTION_MODIFIED;
            }

            if (FilterMatch != 0) {

                NtfsReportDirNotify( IrpContext,
                                     Vcb,
                                     &NewFullLinkName,
                                     NewFullLinkName.Length - NewLinkName.Length,
                                     NULL,
                                     ((TargetParentScb->ScbType.Index.NormalizedName.Length != 0) ?
                                      &TargetParentScb->ScbType.Index.NormalizedName :
                                      NULL),
                                     FilterMatch,
                                     Action,
                                     TargetParentScb->Fcb );
            }
        }

        //
        //  Now adjust the link counts on the different files.
        //

        if (TargetLinkFcb != NULL) {

            TargetLinkFcb->LinkCount -= TargetLinkFcbCountAdj;
            TargetLinkFcb->TotalLinks -= TargetLinkFcbCountAdj;

            //
            //  Now go through and mark everything as deleted.
            //

            if (TargetLinkFcb->LinkCount == 0) {

                SetFlag( TargetLinkFcb->FcbState, FCB_STATE_FILE_DELETED );

                //
                //  We need to mark all of the Scbs as gone.
                //

                for (Links = TargetLinkFcb->ScbQueue.Flink;
                     Links != &TargetLinkFcb->ScbQueue;
                     Links = Links->Flink) {

                    ThisScb = CONTAINING_RECORD( Links, SCB, FcbLinks );

                    if (!FlagOn( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

                        NtfsSnapshotScb( IrpContext, ThisScb );

                        ThisScb->ValidDataToDisk =
                        ThisScb->Header.AllocationSize.QuadPart =
                        ThisScb->Header.FileSize.QuadPart =
                        ThisScb->Header.ValidDataLength.QuadPart = 0;

                        SetFlag( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
                    }
                }
            }
        }

        Fcb->TotalLinks -= FcbLinkCountAdj;
        Fcb->LinkCount -= FcbLinkCountAdj;

    } finally {

        DebugUnwind( NtfsSetRenameInfo );

        if (LockedFcb != NULL) {
            NtfsUnlockFcb( IrpContext, LockedFcb );
        }

        //
        //  See if we have a SavedFcbUsnRecord.
        //

        if (SavedFcbUsnRecord != NULL) {

            //
            //  Conceivably we failed to reallcoate the record when we tried to post
            //  the rename.  If so, we will simply restore it here.  (Note the rename
            //  back to the old name will occur anyway.)
            //

            if (Fcb->FcbUsnRecord == NULL) {
                Fcb->FcbUsnRecord = SavedFcbUsnRecord;

            //
            //  Else just free the pool.
            //

            } else {
                NtfsFreePool( SavedFcbUsnRecord );
            }
        }

        //
        //  release objectid and reparse explicitly so we can call Teardown structures and wait to go up chain
        //

        if (AcquiredObjectIdIndex) { NtfsReleaseScb( IrpContext, Vcb->ObjectIdTableScb ); }
        if (AcquiredReparsePointIndex) { NtfsReleaseScb( IrpContext, Vcb->ReparsePointTableScb ); }
        if (AcquiredFcbTable) { NtfsReleaseFcbTable( IrpContext, Vcb ); }
        if (FcbWithPagingToRelease != NULL) { ExReleaseResourceLite( FcbWithPagingToRelease->PagingIoResource ); }
        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        //
        //  If we allocated any buffers for the notify operations deallocate them now.
        //

        if (NewFullLinkNameBuffer != NULL) { NtfsFreePool( NewFullLinkNameBuffer ); }
        if (PrevFullLinkName.Buffer != NULL) { NtfsFreePool( PrevFullLinkName.Buffer ); }
        if (SourceFullLinkName.Buffer != NULL) {

            NtfsFreePool( SourceFullLinkName.Buffer );
        }

        //
        //  If we allocated a file name attribute, we deallocate it now.
        //

        if (FileNameAttr != NULL) { NtfsFreePool( FileNameAttr ); }

        //
        //  If we allocated a buffer for the tunneled names, deallocate them now.
        //

        if (NamePair.Long.Buffer != NamePair.LongBuffer) {

            NtfsFreePool( NamePair.Long.Buffer );
        }

        //
        //  Some cleanup only occurs if this request has not been posted to
        // the oplock package

        if (Status != STATUS_PENDING) {

            if (AcquiredTargetLinkFcb) {

                NtfsTeardownStructures( IrpContext,
                                        TargetLinkFcb,
                                        NULL,
                                        FALSE,
                                        0,
                                        NULL );
            }
        }

        DebugTrace( -1, Dbg, ("NtfsSetRenameInfo:  Exit  ->  %08lx\n", Status) );
    }

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetLinkInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN OUT PBOOLEAN VcbAcquired
    )

/*++

Routine Description:

    This routine performs the set link function.  It will create a new link for a
    file.

Arguments:

    Irp - Supplies the Irp being processed

    Vcb - Supplies the Vcb for the Volume

    Scb - Supplies the Scb for the file/directory being modified

    Ccb - Supplies the Ccb for this file object

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PLCB Lcb = Ccb->Lcb;
    PFCB Fcb = Scb->Fcb;
    PSCB ParentScb = NULL;
    SHORT LinkCountAdj = 0;

    BOOLEAN AcquiredParentScb = TRUE;
    BOOLEAN AcquiredObjectIdIndex = FALSE;
    PFCB LockedFcb = NULL;

    UNICODE_STRING NewLinkName;
    UNICODE_STRING NewFullLinkName;
    PWCHAR NewFullLinkNameBuffer = NULL;
    PFILE_NAME NewLinkNameAttr = NULL;
    USHORT NewLinkNameAttrLength = 0;
    UCHAR NewLinkNameFlags;

    PSCB TargetParentScb;
    PFILE_OBJECT TargetFileObject = IrpSp->Parameters.SetFile.FileObject;

    BOOLEAN FoundPrevLink;
    UNICODE_STRING PrevLinkName;
    UNICODE_STRING PrevFullLinkName;
    UCHAR PrevLinkNameFlags;
    USHORT PrevFcbLinkCountAdj = 0;
    BOOLEAN ExistingPrevFcb = FALSE;
    PFCB PreviousFcb = NULL;

    ULONG RenameFlags = 0;

    BOOLEAN AcquiredFcbTable = FALSE;
    PFCB FcbWithPagingResourceToRelease = NULL;

    BOOLEAN ReportDirNotify = FALSE;
    PWCHAR NextChar;

    PINDEX_ENTRY IndexEntry;
    PBCB IndexEntryBcb = NULL;

    PLIST_ENTRY Links;
    PSCB ThisScb;
    PISECURITY_DESCRIPTOR SecurityDescriptor;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSetLinkInfo...\n") );

    PrevFullLinkName.Buffer = NULL;

    //
    //  If we are not opening the entire file, we can't set link info.
    //

    if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

        DebugTrace( -1, Dbg, ("NtfsSetLinkInfo:  Exit -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We also fail this if we are attempting to create a link on a directory.
    //  This will prevent cycles from being created.
    //

    if (FlagOn( Fcb->Info.FileAttributes, DUP_FILE_NAME_INDEX_PRESENT)) {

        DebugTrace( -1, Dbg, ("NtfsSetLinkInfo:  Exit -> %08lx\n", STATUS_FILE_IS_A_DIRECTORY) );
        return STATUS_FILE_IS_A_DIRECTORY;
    }

    //
    //  We can't add a link without having a parent directory.  Either we want to use the same
    //  parent or our caller supplied a parent.
    //

    if (Lcb == NULL) {

        //
        //  If the current file has been opened by FileId and there are no
        //  remaining links not marked for delete then don't allow this
        //  operation.  This is because we defer the delete of the last link
        //  until all of the OpenByID handles are closed.  We don't have any
        //  easy way to remember that there is a link to delete after
        //  the open through the link is closed.
        //
        //  The OPEN_BY_FILE_ID flag indicates that we used an open by Id somewhere
        //  in the open path.  This operation is OK if this user opened through
        //  a link, that's why we will only do this test if there is no Lcb.
        //

        if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID ) &&
            (Fcb->LinkCount == 0)) {

            Status = STATUS_ACCESS_DENIED;

            DebugTrace( -1, Dbg, ("NtfsSetLinkInfo:  Exit  ->  %08lx\n", Status) );
            return Status;
        }

        //
        //  If there is no target file object, then we can't add a link.
        //

        if (TargetFileObject == NULL) {

            DebugTrace( -1, Dbg, ("NtfsSetLinkInfo:  No target file object -> %08lx\n", STATUS_INVALID_PARAMETER) );
            return STATUS_INVALID_PARAMETER;
        }

    } else {

        ParentScb = Lcb->Scb;

        //
        //  If this link has been deleted, then we don't allow this operation.
        //

        if (LcbLinkIsDeleted( Lcb )) {

            Status = STATUS_ACCESS_DENIED;

            DebugTrace( -1, Dbg, ("NtfsSetLinkInfo:  Exit  ->  %08lx\n", Status) );
            return Status;
        }
    }

    //
    //  Check if we are allowed to perform this link operation.  We can't if this
    //  is a system file or the user hasn't opened the entire file.  We
    //  don't need to check for the root explicitly since it is one of
    //  the system files.
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

        Status = STATUS_INVALID_PARAMETER;
        DebugTrace( -1, Dbg, ("NtfsSetLinkInfo:  Exit  ->  %08lx\n", Status) );
        return Status;
    }

    //
    //  Verify that we can wait.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        Status = NtfsPostRequest( IrpContext, Irp );
        DebugTrace( -1, Dbg, ("NtfsSetLinkInfo:  Can't wait\n") );
        return Status;
    }

    //
    //  Check if we will want to report this via the dir notify package.
    //

    if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID ) &&
        (Ccb->FullFileName.Buffer[0] == L'\\') &&
        (Vcb->NotifyCount != 0)) {

        ReportDirNotify = TRUE;
    }

    //
    //  Remember the source info flags in the Ccb.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Post the change to the Usn Journal (on errors change is backed out)
        //

        NtfsPostUsnChange( IrpContext, Scb, USN_REASON_HARD_LINK_CHANGE );

        //
        //  We now assemble the names and in memory-structures for both the
        //  source and target links and check if the target link currently
        //  exists.
        //

        NtfsFindTargetElements( IrpContext,
                                TargetFileObject,
                                ParentScb,
                                &TargetParentScb,
                                &NewFullLinkName,
                                &NewLinkName );

        //
        //  Check that the new name is not invalid.
        //

        if ((NewLinkName.Length > (NTFS_MAX_FILE_NAME_LENGTH * sizeof( WCHAR ))) ||
            !NtfsIsFileNameValid( &NewLinkName, FALSE )) {

            Status = STATUS_OBJECT_NAME_INVALID;
            leave;
        }

        if (TargetParentScb == ParentScb) {

            //
            //  Acquire the target parent in order to synchronize adding a link.
            //

            NtfsAcquireExclusiveScb( IrpContext, ParentScb );

            //
            //  Check if we are creating a link to the same directory with the
            //  exact same name.
            //

            if (NtfsAreNamesEqual( Vcb->UpcaseTable,
                                   &NewLinkName,
                                   &Lcb->ExactCaseLink.LinkName,
                                   FALSE )) {

                DebugTrace( 0, Dbg, ("Creating link to same name and directory\n") );
                Status = STATUS_SUCCESS;
                leave;
            }

            //
            //  Make sure the normalized name is in this Scb.
            //

            if (ParentScb->ScbType.Index.NormalizedName.Length == 0) {

                NtfsBuildNormalizedName( IrpContext,
                                         ParentScb->Fcb,
                                         ParentScb,
                                         &ParentScb->ScbType.Index.NormalizedName );
            }

        //
        //  Otherwise we remember that we are creating this link in a new directory.
        //

        } else {

            SetFlag( RenameFlags, CREATE_IN_NEW_DIR );

            //
            //  We know that we need to acquire the target directory so we can
            //  add and remove links.  We want to carefully acquire the Scb in the
            //  event we only have the Vcb shared.
            //

            if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX )) {

                if (!NtfsAcquireExclusiveFcb( IrpContext,
                                              TargetParentScb->Fcb,
                                              TargetParentScb,
                                              ACQUIRE_DONT_WAIT )) {

                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

                //
                //  Now snapshot the Scb.
                //

                if (FlagOn( TargetParentScb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

                    NtfsSnapshotScb( IrpContext, TargetParentScb );
                }

            } else {

                NtfsAcquireExclusiveScb( IrpContext, TargetParentScb );
            }
        }

        //
        //  If we are exceeding the maximum link count on this file then return
        //  an error.  There isn't a descriptive error code to use at this time.
        //

        if (Fcb->TotalLinks >= NTFS_MAX_LINK_COUNT) {

            Status = STATUS_TOO_MANY_LINKS;
            leave;
        }

        //
        //  Lookup the entry for this filename in the target directory.
        //  We look in the Ccb for the type of case match for the target
        //  name.
        //

        FoundPrevLink = NtfsLookupEntry( IrpContext,
                                         TargetParentScb,
                                         BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ),
                                         &NewLinkName,
                                         &NewLinkNameAttr,
                                         &NewLinkNameAttrLength,
                                         NULL,
                                         &IndexEntry,
                                         &IndexEntryBcb,
                                         NULL );

        //
        //  If we found a matching link, we need to check how we want to operate
        //  on the source link and the target link.  This means whether we
        //  have any work to do, whether we need to remove the target link
        //  and whether we need to remove the source link.
        //

        if (FoundPrevLink) {

            PFILE_NAME IndexFileName;

            IndexFileName = (PFILE_NAME) NtfsFoundIndexEntry( IndexEntry );

            //
            //  If the file references match, we are trying to create a
            //  link where one already exists.
            //

            if (NtfsCheckLinkForNewLink( Fcb,
                                         IndexFileName,
                                         IndexEntry->FileReference,
                                         &NewLinkName,
                                         &RenameFlags )) {

                //
                //  There is no work to do.
                //

                Status = STATUS_SUCCESS;
                leave;
            }

            //
            //  We need to check that the user wanted to remove that link.
            //

            if (!IrpSp->Parameters.SetFile.ReplaceIfExists) {

                Status = STATUS_OBJECT_NAME_COLLISION;
                leave;
            }

            //
            //  We want to preserve the case and the flags of the matching
            //  target link.  We also want to preserve the case of the
            //  name being created.  The following variables currently contain
            //  the exact case for the target to remove and the new name to
            //  apply.
            //
            //      Link to remove - In 'IndexEntry'.
            //          The links flags are also in 'IndexEntry'.  We copy
            //          these flags to 'PrevLinkNameFlags'
            //
            //      New Name - Exact case is stored in 'NewLinkName'
            //               - Exact case is also stored in 'NewLinkNameAttr'
            //
            //  We modify this so that we can use the FileName attribute
            //  structure to create the new link.  We copy the linkname being
            //  removed into 'PrevLinkName'.   The following is the
            //  state after the switch.
            //
            //      'NewLinkNameAttr' - contains the name for the link being
            //          created.
            //
            //      'PrevLinkName' - Contains the link name for the link being
            //          removed.
            //
            //      'PrevLinkNameFlags' - Contains the name flags for the link
            //          being removed.
            //

            //
            //  Remember the file name flags for the match being made.
            //

            PrevLinkNameFlags = IndexFileName->Flags;

            //
            //  If we are report this via dir notify then build the full name.
            //  Otherwise just remember the last name.
            //

            if (ReportDirNotify) {

                PrevFullLinkName.MaximumLength =
                PrevFullLinkName.Length = (ParentScb->ScbType.Index.NormalizedName.Length +
                                           sizeof( WCHAR ) +
                                           NewLinkName.Length);

                PrevFullLinkName.Buffer = NtfsAllocatePool( PagedPool,
                                                            PrevFullLinkName.MaximumLength );

                RtlCopyMemory( PrevFullLinkName.Buffer,
                               ParentScb->ScbType.Index.NormalizedName.Buffer,
                               ParentScb->ScbType.Index.NormalizedName.Length );

                NextChar = Add2Ptr( PrevFullLinkName.Buffer,
                                    ParentScb->ScbType.Index.NormalizedName.Length );

                if (ParentScb->ScbType.Index.NormalizedName.Length != sizeof( WCHAR )) {


                    *NextChar = L'\\';
                    NextChar += 1;

                } else {

                    PrevFullLinkName.Length -= sizeof( WCHAR );
                }

                PrevLinkName.Buffer = NextChar;

            } else {

                PrevFullLinkName.Buffer =
                PrevLinkName.Buffer = NtfsAllocatePool( PagedPool, NewLinkName.Length );

                PrevFullLinkName.Length = PrevLinkName.MaximumLength = NewLinkName.Length;
            }

            //
            //  Copy the name found in the Index Entry to 'PrevLinkName'
            //

            PrevLinkName.Length =
            PrevLinkName.MaximumLength = NewLinkName.Length;

            RtlCopyMemory( PrevLinkName.Buffer,
                           IndexFileName->FileName,
                           NewLinkName.Length );

            //
            //  We only need this check if the existing link is for a different file.
            //

            if (!FlagOn( RenameFlags, TRAVERSE_MATCH )) {

                //
                //  We check if there is an existing Fcb for the target link.
                //  If there is, the unclean count better be 0.
                //

                NtfsAcquireFcbTable( IrpContext, Vcb );
                AcquiredFcbTable = TRUE;

                PreviousFcb = NtfsCreateFcb( IrpContext,
                                             Vcb,
                                             IndexEntry->FileReference,
                                             FALSE,
                                             BooleanFlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_INDEX ),
                                             &ExistingPrevFcb );

                //
                //  Before we go on, make sure we aren't about to rename over a system file.
                //

                if (FlagOn( PreviousFcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

                    Status = STATUS_ACCESS_DENIED;
                    leave;
                }

                //
                //  Add a paging resource to the target - this is not supplied if its created
                //  from scratch. We need this (acquired in the proper order) for the delete
                //  to work correctly if there are any data streams. It's not going to harm a
                //  directory del and because of the teardown in the finally clause its difficult
                //  to retry again without looping
                //

                NtfsLockFcb( IrpContext, PreviousFcb );
                LockedFcb = PreviousFcb;
                if (PreviousFcb->PagingIoResource == NULL) {
                    PreviousFcb->PagingIoResource = NtfsAllocateEresource();
                }
                NtfsUnlockFcb( IrpContext, LockedFcb );
                LockedFcb = NULL;

                //
                //  We need to acquire this file carefully in the event that we don't hold
                //  the Vcb exclusively.
                //

                if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX )) {

                    if (!ExAcquireResourceExclusiveLite( PreviousFcb->PagingIoResource, FALSE )) {

                        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                    }

                    FcbWithPagingResourceToRelease = PreviousFcb;

                    if (!NtfsAcquireExclusiveFcb( IrpContext, PreviousFcb, NULL, ACQUIRE_DONT_WAIT )) {

                        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                    }

                    NtfsReleaseFcbTable( IrpContext, Vcb );
                    AcquiredFcbTable = FALSE;

                } else {

                    NtfsReleaseFcbTable( IrpContext, Vcb );
                    AcquiredFcbTable = FALSE;

                    //
                    //  Acquire the paging Io resource for this file before the main
                    //  resource in case we need to delete.
                    //
                    FcbWithPagingResourceToRelease = PreviousFcb;
                    ExAcquireResourceExclusiveLite( PreviousFcb->PagingIoResource, TRUE );

                    NtfsAcquireExclusiveFcb( IrpContext, PreviousFcb, NULL, 0 );
                }

                //
                //  If the Fcb Info field needs to be initialized, we do so now.
                //  We read this information from the disk as the duplicate information
                //  in the index entry is not guaranteed to be correct.
                //

                if (!FlagOn( PreviousFcb->FcbState, FCB_STATE_DUP_INITIALIZED )) {

                    NtfsUpdateFcbInfoFromDisk( IrpContext,
                                               TRUE,
                                               PreviousFcb,
                                               NULL );
                    //
                    //  If we need to acquire the object id index later in order
                    //  to set or lookup information for the tunnel cache, we
                    //  risk a deadlock if the quota index is still held.  Given
                    //  that superceding renames where the target Fcb isn't
                    //  already open are a fairly rare case, we can tolerate the
                    //  potential inefficiency of preacquiring the object id
                    //  index now.
                    //

                    if (Vcb->ObjectIdTableScb != NULL) {

                        NtfsAcquireExclusiveScb( IrpContext, Vcb->ObjectIdTableScb );
                        AcquiredObjectIdIndex = TRUE;
                    }

                    NtfsConditionallyFixupQuota( IrpContext, PreviousFcb );
                }

                //
                //  We are adding a link to the source file which already
                //  exists as a link to a different file in the target directory.
                //
                //  We need to check whether we permitted to delete this
                //  link.  If not then it is possible that the problem is
                //  an existing batch oplock on the file.  In that case
                //  we want to delete the batch oplock and try this again.
                //

                Status = NtfsCheckFileForDelete( IrpContext,
                                                 TargetParentScb,
                                                 PreviousFcb,
                                                 ExistingPrevFcb,
                                                 IndexEntry );

                if (!NT_SUCCESS( Status )) {

                    PSCB NextScb = NULL;

                    //
                    //  We are going to either fail this request or pass
                    //  this on to the oplock package.  Test if there is
                    //  a batch oplock on any streams on this file.
                    //

                    while ((NextScb = NtfsGetNextChildScb( PreviousFcb,
                                                           NextScb )) != NULL) {

                        if ((NextScb->AttributeTypeCode == $DATA) &&
                            (NextScb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA) &&
                            FsRtlCurrentBatchOplock( &NextScb->ScbType.Data.Oplock )) {

                            //
                            //  Go ahead and perform any necessary cleanup now.
                            //  Once we call the oplock package below we lose
                            //  control of the IrpContext.
                            //

                            if (*VcbAcquired) {
                                NtfsReleaseVcb( IrpContext, Vcb );
                                *VcbAcquired = FALSE;
                            }

                            Status = FsRtlCheckOplock( &NextScb->ScbType.Data.Oplock,
                                                       Irp,
                                                       IrpContext,
                                                       NtfsOplockComplete,
                                                       NtfsPrePostIrp );

                            break;
                        }
                    }

                    leave;
                }

                //
                //  We are adding a link to the source file which already
                //  exists as a link to a different file in the target directory.
                //

                NtfsCleanupLinkForRemoval( PreviousFcb,
                                           TargetParentScb,
                                           ExistingPrevFcb );

                //
                //  If the link count on this file is 1, then delete the file.  Otherwise just
                //  delete the link.
                //

                if (PreviousFcb->LinkCount == 1) {

                    PVOID TempFcb;

                    TempFcb = (PFCB)IrpContext->CleanupStructure;
                    IrpContext->CleanupStructure = FcbWithPagingResourceToRelease;
                    FcbWithPagingResourceToRelease = TempFcb;

                    ASSERT( (NULL == TempFcb) || (NTFS_NTC_FCB == SafeNodeType( TempFcb )) );

                    NtfsDeleteFile( IrpContext,
                                    PreviousFcb,
                                    TargetParentScb,
                                    &AcquiredParentScb,
                                    NULL,
                                    NULL );

                    FcbWithPagingResourceToRelease = IrpContext->CleanupStructure;
                    IrpContext->CleanupStructure = TempFcb;

                    //
                    //  Make sure to force the close record out to disk.
                    //

                    PrevFcbLinkCountAdj += 1;

                } else {

                    NtfsPostUsnChange( IrpContext, PreviousFcb, USN_REASON_HARD_LINK_CHANGE | USN_REASON_CLOSE );
                    NtfsRemoveLink( IrpContext,
                                    PreviousFcb,
                                    TargetParentScb,
                                    PrevLinkName,
                                    NULL,
                                    NULL );

                    ClearFlag( PreviousFcb->FcbState, FCB_STATE_VALID_USN_NAME );

                    PrevFcbLinkCountAdj += 1;
                    NtfsUpdateFcb( PreviousFcb, FCB_INFO_CHANGED_LAST_CHANGE );
                }

            //
            //  Otherwise we need to remove this link as our caller wants to replace it
            //  with a different case.
            //

            } else {

                NtfsRemoveLink( IrpContext,
                                Fcb,
                                TargetParentScb,
                                PrevLinkName,
                                NULL,
                                NULL );

                //
                //  Make sure we find the name again when posting another change.
                //

                ClearFlag( Fcb->FcbState, FCB_STATE_VALID_USN_NAME );

                PreviousFcb = Fcb;
                LinkCountAdj += 1;
            }
        }

        //
        //  Make sure we have the full name of the target if we will be reporting
        //  this.
        //

        if (ReportDirNotify && (NewFullLinkName.Buffer == NULL)) {

            NewFullLinkName.MaximumLength =
            NewFullLinkName.Length = (ParentScb->ScbType.Index.NormalizedName.Length +
                                      sizeof( WCHAR ) +
                                      NewLinkName.Length);

            NewFullLinkNameBuffer =
            NewFullLinkName.Buffer = NtfsAllocatePool( PagedPool,
                                                       NewFullLinkName.MaximumLength );

            RtlCopyMemory( NewFullLinkName.Buffer,
                           ParentScb->ScbType.Index.NormalizedName.Buffer,
                           ParentScb->ScbType.Index.NormalizedName.Length );

            NextChar = Add2Ptr( NewFullLinkName.Buffer,
                                ParentScb->ScbType.Index.NormalizedName.Length );

            if (ParentScb->ScbType.Index.NormalizedName.Length != sizeof( WCHAR )) {

                *NextChar = L'\\';
                NextChar += 1;

            } else {

                NewFullLinkName.Length -= sizeof( WCHAR );
            }

            RtlCopyMemory( NextChar,
                           NewLinkName.Buffer,
                           NewLinkName.Length );
        }

        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        //
        //  Check that we have permission to add a file to this directory.
        //

        NtfsCheckIndexForAddOrDelete( IrpContext,
                                      TargetParentScb->Fcb,
                                      FILE_ADD_FILE,
                                      Ccb->AccessFlags >> 2 );

        //
        //  We always set the last change time on the file we renamed unless
        //  the caller explicitly set this.
        //

        SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE | CCB_FLAG_SET_ARCHIVE );

        //
        //  We now want to add the new link into the target directory.
        //  We never create a primary link through the link operation although
        //  we can remove one.
        //

        NtfsAddLink( IrpContext,
                     FALSE,
                     TargetParentScb,
                     Fcb,
                     NewLinkNameAttr,
                     NULL,
                     &NewLinkNameFlags,
                     NULL,
                     NULL,
                     NULL );

        LinkCountAdj -= 1;
        NtfsUpdateFcb( TargetParentScb->Fcb,
                       (FCB_INFO_CHANGED_LAST_CHANGE |
                        FCB_INFO_CHANGED_LAST_MOD |
                        FCB_INFO_UPDATE_LAST_ACCESS) );

        //
        //  Now we want to update the Fcb for the link we renamed.  If we moved it
        //  to a new directory we need to move all the Lcb's associated with
        //  the previous link.
        //

        if (FlagOn( RenameFlags, TRAVERSE_MATCH )) {

            NtfsReplaceLinkInDir( IrpContext,
                                  TargetParentScb,
                                  Fcb,
                                  &NewLinkName,
                                  NewLinkNameFlags,
                                  &PrevLinkName,
                                  PrevLinkNameFlags );
        }

        //
        //  We have now modified the on-disk structures.  We now need to
        //  modify the in-memory structures.  This includes the Fcb and Lcb's
        //  for any links we superseded, and the source Fcb and it's Lcb's.
        //
        //  We start by looking at the link we superseded.  We know the
        //  the target directory, link name and flags, and the file the
        //  link was connected to.
        //

        if (FoundPrevLink && !FlagOn( RenameFlags, TRAVERSE_MATCH )) {

            NtfsUpdateFcbFromLinkRemoval( IrpContext,
                                          TargetParentScb,
                                          PreviousFcb,
                                          PrevLinkName,
                                          PrevLinkNameFlags );
        }

        //
        //  We have three cases to report for changes in the target directory..
        //
        //      1.  If we overwrote an existing link to a different file, we
        //          report this as a modified file.
        //
        //      2.  If we moved a link to a new directory, then we added a file.
        //
        //      3.  If we renamed a link in in the same directory, then we report
        //          that there is a new name.
        //
        //  We currently combine cases 2 and 3.
        //

        if (ReportDirNotify) {

            ULONG FilterMatch = 0;
            ULONG FileAction;

            //
            //  If we removed an entry and it wasn't an exact case match, then
            //  report the entry which was removed.
            //

            if (!FlagOn( RenameFlags, EXACT_CASE_MATCH )) {

                if (FoundPrevLink) {

                    NtfsReportDirNotify( IrpContext,
                                         Vcb,
                                         &PrevFullLinkName,
                                         PrevFullLinkName.Length - PrevLinkName.Length,
                                         NULL,
                                         &TargetParentScb->ScbType.Index.NormalizedName,
                                         (IsDirectory( &PreviousFcb->Info ) ?
                                          FILE_NOTIFY_CHANGE_DIR_NAME :
                                          FILE_NOTIFY_CHANGE_FILE_NAME),
                                         FILE_ACTION_REMOVED,
                                         TargetParentScb->Fcb );
                }

                //
                //  We will be adding an entry.
                //

                FilterMatch = FILE_NOTIFY_CHANGE_FILE_NAME;
                FileAction = FILE_ACTION_ADDED;

            //
            //  If this was not a traverse match then report that all the file
            //  properties changed.
            //

            } else if (!FlagOn( RenameFlags, TRAVERSE_MATCH )) {

                FilterMatch |= (FILE_NOTIFY_CHANGE_ATTRIBUTES |
                                FILE_NOTIFY_CHANGE_SIZE |
                                FILE_NOTIFY_CHANGE_LAST_WRITE |
                                FILE_NOTIFY_CHANGE_LAST_ACCESS |
                                FILE_NOTIFY_CHANGE_CREATION |
                                FILE_NOTIFY_CHANGE_SECURITY |
                                FILE_NOTIFY_CHANGE_EA);

                FileAction = FILE_ACTION_MODIFIED;
            }

            if (FilterMatch != 0) {

                NtfsReportDirNotify( IrpContext,
                                     Vcb,
                                     &NewFullLinkName,
                                     NewFullLinkName.Length - NewLinkName.Length,
                                     NULL,
                                     &TargetParentScb->ScbType.Index.NormalizedName,
                                     FilterMatch,
                                     FileAction,
                                     TargetParentScb->Fcb );
            }
        }

        //
        //  Checkpoint the transaction before we make the changes below.  If there are Usn
        //  records then writing them could raise.
        //

        if (IrpContext->Usn.CurrentUsnFcb != NULL) {
            NtfsCheckpointCurrentTransaction( IrpContext );
        }

        //
        //  Adjust the link counts on the files.
        //

        Fcb->TotalLinks = (SHORT) Fcb->TotalLinks - LinkCountAdj;
        Fcb->LinkCount = (SHORT) Fcb->LinkCount - LinkCountAdj;

        //
        //  We can now adjust the total link count on the previous Fcb.
        //

        if (PreviousFcb != NULL) {

            PreviousFcb->TotalLinks -= PrevFcbLinkCountAdj;
            PreviousFcb->LinkCount -= PrevFcbLinkCountAdj;

            //
            //  Now go through and mark everything as deleted.
            //

            if (PreviousFcb->LinkCount == 0) {

                SetFlag( PreviousFcb->FcbState, FCB_STATE_FILE_DELETED );

                //
                //  Release the quota control block.  This does not have to be done
                //  here however, it allows us to free up the quota control block
                //  before the fcb is removed from the table.  This keeps the assert
                //  about quota table empty from triggering in
                //  NtfsClearAndVerifyQuotaIndex.
                //

                if (NtfsPerformQuotaOperation(PreviousFcb)) {
                    NtfsDereferenceQuotaControlBlock( Vcb,
                                                      &PreviousFcb->QuotaControl );
                }

                //
                //  We need to mark all of the Scbs as gone.
                //

                for (Links = PreviousFcb->ScbQueue.Flink;
                     Links != &PreviousFcb->ScbQueue;
                     Links = Links->Flink) {

                    ThisScb = CONTAINING_RECORD( Links, SCB, FcbLinks );

                    if (!FlagOn( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

                        NtfsSnapshotScb( IrpContext, ThisScb );

                        ThisScb->ValidDataToDisk =
                        ThisScb->Header.AllocationSize.QuadPart =
                        ThisScb->Header.FileSize.QuadPart =
                        ThisScb->Header.ValidDataLength.QuadPart = 0;

                        SetFlag( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
                    }
                }
            }
        }

        //
        //  Do an audit record for the link creation if necc.
        //  Check if we need to load the security descriptor for the file
        //

        if (Fcb->SharedSecurity == NULL) {
            NtfsLoadSecurityDescriptor( IrpContext, Fcb );
        }

        SecurityDescriptor = (PISECURITY_DESCRIPTOR) Fcb->SharedSecurity->SecurityDescriptor;

        if (SeAuditingHardLinkEvents( TRUE, SecurityDescriptor )) {

            UNICODE_STRING GeneratedName;
            PUNICODE_STRING OldFullLinkName;
            UNICODE_STRING DeviceAndOldLinkName;
            UNICODE_STRING DeviceAndNewLinkName;
            USHORT Length;

            GeneratedName.Buffer = NULL;
            DeviceAndOldLinkName.Buffer = NULL;
            DeviceAndNewLinkName.Buffer = NULL;

            try {

                //
                //  Generate current filename
                //

                if (Ccb->FullFileName.Length != 0 ) {
                    OldFullLinkName = &Ccb->FullFileName;

                } else {

                    NtfsBuildNormalizedName( IrpContext, Scb->Fcb, FALSE, &GeneratedName );
                    OldFullLinkName = &GeneratedName;
                }

                //
                //  Create the full device and file name strings
                //

                Length = Vcb->DeviceName.Length + OldFullLinkName->Length;
                DeviceAndOldLinkName.Buffer = NtfsAllocatePool( PagedPool, Length );
                DeviceAndOldLinkName.Length = DeviceAndOldLinkName.MaximumLength = Length;
                RtlCopyMemory( DeviceAndOldLinkName.Buffer, Vcb->DeviceName.Buffer, Vcb->DeviceName.Length );
                RtlCopyMemory( Add2Ptr( DeviceAndOldLinkName.Buffer, Vcb->DeviceName.Length ), OldFullLinkName->Buffer, OldFullLinkName->Length );

                Length = Vcb->DeviceName.Length + TargetParentScb->ScbType.Index.NormalizedName.Length + sizeof( WCHAR ) + NewLinkName.Length;
                DeviceAndNewLinkName.Buffer = NtfsAllocatePool( PagedPool, Length );
                DeviceAndNewLinkName.Length = DeviceAndNewLinkName.MaximumLength = Length;
                RtlCopyMemory( DeviceAndNewLinkName.Buffer, Vcb->DeviceName.Buffer, Vcb->DeviceName.Length );
                RtlCopyMemory( Add2Ptr( DeviceAndNewLinkName.Buffer, Vcb->DeviceName.Length ),
                               TargetParentScb->ScbType.Index.NormalizedName.Buffer,
                               TargetParentScb->ScbType.Index.NormalizedName.Length );

                NextChar = Add2Ptr( DeviceAndNewLinkName.Buffer,
                                    Vcb->DeviceName.Length + TargetParentScb->ScbType.Index.NormalizedName.Length );

                if (TargetParentScb->ScbType.Index.NormalizedName.Length != sizeof( WCHAR )) {
                    *NextChar = L'\\';
                    NextChar += 1;
                } else {
                    DeviceAndNewLinkName.Length -= sizeof( WCHAR );
                }

                RtlCopyMemory( NextChar, NewLinkName.Buffer, NewLinkName.Length );

                SeAuditHardLinkCreation( &DeviceAndOldLinkName,
                                         &DeviceAndNewLinkName,
                                         TRUE );
            } finally {

                if (GeneratedName.Buffer != NULL) {
                    NtfsFreePool( GeneratedName.Buffer );
                }
                if (DeviceAndNewLinkName.Buffer != NULL) {
                    NtfsFreePool( DeviceAndNewLinkName.Buffer );
                }
                if (DeviceAndOldLinkName.Buffer != NULL) {
                    NtfsFreePool( DeviceAndOldLinkName.Buffer );
                }
            }
        }

    } finally {

        DebugUnwind( NtfsSetLinkInfo );

        if (LockedFcb != NULL) {
            NtfsUnlockFcb( IrpContext, LockedFcb );
        }

        //
        //  release objectid and reparse explicitly so we can call Teardown structures and wait to go up chain
        //

        if (AcquiredObjectIdIndex) { NtfsReleaseScb( IrpContext, Vcb->ObjectIdTableScb ); }
        if (AcquiredFcbTable) { NtfsReleaseFcbTable( IrpContext, Vcb ); }

        //
        //  If we allocated any buffers for name storage then deallocate them now.
        //

        if (PrevFullLinkName.Buffer != NULL) { NtfsFreePool( PrevFullLinkName.Buffer ); }
        if (NewFullLinkNameBuffer != NULL) { NtfsFreePool( NewFullLinkNameBuffer ); }

        //
        //  Release any paging io resource acquired.
        //

        if (FcbWithPagingResourceToRelease != NULL) { ExReleaseResourceLite( FcbWithPagingResourceToRelease->PagingIoResource ); }

        //
        //  If we allocated a file name attribute, we deallocate it now.
        //

        if (NewLinkNameAttr != NULL) { NtfsFreePool( NewLinkNameAttr ); }

        //
        //  If we have the Fcb for a removed link and it didn't previously
        //  exist, call our teardown routine.
        //

        if (Status != STATUS_PENDING) {

            if ((PreviousFcb != NULL) &&
                (PreviousFcb->CleanupCount == 0)) {

                NtfsTeardownStructures( IrpContext,
                                        PreviousFcb,
                                        NULL,
                                        FALSE,
                                        0,
                                        NULL );
            }
        }

        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        DebugTrace( -1, Dbg, ("NtfsSetLinkInfo:  Exit  ->  %08lx\n", Status) );
    }

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetShortNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the set shortname function.  We first check that the short name
    passed to us is valid for the context established by the system, i.e. check length and
    whether extended characters are allowed.  We will use the same test Ntfs uses in the
    create path to determine whether to generate a short name.  If the name is valid then
    check whether it is legal to put this short name on the link used to open the file.
    It is legal if the existing link is either a long, long/short or a short name.  It is
    also legal if this is any link AND there isn't a specialized link (long, long/short, short)
    on this file.  The final check is that this new link can't be a case insensitive match with
    any other link in the directory except for the existing short name on the file.

Arguments:

    FileObject - Supplies the file object being processed

    Irp - Supplies the Irp being processed

    Vcb - Vcb for the volume

    Scb - Supplies the Scb for the file/directory being modified

    Ccb - Supplies the Ccb for this file object

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    PLCB Lcb = Ccb->Lcb;
    PFCB Fcb = Scb->Fcb;
    PSCB ParentScb;
    PLCB ShortNameLcb = NULL;
    PLCB LongNameLcb = NULL;

    UNICODE_STRING FullShortName;
    UNICODE_STRING ShortName;
    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING OldShortName;
    UNICODE_STRING FullOldShortName;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN CleanupAttrContext = FALSE;
    BOOLEAN ExistingShortName = FALSE;

    PFILE_NAME FoundFileName;

    BOOLEAN FoundLink;
    PFILE_NAME ShortNameAttr = NULL;
    USHORT ShortNameAttrLength = 0;

    LOGICAL ReportDirNotify = FALSE;

    PINDEX_ENTRY IndexEntry;
    PBCB IndexEntryBcb = NULL;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_IRP( Irp );
    ASSERT_SCB( Scb );

    PAGED_CODE ();

    DebugTrace( +1, Dbg, ("NtfsSetShortNameInfo...\n") );

    OldShortName.Buffer = NULL;
    FullOldShortName.Buffer = NULL;
    FullShortName.Buffer = NULL;

    //
    //  Do a quick check that the caller is allowed to do the rename.
    //  The opener must have opened the main data stream by name and this can't be
    //  a system file.
    //

    if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE ) ||
        (Lcb == NULL) ||
        FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

        DebugTrace( -1, Dbg, ("NtfsSetShortNameInfo:  Exit -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  The caller also must have restore privilege + plus some kind of write access to set the short name
    //

    if (!FlagOn( Ccb->AccessFlags, RESTORE_ACCESS ) ||
        !FlagOn( Ccb->AccessFlags, WRITE_DATA_ACCESS | WRITE_ATTRIBUTES_ACCESS )) {

        return STATUS_PRIVILEGE_NOT_HELD;
    }

    //
    //  This operation only applies to case-insensitive handles.
    //

    if (FlagOn( FileObject->Flags, FO_OPENED_CASE_SENSITIVE )) {

        DebugTrace( -1, Dbg, ("NtfsSetShortNameInfo:  Case sensitive handle\n") );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Validate the new short name.  It must be a valid Ntfs name and satisfy
    //  the current requirement for a short name.  The short name must be a full number of
    //  unicode characters and a valid short name for the current system.
    //

    ShortName.MaximumLength =
    ShortName.Length = (USHORT) ((PFILE_NAME_INFORMATION) IrpContext->OriginatingIrp->AssociatedIrp.SystemBuffer)->FileNameLength;
    ShortName.Buffer = (PWSTR) &((PFILE_NAME_INFORMATION) IrpContext->OriginatingIrp->AssociatedIrp.SystemBuffer)->FileName;

    if ((ShortName.Length == 0) ||
        FlagOn( ShortName.Length, 1 ) ||
        !NtfsIsFatNameValid( &ShortName, FALSE )) {

        DebugTrace( -1, Dbg, ("NtfsSetShortNameInfo:  Invalid name\n") );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Make sure the name is upcased.
    //

    NtfsUpcaseName( Vcb->UpcaseTable, Vcb->UpcaseTableSize, &ShortName );

    //
    //  If this link has been deleted, then we don't allow this operation.
    //

    if (LcbLinkIsDeleted( Lcb )) {

        DebugTrace( -1, Dbg, ("NtfsSetShortNameInfo:  Exit -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Verify that we can wait.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        Status = NtfsPostRequest( IrpContext, Irp );

        DebugTrace( -1, Dbg, ("NtfsSetShortNameInfo:  Can't wait\n") );
        return Status;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If this is a directory file, we need to examine its descendents.
        //  We may not remove a link which may be an ancestor path
        //  component of any open file.
        //

        if (IsDirectory( &Fcb->Info )) {

            Status = NtfsCheckTreeForBatchOplocks( IrpContext, Irp, Scb );

            //
            //  Get out if there are any blocking batch oplocks.
            //

            if (Status != STATUS_SUCCESS) {

                leave;
            }
        }

        //
        //  Find the Parent Scb.
        //

        ParentScb = Lcb->Scb;

        //
        //  Acquire the parent and make sure it has a normalized name.  Also make sure the current
        //  Fcb has a normalized name if it is a directory.
        //

        NtfsAcquireExclusiveScb( IrpContext, ParentScb );

        if (ParentScb->ScbType.Index.NormalizedName.Length == 0) {

            NtfsBuildNormalizedName( IrpContext,
                                     ParentScb->Fcb,
                                     ParentScb,
                                     &ParentScb->ScbType.Index.NormalizedName );
        }

        if (IsDirectory( &Fcb->Info ) &&
            (Scb->ScbType.Index.NormalizedName.Length == 0)) {

            NtfsUpdateNormalizedName( IrpContext,
                                      ParentScb,
                                      Scb,
                                      NULL,
                                      FALSE );
        }

        if (Vcb->NotifyCount != 0) {

            ReportDirNotify = TRUE;
        }

        //
        //  Check if the current Lcb is either part of or all of Ntfs/Dos name pair, if so then
        //  our life is much easier.  Otherwise look through the filename attributes to verify
        //  there isn't already an Ntfs/Dos name.
        //

        if (!FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_NTFS | FILE_NAME_DOS )) {

            //
            //  Initialize the attribute enumeration context.
            //

            NtfsInitializeAttributeContext( &AttrContext );
            CleanupAttrContext = TRUE;

            if (!NtfsLookupAttributeByCode( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            $FILE_NAME,
                                            &AttrContext )) {

                DebugTrace( 0, Dbg, ("Can't find filename attribute Fcb @ %08lx\n", Fcb) );

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Now keep looking until we find a match.
            //

            while (TRUE) {

                FoundFileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                //
                //  If we find any with the Ntfs/Dos flags set then get out.
                //

                if (FlagOn( FoundFileName->Flags, FILE_NAME_NTFS | FILE_NAME_DOS )) {

                    NtfsRaiseStatus( IrpContext, STATUS_OBJECT_NAME_COLLISION, NULL, NULL );
                }

                //
                //  Get the next filename attribute.
                //

                if (!NtfsLookupNextAttributeByCode( IrpContext,
                                                    Fcb,
                                                    $FILE_NAME,
                                                    &AttrContext )) {

                    break;
                }
            }

            //
            //  We know the link in our hand will become the long name Lcb.
            //

            LongNameLcb = Lcb;

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            CleanupAttrContext = FALSE;

        //
        //  Find the appropriate long and short name Lcbs if they are present.  We
        //  need to update them if present.
        //

        } else {

            //
            //  The Lcb has at least one flag set.  If both aren't set then there
            //  is a separate short name.
            //

            if (Lcb->FileNameAttr->Flags != (FILE_NAME_NTFS | FILE_NAME_DOS)) {

                ExistingShortName = TRUE;
            }

            //
            //  If a long name flag is set then we have the long name Lcb.
            //

            if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_NTFS )) {

                LongNameLcb = Lcb;
            }

            //
            //  Find out if there are any Lcb's for these links in memory.
            //  If not there then we don't need to update them.
            //

            ShortNameLcb = NtfsLookupLcbByFlags( Fcb, FILE_NAME_DOS );

            if (LongNameLcb == NULL) {

                LongNameLcb = NtfsLookupLcbByFlags( Fcb, FILE_NAME_NTFS );
            }
        }

        //
        //  Verify that we don't have a case insensitive match in the directory UNLESS it is for
        //  the short name on the link we are adding this entry to.  Our checks above already
        //  verified that any short name we find will match some component of the link we
        //  were called with.
        //

        FoundLink = NtfsLookupEntry( IrpContext,
                                     ParentScb,
                                     TRUE,
                                     &ShortName,
                                     &ShortNameAttr,
                                     &ShortNameAttrLength,
                                     NULL,
                                     &IndexEntry,
                                     &IndexEntryBcb,
                                     NULL );

        //
        //  If we found a link then there is nothing to do. Either its the same file in
        //  which case we noop or we have a name collision
        //

        if (FoundLink) {

            if (NtfsEqualMftRef( &IndexEntry->FileReference, &Scb->Fcb->FileReference )) {
                leave;
            } else {
                NtfsRaiseStatus( IrpContext, STATUS_OBJECT_NAME_COLLISION, NULL, NULL );
            }
        }

        //
        //  Make sure the short name DOS bit is set.
        //

        ShortNameAttr->Flags = FILE_NAME_DOS;

        //
        //  Grow the short name Lcb buffers if present.
        //

        if (ShortNameLcb != NULL) {

            NtfsRenameLcb( IrpContext,
                           ShortNameLcb,
                           &ShortName,
                           FILE_NAME_DOS,
                           TRUE );
        }

        //
        //  We now have the appropriate Lcb's for the name switch and know that their buffers
        //  are the appropriate size.  Proceed now to make the changes on disk and update the
        //  appropriate in-memory structures.  Start with any on-disk changes which may need to
        //  be rolled back.
        //

        //
        //  Convert the corresponding long name to an Ntfs-only long name if necessary.
        //

        if (LongNameLcb != NULL) {

            //
            //  It's possible that we don't need to update the flags.
            //

            if (LongNameLcb->FileNameAttr->Flags != FILE_NAME_NTFS) {

                NtfsUpdateFileNameFlags( IrpContext,
                                         Fcb,
                                         ParentScb,
                                         FILE_NAME_NTFS,
                                         LongNameLcb->FileNameAttr );
            }

        } else {

            //
            //  If the LongNameLcb is NULL then our caller must have opened
            //  through the short name Lcb.  Since there must be a corresponding
            //  NTFS only name we don't need to update the flags.
            //

            ASSERT( Lcb->FileNameAttr->Flags == FILE_NAME_DOS );
            ExistingShortName = TRUE;
        }

        //
        //  Remove the existing short name if necessary.
        //

        if (ExistingShortName) {

            NtfsRemoveLinkViaFlags( IrpContext,
                                    Fcb,
                                    ParentScb,
                                    FILE_NAME_DOS,
                                    NULL,
                                    &OldShortName );

            //
            //  Now allocate a full name for the dir notify.
            //

            if (ReportDirNotify) {

                //
                //  Figure out the length of the name.
                //

                FullOldShortName.Length = OldShortName.Length + ParentScb->ScbType.Index.NormalizedName.Length;

                if (ParentScb != Vcb->RootIndexScb) {

                    FullOldShortName.Length += sizeof( WCHAR );
                }

                FullOldShortName.MaximumLength = FullOldShortName.Length;
                FullOldShortName.Buffer = NtfsAllocatePool( PagedPool, FullOldShortName.Length );

                //
                //  Copy in the full name.  Note we always copy in the '\' separator but will automatically
                //  overwrite in the case where it wasn't needed.
                //

                RtlCopyMemory( FullOldShortName.Buffer,
                               ParentScb->ScbType.Index.NormalizedName.Buffer,
                               ParentScb->ScbType.Index.NormalizedName.Length );

                *(FullOldShortName.Buffer + (ParentScb->ScbType.Index.NormalizedName.Length / sizeof( WCHAR ))) = L'\\';

                RtlCopyMemory( Add2Ptr( FullOldShortName.Buffer, FullOldShortName.Length - OldShortName.Length ),
                               OldShortName.Buffer,
                               OldShortName.Length );
            }
        }

        //
        //  Copy the correct dup info into the attribute.
        //

        RtlCopyMemory( &ShortNameAttr->Info,
                       &Fcb->Info,
                       sizeof( DUPLICATED_INFORMATION ));

        //
        //  Put it in the file record.
        //

        NtfsInitializeAttributeContext( &AttrContext );
        CleanupAttrContext = TRUE;

        NtfsCreateAttributeWithValue( IrpContext,
                                      Fcb,
                                      $FILE_NAME,
                                      NULL,
                                      ShortNameAttr,
                                      NtfsFileNameSize( ShortNameAttr ),
                                      0,
                                      &ParentScb->Fcb->FileReference,
                                      TRUE,
                                      &AttrContext );

        //
        //  Now put it in the index entry.
        //

        NtfsAddIndexEntry( IrpContext,
                           ParentScb,
                           ShortNameAttr,
                           NtfsF