utes=0x%x\n", fRestoreOperation, oldAttributes ));

    // Enable if not already
    // Because of the way RPC transport authentication security tracking works, the
    // held privilege may or may not already be enabled

    if ( (oldAttributes & (SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED)) == 0 ) {

        ptpTokenPrivileges->PrivilegeCount = 1;
        memcpy( &(ptpTokenPrivileges->Privileges[0].Luid), &luid, sizeof(LUID) );
        ptpTokenPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        if (!AdjustTokenPrivileges(
            hToken,
            fFalse,
            ptpTokenPrivileges,
            sizeof(TOKEN_PRIVILEGES),
            NULL,
            NULL))
        {
            DebugTrace(("AdjustTokenPriv(Enable) failed with error %d\n", GetLastError()));
            fGranted = fFalse;
            goto cleanup;
        }
    }

    psPrivileges.Privilege[0].Luid = luid;
    psPrivileges.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    //	Now check to see if the backup privilege is enabled.
    //

    if (!PrivilegeCheck(hToken, &psPrivileges, &fGranted))
    {
        //
        //	When in doubt, fail the API.
        //

        fGranted = fFalse;
    }

    // Disable if necessary
    if ( (oldAttributes & (SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED)) == 0 ) {

        ptpTokenPrivileges->PrivilegeCount = 1;
        memcpy( &(ptpTokenPrivileges->Privileges[0].Luid), &luid, sizeof(LUID) );
        ptpTokenPrivileges->Privileges[0].Attributes = oldAttributes;

        if (!AdjustTokenPrivileges(
            hToken,
            fFalse,
            ptpTokenPrivileges,
            sizeof(TOKEN_PRIVILEGES),
            NULL,
            NULL))
        {
            DebugTrace(("AdjustTokenPriv(Disable) failed with error %d\n", GetLastError()));
            // Keep going
        }
    }

cleanup:
    CloseHandle(hToken);
    return(fGranted);

}


/*
 -	FBackupServerAccessCheck
 -
 *	Purpose:
 *		Performs the necessary access checks to validate the client
 *		security for backup.
 *
 *	Parameters:
 *		None.
 *
 *	Returns:
 *		fTrue if client can legally back up the machine.
 *
 */

BOOL
FBackupServerAccessCheck(
	BOOL fRestoreOperation)
{
    PSID psidCurrentUser = NULL;
    PSID psidRemoteUser = NULL;
    BOOL fSidCurrentUserValid = fFalse;

    DebugTrace(("BackupServerAccessCheck(%s)\n", fRestoreOperation ? "Restore" : "Backup"));

    GetCurrentSid(&psidCurrentUser);

#ifdef DEBUG
	{
        WSZ wszSid = NULL;
        DWORD cbBuffer = 256*sizeof(WCHAR);

        wszSid = MIDL_user_allocate(cbBuffer);

        if (wszSid == NULL)
        {
            DebugTrace(("Unable to allocate memory for SID"));
        } else if (!GetTextualSid(psidCurrentUser, wszSid, &cbBuffer)) {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
				MIDL_user_free(wszSid);
				wszSid = MIDL_user_allocate(cbBuffer);

				if (wszSid != NULL)
				{
					if (!GetTextualSid(psidCurrentUser, wszSid, &cbBuffer)) {
                        DebugTrace(("Unable to print out current SID: %d\n", GetLastError()));
                        MIDL_user_free(wszSid);
                        wszSid = NULL;
					}
				}
            }
            else
            {
                DebugTrace(("Unable to determine SID: %d\n", GetLastError()));
            }
        }
		
        if (wszSid) {
            DebugTrace(("Current SID is %S.  %d bytes required\n", wszSid, cbBuffer));
            MIDL_user_free(wszSid);
        }
        else
        {
            DebugTrace(("Unable to determine current SID\n"));
        }
    }
#endif
    
    if (RpcImpersonateClient(NULL) != hrNone)
    {
        DebugTrace(("BackupServerAccessCheck: Failed to impersonate client - deny access."));
        if (psidCurrentUser)
        {
            LocalFree(psidCurrentUser);
        }
        return(fFalse);
    }

    if (psidCurrentUser)
    {
        GetCurrentSid(&psidRemoteUser);
#ifdef DEBUG
		{
			if (psidRemoteUser)
			{
				WSZ wszSid = NULL;
				DWORD cbBuffer = 256*sizeof(WCHAR);
		
				wszSid = MIDL_user_allocate(cbBuffer);

				if (wszSid == NULL)
				{
					DebugTrace(("Unable to allocate memory for SID"));
				} else if (!GetTextualSid(psidRemoteUser, wszSid, &cbBuffer)) {
					if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
					{
						MIDL_user_free(wszSid);

						wszSid = MIDL_user_allocate(cbBuffer);
						
						if (wszSid != NULL)
						{
							if (!GetTextualSid(psidRemoteUser, wszSid, &cbBuffer)) {
								DebugTrace(("Unable to print out remote SID: %d\n", GetLastError()));
								MIDL_user_free(wszSid);
								wszSid = NULL;
							}
						}
					}
					else
					{
						DebugTrace(("Unable to determine SID: %d\n", GetLastError()));
					}
				}
		
				if (wszSid) {
					DebugTrace(("Remote SID is %S.  %d bytes required\n", wszSid, cbBuffer));
					MIDL_user_free(wszSid);
				}
				else
				{
					DebugTrace(("Unable to determine remote SID\n"));
				}
			}
			else
			{
				DebugTrace(("Could not determine remote sid: %d\n", GetLastError()));
			}
		}
#endif

    	if (psidRemoteUser && EqualSid(psidRemoteUser, psidCurrentUser))
    	{
            RpcRevertToSelf();

            LocalFree(psidRemoteUser);
            LocalFree(psidCurrentUser);
            DebugTrace(("Remote user is running in service account, access granted\n"));
            return fTrue;
    	}
    }

    if (psidRemoteUser)
    {
        LocalFree(psidRemoteUser);
    }

    if (psidCurrentUser)
    {
       	LocalFree(psidCurrentUser);
    }

    //
    //	Now make sure that the user has the backup privilege enabled.
    //
    //	Please note that when the user does a network logon, all privileges
    //	that they might have will automatically be enabled.
    //

    if (!FIsBackupPrivilegeEnabled(fRestoreOperation))
    {
        RpcRevertToSelf();
    	DebugTrace(("Remote user does not have the backup/restore privilege enabled.\n"));
    	return(fFalse);
    }


    DebugTrace(("Remote user is in backup or admin group, access granted.\n"));
    RpcRevertToSelf();
    return(fTrue);

}


DWORD
ErrGetRegString(
    IN WCHAR *KeyName,
    OUT WCHAR **OutputString
    )
/*++

Routine Description:

    This function finds a given key in the DSA Configuration section of the
    registry.

Arguments:

    KeyName - Supplies the name of the key to query.
    OutputString - Returns a pointer to the buffer containing the string
        retrieved.
    Optional - Supplies whether or not the given key MUST be in the registry
        (i.e. if this is false and it is not found, that that is an error).

Return Value:

     0 - Success
    !0 - Failure

--*/
{

    DWORD returnValue = 0;
    DWORD err;
    HKEY keyHandle = NULL;
    DWORD size;
    DWORD keyType;

    *OutputString = NULL;
    
    err = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                        DSA_CONFIG_SECTION,
                        0,
                        KEY_QUERY_VALUE,
                        &keyHandle);
    
    if (err != ERROR_SUCCESS)
    {
        returnValue = err;
        goto CleanUp;
    } 
    
    err = RegQueryValueEx(keyHandle,
                          KeyName,
                          NULL,
                          &keyType,
                          NULL,
                          &size);
    
    if ((err != ERROR_SUCCESS) || (keyType != REG_SZ))
    {
        // invent an error if the keytype is bad
        if ( err == ERROR_SUCCESS ) {
            err = ERROR_INVALID_PARAMETER;
        }
        returnValue = err;
        goto CleanUp;
    }

    *OutputString = MIDL_user_allocate(size);
    
    if ( *OutputString == NULL ) {
        returnValue = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto CleanUp;
    }
    
    err = RegQueryValueEx(keyHandle,
                          KeyName,
                          NULL,
                          &keyType,
                          (LPBYTE)(*OutputString),
                          &size);
    
    if ((err != ERROR_SUCCESS) || (keyType != REG_SZ))
    {
        returnValue = err;
        goto CleanUp;
    }

    
CleanUp:

    if (keyHandle != NULL)
    {
        err = RegCloseKey(keyHandle);
        
        if (err != ERROR_SUCCESS && returnValue == ERROR_SUCCESS)
        {
            returnValue = err;
        }
    }

    return returnValue;

} // ErrGetRegString



DWORD
ErrGetRestoreMarkerFilePath(
    IN HKEY KeyHandle,
    OUT WCHAR **RestoreMarkerFilePath
    )
/*++

Routine Description:

    This function puts together the path of the restore marker file and returns
    it in a freshly allocated buffer.

Arguments:

    KeyHandle - Supplies a handle to the "Restore In Progress" key.
    RestoreMarkerFilePath - Returns the path of the restore marker file.

Return Value:

     0 - Success
    !0 - Failure

--*/
{
    DWORD returnValue = ERROR_SUCCESS;
    DWORD err;
    WCHAR *filePath;
    int i;
    DWORD pathSize;
    DWORD keyType;

    err = ErrGetRegString(TEXT(FILEPATH_KEY), &filePath);
    
    if (err != ERROR_SUCCESS)
    {
        returnValue = err;
        goto CleanUp;
    }

    for ( i = wcslen(filePath) - 1;
          (i >= 0) && (filePath[i] != L'\\');
          i--);

    if (i < 0)
    {
        returnValue = E_FAIL;
        goto CleanUp;
    }

    filePath[i] = L'\0';

    pathSize = (wcslen(filePath) + wcslen(RESTORE_MARKER_FILE_NAME) + 2) *
        sizeof(WCHAR);
    
    *RestoreMarkerFilePath = MIDL_user_allocate(pathSize);

    if (*RestoreMarkerFilePath == NULL)
    {
        returnValue = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto CleanUp;
    }

    wcscpy(*RestoreMarkerFilePath, filePath);
    wcscat(*RestoreMarkerFilePath, L"\\");
    wcscat(*RestoreMarkerFilePath, RESTORE_MARKER_FILE_NAME);

CleanUp:

    if (filePath) {
        MIDL_user_free(filePath);
    }

    return returnValue;
        
} // ErrGetRestoreMarkerFilePath



DWORD
ErrCreateRestoreMarkerFile(
    OUT WCHAR *RestoreMarkerFilePath
    )
/*++

Routine Description:

    This function creates the restore marker file in the given place.

Arguments:

    RestoreMarkerFilePath - Supplies the path for the restore marker file.

Return Value:

     0 - Success
    !0 - Failure
    
--*/
{

    HANDLE hFile;
    DWORD err;

    hFile = CreateFile(RestoreMarkerFilePath,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        err = GetLastError();
        LogNtdsErrorEvent(DIRLOG_FAILED_TO_CREATE_RESTORE_MARKER_FILE, err);
        return(err);
    }

    CloseHandle(hFile);

    return(ERROR_SUCCESS);

} // ErrCreateRestoreMarkerFile



DWORD
ErrDeleteRestoreMarkerFile(
    IN WSZ WszRestoreMarkerFilePath
    )
/*++

Routine Description:

    This function attempts to delete the restore marker file.  If it does
    not succeed it returns an error and prints a message in the event log.

Arguments:

    WszRestoreMarkerFilePath - Supplies the path of the file to delete.

Return Value:

     0 - Success
    !0 - Failure

--*/
{
    HANDLE hEventSource;
    DWORD err;

    if (!DeleteFile(WszRestoreMarkerFilePath))
    {
        err = GetLastError();
        LogNtdsErrorEvent(DIRLOG_FAILED_TO_DELETE_RESTORE_MARKER_FILE, err);
        return(err);
    }

    return 0;

} // ErrDeleteRestoreMarkerFile



/*
 -  ErrRecoverAfterRestoreW
 -  
 *  Purpose:
 *
 *  This routine will recover a database after a restore if necessary.
 *
 *  Parameters:
 *      szParametersRoot - the root of the parameters section for the service in the registry.
 *
 *  Returns:
 *
 *      ERR - Status of operation.  ERROR_SUCCESS if successful, reasonable value if not.
 *
 *
 *  The NTBACKUP program will place a key at the location:
 *      $(wszParametersRoot)\Restore in Progress
 *
 *  This key contains the following values:
 *      BackupLogPath - The full path for the logs after a backup
 *      CheckpointFilePath - The full path for the path that contains the checkpoint
 *     *HighLogNumber - The maximum log file number found.
 *     *LowLogNumber - The minimum log file number found.
 *      LogPath - The current path for the logs.
 *      JET_RstMap - Restore map for database - this is a REG_MULTISZ, where odd entries go into the szDatabase field,
 *          and the even entries go into the szNewDatabase field of a JET_RstMap
 *     *JET_RstMap Size - The number of entries in the restoremap.
 *
 *      * - These entries are REG_DWORD's.  All others are REG_SZ's (except where mentioned).
 */
DWORD
ErrRecoverAfterRestoreW(
    WCHAR * wszParametersRoot,
    WCHAR * wszAnnotation,
    BOOL fInSafeMode
    )
{
    DWORD err = 0;
    WCHAR   rgwcRegistryPath[ MAX_PATH ];
    WCHAR   rgwcCheckpointFilePath[ MAX_PATH ];
    DWORD   cbCheckpointFilePath = sizeof(rgwcCheckpointFilePath);
    WCHAR   rgwcBackupLogPath[ MAX_PATH ];
    DWORD   cbBackupLogPath = sizeof(rgwcBackupLogPath);
    WCHAR   rgwcLogPath[ MAX_PATH ];
    DWORD   cbLogPath = sizeof(rgwcLogPath);
    HKEY    hkey = NULL;
    WCHAR   *pwszRestoreMap = NULL;
    PEDB_RSTMAPW prgRstMap = NULL;
    DWORD    crgRstMap;
    I        irgRstMap;
    DWORD   genLow, genHigh;
    DWORD   cbGen = sizeof(DWORD);
    WSZ     wsz;
    DWORD   dwType;
    BOOL    fBackupEnabled = fFalse;
    CHAR    rgTokenPrivileges[1024];
    DWORD   cbTokenPrivileges = sizeof(rgTokenPrivileges);
    HRESULT hrRestoreError;
    WSZ     wszCheckpointFilePath = rgwcCheckpointFilePath;
    WSZ     wszBackupLogPath = rgwcBackupLogPath;
    WSZ     wszLogPath = rgwcLogPath;
    BOOLEAN fDatabaseRecovered = fFalse;
    BOOLEAN fRestoreInProgressKeyPresent;
    BOOLEAN fRestoreMarkerFilePresent;
    DWORD   cchEnvString;
    WCHAR   envString[100];
    WIN32_FIND_DATA findData;
    HANDLE  hRestoreMarkerFile = INVALID_HANDLE_VALUE;
    WSZ     wszRestoreMarkerFilePath = NULL;

    if (wcslen(wszParametersRoot)+wcslen(RESTORE_IN_PROGRESS) > sizeof(rgwcRegistryPath)/sizeof(WCHAR))
    {
        return(ERROR_INVALID_PARAMETER);
    }

    wcscpy(rgwcRegistryPath, wszParametersRoot);
    wcscat(rgwcRegistryPath, RESTORE_IN_PROGRESS);

    try {

        err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            rgwcRegistryPath,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hkey);
        if ((err != ERROR_SUCCESS) && (err != ERROR_FILE_NOT_FOUND))
        {
            __leave;
        }

        fRestoreInProgressKeyPresent = (err == ERROR_SUCCESS);
        
        if (err = ErrGetRestoreMarkerFilePath(hkey, &wszRestoreMarkerFilePath))
        {
            __leave;
        }
        
        hRestoreMarkerFile = FindFirstFile(wszRestoreMarkerFilePath,
                                           &findData);
        FindClose(hRestoreMarkerFile);

        fRestoreMarkerFilePresent =
            (hRestoreMarkerFile != INVALID_HANDLE_VALUE);

        
        // Delete the marker file if necessary.
        if (!fInSafeMode && fRestoreMarkerFilePresent)
        {
            ErrDeleteRestoreMarkerFile(wszRestoreMarkerFilePath);
        }

        // Create the marker file if necessary
        if (fInSafeMode && !fRestoreMarkerFilePresent)
        {
            ErrCreateRestoreMarkerFile(wszRestoreMarkerFilePath);
        }

        
        //
        //  if there's a restore in progress, then fail to perform any other restore operations.
        // Note that we check this before checking whether there is a restore in progress
        // key. The reason is that in the case of a snapshot-based restore, this key
        // is not used.
        //  

        dwType = REG_DWORD;
        cbBackupLogPath = sizeof(DWORD);
        if ((err = RegQueryValueExW(hkey, RESTORE_STATUS, 0, &dwType, (LPBYTE)&hrRestoreError, &cbBackupLogPath)) == ERROR_SUCCESS)
        {
            err = hrRestoreError;
            __leave;
        }

        // If there was no key present, then there is nothing left to do.
        if (!fRestoreInProgressKeyPresent)
        {
            err = 0;
            __leave;
        }

        //
        //  We have now opened the restore-in-progress key.  This means that we have
        //  something to do now.  Find out what it is.
        //

        //
        //  First, let's get the backup log file path.
        //

        dwType = REG_SZ;
        cbBackupLogPath = sizeof(rgwcBackupLogPath);

        if (err = RegQueryValueExW(hkey, BACKUP_LOG_PATH, 0, &dwType, (LPBYTE)rgwcBackupLogPath, &cbBackupLogPath))
        {
            if (err == ERROR_FILE_NOT_FOUND)
            {
                wszBackupLogPath = NULL;
            }
            else
            {
                __leave;
            }
        }

        //
        //  Then, the checkpoint file path.
        //

        if (err = RegQueryValueExW(hkey, CHECKPOINT_FILE_PATH, 0, &dwType, (LPBYTE)rgwcCheckpointFilePath, &cbCheckpointFilePath))
        {

            if (err == ERROR_FILE_NOT_FOUND)
            {
                wszCheckpointFilePath = NULL;
            }
            else
            {
                __leave;
            }
        }

        //
        //  Then, the Log path.
        //

        if (err = RegQueryValueExW(hkey, LOG_PATH, 0, &dwType, (LPBYTE)rgwcLogPath, &cbLogPath))
        {
            if (err == ERROR_FILE_NOT_FOUND)
            {
                wszLogPath = NULL;
            }
            else
            {
                __leave;
            }
        }

        //
        //  Then, the low log number.
        //

        dwType = REG_DWORD;
        if (err = RegQueryValueExW(hkey, LOW_LOG_NUMBER, 0, &dwType, (LPBYTE)&genLow, &cbGen))
        {
            __leave;
        }

        //
        //  And, the high log number.
        //

        if (err = RegQueryValueExW(hkey, HIGH_LOG_NUMBER, 0, &dwType, (LPBYTE)&genHigh, &cbGen))
        {
            __leave;
        }

        //
        //  Now determine if we had previously recovered the database.
        //

        dwType = REG_BINARY;
        cbGen = sizeof(fDatabaseRecovered);

        if ((err = RegQueryValueExW(hkey, JET_DATABASE_RECOVERED, 0, &dwType, &fDatabaseRecovered, &cbGen)) != ERROR_SUCCESS &&
            (err !=  ERROR_FILE_NOT_FOUND))
        {
            //
            //  If there was an error other than "value doesn't exist", bail.
            //

            __leave;
        }

        //
        //  Now the tricky one.  We want to get the restore map.
        //
        //
        //  First we figure out how big it is.
        //

        dwType = REG_DWORD;
        cbGen = sizeof(crgRstMap);
        if (err = RegQueryValueExW(hkey, JET_RSTMAP_SIZE, 0, &dwType, (LPBYTE)&crgRstMap, &cbGen))
        {
            __leave;
        }

        prgRstMap = (PEDB_RSTMAPW)MIDL_user_allocate(sizeof(EDB_RSTMAPW)*crgRstMap);

        if (prgRstMap == NULL)
        {
            err = GetLastError();
            __leave;
        }

        //
        //  First find out how much memory is needed to hold the restore map.
        //

        dwType = REG_MULTI_SZ;
        if (err = RegQueryValueExW(hkey, JET_RSTMAP_NAME, 0, &dwType, NULL, &cbGen))
        {
            if (err != ERROR_MORE_DATA)
            {
                __leave;
            }
        }

        pwszRestoreMap = MIDL_user_allocate(cbGen);

        if (pwszRestoreMap == NULL)
        {
            err = GetLastError();
            __leave;
        }

        if (err = RegQueryValueExW(hkey, JET_RSTMAP_NAME, 0, &dwType, (LPBYTE)pwszRestoreMap, &cbGen))
        {
            __leave;
        }
        
        wsz = pwszRestoreMap;

        for (irgRstMap = 0; irgRstMap < (I)crgRstMap; irgRstMap += 1)
        {
            prgRstMap[irgRstMap].wszDatabaseName = wsz;
            wsz += wcslen(wsz)+1;
            prgRstMap[irgRstMap].wszNewDatabaseName = wsz;
            wsz += wcslen(wsz)+1;
        }

        if (*wsz != L'\0')
        {
            err = ERROR_INVALID_PARAMETER;
            __leave;
        }

        err = AdjustBackupRestorePrivilege(fTrue /* enable */, fTrue /* restore */, (PTOKEN_PRIVILEGES)rgTokenPrivileges, &cbTokenPrivileges);

        fBackupEnabled = fTrue;
        
        // If the file is present, we already recovered the database.
        if (fRestoreMarkerFilePresent)
        {
            fDatabaseRecovered = TRUE;
        }

        // 
        // Modified to call into local function instead of going through ntdsbcli.dll
        //

        err = HrRestoreLocal(
                        wszCheckpointFilePath,
                        wszLogPath,
                        prgRstMap,
                        crgRstMap,
                        wszBackupLogPath,
                        genLow,
                        genHigh,
                        &fDatabaseRecovered
                        );

        if (err != ERROR_SUCCESS)
        {
            //
            //  The recovery failed.
            //
            //  If we succeeded in recovering the JET database, we want to
            //  indicate that in the registry so we don't try again.
            //
            //  Ignore any errors from the SetValue, because the recovery error
            //  is more important.
            //

            RegSetValueExW(hkey, JET_DATABASE_RECOVERED, 0, REG_BINARY,
                                (LPBYTE)&fDatabaseRecovered, sizeof(fDatabaseRecovered));
            __leave;
        }

        //
        //  Ok, we're all done.  We can now delete the key, since we're done
        //  with it.
        //
        //  Note that we do not do this when run in safe mode -- see bug 426148.
        //

        if (!fInSafeMode) {
            err = RegDeleteKeyW(HKEY_LOCAL_MACHINE, rgwcRegistryPath);
        }

    } finally {
        if (fBackupEnabled)
        {
            AdjustBackupRestorePrivilege(fFalse /* disable */, fTrue /* Restore */, (PTOKEN_PRIVILEGES)rgTokenPrivileges, &cbTokenPrivileges);
            
        }

        if (pwszRestoreMap != NULL)
        {
            MIDL_user_free(pwszRestoreMap);
        }

        if (prgRstMap)
        {
            MIDL_user_free(prgRstMap);
        }

        if (hkey != NULL)
        {
            RegCloseKey(hkey);
        }

        if (wszRestoreMarkerFilePath != NULL)
        {
            MIDL_user_free(wszRestoreMarkerFilePath);
        }
    }

    return(err);
}

/*
 -  ErrRecoverAfterRestoreA
 -  
 *  Purpose:
 *
 *  This routine will recover a database after a restore if necessary.  This is the ANSI stub for this operation.
 *
 *  Parameters:
 *      szParametersRoot - the root of the parameters section for the service in the registry.
 *
 *  Returns:
 *
 *      ERR - Status of operation.  ERROR_SUCCESS if successful, reasonable value if not.
 *
 */
DWORD
ErrRecoverAfterRestoreA(
    char * szParametersRoot,
    char * szRestoreAnnotation,
    BOOL fInSafeMode
    )
{
    DWORD err;
    WSZ wszParametersRoot = WszFromSz(szParametersRoot);
    WSZ wszRestoreAnnotation = NULL;

    if (wszParametersRoot == NULL)
    {
        return(GetLastError());
    }

    wszRestoreAnnotation = WszFromSz(szRestoreAnnotation);

    if (wszRestoreAnnotation == NULL)
    {
        MIDL_user_free(wszParametersRoot);
        return(GetLastError());
    }

    err = ErrRecoverAfterRestoreW(wszParametersRoot,
                                  wszRestoreAnnotation,
                                  fInSafeMode);

    MIDL_user_free(wszParametersRoot);
    MIDL_user_free(wszRestoreAnnotation);

    return(err);
}

/*
 -  EcDsarQueryStatus
 -
 *  Purpose:
 *
 *      This routine will return progress information about the restore process
 *
 *  Parameters:
 *      pcUnitDone - The number of "units" completed.
 *      pcUnitTotal - The total # of "units" completed.
 *
 *  Returns:
 *      ec
 *
 */
EC EcDsaQueryDatabaseLocations(
    SZ szDatabaseLocation,
    CB *pcbDatabaseLocationSize,
    SZ szRegistryBase,
    CB cbRegistryBase,
    BOOL *pfCircularLogging
    )
{
        return HrLocalQueryDatabaseLocations(
            szDatabaseLocation,
            pcbDatabaseLocationSize,
            szRegistryBase,
            cbRegistryBase,
            pfCircularLogging
            );
}




/*
 -  EcDsarPerformRestore
 -
 *  Purpose:
 *
 *      This routine will do all the DSA related operations necessary to
 *      perform a restore operation.
 *
 *      It will:
 *
 *          1) Fix up the registry values for the database names to match the
 *              new database location (and names).
 *
 *          2) Patch the public and private MDB's.
 *
 *  Parameters:
 *      szLogPath - New database log path.
 *      szBackupLogPath - Original database log path.
 *      crstmap - Number of entries in rgrstmap.
 *      rgrstmap - Restore map that maps old database names to new names.
 *
 *  Returns:
 *      ec
 *
 */
EC EcDsarPerformRestore(
    SZ szLogPath,
    SZ szBackupLogPath,
    C crstmap,
    JET_RSTMAP rgrstmap[]
    )
{
    EC ec;
    HKEY hkeyDs;

    ec = RegOpenKeyExA(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, 0, KEY_SET_VALUE, &hkeyDs);

    if (ec != hrNone)
    {
        return(ec);
    }

    ec = RegSetValueExA(hkeyDs, DSA_RESTORED_DB_KEY, 0, REG_DWORD, (BYTE *)&ec, sizeof(ec));

    RegCloseKey(hkeyDs);

    return(ec);
}



DWORD
ErrGetNewInvocationId(
    IN      DWORD   dwFlags,
    OUT     GUID *  NewId
    )
/*++

Routine Description:

    This function finds a given key in the DSA Configuration section of the
    registry.

Arguments:

    dwFlags - Zero or more of the following bits:
        NEW_INVOCID_CREATE_IF_NONE - If no GUID was stored, create one through
            UuidCreate
        NEW_INVOCID_DELETE - If the GUID key exists, delete it after
            reading
        NEW_INVOCID_SAVE - If a GUID was generated, save it to the regkey
        
    pusnAtBackup - high USN at time of backup.  If no backup-time USN has yet
        been registered and dwFlags & NEW_INVOCID_SAVE, this USN will be
        saved for future callers.  The consumer of this information is the
        logic in the DS that saves retired DSA signatures on the DSA object
        following a restore (and possibly one or more authoritative restores
        on top of that).  If a backup-time USN has been registered, that
        value is returned here.
    
    NewId - pointer to the buffer to receive the UUID

Return Value:

     0 - Success
    !0 - Failure

--*/
{
    DWORD err;
    HKEY  keyHandle = NULL;
    DWORD size;
    DWORD keyType;
    USN   usnSaved;

    //
    // preallocate uuid string. String is at most twice the sizeof UUID
    // (since we represent each byte with 2 chars) plus some dashes. Multiply
    // by 4 to cover everything else.
    //

    WCHAR szUuid[sizeof(UUID)*4];

    //
    // Check the registry and see if a uuid have already been 
    // allocated by prior authoritative restore.
    //

    err = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                        DSA_CONFIG_SECTION,
                        0,
                        KEY_ALL_ACCESS,
                        &keyHandle);
    
    if (err != ERROR_SUCCESS) {
        keyHandle = NULL;
        goto CleanUp;
    } 
    
    size = sizeof(szUuid);
    err = RegQueryValueEx(keyHandle,
                          RESTORE_NEW_DB_GUID,
                          NULL,
                          &keyType,
                          (PCHAR)szUuid,
                          &size);
    
    if (err != ERROR_SUCCESS) {

        //
        // Key not present. Create a new one
        //

        if (dwFlags & NEW_INVOCID_CREATE_IF_NONE) {
            err = CreateNewInvocationId(dwFlags & NEW_INVOCID_SAVE, NewId);
        }
    }
    else if (keyType != REG_SZ) {
        err = ERROR_INVALID_PARAMETER;
    }
    else {
        //
        // got it. Convert to uuid.
        //
    
        err = UuidFromStringW(szUuid,NewId);
        if (err != RPC_S_OK) {
            goto CleanUp;
        }
    
        //
        // delete?
        //
    
        if (dwFlags & NEW_INVOCID_DELETE) {
    
            DWORD dwErr = RegDeleteValue(keyHandle, RESTORE_NEW_DB_GUID);
    
            if ( dwErr != NO_ERROR ) {
                LogNtdsErrorEvent(DIRLOG_FAILED_TO_DELETE_NEW_DB_GUID_KEY, dwErr);
            }
        }
    }

CleanUp:

    if (keyHandle != NULL) {
        (VOID)RegCloseKey(keyHandle);
    }

    return err;

} // ErrGetNewInvocationId


JET_ERR
updateBackupUsn(
    IN  JET_SESID     hiddensesid,
    IN  JET_TABLEID   hiddentblid,
    IN  JET_COLUMNID  backupusnid,
    IN  USN *         pusnAtBackup  OPTIONAL
    )
/*++

Routine Description:

    Writes the given backup USN to the hidden record.

Arguments:

    hiddensesid (IN) - Jet session to use to access the hidden table.
    
    hiddentblid (IN) - Open cursor for the hidden table.
    
    pusnAtBackup (OUT) - High USN at time of backup.  If NULL, the value
        will be removed from the hidden table.

Return Value:

    0 -- success
    non-0 -- JET error.

--*/
{
    JET_ERR err;
    BOOL    fInTransaction = FALSE;

    err = JetBeginTransaction(hiddensesid);
    if (err) {
        Assert(!"JetBeginTransaction failed!");
        return err;
    }

    __try {
        fInTransaction = TRUE;
        
        err = JetMove(hiddensesid, hiddentblid, JET_MoveFirst, 0);
        if (err) {
            Assert(!"JetMove failed!");
            __leave;
        }

        err = JetPrepareUpdate(hiddensesid, hiddentblid, JET_prepReplace);
        if (err) {
            Assert(!"JetPrepareUpdate failed!");
            __leave;
        }
    
        err = JetSetColumn(hiddensesid,
                           hiddentblid,
                           backupusnid,
                           pusnAtBackup,
                           pusnAtBackup ? sizeof(*pusnAtBackup) : 0,
                           0,
                           NULL);
        if (err) {
            Assert(!"JetSetColumn failed!");
            __leave;
        }

        err = JetUpdate(hiddensesid, hiddentblid, NULL, 0, 0);
        if (err) {
            Assert(!"JetUpdate failed!");
            __leave;
        }
    
        err = JetCommitTransaction(hiddensesid, 0);
        fInTransaction = FALSE;
        
        if (err) {
            Assert(!"JetCommitTransaction failed!");
            __leave;
        }
    }
    __finally {
        if (fInTransaction) {
            JetRollback(hiddensesid, 0);
        }
    }

    return err;
}


DWORD
ErrGetBackupUsnFromDatabase(
    IN  JET_DBID      dbid,
    IN  JET_SESID     hiddensesid,
    IN  JET_TABLEID   hiddentblid,
    IN  JET_SESID     datasesid,
    IN  JET_TABLEID   datatblid_arg,
    IN  JET_COLUMNID  usncolid,
    IN  JET_TABLEID   linktblid_arg,
    IN  JET_COLUMNID  linkusncolid,
    IN  BOOL          fDelete,
    OUT USN *         pusnAtBackup
    )
/*++

Routine Description:

    Returns a USN which for which we guarantee that we have seen all changes
    at or below its value relative to our invocation ID.  I.e., we guarantee
    that we were not backed up and changes committed at USNs lower than this
    before we were restored.

Arguments:

    dbid (IN) - Jet database ID.
    
    hiddensesid (IN) - Jet session to use to access the hidden table.
    
    hiddentblid (IN) - Open cursor for the hidden table.
    
    datasesid (IN) - Jet session and table to use to access the data table.
    
    datatblid_arg (IN) - Open cursor for the data table.  datatblid_arg will be
        dup'ed, so its current position, etc., remain unchanged.
    
    usncolid (IN) - Jet ID for the usnChanged column.
    
    linktblid_arg (IN) - Open cursor for the link table.  linktblid_arg will be
        dup'ed, so its current position, etc., remain unchanged.
    
    linkusncolid (IN) - Jet ID for the link usnChanged column.
    
    pusnAtBackup (OUT) - High USN at time of backup -- approximately.  We assert
        that any change made at this USN or lower under our invocation ID is
        present on this machine.

Return Value:

    0 -- success
    non-0 -- JET error.

--*/
{
#define SZUSNCHANGEDINDEX "INDEX_00020078"
#define SZLINKDRAUSNINDEX   "link_DRA_USN_index"  /* index for DRA USN */
#define SZBACKUPUSN       "backupusn_col"  /* name of backup USN column */
#define SZLINKNCDNT "link_ncdnt" // Link NC DNT
#define SZHIDDENTABLE     "hiddentable"    /* name of JET hidden table */
#define DNTMAX         0x7fffffff // DNT is signed 32-bit

    const ULONG     USN_PENALTY = 1000;
    ULONG           dntMax = DNTMAX;
    USN             usnMax = USN_MAX;
    JET_ERR         err;
    DWORD           cb;
    USN             usnFound, usnLinkFound;
    JET_TABLEID     datatblid, linktblid;
    BOOL            fCursorDuped = FALSE, fLinkCursorDuped = FALSE;
    JET_COLUMNBASE  colbase;
    JET_COLUMNDEF   coldef;
    JET_COLUMNID    backupusnid;
    JET_COLUMNID    linkncdntid;

    __try {
        // Find/create the backup USN column in the hidden table.
        err = JetGetColumnInfo(hiddensesid,
                               dbid,
                               SZHIDDENTABLE,
                               SZBACKUPUSN,
                               &colbase,
                               sizeof(colbase),
                               4);
        if (err) {
            memset(&coldef, 0, sizeof(coldef));

            coldef.cbStruct = sizeof(coldef);
            coldef.coltyp   = JET_coltypCurrency;
            coldef.grbit    = JET_bitColumnFixed;

            err = JetAddColumn(hiddensesid,
                               hiddentblid,
                               SZBACKUPUSN,
                               &coldef,
                               NULL,
                               0,
                               &backupusnid);
            if (err) {
                Assert(!"JetAddColumn failed!");
                __leave;
            }
        }
        else {
            backupusnid = colbase.columnid;
        }

        err = JetMove(hiddensesid, hiddentblid, JET_MoveFirst, 0);
        if (err) {
            Assert(!"JetMove failed!");
            __leave;
        }
        
        err = JetRetrieveColumn(hiddensesid,
                                hiddentblid,
                                backupusnid,
                                &usnFound,
                                sizeof(usnFound),
                                &cb,
                                0,
                                NULL);
        if (0 == err) {
            // Backup USN is already saved, and it's value has been placed in
            // usnFound.
            Assert(cb == sizeof(usnFound));
            Assert(0 != usnFound);

            if (fDelete) {
                // Remove this information from the hidden table.
                err = updateBackupUsn(hiddensesid,
                                      hiddentblid,
                                      backupusnid,
                                      NULL);
                Assert(0 == err);

                // Failure to remove the value is not fatal.  At worst a future
                // restore will use a lower backup USN than it would have
                // otherwise -- i.e., we won't optimize post-restore bookmarks
                // quite as well.
                err = 0;
                
                __leave;
            }

            __leave;
        }
        else if (JET_wrnColumnNull != err) {
            Assert(!"JetRetrieveColumn failed!");
            __leave;
        }

        // **************************************************
        // Find the highest USN changed value in the database.

        err = JetDupCursor(datasesid, datatblid_arg, &datatblid, 0);
        if (err) {
            Assert(!"JetDupCursor failed!");
            __leave;
        }
        fCursorDuped = TRUE;

        err = JetSetCurrentIndex(datasesid, datatblid, SZUSNCHANGEDINDEX);
        if (err) {
            Assert(!"JetSetCurrentIndex failed!");
            __leave;
        }

        err = JetMakeKey(datasesid, datatblid, &usnMax, sizeof(usnMax),
                         JET_bitNewKey);
        if (err) {
            Assert(!"JetMakeKey failed!");
            __leave;
        }

        err = JetSeek(datasesid, datatblid, JET_bitSeekLE);
        if (err && (JET_wrnSeekNotEqual != err)) {
            Assert(!"JetSeek failed!");
            __leave;
        }
    
        err = JetRetrieveColumn(datasesid,
                                datatblid,
                                usncolid,
                                &usnFound,
                                sizeof(usnFound),
                                &cb,
                                JET_bitRetrieveFromIndex,
                                NULL);
        if (err) {
            Assert(!"JetRetrieveColumn failed!");
            __leave;
        }

        Assert(cb == sizeof(usnFound));
        Assert(0 != usnFound);

        // **************************************************
        // Find the highest USN changed value in the link table.

        // We have to go through a little more work to find the highest USN in
        // use in the link table because we don't have an index keyed solely
        // by USN. To avoid creating another index, we use the LINKDRAUSN
        // index. This has two segments: NCDNT and USNCHANGED. We need to
        // search through all unique NCDNT to check for highest USNCHANGED.
        // Not a big deal since the number of partitions in the enterprise
        // will be relatively small. Second, we need the NCDNT col id in
        // order to reset the search key. We obtain the column id below.

        // Find the LINK NCDNT column in the link table.
        err = JetGetTableColumnInfo(datasesid,
                                    linktblid_arg,
                                    SZLINKNCDNT,
                                    &coldef,
                                    sizeof(coldef),
                                    0);
        if (err) {
            Assert(!"JetGetTableColumn failed!");
            __leave;
        }

        linkncdntid = coldef.columnid;

        err = JetDupCursor(datasesid, linktblid_arg, &linktblid, 0);
        if (err) {
            Assert(!"JetDupCursor failed!");
            __leave;
        }
        fLinkCursorDuped = TRUE;

        err = JetSetCurrentIndex(datasesid, linktblid, SZLINKDRAUSNINDEX);
        if (err) {
            Assert(!"JetSetCurrentIndex failed!");
            __leave;
        }

        while (1) {
            err = JetMakeKey(datasesid, linktblid, &dntMax, sizeof(dntMax),
                             JET_bitNewKey);
            if (err) {
                Assert(!"JetMakeKey 0 failed!");
                __leave;
            }

            err = JetMakeKey(datasesid, linktblid, &usnMax, sizeof(usnMax), 0 );
            if (err) {
                Assert(!"JetMakeKey 1 failed!");
                __leave;
            }

            // Search until no more records
            // A database in the old mode might not have any yet...
            err = JetSeek(datasesid, linktblid, JET_bitSeekLE);
            if ( (err) && (JET_wrnSeekNotEqual != err) ) {
                break;
            }
    
            // Since we are searching the index backwards, we expect to find
            // the largest secondary key first.
            err = JetRetrieveColumn(datasesid,
                                    linktblid,
                                    linkusncolid,
                                    &usnLinkFound,
                                    sizeof(usnLinkFound),
                                    &cb,
                                    JET_bitRetrieveFromIndex,
                                    NULL);
            if (err) {
                Assert(!"JetRetrieveColumn failed!");
                __leave;
            }

            Assert(cb == sizeof(usnLinkFound));
            Assert(0 != usnLinkFound);

            if (usnLinkFound > usnFound) {
                usnFound = usnLinkFound;
            }

            err = JetRetrieveColumn(datasesid,
                                    linktblid,
                                    linkncdntid,
                                    &dntMax,
                                    sizeof(dntMax),
                                    &cb,
                                    JET_bitRetrieveFromIndex,
                                    NULL);
            if (err) {
                Assert(!"JetRetrieveColumn failed!");
                __leave;
            }
            Assert(cb == sizeof(dntMax));
            Assert(0 != dntMax);

            dntMax--;
        }

        err = JET_errSuccess;

        // **************************************************

        // usnFound is the highest USN in the database.  Due to out-of-order
        // commits (e.g., where the update corresponding to USN 50 runs for a
        // long time, and in the meantime the transactions with updates that
        // claimed USNs 51, 52, etc. are committed) there is no guarantee the
        // backup contains all updates to the database with USNs less than or
        // equal to usnFound.
        //
        // To account for this, we subtract 1000.  Why 1000, you ask?  Why not
        // 1000? :-)  This is high enough to give us assurance that it's
        // correct, but low enough that the extra overhead involved to revisit
        // this many objects as candidates for outbound replication is small.

        if ((ULONGLONG)usnFound >= USN_PENALTY) {
            usnFound -= USN_PENALTY;
        }
        else {
            Assert(!"usnFound < USN_PENALTY!");
            usnFound = 0;
        }

        if (fDelete) {
            // We don't want to save this information.
            __leave;
        }

        // Now save the backup USN to the hidden table.
        err = updateBackupUsn(hiddensesid,
                              hiddentblid,
                              backupusnid,
                              &usnFound);
        if (err) {
            Assert(!"updateBackupUsn failed!");
            __leave;
        }
    }
    __finally {
        if (err) {
            Assert(!"Failed to retrieve/find/save backup USN!");
            usnFound = 0;
        }

        if (fCursorDuped) {
            JetCloseTable(datasesid, datatblid);
        }
        if (fLinkCursorDuped) {
            JetCloseTable(datasesid, linktblid);
        }
    }

    *pusnAtBackup = usnFound;
    
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\jetbcli\jetbcli.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1984 - 1999
//
//  File:       jetbcli.cxx
//
//--------------------------------------------------------------------------

/*++

Copyright (C) Microsoft Corporation, 1984 - 1999

Module Name:

    jetbcli.cxx

Abstract:

    This module is the client side header file for the MDB/DS backup APIs.


Author:

    Larry Osterman (larryo) 19-Aug-1994


Revision History:


--*/
#define UNICODE

#include <mxsutil.h>
#include <windows.h>
#include <rpc.h>
#include <rpcdce.h>
#include <ntdsbcli.h>
#include <jetbak.h>
#include <jetbp.h>
#include <dsconfig.h>
#include <winldap.h>
#include <stdlib.h>

PSEC_WINNT_AUTH_IDENTITY_W g_pAuthIdentity = NULL;


/*************************************************************************************
Routine Description: 
    
      DsIsNTDSOnline
        Checks to see if the NTDS is Online on the given server. This call is 
        guaranteed to return quickly.

  Arguments:
    [in] szServerName - UNC name of the server to check
    [out] pfNTDSOnline - pointer to receive the bool result (TRUE if NTDS is
                            online; FALSE, otherwise)

Return Value:

    ERROR_SUCCESS if the call executed successfully;
    Failure code otherwise.
**************************************************************************************/
HRESULT 
NTDSBCLI_API
DsIsNTDSOnlineA(
    LPCSTR szServerName,
    BOOL *pfNTDSOnline
    )
{
    WSZ wszServerName;
    HRESULT hr;

    // Parameter checking is done in the xxxW version of the routine

    if (szServerName == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    wszServerName = WszFromSz(szServerName);
    if (!wszServerName)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    hr = DsIsNTDSOnlineW(wszServerName, pfNTDSOnline);

    MIDL_user_free(wszServerName);

    return hr;
}

HRESULT
NTDSBCLI_API
DsIsNTDSOnlineW(
    LPCWSTR szServerName,
    BOOL *pfNTDSOnline
    )
{
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    RPC_BINDING_HANDLE hBinding = NULL;
    BOOLEAN fRet;

    if ( (szServerName == NULL) || (pfNTDSOnline == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    DebugTrace(("FIsNTDSOnlineW: \\%S (%S service)\n", szServerName, g_wszBackupAnnotation));

    __try {

        DWORD alRpc = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;

        hr = HrJetbpConnectToBackupServer((WSZ) szServerName, g_wszRestoreAnnotation, JetRest_ClientIfHandle, &hBinding);

        if (hr != hrNone)
        {
            DebugTrace(("FIsNTDSOnlineW: Error %d connecting to backup server\n", hr));
            return hr;
        }

        //
        //  We've found an endpoint that matches the one we're looking for, now
        //  lets contact the remote server.
        //

RetrySecurity:
        RpcTryExcept
        {
            hr = RpcBindingSetAuthInfo(hBinding, NULL, alRpc,
                                       RPC_C_AUTHN_WINNT, (RPC_AUTH_IDENTITY_HANDLE) g_pAuthIdentity, RPC_C_AUTHZ_NAME);

            if (hr != hrNone && alRpc != RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
            {
                //
                //  If we couldn't set privacy (encryption), fall back to packet integrity.
                //

                alRpc = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;

                goto RetrySecurity;
            }

            if (hr != hrNone)
            {
                    return hr;
            }

            //
            //  Now tell the server side to prepare for a backup.
            //

            hr = HrRIsNTDSOnline(hBinding, &fRet);

            // RPC returned - set the return value
            if (pfNTDSOnline)
            {
                *pfNTDSOnline = (BOOL) fRet;
            }

            return hr;
        }
        RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        {
                hr = RpcExceptionCode();

                DebugTrace(("FIsNTDSOnlineW: Error %d raised when connecting to backup server\n", hr));

                //  If the client knows about encryption, but the server doesn't,
                //  fall back to unencrypted RPC's.
                //

                if (hr == RPC_S_UNKNOWN_AUTHN_LEVEL ||
                        hr == RPC_S_UNKNOWN_AUTHN_SERVICE ||
                        hr == RPC_S_UNKNOWN_AUTHN_TYPE ||
                        hr == RPC_S_INVALID_AUTH_IDENTITY)
                {
                        alRpc = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
                        goto RetrySecurity;
                }

                //
                //  Return the error from the RPC if it fails.
                //

                return hr;
        }
        RpcEndExcept;

    } __finally {
        if (hr != hrNone)
        {
            DebugTrace(("FIsNTDSOnlineW: Error %d returned after connecting to backup server\n", hr));
        } 

        if (hBinding != NULL)
        {
            UnbindRpc(&hBinding);
        }

    }

    return hr;
}

/*
 -  DsBackupPrepare
 -
 *
 *  Purpose:
 *  DsBackupPrepare will connect to a remote JET database and "prepare" it for
 *      backup.
 *
 *  The remote database is described by the name of the server
 *      (pszBackupServer), and an "annotation" of the server - The only 2
 *      currently defined annotations are:
 *          "Exchange MDB Database"
 *  and "Exchange DS Database"
 *
 *      However there is nothing in this implementation that prevents other databases
 *  from being backed up with this mechanism.
 *
 *  This API requires that the caller have the "Backup Server" privilege held.
 *
 *  Parameters:
 *      LPSTR pszBackupServer - The name of the server that contains the database to
 *                                  back up (\\SERVER).
 *      LPSTR pszBackupAnnotation - The "annotation" of the database in question.
 *
 *      ppvExpiryToken - pointer that will receive the pointer to the
 *              Expiry Token associated with this backup; Client should save
 *              this token and send it back through HrRestorePrepare() when
 *              attempting a restore; allocated memory should be freed using
 *              DsBackupFree() API by the caller when it is no longer needed.
 *      pcbExpiryTokenSize - pointer to receive the size of the expiry token
 *              returned.
 *
 *      phbcBackupContext - Client side context for this API.
 *
 *  Returns:
 *      Hr - The status of the operation.
 *          HrNone if successful, some other reasonable error if not.
 *
 */
HRESULT
DsBackupPrepareA(
    IN  LPCSTR szBackupServer,
    unsigned long grbit,
    unsigned long btBackupType,
    OUT PVOID *ppvExpiryToken,
    OUT LPDWORD pcbExpiryTokenSize,
    OUT PVOID *phbcBackupContext
    )
{
    HRESULT hr;
    WSZ wszBackupServer;

    // Parameter checking is done in the xxxW version of the routine

    if (szBackupServer == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    wszBackupServer = WszFromSz(szBackupServer);

    if (wszBackupServer == NULL)
    {
        return(GetLastError());
    }

    hr = DsBackupPrepareW(wszBackupServer, grbit, btBackupType, 
            ppvExpiryToken, pcbExpiryTokenSize, phbcBackupContext);

    MIDL_user_free(wszBackupServer);
    return(hr);
}

HRESULT
DsBackupPrepareW(
    IN LPCWSTR wszBackupServer,
    unsigned long grbit,
    unsigned long btBackupType,
    OUT PVOID *ppvExpiryToken,
    OUT LPDWORD pcbExpiryTokenSize,
    OUT PVOID *phbcBackupContext
    )
{
    HRESULT hr = hrNone;
    pBackupContext pbcContext = NULL;
    RPC_BINDING_HANDLE hBinding;
    EXPIRY_TOKEN *pToken = NULL;

    if ( (wszBackupServer == NULL) ||
         (phbcBackupContext == NULL)
        ) {
        return ERROR_INVALID_PARAMETER;
    }


    *phbcBackupContext = NULL;

    if (!ppvExpiryToken || !pcbExpiryTokenSize)
    {
        // These are required. We should fail the API, if the backup
        // doesn't want to take the expiry token info (restore would require this
        // and no point in backing up something that cannot be restored)
        //
        return hrInvalidParam;
    }
    else
    {
       *ppvExpiryToken = NULL;
       *pcbExpiryTokenSize = 0;
    }


    pbcContext = (pBackupContext)LocalAlloc(LMEM_ZEROINIT, sizeof(BackupContext));

    DebugTrace(("DsBackupPrepare: \\%S (%S service)\n", wszBackupServer, g_wszBackupAnnotation));

    __try {
        DWORD alRpc = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;

        if (pbcContext == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }

        pToken = (EXPIRY_TOKEN *) MIDL_user_allocate(sizeof(EXPIRY_TOKEN));
        if (!pToken)
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            __leave;
        }

        pToken->dwVersion = 1;
        pToken->dsBackupTime = GetSecsSince1601();
        hr = HrGetTombstoneLifeTime( wszBackupServer,
                                     &(pToken->dwTombstoneLifeTimeInDays) );
        if (FAILED(hr)) {
            DebugTrace(("DsBackupPrepare: Error %d getting tombstone lifetime from backup server\n", hr));
            __leave;
        }

        pbcContext->sock = INVALID_SOCKET;

        hr = HrJetbpConnectToBackupServer((WSZ) wszBackupServer, g_wszBackupAnnotation, JetBack_ClientIfHandle, &hBinding);

        if (hr != hrNone)
        {
            DebugTrace(("DsBackupPrepare: Error %d connecting to backup server\n", hr));
            __leave;
        }

        //
        //  We've found an endpoint that matches the one we're looking for, now
        //  lets contact the remote server.
        //

        pbcContext->hBinding = hBinding;

ResetSecurity:
        RpcTryExcept
        {
            hr = RpcBindingSetAuthInfo(hBinding, NULL, alRpc,
                            RPC_C_AUTHN_WINNT, (RPC_AUTH_IDENTITY_HANDLE) g_pAuthIdentity, RPC_C_AUTHZ_NAME);

            if (hr != hrNone && alRpc != RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
            {

                //
                //  If we couldn't set privacy (encryption), fall back to packet integrity.
                //

                alRpc = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;

                goto ResetSecurity;
            }

            if (hr != hrNone)
            {
                // Note this will leave the innermost enclosing try
                __leave;
            }

            //
            //  Now tell the server side to prepare for a backup.
            //

            hr = HrRBackupPrepare(hBinding, grbit, btBackupType, g_wszBackupAnnotation, GetCurrentProcessId(), &pbcContext->cxh);

            if (hr == hrNone)
            {
                pbcContext->fLoopbacked = FIsLoopbackedBinding((WSZ) wszBackupServer);
            }

            // Fall out of try block with hr set...
        }
        RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        {
            DWORD dwExceptionCode = RpcExceptionCode();

            DebugTrace(("DsBackupPrepare: Error %d raised when connecting to backup server\n", hr));

#if 0
            if (dwExceptionCode == ERROR_ACCESS_DENIED)
            {
                SendMagicBullet("AccessDenied");
            }
#endif   // #if 0
            //
            //  If the client knows about encryption, but the server doesn't,
            //  fall back to unencrypted RPC's.
            //

            if (dwExceptionCode == RPC_S_UNKNOWN_AUTHN_LEVEL ||
                dwExceptionCode == RPC_S_UNKNOWN_AUTHN_SERVICE ||
                dwExceptionCode == RPC_S_UNKNOWN_AUTHN_TYPE ||
                dwExceptionCode == RPC_S_INVALID_AUTH_IDENTITY)
            {
                alRpc = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
                goto ResetSecurity;
            }

            //
            //  Return the error from the RPC if it fails.
            //

            hr = HRESULT_FROM_WIN32( dwExceptionCode );
            // Fall out of except block with hr set...
        }
        RpcEndExcept;

    } __finally {
        if (hr != hrNone)
        {
            DebugTrace(("DsBackupPrepare: Error %d returned after connecting to backup server\n", hr));

            if (pbcContext != NULL)
            {
                if (pbcContext->hBinding != NULL)
                {
                    UnbindRpc(&pbcContext->hBinding);
                }
                LocalFree((void *)pbcContext);
            }

            if (pToken)
            {
                MIDL_user_free(pToken);
            }
        } else
        {
            // backup prepare successful - set correct values on the out parameters
            *phbcBackupContext = pbcContext;

            if (ppvExpiryToken)
            {
                *ppvExpiryToken = pToken;                
            }
            else
            {
                MIDL_user_free(pToken);
            }

            if (pcbExpiryTokenSize)
            {
                *pcbExpiryTokenSize = sizeof(EXPIRY_TOKEN);
            }            
        }

    }

    DebugTrace(("DsBackupPrepare: Returning error %d\n", hr));
    return(hr);
}

/*
 -  DsBackupGetDatabaseNames
 -
 *      DsBackupGetDatabaseNames will return the list of the attached
 *  databases on the remote machine.  The information returned in
 *  ppszAttachmentInformation should not be interpreted, as it only has meaning on
 *  the server being backed up.
 *  
 *      This API will allocate a buffer of sufficient size to hold the entire
 *  attachment list, which must be later freed with DsBackupFree.
 *
 *  Parameters:
 *      hbcBackupContext - Client side context for this API.
 *      ppszAttachmentInformation - A buffer containing null terminated
 *              strings.  It has the format <string>\0<string>\0
 *      pcbSize - The number of bytes in the buffer returned.
 *
 *  Returns:
 *      HRESULT - The status of the operation.
 *          hrNone if successful, some other reasonable error if not.
 *
 */

HRESULT
DsBackupGetDatabaseNamesA(
    IN PVOID hbcBackupContext,
    OUT LPSTR *ppszAttachmentInformation,
    OUT LPDWORD pcbSize
    )
{
    HRESULT hr;
    WSZ wszAttachmentInfo = NULL;
    CB cbwSize;
    WSZ wszAttachment;
    CB cbAttachment = 0;
    CB cbTmp = 0;
    SZ szAttachmentInfo;
    SZ szAttachment;

    // Parameter checking is done in the xxxW version of the routine

    if ( (ppszAttachmentInformation == NULL) ||
         (pcbSize == NULL)
        ) {
        return(ERROR_INVALID_PARAMETER);
    }

    hr = DsBackupGetDatabaseNamesW(hbcBackupContext, &wszAttachmentInfo,
                                            &cbwSize);

    if (hr != hrNone)
    {
        return(hr);
    }

    wszAttachment = wszAttachmentInfo;

    while (*wszAttachment != TEXT('\0'))
    {
        BOOL fUsedDefault;

        cbTmp = WideCharToMultiByte(CP_ACP, 0, wszAttachment, -1,
                                          NULL,
                                          0,
                                          "?", &fUsedDefault);
        if (cbTmp == 0)
        {
            hr = GetLastError();
            DsBackupFree(wszAttachmentInfo);
            return(hr);
        }

        cbAttachment += cbTmp;

        wszAttachment += wcslen(wszAttachment)+1;
    }

    //
    //  Account for the final null in the buffer.
    //

    cbAttachment += 1;

    *pcbSize = cbAttachment;

    szAttachmentInfo = MIDL_user_allocate(cbAttachment);

    if (szAttachmentInfo == NULL)
    {
        DsBackupFree(wszAttachmentInfo);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    szAttachment = szAttachmentInfo;

    wszAttachment = wszAttachmentInfo;

    while (*wszAttachment != TEXT('\0'))
    {
        CB cbThisAttachment;
        BOOL fUsedDefault;

        cbThisAttachment = WideCharToMultiByte(CP_ACP, 0, wszAttachment, -1,
                                          szAttachment,
                                          cbAttachment,
                                          "?", &fUsedDefault);
        if (cbThisAttachment == 0)
        {
            hr = GetLastError();
            DsBackupFree(wszAttachmentInfo);
            DsBackupFree(szAttachmentInfo);
            return(hr);
        }

        wszAttachment += wcslen(wszAttachment)+1;
        //
        // PREFIX: PREFIX complains that szAttachment may be uninitialized,
        // however this is impossible at this point.  We checked the return
        // value of WideCharToMultiByte and if it's zero then we return.  
        // The only way that the return value of WideCharToMultiByte could
        // be non-zero and still not initialize szAttachement is if cbAttachment
        // was zero as well.  This is impossible since cbAttachent will be 
        // atleast 1 at this point.
        //
        szAttachment += strlen(szAttachment)+1;
        cbAttachment -= cbThisAttachment;
    }

    //
    //  Double null terminate the string.
    //
    *szAttachment = '\0';

    *ppszAttachmentInformation = szAttachmentInfo;
    DsBackupFree(wszAttachmentInfo);

    return(hr);
}

HRESULT
DsBackupGetDatabaseNamesW(
    IN PVOID hbcBackupContext,
    OUT LPWSTR *ppwszAttachmentInformation,
    OUT LPDWORD pcbSize
    )
{
    HRESULT hr;
    pBackupContext pbcContext = (pBackupContext)hbcBackupContext;

    DebugTrace(("DsBackupGetDatabaseNames\n"));

    if ( (hbcBackupContext == NULL) ||
         (ppwszAttachmentInformation == NULL) ||
         (pcbSize == NULL)
        )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept
    {
        hr = HrRBackupGetAttachmentInformation(pbcContext->cxh, (SZ *)ppwszAttachmentInformation,
                                            pcbSize);
    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
    {
        hr = RpcExceptionCode();
    }
    RpcEndExcept;

    DebugTrace(("DsBackupGetDatabaseNames returned %d\n", hr));
    return(hr);
}


/*
 -  DsBackupOpenFile
 -
 *
 *  Purpose:
 *      DsBackupOpenFile will open a remote file for backup, and will perform
 *      whatever client and server side operations to prepare for the backup.
 *
 *      It takes in a hint of the size of the buffer that will later be passed into
 *      the DsBackupRead API that can be used to optimize the network traffic for the
 *      API.
 *      
 *      It will return (in pliFileSize) a LARGE_INTEGER that describes the size of
 *      the file.
 *
 *
 *  Parameters:
 *      hbcBackupContext - Client side context for this API.
 *      pszAttachmentName - The name of the file to be backed up.
 *      cbReadHintSize - A hint of the number of bytes that will be read in each
 *          DsBackupRead API.
 *      pliFileSize - The size of the file to be backed up.
 *
 *  Returns:
 *      HRESULT - The status of the operation.
 *      hrNone if successful, some other reasonable error if not.
 */

HRESULT
DsBackupOpenFileA(
    IN PVOID hbcBackupContext,
    IN LPCSTR szAttachmentName,
    IN DWORD cbReadHintSize,
    OUT LARGE_INTEGER *pliFileSize
    )
{
    HRESULT hr;
    WSZ wszAttachmentName;
    CCH cchWstr;

    // Parameter checking is done in the xxxW version of the routine

    if (szAttachmentName == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    cchWstr = MultiByteToWideChar(CP_ACP, 0, szAttachmentName, -1, NULL, 0);

    if (cchWstr == 0)
    {
        return(GetLastError());
    }

    wszAttachmentName = MIDL_user_allocate(cchWstr*sizeof(WCHAR));

    if (wszAttachmentName == NULL)
    {
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }

    if (MultiByteToWideChar(CP_ACP, 0, szAttachmentName, -1, wszAttachmentName, cchWstr) == 0) {
        MIDL_user_free(wszAttachmentName);
        return(GetLastError());
    }

    hr = DsBackupOpenFileW(hbcBackupContext, wszAttachmentName, cbReadHintSize, pliFileSize);

    MIDL_user_free(wszAttachmentName);

    return(hr);
}

HRESULT
DsBackupOpenFileW(
    IN PVOID hbcBackupContext,
    IN LPCWSTR wszAttachmentName,
    IN DWORD cbReadHintSize,
    OUT LARGE_INTEGER *pliFileSize
    )
{
    HRESULT hr;
    hyper hyperFileSize = 0;
    SOCKADDR rgsockaddrAddresses[MAX_SOCKETS];
    BOOLEAN fUseSockets = fFalse;
    SYSTEM_INFO si;
    C csockaddr = 0;
    pBackupContext pbcContext = (pBackupContext)hbcBackupContext;

    if ( (hbcBackupContext == NULL) ||
         (wszAttachmentName == NULL) ||
         (pliFileSize == NULL)
        )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    DebugTrace(("DsBackupOpenFile: %S\n", wszAttachmentName));

    pbcContext->cSockets = MAX_SOCKETS;
    hr = HrCreateBackupSockets(pbcContext->rgsockSocketHandles, pbcContext->rgprotvalProtocolsUsed,
                                &pbcContext->cSockets);

    if (hr == hrNone)
    {
        I iT;

        pbcContext->fUseSockets = fTrue;

        for (iT = 0 ; iT < pbcContext->cSockets ; iT += 1)
        {
            C cSockets;

            //
            //  Convert the socket we just got back into
            //  one or more sockaddr structures that we can use to pass
            //  to the remote machine.
            //

            hr = HrSockAddrsFromSocket(&rgsockaddrAddresses[csockaddr], &cSockets, pbcContext->rgsockSocketHandles[iT],
                                        pbcContext->rgprotvalProtocolsUsed[iT]);
            if (hr != hrNone)
            {
                //
                //  If we could open the sockets, but couldn't get their names,
                //  that's a fatal error.
                //
                return hr;
            }

            csockaddr += cSockets;
        }
    }

    //
    //  Take cbReadHintSize, and round it up to the nearest page size (on the client).
    //

    GetSystemInfo(&si);

    //
    //  Guarantee that dwPageSize is a power of 2
    //

    Assert ((si.dwPageSize & ~si.dwPageSize) == 0);

    //
    //  Round the read size up to the nearest page boundary.
    //

    cbReadHintSize = (cbReadHintSize + (si.dwPageSize-1) ) & ~(si.dwPageSize-1);

    if (pbcContext->fLoopbacked)
    {

        //
        //  We're loopbacked.  We want to create the shared memory section we're going to use for the
        //  data, the mutex that protects access to the shared memory meta-data, the read blocked event,
        //  and the write blocked event.
        //

        pbcContext->fUseSharedMemory = FCreateSharedMemorySection(&pbcContext->jsc, GetCurrentProcessId(), fTrue, cbReadHintSize * READAHEAD_MULTIPLIER);

    }

    RpcTryExcept
    {
        //
        //  Now tell the remote machine to open the file and to connect to the socket.
        //

        hr = HrRBackupOpenFile(pbcContext->cxh, (WSZ) wszAttachmentName,
                                            cbReadHintSize,
                                            &pbcContext->fUseSockets,
                                            csockaddr,
                                            rgsockaddrAddresses,
                                            &pbcContext->fUseSharedMemory,
                                            &hyperFileSize);

    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
    {
        //
        //  Return the error from the RPC if it fails.
        //
        return(RpcExceptionCode());
    }
    RpcEndExcept;

    pliFileSize->QuadPart = hyperFileSize;
    DebugTrace(("DsBackupOpenFile returns: %d\n", hr));

    return(hr);
}

DWORD
HrPerformBackupRead(
    PVOID context
    )
{
    //
    //  Just issue the read API.  We provide a buffer of 256 bytes because RPC will not allow
    //  us to specify a null pointer for the buffer.
    //
    CHAR rgbBuffer[256];
    DWORD cbRead = 256;
    HRESULT hr;

    pBackupContext pbcContext = (pBackupContext)context;

    if (context == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept
        hr = HrRBackupRead(pbcContext->cxh, rgbBuffer,
                                            cbRead,
                                            &cbRead);

    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        hr = RpcExceptionCode();
    RpcEndExcept
    //
    //  Tell the real read API what status we got back from the server.
    //

    pbcContext->hrApiStatus = hr;

    //
    //  And return, terminating the thread.
    //

    return(hr);
}

DWORD
HrPingServer(
    PVOID context
    )
{
    HRESULT hr;
    BOOL fContinue = fTrue;
    pBackupContext pbcContext = (pBackupContext)context;

    if (context == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    Assert(pbcContext->fUseSharedMemory);

    do {
        DWORD dwWaitReason = WAIT_OBJECT_0;

        RpcTryExcept
                hr = HrRBackupPing(pbcContext->hBinding);
        RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
                hr = RpcExceptionCode();
        RpcEndExcept;

        //
        //  Sleep for BACKUP_WAIT_TIMEOUT/4 milliseconds (2.5 minutes or 30 seconds)
        //

        if (pbcContext->hReadThread)
            dwWaitReason = WaitForSingleObject(pbcContext->hReadThread, BACKUP_WAIT_TIMEOUT/4);

        if (dwWaitReason == WAIT_OBJECT_0 )
        {
            fContinue = fFalse;
        }
        else
        {
            Assert(dwWaitReason == WAIT_TIMEOUT);
        }
        
    } while (fContinue);

    return hr;
}


HRESULT
HrReadSharedData(
    IN PJETBACK_SHARED_HEADER pjsh,
    IN PVOID pvBuffer,
    IN DWORD cbBuffer,
    OUT PDWORD pcbRead
    )
{
    DWORD   cbToCopy;
    DWORD   dwReadEnd;

    if ( (pjsh == NULL) ||
         (pvBuffer == NULL) ||
         (pcbRead == NULL)
        ) {
        return(ERROR_INVALID_PARAMETER);
    }

    Assert (pjsh->cbReadDataAvailable <= (LONG)pjsh->cbSharedBuffer);

    //
    //  If the read is > write, this means that the write has wrapped past the end of the
    //  shared memory region.  If the read pointer is less than the write pointer, it means
    //  that the read pointer is on the same side as the write pointer, thus the write pointer
    //  is the end of the read.  If the read is equal to the write pointer, if there is data to
    //  be read, it means that we're going to read to the end of the buffer
    //
    if (pjsh->dwReadPointer > pjsh->dwWritePointer ||
        (DWORD) pjsh->cbReadDataAvailable == pjsh->cbSharedBuffer)
    {
        dwReadEnd = pjsh->cbSharedBuffer;
    }
    else
    {
        dwReadEnd = pjsh->dwWritePointer;
    }

    Assert(dwReadEnd > pjsh->dwReadPointer);

    cbToCopy = min(dwReadEnd-pjsh->dwReadPointer, cbBuffer);

    Assert(cbToCopy > 0);

    //
    //  The read pointer doesn't match the write pointer!  This means that
    //  there's something in the buffer for us to read.
    //  

    CopyMemory(pvBuffer,
                (void *)((CHAR *)pjsh+
                    pjsh->cbPage+pjsh->dwReadPointer),
                cbToCopy);

    *pcbRead = cbToCopy;

    pjsh->dwReadPointer += cbToCopy;

    pjsh->cbReadDataAvailable -= cbToCopy;

    //
    //  Make sure that the data count didn't go negative.
    //
    Assert (pjsh->cbReadDataAvailable >= 0);

    //
    //  And make sure that we have less data than in the buffer.
    //

    Assert (pjsh->cbReadDataAvailable < (LONG)pjsh->cbSharedBuffer);

    Assert (pjsh->cbReadDataAvailable <= ((LONG)pjsh->cbSharedBuffer-(LONG)cbToCopy));

    //
    //  If we've stepped to the end of the buffer, we want to wrap the pointer
    //  back to the beginning.
    //

    if (pjsh->dwReadPointer == pjsh->cbSharedBuffer)
    {
        pjsh->dwReadPointer = 0;
    }

#ifdef DEBUG
    //
    //  The number of bytes available is always the same as the
    //  the number of bytes in the buffer - the # of bytes read, unless
    //  the read and write pointers are the same, in which case, it is either
    //  0 or the total # of bytes available.
    //
    //  If the read is blocked, then there must be 0 bytes available, otherwise there
    //  must be the entire buffer available.
    //

    if (pjsh->dwWritePointer == pjsh->dwReadPointer)
    {
        Assert (pjsh->cbReadDataAvailable == 0);
    }
    else
    {
        CB cbAvailable;
        if (pjsh->dwWritePointer > pjsh->dwReadPointer)
        {
            cbAvailable = pjsh->dwWritePointer - pjsh->dwReadPointer;
        }
        else
        {
            cbAvailable = pjsh->cbSharedBuffer - pjsh->dwReadPointer;
            cbAvailable += pjsh->dwWritePointer;
        }

        Assert (cbAvailable >= 0);
        Assert (pjsh->cbReadDataAvailable == cbAvailable);
    
    }
#endif

    return hrNone;
}

HRESULT
HrSocketRead(
    pBackupContext pbcContext,
    IN PVOID pvBuffer,
    IN DWORD cbBuffer,
    OUT PDWORD pcbRead
    )
{
    HANDLE hWaitList[3];
    DWORD dwWaitReason;
    OVERLAPPED overlap;
    HRESULT hr = hrNone;

    if ( (pbcContext == NULL) ||
         (pvBuffer == NULL) ||
         (pcbRead == NULL)
        ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    //  First create an event that will be signalled when the read on the socket completes.
    //

    overlap.hEvent = CreateEvent(NULL, FALSE, TRUE, NULL);

    if (overlap.hEvent == NULL)
    {
        return(GetLastError());
    }
    
    //
    //  If this is the first time through, we need to wait for the
    //  server to connect back to the client, and we need to create
    //  the client side API read thread.
    //
    //  This code is kinda wierd - it works by creating a thread
    //  on the client side that will issue a EcRBackupRead API to
    //  the server side.  This will create an RPC thread on the server
    //  side that will then proceed to shove data down the wire to the client
    //  until either the entire file has been transmitted to the client
    //  or until there was some form of error.
    //

    if (pbcContext->sock == INVALID_SOCKET)
    {
        DWORD cbReceiveBuffer;
        //
        //  First wait until the server connects to the client.
        //
        
        pbcContext->sock = SockWaitForConnections(pbcContext->rgsockSocketHandles, pbcContext->cSockets);
        
        if (pbcContext->sock == INVALID_SOCKET)
        {
            return(GetLastError());
        }
        
        
        //
        //  We need to make sure that the receive buffer is at least
        //  as long as the default (8K).
        //
        
        cbReceiveBuffer = max(8096, cbBuffer);
        
        if (setsockopt(pbcContext->sock, SOL_SOCKET, SO_RCVBUF,
                       (char *)&cbReceiveBuffer, sizeof(DWORD)) == SOCKET_ERROR)
        {   
            //
            //  We couldn't set the receive buffer to the appropriate
            //  size, do something reasonable.
            //
        }

        //
        //  Boolean socket operations just need a pointer to a non-
        //  zero buffer.
        //
        Assert(cbReceiveBuffer != 0);

        if (setsockopt(pbcContext->sock, SOL_SOCKET, SO_KEEPALIVE,
                       (char *)&cbReceiveBuffer, sizeof(DWORD)))
        {
            //
            //  We couldn't set the receive buffer to the appropriate
            //  size, do something reasonable.
            //
        }

        //
        //  Now create a thread for the read operation.
        //

        pbcContext->hReadThread = CreateThread(NULL, 0, HrPerformBackupRead, pbcContext, 0, &pbcContext->tidThreadId);

        //
        //  If we couldn't create the thread for the read, then we need to bail right now.
        //
            
        if (pbcContext->hReadThread == NULL)
        {
            return(GetLastError());
        }
        
    }
    
    //
    //  Now receive the users data from the socket.
    //
    
    if (!ReadFile((HANDLE)pbcContext->sock, pvBuffer, cbBuffer, pcbRead, &overlap))
    {
        //
        //  It's ok to get the error ERROR_IO_PENDING from this request.
        //
        
        if ((hr = GetLastError()) != ERROR_IO_PENDING)
        {
            closesocket(pbcContext->sock);
            
            pbcContext->sock = INVALID_SOCKET;
            
            //
            //  Now make sure that the read thread goes away.
            //
            
            CloseHandle(pbcContext->hReadThread);
            pbcContext->hReadThread = NULL;

            return(hr);
        }
    }

    hWaitList[0] = pbcContext->hReadThread;
    hWaitList[1] = overlap.hEvent;

    //
    //  Wait for either the read thread to terminate or for the read on the socket to
    //  complete.
    //
    
    dwWaitReason = WaitForMultipleObjects(2, hWaitList, FALSE, INFINITE);

    if (dwWaitReason == WAIT_OBJECT_0)
    {
        
        //
        //  The API (or at least the API thread) completed, lets wait for the read to complete now.
        //
        
        if (!GetOverlappedResult((HANDLE)pbcContext->sock, &overlap, pcbRead, TRUE))
        {
            //
            //  If the API succeeded, and the read failed, set the error
            //  to the error from the read.
            //
            if (pbcContext->hrApiStatus == hrNone)
            {
                pbcContext->hrApiStatus = GetLastError();
            }
        }
        
        //
        //  Shut down the receive event, we don't need it anymore.
        //
        
        CloseHandle(overlap.hEvent);
        
        return(pbcContext->hrApiStatus);
    }
    else
    {
        //
        //  The read completed before the API completed.  See if there was an error.
        //

        Assert (dwWaitReason == WAIT_OBJECT_0+1);

        if (!GetOverlappedResult((HANDLE)pbcContext->sock, &overlap, pcbRead, TRUE))
        {
            //
            //  Save away the error code.
            //

            hr = GetLastError();

            //
            //  The read failed.  This is not good, it indicates that there
            //  was some form of network error between the client and the server.
            //
            //  We want to close down the socket and wait until the read on the
            //  server completes.
            //

            closesocket(pbcContext->sock);
            
            pbcContext->sock = INVALID_SOCKET;

            //
            //  Shut down the event, we don't need it anymore.
            //

            CloseHandle(overlap.hEvent);

            //
            //  Now wait for the read thread to complete.  We know
            //  that the read thread will complete soon because
            //  we closed down the client side of the socket, and
            //  that will cause the write on the server side
            //  to complete, which will cause the server side to
            //  abort, which will cause the RPC to complete, which
            //  will cause the thread to complete....
            //

            WaitForSingleObject(pbcContext->hReadThread, INFINITE);

            //
            //  Then make the read thread go away.
            //

            CloseHandle(pbcContext->hReadThread);

            pbcContext->hReadThread = NULL;

            //
            //  And return the error.
            //

            return(hr);

        }
        else
        {
            //
            //  Shut down the event, we don't need it anymore.
            //

            CloseHandle(overlap.hEvent);

            //
            //  There was no error, return to the caller.
            //

            return(hrNone);
        }
    }
    return hr;
}

HRESULT
DsBackupRead(
    IN PVOID hbcBackupContext,
    IN PVOID pvBuffer,
    IN DWORD cbBuffer,
    OUT PDWORD pcbRead
    )
/*+++

    DsBackupRead will read one block from a backup file.

Inputs:
    hbcBackupContext - Client side context for this API.
    pvBuffer - Buffer to hold the data being backed up.
    cbBuffer - The size of the buffer.
    pcbRead - The number of bytes read.

Returns:
    HRESULT - The status of the operation.
        hrNone if successful.
        ERROR_END_OF_FILE if the end of file was reached while being
backed up
        Other Win32 and RPC error code.

Note:
    It is important to realize that pcbRead may be less than cbBuffer.  This
does not indicate an error, some transports may choose to fragment the buffer
being transmitted instead of returning the entire buffers worth of data.

Comments on the loopback case:
DsBackupRead synchronizes with HrSharedWrite using two events:
heventRead and heventWrite.
heventRead is the data available event from writer to reader
heventWrite is the data consumed event from reader to writer
This side is the reading side.
Writing side is at jetback\jetback.c:HrSharedWrite()

Here is the algorithm:
while ()
     read blocked = false
     if (data available)
        consume data
        if (write blocked) set data consumed event
     else
        read blocked = true
        wait on data available event
        if (error) set data consumed event, return

---*/
{
    HRESULT hr = hrNone;
    pBackupContext pbcContext = (pBackupContext)hbcBackupContext;
    HANDLE hWaitList[3];
    DWORD dwWaitReason;

    if ( (hbcBackupContext == NULL) ||
         (pvBuffer == NULL) ||
         (cbBuffer == 0) || 
         (pcbRead == NULL)
        ) {
        return(ERROR_INVALID_PARAMETER);
    }

    *pcbRead = 0;

    if (pbcContext->fUseSharedMemory)
    {
        //
        //  We're using shared memory to perform the read operation.  First of all, we want to kick off the thread
        //  that supports the read on the server side, if we need to.
        //

        if (pbcContext->hReadThread == NULL)
        {
            pbcContext->hReadThread = CreateThread(NULL, 0, HrPerformBackupRead, pbcContext, 0, &pbcContext->tidThreadId);

            //
            //  If we couldn't create the thread for the read, then we need to bail right now.
            //
            
            if (pbcContext->hReadThread == NULL)
            {
                return(GetLastError());
            }

            //
            //  Ok, our read thread is away.  It will eventually get to the server, so we can proceed as if it were
            //  already there.
            //
            pbcContext->hPingThread = CreateThread(NULL, 0, HrPingServer, pbcContext, 0, &pbcContext->tidThreadIdPing);
        }

        hWaitList[0] = pbcContext->hReadThread;

        do
        {

            //
            //  Ok.  Now we need to try to read data from the shared memory region.
            //
    
    
            //
            //  Acquire the lock that protects the shared memory region.
            //

            hWaitList[1] = pbcContext->jsc.hmutexSection;
            hWaitList[2] = pbcContext->hPingThread;
    
            dwWaitReason = WaitForMultipleObjects(3, hWaitList, FALSE, INFINITE);
    
            if (dwWaitReason == WAIT_OBJECT_0 || dwWaitReason == WAIT_OBJECT_0+2)
            {
                //
                //  The thread terminated.  This will happen when all the data on the server
                //  has been read, or there was an error on the read.
                //
                //  If there's been no error on the read, then we want to pull data until we've read
                //  all the data from the file.
                //

                pbcContext->jsc.pjshSection->hrApi = pbcContext->hrApiStatus;

                if (pbcContext->hrApiStatus == hrNone)
                {
                    //
                    //  There were no errors - read the data from the shared memory section.
                    //

                    if (pbcContext->jsc.pjshSection->cbReadDataAvailable > 0)
                    {
                        //
                        //  Read enough data from the shared memory section for this read.
                        //

                        pbcContext->hrApiStatus = HrReadSharedData(pbcContext->jsc.pjshSection, pvBuffer, cbBuffer, pcbRead);
                    }
                    else
                    {
                        //
                        //  A read at EOF returns ERROR_HANDLE_EOF.
                        //

                        *pcbRead = 0;

                        pbcContext->hrApiStatus = ERROR_HANDLE_EOF;
                    }
                }

                //
                //  For whatever reason, the thread went away - we have to blow this read away.
                //

                return pbcContext->hrApiStatus;
            }
    
            Assert (dwWaitReason == WAIT_OBJECT_0+1 || dwWaitReason == WAIT_ABANDONED_0+1);
    
            //
            //  The read thread is no longer blocked (if it used to be).
            //

            pbcContext->jsc.pjshSection->fReadBlocked = fFalse;

            //
            //  Let's see if we can read anything from the buffer.
            //
    
            if (pbcContext->jsc.pjshSection->cbReadDataAvailable > 0)
            {
                //
                //  Yipeee!  There's data in the buffer.  Read it out.
                //

                hr = HrReadSharedData(pbcContext->jsc.pjshSection, pvBuffer, cbBuffer, pcbRead);

                if (pbcContext->jsc.pjshSection->fWriteBlocked)
                {
                    //
                    //  Kick the write event - we can let ourselves loose now.
                    //

                    SetEvent(pbcContext->jsc.heventWrite);
                }

                ReleaseMutex(pbcContext->jsc.hmutexSection);


            } else {
                Assert (pbcContext->jsc.pjshSection->cbReadDataAvailable == 0);
                //
                //  Bummer!  There's no data in the buffer.  Wait until someone puts something in the buffer.
                //


                //
                //  We want to release the mutex and wait until the server puts
                //  something there for us.
                //

                pbcContext->jsc.pjshSection->fReadBlocked = fTrue;

                ReleaseMutex(pbcContext->jsc.hmutexSection);

                hWaitList[1] = pbcContext->jsc.heventRead;
                Assert(hWaitList[2] == pbcContext->hPingThread);

                //
                //  Wait until there's something for us to read.
                //

                dwWaitReason = WaitForMultipleObjects(3, hWaitList, FALSE, BACKUP_WAIT_TIMEOUT);
    
                if (dwWaitReason == WAIT_TIMEOUT)
                {
                    return hrCommunicationError;
                }
                else if (dwWaitReason == WAIT_OBJECT_0 || dwWaitReason == WAIT_OBJECT_0+2)
                {
                    //
                    //  The remote side completed.
                    //

                    pbcContext->jsc.pjshSection->hrApi = pbcContext->hrApiStatus;

                    if (pbcContext->hrApiStatus != hrNone)
                    {
                        return pbcContext->hrApiStatus;
                    }
                    //
                    //  Hmmm...  Since the remote side completed, that means that we're done reading the
                    //  data.  Now we want to copy the remaining data from the shared memory section.
                    //

                    if (pbcContext->jsc.pjshSection->cbReadDataAvailable > 0)
                    {
                        //
                        //  Read enough data from the shared memory section for this read.
                        //

                        pbcContext->hrApiStatus = HrReadSharedData(pbcContext->jsc.pjshSection, pvBuffer, cbBuffer, pcbRead);
                    }
                    else
                    {
                        Assert (pbcContext->jsc.pjshSection->cbReadDataAvailable == 0);
                        //
                        //  A read at EOF returns ERROR_HANDLE_EOF.
                        //

                        *pcbRead = 0;

                        pbcContext->hrApiStatus = ERROR_HANDLE_EOF;
                    }

                    return pbcContext->hrApiStatus;
                }
    
                Assert (dwWaitReason == WAIT_OBJECT_0+1 || dwWaitReason == WAIT_ABANDONED_0+1);
    
            }
    
        } while ( *pcbRead == 0 );

        if (hr != hrNone)
        {
            //
            //  Mark that the read had an error to allow the server to wake up and continue.
            //
            pbcContext->jsc.pjshSection->hrApi = hr;

            //
            //  Kick the server if it's blocked waiting on a read.
            //

            SetEvent(pbcContext->jsc.heventWrite);

        }

    } else if (pbcContext->fUseSockets)
    {
        hr = HrSocketRead(pbcContext, pvBuffer, cbBuffer, pcbRead);

    }
    else
    {
        RpcTryExcept
            //
            //  We're not using sockets, fall back to the
            //  core RPC protocols.
            //

            hr = HrRBackupRead(pbcContext->cxh, pvBuffer,
                                            cbBuffer,
                                            pcbRead);
        RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
            hr = RpcExceptionCode();
        RpcEndExcept

    }

    return(hr);
}

HRESULT
DsBackupClose(
    IN PVOID hbcBackupContext
    )
/*+++

    DsBackupCloseFile will close the current file being backed up.

Inputs:
    hbcBackupContext - Client side context for this API.

Returns:
    HR - The status of the operation.
        hrNone if successful.
        Other Win32 and RPC error code.

---*/
{
    HRESULT hr;
    pBackupContext pbcContext = (pBackupContext)hbcBackupContext;

    if (hbcBackupContext == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    if (pbcContext->sock != INVALID_SOCKET)
    {
        //
        //  Shut down the current socket.
        //

        closesocket(pbcContext->sock);

        //
        //  Mark the socket as being invalid for a later open.
        //

        pbcContext->sock = INVALID_SOCKET;
    }

    //
    //  If we've created a read thread, shut it down.
    //


    if (pbcContext->hReadThread != NULL)
    {
        //
        //  Now wait for the read thread to complete.
        //

        if (pbcContext->fUseSharedMemory) {
            pbcContext->jsc.pjshSection->hrApi = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            SetEvent(pbcContext->jsc.heventWrite);
        }

        WaitForSingleObject(pbcContext->hReadThread, INFINITE);

    }

    //
    //  If we've created a ping thread, shut it down.
    //

    if (pbcContext->hPingThread != NULL)
    {
        //
        //  Now wait for the read thread to complete.
        //

        WaitForSingleObject(pbcContext->hPingThread, INFINITE);

    }

    // Both the read thread and ping thread are done - close handles

    if (pbcContext->hReadThread != NULL)
    {

        CloseHandle(pbcContext->hReadThread);

        pbcContext->hReadThread = NULL;
    }

    if (pbcContext->hPingThread != NULL)
    {

        CloseHandle(pbcContext->hPingThread);

        pbcContext->hPingThread = NULL;
    }

    CloseSharedControl(&pbcContext->jsc);

    RpcTryExcept

        hr = HrRBackupClose(pbcContext->cxh);

    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        hr = RpcExceptionCode();
    RpcEndExcept

    return(hr);
}

/*
 -  DsBackupGetBackupLogs
 -
 *
 *  Purpose:
 *      DsBackupGetBackupLogs will retrieve the list of additional files that need
 *  to be backed up.
 *
 *
 *      This API will allocate a buffer of sufficient size to hold the entire
 *  backup log list, which must be later freed with DsBackupFree.
 *
 *
 *  Parameters:
 *      hbcBackupContext - Client side context for this API.
 *      ppszBackupLogFile - A buffer containing null terminated
 *          strings.  It has the format <string>\0<string>\0
 *      pcbSize - The number of bytes in the buffer returned.
 *
 *  Returns:
 *      HRESULT - The status of the operation.
 *          hrNone if successful.
 *          Other Win32 and RPC error code.
 *
 */

HRESULT
DsBackupGetBackupLogsA(
    IN PVOID hbcBackupContext,
    OUT LPSTR *ppszLogInformation,
    OUT PDWORD pcbSize
    )
{
    HRESULT hr;
    WSZ wszLogInfo = NULL;
    CB cbwSize;
    WSZ wszLog;
    CB cbLog = 0;
    CB cbTmp = 0;
    SZ szLogInfo;
    SZ szLog;

    // Parameter checking is done in the xxxW version of the routine

    if ( (ppszLogInformation == NULL) ||
         (pcbSize == NULL) ) {
        return(ERROR_INVALID_PARAMETER);
    }
    hr = DsBackupGetBackupLogsW(hbcBackupContext, &wszLogInfo, &cbwSize);

    if (hr != hrNone)
    {
        return(hr);
    }

    wszLog = wszLogInfo;

    while (*wszLog != TEXT('\0'))
    {
        BOOL fUsedDefault;
        cbTmp = WideCharToMultiByte(CP_ACP, 0, wszLog, -1,
                                          NULL,
                                          0,
                                          "?", &fUsedDefault);
        if (cbTmp == 0)
        {
            hr = GetLastError();
            DsBackupFree(wszLogInfo);
            return(hr);
        }

        cbLog += cbTmp;

        wszLog += wcslen(wszLog)+1;
    }

    //
    //  Account for the null at the end of the buffer.
    //

    cbLog += 1;

    *pcbSize = cbLog;

    szLogInfo = MIDL_user_allocate(cbLog);

    if (szLogInfo == NULL)
    {
        DsBackupFree(wszLogInfo);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    szLog = szLogInfo;

    wszLog = wszLogInfo;

    while (*wszLog != TEXT('\0'))
    {
        CB cbThisLog;
        BOOL fUsedDefault;

        cbThisLog = WideCharToMultiByte(CP_ACP, 0, wszLog, -1,
                                          szLog,
                                          cbLog,
                                          "?", &fUsedDefault);
        if (cbThisLog == 0)
        {
            hr = GetLastError();
            DsBackupFree(wszLogInfo);
            DsBackupFree(szLogInfo);
            return(hr);
        }

        wszLog += wcslen(wszLog)+1;
        //
        // PREFIX: PREFIX complains that szLog may be uninitialized,
        // however this is impossible at this point.  We checked the return
        // value of WideCharToMultiByte and if it's zero then we return.  
        // The only way that the return value of WideCharToMultiByte could
        // be non-zero and still not initialize szAttachement is if cbLog
        // was zero as well.  This is impossible since cbLog will be 
        // atleast 1 at this point.
        //
        szLog += strlen(szLog)+1;
        cbLog -= cbThisLog;
    }

    //
    //  Double null terminate the string.
    //
    *szLog = '\0';

    *ppszLogInformation = szLogInfo;
    DsBackupFree(wszLogInfo);
    return(hr);
}

HRESULT
DsBackupGetBackupLogsW(
    IN PVOID hbcBackupContext,
    OUT LPWSTR *ppwszBackupLogFile,
    OUT PDWORD pcbSize
    )
{
    HRESULT hr;
    pBackupContext pbcContext = (pBackupContext)hbcBackupContext;

    if ( (hbcBackupContext == NULL) ||
         (ppwszBackupLogFile == NULL) ||
         (pcbSize == NULL) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept
        hr = HrRBackupGetBackupLogs(pbcContext->cxh,
                                (SZ *)ppwszBackupLogFile,
                                pcbSize);

    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        hr = RpcExceptionCode();
    RpcEndExcept;
    return(hr);
}

HRESULT
DsBackupTruncateLogs(
    IN PVOID hbcBackupContext
    )
/*+++

    DsBackupTruncateLogs will terminate the backup operation.  It is to be
    called when the backup has completed successfully.

Inputs:
    hbcBackupContext - Client side context for this API.

Returns:
    HRESULT - The status of the operation.
        hrNone if successful.
        Other Win32 and RPC error code.

NOTE:
    Again, this API may have to take a grbit parameter to be passed to the
server to indicate the backup type.

---*/
{
    HRESULT hr;
    pBackupContext pbcContext = (pBackupContext)hbcBackupContext;

    if (hbcBackupContext == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept
        hr = HrRBackupTruncateLogs(pbcContext->cxh);
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        hr = RpcExceptionCode();
    RpcEndExcept;

    return(hr);
}

HRESULT
DsBackupEnd(
    IN PVOID hbcBackupContext
    )
/*+++

    DsBackupEnd will clean up after a backup operation has been performed.  This
API will close outstanding binding handles, and do whatever is necessary to
clean up after a successful (or unsuccesful) backup attempt.


Inputs:
    hbcBackupContext - Client side context for this API.

Returns:
    HRESULT - The status of the operation.
        hrNone if successful.
        Other Win32 and RPC error code.

NOTE:

---*/
{
    HRESULT hr;
    pBackupContext pbcContext = (pBackupContext)hbcBackupContext;

    if (hbcBackupContext == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (pbcContext->hBinding != NULL)
    {
        I irgsock;

        //
        //  Close the file (and shut down the thread) if it is still open.
        //

        DsBackupClose(hbcBackupContext);

        RpcTryExcept
            hr = HrRBackupEnd(&pbcContext->cxh);
        RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
            hr = RpcExceptionCode();
        RpcEndExcept;

        RpcBindingFree(&pbcContext->hBinding);

        //
        //  Now close down the listening socket handles, we're
        //  done.
        //
        for (irgsock = 0; irgsock < pbcContext->cSockets; irgsock += 1)
        {
            closesocket(pbcContext->rgsockSocketHandles[irgsock]);
        }

    }

    MIDL_user_free(pbcContext);

    return(hrNone);
}
VOID
DsBackupFree(
    IN PVOID pvBuffer
    )
/*+++

    DsBackupFree will free memory allocated during one of the backup APIs.

Inputs:
    pvBuffer - Buffer to free

Returns:
    None.

NOTE:
    This is simply a wrapper for MIDL_user_free().

---*/

{
    MIDL_user_free(pvBuffer);
}


void *
MIDL_user_allocate(
    size_t cbBytes
    )
{
    return(LocalAlloc(0, cbBytes));
}

void
MIDL_user_free(
    void *pvBuffer
    )
{
    LocalFree(pvBuffer);
}


// supported protocol sequences

#define iszProtoseqNamedPipes 1

WSZ rgszProtSeq[] =
{	
	L"ncalrpc",		// lpc
	L"ncacn_np",		// named pipe
	L"ncacn_ip_tcp",	// tcp/ip
	L"ncacn_spx",	// spx
};


long
cszProtSeq = sizeof(rgszProtSeq) / sizeof(rgszProtSeq[0]);



/*
 -	HrCreateRpcBinding
 *
 *	Purpose:
 *		Tries to bind to a particular RPC protocol sequence
 *
 *	Parameters:
 *		iszProtoseq		index into array of protocol sequences
 *		szServer		server name as a string
 *		phBinding		used to return RPC binding on success
 *
 *	Returns:
 *		binding handle filled in.  Returns no error, but null handle if xport
 *		is not valid on this machine.
 */
HRESULT
HrCreateRpcBinding( I iszProtoseq, WSZ szServer, handle_t * phBinding )
{
	RPC_STATUS			rpc_status;
	WCHAR				rgchServer[256];
	WSZ					wszStringBinding = NULL;
	HRESULT				hr = hrNone;

	Assert(iszProtoseq>=0 && iszProtoseq < cszProtSeq);

	wszStringBinding = NULL;
	*phBinding = 0;
	if ( (szServer == NULL) || (phBinding == NULL) ) 
		return hrInvalidParam;

	// Allow caller to specify the leading "\\" or not.
	if (szServer[0] == TEXT('\\') && szServer[1] == TEXT('\\'))
		szServer += 2;

	// Format server name
        // Note that LPC may or may not be used even when the server name identifies
        // the local system. LPC only accepts NULL or the NETBIOS name of the computer.
        // If a dns name or dns alias name of the local system is used, LPC will not
        // work.  This corresponds with the check in FIsLoopbacked().
	if (iszProtoseq == iszProtoseqNamedPipes)
	{
		// Named pipes require "\\" before the server name.
		rgchServer[0] = TEXT('\\');
		rgchServer[1] = TEXT('\\');
		wcsncpy(rgchServer + 2, szServer, (sizeof(rgchServer)/sizeof(rgchServer[0])) - 2);
                rgchServer[(sizeof(rgchServer)/sizeof(rgchServer[0])) - 1] = L'\0';
	}
	else {
		wcsncpy(rgchServer, szServer, sizeof(rgchServer)/ sizeof(rgchServer[0]));
                rgchServer[(sizeof(rgchServer)/sizeof(rgchServer[0])) - 1] = L'\0';
        }

	if (RpcNetworkIsProtseqValidW(rgszProtSeq[iszProtoseq]) == NO_ERROR)
	{
		/* Set up the RPC binding */
		rpc_status = RpcStringBindingComposeW( NULL,
				   			  rgszProtSeq[iszProtoseq],
				   			  rgchServer,
				   			  NULL,
				   			  NULL,
				   			  &wszStringBinding );
		if (rpc_status)
			return rpc_status;
		
		rpc_status = RpcBindingFromStringBindingW(wszStringBinding, phBinding);
		(void) RpcStringFreeW(&wszStringBinding);
		if (rpc_status)
			return rpc_status;

		Assert(*phBinding);
	}

	return hrNone;
}

/*
 -	UnbindRpc
 -
 *	Purpose:
 *		Tear down RPC binding
 *
 *	Parameters:
 *		phBinding
 *
 *	Returns:
 */
void
UnbindRpc( handle_t *phBinding )
{
	(void) RpcBindingFree(phBinding);
}

BOOLEAN
FIsLoopbackedBinding(
    WSZ wszServerName
	)
{
	BOOLEAN fLoopbacked = FALSE;
    WCHAR wszLocalServer[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD csz = MAX_COMPUTERNAME_LENGTH + 1;
    WSZ wszRemoteServer = wszServerName;

    if (!GetComputerNameW(wszLocalServer, &csz))
    {
        return fFalse;
    }

    if (L'\\' == *wszRemoteServer)
    {
        Assert(L'\\' == *(wszRemoteServer + 1));

        // skip the "\\" prefix to go to the start of the server name
        wszRemoteServer += 2;
    }

    fLoopbacked = (0 == _wcsicmp(wszRemoteServer, wszLocalServer));

	if (fLoopbacked)
	{
		HRESULT hr;
		HKEY hkey;
		DWORD fLoopbackDisabled;
		DWORD dwType;
		DWORD cbLoopbackDisabled;

		//
		//	Let's check the registry just in case someone has disabled us.
		//
		if (hr = RegOpenKeyExW(HKEY_LOCAL_MACHINE, BACKUP_INFO, 0, KEY_READ, &hkey))
		{
			//
			//	We couldn't open the key, so return what we deduced.
			//
			return fLoopbacked;
		}

		dwType = REG_DWORD;
		cbLoopbackDisabled = sizeof(fLoopbackDisabled);
		hr = RegQueryValueExW(hkey, DISABLE_LOOPBACK, 0, &dwType, (LPBYTE)&fLoopbackDisabled, &cbLoopbackDisabled);
	
		if (hr != hrNone)
		{
			RegCloseKey(hkey);
			return fLoopbacked;
		}
	
		//
		//	If the registry told us to disable loopbacked access, then respect it.
		//
		if (fLoopbackDisabled)
		{
			fLoopbacked = fFalse;
		}

		RegCloseKey(hkey);
	}

	return fLoopbacked;
}

HRESULT
HrJetbpConnectToBackupServer(
    WSZ wszBackupServer,
    WSZ wszBackupAnnotation,
    RPC_IF_HANDLE rifHandle,
    handle_t *prbhBinding
    )
/*+++

    HrJetbpConnectToBackupServer will create an RPC binding handle that talks to the specified remote backup server
    with the specified annotation.

Inputs:
    wszBackupServer - The name of the server to contact.  It can be of the form \\server or server.
    szBackupAnnotation -The "annotation" that allows us to choose the backup server in question.
    rifHandle - The RPC binding handle we wish to connect to.
    prbhBinding - Holds the returned binding handle.

Returns:
    Status of operation.  hrNone if successful, some reasonable error if not.

---*/
{
    RPC_EP_INQ_HANDLE inqcontext = NULL;
    RPC_BINDING_HANDLE rbhHandle = NULL;
    I iszProtSeq;
    RPC_BINDING_HANDLE hBinding = NULL;
    HRESULT hr;
    WSZ szStringBinding = NULL;
    WSZ szProtocolSequence = NULL;
    WSZ wszAnnotation = NULL;

    if ( (wszBackupServer == NULL) ||
         (wszBackupAnnotation == NULL) ||
         (rifHandle == NULL) ||
         (prbhBinding == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    *prbhBinding = NULL;

    __try {
        for (iszProtSeq = 0; iszProtSeq < cszProtSeq; iszProtSeq++) {
            RPC_IF_ID ifid;
    
            if (NULL != hBinding) {
                UnbindRpc(&hBinding);
            }

            hr = HrCreateRpcBinding(iszProtSeq, wszBackupServer, &hBinding);
            if (hr != hrNone) {
                continue;
            }
    
            //
            //  If the binding handle isn't active locally, don't bother.
            //

            if (hBinding == NULL) {
                continue;
            }

            RpcTryExcept {
                hr = RpcIfInqId(rifHandle, &ifid);
    
                if (inqcontext != NULL) {
                    RpcMgmtEpEltInqDone(&inqcontext);
                }

                hr = RpcMgmtEpEltInqBegin(hBinding,
                                          RPC_C_EP_MATCH_BY_IF,
                                          &ifid,
                                          RPC_C_VERS_EXACT,
                                          NULL,
                                          &inqcontext);
                //
                //  Try the next interface if this fails.
                //
                if (hr != hrNone) {
                    continue;
                }
    
                do {
                    if (NULL != wszAnnotation) {
                        RpcStringFreeW(&wszAnnotation);
                    }

                    if (NULL != rbhHandle) {
                        RpcBindingFree(&rbhHandle);
                    }

                    hr = RpcMgmtEpEltInqNextW(inqcontext,
                                              &ifid,
                                              &rbhHandle, // Binding
                                              NULL,   // UUID
                                              &wszAnnotation
                                              );
        
                    //
                    //  We don't get any errors from RpcMgmtEpEltInqBegin,
                    //  so take the error from InqNext and continue....
                    //
                    //  Please note that if a transport is present on the server but
                    //  not present on the client, we will get RPC_S_PROTSEQ_NOT_SUPPORTED
                    //  from RpcMgmtEpEltInqNext(), so we want to skip to the next endpoint.
                    //

                    if (hr != hrNone) {
                        if (hr == RPC_S_PROTSEQ_NOT_SUPPORTED) {
                            hr = hrNone;
                        }
                        continue;
                    }
    
                    //
                    //  Check this endpoints annotation against the annotation
                    //  supplied.  If it matches, we're done.
                    //
    
                    if (0 == _wcsicmp(wszAnnotation, wszBackupAnnotation)) {
                        //
                        //  Ok, this is on the right endpoint, now lets
                        //  check to make sure that it's on the right
                        //  transport.
                        //

                        if (NULL != szStringBinding) {
                            RpcStringFreeW(&szStringBinding);
                        }

                        hr = RpcBindingToStringBindingW(rbhHandle, &szStringBinding);
                        if (hr != hrNone) {
                            break;
                        }
    
                        if (NULL != szProtocolSequence) {
                            RpcStringFreeW(&szProtocolSequence);
                        }
                        
                        hr = RpcStringBindingParseW(szStringBinding, NULL, &szProtocolSequence, NULL, NULL, NULL);
                        if (hr != hrNone) {
                            break;
                        }
    

                        //
                        //  Now check to see if this binding handle goes over the
                        //  right protocol.
                        //
    
                        if (0 == wcscmp(szProtocolSequence, rgszProtSeq[iszProtSeq])) {
                            DebugTrace(("ConnectToBackup, binding = %ws\n",
                                        szStringBinding));
                            //
                            //  Ok, the annotation and the protocol sequence
                            //  both match, we can use this binding
                            //  handle for our API.
                            //
    
                            *prbhBinding = rbhHandle;
                            rbhHandle = NULL; // i.e., don't RpcBindingFree

                            return(hrNone);
                        }
                    }
                } while (hr == hrNone);
            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) ) {
                continue;
            } RpcEndExcept;
        }
    } __finally {
        if (inqcontext != NULL) {
            RpcMgmtEpEltInqDone(&inqcontext);
        }

        if (NULL != szStringBinding) {
            RpcStringFreeW(&szStringBinding);
        }

        if (NULL != szProtocolSequence) {
            RpcStringFreeW(&szProtocolSequence);
        }

        if (NULL != wszAnnotation) {
            RpcStringFreeW(&wszAnnotation);
        }

        if (NULL != rbhHandle) {
            RpcBindingFree(&rbhHandle);
        }
    
        if (NULL != hBinding) {
            RpcBindingFree(&hBinding);
        }
    }

    if (hr != hrNone) {
        return(hrCouldNotConnect);
    }

    return(hr);

}

/*
 -  DsSetCurrentBackupLogs
 -
 *  Purpose:
 *      This routine remotes an API to the server to check to make sure that all the necessary
 *      are present for the backup to proceed.  It is called for Incremental and Differential backups.
 *
 *  Parameters:
 *      puuidService - an Object UUID for the service.
 *      char *szEndpointAnnotation - An annotation for the endpoint.  A client can use this
 *          annotation to determine which endpoint to bind to.
 *
 *  Returns:
 *
 *      HRESULT - Status of operation.  ecNone if successful, reasonable value if not.
 *
 */
HRESULT
DsSetCurrentBackupLogA(
    LPCSTR szServer,
    DWORD dwCurrentLog
    )
{
    HRESULT hr;
    WSZ wszServer;

    // Parameter checking is done in the xxxW version of the routine

    if (szServer == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    wszServer = WszFromSz(szServer);

    if (wszServer == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    hr = DsSetCurrentBackupLogW(wszServer, dwCurrentLog);

    MIDL_user_free(wszServer);

    return hr;
}

HRESULT
DsSetCurrentBackupLogW(
    LPCWSTR wszServer,
    DWORD dwCurrentLog
    )
{
    HRESULT hr;
    RPC_BINDING_HANDLE hBinding = NULL;
    I iszProtSeq;

    if (wszServer == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    for (iszProtSeq = 0; iszProtSeq < cszProtSeq ; iszProtSeq += 1)
    {
    
        Assert(hBinding == NULL);
        hr = HrCreateRpcBinding(iszProtSeq, (WSZ) wszServer, &hBinding);

        if (hr != hrNone)
        {
            return hr;
        }

        if (hBinding == NULL)
        {
            continue;
        }

        RpcTryExcept
        {
            hr = HrRRestoreSetCurrentLogNumber(hBinding, g_wszRestoreAnnotation, dwCurrentLog);
        }
        RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        {
            hr = RpcExceptionCode();
            UnbindRpc(&hBinding);
            continue;
        }
        RpcEndExcept

        break;
    }

    if (hBinding)
    {
        UnbindRpc(&hBinding);
    }

    return hr;
}


/*
 -  DsCheckBackupLogs
 -
 *  Purpose:
 *      This routine remotes an API to the server to check to make sure that all the necessary
 *      are present for the backup to proceed.  It is called for Incremental and Differential backups.
 *
 *  Parameters:
 *      puuidService - an Object UUID for the service.
 *      char *szEndpointAnnotation - An annotation for the endpoint.  A client can use this
 *          annotation to determine which endpoint to bind to.
 *
 *  Returns:
 *
 *      HRESULT - Status of operation.  ecNone if successful, reasonable value if not.
 *
 */
HRESULT
I_DsCheckBackupLogs(
    WSZ wszBackupAnnotation
    )
{
    HRESULT hr;
    handle_t hBinding;
    WCHAR rgwcComputer[ MAX_COMPUTERNAME_LENGTH + 1];
    DWORD cbComputerName = sizeof(rgwcComputer) / sizeof(rgwcComputer[0]);

    if (wszBackupAnnotation == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!GetComputerNameW(rgwcComputer, &cbComputerName))
    {
        return GetLastError();
    }

    hr = HrCreateRpcBinding(1, rgwcComputer, &hBinding);

    if (hr != hrNone)
    {
        return hr;
    }

    //
    //  If somehow named pipes weren't available, punt.
    //

    if (hBinding == NULL)
    {
        return hrCouldNotConnect;
    }

    RpcTryExcept
    {
        hr = HrRRestoreCheckLogsForBackup(hBinding, wszBackupAnnotation);
    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
    {
        hr = RpcExceptionCode();
    }
    RpcEndExcept;

    UnbindRpc(&hBinding);

    return hr;
}


BOOL
DllEntryPoint(
    HINSTANCE hinstDll,
    DWORD dwReason,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This routine is invoked when interesting things happen to the dll.

Arguments:

    hinstDll - an instance handle for the DLL.
    dwReason - The reason the routine was called.
    pvReserved - Unused, unless dwReason is DLL_PROCESS_DETACH.

Return Value:

    BOOL - TRUE if the DLL initialization was successful, FALSE if not.

--*/
{
    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
    {
        LPSTR rgpszDebugParams[] = {"ntdsbcli.dll", "-noconsole"};
        DWORD cNumDebugParams = sizeof(rgpszDebugParams)/sizeof(rgpszDebugParams[0]);

        DEBUGINIT(cNumDebugParams, rgpszDebugParams, "ntdsbcli");
        
        //
        //  We don't do anything on thread attach/detach, so we don't
        //  need to be called.
        //
        DisableThreadLibraryCalls(hinstDll);

        return(FInitializeSocketClient());
    }
    case DLL_THREAD_ATTACH:
        break;
    case DLL_THREAD_DETACH:
        break;
    case DLL_PROCESS_DETACH:
        DEBUGTERM();
        if (pvReserved == NULL)
        {
            //
            //  We were called because of an FreeLibrary call.  Clean up what ever is
            //  appropriate.
            //
            return(FUninitializeSocketClient());
        } else
        {
            //
            //  The system will free up resources we have loaded.
            //
        }
        break;
    default:
        break;
    }
    return(TRUE);
}


/*************************************************************************************
Routine Description: 
    
      DsSetAuthIdentity
        Used to set the security context under which the client APIs are to be
        called. If this function is not called, security context of the current
        process is assumed.

  Arguments:
    [in]    szUserName - name of the user
    [in]    szDomainName -  name of the domain the user belongs to
    [in]    szPassword - password of the user in the specified domain

Return Value:

    One of the standard HRESULT success codes;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsSetAuthIdentityA(
    LPCSTR szUserName,
    LPCSTR szDomainName,
    LPCSTR szPassword
    )
{
    WSZ wszUserName = NULL;
    WSZ wszDomainName = NULL;
    WSZ wszPassword = NULL;
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;

    if ( (szUserName == NULL) ||
         (szDomainName == NULL) ||
         (szPassword == NULL) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    wszUserName = WszFromSz(szUserName);
    wszDomainName = WszFromSz(szDomainName);
    wszPassword = WszFromSz(szPassword);

    if (wszUserName && wszDomainName && wszPassword)
    {
        hr = DsSetAuthIdentityW(wszUserName, wszDomainName, wszPassword);
    }

    if (wszUserName)
        MIDL_user_free(wszUserName);

    if (wszDomainName)
        MIDL_user_free(wszDomainName);

    if (wszPassword)
        MIDL_user_free(wszPassword);

    return hr;
}

HRESULT
NTDSBCLI_API
DsSetAuthIdentityW(
    LPCWSTR szUserName,
    LPCWSTR szDomainName,
    LPCWSTR szPassword
    )
{
    HRESULT hr = ERROR_SUCCESS;

    if ( (szUserName == NULL) ||
         (szDomainName == NULL) ||
         (szPassword == NULL) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    g_pAuthIdentity = MIDL_user_allocate(sizeof(SEC_WINNT_AUTH_IDENTITY_W));

    if (!g_pAuthIdentity)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memset(g_pAuthIdentity, 0, sizeof(SEC_WINNT_AUTH_IDENTITY_W));

    // set the user name
    g_pAuthIdentity->UserLength = wcslen(szUserName);
    g_pAuthIdentity->User = (WCHAR *) MIDL_user_allocate((g_pAuthIdentity->UserLength + 1) * sizeof(WCHAR));
    if (!g_pAuthIdentity->User)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
    }

    // set the domain name
    g_pAuthIdentity->DomainLength = wcslen(szDomainName);
    g_pAuthIdentity->Domain = (WCHAR *) MIDL_user_allocate((g_pAuthIdentity->DomainLength + 1) * sizeof(WCHAR));
    if (!g_pAuthIdentity->Domain)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
    }

    // set the password
    g_pAuthIdentity->PasswordLength = wcslen(szPassword);
    g_pAuthIdentity->Password = (WCHAR *) MIDL_user_allocate((g_pAuthIdentity->PasswordLength + 1) * sizeof(WCHAR));
    if (!g_pAuthIdentity->Password)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (ERROR_SUCCESS == hr)
    {
        wcscpy(g_pAuthIdentity->User, szUserName);
        wcscpy(g_pAuthIdentity->Domain, szDomainName);
        wcscpy(g_pAuthIdentity->Password, szPassword);
        g_pAuthIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    }
    else
    {
        // unable to allocate space for some parts - free everything and set g_pAuthIdentity to NULL
        if (g_pAuthIdentity->User)
            MIDL_user_free(g_pAuthIdentity->User);

        if (g_pAuthIdentity->Domain)
            MIDL_user_free(g_pAuthIdentity->Domain);

        if (g_pAuthIdentity->Password)
            MIDL_user_free(g_pAuthIdentity->Password);

        MIDL_user_free(g_pAuthIdentity);

        g_pAuthIdentity = NULL;
    }
    
    return hr;
}

LONGLONG
GetSecsSince1601()
{
    SYSTEMTIME sysTime;
    FILETIME   fileTime;

    LONGLONG  dsTime = 0, tempTime = 0;

    GetSystemTime( &sysTime );
    
    // Get FileTime
    SystemTimeToFileTime(&sysTime, &fileTime);
    dsTime = fileTime.dwLowDateTime;
    tempTime = fileTime.dwHighDateTime;
    dsTime |= (tempTime << 32);

    // Ok. now we have the no. of 100 ns intervals since 1601
    // in dsTime. Convert to seconds and return
    
    return(dsTime/(10*1000*1000L));
}

HRESULT
HrGetTombstoneLifeTime(
    LPCWSTR wszBackupServer,
    LPDWORD pdwTombstoneLifeTimeDays
    )
{
    DWORD err, ldStatus, length;
    LDAP *hld;
    static LPSTR rgpszRootAttrsToRead[] = {"configurationNamingContext", NULL};
    static CHAR pszDirectoryService[] = "CN=Directory Service,CN=Windows NT,CN=Services,";
    static LPSTR rgpszDsAttrsToRead[] = {"tombstoneLifetime", NULL};
    LDAPMessage *pRootResults = NULL;
    LDAPMessage *pDsResults = NULL;
    LPSTR *ppszConfigNC = NULL;
    LPSTR pszDsDn = NULL;
    LPSTR *ppszValues = NULL;

    // Get the tombstone lifetime using ldap

    // Get rid of leading backslashes if present
    if (*wszBackupServer == L'\\') {
        wszBackupServer++;
        if (*wszBackupServer == L'\\') {
            wszBackupServer++;
        }
    }

    // Connect & bind to target DSA.
    hld = ldap_openW((LPWSTR)wszBackupServer, LDAP_PORT);
    if (NULL == hld) {
        err = ERROR_DS_UNAVAILABLE;
        goto error;
    }
    ldStatus = ldap_bind_s(hld, NULL, (WCHAR *) g_pAuthIdentity, LDAP_AUTH_SSPI);
    if (ldStatus != LDAP_SUCCESS) {
        err = LdapMapErrorToWin32( ldStatus );
        goto error;
    }

    // Get the config container
    ldStatus = ldap_search_sA(hld, NULL, LDAP_SCOPE_BASE, "(objectClass=*)",
                             rgpszRootAttrsToRead, 0, &pRootResults);
    if (ldStatus != LDAP_SUCCESS) {
        err = LdapMapErrorToWin32( ldStatus );
        goto error;
    }
    if (pRootResults == NULL) {
        err = ERROR_DS_PROTOCOL_ERROR;
        goto error;
    }
    ppszConfigNC = ldap_get_valuesA(hld, pRootResults, "configurationNamingContext");
    if (ppszConfigNC == NULL) {
        err = ERROR_DS_PROTOCOL_ERROR;
        goto error;
    }

    // Construct dn to directory service object
    length = strlen( *ppszConfigNC ) +
        sizeof( pszDirectoryService ) + 1;
    pszDsDn = malloc( length );
    if (pszDsDn == NULL) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    strcpy( pszDsDn, pszDirectoryService );
    strcat( pszDsDn, *ppszConfigNC );

    // Read tombstone lifetime, if present
    ldStatus = ldap_search_sA(hld, pszDsDn, LDAP_SCOPE_BASE, "(objectClass=*)",
                             rgpszDsAttrsToRead, 0, &pDsResults);
    if (ldStatus == LDAP_NO_SUCH_ATTRIBUTE) {
        // Not present - use default
        *pdwTombstoneLifeTimeDays = DEFAULT_TOMBSTONE_LIFETIME;
        err = ERROR_SUCCESS;
        goto error;
    }
    if (ldStatus != LDAP_SUCCESS) {
        err = LdapMapErrorToWin32( ldStatus );
        goto error;
    }
    if (pDsResults == NULL) {
        err = ERROR_DS_PROTOCOL_ERROR;
        goto error;
    }
    ppszValues = ldap_get_valuesA(hld, pDsResults, "tombstoneLifetime");
    if (ppszValues == NULL) {
        // Not present - use default
        *pdwTombstoneLifeTimeDays = DEFAULT_TOMBSTONE_LIFETIME;
        err = ERROR_SUCCESS;
        goto error;
    }

    *pdwTombstoneLifeTimeDays = strtoul( *ppszValues, NULL, 10 );
    err = ERROR_SUCCESS;

error:
    if (ppszValues) {
        ldap_value_freeA( ppszValues );
    }
    if (pDsResults) {
        ldap_msgfree(pDsResults);
    }
    if (pszDsDn) {
        free( pszDsDn );
    }
    if (ppszConfigNC) {
        ldap_value_freeA( ppszConfigNC );
    }
    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }
    ldap_unbind( hld );

    // This function returns a HRESULT status
    return err ? HRESULT_FROM_WIN32( err ) : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\jetbcli\jetrcli.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       jetrcli.c
//
//--------------------------------------------------------------------------

/*
 *  JETRCLI.C
 *  
 *  JET restore client API support.
 *  
 *  
 */
#define UNICODE 1
#include <windows.h>
#include <mxsutil.h>
#include <rpc.h>
#include <rpcdce.h>
#include <ntdsbcli.h>
#include <jetbp.h>
#include <dsconfig.h>

#include "local.h"  // common functions shared by client and server

extern PSEC_WINNT_AUTH_IDENTITY_W g_pAuthIdentity;

// Forward

HRESULT
DsRestoreCheckExpiryToken(
    PVOID pvExpiryToken,
    DWORD cbExpiryTokenSize
    );

HRESULT
DsRestorePrepareA(
    LPCSTR szServerName,
    ULONG rtFlag,
    PVOID pvExpiryToken,
    DWORD cbExpiryTokenSize,
    HBC *phbcBackupContext)
{
    HRESULT hr;
    WSZ wszServerName;

    // Parameter checking is done in the xxxW version of the routine

    if (szServerName == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    wszServerName = WszFromSz(szServerName);

    if (wszServerName == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    hr = DsRestorePrepareW(wszServerName, rtFlag, 
                pvExpiryToken, cbExpiryTokenSize, phbcBackupContext);

    MIDL_user_free(wszServerName);
    return(hr);
}

// The presense of the expiry token is optional at this point.
// If it is present, it is checked.
// The context is marked whether the expiry token was checked or not

HRESULT
DsRestorePrepareW(
    LPCWSTR wszServerName,
    ULONG rtFlag,
    PVOID pvExpiryToken,
    DWORD cbExpiryTokenSize,
    HBC *phbcBackupContext)
{
    HRESULT hr = hrCouldNotConnect;
    pBackupContext pbcContext = NULL;
    RPC_BINDING_HANDLE hBinding = NULL;
    I iszProtSeq;

    if ( (wszServerName == NULL) ||
         (phbcBackupContext == NULL)
        ) {
        return ERROR_INVALID_PARAMETER;
    }

    *phbcBackupContext = NULL;

    pbcContext = (pBackupContext)MIDL_user_allocate(sizeof(BackupContext));

    if (pbcContext == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    pbcContext->hBinding = NULL;
    pbcContext->sock = INVALID_SOCKET;

    __try
    {
        if (!pvExpiryToken || !cbExpiryTokenSize)
        {
            // Note that expiry token was not provided.  We will check for it later
            pbcContext->fExpiryTokenChecked = FALSE;
        }
        else
        {
            // Check the supplied token and note that we saw it
            hr = DsRestoreCheckExpiryToken( pvExpiryToken, cbExpiryTokenSize );
            if (hr != hrNone) {
                __leave;
            }
            pbcContext->fExpiryTokenChecked = TRUE;
        }

        for (iszProtSeq = 0; iszProtSeq < cszProtSeq ; iszProtSeq += 1)
        {
            DWORD alRpc = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;

            if (hBinding != NULL)
            {
                RpcBindingFree(&hBinding);
            }

            hr = HrCreateRpcBinding(iszProtSeq, (WSZ) wszServerName, &hBinding);

            if (hr != hrNone)
            {
                continue;
            }

            //
            //  If we couldn't get a binding handle with this protocol sequence,
            //  try the next one.
            //

            if (hBinding == NULL)
            {
                continue;
            }

            //
            //  Enable security on the binding handle.
            //

            pbcContext->hBinding = hBinding;

            
ResetSecurity:

            hr = RpcBindingSetAuthInfo(hBinding, NULL, alRpc,
                            RPC_C_AUTHN_WINNT, (RPC_AUTH_IDENTITY_HANDLE) g_pAuthIdentity, RPC_C_AUTHZ_NAME);

            if (hr != hrNone && alRpc != RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
            {
                alRpc = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;

                goto ResetSecurity;
            }

            if (hr != hrNone)
            {
                return hr;
            }
            //
            //  Now remote the API to the remote machine.
            //

            RpcTryExcept
            {
                hr = HrRRestorePrepare(hBinding, g_wszRestoreAnnotation, &pbcContext->cxh);
            }
            RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
            {
                hr = RpcExceptionCode();

                //
                //  If the client knows about encryption, but the server doesn't,
                //  fall back to unencrypted RPC's.
                //

                if ((hr == RPC_S_UNKNOWN_AUTHN_LEVEL ||
                     hr == RPC_S_UNKNOWN_AUTHN_SERVICE ||
                     hr == RPC_S_UNKNOWN_AUTHN_TYPE ||
                     hr == RPC_S_INVALID_AUTH_IDENTITY) &&
                    alRpc != RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
                {
                    alRpc = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
                    goto ResetSecurity;
                }

                continue;
            }
            RpcEndExcept

            return(hr);
        }

        hr = hrCouldNotConnect;
    }
    __finally
    {
        if (hr != hrNone)
        {
            if (pbcContext != NULL)
            {
                if (pbcContext->hBinding != NULL)
                {
                    RpcBindingFree(&pbcContext->hBinding);
                }

                MIDL_user_free(pbcContext);
            }

            //
            //  Make sure we return null.
            //
            *phbcBackupContext = NULL;
        }
        else
        {
            //
            //  Make sure we return NON null.
            //
            Assert(pbcContext != NULL);
            *phbcBackupContext = (HBC)pbcContext;
        }
    }

    return hr;
}


HRESULT
I_DsRestoreW(
    HBC hbc,    
    WSZ szCheckpointFilePath,
    WSZ szLogPath,
    EDB_RSTMAPW rgrstmap[],
    C crstmap,
    WSZ szBackupLogPath,
    unsigned long genLow,
    unsigned long genHigh,
    BOOLEAN *pfRecoverJetDatabase
    )
{
    HRESULT hr;
    pBackupContext pbcContext = (pBackupContext)hbc;

    if ( (hbc == NULL) ||
         (szCheckpointFilePath == NULL) ||
         (szLogPath == NULL) ||
         (rgrstmap == NULL) ||
         (szBackupLogPath == NULL) ||
         (pfRecoverJetDatabase == NULL) 
        )
    {
        return ERROR_INVALID_PARAMETER;
    }

    RpcTryExcept
        //
        //  Now tell the server side to prepare for a backup.
        //

        hr = HrRRestore(pbcContext->cxh,
                        szCheckpointFilePath,
                        szLogPath,
                        rgrstmap,
                        crstmap,
                        szBackupLogPath,
                        genLow,
                        genHigh,
                        pfRecoverJetDatabase
                        );

        return(hr);
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        //
        //  Return the error from the RPC if it fails.
        //
        return(RpcExceptionCode());
    RpcEndExcept;

    return(hr);

}

/*
 -  DsRestoreGetDatabaseLocations
 -
 *  Purpose:
 *      Retrieves the locations of the databases for the restore target.
 *
 *  Parameters:
 *      hbcRestoreContext - restore context
 *      LPSTR *ppszDatabaseLocationList - Allocated buffer that holds the result of the list.
 *      LPDWORD - the size of the list
 *
 *  Returns:
 *      HRESULT - status of operation.
 *
 *  Note:
 *      This API returns only the fully qualified path of the databases, not the name
 *      of the databases.
 *
 */
HRESULT
DsRestoreGetDatabaseLocationsA(
    IN HBC hbcRestoreContext,
    OUT LPSTR *ppszDatabaseLocationList,
    OUT LPDWORD pcbSize
    )
{
    HRESULT hr;
    WSZ wszDatabaseLocations = NULL;
    CB cbwSize;
    WSZ wszDatabaseLocation;
    CB cbDatabase = 0;
    SZ szDatabaseLocations;
    SZ szDatabase;

    // Parameter checking is done in the xxxW version of the routine

    if ( (ppszDatabaseLocationList == NULL) ||
         (pcbSize == NULL) )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    hr = DsRestoreGetDatabaseLocationsW(hbcRestoreContext, &wszDatabaseLocations,
                                            &cbwSize);

    if (hr != hrNone)
    {
        return(hr);
    }

    wszDatabaseLocation = wszDatabaseLocations;

    while (*wszDatabaseLocation != TEXT('\0'))
    {
        BOOL fUsedDefault;

        cbDatabase += WideCharToMultiByte(CP_ACP, 0, wszDatabaseLocation, -1,
                                          NULL,
                                          0,
                                          "?", &fUsedDefault);
        if (cbDatabase == 0)
        {
            hr = GetLastError();
            DsBackupFree(wszDatabaseLocations);
            return(hr);
        }

        wszDatabaseLocation += wcslen(wszDatabaseLocation)+1;
    }

    //
    //  Account for the final null in the buffer.
    //

    cbDatabase += 1;

    *pcbSize = cbDatabase;

    szDatabaseLocations = MIDL_user_allocate(cbDatabase);

    if (szDatabaseLocations == NULL)
    {
        DsBackupFree(wszDatabaseLocations);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    szDatabase = szDatabaseLocations;

    wszDatabaseLocation = wszDatabaseLocations;

    while (*wszDatabaseLocation != TEXT('\0'))
    {
        CB cbThisDatabase;
        BOOL fUsedDefault;

        //
        //  Copy over the backup file type.
        //
        *szDatabase++ = (char)*wszDatabaseLocation;

        wszDatabaseLocation++;

        cbThisDatabase = WideCharToMultiByte(CP_ACP, 0, wszDatabaseLocation, -1,
                                          szDatabase,
                                          cbDatabase,
                                          "?", &fUsedDefault);
        //
        //  Assume the conversion didn't need to use the defaults.
        //

        Assert (!fUsedDefault);

        if (cbThisDatabase == 0)
        {
            hr = GetLastError();
            DsBackupFree(wszDatabaseLocations);
            DsBackupFree(szDatabaseLocations);
            return(hr);
        }

        wszDatabaseLocation += wcslen(wszDatabaseLocation)+1;
        //
        // PREFIX: PREFIX complains that szDatabase may be uninitialized,
        // however this is impossible at this point.  We checked the return
        // value of WideCharToMultiByte and if it's zero then we return.  
        // The only way that the return value of WideCharToMultiByte could
        // be non-zero and still not initialize szDatabase is if cbDatabase
        // was zero as well.  This is impossible since cbDatabase will be 
        // atleast 1 at this point.
        //
        szDatabase += strlen(szDatabase)+1;
        cbDatabase -= cbThisDatabase;
    }

    //
    //  Double null terminate the string.
    //
    *szDatabase = '\0';

    *ppszDatabaseLocationList = szDatabaseLocations;
    DsBackupFree(wszDatabaseLocations);

    return(hr);

}
HRESULT
DsRestoreGetDatabaseLocationsW(
    IN HBC hbcRestoreContext,
    OUT LPWSTR *ppwszDatabaseLocationList,
    OUT LPDWORD pcbSize
    )
{
    HRESULT hr;
    pBackupContext pbcContext = (pBackupContext)hbcRestoreContext;

    if ( (hbcRestoreContext == NULL) ||
         (ppwszDatabaseLocationList == NULL) ||
         (pcbSize == NULL) )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept
    {
        hr = HrRRestoreGetDatabaseLocations(pbcContext->cxh, (SZ *)ppwszDatabaseLocationList,
                                            pcbSize);
    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
    {
        hr = RpcExceptionCode();
    }
    RpcEndExcept;

    return(hr);
}

HRESULT
DsRestoreRegisterA(
    HBC hbc,    
    LPCSTR szCheckpointFilePath,
    LPCSTR szLogPath,
    EDB_RSTMAPA rgrstmap[],
    C crstmap,
    LPCSTR szBackupLogPath,
    unsigned long genLow,
    unsigned long genHigh
    )
{
    WSZ wszCheckpointFilePath = NULL;
    WSZ wszLogPath = NULL;
    WSZ wszBackupLogPath = NULL;
#ifdef  UNICODE_RSTMAP
    EDB_RSTMAPW *rgrstmapw = NULL;
    I irgrstmapw;
#endif
    HRESULT hr;

    // Parameter checking also done in the xxxW version of the routine

    if (szCheckpointFilePath == NULL ||
        szBackupLogPath == NULL ||
        szLogPath == NULL ||
        rgrstmap == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    try
    {

        if (szCheckpointFilePath != NULL)
        {
            wszCheckpointFilePath = WszFromSz(szCheckpointFilePath);
    
            if (wszCheckpointFilePath == NULL)
            {
                return(GetLastError());
            }
        }

        if (szLogPath != NULL)
        {
            wszLogPath = WszFromSz(szLogPath);
    
            if (wszLogPath == NULL)
            {
                return(GetLastError());
            }
        }

        if (szBackupLogPath != NULL)
        {
            wszBackupLogPath = WszFromSz(szBackupLogPath);
    
            if (wszBackupLogPath == NULL)
            {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
        }

        rgrstmapw = MIDL_user_allocate(sizeof(EDB_RSTMAPW)*crstmap);        

        if (rgrstmapw == NULL)
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // This is to make sure that no matter how we get into the finally clause
        // below that the checks for NULL will be valid.
        //
        memset(rgrstmapw, 0, sizeof(EDB_RSTMAPW)*crstmap);
        
        for (irgrstmapw = 0 ; irgrstmapw < crstmap ; irgrstmapw += 1)
        {
            if (rgrstmap[irgrstmapw].szDatabaseName == NULL ||
                rgrstmap[irgrstmapw].szNewDatabaseName == NULL)
            {
                return ERROR_INVALID_PARAMETER;
            }

            rgrstmapw[irgrstmapw].wszDatabaseName = WszFromSz(rgrstmap[irgrstmapw].szDatabaseName);

            if (rgrstmapw[irgrstmapw].wszDatabaseName == NULL)
            {
                return(GetLastError());
            }

            rgrstmapw[irgrstmapw].wszNewDatabaseName = WszFromSz(rgrstmap[irgrstmapw].szNewDatabaseName);

            if (rgrstmapw[irgrstmapw].wszNewDatabaseName == NULL)
            {
                return(GetLastError());
            }
        }

        hr = DsRestoreRegisterW(hbc, wszCheckpointFilePath, wszLogPath,
                                rgrstmapw,
                                crstmap, wszBackupLogPath, genLow, genHigh);

    }
    finally
    {
        if (rgrstmapw != NULL)
        {
            I irgrstmapw;

            for (irgrstmapw = 0 ; irgrstmapw < crstmap ; irgrstmapw += 1)
            {
                if (rgrstmapw[irgrstmapw].wszDatabaseName != NULL)
                {
                    MIDL_user_free(rgrstmapw[irgrstmapw].wszDatabaseName);
                }
                if (rgrstmapw[irgrstmapw].wszNewDatabaseName != NULL)
                {
                    MIDL_user_free(rgrstmapw[irgrstmapw].wszNewDatabaseName);
                }
            }

            MIDL_user_free(rgrstmapw);
        }

        if (wszBackupLogPath != NULL)
        {
            MIDL_user_free(wszBackupLogPath);
        }
        if (wszLogPath != NULL)
        {
            MIDL_user_free(wszLogPath);
        }
        if (wszCheckpointFilePath != NULL)
        {
            MIDL_user_free(wszCheckpointFilePath);
        }
    }

    return(hr);
}


HRESULT
DsRestoreCheckExpiryToken(
    PVOID pvExpiryToken,
    DWORD cbExpiryTokenSize
    )

/*++

Routine Description:

Check an expiry token to see if it has expired.

Arguments:

    pvExpiryToken - Expiry token as returned by DsBackupPrepare
    cbExpiryTokenSize - size of token

Return Value:

    HRESULT - 
    hrNone
    hrMissingExpiryToken
    hrUnknownExpiryTokenFormat
    hrContentsExpired

--*/

{
    EXPIRY_TOKEN *pToken = NULL;
    LONGLONG dsCurrentTime;
    DWORD dwDaysElapsedSinceBackup;
    HRESULT hrResult = hrNone;

    if (!pvExpiryToken || !cbExpiryTokenSize) {
        // These are required. We should fail the API, if the restore
        // doesn't pass the expiry token
        //
        return hrMissingExpiryToken;
    }

    if (cbExpiryTokenSize != sizeof(EXPIRY_TOKEN))
    {
        return hrUnknownExpiryTokenFormat;
    }           

    // Copy the token to its own aligned buffer
    pToken = (EXPIRY_TOKEN *) MIDL_user_allocate( cbExpiryTokenSize );
    if (!pToken) {
        return hrOutOfMemory;
    }
    memcpy( pToken, pvExpiryToken, cbExpiryTokenSize );

    __try {
        // Check that the expiry token is correct
        if (1 != pToken->dwVersion)
        {
            hrResult = hrUnknownExpiryTokenFormat;
            __leave;
        }           
            
        // check to see if the copy has expired or not
        dsCurrentTime = GetSecsSince1601();

        dwDaysElapsedSinceBackup = (DWORD) ((dsCurrentTime - pToken->dsBackupTime) / (24 * 3600));

        if (dwDaysElapsedSinceBackup >= pToken->dwTombstoneLifeTimeInDays)
        {
            hrResult = hrContentsExpired;
            __leave;
        }            

        hrResult = hrNone;
    } __finally {
        MIDL_user_free( pToken );
    }

    return hrResult;
} /* DsCheckExpiryToken */

HRESULT
DsRestoreRegisterW(
    HBC hbc,    
    LPCWSTR szCheckpointFilePath,
    LPCWSTR szLogPath,
    EDB_RSTMAPW rgrstmap[],
    C crstmap,
    LPCWSTR szBackupLogPath,
    unsigned long genLow,
    unsigned long genHigh
    )
{
    HRESULT hr;
    pBackupContext pbcContext = (pBackupContext)hbc;
    I irgrstmapw;

    // hbc is allowed to be null
    if ( (szCheckpointFilePath == NULL) ||
         (szLogPath == NULL) ||
         (rgrstmap == NULL) ||
         (szBackupLogPath == NULL)
        ) {
        return ERROR_INVALID_PARAMETER;
    }

    for (irgrstmapw = 0 ; irgrstmapw < crstmap ; irgrstmapw += 1)
    {
        if (rgrstmap[irgrstmapw].wszDatabaseName == NULL ||
            rgrstmap[irgrstmapw].wszNewDatabaseName == NULL)
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    RpcTryExcept

    // Use the presence of the context to determine if we go remote
    if (hbc) {

        //
        // Perform the operation remotely
        //

        // Check that an expiry token was supplied and checked

        if (!pbcContext->fExpiryTokenChecked) {
            return hrMissingExpiryToken;
        }

        //
        //  Now tell the server side to prepare for a backup.
        //

        hr = HrRRestoreRegister(pbcContext->cxh,
                        (WSZ) szCheckpointFilePath,
                        (szLogPath ? (WSZ) szLogPath : (WSZ) szCheckpointFilePath),
                        rgrstmap,
                        crstmap,
                        (szBackupLogPath ? (WSZ) szBackupLogPath : (WSZ) szCheckpointFilePath),
                        genLow,
                        genHigh
                        );

    } else {

        //
        // Perform the operation locally
        //

        hr = HrLocalRestoreRegister(
                        (WSZ) szCheckpointFilePath,
                        (szLogPath ? (WSZ) szLogPath : (WSZ) szCheckpointFilePath),
                        rgrstmap,
                        crstmap,
                        (szBackupLogPath ? (WSZ) szBackupLogPath : (WSZ) szCheckpointFilePath),
                        genLow,
                        genHigh
                        );


    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        //
        //  Return the error from the RPC if it fails.
        //
        return(RpcExceptionCode());
    RpcEndExcept;

    return(hr);

}

HRESULT
DsRestoreRegisterComplete(
    HBC hbc,    
    HRESULT hrRestore
    )
{
    HRESULT hr;
    pBackupContext pbcContext = (pBackupContext)hbc;

    // Parameter checking: hbc allowed to be null

    RpcTryExcept
    // Use the presence of the context to determine if we go remote
    if (hbc) {
        //
        //  Now tell the server side to prepare for a backup.
        //

        hr = HrRRestoreRegisterComplete(pbcContext->cxh,
                        hrRestore
                        );
    } else {
        //
        // Perform the operation locally
        //

        hr = HrLocalRestoreRegisterComplete(
                        hrRestore
                        );
    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        //
        //  Return the error from the RPC if it fails.
        //
        return(RpcExceptionCode());
    RpcEndExcept;

    return(hr);

}

HRESULT
DsRestoreEnd(
    HBC hbcBackupContext
    )
{
    HRESULT hr = hrNone;
    pBackupContext pbcContext = (pBackupContext)hbcBackupContext;

    if (hbcBackupContext == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (pbcContext->hBinding != NULL)
    {
        RpcTryExcept
            //
            //  Now tell the server side to prepare for a backup.
            //

            hr = HrRRestoreEnd(&pbcContext->cxh);

            //
            //  We're done with the RPC binding now.
            //
            RpcBindingFree(&pbcContext->hBinding);
        RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
            //
            //  Return the error from the RPC if it fails.
            //
            return(RpcExceptionCode());
        RpcEndExcept;
    }

    MIDL_user_free(pbcContext);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kccbridge.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccbridge.cxx

ABSTRACT:

    KCC_BRIDGE class.

DETAILS:

    This class represents the DS notion of bridges.

CREATED:

    03/12/97    Jeff Parham (jeffparh)

REVISION HISTORY:

    06/21/00    Will Lees (wlees)

--*/

#include <ntdspchx.h>
#include "kcc.hxx"
#include "kccdynar.hxx"
#include "kccsite.hxx"
#include "kccbridge.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include "kccdsa.hxx"
#include "kcctrans.hxx"
#include "kccconn.hxx"
#include "kccsconn.hxx"
#include "dsconfig.h"
#include "dsutil.h"

#define FILENO FILENO_KCC_KCCBRIDGE


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_BRIDGE methods
//

void
KCC_BRIDGE::Reset()
//
// Set member variables to their pre-Init() state.
//
{
    m_fIsInitialized        = FALSE;
    m_pdnBridgeObject     = NULL;
    m_SiteLinkArray.RemoveAll();
}

BOOL
KCC_BRIDGE::Init(
    IN KCC_TRANSPORT *pTransport,
    IN  ENTINF *    pEntInf
    )
// Init the object given its ds properties
// Note, do not store any pointers to the memory in the pEntInf.
// It will be deallocated shortly.
{

    DWORD   iAttr, cAttr, iAttrVal;
    ATTR *  pAttr;
    DWORD   cbVal;
    BYTE *  pbVal;

    Reset();

    m_pdnBridgeObject = (DSNAME *) new BYTE [pEntInf->pName->structLen];
    memcpy( m_pdnBridgeObject, pEntInf->pName, pEntInf->pName->structLen );

    for ( iAttr = 0, cAttr = pEntInf->AttrBlock.attrCount; 
            iAttr < cAttr; 
                iAttr++ )
    {
        pAttr = &pEntInf->AttrBlock.pAttr[ iAttr ];
        cbVal = pAttr->AttrVal.pAVal->valLen;
        pbVal = pAttr->AttrVal.pAVal->pVal;

        Assert( pAttr->attrTyp == ATT_SITE_LINK_LIST || 1 == pAttr->AttrVal.valCount ); // all should be single-valued
        Assert( pbVal );

        switch ( pAttr->attrTyp )
        {
        case ATT_SITE_LINK_LIST:
            for ( iAttrVal = 0; iAttrVal < pAttr->AttrVal.valCount; iAttrVal++ )
            {
                DSNAME *pdnSiteLink = (DSNAME *) pAttr->AttrVal.pAVal[ iAttrVal ].pVal;
                KCC_SITE_LINK *pSiteLink = pTransport->GetSiteLinkList()->GetSiteLink( pdnSiteLink );
                if (pSiteLink) {
                    m_SiteLinkArray.Add( pSiteLink );
                } else {
                    DPRINT2(0, "Bridge %ls references site link %ls, but not found in site link list.\n",
                            m_pdnBridgeObject->StringName,
                            pdnSiteLink->StringName );
                    LogEvent(DS_EVENT_CAT_KCC,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_KCC_BRIDGE_SITE_LINK_NOT_IN_SITE_LINK_LIST,
                             szInsertDN(m_pdnBridgeObject),
                             szInsertDN(pdnSiteLink),
                             0); 
                    // keep going
                }
            }
            // This does not need to be sorted
            break;

        default:
            DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pAttr->attrTyp );
            break;
        }
    }

    if (m_SiteLinkArray.GetCount() >= 2) {
        m_fIsInitialized = TRUE;
    } else {
        DPRINT1(0, "Site link bridge %ls does not have enough site links.\n",
                m_pdnBridgeObject->StringName );
        LogEvent(DS_EVENT_CAT_KCC,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_KCC_SITE_LINK_BRIDGE_TOO_SMALL,
                 szInsertDN(m_pdnBridgeObject),
                 0,
                 0); 

        delete [] m_pdnBridgeObject;
        m_pdnBridgeObject = NULL;
    }

    return m_fIsInitialized;
}

BOOL
KCC_BRIDGE::InitForKey(
    IN  DSNAME   *    pdnBridge
    )
//
// Init a KCC_BRIDGE object for use as a key (i.e., solely for comparison use
// by bsearch()).
//
// WARNING: The DSNAME argument pdnSite must be valid for the lifetime of this
// object!
//
{
    Reset();

    m_pdnBridgeObject = pdnBridge;

    m_fIsInitialized = TRUE;

    return TRUE;
}


BOOL
KCC_BRIDGE::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

PDSNAME
KCC_BRIDGE::GetObjectDN()
{
    ASSERT_VALID( this );

    return m_pdnBridgeObject;
}


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_BRIDGE_LIST methods
//

BOOL
KCC_BRIDGE_LIST::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

BOOL
KCC_BRIDGE_LIST::Init(
    IN KCC_TRANSPORT *pTransport
    )
{

    ATTR      rgAttrs[] =
    {
        { ATT_SITE_LINK_LIST, { 0, NULL } }
    };

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    // Find all the site objects.
    DSNAME * pdnBridgeCat = DsGetDefaultObjCategory(CLASS_SITE_LINK_BRIDGE);

    ULONG               dirError;
    FILTER              filtObjCat;
    SEARCHRES *         pResults;
    ENTINFLIST *        pEntInfList;

    // Clear the member variables
    Reset();

    Assert(NULL != pdnBridgeCat);

    // Set up the search filter
    memset( &filtObjCat, 0, sizeof( filtObjCat ) );
    filtObjCat.choice                  = FILTER_CHOICE_ITEM;
    filtObjCat.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    filtObjCat.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CATEGORY;
    filtObjCat.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnBridgeCat->structLen;
    filtObjCat.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) pdnBridgeCat;

    dirError = KccSearch(
        pTransport->GetDN(),
        SE_CHOICE_IMMED_CHLDRN,
        &filtObjCat,
        &Sel,
        &pResults
        );

    if ( 0 != dirError )
    {
        KCC_LOG_SEARCH_FAILURE( pTransport->GetDN(), dirError );

        return FALSE;
    }
    else
    {
        if ( 0 == pResults->count )
        {
           DPRINT1( 1, "No bridge objects found for transport %ls.\n",
               pTransport->GetDN() );
        }
        else
        {
            for ( pEntInfList = &pResults->FirstEntInf;
                  NULL != pEntInfList;
                  pEntInfList = pEntInfList->pNextEntInf
                )
            {
                KCC_BRIDGE * pBridge = new KCC_BRIDGE;

                if ( pBridge->Init( pTransport, &pEntInfList->Entinf ) )
                {
                    m_BridgeArray.Add( pBridge );
                } else {
                    delete pBridge;
                    // Error already logged
                    // Keep going
                }
            }
        }

        DirFreeSearchRes( pResults );

        // Bridge array does not need to be sorted

        m_fIsInitialized = TRUE;
    }

    return m_fIsInitialized;
}

ULONG
KCC_BRIDGE_LIST::GetCount()
//
// Get the number of site.
//
{
    return m_BridgeArray.GetCount();
}

KCC_BRIDGE *
KCC_BRIDGE_LIST::GetBridge(
        IN  DWORD   iBridge
        )
//
// Get the site requested
//
{
    ASSERT_VALID( this );

    return m_BridgeArray[iBridge];
}

KCC_BRIDGE *
KCC_BRIDGE_LIST::GetBridge(
    IN  DSNAME *  pdnBridge
    )
//
// Retrieve the KCC_BRIDGE object with the given DSNAME.
//
{
    ASSERT_VALID(this);

    return m_BridgeArray.Find( pdnBridge );
}

void
KCC_BRIDGE_LIST::Reset()
//
// Set member variables to their pre-Init() state.
//
{
    m_fIsInitialized = FALSE;
    m_BridgeArray.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kcccref.cxx ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcccref.cxx

ABSTRACT:

    KCC_CROSSREF and KCC_CROSSREF_LIST classes.

DETAILS:

    These classes represent a single Cross-Ref DS object and a collection
    thereof, resp.

    Cross-Ref DS objects are found in the CN=Partitions,CN=Configuration,...
    container.  They represent partitions of the DS namespace (NCs) in the
    enterprise, be they hosted by NT DS or by a foreign DS.

CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include "kcc.hxx"
#include "kcccref.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"

#define FILENO FILENO_KCC_KCCCREF

void
KCC_CROSSREF::Reset()
//
// Reset member variables to their pre-Init() state.
//
{
    m_pdnNC              = NULL;
    m_fIsReplicatedToGCs = FALSE;
    m_NCType             = KCC_NC_TYPE_INVALID;
    m_crCategory         = KCC_CR_CAT_INVALID;
    m_pLinkList          = NULL;
    m_fSiteArraysInited  = FALSE;

    m_NCReplicaLocationsArray.RemoveAll();
}

BOOL
KCC_CROSSREF::IsValid()
//
// Is this object internally consistent?
//
{
    return (NULL != m_pdnNC)
           && (KCC_NC_TYPE_INVALID != m_NCType)
           && m_NCReplicaLocationsArray.IsValid();
}

BOOL
KCC_CROSSREF::IsDSAPresentInNCReplicaLocations(
    IN  KCC_DSA *   pDSA
    )
//
// Is the given DSA a value for the NC-Replica-Locations attribute of this
// cross-ref object?
//
{
    Assert(KCC_NC_TYPE_NONDOMAIN == m_NCType);
    return m_NCReplicaLocationsArray.IsElementOf(pDSA->GetDsName());
}

BOOL
KCC_CROSSREF::Init(
    IN  ENTINF *    pEntInf
    )
//
// Initialize the internal object from an ENTINF describing a corresponding
// Cross-Ref DS object.
//
{
    DWORD   iAttr;
    ATTR *  pAttr;
    BOOL    fSuccess = FALSE;
    DWORD   dwSystemFlags = 0;

    Reset();

    DPRINT1(5, "Parsing cross-ref %ls.\n", pEntInf->pName->StringName );

    for (iAttr = 0; iAttr < pEntInf->AttrBlock.attrCount; iAttr++) {
        pAttr = &pEntInf->AttrBlock.pAttr[ iAttr ];

        switch (pAttr->attrTyp) {
        case ATT_NC_NAME:
            Assert(1 == pAttr->AttrVal.valCount);
            m_pdnNC = (DSNAME *) pAttr->AttrVal.pAVal->pVal;
            break;

        case ATT_SYSTEM_FLAGS:
            Assert(1 == pAttr->AttrVal.valCount);
            dwSystemFlags = *((DWORD *) pAttr->AttrVal.pAVal->pVal);
            break;

        case ATT_MS_DS_NC_REPLICA_LOCATIONS:
            for (DWORD iValue = 0; iValue < pAttr->AttrVal.valCount; iValue++) {
                DSNAME * pDN = (DSNAME *) pAttr->AttrVal.pAVal[iValue].pVal;
                m_NCReplicaLocationsArray.Add(pDN);
            }
            break;
        
        default:
            DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pAttr->attrTyp );
            break;
        }
    }

    // NC-Name is a System-Must-Have on Cross-Ref objects.
    Assert(NULL != m_pdnNC);

    if (!(dwSystemFlags & FLAG_CR_NTDS_NC)) {
        // This partition lives e.g. on a Netscape, NDS, or other-forest NT5
        // server.
        DPRINT1(3, "Ignoring crossRef for NC %ls not hosted by our forest.\n",
                m_pdnNC->StringName);
    }
    else if (fNullUuid(&m_pdnNC->Guid)) {
        // This can occur for crossRefs for a new domain at the root of a new
        // tree in our forest.  Lack of a guid indicates that replication of
        // the guid in the config NC (which happens after DCPROMO, when pre-
        // existing DCs replicate the config NC from the newly installed DC)
        // has not yet occurred.
        DPRINT1(0, "Ignoring cross-ref for NC %ls because the NC has no guid.\n",
                m_pdnNC->StringName);
        LogEvent(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_MINIMAL,
            DIRLOG_KCC_NC_HEAD_NOT_FOUND,
            szInsertDN(m_pdnNC),
            NULL, 
            NULL
            );
    }
    else {
        // Cross-ref is viable for topology generation.
        
        if (dwSystemFlags & FLAG_CR_NTDS_DOMAIN) {
            m_NCType = KCC_NC_TYPE_DOMAIN;
        } else if (KccIsSchemaNc(m_pdnNC)) {
            m_NCType = KCC_NC_TYPE_SCHEMA;
        } else if (KccIsConfigurationNc(m_pdnNC)) {
            m_NCType = KCC_NC_TYPE_CONFIG;
        } else {
            m_NCType = KCC_NC_TYPE_NONDOMAIN;
        }

        if (KCC_NC_TYPE_NONDOMAIN == m_NCType) {
            // Is a cross-ref for a native non-(domain|config|schema) NC.
            m_NCReplicaLocationsArray.Sort();
        } else {
            // This is not a cross-ref for a non-domain NC -- ignore any values
            // for NC-Replica-Locations.
            m_NCReplicaLocationsArray.RemoveAll();
        }

        m_fIsReplicatedToGCs = !(m_NCType & FLAG_CR_NTDS_NOT_GC_REPLICATED);
        
        fSuccess = TRUE;
    }

    return fSuccess;
}

VOID
KCC_CROSSREF::InitSiteArrays()
//
// Create two arrays: m_writeableSites and m_partialSites.
// The former contains pointers to sites which host a writeable copy of
// this NC. The latter contains pointers to sites which only have a
// partial copy of this NC.
//
{
    KCC_SITE_LIST*  pSiteList = gpDSCache->GetSiteList();
    DWORD           isite, csite;

    ASSERT_VALID(this);
    if( m_fSiteArraysInited ) {
        // Already initialized -- no work to do here.
        return;
    }

    // Site arrays have not been inited yet -- must be empty.
    Assert( m_writeableSites.GetCount()==0 );
    Assert( m_partialSites.GetCount()==0 );

    ASSERT_VALID( pSiteList );
    csite = pSiteList->GetCount();

    for( isite=0; isite<csite; isite++ ) {
        KCC_SITE *      psite = pSiteList->GetSite(isite);
        BOOL            fIsLocal = (psite == gpDSCache->GetLocalSite());
        KCC_DSA_LIST *  pDsaList = psite->GetDsaList();
        DWORD           idsa, cdsa = pDsaList->GetCount();
        BOOL            fPartialExists=FALSE, fWriteableExists=FALSE;

        ASSERT_VALID(psite);
        ASSERT_VALID(pDsaList);

        for( idsa=0; idsa<cdsa; idsa++ ) {
            BOOL      fIsMaster;
            KCC_DSA * pdsa = pDsaList->GetDsa( idsa );

            ASSERT_VALID(pdsa);
            if (pdsa->IsNCHost(this, fIsLocal, &fIsMaster)) {
                if (fIsMaster) {
                    // This site contains a ds with a writable copy of 
                    // this naming context
                    m_writeableSites.Add( psite );
                    fWriteableExists = TRUE;
                    break;
                } else {
                    // This NC is instantiated as a partial replica on this DSA
                    // Remember this as we need this info there are no writeable
                    // copies of the NC in the site
                    fPartialExists = TRUE;
                }
            }
        } // end iteration over DSAs in the site

        if (!fWriteableExists && fPartialExists) {
            // There are no writeable replicas of this NC in this site,
            // but a partial replica exists - candidate for GC inter-site topology
            m_partialSites.Add( psite );
        }
    } // end iteration over the sites 

    m_fSiteArraysInited = TRUE;
}


VOID
KCC_CROSSREF::CheckForOrphans()
//
// Log an event if the NC is either:
//  - hosted only at this site, but has not been instantiated here yet.
//  - partial at this site, but no writeable copies exist.
//
{
    KCC_SITE           *pLocalSite = gpDSCache->GetLocalSite();
    KCC_DSA_LIST       *pDsaList = pLocalSite->GetDsaList();
    KCC_NC_COMING_TYPE  isComing;
    BOOL                fInstantiated=FALSE;
    DWORD               idsa, cdsa;

    ASSERT_VALID(this);
    ASSERT_VALID(pDsaList);
    InitSiteArrays();

    if (   (   m_writeableSites.GetCount()==1
            && m_writeableSites.IsElementOf(pLocalSite) )
        || (   m_partialSites.GetCount()==1
            && m_writeableSites.GetCount()==0                    
            && m_partialSites.IsElementOf(pLocalSite) ) )
    {
        // Examine all DSAs in the local site to see if NC has
        // been instantiated somewhere.
        cdsa = pDsaList->GetCount();
        for( idsa=0; idsa<cdsa; idsa++ ) {
            KCC_DSA * pdsa = pDsaList->GetDsa( idsa );
            ASSERT_VALID(pdsa);
            
            if(   pdsa->IsNCInstantiated(GetNCDN(), NULL, &isComing)
               && KCC_NC_IS_COMING!=isComing )
            {
                // If the NC is instantiated, and we do not have any
                // evidence that it is still in the 'coming' stage, we
                // accept the fact that the NC is instantiated.
                fInstantiated=TRUE;
                break;
            }
        }

        if( ! fInstantiated ) {
            DPRINT1(0, "NC %ws is not instantiated at local site, but not "
                    "hosted in any other sites either!\n",
                    GetNCDN()->StringName);
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_KCC_NC_NOT_INSTANTIATED_ANYWHERE,
                szInsertDN(GetNCDN()),
                szInsertDN(pLocalSite->GetObjectDN()),                        
                NULL
                ); 
        }           
    }

    // Check if we have a partial replica but no writeable replicas exist.
    if(   (m_partialSites.GetCount() > 0)
       && (m_partialSites.IsElementOf(pLocalSite))
       && (m_writeableSites.GetCount()==0) )
    {
        DPRINT1(0, "A partial replica of NC %ws is hosted at the local "
                "site, but no writeable sources exist.\n",
                GetNCDN()->StringName);
        LogEvent(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_KCC_NO_WRITEABLE_SOURCE_FOR_GC_TOPOLOGY,
            szInsertDN(GetNCDN()),
            szInsertDN(pLocalSite->GetObjectDN()),                        
            NULL
            ); 
    }
}

    
KCC_CR_CATEGORY
KCC_CROSSREF::GetCategory()
/*++

Routine Description:

    This function examines a crossref-and-sitearrays entry and returns
    the crossref's category.
    
Returns:

    1 - Domain Crossrefs which are writeable at the local site
    2 - NDNC Crossrefs which are writeable at the local site
    3 - Domain Crossrefs which are readonly at the local site
    4 - Crossrefs which are not hosted at the local site
    5 - Schema
    6 - Config
    
--*/
{
    KCC_NC_TYPE     ncType;
     
    ASSERT_VALID(this);

    if( KCC_CR_CAT_INVALID!=m_crCategory ) {
        return m_crCategory;
    }

    ncType = GetNCType();
    
    if (KCC_NC_TYPE_CONFIG == ncType) {

        // Config comes last
        m_crCategory = KCC_CR_CAT_CONFIG;

    } else if (KCC_NC_TYPE_SCHEMA == ncType) {
        
        // Schema is penultimate
        m_crCategory = KCC_CR_CAT_SCHEMA;

    } else {
        KCC_SITE       *pLocalSite = gpDSCache->GetLocalSite();
        BOOL            fWriteableExists=FALSE, fPartialExists=FALSE;

        InitSiteArrays();

        // Determine if this NC is writeable or not in the local site.
        if( m_writeableSites.IsElementOf(pLocalSite) ) {
            fWriteableExists = TRUE;
        }
        if( m_partialSites.IsElementOf(pLocalSite) ) {
            Assert( !fWriteableExists );
            fPartialExists = TRUE;
        }

        if(!fWriteableExists && !fPartialExists) {
    
            // This crossref is not hosted in local site
            m_crCategory = KCC_CR_CAT_UNHOSTED;
    
        } else if(!fWriteableExists) {
            
            // Only a partial copy is hosted in local site.
            Assert(fPartialExists);
            
            m_crCategory = KCC_CR_CAT_PARTIAL_DOMAIN;
    
        } else if(KCC_NC_TYPE_NONDOMAIN == ncType) {
    
            m_crCategory = KCC_CR_CAT_NDNC;

        } else {
            
            // A writeable copy is hosted in local site.
            Assert(!fPartialExists);
            m_crCategory = KCC_CR_CAT_WRITEABLE_DOMAIN;
        
        }
    }
    
    return m_crCategory;
}


void
KCC_CROSSREF::BuildLinkList()
//
// Build a link-list object containing all replication links
// for this NC (cross-ref).
//
{
    // We should only build this list once, so assert if one exists already
    Assert( m_pLinkList==NULL );

    m_pLinkList = new KCC_LINK_LIST;

    if( ! m_pLinkList->Init( this->GetNCDN(), ATT_REPS_FROM ) ) {
        // If we fail to initialize the link list, just delete the list
        delete m_pLinkList;
        m_pLinkList = NULL;
    }
}

void
KCC_CROSSREF_LIST::Reset()
//
// Reset member variables to their pre-Init() state.
//
{
    m_fIsInitialized  = FALSE;
    m_ccref           = 0;
    m_pcref           = NULL;
    // Default to the lowest version we support
    m_dwForestVersion = DS_BEHAVIOR_VERSION_MIN;
}

BOOL
KCC_CROSSREF_LIST::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}


int __cdecl
KCC_CROSSREF_LIST::CompareCrossrefs(
    const void *p1,
    const void *p2
    )
/*++

Routine Description:

    This function takes two crossref objects and compares them.
    We want to sort the crossrefs by (category,GUID). For a definition
    of crossref category, see kcccref.hxx.
    
Returns:

    <0  If p1 should come first
    0   Never (only if there are duplicates)
    >0  If p2 should come first
    
--*/
{
    KCC_CROSSREF    *pcr1, *pcr2;
    int              category1, category2, result;

    pcr1 = (KCC_CROSSREF*) p1;
    pcr2 = (KCC_CROSSREF*) p2;
    ASSERT_VALID(pcr1);
    ASSERT_VALID(pcr2);

    category1 = pcr1->GetCategory();
    category2 = pcr2->GetCategory();

    if( category1 < category2 ) {
        return -1;
    } else if( category1 > category2 ) {
        return 1;
    }

    result = CompareCrossRefIndirectByNCDN(&pcr1,&pcr2);
    if(0==result) {
        Assert(p1==p2 && "Duplicate Crossref Detected!" );
    }

    return result;
}


BOOL
KCC_CROSSREF_LIST::Init()
//
// Initialize the collection from the set of Cross-Ref DS objects
// that are direct children of the CN=Partitions,CN=Configuration,...
// container.
//
{
    ATTR      rgPartAttrs[] =
    {
        { ATT_MS_DS_BEHAVIOR_VERSION,  { 0, NULL } }
    };
    ATTR      rgAttrs[] =
    {
        { ATT_NC_NAME,  { 0, NULL } },
        { ATT_SYSTEM_FLAGS,  { 0, NULL } },
        { ATT_MS_DS_NC_REPLICA_LOCATIONS,  { 0, NULL } },
    };

    ENTINFSEL PartSel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgPartAttrs )/sizeof( rgPartAttrs[ 0 ] ), rgPartAttrs },
        EN_INFOTYPES_TYPES_VALS
    };
    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    DWORD     dwCrossRefClass = CLASS_CROSS_REF;

    ULONG               dirError;
    FILTER              Filter;
    SEARCHRES *         pResults;
    ENTINFLIST *        pEntInfList;
    NTSTATUS            status;
    DWORD               cbName = 0;
    DSNAME *            pdnPartitions = NULL;
    READRES *           pPartResults;
    ATTRBLOCK *         pAttrBlock;

    status = GetConfigurationName(
                        DSCONFIGNAME_PARTITIONS,
                        &cbName,
                        pdnPartitions);
    Assert(STATUS_BUFFER_TOO_SMALL == status);
    pdnPartitions = (DSNAME *) alloca(cbName);
    status = GetConfigurationName(
                        DSCONFIGNAME_PARTITIONS,
                        &cbName,
                        pdnPartitions);
    Assert(STATUS_SUCCESS == status);

    Reset();

    // Read info off of the partitions container
    // It is permissible for this attribute to be absent.
    dirError = KccRead(
        pdnPartitions,
        &PartSel,
        &pPartResults
        );
    if ( 0 == dirError )
    {
        pAttrBlock = &pPartResults->entry.AttrBlock;
        Assert(1 == pAttrBlock->attrCount);
        Assert(ATT_MS_DS_BEHAVIOR_VERSION == pAttrBlock->pAttr->attrTyp);
        Assert(1 == pAttrBlock->pAttr->AttrVal.valCount);
        Assert(pAttrBlock->pAttr->AttrVal.pAVal->valLen == sizeof( m_dwForestVersion ));

        m_dwForestVersion = *((DWORD *) pAttrBlock->pAttr->AttrVal.pAVal->pVal);
    }



    // construct search filter
    memset( &Filter, 0, sizeof( Filter ) );

    Filter.choice               = FILTER_CHOICE_ITEM;
    Filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;

    Filter.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CLASS;
    Filter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof( dwCrossRefClass );
    Filter.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) &dwCrossRefClass;

    dirError = KccSearch(
        pdnPartitions,
        SE_CHOICE_IMMED_CHLDRN,
        &Filter,
        &Sel,
        &pResults
        );

    if ( 0 != dirError )
    {
        KCC_LOG_SEARCH_FAILURE( pdnPartitions, dirError );
    }
    else
    {
        if ( 0 == pResults->count )
        {
            DPRINT( 0, "No cross-ref objects found!\n" );
            KCC_EXCEPT( ERROR_DS_NCNAME_MISSING_CR_REF, 0);
        }
        else
        {
            m_pcref = new KCC_CROSSREF[ pResults->count ];

            m_ccref = 0;
            for ( pEntInfList = &pResults->FirstEntInf;
                  NULL != pEntInfList;
                  pEntInfList = pEntInfList->pNextEntInf
                )
            {
                KCC_CROSSREF * pcref = &(m_pcref)[ m_ccref ];

                if ( pcref->Init( &pEntInfList->Entinf ) )
                {
                    m_ccref++;
                }
            }
        }

        m_fIsInitialized = TRUE;
    }

    return m_fIsInitialized;
}

    
VOID
KCC_CROSSREF_LIST::Sort()
//
// Sort crossrefs by (Category,GUID)
//  
{
    ASSERT_VALID( this );
    qsort( m_pcref, m_ccref, sizeof(KCC_CROSSREF), CompareCrossrefs );
}


KCC_CROSSREF *
KCC_CROSSREF_LIST::GetCrossRefForNC(
    IN  DSNAME *    pdnNC
    )
//
// Retrieve the KCC_CROSSREF object associated with the given NC.
//
{
    KCC_CROSSREF * pcref = NULL;

    ASSERT_VALID( this );

    for ( DWORD icref = 0; icref < m_ccref; icref++ )
    {
        if ( NameMatched( pdnNC, m_pcref[ icref ].GetNCDN() ) )
        {
            pcref = &m_pcref[ icref ];
            break;
        }
    }

    return pcref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kccdsa.cxx ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccdsa.cxx

ABSTRACT:

    KCC_DSA class.

DETAILS:

    This class represents an NTDS-DSA DS object.

    NTDS-DSA DS objects hold DC-specific DS configuration information;
    e.g., which NCs are instantiated on that NC.

CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

    03/37/97    Colin Brace (ColinBr)
        
        Added the notion of a list of dsa objects

--*/

#include <ntdspchx.h>
#include <winsock.h>
#include "kcc.hxx"
#include "kcctools.hxx"
#include "kcctrans.hxx"
#include "kccdsa.hxx"
#include "kccduapi.hxx"
#include "kccsite.hxx"
#include "ismapi.h"
#include "kccconn.hxx"
#include "kccsconn.hxx"
#include "kccdynar.hxx"

#define FILENO FILENO_KCC_KCCDSA


// List of interesting attributes on DSA objects.
static ATTR AttrList[] = {
    { ATT_OBJ_DIST_NAME,              { 0, NULL } },
    { ATT_HAS_MASTER_NCS,             { 0, NULL } },
    { ATT_HAS_PARTIAL_REPLICA_NCS,    { 0, NULL } },
    { ATT_OPTIONS,                    { 0, NULL } },
    { ATT_MS_DS_BEHAVIOR_VERSION,     { 0, NULL } },
    { ATT_MS_DS_HAS_INSTANTIATED_NCS, { 0, NULL } },
    { ATT_INVOCATION_ID,              { 0, NULL } }
};


void
KCC_DSA::Reset()
//
// Set member variables to their pre-Init() state.
//
{
    m_fIsInitialized     = FALSE;
    m_pdnDSA             = NULL;
    m_cMasterNCs         = 0;
    m_ppdnMasterNCs      = NULL;
    m_cFullReplicaNCs    = 0;
    m_ppdnFullReplicaNCs = NULL;
    m_cInstantiatedNCs   = 0;
    m_pInstantiatedNCs   = NULL;
    m_pmtxRpcAddress     = NULL;
    m_pszRpcAddress      = NULL;
    m_dwOptions          = 0;
    m_pdnSite            = NULL;
    m_cNumAddrs          = 0;
    m_pAddrs             = NULL;
    m_fAddrsRead         = FALSE;
    m_pIntraSiteCnList   = NULL;
    m_pInterSiteCnList   = NULL;
    m_dwBehaviorVersion  = 0;
    memset(&m_invocationId, 0, sizeof(UUID));
}

BOOL
KCC_DSA::InitDsa(
    IN  ATTRBLOCK*    pAttrBlock,
    IN  DSNAME *      pdnSite
    )
// Initialize the internal object from the ds information 
// passed in.
//
// Caller can dispense of 'pdnSite' when call completes.
{
    Reset();

    for ( DWORD iAttr = 0; iAttr < pAttrBlock->attrCount; iAttr++ )
    {
        ATTR *  pattr = &pAttrBlock->pAttr[ iAttr ];
        DWORD   iAttrVal;

        switch ( pattr->attrTyp )
        {
        case ATT_HAS_MASTER_NCS:
            m_ppdnMasterNCs = new DSNAME* [ pattr->AttrVal.valCount ];
            m_cMasterNCs = pattr->AttrVal.valCount;
            for ( iAttrVal = 0; iAttrVal < m_cMasterNCs; iAttrVal++ )
            {
                DSNAME *pdn = (DSNAME *) pattr->AttrVal.pAVal[ iAttrVal ].pVal;
                m_ppdnMasterNCs[ iAttrVal ] = (DSNAME *) new BYTE [pdn->structLen];
                memcpy( m_ppdnMasterNCs[ iAttrVal ], pdn, pdn->structLen );
            }
            break;

        case ATT_HAS_PARTIAL_REPLICA_NCS:
            m_ppdnFullReplicaNCs = new DSNAME* [ pattr->AttrVal.valCount ];
            m_cFullReplicaNCs = pattr->AttrVal.valCount;
            for ( iAttrVal = 0; iAttrVal < m_cFullReplicaNCs; iAttrVal++ )
            {
                DSNAME *pdn = (DSNAME *) pattr->AttrVal.pAVal[ iAttrVal ].pVal;
                m_ppdnFullReplicaNCs[ iAttrVal ] = (DSNAME *) new BYTE [pdn->structLen];
                memcpy( m_ppdnFullReplicaNCs[ iAttrVal ], pdn, pdn->structLen );
            }
            break;

        case ATT_MS_DS_HAS_INSTANTIATED_NCS:
            m_pInstantiatedNCs = new DN_AND_INSTANCETYPE[ pattr->AttrVal.valCount ];
            m_cInstantiatedNCs = pattr->AttrVal.valCount;
            for ( iAttrVal = 0; iAttrVal < m_cInstantiatedNCs; iAttrVal++ )
            {
                SYNTAX_DISTNAME_BINARY *pdnb;
                DSNAME *pdn;
                SYNTAX_ADDRESS *psa;
                DWORD  dwTemp, dwIT;

                pdnb = (SYNTAX_DISTNAME_BINARY *) pattr->AttrVal.pAVal[ iAttrVal ].pVal;

                // Retrieve the dsname part.
                pdn = NAMEPTR(pdnb);
                m_pInstantiatedNCs[ iAttrVal ].dn = (DSNAME *) new BYTE [pdn->structLen];
                memcpy( m_pInstantiatedNCs[ iAttrVal ].dn, pdn, pdn->structLen );

                // Extract the binary blob part                
                psa = DATAPTR(pdnb);
                
                // First check that the length of the blob is what we expect.
                Assert(psa->structLen>=2*sizeof(DWORD)); // Length + Data DWORD
                if( psa->structLen<2*sizeof(DWORD) ) {
                    KCC_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
                }
                
                // Copy the data to a temp variable to avoid alignment problems,
                // then convert to 'host' byte-ordering.
                memcpy(&dwTemp, &psa->byteVal[0], sizeof(DWORD));
                dwIT = (DWORD) ntohl(dwTemp);

                m_pInstantiatedNCs[ iAttrVal ].instanceType = dwIT;
            }
            break;

        case ATT_OPTIONS:
            Assert( 1 == pattr->AttrVal.valCount );
            Assert( sizeof( DWORD ) == pattr->AttrVal.pAVal->valLen );
            m_dwOptions = *( (DWORD *) pattr->AttrVal.pAVal->pVal );
            break;

        case ATT_OBJ_DIST_NAME:
        {
            DSNAME *pdnFrom = (DSNAME *) pattr->AttrVal.pAVal->pVal;
            Assert(1 == pattr->AttrVal.valCount);
            m_pdnDSA = (DSNAME *) new BYTE [pdnFrom->structLen];
            memcpy( m_pdnDSA, pdnFrom, pdnFrom->structLen );
            break;
        }
        case ATT_MS_DS_BEHAVIOR_VERSION:
            Assert(1 == pattr->AttrVal.valCount);
            Assert(sizeof(DWORD) == pattr->AttrVal.pAVal->valLen);
            m_dwBehaviorVersion = *((DWORD *) pattr->AttrVal.pAVal->pVal);
            break;

        case ATT_INVOCATION_ID:
            Assert(1 == pattr->AttrVal.valCount);
            Assert(sizeof(UUID) == pattr->AttrVal.pAVal->valLen);
            memcpy(&m_invocationId, pattr->AttrVal.pAVal->pVal, sizeof(UUID));
            break;

        default:
            DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp );
            break;
        }
    }

    Assert(NULL != m_pdnDSA);
    Assert(!fNullUuid(&m_invocationId));

    if (pdnSite) {
        Assert(NULL != pdnSite);
        Assert(!fNullUuid(&pdnSite->Guid));
        m_pdnSite = (DSNAME *) new BYTE [pdnSite->structLen];
    } else {
        m_pdnSite = GetSiteDNSyntacticNoGuid( m_pdnDSA );

        // Guid-less name lookup is ok here
        KCC_SITE *pSite = gpDSCache->GetUnpopulatedSiteList()->GetSite( m_pdnSite );
        if( NULL==pSite ) {
            m_fIsInitialized=FALSE;
            return FALSE;
        }
        pdnSite = pSite->GetObjectDN();
    }
    memcpy( m_pdnSite, pdnSite, pdnSite->structLen );

    Assert(NULL != m_pdnSite);
    Assert(!fNullUuid(&m_pdnSite->Guid));

    m_fIsInitialized = TRUE;

    return m_fIsInitialized;
}

DWORD
KCC_DSA::GetNCCount(
    IN  ATTRTYP attidReplicaType
    )
//
// Get the count of NCs with the specified type (ATT_HAS_MASTER_NCS or
// ATT_HAS_PARTIAL_REPLICA_NCS).
//
{
    DWORD   cNCs;

    ASSERT_VALID( this );

    switch ( attidReplicaType )
    {
    case ATT_HAS_MASTER_NCS:
        cNCs = m_cMasterNCs;
        break;

    case ATT_HAS_PARTIAL_REPLICA_NCS:
        cNCs = m_cFullReplicaNCs;
        break;

    default:
        Assert( !"Invalid parameter passed to KCC_DSA::GetNCCount()" );
        cNCs = 0;
        break;
    }

    return cNCs;
}

DSNAME *
KCC_DSA::GetNC(
    IN  DWORD   iNC,
    OUT BOOL *  pfIsMaster
    )
//
// Get the instantiated NC at the given index (regardless of type).
//
{
    DSNAME *    pdnNC=NULL;

    ASSERT_VALID( this );

    if ( iNC < m_cMasterNCs )
    {
        pdnNC = m_ppdnMasterNCs[ iNC ];
        Assert( NULL != pdnNC );

        if ( NULL != pfIsMaster )
        {
            *pfIsMaster = TRUE;
        }
    }
    else if ( iNC - m_cMasterNCs < m_cFullReplicaNCs )
    {
        pdnNC = m_ppdnFullReplicaNCs[ iNC - m_cMasterNCs ];
        Assert( NULL != pdnNC );

        if ( NULL != pfIsMaster )
        {
            *pfIsMaster = FALSE;
        }
    }
    
    if( NULL==pdnNC )
    {
        KCC_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
    }

    return pdnNC;
}

DSNAME *
KCC_DSA::GetNC(
    IN  ATTRTYP attidReplicaType,
    IN  DWORD   iNC
    )
//
// Get the i'th instantiated NC of the given type (ATT_HAS_MASTER_NCS or
// ATT_HAS_PARTIAL_REPLICA_NCS).
//
{
    DWORD       cNCs;
    DSNAME **   ppdnNCs = NULL;
    DSNAME *    pdnNC;

    ASSERT_VALID( this );

    switch ( attidReplicaType )
    {
    case ATT_HAS_MASTER_NCS:
        cNCs    = m_cMasterNCs;
        ppdnNCs = m_ppdnMasterNCs;
        break;

    case ATT_HAS_PARTIAL_REPLICA_NCS:
        cNCs    = m_cFullReplicaNCs;
        ppdnNCs = m_ppdnFullReplicaNCs;
        break;

    default:
        Assert( !"Invalid parameter passed to KCC_DSA::GetNC()" );
        cNCs = 0;
        break;
    }

    if ( iNC < cNCs )
    {
        pdnNC = ppdnNCs[ iNC ];
        Assert( NULL != pdnNC );
    }
    else
    {
        pdnNC = NULL;
    }

    return pdnNC;
}

BOOL
KCC_DSA::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

MTX_ADDR *
KCC_DSA::GetMtxAddr(
    IN  KCC_TRANSPORT * pTransport
    )
//
// Get the mail or RPC network address of this server.
//
{
    ATTRTYP     att;
    MTX_ADDR *  pmtx = NULL;
    DWORD       iAddr;

    ASSERT_VALID( this );

    if (NULL == pTransport) {
        att = ATT_DNS_HOST_NAME;
    }
    else {
        att = pTransport->GetAddressType();
    }

    if (ATT_DNS_HOST_NAME == att) {
        // Easy -- return the cached DNS name.
        if (NULL == m_pmtxRpcAddress) {
            m_pmtxRpcAddress = GetMtxAddr(&m_pdnDSA->Guid);
        }
        
        pmtx = m_pmtxRpcAddress;
    }
    else {
        if (!m_fAddrsRead) {
            // Transport-specific addrs not yet cached.
            GetTransportSpecificAddrs();
            Assert(m_fAddrsRead);
        }

        for (iAddr = 0; iAddr < m_cNumAddrs; iAddr++) {
            if (att == m_pAddrs[iAddr].attrType) {
                // Found entry for this transport.
                pmtx = m_pAddrs[iAddr].pmtxAddr;
                Assert(NULL != pmtx);
                break;
            }
        }
    }

    return pmtx;
}

MTX_ADDR *
KCC_DSA::GetMtxAddr(
    IN  UUID *  puuidDSA
    )
//
// Get the DNS name of a server with the given UUID.
//
{
    MTX_ADDR * pmtx;

    Assert(NULL != puuidDSA);

    pmtx = MtxAddrFromTransportAddr(GetTransportAddr(puuidDSA));

    // Should fail only if out of memory.
    Assert(NULL != pmtx);
    if (NULL == pmtx) {
        KCC_MEM_EXCEPT(100);
    }

    return pmtx;
}

void
KCC_DSA::GetTransportSpecificAddrs()
//
// Read non-RPC transport-specific address(es) of the server.
//
{
    ULONG                 dirError;
    READRES *             pReadRes = NULL;
    ATTR *                pAttr;
    DWORD                 cNumAttrs;
    DWORD                 iAttr;
    ENTINFSEL             Sel;
    DSNAME *              pdnServer = (DSNAME *) alloca(m_pdnDSA->structLen);
    KCC_TRANSPORT_LIST *  pTransportList = gpDSCache->GetTransportList();
    DWORD                 cNumTransports = pTransportList->GetCount();
    DWORD                 iTransport;
    DWORD                 attrType;
    ATTRBLOCK *           pAttrBlock;

    ASSERT_VALID(this);
    Assert(!m_fAddrsRead);
    Assert(0 == m_cNumAddrs);
    Assert(NULL == m_pAddrs);

    // The server object is the parent of the ntdsDSA object.
    TrimDSNameBy(m_pdnDSA, 1, pdnServer);

    // Construct attribute selection list.  We read all server attributes
    // that are defined as a transport-specific attribute of an intersite
    // transport object, with the exception of ATT_DNS_HOST_NAME, which we
    // derive from the DSA guid.
    Assert(cNumTransports > 0);
    cNumAttrs = cNumTransports - 1;
    pAttr = new ATTR[cNumAttrs];
    
    iAttr = 0;
    for (iTransport = 0; iTransport < cNumTransports; iTransport++) {
        attrType = pTransportList->GetTransport(iTransport)->GetAddressType();
        if (ATT_DNS_HOST_NAME != attrType) {
            // We derive the DNS host name from the DSA guid -- don't need
            // to read the "real" DNS host name attribute.
            pAttr[iAttr].attrTyp = attrType;
            iAttr++;
        }
    }
    Assert(iAttr == cNumAttrs);

    Sel.attSel                 = EN_ATTSET_LIST;
    Sel.AttrTypBlock.attrCount = cNumAttrs;
    Sel.AttrTypBlock.pAttr     = pAttr;
    Sel.infoTypes              = EN_INFOTYPES_TYPES_VALS;

    dirError = KccRead(pdnServer, &Sel, &pReadRes);

    delete [] pAttr;

    if (0 != dirError) {
        if (attributeError == dirError) {
            INTFORMPROB * pprob = &pReadRes->CommRes.pErrInfo->AtrErr.FirstProblem.intprob;

            if ((PR_PROBLEM_NO_ATTRIBUTE_OR_VAL == pprob->problem)
                && (DIRERR_NO_REQUESTED_ATTS_FOUND == pprob->extendedErr)) {
                // No value for this attribute; return NULL.
                dirError = 0;
            }
        }

        if (0 != dirError) {
            // Other error; bail.
            KCC_LOG_READ_FAILURE(pdnServer, dirError);
            KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
        }
    }
    else {
        pAttrBlock = &pReadRes->entry.AttrBlock;
        Assert(pAttrBlock->attrCount <= cNumAttrs);
        
        m_pAddrs = new KCC_DSA_ADDR[pAttrBlock->attrCount];
        
        for (iAttr = 0; iAttr < pAttrBlock->attrCount; iAttr++) {
            WCHAR *     pwchAddress;    // wide, not null-terminated
            DWORD       cwchAddress;    // wide char count, excl null
            DWORD       cachAddress;    // ansi char count, excl null
            LPWSTR      pwszAddress;    // wide, null-terminated
            MTX_ADDR *  pmtxAddress;    // counted UTF8 string

            pAttr = &pAttrBlock->pAttr[iAttr];
            
            pwchAddress = (WCHAR *) pAttr->AttrVal.pAVal[0].pVal;
            cwchAddress = pAttr->AttrVal.pAVal[0].valLen / sizeof(WCHAR);
        
            Assert(0 != cwchAddress);
            // The simulator stores some strings in the directory with the null-terminator
            // Assert(L'\0' != pwchAddress[cwchAddress - 1]); // not already null-terminated

            // Convert transport-specific address (which is assumed to be a
            // Unicode string) to UTF8 (suitable for use as an MTX address).
            cachAddress = WideCharToMultiByte(CP_UTF8, 0L, pwchAddress,
                                              cwchAddress, NULL, 0, NULL, NULL);
    
            pmtxAddress = (MTX_ADDR *) new BYTE[MTX_TSIZE_FROM_LEN(cachAddress)];
            pmtxAddress->mtx_namelen = cachAddress + 1; // includes null-term
            WideCharToMultiByte(CP_UTF8, 0L, pwchAddress, cwchAddress,
                                (CHAR *) &pmtxAddress->mtx_name[0], cachAddress,
                                NULL, NULL);
            pmtxAddress->mtx_name[cachAddress] = '\0';

            // Null-terminate pwchAddress so it can be used as the transport address.
            pwszAddress = (LPWSTR) THReAlloc(pwchAddress,
                                             sizeof(WCHAR) * (1 + cwchAddress));
            if (NULL == pwszAddress) {
                KCC_MEM_EXCEPT(sizeof(WCHAR) * (cwchAddress + 1));
            }
            
            m_pAddrs[m_cNumAddrs].attrType = pAttr->attrTyp;
            m_pAddrs[m_cNumAddrs].pmtxAddr = pmtxAddress;
            m_pAddrs[m_cNumAddrs].pszAddr  = pwszAddress;
            m_cNumAddrs++;
        }
    }

    m_fAddrsRead = TRUE;
}

LPWSTR
KCC_DSA::GetTransportAddr(
    IN  KCC_TRANSPORT * pTransport
    )
//
// Get the mail or RPC network address of this server.
//
{
    ATTRTYP att;
    LPWSTR  pszTransportAddr = NULL;
    DWORD   iAddr;

    ASSERT_VALID( this );

    if (NULL == pTransport) {
        att = ATT_DNS_HOST_NAME;
    }
    else {
        att = pTransport->GetAddressType();
    }

    if (ATT_DNS_HOST_NAME == att) {
        // Easy -- return the cached DNS name.
        if (NULL == m_pszRpcAddress) {
            m_pszRpcAddress = GetTransportAddr(&m_pdnDSA->Guid);
        }
        pszTransportAddr = m_pszRpcAddress;
    }
    else {
        if (!m_fAddrsRead) {
            // Transport-specific addrs not yet cached.
            GetTransportSpecificAddrs();
            Assert(m_fAddrsRead);
        }

        for (iAddr = 0; iAddr < m_cNumAddrs; iAddr++) {
            if (att == m_pAddrs[iAddr].attrType) {
                // Found entry for this transport.
                pszTransportAddr = m_pAddrs[iAddr].pszAddr;
                Assert(NULL != pszTransportAddr);
                break;
            }
        }
    }

    return pszTransportAddr;
}

LPWSTR
KCC_DSA::GetTransportAddr(
    IN  UUID *  puuidDSA
    )
//
// Get the DNS name of a server with the given UUID.
//
{
    LPWSTR      pszTransportAddr;
    DSNAME      DN = {0};

    Assert(NULL != puuidDSA);
    Assert(!fNullUuid(puuidDSA));

    DN.Guid = *puuidDSA;
    DN.structLen = DSNameSizeFromLen(0);

    pszTransportAddr = GuidBasedDNSNameFromDSName(&DN);
    
    // Should fail only if out of memory.
    Assert(NULL != pszTransportAddr);
    if (NULL == pszTransportAddr) {
        KCC_MEM_EXCEPT(100);
    }

    return pszTransportAddr;
}

BOOL
KCC_DSA::IsNCInstantiated(
    IN  DSNAME *                        pdnNC,
    OUT BOOL *                          pfIsMaster OPTIONAL,
    OUT KCC_NC_COMING_TYPE *            pIsComing OPTIONAL
    )
//
// Is the given NC instantiated on this DSA?
//
// If the NC is instantiated and it is a master copy, pfIsMaster is set to
// TRUE. If it is a partial copy, pfIsMaster is set to FALSE. If the NC is
// not instantiated, pfIsMaster is unmodified.
//
// If the 'mS-DS-Has-Instantiated-NCs' attribute is present on this DSA, we
// can determine if the NC is in the process of being removed or being added.
// If the NC is in the process of being removed from this DSA ('going') then the
// NC is considered to be not instantiated at the DSA because it will be gone
// soon.
//
// If the NC is 'going' or is truly not instantiated, 'pIsComing' is set to
// KCC_NC_NOT_INSTANTIATED. If the 'mS-DS-Has-Instantiated-NCs' attribute is there,
// 'pIsComing' will be set to either KCC_NC_IS_COMING or KCC_NC_IS_NOT_COMING.
// If the attribute is not there, then we don't know, so 'pIsComing' is set to
// KCC_NC_MIGHT_BE_COMING.
//
{
    BOOL                    fFoundIt = FALSE, fIsInstantiated, fIsMaster;
    KCC_NC_COMING_TYPE      isComing = KCC_NC_MIGHT_BE_COMING;
    DWORD                   iNC, instanceType;

    ASSERT_VALID( this );

    // The list of instantiated NCs is not guaranteed to be present.
    // However, this list is our preferred method of determining if an NC
    // is instantiated because we can also use it to determine when an NC
    // is in the process of being removed or added.
    for( iNC=0; iNC<m_cInstantiatedNCs; iNC++ ) {
    
        if( !NameMatched(pdnNC, m_pInstantiatedNCs[iNC].dn) ) {
            // Wrong NC. Try the next one
            continue;
        }
        
        instanceType = m_pInstantiatedNCs[iNC].instanceType;    
        if( IT_NC_GOING & instanceType ) {
        
            // 'Going' NCs are immediately considered to be uninstantiated.
            fIsInstantiated = FALSE;

        } else {

            // Determine if the NC is still coming or completely instantiated.
            if( IT_NC_COMING & instanceType ) {
                isComing = KCC_NC_IS_COMING;
            } else {
                isComing = KCC_NC_IS_NOT_COMING;
            }

            fIsInstantiated = TRUE;
            fIsMaster = !! (instanceType & IT_WRITE);
        }
        
        fFoundIt = TRUE;
        break;
    }

    if( !fFoundIt ) {
    
        // Haven't found it yet. Look through the list of master NCs that
        // should be hosted at this DSA.
        for( iNC=0; iNC<m_cMasterNCs; iNC++ ) {       
            if( NameMatched(pdnNC, m_ppdnMasterNCs[iNC]) ) {
                fIsInstantiated = TRUE;
                fIsMaster = TRUE;
                fFoundIt = TRUE;
                break;
            }
        }

    }
    

    if( !fFoundIt ) {
    
        // No luck yet. Look through the list of partial NCs that should
        // be hosted at this DSA.
        for( iNC=0; iNC<m_cFullReplicaNCs; iNC++ ) {            
            if( NameMatched( pdnNC, m_ppdnFullReplicaNCs[iNC]) ) {
                fIsInstantiated = TRUE;
                fIsMaster = FALSE;
                fFoundIt = TRUE;
                break;
            }
        }

    }

    if( !fFoundIt ) {
        // We never found it. The NC must not be instantiated.
        fIsInstantiated = FALSE;    
    }

    // Set optional parameter pfIsComing. If the NC is not instantiated,
    // this parameter is set to KCC_NC_NOT_INSTANTIATED.
    if( NULL!=pIsComing ) {
        if( fIsInstantiated ) {
            *pIsComing = isComing;
        } else {
            *pIsComing = KCC_NC_NOT_INSTANTIATED;
        }
    }

    // Set optional parameter pfIsMaster only if the NC is instantiated.
    if( fIsInstantiated && (NULL!=pfIsMaster) ) {
        *pfIsMaster = fIsMaster;
    }

    return fIsInstantiated;
}


BOOL
KCC_DSA::IsNCHost(
    IN  KCC_CROSSREF *  pCrossRef,
    IN  BOOL            fIsLocal,
    OUT BOOL *          pfIsMaster
    )
//
// Should this DSA be included in the topology for the given NC?
//
{
    // Note that "should this DSA be included in the topology for this NC" is
    // a different question than "is this NC instantiated on this DSA."  An
    // NC may be instantiated on a DSA that should not be included in the
    // topology (e.g., a DC that was recently un-GCed but has not yet
    // completed tearing down its read-only NCs), and an NC may not yet
    // be instantiated on a DSA that should be included in the topology
    // (e.g., a recently promoted GC that has not yet instantiated read-only
    // replicas of other domains' NCs).
    //
    // Ideally for replication sources this routine should return true if and
    // only if the DSA can currently support outbound replication of the NC.
    // We deviate form the ideal for demoted & quickly re-promoted GCs, as
    // based on the contents of the config NC we cannot differentiate between
    // "normal" GCs and those GCs that can't yet support outbound GC replication
    // because they have not yet completely removed the old instantiation of
    // that NC.
    //
    // The NC instantiation requirements for local DSAs are somewhat relaxed
    // compared to those for remote DSAs, where "local" is defined as "is in the
    // same site" for inter-site topologies and "is the local DSA" for
    // intra-site topologies.  This is to allow the KCC to seed the
    // instantiation of local NCs that we allow to be instantiated after DCPROMO
    // -- e.g., so we can replicate in a read-only NC to a local GC to allow the
    // NC to be instantiated.

    BOOL fIsHost = FALSE;
    BOOL fIsMaster = FALSE;
    BOOL fIsInstantiated = IsNCInstantiated(pCrossRef->GetNCDN(), &fIsMaster);
    BOOL fWillBeInstantiated = FALSE;
    BOOL fWillBeMaster = FALSE;

    // Based on the current information in the config NC, does our policy
    // indicate that the DSA should ultimately host a writeable replica of this
    // NC?  (This is somewhat orthogonal to the question of "does this DSA
    // already host a replica of this NC," which we have already determined by
    // calling IsNCInstantiated() above.)

    // NOTE: If you change the logic here you may also need to change the logic
    // in KCC_TASK_UPDATE_REPL_TOPOLOGY::UpdateLinks to correctly infer why we
    // might have an existing replica of an NC but IsNCHost() returns FALSE.
    // (I.e., so we can log an appropriate event.)

    switch (pCrossRef->GetNCType()) {
    case KCC_NC_TYPE_SCHEMA:
    case KCC_NC_TYPE_CONFIG:
    case KCC_NC_TYPE_DOMAIN:
        // All DCs host (and have already instantiated) the config and schema
        // NCs.  DCs in the domain host (and have already instantiated) writable
        // replicas of their domain NC.
        if (fIsInstantiated && fIsMaster) {
            fWillBeInstantiated = fWillBeMaster = TRUE;
        }
        break;

    case KCC_NC_TYPE_NONDOMAIN:
        // Non-domain NC.  Hosted only by those DSAs explicitly enumerated in
        // the NC replica locations attribute of the crossRef.
        if (pCrossRef->IsDSAPresentInNCReplicaLocations(this)) {
            fWillBeInstantiated = fWillBeMaster = TRUE;
        }
        break;
    }

    // If the policy does not indicate the DSA should ultimately hold a
    // writeable replica, how about a read-only replica?
    if (!fWillBeInstantiated
        && IsGC()
        && pCrossRef->IsReplicatedToGCs()) {
        // The DSA should ultimately hold a read-only replica of the NC.
        fWillBeInstantiated = TRUE;
        fWillBeMaster = FALSE;
    }

    if (fIsInstantiated
        && fWillBeInstantiated
        && (!!fIsMaster == !!fWillBeMaster)) {
        // The DSA has already instantiated a replica of this NC of the
        // correct type, as the policy currently dictates it should.
        // It is a viable member of the topology.
        fIsHost = TRUE;
    } else if (fWillBeInstantiated
               && fIsLocal) {
        // This is a local DSA which has not yet had the opportunity to
        // instantiate a replica of the NC, although the policy dictates it
        // should.  Allow it to be added to the topology.
        fIsHost = TRUE;
    }

    // All DSAs host writeable config and schema.
    Assert(((KCC_NC_TYPE_SCHEMA != pCrossRef->GetNCType())
            && (KCC_NC_TYPE_CONFIG != pCrossRef->GetNCType()))
           || (fIsHost && fIsMaster));

    // Although the code above is designed to handle otherwise, currently only
    // domain NCs should ever be read-only replicas.
    Assert(!(fIsHost
             && !fWillBeMaster
             && (KCC_NC_TYPE_DOMAIN != pCrossRef->GetNCType())));

    if (fIsHost) {
        *pfIsMaster = fWillBeMaster;
    }

    return fIsHost;
}


BOOL
KCC_DSA::IsConnectionObjectTranslationDisabled()
//
// Is NTDS-Connection object-to-REPLICA_LINK translation disabled?
//
{
    ASSERT_VALID( this );

    if (gpDSCache->AmRunningUnderAltID()) {
        // Not running as local DSA; do not translate!
        DPRINT(0, "Using alternate identity; connection object translation disabled!\n");
        return TRUE;
    }

    return !!( m_dwOptions & NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE );
}


DSNAME *
KCC_DSA::GetSiteDN()
//
// Retrieve the site name for this DSA.
//
{
    ASSERT_VALID(this);

    Assert(NULL != m_pdnSite);
    Assert(!fNullUuid(&m_pdnSite->Guid));

    return m_pdnSite;
}

DSNAME *
KCC_DSA::GetSiteDNSyntacticNoGuid(
    IN  DSNAME *  pdnDSA
    )
//
// Retrieve the site name for a given DSA.
//
{
    DSNAME * pdnSite;

    Assert(NULL != pdnDSA);

    pdnSite = (DSNAME *) new BYTE[ pdnDSA->structLen ];
    TrimDSNameBy(pdnDSA, 3, pdnSite);

    return pdnSite;
}

KCC_INTRASITE_CONNECTION_LIST *
KCC_DSA::GetIntraSiteCnList()
//
// Retrieve the list of intra-site connections inbound to this DSA.
//
{
    if (NULL == m_pIntraSiteCnList) {
        // Not yet cached; read now.
        m_pIntraSiteCnList = new KCC_INTRASITE_CONNECTION_LIST;

        if (!m_pIntraSiteCnList->Init(m_pdnDSA)) {
            // Search for connection objects failed.  Likely either out of
            // resources or the DSA object has been renamed since we read it.
            delete m_pIntraSiteCnList;
            m_pIntraSiteCnList = NULL;
            KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
        }
    }

    return m_pIntraSiteCnList;
}

KCC_INTERSITE_CONNECTION_LIST *
KCC_DSA::GetInterSiteCnList()
//
// Retrieve the list of inter-site connections inbound to this DSA.
//
{
    if (NULL == m_pInterSiteCnList) {
        // Not yet cached; read now.
        m_pInterSiteCnList = new KCC_INTERSITE_CONNECTION_LIST;

        if (!m_pInterSiteCnList->Init(m_pdnDSA)) {
            // Search for connection objects failed.  Likely either out of
            // resources or the DSA object has been renamed since we read it.
            delete m_pInterSiteCnList;
            m_pInterSiteCnList = NULL;
            KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
        }
    }

    return m_pInterSiteCnList;
}

BOOL
KCC_DSA::InitForKey(
    IN  DSNAME   *    pdnDSA
    )
//
// Init a KCC_DSA object for use as a key (i.e., solely for comparison use
// by bsearch()).
//
// WARNING: The DSNAME argument pdnDSA must be valid for the lifetime of this
// object!
//
{
    Reset();

    m_pdnDSA = pdnDSA;

    m_fIsInitialized = TRUE;

    return TRUE;
}

int __cdecl
KCC_DSA::CompareIndirectBySiteGuid(
    IN  const void * ppvDsa1,
    IN  const void * ppvDsa2
    )
//
// Compare two KCC_DSA objects for sorting purposes.
// Note that this is used for indirect comparisons (e.g., to sort an
// array of *pointers* to KCC_DSA objects).
//
{
    KCC_DSA * pDsa1 = (KCC_DSA *) *((void **) ppvDsa1);
    KCC_DSA * pDsa2 = (KCC_DSA *) *((void **) ppvDsa2);

    ASSERT_VALID(pDsa1);
    ASSERT_VALID(pDsa2);

    Assert(!fNullUuid(&pDsa1->GetSiteDN()->Guid));
    Assert(!fNullUuid(&pDsa2->GetSiteDN()->Guid));

    return memcmp(&pDsa1->GetSiteDN()->Guid,
                  &pDsa2->GetSiteDN()->Guid,
                  sizeof(GUID));
}

int __cdecl
KCC_DSA::CompareIndirectByNtdsDsaGuid(
    IN  const void * ppvDsa1,
    IN  const void * ppvDsa2
    )
//
// Compare two KCC_DSA objects for sorting purposes.
// Note that this is used for indirect comparisons (e.g., to sort an
// array of *pointers* to KCC_DSA objects).
//
{
    KCC_DSA * pDsa1 = (KCC_DSA *) *((void **) ppvDsa1);
    KCC_DSA * pDsa2 = (KCC_DSA *) *((void **) ppvDsa2);

    ASSERT_VALID(pDsa1);
    ASSERT_VALID(pDsa2);

    Assert(!fNullUuid(&pDsa1->GetDsName()->Guid));
    Assert(!fNullUuid(&pDsa2->GetDsName()->Guid));

    return memcmp(&pDsa1->GetDsName()->Guid,
                  &pDsa2->GetDsName()->Guid,
                  sizeof(GUID));
}

int __cdecl
KCC_DSA::CompareIndirectByNtdsDsaString(
    IN  const void * ppvDsa1,
    IN  const void * ppvDsa2
    )
//
// Compare two KCC_DSA objects for sorting purposes.
// Note that this is used for indirect comparisons (e.g., to sort an
// array of *pointers* to KCC_DSA objects).
//
{
    KCC_DSA * pDsa1 = (KCC_DSA *) *((void **) ppvDsa1);
    KCC_DSA * pDsa2 = (KCC_DSA *) *((void **) ppvDsa2);

    ASSERT_VALID(pDsa1);
    ASSERT_VALID(pDsa2);

    Assert(0!=pDsa1->GetDsName()->NameLen);
    Assert(0!=pDsa2->GetDsName()->NameLen);
    
    return wcscmp(pDsa1->GetDsName()->StringName,
                  pDsa2->GetDsName()->StringName);
}

int __cdecl
KCC_DSA::CompareIndirectGcGuid(
    IN  const void * ppvDsa1,
    IN  const void * ppvDsa2
    )
//
// Compare two KCC_DSA objects for sorting purposes.
// Sort by decending Gc-ness first, then ascending guid next
// Note that this is used for indirect comparisons (e.g., to sort an
// array of *pointers* to KCC_DSA objects).
//
{
    KCC_DSA * pDsa1 = (KCC_DSA *) *((void **) ppvDsa1);
    KCC_DSA * pDsa2 = (KCC_DSA *) *((void **) ppvDsa2);

    ASSERT_VALID(pDsa1);
    ASSERT_VALID(pDsa2);

    Assert(!fNullUuid(&pDsa1->GetDsName()->Guid));
    Assert(!fNullUuid(&pDsa2->GetDsName()->Guid));

    if (pDsa1->IsGC() == pDsa2->IsGC()) {
        return memcmp(&pDsa1->GetDsName()->Guid,
                      &pDsa2->GetDsName()->Guid,
                      sizeof(GUID));
    } else if (pDsa1->IsGC()) {
        // GC-ness sorts before non-GC-ness
        return -1;
    } else {
        return 1;
    }
}

KCC_DSA_LIST::~KCC_DSA_LIST()
{
    if( m_ppdsa ) {
        for (DWORD i = 0; i < m_cdsa; i++) {
            delete m_ppdsa[i];
        }
        delete [] m_ppdsa;
    }

    Reset();
}

void
KCC_DSA_LIST::Reset()
//
// Reset member variables to their pre-Init() state.
//
{
    m_fIsInitialized = FALSE;
    m_cdsa           = 0;
    m_ppdsa          = NULL;
    m_pfnSortedBy    = NULL;
}

KCC_DSA *
KCC_DSA_LIST::GetDsa(
    IN  DWORD   iDsa
    )
//
// Retrieve the KCC_DSA object at the given index.
//
{
    KCC_DSA * pdsa;

    ASSERT_VALID( this );

    if ( iDsa < m_cdsa )
    {
        pdsa = m_ppdsa[ iDsa ];
        ASSERT_VALID( pdsa );
    }
    else
    {
        pdsa = NULL;
    }

    return pdsa;
}


DWORD
KCC_DSA_LIST::GetCount()
//
// Retrieve the number of KCC_DSA objects in the collection.
//
{
    ASSERT_VALID( this );
    return m_cdsa;
}

BOOL
KCC_DSA_LIST::IsValid()
//
// Is the collection initialized and internally consistent?
//
{
    return m_fIsInitialized;
}


BOOL
KCC_DSA_LIST::InitSubsequence(
    IN  KCC_DSA_LIST   *pDsaList,
    IN  DWORD           left,
    IN  DWORD           right
    )
// Initialize a list of DSAs which is a contiguous subsequence
// of the list 'pDsaList'. The leftmost index of this subsequence
// is 'left' and the rightmost is 'right'.
{
    KCC_DSA        *pDsa;
    DWORD           iDSA, cTotalDSAs;

    ASSERT_VALID( pDsaList );
    Assert( left<=right );

    // Allocate memory for the new DSA list
    cTotalDSAs = right-left+1;
    m_ppdsa = new KCC_DSA*[ cTotalDSAs ];
    memset( m_ppdsa, 0, sizeof(KCC_DSA*)*cTotalDSAs ); 

    for( iDSA=left; iDSA<=right; iDSA++ ) {
        pDsa = pDsaList->GetDsa( iDSA );
        ASSERT_VALID( pDsa );
        
        // Check that the DSA objects has its DN setup properly
        Assert(!fNullUuid(&pDsa->GetDsName()->Guid));

        Assert( iDSA-left<cTotalDSAs );
        m_ppdsa[ iDSA-left ] = pDsa;
    }

    // Sort the list of DSAs by DSA GUID
    m_pfnSortedBy = KCC_DSA::CompareIndirectByNtdsDsaGuid;
    qsort( m_ppdsa, cTotalDSAs, sizeof(KCC_DSA*), m_pfnSortedBy );
    
    // Setup all members of this KCC_DSA_LIST object
    m_cdsa = cTotalDSAs;
    m_fIsInitialized = TRUE;

    return TRUE;
}


BOOL
KCC_DSA_LIST::InitAllDSAs(
	VOID
	)
// Initialize the collection from all NTDS-DSA objects in the
// Sites container. The DSAs will be ordered by site name.
{
    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { ARRAY_SIZE(AttrList), AttrList },
        EN_INFOTYPES_TYPES_VALS
    };

    DSNAME             *pdnConfigNC = gpDSCache->GetConfigNC();
    ULONG               cbSitesContainer;
    DSNAME             *pdnSitesContainer;
    WCHAR               szSitesRDN[] = L"Sites";
    DWORD               cchSitesRDN  = ARRAY_SIZE(szSitesRDN) - 1;
    DSNAME             *pdnDsaObjCat;

    ULONG               dirError;
    FILTER              Filter;
    SEARCHRES          *pResults;
    ENTINFLIST         *pEntInfList;
    DWORD               iDsa, cDsaNew;

    // Clear the member variables
    Reset();
    Assert( NULL==m_ppdsa );

    // Set up the root search dn
    cbSitesContainer  = pdnConfigNC->structLen +
                        (MAX_RDN_SIZE+MAX_RDN_KEY_SIZE) * sizeof(WCHAR);
    pdnSitesContainer = (DSNAME*) new BYTE[cbSitesContainer];
    AppendRDN(pdnConfigNC, pdnSitesContainer, cbSitesContainer,
              szSitesRDN, cchSitesRDN, ATT_COMMON_NAME);
    
    // Set up the search filter
    memset( &Filter, 0, sizeof( Filter ) );
    Filter.choice                  = FILTER_CHOICE_ITEM;
    Filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;

    pdnDsaObjCat = DsGetDefaultObjCategory(CLASS_NTDS_DSA);
    Assert(NULL != pdnDsaObjCat);

    Filter.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CATEGORY;
    Filter.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnDsaObjCat->structLen;
    Filter.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) pdnDsaObjCat;

    // Create an object to perform a paged search.
    KCC_PAGED_SEARCH    pagedSearch( pdnSitesContainer,
                                     SE_CHOICE_WHOLE_SUBTREE,
                                    &Filter,
                                    &Sel);
    do {
        dirError = pagedSearch.GetResults( &pResults );

        if( dirError ) {
            // Handle DirSearch() errors
            if( nameError==dirError ) {
                NAMERR * pnamerr = &pResults->CommRes.pErrInfo->NamErr;
        
                if(    ( NA_PROBLEM_NO_OBJECT == pnamerr->problem )
                    && ( DIRERR_OBJ_NOT_FOUND == pnamerr->extendedErr ))
                {
                    DPRINT(3, "No sites container!\n");
                }
            }
            
            DPRINT1( 0, "KccSearch() failed with error %d.\n", dirError );
            KCC_LOG_SEARCH_FAILURE( pdnSitesContainer, dirError );
            KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);            
        }

        // DirSearch() succeeded

        if( pResults->count>0 ) {

            // Allocate space in the array for the new DSAs.
            cDsaNew = m_cdsa + pResults->count;
            if(m_ppdsa) {
                m_ppdsa = (KCC_DSA**) THReAlloc( m_ppdsa, cDsaNew*sizeof(KCC_DSA*) );
            } else {
                m_ppdsa = (KCC_DSA**) THAlloc( cDsaNew*sizeof(KCC_DSA*) );
            }
            if(!m_ppdsa) {
                KCC_MEM_EXCEPT( cDsaNew*sizeof(KCC_DSA*) );
            }

            // Copy the newly-found DSAs into the array
            for( pEntInfList=&pResults->FirstEntInf, iDsa=m_cdsa;
                 NULL!=pEntInfList;
                 pEntInfList=pEntInfList->pNextEntInf )
            {
                KCC_DSA    *pdsa = new KCC_DSA;

                // Initialize the DSA with the attributes that we have loaded.
                // Add the DSA to our array.
                if( pdsa->InitDsa(&pEntInfList->Entinf.AttrBlock, NULL) ) {
                    Assert( iDsa<cDsaNew );
                    m_ppdsa[ iDsa++ ] = pdsa;
                }
            }

            m_cdsa = iDsa;      // Note: can be less than cNewDsaArray
        } else {
            Assert( pagedSearch.IsFinished() );
        }

        DirFreeSearchRes( pResults );
            
    } while( !pagedSearch.IsFinished() );

    // Handle no search results
    if( 0 == m_cdsa ) {
        DPRINT( 3, "No dsa objects found in any site!\n" );
        KCC_LOG_SEARCH_FAILURE( pdnSitesContainer, dirError );
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }

    // Now sort the DSAs by ascending ntdsDsa objectGuid.
    m_pfnSortedBy = KCC_DSA::CompareIndirectBySiteGuid;
    qsort(m_ppdsa, m_cdsa, sizeof(*m_ppdsa), m_pfnSortedBy);

    m_fIsInitialized = TRUE;
    return m_fIsInitialized;
}


VOID
KCC_DSA_LIST::InitUnionOfSites(
    IN  KCC_SITE_LIST *pSiteList,
    IN  KCC_DSA_SORTFN *pfnSortFunction
    )
/*++

Routine Description:

    Given a list of sites, create a list of DSAs contained in all of those
    sites and sort with the given sort function.
    
Arguments:

    pSiteList - A list of sites whose DSAs we want to store in the new list
    pfnSortFunction - The comparison function that will be used to sort the
        entries in the new list.

Return Value:

    None

--*/
{
    KCC_DSA_LIST   *pSiteDsaList;
    KCC_DSA        *pDsa;
    DWORD           iSite, cSite, cTotalDSAs=0;
    DWORD           iDSA=0, iSiteDSA, cSiteDSAs; 

    // Count how many DSAs there are in all the sites
    cSite = pSiteList->GetCount();
    for( iSite=0; iSite<cSite; iSite++ ) {
        pSiteDsaList = pSiteList->GetSite(iSite)->GetDsaList();

        // GetDsaList raises an exception on failure, so pSiteDsaList
        // should always be valid.
        Assert( pSiteDsaList->IsValid() );
        
        cTotalDSAs += pSiteDsaList->GetCount();
    }

    // Allocate memory for the new DSA list
    m_ppdsa = new KCC_DSA*[ cTotalDSAs ];
    memset( m_ppdsa, 0, sizeof(KCC_DSA*)*cTotalDSAs ); 

    // Fill in the new DSA list
    for( iSite=0; iSite<cSite; iSite++ ) {
        pSiteDsaList = pSiteList->GetSite(iSite)->GetDsaList();
        Assert( pSiteDsaList->IsValid() );

        cSiteDSAs = pSiteDsaList->GetCount();
        for( iSiteDSA=0; iSiteDSA<cSiteDSAs; iSiteDSA++ ) {
            pDsa = pSiteDsaList->GetDsa( iSiteDSA );
            
            // Check that the DSA objects have their DNs setup properly
            if( KCC_DSA::CompareIndirectByNtdsDsaGuid==pfnSortFunction ) {
                Assert(!fNullUuid(&pDsa->GetDsName()->Guid));
            } else if( KCC_DSA::CompareIndirectByNtdsDsaString==pfnSortFunction ) {
                Assert(0 != pDsa->GetDsName()->NameLen);
            }

            Assert( iDSA<cTotalDSAs );
            Assert( NULL==m_ppdsa[iDSA] );
            m_ppdsa[ iDSA++ ] = pDsa;
        }
    }

    // Sort the list of DSAs by the requested sort function
    qsort( m_ppdsa, cTotalDSAs, sizeof(KCC_DSA*), pfnSortFunction );
    
    // Setup all members of this KCC_DSA_LIST object
    m_fIsInitialized = TRUE;
    m_cdsa = cTotalDSAs;
    m_pfnSortedBy = pfnSortFunction;

    // Check that every DSA can be found in the new list
    #ifdef DBG
        for( iSite=0; iSite<cSite; iSite++ ) {
            pSiteDsaList = pSiteList->GetSite(iSite)->GetDsaList();
            Assert( pSiteDsaList->IsValid() );
        
            cSiteDSAs = pSiteDsaList->GetCount();
            for( iSiteDSA=0; iSiteDSA<cSiteDSAs; iSiteDSA++ ) {
                pDsa = pSiteDsaList->GetDsa( iSiteDSA );
                Assert( pDsa == this->GetDsa(pDsa->GetDsName(),NULL) );
            }
        }
    #endif // DBG
}


BOOL
KCC_DSA_LIST::InitBridgeheads(
    IN  KCC_SITE *      Site,
    IN  KCC_TRANSPORT * Transport,
    OUT BOOL *          pfExplicitBridgeheadsDefined    OPTIONAL
    )
/*++

Routine Description:

    Initialize a collection of DSA objects from the list of transport servers
    returned by the ISM for a particular site and transport.
    
Arguments:

    Site - 
    Transport - 

Return Value:

    BOOL - False if object was not initialized

--*/
{
    KCC_DSA_LIST * pAllDsaList;
    DWORD cAllDsas;
    DWORD iDsa;
    KCC_DSNAME_ARRAY * pBridgeheadArray = NULL;

    ASSERT_VALID( Site );
    ASSERT_VALID( Transport );

    Reset();

    // This list is all DSAs in the site -- a superset of the transport servers.
    // Rather than re-reading the DSA objects, we will construct our DSA list
    // using the pre-read, pre-parsed objects here.
    pAllDsaList = Site->GetDsaList();

    // GetDsaList() excepts if it fails to Init the list so 'pAllDsaList'
    // is never NULL.
    Assert( pAllDsaList );

    pBridgeheadArray = Transport->GetExplicitBridgeheadsForSite( Site );

    if (NULL != pfExplicitBridgeheadsDefined) {
        *pfExplicitBridgeheadsDefined = (NULL != pBridgeheadArray);
    }

    // Allocate space for the new (indirected) list of KCC_DSA objects.
    cAllDsas = pAllDsaList->GetCount();
    m_ppdsa = new KCC_DSA * [ pBridgeheadArray ? pBridgeheadArray->GetCount()
                                               : cAllDsas ];
    Assert(0 == m_cdsa);

    // For each DSA in the site (bridgehead or not)...
    for (iDsa = 0; iDsa < cAllDsas; iDsa++) {
        KCC_DSA * pDsa = pAllDsaList->GetDsa(iDsa);

        if ((NULL == pBridgeheadArray)
            || pBridgeheadArray->IsElementOf(pDsa->GetDsName())) {
            // This KCC_DSA object corresponds to a potential bridgehead.
            m_ppdsa[m_cdsa] = pDsa;
            m_cdsa++;
        }
    }

    if (NULL != pBridgeheadArray) {
        delete pBridgeheadArray;
    }

    // Initialized the array; now sort the DSAs by descending bridgehead
    // preference.  (GCs are more favored, otherwise sorted by
    // objectGuid.)
    m_pfnSortedBy = KCC_DSA::CompareIndirectGcGuid;
    qsort(m_ppdsa, m_cdsa, sizeof(*m_ppdsa), m_pfnSortedBy);

    m_fIsInitialized = TRUE;

    return m_fIsInitialized;
} /* KCC_DSA_LIST::InitBridgeheads */

KCC_DSA *
KCC_DSA_LIST::GetDsa(
    IN  DSNAME *pdn,
    OUT DWORD * piDsa
    )
//
// Retrieve the KCC_DSA object with the given dsname.
//
{
    KCC_DSA *   pDsa = NULL;
    KCC_DSA     DsaKey;
    KCC_DSA *   pDsaKey = &DsaKey;
    KCC_DSA **  ppDsa;

    ASSERT_VALID( this );

    if ( !pdn || !m_cdsa)
    {
        return NULL;
    }

    Assert(NULL != m_pfnSortedBy);

    // Check if we are able to use binary search to retrieve the DSA object.
    if(    ( // Guid present in key and DSAs sorted by guid
                (!fNullUuid(&pdn->Guid))
             && (m_pfnSortedBy == KCC_DSA::CompareIndirectByNtdsDsaGuid)
           )
        || ( // String present in key and DSAs sorted by string name
                (0 != pdn->NameLen)
             && (m_pfnSortedBy == KCC_DSA::CompareIndirectByNtdsDsaString)
           )
      )
    {
        // NOTE: The DSNAME argument pdn must be valid for the lifetime of
        // DsaKey.
        DsaKey.InitForKey(pdn);
    
        ppDsa = (KCC_DSA **) bsearch(&pDsaKey,
                                     &m_ppdsa[0],
                                     m_cdsa,
                                     sizeof(m_ppdsa[0]),
                                     m_pfnSortedBy);
        if (NULL != ppDsa) {
            pDsa = *ppDsa;
            ASSERT_VALID(pDsa);
    
            if (NULL != piDsa) {
                *piDsa = (DWORD)(ppDsa - m_ppdsa);
                Assert(pDsa == GetDsa(*piDsa));
            }
        }
    }
    else {
        // No guid present in key or DSAs not sorted by guid -- must use linear
        // search.
        for (DWORD iDsa = 0; iDsa < m_cdsa; iDsa++) {
            DSNAME *pdnCurrent = m_ppdsa[ iDsa ]->GetDsName();

            if (NameMatched(pdn, pdnCurrent)) {
                pDsa = m_ppdsa[ iDsa ];
                break;
            }
        }
    }

    return pDsa;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\utest\main.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       main.c
//
//--------------------------------------------------------------------------

/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    main.c

Abstract:

    This module implements a command line utility that uses the NTDS backup/restore
    client API to perform backup and restore. The API used by this utility is identical
    to the one that is used by the NT Tape backup utility except that this utility stores
    the backup files in a disk directory instead of a tape.

Author:

    R.S. Raghavan (rsraghav)    

Revision History:
    
    Created     04/04/97    rsraghav
    
    Modified    10/15/1999  BrettSh - Added support for expiry tokens.

NOTES:

WARNING: THIS IS NOT A FULL ACTIVE DIRECTORY BACKUP UTILITY.
 
    This is not a full DS backup utility, this utility is merely for 
    demonstrating the remote backup API.  Other things (registry, system 
    ini files, etc) need to be backed up to perform a full backup of a 
    Domain Controller (DC), so that it will be able to recover from a 
    complete crash.  

Local Case Backup/Restore:
------------------------------------------------- Local Backup
rem This is the local case of a backup.
dsback /backup -s brettsh-posh -dir C:\dsbackup

------------------------------------------------- Local Restore
rem This is for the local case, obviously some of the commands should be 
rem     changed in the remote cases.  One should change drive letters, and 
rem     windows directories as appropriate.
rem Note: This machine must be started up in DS repair mode before running 
rem     these commands.
rem Step 1: Remove old DS files ------------------------------
del C:\winnt\ntds\*
rem Step 2: Move over backup files ---------------------------
xcopy  C:\dsbackup\*  C:\winnt\ntds\
rem Step 3: Run restore utility ----------------------------------
rem Note: You must use the UNC name of the ntds directory
dsback /restore -s brettsh-posh -dir \\brettsh-posh\c$\winnt\ntds <lowLog #> <highLog #>
rem restart machine.

Remote Case Backup/Restore:
------------------------------------------------- Remote Backup
rem This is the remote case of a backup.  This backs up brettsh-baby's
rem    directory onto the local machine (the machine this command should
rem    be run from) brettsh-ginger.
dsback /backup -s brettsh-baby -dir C:\dsbackup

------------------------------------------------- Remote Restore
rem This is the remote machine.  The DC being restored is brettsh-baby.  The 
rem    machine that has the backed up DS files is brettsh-ginger.  These 
rem    commands would be run from brettsh-ginger.
rem Note: before this brettsh-baby must be restarted in DS repair mode.
rem Step 1: Remove old DS files ------------------------------
del \\brettsh-baby\winnt\ntds\*
rem Step 2: Move over backup files ---------------------------
rem Note: that C:\dsbackup is on brettsh-ginger.
xcopy  C:\dsbackup\*  \\brettsh-baby\winnt\ntds\
rem Step 3: Run restore utility ----------------------------------
rem Note: You must use the UNC name of the ntds directory
dsback /restore -s brettsh-baby -dir \\brettsh-baby\c$\winnt\ntds <lowLog #> <highLog #>

rem restart brettsh-baby, note this is the remote machine.

---------------------------------------------------
Suggested that one uses NT backup normally, unless you are developing
your own backup utility, then this code provides a framework to start
your Active Directory backup utility.

--*/


#include <windows.h>
#include <stdio.h>
#include <ntdsbcli.h>
#include <stdarg.h>
#include <stdlib.h>

#define ERROR_MODE      (0)
#define WARNING_MODE    (1)
#define INFO_MODE       (2)
#define VERBOSE_MODE    (3)

#define DSBACK_DATABASE_LOCATIONS_FILE "dsback.txt"
#define DEFAULT_BUFFER_SIZE 32768
#define TOKEN_FILE_NAME "token.dat"

typedef enum
{
    CMD_STATUS,
    CMD_BACKUP,
    CMD_RESTORE,
    CMD_HELP
} CMD_TYPE;

BOOL g_fVerbose = FALSE;
char *g_szServer = NULL;
char *g_szBackupDir = NULL;
char *g_szBackupLogDir = NULL;
ULONG g_ulLowLog = 0;
ULONG g_ulHighLog = 0;

// Proto-type all internal functions
int Print(int nLevel, const char *format, ...);
void PrintUsage();
CMD_TYPE GetCommand(const char *szCmd);
int Status(int argc, char *argv[]);
int Backup(int argc, char *argv[]);
int Restore(int argc, char *argv[]);
DWORD ReadTokenFile(PVOID * ppvExpiryToken, PDWORD pcbExpiryToken);
DWORD WriteTokenFile(PVOID pvExpiryToken, DWORD cbExpiryToken);

void DoBackup();
void DoRestore();

BOOL FBackupAttachments(HBC hbc, char *szAttachmentList);

// returns the number of params processed
int ProcessCommonParams(int argc, char *argv[]);

// returns the number of params processed
int ImpersonateClient(int argc, char *argv[]);

// returns the number of params processed
int ProcessBackupDir(int argc, char *argv[], int argIndex);

// returns a pointer to the filename part of the given full path'ed filename
// NULL, if there is no filename part
char *SzFileName(char *szPath);

// Adjust the client token privilege for backup or restore
DWORD AdjustTokenPrivilege(BOOL fBackup);

int __cdecl main(int argc, char *argv[])
{

    int nRet = 0;
    BOOL fRet;
    HRESULT hr;

    if (argc < 2)
    {
        PrintUsage();
        return 0;
    }

    switch (GetCommand(argv[1]))
    {
        case CMD_STATUS:
            nRet = Status(argc, argv);
            break;

        case CMD_BACKUP:
            nRet = Backup(argc, argv);
            break;

        case CMD_RESTORE:
            nRet = Restore(argc, argv);
            break;

        case CMD_HELP:
            PrintUsage();
            break;

        default:
            printf("Unknown Command!\n");
            break;
    }

    return nRet;
}

int Status(int argc, char *argv[])
{
    HRESULT hr; 
    BOOL fOnline;
    
    if (ProcessCommonParams(argc, argv))
    {
        // the command-line arguments are valid so far - find out the DS Online status
        if (hrNone == (hr = DsIsNTDSOnline(g_szServer, &fOnline)))
        {
            Print(INFO_MODE, "NT Directory Service is %s on %s!\n", fOnline ? "ONLINE" : "OFFLINE", g_szServer);
        }
        else
        {
            Print(ERROR_MODE, "Unable to contact %s - Error Code: %d\n", g_szServer, hr);
        }
    }

    return 0;
}

int Backup(int argc, char *argv[])
{
    int nProcessed = 0;
    int nBackupDirArgIndex = 0;

    if (nProcessed = ProcessCommonParams(argc, argv))
    {
        // the command-line arguments are valid so far
        nBackupDirArgIndex = nProcessed + 2;
        
        if (ProcessBackupDir(argc, argv, nBackupDirArgIndex))
        {
            // all command-line arguments are valid so far
            // no more command-line processing needed
            DoBackup();
        }
    }

    return 0;
}

int Restore(int argc, char *argv[])
{
    int nProcessed = 0;
    int nBackupDirArgIndex = 0;
    
    if (nProcessed = ProcessCommonParams(argc, argv))
    {
        // the command-line arguments are valid so far
        nBackupDirArgIndex = nProcessed + 2;
        
        if (nProcessed = ProcessBackupDir(argc, argv, nBackupDirArgIndex))
        {
            if (argc < (nBackupDirArgIndex + nProcessed + 2))
            {
                PrintUsage();
                return 0;
            }

            g_ulLowLog = strtoul(argv[nBackupDirArgIndex + nProcessed], NULL, 16);
            g_ulHighLog = strtoul(argv[nBackupDirArgIndex + nProcessed + 1], NULL, 16);

            // all command-line arguments are valid so far
            // no more command-line processing needed
            DoRestore();
        }
    }

    return 0;
}

void DoBackup()
{
    HBC hbc = NULL;
    HRESULT hr;
    LPSTR szAttachmentInfo = NULL;
    LPSTR szLogfileInfo = NULL;
    DWORD cbAttachmentInfo =0;
    DWORD cbLogfileInfo = 0;
    BOOL fOnline = FALSE;
    DWORD dwRet;
    PVOID pvExpiryToken = NULL;
    DWORD cbExpiryToken = 0;

    // Adjust token privileges for backup
    dwRet = AdjustTokenPrivilege(TRUE);

    if (ERROR_SUCCESS != dwRet)
    {
        Print(VERBOSE_MODE, "AdjustTokenPrivilege() failed for enabling backup privilege - Error Code: %u\n", dwRet);
    }

    if (hrNone == (hr = DsIsNTDSOnline(g_szServer, &fOnline)))
    {
        if (!fOnline)
        {
            Print(ERROR_MODE, "DS on server %s in NOT online! Offline backup is not supported!\n", g_szServer);
            return;
        }
    }
    else
    {
        Print(ERROR_MODE, "Unable to contact %s - Error Code: %d\n", g_szServer, hr);
        return;
    }

    // Prepare for backup
    hr = DsBackupPrepare(g_szServer, 0, BACKUP_TYPE_FULL, 
                &pvExpiryToken, &cbExpiryToken, &hbc);
    if (hr != hrNone)
    {
        Print(ERROR_MODE, "DsBackupPrepare() failed for server %s - Error Code: %d\n",
              g_szServer, hr);
        return;
    }

    Print(VERBOSE_MODE, "DsBackupPrepare() for server %s successful!\n", g_szServer);

    __try
    {
        // Get Database names and back them up
        hr = DsBackupGetDatabaseNames(hbc, &szAttachmentInfo, &cbAttachmentInfo);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsBackupGetDatabaseNames() failed for server %s - Error Code: %d\n", g_szServer, hr);
            __leave;
        }
        Print(VERBOSE_MODE, "DsBackupGetDatabaseNames() for server %s successful!\n", g_szServer);

        if (!FBackupAttachments(hbc, szAttachmentInfo))
        {
            __leave;
        }
        DsBackupFree(szAttachmentInfo);

        // Get logfile names and back them up
        hr = DsBackupGetBackupLogs(hbc, &szLogfileInfo, &cbLogfileInfo);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsBackupGetBackupLogs() failed for server %s - Error Code: %d\n", g_szServer, hr);
            __leave;
        }
        Print(VERBOSE_MODE, "DsBackupGetBackupLogs() for server %s successful!\n", g_szServer);

        if (!FBackupAttachments(hbc, szLogfileInfo))
        {
            __leave;
        }
        DsBackupFree(szLogfileInfo);

        // All logs are backed up - truncate logs
        hr = DsBackupTruncateLogs(hbc);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsBackupTruncateLogs() failed for server %s - Error Code: %d\n", g_szServer, hr);
        }
        else
        {
            Print(INFO_MODE, "DB logs truncated successfully on server %s!\n", g_szServer);
        }
        
        // Write the token that we got up at the top in DsBackupPrepare().
        dwRet = WriteTokenFile(pvExpiryToken, cbExpiryToken);
        if(dwRet != ERROR_SUCCESS){
            // The error is printed/success msg is printed by WriteTokenFile()
            __leave;
        }


    }
    __finally
    {

        // close the backup context
        hr = DsBackupEnd(hbc);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsBackupEnd() failed for server %s - Error Code: %d\n", g_szServer, hr);
        }
        else
        {
            Print(INFO_MODE, "Server %s successfully backed up into directory %s\n", g_szServer, g_szBackupDir);
        }
    }
}

void DoRestore()
{
    HBC hbc = NULL;
    HRESULT hr;
    EDB_RSTMAP rstMap;
    LPSTR szDatabaseLocations = NULL;
    DWORD cbDatabaseLocations = 0;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbWritten = 0;
    char szFileName[MAX_PATH];
    char szOldDBName[MAX_PATH];
    char szNewDBName[MAX_PATH];
    BOOL fOnline = TRUE;
    DWORD dwRet;
    PVOID pvExpiryToken = NULL;
    DWORD cbExpiryToken = 0;

    // Adjust token privileges for restore
    dwRet = AdjustTokenPrivilege(FALSE);

    if (ERROR_SUCCESS != dwRet)
    {
        Print(VERBOSE_MODE, "AdjustTokenPrivilege() failed for enabling restore privilege - Error Code: %u\n", dwRet);
    }

    if (hrNone == (hr = DsIsNTDSOnline(g_szServer, &fOnline)))
    {
        if (fOnline)
        {
            Print(ERROR_MODE, "DS on server %s is Online! Online restore is NOT supported!\n", g_szServer);
            return;
        }
    }
    else
    {
        Print(ERROR_MODE, "Unable to contact %s - Error Code: %d\n", g_szServer, hr);
        return;
    }

    dwRet = ReadTokenFile(&pvExpiryToken, &cbExpiryToken);
    if (dwRet != ERROR_SUCCESS) {
        // Error printed in ReadTokenFile()
        return;
    }

    hr = DsRestorePrepare(g_szServer, RESTORE_TYPE_CATCHUP, 
            pvExpiryToken, cbExpiryToken, &hbc); 
    if (hr != hrNone)
    {
        Print(ERROR_MODE, "DsRestorePrepare() failed for server %s - Error Code: %d\n", g_szServer, hr);
        if(pvExpiryToken) { LocalFree(pvExpiryToken); }
        return;
    }

    Print(VERBOSE_MODE, "DsRestorePrepare() for server %s successful!\n", g_szServer);

    __try
    {
        // Get the Database locations and store it in a file for later use
        hr = DsRestoreGetDatabaseLocations(hbc, &szDatabaseLocations, &cbDatabaseLocations);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsRestoreGetDatabaseLocations() failed for server %s - Error Code: %d\n", g_szServer, hr);
            __leave;
        }

        Print(VERBOSE_MODE, "DsRestoreGetDatabaseLocations() for server %s successful!\n", g_szServer);

        DsBackupFree(szDatabaseLocations);

        // register the restore
        strcpy(szOldDBName, g_szBackupDir);
        strcat(szOldDBName, "\\ntds.dit");
        strcpy(szNewDBName, szOldDBName);

        rstMap.szDatabaseName = szOldDBName;
        rstMap.szNewDatabaseName = szNewDBName;                                   
        hr = DsRestoreRegister(hbc, g_szBackupLogDir ? g_szBackupLogDir : g_szBackupDir, 
                g_szBackupLogDir ? g_szBackupLogDir : g_szBackupDir, &rstMap, 1, 
                g_szBackupLogDir ? g_szBackupLogDir : g_szBackupDir, g_ulLowLog, g_ulHighLog);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsRestoreRegister() failed for server %s - Error Code: %d\n", g_szServer, hr);
            __leave;
        }
        Print(VERBOSE_MODE, "DsRestoreRegister() for server %s successful!\n", g_szServer);

        // do actual file copy here!!

        //Register restore as complete
        hr = DsRestoreRegisterComplete(hbc, hrNone);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsRestoreRegisterComplete() failed for server %s - Error Code: %d\n", g_szServer, hr);
            __leave;
        }
        Print(VERBOSE_MODE, "DsRestoreRegisterComplete() for server %s successful!\n", g_szServer);
    
    }
    __finally
    {
        // close the restore context
        hr = DsRestoreEnd(hbc);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsRestoreEnd() failed for server %s - Error Code: %d\n", g_szServer, hr);
        }
        else
        {
            Print(INFO_MODE, "Server %s successfully restored!\n", g_szServer);
        }
        if(pvExpiryToken) { LocalFree(pvExpiryToken); }
    }
}


CMD_TYPE GetCommand(const char *szCmd)
{
    if (!_stricmp(szCmd, "/Status"))
        return CMD_STATUS;

    if (!_stricmp(szCmd, "/Backup"))
        return CMD_BACKUP;

    if (!_stricmp(szCmd, "/Restore"))
        return CMD_RESTORE;

    return CMD_HELP;
}

// returns the number of params processed
int ProcessCommonParams(int argc, char *argv[])
{
    int nProcessed = 0;

    int nArgBase = 2;

    if ((argc < 4) || (_stricmp(argv[2], "-s") && _stricmp(argv[2], "-v")))
    {
        // -s or -v expected
        PrintUsage();
        return 0;
    }

    if (!_stricmp(argv[2], "-v"))
    {
        g_fVerbose = TRUE;
        nArgBase++;

        if (_stricmp(argv[3], "-s"))
        {
            // server name argument not present
            PrintUsage();
            return 0;
        }
    }

    // get the server name
    g_szServer = argv[nArgBase + 1];

    nProcessed = ImpersonateClient(argc, argv);
    if (nProcessed < 0)
    {
        // some error occurred while getting params for impersonate client
        return 0;
    }

    return (nProcessed + nArgBase);    
}

// returns the number of params processed
int ImpersonateClient(int argc, char *argv[])
{
    HRESULT hr;

    int nArgBase = 4;

    if (g_fVerbose)
        nArgBase++;

    if ((argc < (nArgBase + 1)) || _stricmp(argv[nArgBase], "-d"))
    {
        // 5th parameter is not -d, no need to impersonate client
        return 0;
    }

    // Need to impersonate client - make sure all parameters needed to impersonate client are available
    if ((argc < (nArgBase + 6)) || _stricmp(argv[nArgBase + 2], "-u") || _stricmp(argv[nArgBase + 4], "-p"))
    {
        // command-line args for impersonation are incorrect
        PrintUsage();
        return -1;
    }

    // We have all parameter - call the API to set security context
    hr = DsSetAuthIdentity(argv[nArgBase + 3], argv[nArgBase + 1], argv[nArgBase + 5]);

    if (hr != hrNone)
    {
        Print(ERROR_MODE, "DsSetAuthIdentity() failed for domain: %s, user: %s, password: %s\n", argv[nArgBase + 1], argv[nArgBase + 3], argv[nArgBase + 5]);
        return -1;
    }

    return 6;
}

int ProcessBackupDir(int argc, char *argv[], int argIndex)
{
    int nParamsProcessed = 0;

    if (argIndex < 4 || argc < (argIndex + 2) || _stricmp(argv[argIndex], "-dir"))
    {
        // error 
        PrintUsage();
        return 0;
    }

    // get the back dir
    g_szBackupDir = argv[argIndex + 1];
    nParamsProcessed += 2;

    // Check to see if there is a separate log dir specified
    if (argc >= (argIndex + 4) && !_stricmp(argv[argIndex + 2], "-logdir"))
    {
        g_szBackupLogDir = argv[argIndex + 3];
        nParamsProcessed += 2;
    }

    // return number of parameters processed
    return nParamsProcessed;
}

void PrintUsage()
{
    printf("Usage:: dsback /<cmd> [-v] -s server [-d <domain> -u <user> -p <password>] <cmd specific params>\n");
    printf("<cmd>:\n");
    printf("       /status   : tells if the NTDS is online on the specified server\n");
    printf("       /backup   : backs up the NTDS (if it is online) into the given dir\n");
    printf("                   <params>: -dir <backup dir>\n");
    printf("       /restore  : configures the specified server for NTDS restore\n");
    printf("                   <params>: -dir <UNC path of the database dir> [-logdir <UNC path of the db log dir]<lowLog#> <highLog#>\n");
    printf(" -v : executes the specified command in verbose mode\n");
    printf("  Note: That before running the restore command, the old directory files\n");
    printf("        should be deleted from %%windir%%\\ntds\\, and all the backup files should\n");
    printf("        be copied into this directory.  High and Low log numbers are in hex.\n");
}

int Print(int nLevel, const char *format, ...)
{
    va_list arglist;
    int nRet = 0;

    va_start(arglist, format);

    switch(nLevel)
    {
        case VERBOSE_MODE:
            if (g_fVerbose)
            {
                nRet = vprintf(format, arglist);
            }
            break;

        case INFO_MODE:
            nRet = vprintf(format, arglist);
            break;
            
        case WARNING_MODE:
            nRet = vprintf(format, arglist);
            break;
            
        case ERROR_MODE:
            nRet = vprintf(format, arglist);
            break;

        default:
            nRet = vprintf(format, arglist);
            break;
    }

    va_end(arglist);

    return nRet;
}

char *SzFileName(char *szPath)
{
    char *szRet;

    if ((szRet = strrchr(szPath, '\\')))
        return (szRet+1);

    return NULL;
}

BOOL FBackupAttachments(HBC hbc, char *szAttachmentList)
{
    LPSTR szTemp = NULL;
    char szFileName[MAX_PATH];
    BYTE pb[DEFAULT_BUFFER_SIZE];
    DWORD cb = DEFAULT_BUFFER_SIZE;
    DWORD cbRead = 0;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbWritten = 0;
    HRESULT hr;

    szTemp = szAttachmentList;
    while (*szTemp != 0)
    {
        LARGE_INTEGER liFileSize;
        DWORD cbExpected;
        char *chTmp;

        szTemp++; // skip the BFT char
        hr = DsBackupOpenFile(hbc, szTemp, cb, &liFileSize);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsBackupOpenFile() failed for server %s - Error Code: %d\n", g_szServer, hr);
            return FALSE;
        }

        cbExpected = liFileSize.LowPart;

        // backup file is opened in the backup context - create a disk file
        strcpy(szFileName, g_szBackupDir);
        strcat(szFileName, "\\");
        if (NULL == (chTmp = SzFileName(szTemp))) {
            Print(ERROR_MODE, "DsBackupOpenFile() failed to parse file name\n");
            return FALSE;
        }
        strcat(szFileName, chTmp); 
        hFile = CreateFile(szFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            Print(ERROR_MODE, "Unable to Create the file %s\n!", szFileName);
            return FALSE;            
        }

        // read the file data through the API and write it to the disk file
        do 
        {
            cbRead = 0;

            hr = DsBackupRead(hbc, pb, cb, &cbRead);
            if (hr != hrNone &&  hr != ERROR_HANDLE_EOF)
            {
                Print(ERROR_MODE, "DsBackupRead() failed for server %s  - Error Code: %d\n", g_szServer, hr);
                return FALSE;
            }

            if (cbRead)
            {
                if (!WriteFile(hFile, pb, cbRead, &cbWritten, NULL) || (cbWritten != cbRead))
                {
                    Print(ERROR_MODE, "WriteFile failed for %s \n!", szFileName);
                    return FALSE;
                }
                
                cbExpected -= cbRead;
            }
            else
                break;

        } while ((hrNone == hr) && (cbExpected > 0));
        
        Print(VERBOSE_MODE, "Finished backing up %s!\n", SzFileName(szTemp));

        hr = DsBackupClose(hbc);
        if (hr !=hrNone)
        {
            Print(ERROR_MODE, "DsBackupClose() failed for server %s - Error Code: %d\n", g_szServer, hr);
            return FALSE;
        }
        
        CloseHandle(hFile);

        szTemp += (strlen(szTemp) + 1);
    }

    return TRUE;
}

DWORD AdjustTokenPrivilege(BOOL fBackup)
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tpNew;
    LUID luid;
    DWORD dwRet;

    // Open the process token for this process
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
    {
        dwRet = GetLastError();
        return dwRet;
    }

    // Get the local unique id 
    if (!LookupPrivilegeValue(NULL, fBackup ? SE_BACKUP_NAME : SE_RESTORE_NAME, &luid))
    {
        dwRet = GetLastError();
        CloseHandle(hToken);
        return dwRet;
    }

    // Fill-in the TOKEN_PRIVILEGE struct
    tpNew.PrivilegeCount = 1;
    tpNew.Privileges[0].Luid = luid;
    tpNew.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(hToken, FALSE, &tpNew, sizeof(tpNew), NULL, NULL))
    {
        dwRet = GetLastError();
        CloseHandle(hToken);
        return dwRet;
    }

    
    CloseHandle(hToken);
    
    return ERROR_SUCCESS;
}


DWORD
WriteSmallFile(
    LPSTR                    szFileName,
    BYTE *                   pbBuffer,
    DWORD                    cbBuffLen
    )
/*++

Description: Takes the a buffer (pbBuffer), and the size of the buffer 
    (cBuffLen), and writes it to the file szFileName.  Note can only handle 
    files of 4 GB or less.
    
Arguments:
    szFileName (IN) - String of the filename.
    pbBuffer (IN) - The buffer to write to disk.
    cBuffLen (IN) - The length of the buffer in pbBuffer.    
    
Return Value: Returns a Win32 error.

--*/
{
    HANDLE                   hFile = INVALID_HANDLE_VALUE;
    DWORD                    cbWritten = 0;

    hFile = CreateFile(szFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hFile){
        return(GetLastError());
    }
    
    if (!WriteFile(hFile, pbBuffer, cbBuffLen, &cbWritten, NULL) || (cbWritten != cbBuffLen)){
        CloseHandle(hFile);
        return(GetLastError());
    }

    CloseHandle(hFile);
    return(ERROR_SUCCESS);
}

DWORD
ReadSmallFile(
    LPSTR                    szFileName,
    BYTE **                  ppbBuffer,
    PDWORD                   pcbBuffLen
    )
/*++
Description: Takes the name of a file (szFileName), and returns in *pcbBuffLen 
    bytes of LocalAlloc'd memory pointed to by *ppbBuffer.

Arguments:
    szFileName (IN) - String of the filename.
    ppbBuffer (OUT) - A pointer to the loc of the pointer of the LocalAlloc'd 
        buffer that gets returned.
    pcBuffLen (OUT) - The length of the buffer returned.
    
Return Value: Returns a Win32 error.

--*/
{
    HANDLE                   hFile = INVALID_HANDLE_VALUE;
    DWORD                    cbRead = 0;

    hFile = CreateFile(szFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hFile){
        return(GetLastError());
    }
    
    *pcbBuffLen = GetFileSize(hFile, NULL);
    if(*pcbBuffLen == -1){
        CloseHandle(hFile);
        return(GetLastError());
    }
    *ppbBuffer = LocalAlloc(LMEM_FIXED, *pcbBuffLen);
    if(*ppbBuffer == NULL){
        CloseHandle(hFile);
        return(GetLastError());
    }

    if (!ReadFile(hFile, *ppbBuffer, *pcbBuffLen, &cbRead, NULL) || (*pcbBuffLen != cbRead)){
        CloseHandle(hFile);
        LocalFree(*ppbBuffer);
        return(GetLastError());
    }

    CloseHandle(hFile);
    return(ERROR_SUCCESS);
}

DWORD
ReadTokenFile(
    PVOID *                 ppvExpiryToken,
    PDWORD                  pcbExpiryToken
    )
/*++
Description: This constructs the filename of the Expiry Token, and then
    writes this out to a file in the backup dir.
    
Arguments:
    ppvExpiryToken (OUT) - This is a LocalAlloc'd version of the Expiry Token.
    pcbExpiryToken (OUT) - This is the size of the LocalAlloc'd Expiry Token.
    
Return Value: Returns a Win32 error.

--*/
{
    CHAR                     szFileName[MAX_PATH];
    DWORD                    dwRet;

    strcpy(szFileName, g_szBackupDir);
    strcat(szFileName, "\\");
    strcat(szFileName, TOKEN_FILE_NAME); 

    dwRet = ReadSmallFile(szFileName, (BYTE **) ppvExpiryToken, pcbExpiryToken);
    if(dwRet != ERROR_SUCCESS){
        Print(ERROR_MODE, "There was an error (%d) reading the Expiry Token file (%s).\n",
              dwRet, szFileName);
        return(dwRet);
    }
    Print(VERBOSE_MODE, "Finished reading Expiry Token file!\n");
    return(ERROR_SUCCESS);
}

DWORD
WriteTokenFile(
    PVOID                   pvExpiryToken,
    DWORD                   cbExpiryToken
    )
/*++
Description: This constructs the file name of the Expiry Token, and then
    writes the token out.
    
Arguments:
    pvExpiryToken (IN) - This is the Expiry Token to write out.
    cbExpiryToken (IN) - This is the Expiry Token's size to write out.

Return Values: Returns a Win32 error.  

--*/
{
    CHAR                     szFileName[MAX_PATH];
    DWORD                    dwRet;

    strcpy(szFileName, g_szBackupDir);
    strcat(szFileName, "\\");
    strcat(szFileName, TOKEN_FILE_NAME);

    dwRet = WriteSmallFile(szFileName, pvExpiryToken, cbExpiryToken);
    if(dwRet != ERROR_SUCCESS){
        Print(ERROR_MODE, "There was an error (%d) writing the token file (%s).\n",
              dwRet, szFileName);
        return(dwRet);
    }
    Print(VERBOSE_MODE, "Finnished writing out Expiry Token file!\n");
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kccduapi.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccduapi.cxx

ABSTRACT:

    Wrappers for NTDSA.DLL Dir* calls.

DETAILS:


CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpchx.h>
#include "kcc.hxx"
#include "kccduapi.hxx"

#define FILENO FILENO_KCC_KCCDUAPI
#define KCC_PAGED_SEARCH_LIMIT      1000
#define KCC_PAGED_SEARCH_LIMIT_DBG  2

// Global flag to control whether we assert on unexpected directory failures
DWORD gfKccAssertOnDirFailure = FALSE;

void
KccBuildStdCommArg(
    OUT COMMARG *   pCommArg
    )
{
    InitCommarg(pCommArg);

    pCommArg->Svccntl.fUnicodeSupport         = TRUE;
    pCommArg->Svccntl.SecurityDescriptorFlags = 0;
// Allow removal of non-existant values and addition of already-present values.
    pCommArg->Svccntl.fPermissiveModify       = TRUE;
}


ULONG
KccRead(
    IN  DSNAME *            pDN,
    IN  ENTINFSEL *         pSel,
    OUT READRES **          ppReadRes,
    IN  KCC_INCLUDE_DELETED eIncludeDeleted
    )
//
// Wrapper for DirRead().
//
{
    ULONG       dirError;
    READARG     ReadArg;

    *ppReadRes = NULL;

    RtlZeroMemory(&ReadArg, sizeof(READARG));
    ReadArg.pObject = pDN;
    ReadArg.pSel    = pSel;
    KccBuildStdCommArg( &ReadArg.CommArg );

    if ( KCC_INCLUDE_DELETED_OBJECTS == eIncludeDeleted )
    {
        ReadArg.CommArg.Svccntl.makeDeletionsAvail = TRUE;
    }

    THClearErrors();
    SampSetDsa( TRUE );
    dirError = DirRead( &ReadArg, ppReadRes );

    return dirError;
}


ULONG
KccSearch(
    IN  DSNAME *            pRootDN,
    IN  UCHAR               uchScope,
    IN  FILTER *            pFilter,
    IN  ENTINFSEL *         pSel,
    OUT SEARCHRES **        ppResults,
    IN  KCC_INCLUDE_DELETED eIncludeDeleted
    )
//
// Wrapper for DirSearch().
//
{
    ULONG       dirError;
    SEARCHARG   SearchArg;

    *ppResults = NULL;

    memset(&SearchArg, 0, sizeof(SEARCHARG));
    SearchArg.pObject       = pRootDN;
    SearchArg.choice        = uchScope;     /* Base, One-Level, or SubTree */
    SearchArg.bOneNC        = TRUE;         /* KCC never needs cross-NC searches */
    SearchArg.pFilter       = pFilter;      /* pFilter describes desired objects */
    SearchArg.searchAliases = FALSE;        /* Not currently used; always FALSE */
    SearchArg.pSelection    = pSel;         /* pSel describes selected attributes */
    KccBuildStdCommArg( &SearchArg.CommArg );

    if ( KCC_INCLUDE_DELETED_OBJECTS == eIncludeDeleted )
    {
        SearchArg.CommArg.Svccntl.makeDeletionsAvail = TRUE;
    }

    THClearErrors();
    SampSetDsa( TRUE );
    dirError = DirSearch( &SearchArg, ppResults );

    return dirError;
}


KCC_PAGED_SEARCH::KCC_PAGED_SEARCH(
    IN      DSNAME             *pRootDN,
    IN      UCHAR               uchScope,
    IN      FILTER             *pFilter,
    IN      ENTINFSEL          *pSel
    )
{
    // Setup the SEARCHARG structure
    this->pRootDN    = pRootDN;
    this->uchScope   = uchScope;
    this->pFilter    = pFilter;
    this->pSel       = pSel;

    // Setup the restart structure
    pRestart = NULL;
    fSearchFinished = FALSE;
}


ULONG
KCC_PAGED_SEARCH::GetResults(
    OUT SEARCHRES         **ppResults
    )
//
// Retrieve some (but possibly not all) results from a paged search.
// The caller should use IsFinished() to determine if the search is
// complete or not. If the search is already complete when this function
// is called, *ppResults is set to NULL and 0 is returned.
// The caller should call DirFreeSearchRes() on the ppResults.
//
{
    SEARCHARG   SearchArg;
    ULONG       dirError;

    // If the search is already finished, just return NULL results.
    if( fSearchFinished ) {
        *ppResults = NULL;
        return 0;
    }

    // Setup the SEARCHARG structure
    memset(&SearchArg, 0, sizeof(SEARCHARG));

    SearchArg.pObject       = pRootDN;
    SearchArg.choice        = uchScope;
    SearchArg.bOneNC        = TRUE;
    SearchArg.pFilter       = pFilter;
    SearchArg.searchAliases = FALSE;        
    SearchArg.pSelection    = pSel;

    // Set up the paged-result data
    KccBuildStdCommArg( &SearchArg.CommArg );
    SearchArg.CommArg.PagedResult.fPresent = TRUE;
    SearchArg.CommArg.PagedResult.pRestart = pRestart;
#ifdef DBG
    // Use the paging code more aggresively on debug builds
    SearchArg.CommArg.ulSizeLimit = KCC_PAGED_SEARCH_LIMIT_DBG;
#else
    SearchArg.CommArg.ulSizeLimit = KCC_PAGED_SEARCH_LIMIT;
#endif
    
    THClearErrors();
    SampSetDsa( TRUE );

    // Perform the actual search operation
    dirError = DirSearch( &SearchArg, ppResults );
    if( dirError ) {
        return dirError;
    }

    // Check if the search has finished
    if(   (NULL != ppResults[0]->PagedResult.pRestart)
       && (ppResults[0]->PagedResult.fPresent) )
    {
        pRestart = ppResults[0]->PagedResult.pRestart;
    } else {
        fSearchFinished = TRUE;
    }

    return 0;
}


ULONG
KccAddEntry(
    IN  DSNAME *    pDN,
    IN  ATTRBLOCK * pAttrBlock
    )
//
// Wrapper for DirAddEntry().
//
{
    ULONG       dirError;
    ADDARG      AddArg;
    ADDRES *    pAddRes;

    memset( &AddArg, 0, sizeof( AddArg ) );
    AddArg.pObject = pDN;
    memcpy( &AddArg.AttrBlock, pAttrBlock, sizeof( AddArg.AttrBlock ) );
    KccBuildStdCommArg( &AddArg.CommArg );

    THClearErrors();
    SampSetDsa( TRUE );
    dirError = DirAddEntry( &AddArg, &pAddRes );

    return dirError;
}


ULONG
KccRemoveEntry(
    IN  DSNAME *    pDN
    )
//
// Wrapper for DirRemoveEntry().
//
{
    ULONG       dirError;
    REMOVEARG   RemoveArg;
    REMOVERES * pRemoveRes;

    memset( &RemoveArg, 0, sizeof( RemoveArg ) );
    RemoveArg.pObject = pDN;
    KccBuildStdCommArg( &RemoveArg.CommArg );

    THClearErrors();
    SampSetDsa( TRUE );
    dirError = DirRemoveEntry( &RemoveArg, &pRemoveRes );

    return dirError;
}


ULONG
KccModifyEntry(
    IN  DSNAME *        pDN,
    IN  USHORT          cMods,
    IN  ATTRMODLIST *   pModList
    )
//
// Wrapper for DirModifyEntry().
//
{
    ULONG       dirError;
    MODIFYARG   ModifyArg;
    MODIFYRES * pModifyRes;

    memset(&ModifyArg, 0, sizeof(ModifyArg));
    ModifyArg.pObject = pDN;
    ModifyArg.count = cMods;
    memcpy(&ModifyArg.FirstMod, pModList, sizeof(ModifyArg.FirstMod));
    KccBuildStdCommArg(&ModifyArg.CommArg);

    THClearErrors();
    SampSetDsa(TRUE);
    dirError = DirModifyEntry(&ModifyArg, &pModifyRes);

    return dirError;
}


VOID
KccLogDirOperationFailure(
    LPWSTR OperationName,
    DSNAME *ObjectDn,
    DWORD DirError,
    DWORD DsId
    )

/*++

Routine Description:

    General routine to log unexpected directory service failures

Arguments:

    OperationName - 
    ObjectDn - 
    DirError - 
    FileNumber - 
    LineNumber - 

Return Value:

    None

--*/

{
    LPSTR pszError = THGetErrorString();
    CHAR szNumber[30];

    // Put in a default error string if GetErrorString fails
    if (!pszError) {
        sprintf( szNumber, "Dir error %d\n", DirError );
        pszError = szNumber;
    }

    DPRINT4(0,
            "Unexpected %ws error on %ws @ dsid %x: %s",
            OperationName, ObjectDn->StringName, DsId, pszError);

    LogEvent8(
        DS_EVENT_CAT_KCC,
        DS_EVENT_SEV_ALWAYS,
        DIRLOG_KCC_DIR_OP_FAILURE,
        szInsertWC(OperationName),
        szInsertDN(ObjectDn),
        szInsertInt(DirError),
        szInsertHex(DsId),
        szInsertSz(pszError),
        NULL, NULL, NULL
        ); 

    if (gfKccAssertOnDirFailure) {
        Assert( !"Unexpected KCC Directory Service failure\ned ntdskcc!gfKccAssertOnDirFailure 0 and continue to disable these asserts" );
    }

} /* KccLogDirOperationFailure */


VOID
freeEntInf(
    IN ENTINF *pEntInf
    )

/*++

Routine Description:

    Free the contents of an Entinf (but not the structure itself)

Arguments:

    pEntInf - 

Return Value:

    None

--*/

{
    DWORD iAttr, iValue;

    Assert( pEntInf );

    THFree( pEntInf->pName );

    for( iAttr = 0; iAttr < pEntInf->AttrBlock.attrCount; iAttr++ ) {
        ATTR *pAttr = &( pEntInf->AttrBlock.pAttr[iAttr] );
        for( iValue = 0; iValue < pAttr->AttrVal.valCount; iValue++ ) {
            ATTRVAL pAVal = pAttr->AttrVal.pAVal[iValue];
            THFree( pAVal.pVal );
        }
        if (pAttr->AttrVal.valCount) {
            THFree( pAttr->AttrVal.pAVal );
        }
    }
    if (pEntInf->AttrBlock.attrCount) {
        THFree( pEntInf->AttrBlock.pAttr );
    }
} /* KccFreeEntInf */


VOID
freeRangeInf(
    IN RANGEINF *pRangeInf
    )

/*++

Routine Description:

    Free the contents of a RangeInf

Arguments:

    pRangeInf - 

Return Value:

    None

--*/

{
    if (pRangeInf->count) {
        THFree( pRangeInf->pRanges );
    }
} /* freeRangeInf */


VOID
DirFreeSearchRes(
    IN SEARCHRES *pSearchRes
    )

/*++

Routine Description:

BUGBUG - move into NTDSA

    Release the memory used by a SearchRes.
    SearchRes returns results allocated using the thread-heap.
    Best-effort basis.

Arguments:

    pSearchRes - 

Return Value:

    None

--*/

{
    ENTINFLIST *pEntInfList, *pNextEntInfList;
    RANGEINFLIST *pRangeInfList, *pNextRangeInfList;

    THFree( pSearchRes->pBase );

    if (pSearchRes->count) {
        pEntInfList = &pSearchRes->FirstEntInf;
        freeEntInf( &(pEntInfList->Entinf) );
        // Do not free the first pEntInfList since it is embedded

        pNextEntInfList = pEntInfList->pNextEntInf;
        while ( NULL != pNextEntInfList ) {
            pEntInfList = pNextEntInfList;

            freeEntInf( &(pEntInfList->Entinf) );

            pNextEntInfList = pEntInfList->pNextEntInf;
            THFree( pEntInfList );
        }
    }

    pRangeInfList = &pSearchRes->FirstRangeInf;
    freeRangeInf( &(pRangeInfList->RangeInf) );
    // Do not free the first pRangeInfList since it is embedded

    pNextRangeInfList = pRangeInfList->pNext;
    while ( NULL != pNextRangeInfList ) {
        pRangeInfList = pNextRangeInfList;
        
        freeRangeInf( &(pRangeInfList->RangeInf) );
            
        pNextRangeInfList = pRangeInfList->pNext;
        THFree( pRangeInfList ); // ok
    }

    // Free the search res itself
    THFree( pSearchRes );

} /* KccFreeSearchRes */


VOID
DirFreeReadRes(
    IN READRES *pReadRes
    )

/*++

Routine Description:

BUGBUG - move into NTDSA

    Release the memory used by a SearchRes.
    ReadRes returns results allocated using the thread-heap.
    Best-effort basis.

Arguments:

    None

Return Value:

    None

--*/

{
    freeEntInf( &(pReadRes->entry) );
    THFree( pReadRes );

} /* KccFreeReadRes */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kcccache.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcccache.cxx

ABSTRACT:

    KCC_DS_CACHE

DETAILS:

    This class acts as a cache for configuration information from the DS.

CREATED:

    04/28/99    JeffParh

REVISION HISTORY:

--*/

#include <ntdspchx.h>
extern "C" {
#include <ntsam.h>
#include <lsarpc.h>
#include <lsaisrv.h>
}
#include <dsconfig.h>
#include "kcc.hxx"
#include "kcctask.hxx"
#include "kccconn.hxx"
#include "kcctopl.hxx"
#include "kcccref.hxx"
#include "kccdsa.hxx"
#include "kcctools.hxx"
#include "kcctrans.hxx"
#include "kccsconn.hxx"
#include "kccdynar.hxx"
#include "kccsite.hxx"
#include "kccduapi.hxx"

#define FILENO FILENO_KCC_KCCCACHE

BOOL
KCC_DS_CACHE::Init()
{
    BOOL                        fSuccess = FALSE;
    NTSTATUS                    ntStatus = 0;
    LSAPR_POLICY_INFORMATION *  pPolicyInfo = NULL;
    DSNAME                     *pdnLocalSite;
    ULONG                       cBytes;
    DWORD                       i, dsid = 0;

    Reset();

    __try {
        //////////////////////////////////////////////////////////////////////
        // Stage 0 Initialization Begins

        // Cache the DNS name of the root domain.
        ntStatus = LsaIQueryInformationPolicyTrusted(
                        PolicyDnsDomainInformation,
                        &pPolicyInfo);

        if (!NT_SUCCESS(ntStatus)) {
            // LsaIQueryInformationPolicyTrusted() failed.
            dsid = DSID(FILENO_KCC_KCCCACHE, __LINE__);
            __leave;
        }

        // NULL-terminate the root domain DNS name.
        m_pszForestDnsName = (WCHAR *)
            new BYTE[pPolicyInfo->PolicyDnsDomainInfo.DnsForestName.Length + 2];

        memcpy(m_pszForestDnsName,
               pPolicyInfo->PolicyDnsDomainInfo.DnsForestName.Buffer,
               pPolicyInfo->PolicyDnsDomainInfo.DnsForestName.Length);

        // Get the system partition and ntdsDsa DNs.
        cBytes = 0;
        ntStatus = GetConfigurationName(DSCONFIGNAME_CONFIGURATION,
                                        &cBytes,
                                        m_pdnConfiguration);

        if (STATUS_BUFFER_TOO_SMALL == ntStatus) {
            m_pdnConfiguration = (DSNAME *) new BYTE[cBytes];

            ntStatus = GetConfigurationName(DSCONFIGNAME_CONFIGURATION,
                                            &cBytes,
                                            m_pdnConfiguration);
        }

        if (NT_SUCCESS(ntStatus)) {
            cBytes = 0;
            ntStatus = GetConfigurationName(DSCONFIGNAME_DMD,
                                            &cBytes,
                                            m_pdnSchema);

            if (STATUS_BUFFER_TOO_SMALL == ntStatus) {
                m_pdnSchema = (DSNAME *) new BYTE[cBytes];

                ntStatus = GetConfigurationName(DSCONFIGNAME_DMD,
                                                &cBytes,
                                                m_pdnSchema);
            }
        }

        if (NT_SUCCESS(ntStatus)) {
#if DBG
            m_fRunningUnderAltID = GetAltIdentity(&m_pdnLocalDSA);
#else
            m_fRunningUnderAltID = FALSE;
#endif
            if (!m_fRunningUnderAltID) {
                cBytes = 0;
                ntStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                                &cBytes,
                                                m_pdnLocalDSA);

                if (STATUS_BUFFER_TOO_SMALL == ntStatus) {
                    m_pdnLocalDSA = (DSNAME *) new BYTE[cBytes];

                    ntStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                                    &cBytes,
                                                    m_pdnLocalDSA);
                }
            }
        }

        if (!NT_SUCCESS(ntStatus)) {
            dsid = DSID(FILENO_KCC_KCCCACHE, __LINE__);
            __leave;
        }

        //////////////////////////////////////////////////////////////////////
        // Stage 0 Initialization Complete. Stage 1 Initialization Begins
        m_initializationStage = KCC_CACHE_STAGE_0_COMPLETE;

        // Initialize the schedule cache
        if (!(m_hScheduleCache = ToplScheduleCacheCreate())) {
            dsid = DSID(FILENO_KCC_KCCCACHE, __LINE__);
            __leave;
        }

        // Read the interSiteTransport objects.
        if (!m_TransportList.Init()) {
            dsid = DSID(FILENO_KCC_KCCCACHE, __LINE__);
            __leave;
        }

        // Find the IP transport.
        for (i = 0; i < m_TransportList.GetCount(); i++) {
            KCC_TRANSPORT * pTransport = m_TransportList.GetTransport(i);
            if (pTransport->IsIntersiteIP()) {
                m_pdnIpTransport = pTransport->GetDN();
                break;
            }
        }

        if (NULL == m_pdnIpTransport) {
            dsid = DSID(FILENO_KCC_KCCCACHE, __LINE__);
            __leave;
        }

        // Read the crossRef objects.
        if (!m_CrossRefList.Init()) {
            dsid = DSID(FILENO_KCC_KCCCACHE, __LINE__);
            __leave;
        }

        // Check that the crossRef for the Config NC could be loaded.
        if( !m_CrossRefList.GetCrossRefForNC(m_pdnConfiguration) ) {
            dsid = DSID(FILENO_KCC_KCCCACHE, __LINE__);
            __leave;
        }

        //////////////////////////////////////////////////////////////////////
        // Stage 1 Initialization Complete. Stage 2 Initialization Begins
        m_initializationStage = KCC_CACHE_STAGE_1_COMPLETE;

        // Initialize all site objects here. However, none of the sites
        // will contain any DSA objects yet.
        if (!m_SiteList.InitAllSites()) {
            // Failed to initialize site / DSA objects
            dsid = DSID(FILENO_KCC_KCCCACHE, __LINE__);
            __leave;
        }

        //////////////////////////////////////////////////////////////////////
        // Stage 2 Initialization Complete. Stage 3 Initialization Begins
        m_initializationStage = KCC_CACHE_STAGE_2_COMPLETE;

        // Add all the DSA objects to their sites.
        m_SiteList.PopulateDSAs();

        //////////////////////////////////////////////////////////////////////
        // Stage 3 Initialization Complete. Stage 4 Initialization Begins
        m_initializationStage = KCC_CACHE_STAGE_3_COMPLETE;

        // Find KCC_SITE object for local site
        pdnLocalSite = KCC_DSA::GetSiteDNSyntacticNoGuid( m_pdnLocalDSA );
        m_pLocalSite = m_SiteList.GetSite( pdnLocalSite );
        if( ! m_pLocalSite ) {
            // A match for the local site was not read.  This can occur if
            // the site was renamed or deleted while the KCC was running.
            // Abort this KCC run.
            KCC_EXCEPT(ERROR_DS_OBJ_NOT_FOUND, 0);
        }

        //////////////////////////////////////////////////////////////////////
        // Stage 4 Initialization Complete. Stage 5 Initialization Begins
        m_initializationStage = KCC_CACHE_STAGE_4_COMPLETE;

        // Find KCC_DSA object for local DSA
        m_pLocalDSA = m_pLocalSite->GetDsaList()->GetDsa( m_pdnLocalDSA );
        if( ! m_pLocalDSA ) {
            KCC_EXCEPT(ERROR_DS_OBJ_NOT_FOUND, 0);
        }

        //////////////////////////////////////////////////////////////////////
        // All Initialization Complete
        m_initializationStage = KCC_CACHE_INITIALIZATION_COMPLETE;

        fSuccess = TRUE;
    }
    __finally {
        if (NULL != pPolicyInfo) {
            LsaIFree_LSAPR_POLICY_INFORMATION(PolicyDnsDomainInformation,
                                              pPolicyInfo);
        }
    }

    if (!fSuccess) {
        DPRINT(0, "KCC_DS_CACHE::Init() failed!\n");
        LogEvent(DS_EVENT_CAT_KCC,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_KCC_CACHE_INIT_FAILED,
                 szInsertHex(dsid),
                 0,
                 0);
    }

    return fSuccess;
}

void
KCC_DS_CACHE::Reset()
{
    m_initializationStage    = KCC_CACHE_NOT_INITIALIZED;
    m_fRunningUnderAltID     = FALSE;

    m_pdnLocalDSA       = NULL;
    m_pLocalDSA         = NULL;
    m_pLocalSite        = NULL;
    m_pdnConfiguration  = NULL;
    m_pdnSchema         = NULL;
    m_pdnIpTransport    = NULL;
    m_pszForestDnsName  = NULL;
    m_hScheduleCache    = NULL;
    m_dwStayOfExecution = 0;
    m_fReadStayOfExecution = FALSE;

    m_globalDSAListByGUID   = NULL;
    m_globalDSAListByString = NULL;

    m_CrossRefList.Reset();
    m_TransportList.Reset();
    m_SiteList.Reset();

    m_fReachableMarkingComplete = FALSE;
}

// Check that the cache finished up to 'initStage' of its initialization.
BOOL
KCC_DS_CACHE::IsValid( KCC_CACHE_INIT_STAGE initStage )
{
    Assert(NULL != this);

    if( m_initializationStage < initStage ) {
        Assert("KCC Cache initialization not complete");
        return FALSE;
    }
    
    if( m_initializationStage>=KCC_CACHE_STAGE_0_COMPLETE ) {
        Assert(NULL != m_pszForestDnsName);
        Assert(NULL != m_pdnConfiguration);
        Assert(NULL != m_pdnSchema);
        Assert(NULL != m_pdnLocalDSA);
    }

    if( m_initializationStage>=KCC_CACHE_STAGE_1_COMPLETE ) {
        Assert(NULL != m_hScheduleCache);
        ASSERT_VALID(&m_TransportList);
        Assert(NULL != m_pdnIpTransport);
        ASSERT_VALID(&m_CrossRefList);

        Assert(3 <= m_CrossRefList.GetCount());
        Assert(1 <= m_TransportList.GetCount());
    }

    if( m_initializationStage>=KCC_CACHE_STAGE_2_COMPLETE ) {
        ASSERT_VALID(&m_SiteList);
        Assert(1 <= m_SiteList.GetCount());
    }

    if( m_initializationStage>=KCC_CACHE_STAGE_4_COMPLETE ) {
        ASSERT_VALID(m_pLocalSite);
    }

    if( m_initializationStage>=KCC_CACHE_INITIALIZATION_COMPLETE ) {
        ASSERT_VALID(m_pLocalDSA);
    }

    // The cache is valid up to the requested stage.
    return TRUE;
}

ULONG
KCC_DS_CACHE::GetStayOfExecution()
//
// Retrieve the length of time (in seconds) between when a server object is
// deleted and when we declare that it's dead forever.
//
// (This period allows the deletion to propagate to the server corresponding
// to the deleted server object and for that server to revive the object and
// propagate it back to the rest of the enterprise.)
//
// [103513 wlees] Make stay of execution configurable
//
{
    ATTR      rgAttrs[] =
    {
        { ATT_TOMBSTONE_LIFETIME, { 0, NULL } },
        { ATT_REPL_TOPOLOGY_STAY_OF_EXECUTION, { 0, NULL } }
    };

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    ULONG       dirError;
    READRES *   pReadRes = NULL;
    NTSTATUS    status;
    DWORD       cBytes = 0;
    DSNAME *    pdnDirectoryService = NULL;
    ULONG       ulTombstoneLifetimeDays;
    ULONG       ulStayOfExecutionDays, ulStayOfExecutionDaysMax;
    ULONG       ulStayOfExecutionSecs;
    BOOL        fSkipRangeCheck = FALSE;

    ASSERT_VALID(this);

    // If the stay of execution length is stored in the cache, we
    // don't bother to read it from the directory again.
    if( m_fReadStayOfExecution ) {
        return m_dwStayOfExecution;
    }

    status = GetConfigurationName(
                        DSCONFIGNAME_DS_SVC_CONFIG,
                        &cBytes,
                        pdnDirectoryService);
    Assert(STATUS_BUFFER_TOO_SMALL == status);
    pdnDirectoryService = (DSNAME *) alloca(cBytes);
    status = GetConfigurationName(
                        DSCONFIGNAME_DS_SVC_CONFIG,
                        &cBytes,
                        pdnDirectoryService);

    if ( STATUS_SUCCESS != status )
    {
        // Name derivation failed.
        LogUnhandledError( DIRERR_NAME_TOO_LONG );
        KCC_EXCEPT( DIRERR_NAME_TOO_LONG, status );
    }
    
    ulStayOfExecutionDays = 0;
    ulTombstoneLifetimeDays = DEFAULT_TOMBSTONE_LIFETIME;
    dirError = KccRead( pdnDirectoryService, &Sel, &pReadRes );

    if ( 0 != dirError )
    {
        if ( attributeError == dirError )
        {
            INTFORMPROB * pprob = &pReadRes->CommRes.pErrInfo->AtrErr.FirstProblem.intprob;

            if (    ( PR_PROBLEM_NO_ATTRIBUTE_OR_VAL == pprob->problem )
                 && ( DIRERR_NO_REQUESTED_ATTS_FOUND == pprob->extendedErr )
               )
            {
                // No value; use default (as set above).
                dirError = 0;
            }
        }

        if ( 0 != dirError )
        {
            KCC_LOG_READ_FAILURE( pdnDirectoryService, dirError );
            // Other error; bail.
            KCC_EXCEPT( DIRERR_MISSING_EXPECTED_ATT, dirError );
        }
    }
    else
    {
        // Read succeeded; parse returned attributes.
        for ( DWORD iAttr = 0; iAttr < pReadRes->entry.AttrBlock.attrCount; iAttr++ )
        {
            ATTR *  pattr = &pReadRes->entry.AttrBlock.pAttr[ iAttr ];

            switch ( pattr->attrTyp )
            {
            case ATT_TOMBSTONE_LIFETIME:
                Assert( 1 == pattr->AttrVal.valCount );
                Assert( sizeof( ULONG ) == pattr->AttrVal.pAVal->valLen );
                ulTombstoneLifetimeDays = *( (ULONG *) pattr->AttrVal.pAVal->pVal );
                break;
            
            case ATT_REPL_TOPOLOGY_STAY_OF_EXECUTION:
                Assert( 1 == pattr->AttrVal.valCount );
                Assert( sizeof( ULONG ) == pattr->AttrVal.pAVal->valLen );
                ulStayOfExecutionDays = *( (ULONG *) pattr->AttrVal.pAVal->pVal );
                if( 0 == ulStayOfExecutionDays ) {
                    DPRINT( 3, "Stay of Execution Disabled\n" );
                    fSkipRangeCheck = TRUE;
                }                    
                break;

            default:
                DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp );
                break;
            }
        }

        if ( ulTombstoneLifetimeDays < DRA_TOMBSTONE_LIFE_MIN )
        {
            // Invalid value; use default.
            ulTombstoneLifetimeDays = DEFAULT_TOMBSTONE_LIFETIME;
        }
    }

    if( ! fSkipRangeCheck ) {
    
        // Calculate max stay of execution based on runtime value of tombstone life
        // DRA_TOMBSTONE_LIFE_MIN/2 <= DEFAULT_STAY_OF_EXECUTION <= tombstone-lifetime/2
    
        ulStayOfExecutionDaysMax = (ulTombstoneLifetimeDays / 2);

        // If stay is not specified, or is too small or too large
        if ( (ulStayOfExecutionDays < (DRA_TOMBSTONE_LIFE_MIN / 2) ) ||
             (ulStayOfExecutionDays > ulStayOfExecutionDaysMax) ) {
            
            // Use the default stay, unless that, too, is too large
            if ( DEFAULT_STAY_OF_EXECUTION <= ulStayOfExecutionDaysMax ) {
                 Assert( DEFAULT_STAY_OF_EXECUTION >= (DRA_TOMBSTONE_LIFE_MIN / 2) );
                 ulStayOfExecutionDays = DEFAULT_STAY_OF_EXECUTION;
            } else {
                ulStayOfExecutionDays = ulStayOfExecutionDaysMax;
            }
        }
    
        Assert( ulStayOfExecutionDays );
    
        DPRINT1( 5, "Stay of Execution days = %d\n", ulStayOfExecutionDays );
        
    }

    // Calculate number of seconds and store in cache
    m_fReadStayOfExecution = TRUE;
    m_dwStayOfExecution = ( ulStayOfExecutionDays * 24 * 60 * 60 );
    return m_dwStayOfExecution;
}

KCC_DSA_LIST*
KCC_DS_CACHE::GetGlobalDSAListByGUID()
// Retrieves a list of all DSAs in the enterprise, sorted by GUID
{
    Assert(IsValid());
    if(!m_globalDSAListByGUID) {
        m_globalDSAListByGUID = new KCC_DSA_LIST;
        m_globalDSAListByGUID->InitUnionOfSites(
                                    GetSiteList(),
                                    KCC_DSA::CompareIndirectByNtdsDsaGuid );

    }
    return m_globalDSAListByGUID;
}

KCC_DSA_LIST*
KCC_DS_CACHE::GetGlobalDSAListByString()
// Retrieves a list of all DSAs in the enterprise, sorted by string-name
{
    Assert(IsValid());
    if(!m_globalDSAListByString) {
        m_globalDSAListByString = new KCC_DSA_LIST;
        m_globalDSAListByString->InitUnionOfSites(
                                   GetSiteList(),
                                   KCC_DSA::CompareIndirectByNtdsDsaString );
    }
    return m_globalDSAListByString;
}

// Indicates that all sites have been marked as reachable / unreachable.
VOID
KCC_DS_CACHE::SetReachableMarkingComplete()
{
    m_fReachableMarkingComplete = TRUE;
}

// Checks if the KCC has finished marking all sites as reachable / unreachable
BOOL
KCC_DS_CACHE::IsReachableMarkingComplete()
{
    return m_fReachableMarkingComplete;
}


#if DBG
BOOL
KCC_DS_CACHE::GetAltIdentity(
    OUT DSNAME ** ppAltDsa
    )
//
// Hook to allow KCC to be run as if it were on a different DC.
// This is primarily here to support CDermody's scalability testing.
//
{
    ATTR rgAttrs[] = {
        { ATT_OBJ_DIST_NAME, {0, NULL} }
    };

    ENTINFSEL Sel = {
        EN_ATTSET_LIST,
        { sizeof(rgAttrs)/sizeof(rgAttrs[0]), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    DWORD         winError;
    DSNAME *      pAltDsa;
    ULONG         dirError;
    READRES *     pResults;
    ATTRBLOCK *   pAttrBlock;

    pAltDsa = GetConfigDsName(MAKE_WIDE(KCC_RUN_AS_NTDSDSA_DN));
    if (!pAltDsa) {
        DPRINT(5, "No alternate identity defined.\n");
        return FALSE;
    }

    Assert(0 == pAltDsa->SidLen);
    Assert(fNullUuid(&pAltDsa->Guid));

    dirError = KccRead(pAltDsa, &Sel, &pResults);
    if (0 != dirError) {
        DPRINT2(0, "Error %d reading %ls; alternate identity will be ignored.\n",
                dirError, pAltDsa->StringName);
        KCC_LOG_READ_FAILURE( pAltDsa, dirError );
        THFree(pAltDsa);
        return FALSE;
    }

    pAttrBlock = &pResults->entry.AttrBlock;
    Assert(1 == pAttrBlock->attrCount);
    Assert(ATT_OBJ_DIST_NAME == pAttrBlock->pAttr->attrTyp);
    Assert(1 == pAttrBlock->pAttr->AttrVal.valCount);

    *ppAltDsa = (DSNAME *) pAttrBlock->pAttr->AttrVal.pAVal->pVal;

    Assert(pAttrBlock->pAttr->AttrVal.pAVal->valLen == (*ppAltDsa)->structLen);

    DPRINT1(0, "KCC running under alternate identity %ls.\n", (*ppAltDsa)->StringName);

    //
    // Cleanup
    //
    THFree(pAltDsa);

    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kccconn.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccconn.cxx

ABSTRACT:

    KCC_CONNECTION and KCC_CONNECTION_LIST classes.

DETAILS:

    These classes represent a single NTDS-Connection DS object and a
    collection thereof, resp.

    NTDS-Connection objects represent a uni-directional replication link,
    with the parent server object being the destination and the From-Server
    attribute holding the source.

CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include <sddl.h>
#include "kcc.hxx"
#include "kcctrans.hxx"
#include "kccconn.hxx"
#include "kcclink.hxx"
#include "kccdsa.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include "kcccref.hxx"
#include "kccstale.hxx"
#include "kccsite.hxx"
#include <dsutil.h>
#include <winsock.h>                    // host <--> net long conversions

extern "C"
{
#include "permit.h"
}


#define FILENO FILENO_KCC_KCCCONN


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_CONNECTION methods
//

ATTR KCC_CONNECTION::AttrList[7] = {
    { ATT_ENABLED_CONNECTION,           { 0, NULL } },
    { ATT_FROM_SERVER,                  { 0, NULL } },
    { ATT_OPTIONS,                      { 0, NULL } },
    { ATT_SCHEDULE,                     { 0, NULL } },
    { ATT_WHEN_CREATED,                 { 0, NULL } },
    { ATT_TRANSPORT_TYPE,               { 0, NULL } },
    { ATT_MS_DS_REPLICATES_NC_REASON,   { 0, NULL } }
    // If adding or removing entries from this list, be sure to update array
    // size in kccconn.hxx.
};

DSNAME *
KCC_CONNECTION::GetConnectionDN()
//
// Retrieve the DN of the corresponding NTDS-Connection DS object.
//
{
    ASSERT_VALID( this );
    return m_pdnConnection;
}

DSNAME *
KCC_CONNECTION::GetSourceDSADN()
//
// Retrieve the DN of the source DSA's NTDS-DSA DS object.
//
{
    ASSERT_VALID( this );
    return m_pSourceDSA->GetDsName();
}

KCC_DSA *
KCC_CONNECTION::GetSourceDSA()
//
// Retrieve the source DSA's NTDS-DSA DS object.
//
{
    ASSERT_VALID( this );
    return m_pSourceDSA;
}

DSNAME *
KCC_CONNECTION::GetSourceSiteDN()
//
// Retrieve the DN of the source DSA's site object.
//
{
    ASSERT_VALID(this);

    return m_pSourceDSA->GetSiteDN();
}

DSNAME *
KCC_CONNECTION::GetDestinationDSADN()
//
// Retrieve the DN of the destination DSA's NTDS-DSA DS object.
//
{
    KCC_DSA *pDsa;
    
    ASSERT_VALID(this);
    
    if (NULL == m_pdnDestinationDSA) {
        Assert(m_pdnConnection && "Can't currently call this if obj not yet added!");
    
        // Destination ntdsDsa is the parent of the ntdsConnection object.
        m_pdnDestinationDSA = (DSNAME *) new BYTE[m_pdnConnection->structLen];
        TrimDSNameBy(m_pdnConnection, 1, m_pdnDestinationDSA);

        // Need to find the GUID for the destination DSA DN. Try to find an
        // in-memory KCC_DSA object for this DSA.

        // We can quickly find the KCC_DSA object in our global list of DSAs.
        pDsa = gpDSCache->GetGlobalDSAListByString()
                        ->GetDsa( m_pdnDestinationDSA, NULL );
        if( pDsa ) {
            memcpy( &m_pdnDestinationDSA->Guid,
                    &pDsa->GetDsName()->Guid,
                    sizeof(UUID) );
        } else {
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_KCC_DESTINATION_DSA_NOT_FOUND,
                szInsertDN( m_pdnConnection ),
                0,
                0
                );
            KCC_EXCEPT(ERROR_DS_OBJ_NOT_FOUND, 0);
        }

    }

    return m_pdnDestinationDSA;
}

BOOL
KCC_CONNECTION::IsEnabled()
//
// Is the connection enabled?
//
{
    ASSERT_VALID( this );
    return !!m_fIsEnabled;
}

BOOL
KCC_CONNECTION::IsIntrasite()
//
// Is this an intra-site connection?
// This is determined by checking if the source DSA is in the local site.
//
{
    // Note that we implicitly assume here that all connections loaded have their
    // destination DSA in the local site. In the future, we may load connections
    // from other sites as well.
    return NamePrefix( gpDSCache->GetLocalSite()->GetObjectDN(), GetSourceDSADN() );
}

BOOL
KCC_CONNECTION::IsGenerated()
//
// Was the connection generated by the KCC (as opposed to being created by
// an administrator)?
//
{
    ASSERT_VALID( this );
    return !!( m_dwOptions & NTDSCONN_OPT_IS_GENERATED );
}

BOOL
KCC_CONNECTION::IsTwoWaySynced()
//
// Does completion of a sync of this NC trigger a sync in the opposite
// direction?
//
{
    ASSERT_VALID(this);
    return !!(m_dwOptions & NTDSCONN_OPT_TWOWAY_SYNC);
}

BOOL
KCC_CONNECTION::IsCompressionEnabled()
//
// Is compression enabled over this connection? 
// For intra-site connections, compression is never enabled.
// For inter-site connections, compression is enabled unless the option
// has been set to disable it.
//
{
    ASSERT_VALID(this);
    if( IsIntrasite() ) {
        return FALSE;
    } else {
        return !(m_dwOptions & NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION);
    }
}

BOOL
KCC_CONNECTION::UsesNotification()
//
// Override the default notification based on intra/inter site.
// Force the notification to be as specified
//
{
    BOOL fUsesNotification;
    ASSERT_VALID(this);

    if (m_dwOptions & NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT) {
        fUsesNotification = !!(m_dwOptions & NTDSCONN_OPT_USE_NOTIFY);
    } else {
        // True if in same site
        fUsesNotification = IsIntrasite();
    }

    return fUsesNotification;
}

TOPL_SCHEDULE
KCC_CONNECTION::GetSchedule()
//
// Retrieve the periodic replication schedule.
//
{
    ASSERT_VALID( this );
    return m_toplSchedule;
}

KCC_CONNECTION &
KCC_CONNECTION::SetConnectionDN(
    IN  DSNAME *    pdn
    )
//
// Set the DN of the corresponding NTDS-Connection DS object.
//
{
    m_pdnConnection = (DSNAME *) new BYTE[ pdn->structLen ];
    memcpy( m_pdnConnection, pdn, pdn->structLen );

    return *this;
}
    
KCC_CONNECTION &
KCC_CONNECTION::SetSourceDSA(
    IN KCC_DSA *pDsa
    )
//
// Set the DN of the source DSA's NTDS-DSA DS object.
//
{
    m_pSourceDSA = pDsa;

    return *this;
}
    
KCC_CONNECTION &
KCC_CONNECTION::SetEnabled(
    IN  BOOL    fIsEnabled
    )
//
// Set the is-enabled flag to the given value.
//
{
    m_fIsEnabled = !!fIsEnabled;

    return *this;
}

KCC_CONNECTION &
KCC_CONNECTION::SetGenerated(
    IN  BOOL    fIsGenerated
    )
//
// Set the is-generated flag to the given value.
//
{
    if ( fIsGenerated )
    {
        m_dwOptions |= NTDSCONN_OPT_IS_GENERATED;
    }
    else
    {
        m_dwOptions &= ~NTDSCONN_OPT_IS_GENERATED;
    }

    m_fUpdatedOptions = TRUE;

    return *this;
}

KCC_CONNECTION &
KCC_CONNECTION::SetOverrideNotification(
    IN  BOOL    fUsesNotification
    )
//
// Override the default notification of the connection
//
{
    m_dwOptions |= NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT;
    if ( fUsesNotification )
    {
        m_dwOptions |= NTDSCONN_OPT_USE_NOTIFY;
    }
    else
    {
        m_dwOptions &= ~NTDSCONN_OPT_USE_NOTIFY;
    }

    m_fUpdatedOptions = TRUE;

    return *this;
}

KCC_CONNECTION &
KCC_CONNECTION::SetTwoWaySync(
    IN  BOOL    fIsTwoWaySync
    )
//
// Set the TwoWaySync'd state of the connection
//
{
    if ( fIsTwoWaySync )
    {
        m_dwOptions |= NTDSCONN_OPT_TWOWAY_SYNC;
    }
    else
    {
        m_dwOptions &= ~NTDSCONN_OPT_TWOWAY_SYNC;
    }

    m_fUpdatedOptions = TRUE;

    return *this;
}

KCC_CONNECTION &
KCC_CONNECTION::SetDisableIntersiteCompression(
    IN  BOOL    fDisableCompression
    )
//
// If this flag is set, compression of replication traffic across
// this connection is disabled. This function may only be called
// for inter-site connections.
//
{
    if ( fDisableCompression )
    {
        m_dwOptions |= NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION;
    }
    else
    {
        m_dwOptions &= ~NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION;
    }

    m_fUpdatedOptions = TRUE;

    return *this;
}

KCC_CONNECTION &
KCC_CONNECTION::SetSchedule(
    IN  TOPL_SCHEDULE toplSchedule
    )
//
// Set the periodic replication schedule.
//
{
    Assert( ToplScheduleValid(toplSchedule) );
    m_toplSchedule = toplSchedule;
    m_fUpdatedSchedule = TRUE;
    return *this;
}

BOOL
KCC_CONNECTION::IsValid()
//
// Is this object internally consistent?
//
{
    return ( NULL != m_pSourceDSA );
}

BOOL
KCC_CONNECTION::Init(
    IN  ENTINF *    pEntInf
    )
//
// Initialize the internal object from an ENTINF describing a corresponding
// NTDS-Connection DS object.
//
{
    DWORD   iAttr, iAttrVal;
    ATTR *  pAttr;
    DWORD   cbVal;
    BYTE *  pbVal;
    DSNAME *pdnSourceDSA = NULL;

    Reset();

    m_pdnConnection = (DSNAME *) new BYTE[ pEntInf->pName->structLen ];
    memcpy( m_pdnConnection, pEntInf->pName, pEntInf->pName->structLen );
    DPRINT1( 5, "Parsing connection %ls.\n", m_pdnConnection->StringName );

    for ( iAttr = 0; iAttr < pEntInf->AttrBlock.attrCount; iAttr++ )
    {
        pAttr = &pEntInf->AttrBlock.pAttr[ iAttr ];
        cbVal = pAttr->AttrVal.pAVal->valLen;
        pbVal = pAttr->AttrVal.pAVal->pVal;

        switch ( pAttr->attrTyp )
        {
        case ATT_ENABLED_CONNECTION:
            Assert( 1 == pAttr->AttrVal.valCount );
            Assert( cbVal == sizeof( m_fIsEnabled ) );
            memcpy( &m_fIsEnabled, pbVal, sizeof( m_fIsEnabled ) );
            break;

        case ATT_FROM_SERVER:
            Assert( 1 == pAttr->AttrVal.valCount );
            pdnSourceDSA = (DSNAME*) pbVal;
            break;

        case ATT_OPTIONS:
            Assert( 1 == pAttr->AttrVal.valCount );
            Assert( cbVal == sizeof( m_dwOptions ) );
            memcpy( &m_dwOptions, pbVal, sizeof( m_dwOptions ) );
            break;

        case ATT_SCHEDULE:
            Assert( 1 == pAttr->AttrVal.valCount );
            if( IS_VALID_SCHEDULE((PSCHEDULE) pbVal) ) {

                // Schedule is okay. Load it into the cache and store it in
                // this connection object.
                m_toplSchedule = ToplScheduleImport(
                    gpDSCache->GetScheduleCache(),
                    (PSCHEDULE) pbVal );

            } else {
                // improper schedule format - default schedule used; complain 
                LogEvent(
                    DS_EVENT_CAT_KCC,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_CHK_BAD_SCHEDULE,
                    szInsertDN( m_pdnConnection ),
                    0,
                    0
                    );

                DPRINT1(
                    0,
                    "The value of the schedule attribute on the connection "
                        "object %ls is invalid.  A default schedule will be "
                        "substituted.\n",
                    m_pdnConnection->StringName
                    );

                m_toplSchedule = NULL;
            }
            break;

        case ATT_WHEN_CREATED:
            Assert( 1 == pAttr->AttrVal.valCount );
            Assert( cbVal == sizeof( m_timeCreated ) );
            memcpy( &m_timeCreated, pbVal, sizeof( m_timeCreated ) );
            break;

        case ATT_TRANSPORT_TYPE:
            Assert( 1 == pAttr->AttrVal.valCount );
            m_pdnTransport = (DSNAME*) new BYTE[ cbVal ];
            memcpy( m_pdnTransport, pbVal, cbVal );
            break;

        case ATT_MS_DS_REPLICATES_NC_REASON:
            m_pOldNCs = new DN_AND_REASON[ pAttr->AttrVal.valCount ];
            m_cOldNCs = pAttr->AttrVal.valCount;
            for ( iAttrVal = 0; iAttrVal < m_cOldNCs; iAttrVal++ )
            {
                SYNTAX_DISTNAME_BINARY *pdnb;
                DSNAME *pdn;
                SYNTAX_ADDRESS *psa;
                DWORD  dwTemp;

                pdnb = (SYNTAX_DISTNAME_BINARY *) pAttr->AttrVal.pAVal[ iAttrVal ].pVal;

                // Retrieve the dsname part.
                pdn = NAMEPTR(pdnb);
                m_pOldNCs[ iAttrVal ].dn = (DSNAME *) new BYTE [pdn->structLen];
                memcpy( m_pOldNCs[ iAttrVal ].dn, pdn, pdn->structLen );

                // Extract the binary blob part                
                psa = DATAPTR(pdnb);
                
                // Check that the binary blob is at least as long as we expect.
                Assert(psa->structLen >= 2*sizeof(DWORD)); // Length + Data DWORD
                if( psa->structLen < 2*sizeof(DWORD) ) {
                    KCC_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
                }
                
                // Copy the data to a temp variable to avoid alignment problems,
                // then convert to 'host' byte-ordering.
                memcpy(&dwTemp, &psa->byteVal[0], sizeof(DWORD));
                m_pOldNCs[ iAttrVal ].reason = (DWORD) ntohl(dwTemp);
            }
            break;

        default:
            DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pAttr->attrTyp );
            break;
        }
    }

    // Initialize the DSA. We have the guidded DSA name. The problem is that
    // the DSA lists are site specific, and we don't have a pSite, so we
    // have to compute one.

    // Defense against deleted DSA's. We look up the DSA by guid in the cache.
    // The DSA should not be in the cache if it is deleted, since the
    // cache is populated using a search of the site servers container, and a
    // deleted DSA would reside in the deleted objects container.

    if (pdnSourceDSA) {
        KCC_SITE *pSite;
        DSNAME *pdnSourceSite;

        // Allocate a DSNAME for the site name
        pdnSourceSite = (DSNAME *) new BYTE[ pdnSourceDSA->structLen ];

        // Syntactically convert the DSA DN to a Site DN without a guid
        TrimDSNameBy(pdnSourceDSA, 3, pdnSourceSite);

        // Guid-less name lookup is ok here
        pSite = gpDSCache->GetSiteList()->GetSite( pdnSourceSite );
        // pSite may be NULL if site renamed concurrently

        delete [] pdnSourceSite;

        if (pSite) {
            m_pSourceDSA = pSite->GetDsaList()->GetDsa( pdnSourceDSA );
            // m_pSourceDSA may be null if DSA not found, deleted, etc.
        }
    }

    if ( IsValid() )
    {
        // A connection object must store the DN of its destination DSA,
        // (including the GUID). In order to find the DN+GUID, we trim the name and
        // read the directory. This presents a race condition, since the connection
        // object and the destination DSA are read from the directory in two
        // transations. If we postpone construction of the destination DSA DN until
        // it is needed (i.e. read on demand) then we increase the severity of the
        // race condition. We mitigate the severity by reading it as soon as possible.
        GetDestinationDSADN();

        // We don't want to permit KCC-Generated connection with the NEVER
        // schedule. If we see this, we set it to the Always schedule.
        if( IsGenerated() && ToplScheduleDuration(m_toplSchedule)==0 ) {
            m_toplSchedule = ToplGetAlwaysSchedule( gpDSCache->GetScheduleCache() );
        }

        return TRUE;
    }
    else
    {
        // WARNING: A FALSE return implies the KCC_CONNECTION_LIST::Init()
        // routine should delete this NTDS-Connection object from the DIT.
        DPRINT1( 4, "Connection %ls is invalid.\n", m_pdnConnection->StringName );
        return FALSE;
    }
}

DWORD
KCC_CONNECTION::Add(
    DSNAME *    pdnDestinationDSA
    )
//
// Convert to an NTDS-Connection DS object and write it to the DS.
// If the connection object DN has not been set, it will be constructed
// from the pdnDSA argument and a unique RDN.
//
{
    ULONG           dirError;
    DWORD           WinError;
    DWORD           dwConnectionClass = CLASS_NTDS_CONNECTION;
    ATTRBLOCK       AttrBlock;
    ATTR            rgAttr[ 6 ];
    ATTRVALBLOCK    rgAttrValBlock[ 6 ];
    ATTRVAL         rgAttrVal[ 6 ];
    DSNAME *        pdnSourceDSA;

    ASSERT_VALID( this );

    Assert( NTDSCONN_OPT_IS_GENERATED & m_dwOptions );

    if ( NULL == m_pdnConnection )
    {
        //
        // Generate unique RDN.
        //

        RPC_STATUS      rpcStatus;
        UUID            uuid;
        UCHAR *         pszUuid;
        WCHAR           rgchRdn[ MAX_RDN_SIZE ];
        DWORD           cchRdn;

        rpcStatus = UuidCreate( &uuid );
        
        // Note: Global uniqueness is not really critical here -- we only seek
        // to make sure the RDN is unique in its container.  Thus, "local only"
        // UUIDs are okay.  (If a collision occurs, the add will fail, and we'll
        // try again next time -- with a different UUID.)

        if (    ( RPC_S_OK              != rpcStatus )
             && ( RPC_S_UUID_LOCAL_ONLY != rpcStatus )
           )
        {
            KCC_EXCEPT( rpcStatus, 0 );
        }

        rpcStatus = UuidToString( &uuid, &pszUuid );
        if ( RPC_S_OK != rpcStatus )
        {
            KCC_EXCEPT( rpcStatus, 0 );
        }

        cchRdn = MultiByteToWideChar(
                    CP_TELETEX,
                    0,
                    (char *) pszUuid,
                    -1,
                    rgchRdn,
                    sizeof( rgchRdn ) / sizeof( rgchRdn[ 0 ] )
                    );
        if ( 0 == cchRdn )
        {
            KCC_EXCEPT( GetLastError(), 0 );
        }
        DWORD cbConnectionDN =  pdnDestinationDSA->structLen +
                      ( MAX_RDN_SIZE+MAX_RDN_KEY_SIZE )*sizeof(WCHAR);
        m_pdnConnection = (DSNAME *) new BYTE[ cbConnectionDN ];
        AppendRDN( pdnDestinationDSA,
                  m_pdnConnection,
                  cbConnectionDN,
                  rgchRdn,
                  cchRdn - 1,
                  ATT_COMMON_NAME );
    }

    //
    // Add NTDS-Connection object to the DS.
    //
    ULONG cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    TOPL_SCHEDULE_CACHE scheduleCache = gpDSCache->GetScheduleCache();
    PSCHEDULE pSchedule;
    Assert( scheduleCache );
    pSchedule = ToplScheduleExportReadonly( scheduleCache, m_toplSchedule );
    Assert( pSchedule );

    pdnSourceDSA = m_pSourceDSA->GetDsName();

    AttrBlock.attrCount = 6;
    AttrBlock.pAttr     = new ATTR [AttrBlock.attrCount];

    AttrBlock.pAttr[ 0 ].attrTyp          = ATT_ENABLED_CONNECTION;
    AttrBlock.pAttr[ 0 ].AttrVal.valCount = 1;
    AttrBlock.pAttr[ 0 ].AttrVal.pAVal    = &rgAttrVal[ 0 ];
    rgAttrVal[ 0 ].valLen                 = sizeof( m_fIsEnabled );
    rgAttrVal[ 0 ].pVal                   = (BYTE *) &m_fIsEnabled;

    AttrBlock.pAttr[ 1 ].attrTyp          = ATT_FROM_SERVER;
    AttrBlock.pAttr[ 1 ].AttrVal.valCount = 1;
    AttrBlock.pAttr[ 1 ].AttrVal.pAVal    = &rgAttrVal[ 1 ];
    rgAttrVal[ 1 ].valLen                 = pdnSourceDSA->structLen;
    rgAttrVal[ 1 ].pVal                   = (BYTE *) pdnSourceDSA;

    AttrBlock.pAttr[ 2 ].attrTyp          = ATT_OPTIONS;
    AttrBlock.pAttr[ 2 ].AttrVal.valCount = 1;
    AttrBlock.pAttr[ 2 ].AttrVal.pAVal    = &rgAttrVal[ 2 ];
    rgAttrVal[ 2 ].valLen                 = sizeof( m_dwOptions );
    rgAttrVal[ 2 ].pVal                   = (BYTE *) &m_dwOptions;

    AttrBlock.pAttr[ 3 ].attrTyp          = ATT_SCHEDULE;
    AttrBlock.pAttr[ 3 ].AttrVal.valCount = 1;
    AttrBlock.pAttr[ 3 ].AttrVal.pAVal    = &rgAttrVal[ 3 ];
    rgAttrVal[ 3 ].valLen                 = cbSchedule;
    rgAttrVal[ 3 ].pVal                   = (BYTE *) pSchedule;

    AttrBlock.pAttr[ 4 ].attrTyp          = ATT_OBJECT_CLASS;
    AttrBlock.pAttr[ 4 ].AttrVal.valCount = 1;
    AttrBlock.pAttr[ 4 ].AttrVal.pAVal    = &rgAttrVal[ 4 ];
    rgAttrVal[ 4 ].valLen                 = sizeof( dwConnectionClass );
    rgAttrVal[ 4 ].pVal                   = (BYTE *) &dwConnectionClass;

    if ( m_pdnTransport )
    {
        AttrBlock.pAttr[ 5 ].attrTyp          = ATT_TRANSPORT_TYPE;
        AttrBlock.pAttr[ 5 ].AttrVal.valCount = 1;
        AttrBlock.pAttr[ 5 ].AttrVal.pAVal    = &rgAttrVal[ 5 ];
        rgAttrVal[ 5 ].valLen                 = m_pdnTransport->structLen;
        rgAttrVal[ 5 ].pVal                   = (BYTE *) m_pdnTransport;
    }
    else
    {
        //
        // No transport type attribute to add
        //
        AttrBlock.attrCount--;
    }


    dirError = KccAddEntry( m_pdnConnection, &AttrBlock );
    if (dirError != 0 ) {
        KCC_LOG_ADDENTRY_FAILURE( m_pdnConnection, dirError );
    }
    
    return dirError;
}


DWORD
KCC_CONNECTION::UpdateDS()
//
// Update the ntdsConnection object in the DS with recent changes made to the
// in-memory KCC_CONNECTION representation.
//
{
    ATTRMODLIST rgMods[3] = {0};
    ATTRVAL     rgAttrVals[3] = {0};
    DWORD       dirError;
    USHORT      cNumMods = 0;
    const DWORD cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    PSCHEDULE   pSchedule;


    Assert(m_fUpdatedOptions
           || m_fUpdatedSchedule 
           || m_fUpdatedTransport);

    if (m_fUpdatedOptions) {
        rgMods[cNumMods].choice                   = AT_CHOICE_REPLACE_ATT;
        rgMods[cNumMods].AttrInf.attrTyp          = ATT_OPTIONS;
        rgMods[cNumMods].AttrInf.AttrVal.valCount = 1;
        rgMods[cNumMods].AttrInf.AttrVal.pAVal    = &rgAttrVals[cNumMods];
        
        rgAttrVals[cNumMods].valLen = sizeof(m_dwOptions);
        rgAttrVals[cNumMods].pVal   = (BYTE *) &m_dwOptions;

        if (cNumMods) {
            rgMods[cNumMods-1].pNextMod = &rgMods[cNumMods];
        }

        cNumMods++;
    }
    
    if (m_fUpdatedSchedule) {
        TOPL_SCHEDULE_CACHE scheduleCache = gpDSCache->GetScheduleCache();
        Assert( scheduleCache );
        pSchedule = ToplScheduleExportReadonly( scheduleCache, m_toplSchedule );
        Assert( pSchedule );
        
        rgMods[cNumMods].choice                   = AT_CHOICE_REPLACE_ATT;
        rgMods[cNumMods].AttrInf.attrTyp          = ATT_SCHEDULE;
        rgMods[cNumMods].AttrInf.AttrVal.valCount = 1;
        rgMods[cNumMods].AttrInf.AttrVal.pAVal    = &rgAttrVals[cNumMods];
        
        rgAttrVals[cNumMods].valLen = cbSchedule;
        rgAttrVals[cNumMods].pVal   = (BYTE *) pSchedule;

        if (cNumMods) {
            rgMods[cNumMods-1].pNextMod = &rgMods[cNumMods];
        }

        cNumMods++;
    }

    if (m_fUpdatedTransport) {
        if (NULL == m_pdnTransport) {
            // Transport removed (i.e., changed from inter-site to intra-site).
            rgMods[cNumMods].choice          = AT_CHOICE_REMOVE_ATT;
            rgMods[cNumMods].AttrInf.attrTyp = ATT_TRANSPORT_TYPE;
        } else {
            // Transport added/updated.
            rgMods[cNumMods].choice                   = AT_CHOICE_REPLACE_ATT;
            rgMods[cNumMods].AttrInf.attrTyp          = ATT_TRANSPORT_TYPE;
            rgMods[cNumMods].AttrInf.AttrVal.valCount = 1;
            rgMods[cNumMods].AttrInf.AttrVal.pAVal    = &rgAttrVals[cNumMods];
            
            rgAttrVals[cNumMods].valLen = m_pdnTransport->structLen;
            rgAttrVals[cNumMods].pVal   = (BYTE *) m_pdnTransport;
        }

        if (cNumMods) {
            rgMods[cNumMods-1].pNextMod = &rgMods[cNumMods];
        }

        cNumMods++;
    }
        
    Assert(cNumMods <= ARRAY_SIZE(rgMods));
    Assert(cNumMods <= ARRAY_SIZE(rgAttrVals));

    dirError = KccModifyEntry(GetConnectionDN(), cNumMods, rgMods);

    if (0 == dirError) {
        // Success.
        DPRINT1(0, "Updated connection object %ws.\n",
                GetConnectionDN()->StringName);
        m_fUpdatedOptions = m_fUpdatedSchedule = m_fUpdatedTransport = FALSE;
    } else {
        // Failure.
        KCC_LOG_MODIFYENTRY_FAILURE(GetConnectionDN(), dirError);
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }

    return dirError;
}


KCC_CONNECTION &
KCC_CONNECTION::SetTransport(
        IN DSNAME *pdn
        )
// Set transport associated with this connection.
{
    m_pdnTransport = pdn;

    m_fUpdatedTransport = TRUE;
    
    return *this;
}

DSNAME*
KCC_CONNECTION::GetTransportDN()
// Get the transport associated with this connection.
{
    return m_pdnTransport;
}

DWORD
KCC_CONNECTION::Remove(
        VOID
        )
//
// Remove the connection object from the ds. Note that the in memory copy of the
// object remains.
//
{
    ULONG dirError;

    ASSERT_VALID( this );

    dirError = KccRemoveEntry( m_pdnConnection );
    if (0 == dirError) {
        // Success.
        DPRINT1(0, "Deleted connection object %ls from the database.\n",
                GetConnectionDN()->StringName);
        
        LogEvent(DS_EVENT_CAT_KCC,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_KCC_CONNECTION_OBJECT_DELETED,
                 szInsertDN(GetSourceDSADN()),
                 szInsertDN(GetDestinationDSADN()),
                 0);
    }
    else {
        // Failure.
        KCC_LOG_REMOVEENTRY_FAILURE( m_pdnConnection, dirError );

        LogEvent(DS_EVENT_CAT_KCC,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_KCC_CONNECTION_OBJECT_DELETION_FAILED,
                 szInsertDN(GetSourceDSADN()),
                 szInsertDN(GetDestinationDSADN()),
                 0);
    }

    return dirError;
}

void
KCC_CONNECTION::UpdateLink(
    IN  KCC_LINK *              plink,
    IN  KCC_CROSSREF *          pCrossRef,
    IN  DSNAME *                pdnLocalSite,
    IN  KCC_TRANSPORT_LIST *    pTransportList
    )
//
// Update pre-existing repsFrom link to reflect the state of this connection
// object.
//
{
    BOOL fUpdateLink = FALSE;
    BOOL fIsDSRPCReplica;
    BOOL fInSameSite;
    DWORD cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    SCHEDULE *pSchedule = (SCHEDULE *) alloca(cbSchedule);
    DSNAME *pdnNC = pCrossRef->GetNCDN();
    TOPL_SCHEDULE_CACHE scheduleCache = gpDSCache->GetScheduleCache();
    
    ASSERT_VALID( this );
    Assert( scheduleCache );
    Assert(0 == memcmp(plink->GetDSAUUID(), &GetSourceDSADN()->Guid, sizeof(GUID)));

    if (IsGenerated() && IsIntrasite()) {
        // Auto-generated, intra-site connection.
        
        Assert( gfIntrasiteSchedInited );
        if (!ToplScheduleIsEqual(scheduleCache,
                                 m_toplSchedule,
                                 gpIntrasiteSchedule))
        {
            // The auto-generated, intra-site connection object has the wrong
            // schedule.  Update it.
            ATTRMODLIST rgMods[1] = {0};
            ATTRVAL     AttrVal;
            ULONG       dirError;
        
            Assert( gfIntrasiteSchedInited );
            SetSchedule(gpIntrasiteSchedule);

            UpdateDS();

            DPRINT1(0, "Updated intra-site schedule on %ls.\n",
                    GetConnectionDN()->StringName);

            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CHK_UPDATED_SCHEDULE,
                     szInsertDN(GetConnectionDN()),
                     szInsertDN(GetSourceDSADN()),
                     szInsertDN(GetDestinationDSADN()));
        }
    }

    REPLTIMES *linkRT, *connRT;

    linkRT = plink->GetSchedule();
    connRT = KccConvertToplScheduleToReplTimes( m_toplSchedule );

    if ( 0 != memcmp( linkRT, connRT, sizeof(REPLTIMES) ) )
    {
        // update schedule
        DPRINT2(
            0,
            "Updating schedule in Reps-From %hs on %ls.\n",
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetSchedule( connRT );
        fUpdateLink = TRUE;
    }

    // Free the REPLTIMES structure that was allocated
    delete[] connRT;

    if ( plink->IsEnabled() != IsEnabled() )
    {
        // update enabled flag
        DPRINT3(
            0,
            "Changing Enabled flag to 0x%x in Reps-From %hs on %ls.\n",
            IsEnabled(),
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetEnabled( IsEnabled() );
        fUpdateLink = TRUE;
    }

    if ( IsIntrasite() )
    {
        // DSAs in the same site always replicate via DS RPC
        fIsDSRPCReplica = TRUE;
        fInSameSite = TRUE;
    }
    else
    {
        // DSAs in different sites can replicate via RPC or mail.
        // Intersite IP connections send/receive using DS RPC,
        // though we still use the ISM IP plug-in for topology
        // queries.
        fIsDSRPCReplica = (NULL == GetTransportDN())
                          || IsOverIntersiteIP();
        fInSameSite = FALSE;
    }

    if ( fIsDSRPCReplica != plink->IsDSRPCReplica() )
    {
        // update mail replica flag
        DPRINT3(
            0,
            "Changing Is-DS-RPC-Replica flag to 0x%x in Reps-From %hs on %ls.\n",
            fIsDSRPCReplica,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetDSRPCReplica( fIsDSRPCReplica );
        fUpdateLink = TRUE;
    }

    DSNAME * pdnTransport = NULL;

    if (fIsDSRPCReplica) {
        // fIsDSRPCReplica trumps GetTransportDN()
        Assert( pdnTransport == NULL );

        // Note that the call to UpdateRepsFromRef in ReplicateNC expects that
        // the transport uuid is fNullUuid for RPC-based links
        if (!fNullUuid( plink->GetTransportUUID() )) {
            // update transport
            DPRINT2(
                0,
                "Changing transport in Reps-From %hs on %ls to NULL for RPC link.\n",
                plink->GetDSAAddr()->mtx_name,
                pdnNC->StringName
                );
            plink->SetTransportUUID( &gNullUuid );
            fUpdateLink = TRUE;
        }
    } else {
        pdnTransport = GetTransportDN();
        Assert( pdnTransport != NULL );
        if ( (pdnTransport != NULL) &&
             (0 != memcmp(&pdnTransport->Guid,
                          plink->GetTransportUUID(),
                          sizeof(UUID)))) {
            // update transport
            DPRINT3(
                0,
                "Changing transport in Reps-From %hs on %ls to %ls.\n",
                plink->GetDSAAddr()->mtx_name,
                pdnNC->StringName,
                pdnTransport->StringName
                );
            plink->SetTransportUUID( &pdnTransport->Guid );
            fUpdateLink = TRUE;
        }
    }

    BOOL fIsPeriodic = ( 0 != ToplScheduleDuration(m_toplSchedule) );
    if ( fIsPeriodic != plink->IsPeriodicSynced() )
    {
        // update periodic flag
        DPRINT3(
            0,
            "Changing Periodic-Sync flag to 0x%x in Reps-From %hs on %ls.\n",
            fIsPeriodic,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetPeriodicSync( fIsPeriodic );
        fUpdateLink = TRUE;
    }

    BOOL fUseCompression=IsCompressionEnabled();
    if ( fUseCompression != plink->UsesCompression() )
    {
        // update compression flag
        DPRINT3(
            0,
            "Changing Use-Compression flag to 0x%x in Reps-From %hs on %ls.\n",
            fUseCompression,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetCompression( fUseCompression );
        fUpdateLink = TRUE;
    }

    BOOL fIsNeverNotified = !UsesNotification();

    if ( fIsNeverNotified != plink->IsNeverNotified() )
    {
        // update is-never-notified flag
        DPRINT3(
            0,
            "Changing Is-Never-Notified flag to 0x%x in Reps-From %hs on %ls.\n",
            fIsNeverNotified,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetNeverNotified( fIsNeverNotified );
        fUpdateLink = TRUE;
    }

    BOOL fIsInitSync = fInSameSite;

    if ( fIsInitSync != plink->IsInitSynced() )
    {
        // update init-sync flag
        DPRINT3(
            0,
            "Changing Init-Sync flag to 0x%x in Reps-From %hs on %ls.\n",
            fIsInitSync,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetInitSync( fIsInitSync );
        fUpdateLink = TRUE;
    }

    if (IsTwoWaySynced() != plink->IsTwoWaySynced()) {
        // update two-way-synced flag
        DPRINT3(0,
                "Changing Two-Way-Sync flag to 0x%x in Reps-From %hs on %ls.\n",
                IsTwoWaySynced(),
                plink->GetDSAAddr()->mtx_name,
                pdnNC->StringName);
        plink->SetTwoWaySync(IsTwoWaySynced());
        fUpdateLink = TRUE;
    }

    KCC_TRANSPORT * pTransport
        = (NULL == pdnTransport)
            ? NULL
            : pTransportList->GetTransport(pdnTransport);

    MTX_ADDR *pmtx = m_pSourceDSA->GetMtxAddr(pTransport);

    if (    ( NULL != pmtx )
         && !MtxSame( plink->GetDSAAddr(), pmtx )
       )
    {
        // update source dsa address
        DPRINT3(
            0,
            "Changing Mtx-Addr flag to %hs in Reps-From %hs on %ls.\n",
            pmtx->mtx_name,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetDSAAddr( pmtx );
        fUpdateLink = TRUE;
    }

    if ( fUpdateLink )
    {
        DWORD draError = plink->Update( pdnNC, ATT_REPS_FROM );

        if ( DRAERR_Success == draError )
        {
            DPRINT2(
                0,
                "Successfully updated link to %hs in Reps-From on %ls.\n",
                plink->GetDSAAddr()->mtx_name,
                pdnNC->StringName
                );
        }
        else
        {
            DPRINT3(
                0,
                "Failed to update link to %hs in Reps-From on %ls, DRA error %d.\n",
                plink->GetDSAAddr()->mtx_name,
                pdnNC->StringName,
                draError
                );
        }
    }
}

BOOL
KCC_CONNECTION::ShouldSkipDraAdd(
    KCC_DSA *pRemoteDSA,
    DWORD   *pdwDraError OPTIONAL
    )
//
// Check the connection failure cache for any failures communicating with
// pRemoteDSA. If an error has already occurred during this run of the KCC,
// then we decide to skip the DirReplicaAdd() since it is quite likely we will
// hit the same error again (and thus have to wait for the DirReplicaAdd() call
// to timeout).
// 
{
    DWORD draError;
    BOOL  fErrorOccurredThisRun;

    if( ! gConnectionFailureCache.Get( pRemoteDSA->GetDsName(),
                                       NULL, /* TimeSinceFirstAttempt */
                                       NULL, /* NumberOfFailures */
                                       NULL, /* fUserNotifiedOfStaleness */
                                       &draError,
                                       &fErrorOccurredThisRun ) )
    {
        // No error in the cache, so we shouldn't skip DirReplicaAdd()
        return FALSE;
    }

    if( !fErrorOccurredThisRun ) {
        // The error in the cache didn't happen during this run of the KCC
        // so we don't want to skip the DirReplicaAdd().
        return FALSE;
    }

    switch( draError ) {
        case RPC_S_SERVER_UNAVAILABLE:
        case RPC_S_SERVER_TOO_BUSY:
        case ERROR_DS_DNS_LOOKUP_FAILURE:
            // These transient errors might cause DirReplicaAdd() to take
            // a long time.
            if( pdwDraError ) {
                *pdwDraError = draError;
            }
            return TRUE;
        default:
            return FALSE;
    }

    return FALSE;
}


void
KCC_CONNECTION::AddLink(
    IN  KCC_CROSSREF *          pCrossRef,
    IN  BOOL                    fIsLocalMaster,
    IN  DSNAME *                pdnLocalSite,
    IN  KCC_DSA *               pLocalDSA,
    IN  KCC_DSA *               pRemoteDSA,
    IN  KCC_TRANSPORT_LIST *    pTransportList
    )
//
// Derive new repsFrom link from this connection object.
//
{
    DSNAME *pdnNC = pCrossRef->GetNCDN();
    BOOL fInSameSite = IsIntrasite();
    BOOL fIsDSRPCReplica;

    DPRINT3( 3, "AddLink: nc %ws isLocMaster:%d remote:%ws\n",
             pdnNC->StringName,
             fIsLocalMaster,
             pRemoteDSA->GetDsName()->StringName );

    if ( fInSameSite )
    {
        // DSAs in the same site always replicate via DS RPC
        fIsDSRPCReplica = TRUE;
        fInSameSite = TRUE;
    }
    else
    {
        // DSAs in different sites can replicate via RPC or mail.
        // Intersite IP connections send/receive using DS RPC,
        // though we still use the ISM IP plug-in for topology
        // queries.
        fIsDSRPCReplica = (NULL == GetTransportDN())
                          || IsOverIntersiteIP();
        fInSameSite = FALSE;
    }

    DSNAME * pdnTransport = GetTransportDN();
    KCC_TRANSPORT * pTransport
        = (NULL == pdnTransport)
            ? NULL
            : pTransportList->GetTransport(pdnTransport);
    LPWSTR pszTransportAddr = pRemoteDSA->GetTransportAddr(pTransport);
    LPWSTR pszLocalTransportAddr = pLocalDSA->GetTransportAddr(pTransport);
    
    if ( (NULL != pszTransportAddr) &&
         (NULL != pszLocalTransportAddr) ) {
        BOOL            fIsPeriodic;
        DWORD           dwOptions = DRS_ASYNC_REP;

        // See comments in UpdateLink regarding periodic sync criteria
        fIsPeriodic = ( 0 != ToplScheduleDuration(m_toplSchedule) );
        if ( fIsPeriodic )
        {
            // connection has a non-empty schedule, so we periodically sync
            dwOptions |= DRS_PER_SYNC;
        }

        if ( !fInSameSite )
        {
            if(IsCompressionEnabled()) {
                dwOptions |= DRS_USE_COMPRESSION;
            }
            if (!fIsDSRPCReplica) {
                dwOptions |= DRS_MAIL_REP;
            }
        }
        else
        {
            // sync RPC-based replicas on startup, too
            dwOptions |= DRS_INIT_SYNC;
        }

        if ( fIsLocalMaster )
        {
            dwOptions |= DRS_WRIT_REP;
        }

        if (IsTwoWaySynced()) {
            dwOptions |= DRS_TWOWAY_SYNC;
        }
    
        if (!UsesNotification()) {
            dwOptions |= DRS_NEVER_NOTIFY;
        }
    
        
        // Don't try to add the replica link if we have previously encountered
        // a transient error while contacting this DSA.
        DWORD draError;
        if( ShouldSkipDraAdd(pRemoteDSA, &draError) )
        {          
            DPRINT3(
                1,
                "Didn't try to add link for %ls from %ls due to previous error %d.\n",
                pdnNC->StringName,
                pszTransportAddr,
                draError
                );

            LogEvent8WithData(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_KCC_SKIPPED_DIRREPLICAADD,
                szInsertDN( pdnNC ),
                szInsertWC( pszTransportAddr ),
                szInsertWin32Msg( draError ),
                szInsertDN( pRemoteDSA->GetDsName() ),
                pdnTransport ? szInsertDN(pdnTransport) : szInsertSz(""),
                NULL,
                NULL,
                NULL,
                sizeof( draError ),
                &draError );
        
        } else {
            
            // DirReplicaAdd takes its schedules as REPLTIMES.
            // We convert our TOPL_SCHEDULE here.
            REPLTIMES* pRT;
            pRT = KccConvertToplScheduleToReplTimes(m_toplSchedule);
            Assert( NULL!=pRT );

            draError = DirReplicaAdd(
                            pdnNC,
                            pRemoteDSA->GetDsName(),
                            pdnTransport,
                            pszTransportAddr,
                            NULL,
                            pRT,
                            dwOptions
#ifdef KCC_PERF_TEST
                                // When doing KCC testing, don't want DirReplicaAdd to block
                                // when adding IP links. So we initially make them as SMTP
                                // links, // then they will get repaired on the second run. This
                                // is just a temporary workaround.
                                | DRS_ASYNC_REP | DRS_MAIL_REP
#endif
                            );

            // Free the REPLTIMES structure that was allocated.
            delete[] pRT;

            if ( DRAERR_Success == draError )
            {
                DPRINT3(
                    0,
                    "Added link for %ls from %ls with options 0x%x.\n",
                    pdnNC->StringName,
                    pszTransportAddr,
                    dwOptions
                    );

                LogEvent(
                    DS_EVENT_CAT_KCC,
                    DS_EVENT_SEV_ALWAYS,
                    fIsLocalMaster
                      ? DIRLOG_CHK_LINK_ADD_MASTER_SUCCESS
                      : DIRLOG_CHK_LINK_ADD_REPLICA_SUCCESS,
                    szInsertDN( pdnNC ),
                    szInsertDN( pRemoteDSA->GetDsName() ),
                    NULL);

                //
                // Remove this server from the list of servers that have
                // failed in the past
                //
                gConnectionFailureCache.Remove( pRemoteDSA->GetDsName() );

            }
            else
            {
                DPRINT4(
                    0,
                    "Failed to add link for %ls from %ls with options 0x%x, error %d.\n",
                    pdnNC->StringName,
                    pszTransportAddr,
                    dwOptions,
                    draError
                    );

                LogEvent8WithData(
                    DS_EVENT_CAT_KCC,
                    DS_EVENT_SEV_ALWAYS,
                    fIsLocalMaster
                      ? DIRLOG_CHK_LINK_ADD_MASTER_FAILURE
                      : DIRLOG_CHK_LINK_ADD_REPLICA_FAILURE,
                    szInsertDN( pdnNC ),
                    szInsertWC( pszTransportAddr ),
                    szInsertWin32Msg( draError ),
                    szInsertDN( pRemoteDSA->GetDsName() ),
                    pdnTransport ? szInsertDN(pdnTransport) : szInsertSz(""),
                    NULL,
                    NULL,
                    NULL,
                    sizeof( draError ),
                    &draError );

                //
                // Add this server from the list of servers with whom
                // we have failed to initiate a link with
                //
                if ( !gConnectionFailureCache.Add(pRemoteDSA->GetDsName(), draError, FALSE) )
                {
                    DPRINT1(
                        3,
                        "Failed to add %ws in gConnectionFailureCache\n",
                        pszTransportAddr
                        );

                }
            }       // End DirReplicaAdd() failed
        }       // End No Cached RPC Failure

    } else {
        // We've committed to a certain connection and transport, but one
        // of the dsas is not configured for it. Error out.
        // If we could back out and try another connection, we should.
        // It would be better if we didn't get to this point, and instead
        // decided earlier on not to use this transport.
        // Do we need a way to tell the user that we could use a given transprt
        // if he would only configure it on the dsas?

        // JeffParh 03-19-99: This should never happen for auto-generated
        // connections.  We should have verified that the source and destination
        // bridgeheads supported the transport in KccGetNcBridgeheadForTransport.

        DPRINT3( 0, "Failed to add link for %ws from %ws, transport %ws because transport-specific address is missing!\n",
                 pdnNC->StringName,
                 pRemoteDSA->GetDsName()->StringName,
                 pdnTransport->StringName );
        LogEvent(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_KCC_TRANSPORT_ADDRESS_MISSING,
            szInsertDN( pdnNC ),
            szInsertDN( pRemoteDSA->GetDsName() ),
            szInsertDN( pdnTransport ) );
    }
}

// Register an NC as being replicated over this connection.
void
KCC_CONNECTION::AddReplicatedNC(
    IN  DSNAME * pNC,
    IN  BOOL     fGCTopology
    )
{
    KCC_REPLICATED_NC * pReplNC;

    pReplNC = m_ReplicatedNCArray.Find(pNC);

    if (NULL == pReplNC) {
        // No entry yet exists.
        pReplNC = new KCC_REPLICATED_NC;
    
        pReplNC->pNC = pNC;
        pReplNC->fReadOnly = fGCTopology;

        m_ReplicatedNCArray.Add(pReplNC);
    }
    else {
        // Entry already exists -- update it if necessary.
        if (!fGCTopology && pReplNC->fReadOnly) {
            // This connection used to replicate both writeable and read-only.
            pReplNC->fReadOnly = FALSE;
        }
    }
}

// Enumerate the NCs replicated over this connection (as previously
// registered via AddReplicatedNC()).
DSNAME *
KCC_CONNECTION::GetReplicatedNC(
    IN  DWORD    iNC,
    OUT BOOL *   pfGCTopology
    )
{
    DSNAME * pNC = NULL;

    if (iNC < m_ReplicatedNCArray.GetCount()) {
        KCC_REPLICATED_NC * pReplNC = m_ReplicatedNCArray[iNC];
        pNC = pReplNC->pNC;
        *pfGCTopology = pReplNC->fReadOnly;
    }

    return pNC;
}

// Return the number of replicated NCs that are writeable.
DWORD
KCC_CONNECTION::GetReplicatedWriteableNCCount()
{
    DWORD cReplNCCount = m_ReplicatedNCArray.GetCount();
    DWORD cWriteable = 0;
    DWORD i;

    for (i = 0; i < cReplNCCount; i++) {
        if (!m_ReplicatedNCArray[i]->fReadOnly) {
            cWriteable++;
        }
    }

    return cWriteable;
}

// Is the connection used by the given naming context?
//
// There are two special cases:
// 1. Schema does not appear specifically. It is assumed that if Config
//    is replicated, schema is also
// 2. Admin generated connections are assumed to carry all common ncs
//
// Note that you should not use this to filter which which replica links
// should be created on behalf of which connections. Applications make
// assumptions that each connection may replicate all common NC's.
//
BOOL
KCC_CONNECTION::ReplicatesNC(
    IN KCC_CROSSREF *pCrossRef
    )
{
    if (!IsGenerated()) {
        // Admin generated connections carry all common, compatible nc's
        return TRUE;
    } else {
        DSNAME *pNC;

        // If they ask for Schema, use Config since they share the same topology
        if (pCrossRef->GetNCType() == KCC_NC_TYPE_SCHEMA) {
            pNC = gpDSCache->GetConfigNC();
        } else {
            pNC = pCrossRef->GetNCDN();
        }

        return (m_ReplicatedNCArray.IsElementOf( pNC ));
    }
}

// Determine whether the info replicated by this connection is a subset of that
// replicated by the specified connection.
BOOL
KCC_CONNECTION::ReplicatesSubsetOf(
    IN KCC_CONNECTION * pcn2
    )
{
    DWORD cNumReplNCs1 = m_ReplicatedNCArray.GetCount();
    DWORD cNumReplNCs2 = pcn2->m_ReplicatedNCArray.GetCount();
    BOOL fIsSubset;

    if (cNumReplNCs1 > cNumReplNCs2) {
        // *this replicates more NCs, so it can't be a subset.
        fIsSubset = FALSE;
    }
    else {
        DWORD iReplNC1, iReplNC2;

        m_ReplicatedNCArray.Sort();
        pcn2->m_ReplicatedNCArray.Sort();

        fIsSubset = TRUE;
        iReplNC2 = 0;
        for (iReplNC1 = 0; iReplNC1 < cNumReplNCs1; iReplNC1++) {
            KCC_REPLICATED_NC * pReplNC1 = m_ReplicatedNCArray[iReplNC1];
            KCC_REPLICATED_NC * pReplNC2;
            int nDiff;

            if (iReplNC2 >= cNumReplNCs2) {
                // Remaining NC(s) replicated by 1 are not replicated by 2.
                // 1 is not a subset of 2.
                fIsSubset = FALSE;
                break;
            }

            // Skip over NCs replicated by 2 that are not replicated by 1 --
            // they're irrelevant.

            do {
                pReplNC2 = pcn2->m_ReplicatedNCArray[iReplNC2++];
            } while (((nDiff = CompareDsName(&pReplNC2->pNC, &pReplNC1->pNC))
                      < 0)
                     && (iReplNC2 < cNumReplNCs2));

            if (nDiff) {
                // NC replicated by 1 not replicated by 2 -- not a subset.
                fIsSubset = FALSE;
                break;
            }

            Assert(NameMatched(pReplNC1->pNC, pReplNC2->pNC));
            
            if (!pReplNC1->fReadOnly && pReplNC2->fReadOnly) {
                // 1 supports writeable replication of this NC; 2 solely
                // supports read-only -- not a subset.
                fIsSubset = FALSE;
                break;
            }
        }
    }

    return fIsSubset;
}


BOOL
KCC_CONNECTION::IsSourceSiteUnreachable()
/*++

Routine Description:

    This function should only be called after the spanning-tree algorithm has
    completed. If the source site was found to be unreachable from the local
    site for any NC, this function will return TRUE.

Parameters:

    None.

Return value:

    TRUE  - The source site is unreachable.
    FALSE - Otherwise.

--*/
{
    KCC_SITE_LIST   *pSiteList;
    DSNAME          *pdnSourceSite;
    KCC_SITE        *pSourceSite;

    pSiteList = gpDSCache->GetSiteList();
    ASSERT_VALID( pSiteList );

    pdnSourceSite = GetSourceSiteDN();
    Assert( pdnSourceSite );

    pSourceSite = pSiteList->GetSite(pdnSourceSite);
    ASSERT_VALID( pSourceSite );

    return pSourceSite->IsUnreachable();
}


BOOL
KCC_CONNECTION::OnProbation()
/*++

Routine Description:

    When a connection has been newly created, we cannot immediately
    determine if replication is succeeding over this connection.
    
    For example, an ISTG may create a connection inbound to another
    bridgehead server. In order to determine if replication is succeeding
    over this connection, the following steps must occur:

      - The connection must replicate to the bridgehead server
      - The KCC on the bridgehead server must run and fail to create the
        repsFrom more than gcIntersiteLinkFailuresAllowed times.
      - At least gcSecsUntilIntersiteLinkFailure seconds must elapse.
      - The KCC must run on the ISTG and retrieve the staleness entries
        from the bridgehead server.

    Thus, it takes a fair amount of time before we can assert that
    replication is succeeding over a connection.

    When a connection is newly created, it goes 'on probation' for a
    certain period of time. The intention is that, by the time the connection
    is no longer 'on probation', we will have had sufficient time to determined
    whether or not replication is succeeding over that connection.
    
    This function determines if this connection is it its 'probation period'.

Parameters:

    None

Return value:

    TRUE  - Connection is on probation
    FALSE - Connection is not on probation

--*/
{
    DSTIME timeNow, timeCreated, cSecsCalculatedProbation;
    const DWORD MINS_IN_SECS=60;
    
    timeNow = GetSecondsSince1601();
    timeCreated = GetWhenCreated();
    
    // If 'timeCreated' is 0, this connection was created during this run of
    // the KCC and is therefore still in its probation period.
    if( timeCreated==0 ) {
        return TRUE;
    }

    // If the connection was created in the future, we consider it to be _not_
    // on probation. Otherwise, if the administrator set the clocks far into the
    // future, created some connections, and then set the clocks back to normal,
    // the connections would be on probation for a very long time.
    if(timeCreated > timeNow) {
        return FALSE;
    }

    // If this connection was created less than gcConnectionProbationSecs ago,
    // it is therefore still in its probation period.
    if(timeNow-timeCreated < (DSTIME) gcConnectionProbationSecs) {
        return TRUE;
    }

    // At the bare minimum, the KCC must run at least
    // (gcIntersiteLinkFailuresAllowed+1) times plus a fudge factor of 1 hour
    // to determine that a connection is stale.
    cSecsCalculatedProbation = (DSTIME) (60 * MINS_IN_SECS)
        + ((gcIntersiteLinkFailuresAllowed+1) * gcSecsBetweenTopologyUpdates);
    
    // If this connection was created less than cSecsCalculatedProbation ago,
    // it is therefore still in its probation period.
    if(timeNow-timeCreated < cSecsCalculatedProbation ) {
        return TRUE;
    }
    
    return FALSE;
}


BOOL
KCC_CONNECTION::Supercedes(
    IN  KCC_CONNECTION *pcn
    )
/*++

Routine Description:

    Determine if this connection 'supercedes' pcn. The requirements are
    that this connection is not stale and that this connection replicates a
    superset of the NCs that pcn does.

Parameters:

    pcn - The connection to compare against.

Return value:

    TRUE  - this supercedes pcn
    FALSE - Otherwise

--*/
{
    BOOL fOnProbation, fReplicatesSubset, fShouldSupercede;

    fOnProbation = this->OnProbation();
    fReplicatesSubset = pcn->ReplicatesSubsetOf(this);
    fShouldSupercede = ( !this->IsStale() && fReplicatesSubset );

    if( fShouldSupercede ) {

        if( fOnProbation ) {
            // this should supercede pcn but it can't because it's
            // on probation.
            DPRINT2(2,"Connection %ls would supercede %ls but did not "
                      "because it is on probation.\n",
                    this->GetConnectionDN()->StringName,
                    pcn->GetConnectionDN()->StringName);
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_INTERNAL,
                     DIRLOG_KCC_CONN_ON_PROBATION,
                     szInsertDN(this->GetConnectionDN()),
                     szInsertDN(pcn->GetConnectionDN()),
                     0);
            return FALSE;
        } else {
            // this supercedes pcn and this is not on probation
            return TRUE;
        }

    } else {
        // Does not supercede
        return FALSE;
    }
}


int __cdecl
KCC_CONNECTION::CompareDNAndReason(
    const void *elem1,
    const void *elem2
    )
//
// Compare two DN_AND_REASON elements by their DN.
//
{
    DN_AND_REASON *p1 = (DN_AND_REASON *) elem1;
    DN_AND_REASON *p2 = (DN_AND_REASON *) elem2;
    int nDiff;

    Assert(!fNullUuid(&p1->dn->Guid));
    Assert(!fNullUuid(&p2->dn->Guid));

    nDiff = CompareDsName(&p1->dn, &p2->dn);
    
    return nDiff;
}

BOOL
KCC_CONNECTION::NewNCsSameAsOld(
    void
    )
//
// Determine if the new set of replicated NCs and their reasons are
// identical to the old set of replicated NCs and their reasons.
// To do this, we sort the lists and compare the corresponding elements.
//
{
    DSNAME      *dnOld, *dnNew;
    DWORD       iNC;

    // If the two arrays differ in size, they are obviously not the same.
    if( m_cOldNCs != m_ReplicatedNCArray.GetCount() ) {
        return FALSE;
    }

    // Sort both arrays by the NC DNs
    qsort( m_pOldNCs, m_cOldNCs, sizeof(DN_AND_REASON), CompareDNAndReason );
    m_ReplicatedNCArray.Sort();

    // Now that the arrays are sorted, we can compare their contents one-by-one.
    for( iNC=0; iNC<m_cOldNCs; iNC++ ) {
    
        dnOld = m_pOldNCs[iNC].dn;
        dnNew = m_ReplicatedNCArray[iNC]->pNC;

        // Check that the same NC is in both lists
        if( 0!=CompareDsName(&dnOld,&dnNew) ) {
            return FALSE;
        }

        // Check that the reason has not changed
        if( m_pOldNCs[iNC].reason != m_ReasonForConnection ) {
            return FALSE;
        }
    }

    return TRUE;
}


// The binary data in the replicatesNCReason distname-binary
// Note that each DWORD is encoded in network byte order.
// Another example of distname-binary values is dsamain\src\xdommove.c

#define REASON_BINARY_DATA_SIZE (STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(DWORD)))

void
KCC_CONNECTION::UpdateReason(
    void
    )
//
// Update reason fields in object
//
{
    ATTRMODLIST rgMods[1];
    ULONG       dirError;
    DWORD       cReplNCCount = m_ReplicatedNCArray.GetCount();
    ATTRVAL    *pAttrValNC;
    DWORD       iNC;
    SYNTAX_ADDRESS *pBinaryData = (SYNTAX_ADDRESS *) alloca(REASON_BINARY_DATA_SIZE);
    SYNTAX_DISTNAME_BINARY *pReason;

    
    // We want to avoid updating the reason fields in the DB if the new reasons
    // are identical to the old reasons.
    if( NewNCsSameAsOld() ) {
        DPRINT1(1,
            "Not updating NC reasons for connection %ls because they haven't changed.\n",
            m_pdnConnection->StringName );
        return;
    }
    
    DPRINT3(1,
        "Updated connection %ls with rep nc count %d, reason flags 0x%x.\n",
        m_pdnConnection->StringName,
        cReplNCCount,
        m_ReasonForConnection );
    
    // Fill out binary data
    pBinaryData->structLen = REASON_BINARY_DATA_SIZE;
    // Someday make this reason NC specific. Move inside loop.
    Assert( (((ULONG_PTR)pBinaryData) & 0x3) == 0 );  // DWORD alignment
    *((LPDWORD) &(pBinaryData->byteVal)) = htonl(m_ReasonForConnection);

    memset(rgMods, 0, sizeof(rgMods));

    rgMods[0].choice = ( (0 == cReplNCCount) ? AT_CHOICE_REMOVE_ATT
                                             : AT_CHOICE_REPLACE_ATT );        
    rgMods[0].AttrInf.attrTyp          = ATT_MS_DS_REPLICATES_NC_REASON;
    rgMods[0].AttrInf.AttrVal.valCount = cReplNCCount;
    if (cReplNCCount) {
        pAttrValNC = new ATTRVAL [cReplNCCount];
        rgMods[0].AttrInf.AttrVal.pAVal= pAttrValNC;

        for( iNC = 0; iNC < cReplNCCount; iNC++ ) {
            BOOL fGCTopology;
            DSNAME *pNC = GetReplicatedNC( iNC, &fGCTopology );
            DWORD cbDistNameBinary = DERIVE_NAME_DATA_SIZE( pNC, pBinaryData );

            pReason = (SYNTAX_DISTNAME_BINARY *) new BYTE [cbDistNameBinary];
            BUILD_NAME_DATA( pReason, pNC, pBinaryData );

            pAttrValNC[ iNC ].valLen      = cbDistNameBinary;
            pAttrValNC[ iNC ].pVal        = (LPBYTE) pReason;

            // Supportability logging event 7, dump reason for connection
            LogEvent8(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_VERBOSE,
                DIRLOG_KCC_CONNECTION_REPLICATES_NC,
                szInsertDN( GetConnectionDN() ),
                szInsertDN( pNC ),
                szInsertDN( GetTransportDN() ),
                szInsertDN( GetSourceSiteDN() ),
                szInsertUL( GetReasonForConnection() ),
                szInsertUL( fGCTopology ),
                0, 0
                ); 
        }
    }
    // rgMod[0].pNextMod is zero

    dirError = KccModifyEntry(m_pdnConnection,
                              ARRAY_SIZE(rgMods),
                              rgMods);
    if (0 != dirError) {
        KCC_LOG_MODIFYENTRY_FAILURE( m_pdnConnection, dirError);
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }
}

int __cdecl
KCC_CONNECTION::CompareForRemoval(
    IN  const void *  pv1,
    IN  const void *  pv2
    )
/*++

Routine Description:

    Order the connections by:
    
        increasing source site (as per wcscmp())
        increasing number of writeable NCs supported
        increasing number of read-only NCs supported
        KCC-generated connections come before "created by admin" connections
        stale connections come before non-stale connections
        increasing connection objectGuid
    
Parameters:

    pv1, pv2 -- KCC_CONNECTION **'s of the connections to order.

Returns:

    0   identical
    <0  pcn1 "less than" pcn2
    >0  pcn1 "greater than" pcn2
    
--*/
{
    int nDiff;

    KCC_CONNECTION * pcn1 = *((KCC_CONNECTION **) pv1);
    KCC_CONNECTION * pcn2 = *((KCC_CONNECTION **) pv2);

    Assert(!fNullUuid(&pcn1->GetConnectionDN()->Guid));
    Assert(!fNullUuid(&pcn2->GetConnectionDN()->Guid));

    // Sort first by ascending source site.  Note that the GUIDs are not
    // filled in on the site DNs, so GUID-based order is not currently an option.
    // Shouldn't need to use case-insensitive version, since both names are from
    // the DS and the DS preserves case.  (Case-insensitive compares are much
    // more expensive.)
    nDiff = wcscmp(pcn1->GetSourceSiteDN()->StringName,
                   pcn2->GetSourceSiteDN()->StringName);

    if (0 == nDiff) {
        // Same source site; use ascending number of writeable NCs.
        nDiff = pcn1->GetReplicatedWriteableNCCount()
                - pcn2->GetReplicatedWriteableNCCount();
    }

    if (0 == nDiff) {
        // Same source site, same number of writeable NCs; use ascending number of
        // read-only NCs.
        nDiff = pcn1->GetReplicatedNCCount() - pcn2->GetReplicatedNCCount();
    }

    if (0 == nDiff) {
        // Same source site, same number of writeable/read-only NCs supported;
        // those created by admins sort after those that are KCC-generated.
        nDiff = !pcn1->IsGenerated() - !pcn2->IsGenerated();
    }

    if (0 == nDiff) {
    	// Stale connections can be superceded by non-stale connections, so the
    	// stale connections must come first in the sorted array.
        nDiff = !pcn1->IsStale() - !pcn2->IsStale();
    }

    if (0 == nDiff) {
        // Connections with lower GUID come first.
        nDiff = memcmp(&pcn1->GetConnectionDN()->Guid,
                       &pcn2->GetConnectionDN()->Guid,
                       sizeof(GUID));

        Assert((0 != nDiff) && "Same connection appears twice in list!");
    }
    
    return nDiff;
}


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_CONNECTION_LIST methods
//

RTL_GENERIC_COMPARE_RESULTS
KCC_CONNECTION_LIST::ComparePConnByDsname(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID a,
    PVOID b
    )
// Compare two connection objects by their source site DSNames. This function
// defines the ordering used by the m_dsnameSearchTree. The parameters a and b
// are pointers to pointers to connection objects.
{
    KCC_CONNECTION *conn1, *conn2;
    DSNAME         *dn1, *dn2;
    int             r;

    Assert( a!=NULL && b!=NULL );

    conn1 = *((KCC_CONNECTION**) a);
    conn2 = *((KCC_CONNECTION**) b);

    ASSERT_VALID( conn1 );
    ASSERT_VALID( conn2 );

    dn1 = conn1->GetConnectionDN();
    dn2 = conn2->GetConnectionDN();

    Assert( dn1!=NULL );
    Assert( dn2!=NULL );

    r = CompareDsName( &dn1, &dn2 );

    if( r<0 ) return GenericLessThan;
    else if( r>0 ) return GenericGreaterThan;
    return GenericEqual;
}

RTL_GENERIC_COMPARE_RESULTS
KCC_CONNECTION_LIST::CompareSourceDsaTreeEntry(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID a,
    PVOID b
    )
// Compare two nodes in the m_sourceDsaSearchTree by their GUIDs. The
// parameters, a and b, are pointers to SOURCE_DSA_CONN_ARRAYs.
{
    SOURCE_DSA_CONN_ARRAY   *sde1, *sde2;
    int                     r;

    Assert( a!=NULL && b!=NULL );

    sde1 = (SOURCE_DSA_CONN_ARRAY*) a;
    sde2 = (SOURCE_DSA_CONN_ARRAY*) b;

    Assert( !fNullUuid(&sde1->uuid) );
    Assert( !fNullUuid(&sde2->uuid) );
    
    r = memcmp( &sde1->uuid, &sde2->uuid, sizeof(UUID) );

    if( r<0 ) return GenericLessThan;
    else if( r>0 ) return GenericGreaterThan;
    return GenericEqual;
}

RTL_GENERIC_COMPARE_RESULTS
KCC_CONNECTION_LIST::CompareSourceSiteConnArray(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID a,
    PVOID b
    )
// Compare two nodes in the m_sourceSiteSearchTree by the sites' DSNAMEs.
// The parameters, a and b, are pointers to SOURCE_SITE_CONN_ARRAY's.
{
    SOURCE_SITE_CONN_ARRAY  *sse1, *sse2;
    int                     r;

    Assert( a!=NULL && b!=NULL );

    sse1 = (SOURCE_SITE_CONN_ARRAY*) a;
    sse2 = (SOURCE_SITE_CONN_ARRAY*) b;

    Assert( sse1->siteDN!=NULL );
    Assert( sse2->siteDN!=NULL );

    r = CompareDsName( &sse1->siteDN, &sse2->siteDN );

    if( r<0 ) return GenericLessThan;
    else if( r>0 ) return GenericGreaterThan;
    return GenericEqual;
}

PVOID NTAPI
KCC_CONNECTION_LIST::KccTreeAlloc(
    struct _RTL_GENERIC_TABLE *Table,
    CLONG ByteSize
    )
// This function is used to allocate memory by the three search
// trees in the KCC_CONNECTION_LIST class.
{
    return new BYTE[ ByteSize ];
}

VOID NTAPI
KCC_CONNECTION_LIST::KccTreeFree(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID Buffer
    )
// This function is used to deallocate memory by the three search
// trees in the KCC_CONNECTION_LIST class.
{
    delete[] Buffer;
}

void
KCC_CONNECTION_LIST::Reset()
//
// Reset member variables to their pre-Init() state.
// This includes creating the three empty search trees.
//
{
    SOURCE_DSA_CONN_ARRAY      *psde;
    SOURCE_SITE_CONN_ARRAY     *psse;
    KCC_CONNECTION            **ppcn;
    DWORD                       i;
    BOOLEAN                     fSuccess;

    if( m_fTreesInited ) {

        // Clear the dsname search tree
        for( i=0; i<m_ccn; i++ ) {
            fSuccess = RtlDeleteElementGenericTable( &m_dsnameSearchTree, &m_ppcn[i] );
            Assert( fSuccess==TRUE );
        }
        Assert( RtlIsGenericTableEmpty(&m_dsnameSearchTree) );

        // The source dsa search tree is a tree of lists -- each node corresponds
        // to a distinct source dsa and contains a linked list of connections. We
        // must enumerate the tree to find every list, free the list, and then delete
        // the node from the tree.
        while( ! RtlIsGenericTableEmpty(&m_sourceDsaSearchTree) ) {
            psde = (SOURCE_DSA_CONN_ARRAY*) RtlEnumerateGenericTable(
                &m_sourceDsaSearchTree, TRUE );
            Assert( psde!=NULL );
            Assert( psde->numConnections>0 && psde->numConnections<=m_ccn );
            ppcn = psde->connection;
            Assert( NULL!=ppcn );

            fSuccess = RtlDeleteElementGenericTable( &m_sourceDsaSearchTree, psde );
            Assert( fSuccess==TRUE );
            THFree( ppcn );
        }
        Assert( RtlIsGenericTableEmpty(&m_sourceDsaSearchTree) );

        // The sourceSite search tree is a tree of lists -- each node corresponds
        // to a distinct source site and contains a linked list of connections. We
        // must enumerate the tree to find every list, free the list, and then delete
        // the node from the tree.
        while( ! RtlIsGenericTableEmpty(&m_sourceSiteSearchTree) ) {
            psse = (SOURCE_SITE_CONN_ARRAY*) RtlEnumerateGenericTable(
                &m_sourceSiteSearchTree, TRUE );
            Assert( psse!=NULL );
            Assert( psse->numConnections>0 && psse->numConnections<=m_ccn );
            ppcn = psse->connection;
            Assert( NULL!=ppcn );

            fSuccess = RtlDeleteElementGenericTable( &m_sourceSiteSearchTree, psse );
            Assert( fSuccess==TRUE );
            THFree( ppcn );
        }
    }

    m_cnAllocated    = 0;
    m_ccn            = 0;
    m_ppcn           = NULL;
    m_fIsInitialized = FALSE;
    m_fTreesInited   = FALSE;
}

void
KCC_CONNECTION_LIST::InitTrees()
// Initialize the three search trees
{

    RtlInitializeGenericTable(
       &m_dsnameSearchTree,
        ComparePConnByDsname,
        KccTreeAlloc,
        KccTreeFree,
        NULL
    );
    RtlInitializeGenericTable(
       &m_sourceDsaSearchTree,
        CompareSourceDsaTreeEntry,
        KccTreeAlloc,
        KccTreeFree,
        NULL
    );
    RtlInitializeGenericTable(
       &m_sourceSiteSearchTree,
        CompareSourceSiteConnArray,
        KccTreeAlloc,
        KccTreeFree,
        NULL
    );

    m_fTreesInited = TRUE;
}

KCC_CONNECTION *
KCC_CONNECTION_LIST::GetConnection(
    IN  DWORD   iConnection
    )
//
// Retrieve the KCC_CONNECTION object at the given index.
//
{
    KCC_CONNECTION * pcn;

    ASSERT_VALID( this );

    if ( iConnection < m_ccn )
    {
        pcn = m_ppcn[ iConnection ];
        ASSERT_VALID( pcn );
    }
    else
    {
        pcn = NULL;
    }

    return pcn;
}

KCC_CONNECTION *
KCC_CONNECTION_LIST::GetConnectionWithSameGUID(
    IN  KCC_CONNECTION *pConnection
    )
//
// Retrieve the KCC_CONNECTION object which has the same GUID
// as the connection we passed in.
//
{
    KCC_CONNECTION  *pcn;
    KCC_CONNECTION  *pcnReturn = NULL;
    KCC_CONNECTION **ppcn;

    ASSERT_VALID(this);
    ASSERT_VALID(pConnection);
    Assert( !fNullUuid(&pConnection->GetConnectionDN()->Guid) );

    ppcn = (KCC_CONNECTION**) RtlLookupElementGenericTable(
        &m_dsnameSearchTree, &pConnection );

    if( ppcn!=NULL ) {
        pcnReturn = *ppcn;
    }

    return pcnReturn;
}

KCC_CONNECTION*
KCC_CONNECTION_LIST::GetConnectionFromSourceDSAUUID(
    IN  UUID *  puuid
    )
//
// Retrieve a KCC_CONNECTION object with source DSA matching the given
// UUID.  Returns NULL if none found. Note that there could very well
// be more than one matching connection (for example, if there were manually
// created duplicate connections). In the future, if any callers of this
// function actually need to enumerate all matching connections, we will need
// to rewrite this function slightly.
//
{
    SOURCE_DSA_CONN_ARRAY   *pSearchResult, searchKey;

    ASSERT_VALID( this );
    Assert( !fNullUuid(puuid) );

    memcpy( &searchKey.uuid, puuid, sizeof(UUID) );
    pSearchResult = (SOURCE_DSA_CONN_ARRAY*) RtlLookupElementGenericTable(
        &m_sourceDsaSearchTree, &searchKey );

    if( pSearchResult!=NULL ) {
        Assert( pSearchResult->numConnections>=1 );
        Assert( NULL!=pSearchResult->connection );
        ASSERT_VALID( pSearchResult->connection[0] );
        return pSearchResult->connection[0];
    }

    return NULL;
}

KCC_CONNECTION_LIST::SOURCE_SITE_CONN_ARRAY*
KCC_CONNECTION_LIST::GetConnectionsFromSite(
    IN  DSNAME * pSourceSiteDN
    )
//
// Retrieve a list of KCC_CONNECTION objects, all of which source from the
// site pSourceSiteDN. Returns NULL if none found.
//
{
    SOURCE_SITE_CONN_ARRAY sseKey, *sseResult;

    Assert( NULL!=pSourceSiteDN );

    // Find this list of connections corresponding to this source site in the
    // source dsa search tree
    sseKey.siteDN = pSourceSiteDN;
    sseKey.numConnections = 0;
    sseKey.connection = NULL;
    sseResult = (SOURCE_SITE_CONN_ARRAY*) RtlLookupElementGenericTable(
        &m_sourceSiteSearchTree, &sseKey );

    if( sseResult ) {
        // If the list is empty, we would have removed it from the tree
        // in KCC_CONNECTION_LIST::RemoveFromList().
        Assert( sseResult->numConnections!=0 );
    }
    
    return sseResult;
}

BOOL
KCC_CONNECTION_LIST::IsValid()
//
// Is the collection initialized and internally consistent?
//
{
    return m_fIsInitialized;
}

VOID
KCC_CONNECTION_LIST::AddConnectionToSearchTrees(
    IN KCC_CONNECTION* pcn
    )
//
// After adding new connections to the list (either in Init() or
// AddToList()), we must add the new entries to the search trees for
// efficient retrieval. This function adds new connections to all
// three search trees.
//
{
    SOURCE_DSA_CONN_ARRAY     *sdeResult, sdeKey;
    SOURCE_SITE_CONN_ARRAY    *sseResult, sseKey;
    BOOLEAN                    fNewElement;

    ASSERT_VALID(pcn);
    Assert( m_fTreesInited );


    // Add this connection to the dsname search tree
    RtlInsertElementGenericTable( &m_dsnameSearchTree, &pcn,
        sizeof(KCC_CONNECTION*), &fNewElement );
    Assert( fNewElement==TRUE );


    // Add this connection to the source dsa search tree
    Assert( !fNullUuid(&pcn->GetSourceDSA()->GetDsName()->Guid) );
    memcpy( &sdeKey.uuid, &pcn->GetSourceDSA()->GetDsName()->Guid, sizeof(UUID) );
    sdeKey.numConnections = 0;
    sdeKey.connection = NULL;
    sdeResult = (SOURCE_DSA_CONN_ARRAY*) RtlInsertElementGenericTable(
        &m_sourceDsaSearchTree,
        &sdeKey,
        sizeof(SOURCE_DSA_CONN_ARRAY),
        &fNewElement );

    if( fNewElement ) {
        // If this is the first connection which sources from this dsa,
        // we must allocate the list of connections
        sdeResult->numConnections = 1;
        sdeResult->connection = (KCC_CONNECTION**) THAlloc(sizeof(KCC_CONNECTION*));
        if(!sdeResult->connection) {
            KCC_MEM_EXCEPT(sizeof(KCC_CONNECTION*));
        }
        sdeResult->connection[0] = pcn;
    } else {
        // If this is not the first connection which sources from this site,
        // we must grow (reallocate) the list of connections.
        sdeResult->numConnections++;
        sdeResult->connection = (KCC_CONNECTION**) THReAlloc(
            sdeResult->connection,
            sdeResult->numConnections * sizeof(KCC_CONNECTION*) );
        if(!sdeResult->connection) {
            KCC_MEM_EXCEPT(sdeResult->numConnections*sizeof(KCC_CONNECTION*));
        }
        sdeResult->connection[sdeResult->numConnections-1] = pcn;
    }


    // Add this connection to the appropriate list in the source site search tree
    sseKey.siteDN = pcn->GetSourceSiteDN();
    sseKey.numConnections = 0;
    sseKey.connection = NULL;
    sseResult = (SOURCE_SITE_CONN_ARRAY*) RtlInsertElementGenericTable(
        &m_sourceSiteSearchTree,
        &sseKey,
        sizeof(SOURCE_SITE_CONN_ARRAY),
        &fNewElement );

    if( fNewElement ) {
        // If this is the first connection which sources from this site,
        // we must allocate the list of connections
        sseResult->numConnections = 1;
        sseResult->connection = (KCC_CONNECTION**) THAlloc(sizeof(KCC_CONNECTION*));
        if(!sseResult->connection) {
            KCC_MEM_EXCEPT(sizeof(KCC_CONNECTION*));
        }
        sseResult->connection[0] = pcn;
    } else {
        // If this is not the first connection which sources from this site,
        // we must grow (reallocate) the list of connections.
        sseResult->numConnections++;
        sseResult->connection = (KCC_CONNECTION**) THReAlloc(
            sseResult->connection,
            sseResult->numConnections * sizeof(KCC_CONNECTION*) );
        if(!sseResult->connection) {
            KCC_MEM_EXCEPT(sseResult->numConnections*sizeof(KCC_CONNECTION*));
        }
        sseResult->connection[sseResult->numConnections-1] = pcn;
    }

}

BOOL
KCC_CONNECTION_LIST::Init(
    IN DSNAME *     pdnDestinationDSA,
    IN BOOL         fIntraSite
    )
//
// Initialize the collection from the set of NTDS-Connection DS objects
// that are direct children of the given DSA.
//
{

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { ARRAY_SIZE(KCC_CONNECTION::AttrList), KCC_CONNECTION::AttrList },
        EN_INFOTYPES_TYPES_VALS
    };

    DWORD           dwConnectionClass = CLASS_NTDS_CONNECTION;
    ULONG           dirError;
    FILTER          filtTop = {0};
    FILTER          filtConnectionObject = {0};
    FILTER          filtIntersite = {0};
    FILTER          filtNotIntersite = {0};
    SEARCHRES *     pResults;
    
    Reset();
    InitTrees();

    filtTop.choice                       = FILTER_CHOICE_AND;
    filtTop.FilterTypes.And.count        = 2;
    filtTop.FilterTypes.And.pFirstFilter = &filtConnectionObject;
    
    filtConnectionObject.choice                                     = FILTER_CHOICE_ITEM;
    filtConnectionObject.FilterTypes.Item.choice                    = FI_CHOICE_EQUALITY;
    filtConnectionObject.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CLASS;
    filtConnectionObject.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(dwConnectionClass);
    filtConnectionObject.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) &dwConnectionClass;
    
    if (fIntraSite) {
        filtConnectionObject.pNextFilter = &filtNotIntersite;
    
        filtNotIntersite.choice           = FILTER_CHOICE_NOT;
        filtNotIntersite.FilterTypes.pNot = &filtIntersite;
    } else {
        filtConnectionObject.pNextFilter = &filtIntersite;
    }

    filtIntersite.choice                            = FILTER_CHOICE_ITEM;
    filtIntersite.FilterTypes.Item.choice           = FI_CHOICE_PRESENT;
    filtIntersite.FilterTypes.Item.FilTypes.present = ATT_TRANSPORT_TYPE;

    dirError = KccSearch(
        pdnDestinationDSA,
        SE_CHOICE_IMMED_CHLDRN,
        &filtTop,
        &Sel,
        &pResults
        );

    if (0 != dirError) {
        KCC_LOG_SEARCH_FAILURE(pdnDestinationDSA, dirError);
    } else {
        Init( pdnDestinationDSA, pResults->count, &pResults->FirstEntInf );
        DirFreeSearchRes( pResults );
    }

    return m_fIsInitialized;
}

BOOL
KCC_CONNECTION_LIST::Init(
    IN  DSNAME *        pdnDestinationDSA,
    IN  DWORD           cNumEntInfs,
    IN  ENTINFLIST *    pEntInfList
    )
//
// Initialize connection list from the given search results.
//
{
    ULONG    dirError;
    DSNAME * pdnLocalDSA = gpDSCache->GetLocalDSADN();
    DWORD    iConn;

    Reset();
    InitTrees();
    
    if (0 == cNumEntInfs) {
        DPRINT1(4, "No connection objects found inbound to %ls.\n",
            pdnDestinationDSA->StringName);
        m_fIsInitialized = TRUE;
    } else {
        m_cnAllocated = cNumEntInfs;
        m_ppcn = (KCC_CONNECTION**) THAlloc( cNumEntInfs*sizeof(KCC_CONNECTION*) );
        if(!m_ppcn) {
            KCC_MEM_EXCEPT( cNumEntInfs*sizeof(KCC_CONNECTION*) );
        }

        m_ccn = 0;
        while (NULL != pEntInfList) {
            KCC_CONNECTION * pcn = new KCC_CONNECTION;
            m_ppcn[ m_ccn ] = pcn;

            if (pcn->Init(&pEntInfList->Entinf)) {
                m_ccn++;
            } else {

                // NTDS-Connection object is invalid.  The only case in which
                // this could happen currently is if the DSA referenced by the
                // From-Server attribute has been deleted.  In this case, we
                // ignore the connection object and, if it's inbound to the
                // local DSA, delete it from the DS.

                //
                // Only delete connection under local server's ntds-dsa object
                //
                if (KccIsEqualGUID(&pdnDestinationDSA->Guid,
                                   &pdnLocalDSA->Guid)) {
                    dirError = KccRemoveEntry( pEntInfList->Entinf.pName );
                    if (0 == dirError) {
                        LogEvent(DS_EVENT_CAT_KCC,
                                 DS_EVENT_SEV_ALWAYS,
                                 DIRLOG_CHK_REMOVED_CONN_FROM_DEAD_SERVER,
                                 szInsertDN(pEntInfList->Entinf.pName),
                                 0,
                                 0);

                        DPRINT1(0,
                                "Deleted connection %ls as it sourced from"
                                    " a deleted server.\n",
                                pEntInfList->Entinf.pName->StringName);
                    } else {
                        KCC_LOG_REMOVEENTRY_FAILURE(pEntInfList->Entinf.pName,
                                                    dirError);
                    }
                }


                //
                // Remove the from server from the list of failed
                // servers to initiate a link with since the server
                // no longer exists
                //
                ULONG iAttr;
                BYTE* pbVal;
                ATTR* pAttr;
                for (iAttr = 0;
                     iAttr < pEntInfList->Entinf.AttrBlock.attrCount;
                     iAttr++) {
                    pAttr = &(pEntInfList->Entinf.AttrBlock.pAttr[ iAttr ]);
            
                    if (ATT_FROM_SERVER == pAttr->attrTyp) {
                        Assert(1 == pAttr->AttrVal.valCount);
                        pbVal = pAttr->AttrVal.pAVal->pVal;
                        gConnectionFailureCache.Remove( (DSNAME *) pbVal );
                    }
                }

                //
                // Finally, delete the KCC_CONNECTION we allocated yet
                // failed to initialize.
                //
                delete pcn;
            }
            
            pEntInfList = pEntInfList->pNextEntInf;
        }
    }

    Assert(m_ccn <= cNumEntInfs);

    // Ensure that the search trees are all kept up to date.
    for( iConn=0; iConn<m_ccn; iConn++ ) {
        AddConnectionToSearchTrees( m_ppcn[iConn] );
    }
    m_fIsInitialized = TRUE;

    return m_fIsInitialized;
}

void
KCC_CONNECTION_LIST::AddToList(
    IN  KCC_CONNECTION *  pcn
    )
/*++

Routine Description:

    Add a new connection to the list. If the list is full, we must reallocate
    (by doubling its size). We then add this new connection to our search trees.
    
Parameters:

    pcn - New connection to add.

Returns:

    None.
    
--*/
{
    KCC_CONNECTION    **ppcnNew;
    DWORD               newIndex;

    // Increase the size of the KCC_CONNECTION array, and add the new
    // connection to it
    newIndex = m_ccn;
    m_ccn++;

    if( m_ccn > m_cnAllocated ) {
        m_cnAllocated = 2*(m_cnAllocated+10);
        if( m_ppcn ) {
            m_ppcn = (KCC_CONNECTION**) THReAlloc( m_ppcn,
                m_cnAllocated * sizeof(KCC_CONNECTION*) );
        } else {
            m_ppcn = (KCC_CONNECTION**) THAlloc(
                m_cnAllocated * sizeof(KCC_CONNECTION*) );
        }
        if(!m_ppcn) {
            KCC_MEM_EXCEPT(m_cnAllocated*sizeof(KCC_CONNECTION*));
        }
    }

    m_ppcn[newIndex] = pcn;

    // Now, update our three search trees
    AddConnectionToSearchTrees( pcn );
}

void
KCC_CONNECTION_LIST::RemoveDuplicates(
    IN  BOOL  fDeleteDuplicatesFromDatabase
    )
//
// Scan the collection of connection objects and remove duplicates.  Two
// connection objects are duplicates if they refer to the same source
// DSA.  When we do encounter duplicates, we keep only one of them.
// The general idea is that we first prefer admin-generated connections
// over auto-generated connections and newer connections over older ones,
// in that order.
//
{
    // First, sort 'em by preference.
    qsort(m_ppcn, m_ccn, sizeof(*m_ppcn), CompareForDuplicateCheck);

    // Now, any connections that source from the same DSA will be next to
    // each other in the list.  Moreover, the one that occurs later in the
    // sequence is preferred.  Remove the duplicates, leaving just the most
    // preferred connections in the list.
    DWORD icn = 0;
    while (icn+1 < m_ccn) {
        KCC_CONNECTION * pcnCurr = m_ppcn[icn];
        KCC_CONNECTION * pcnNext = m_ppcn[icn+1];

        if (0 == memcmp(&pcnCurr->GetSourceDSADN()->Guid,
                        &pcnNext->GetSourceDSADN()->Guid,
                        sizeof(GUID))) {
            // icn is a duplicate of icn+1, and icn+1 is the one we want to
            // keep.
            DPRINT2(0, "Ignoring duplicate connection object %ls in favor of %ls.\n",
                    pcnCurr->GetConnectionDN()->StringName,
                    pcnNext->GetConnectionDN()->StringName);
            
            if (!pcnCurr->IsGenerated()) {
                // The connection object we're ignoring was created by an admin.
                // Inform him of his dastardly deed.
                LogEvent(DS_EVENT_CAT_KCC,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_CHK_DUPLICATE_CONNECTION,
                         szInsertDN(pcnCurr->GetConnectionDN()),
                         szInsertDN(pcnNext->GetConnectionDN()),
                         0);
            }
            else if (fDeleteDuplicatesFromDatabase) {
                // Delete duplicate connection object from the database.
                pcnCurr->Remove();
            }

            // ISSUE-2000/08/01-nickhar  Removing duplicate connections from list.
            // Performance could be improved here by using lazy deletion and a
            // final sweep to remove deleted entries. (Although we probably don't
            // remove connections very often).
            //
            // Remove connection from the in-memory connection list and free it.
            RemoveFromList(icn);
            delete pcnCurr;
        }
        else {
            // Not a duplicate; move on.
            icn++;
        }
    }
}

int __cdecl
KCC_CONNECTION_LIST::CompareForDuplicateCheck(
    IN  const void *    pv1,
    IN  const void *    pv2
    )
//
// QSort helper routine to sort connection list by preference.  If two
// connection objects have the same source DSA, the connection that is
// "greater" is preferred (and it is the one that will be translated into a
// repsFrom link).
//
{
    int nDiff;

    KCC_CONNECTION * pcn1 = *((KCC_CONNECTION **) pv1);
    KCC_CONNECTION * pcn2 = *((KCC_CONNECTION **) pv2);

    // Don't allow just one of the Guids to be NULL
    Assert( ! (   fNullUuid(&pcn1->GetSourceDSADN()->Guid)
                ^ fNullUuid(&pcn2->GetSourceDSADN()->Guid) ) );
    
    // Sort first by ascending source ntdsDsa objectGuid.
    nDiff = memcmp(&pcn1->GetSourceDSADN()->Guid,
                   &pcn2->GetSourceDSADN()->Guid,
                   sizeof(GUID));
    
    if (0 == nDiff) {
        // Same source; prefer admin-generated over auto-generated.
        nDiff = !pcn1->IsGenerated() - !pcn2->IsGenerated();
    }

    if (0 == nDiff) {
        // Same source, same "generatedness"; prefer newer connections over
        // older ones.
        nDiff = (int)(pcn1->GetWhenCreated() - pcn2->GetWhenCreated());
    }

    if (0 == nDiff) {
        // This will probably never happen.  This indicates we have two
        // connections with the same source, "generatedness", and creation time.
        // Arbitrarily choose the one with the larger objectGuid.
        nDiff = memcmp(&pcn1->GetConnectionDN()->Guid,
                       &pcn2->GetConnectionDN()->Guid,
                       sizeof(GUID));

        Assert((0 != nDiff) && "Same connection appears twice in list!");
    }

    return nDiff;
}

void
KCC_CONNECTION_LIST::UpdateTransportTypeForSite(
    IN      BOOL                    fIntraSite,
    IN OUT  KCC_CONNECTION_LIST *   pMisfitCnList
    )
//
// Scan connection list and update transport type attribute for admin generated
// connections. If the source is in the same site, and there is a transport type
// attribute, remove it. If the source is in a different site but there is no
// transport type attribute, create one, defaulting to the IP transport.
//
{
    ATTRMODLIST rgMods[1];
    ATTRVAL     AttrVal;
    ULONG       dirError;
    KCC_SITE *  pLocalSite = gpDSCache->GetLocalSite();

    for (DWORD icn = 0; icn < m_ccn; /* icn++/m_ccn-- below */ ) {
        KCC_CONNECTION *pcn = m_ppcn[icn];
        KCC_TRANSPORT  *pTransport;
        BOOL            fUpdate, fInSameSite;
        DSNAME         *pTransportDN, *pDn1, *pDn2, *pNewTransportDN;

        fUpdate = FALSE;
        pDn1 = pLocalSite->GetObjectDN();
        pDn2 = pcn->GetSourceDSA()->GetSiteDN();
        fInSameSite = (CompareDsName( &pDn1, &pDn2 ) == 0);
        pTransportDN = pcn->GetTransportDN();

        if (!fIntraSite) {

            // We're processing inter-site connections. They should always
            // have a transportType.            
            Assert( NULL != pTransportDN );
            pTransport = gpDSCache->GetTransportList()->GetTransport( pTransportDN );

            if( fInSameSite ) {
                // Connection with a transport type but source and destination
                // are in the same site.  Remove the transport type.                
                fUpdate = TRUE;
                pNewTransportDN = NULL;
            } else if( NULL==pTransport ) {
                // The connection had a non-NULL but invalid transport DN.
                // We update the transport type to IP. If IP is not the
                // correct transport, the KCC will have the opportunity to
                // correct this later on.
                fUpdate = TRUE;
                pNewTransportDN = gpDSCache->GetIPTransportDN();
            }

        } else {
            // We're processing intra-site connections. They should have no
            // transportType.
            Assert( NULL == pTransportDN );

            if( !fInSameSite ) {
                // The two endpoints of this connection are not in the same
                // site -- this is in fact an inter-site connection.
                // We set the transport type to IP. If IP is not the
                // correct transport, the KCC will have the opportunity to
                // correct this later on.
                fUpdate = TRUE;
                pNewTransportDN = gpDSCache->GetIPTransportDN();
            }
        }
        
        if (fUpdate) {
            // Update in-memory and DS objects.
            pcn->SetTransport(pNewTransportDN);
            pcn->UpdateDS();
            
            DPRINT2(0, "Updated transport type on %ls to %ls.\n",
                    pcn->GetConnectionDN()->StringName,
                    pNewTransportDN ? pNewTransportDN->StringName : L"RPC" );
            LogEvent8(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CHK_UPDATED_TRANSPORT_TYPE,
                     szInsertDN(pcn->GetConnectionDN()),
                     szInsertDN(pcn->GetSourceDSADN()),
                     szInsertDN(pcn->GetDestinationDSADN()),
                     pNewTransportDN
                        ? szInsertDN(pNewTransportDN)
                        : szInsertSz("RPC"),
                     0,0,0,0
                     );

            // Remove connection from this list and add it to the misfit list.
            RemoveFromList(icn);
            pMisfitCnList->AddToList(pcn);

        } else {
            // No connection update needed.
            icn++;
        }
    }
}
void
KCC_CONNECTION_LIST::RemoveFromList(
    IN  DWORD   icn
    )
//
// Remove connection from the in-memory connection list.
// Does NOT delete the connection object from the DS.
//
{
    SOURCE_DSA_CONN_ARRAY    sdeKey, *sdeResult;
    SOURCE_SITE_CONN_ARRAY   sseKey, *sseResult;
    KCC_CONNECTION          *pcn;
    DWORD                    iConn, cConn;
    BOOLEAN                  fSuccess;

    Assert( m_fTreesInited );
    Assert(icn < m_ccn);
    pcn = m_ppcn[icn];

    // Remove this connection from the connection array.
    memmove(&m_ppcn[icn],
            &m_ppcn[icn+1],
            (m_ccn - icn - 1) * sizeof(*m_ppcn));
    m_ccn--;


    // Remove this connection from the dsname search tree
    fSuccess = RtlDeleteElementGenericTable( &m_dsnameSearchTree, &pcn );
    Assert( TRUE==fSuccess );

    
    // Find this list of connections corresponding to this source dsa in the
    // source dsa search tree
    Assert( !fNullUuid(&pcn->GetSourceDSA()->GetDsName()->Guid) );
    memcpy( &sdeKey.uuid, &pcn->GetSourceDSA()->GetDsName()->Guid, sizeof(UUID) );
    sdeKey.numConnections = 0;
    sdeKey.connection = NULL;
    sdeResult = (SOURCE_DSA_CONN_ARRAY*) RtlLookupElementGenericTable(
        &m_sourceDsaSearchTree, &sdeKey );
    if( NULL==sdeResult ) {

        Assert( !"RtlLookupElementGenericTable() returned NULL unexpectedly" );
    
    } else {

        // Scan the list of connections corresponding to this source dsa, and
        // remove entry 'pcn'
        fSuccess = FALSE;
        cConn = sdeResult->numConnections;
        for( iConn=0; iConn<cConn; iConn++ ) {
    
            if( sdeResult->connection[iConn]!=pcn ) {
                continue;
            }
    
            // We found the entry to remove. Slide its successors down,
            // but don't bother to reclaim the memory.
            memmove(
                &sdeResult->connection[iConn],
                &sdeResult->connection[iConn+1],
                (cConn-1-iConn) * sizeof(KCC_CONNECTION*)
                );
            sdeResult->numConnections--;
            fSuccess = TRUE;
            break;
        }
        Assert( TRUE==fSuccess );
    
        // If all items have been removed from the list of connections corresponding
        // to this dsa, we remove this list from the sourceDsaSearchTree.
        if( sdeResult->numConnections==0 ) {
            THFree( sdeResult->connection );
            sdeResult->connection=NULL;
    
            fSuccess = RtlDeleteElementGenericTable( &m_sourceDsaSearchTree, sdeResult );
            Assert( TRUE==fSuccess );
        }
    }

    // Find this list of connections corresponding to this source site in the
    // source site search tree
    sseKey.siteDN = pcn->GetSourceSiteDN();
    sseKey.numConnections = 0;
    sseKey.connection = NULL;
    sseResult = (SOURCE_SITE_CONN_ARRAY*) RtlLookupElementGenericTable(
        &m_sourceSiteSearchTree, &sseKey );
    if( NULL==sseResult ) {

        Assert( NULL!=sseResult );

    } else {
    
        // Scan the list of connections corresponding to this source site, and
        // remove entry 'pcn'
        fSuccess = FALSE;
        cConn = sseResult->numConnections;
        for( iConn=0; iConn<cConn; iConn++ ) {
    
            if( sseResult->connection[iConn]!=pcn ) {
                continue;
            }
    
            // We found the entry to remove. Slide its successors down,
            // but don't bother to reclaim the memory.
            memmove(
                &sseResult->connection[iConn],
                &sseResult->connection[iConn+1],
                (cConn-1-iConn) * sizeof(KCC_CONNECTION*)
                );
            sseResult->numConnections--;
            fSuccess = TRUE;
            break;
        }
        Assert( TRUE==fSuccess );
    
        // If all items have been removed from the list of connections corresponding
        // to this site, we remove this list from the sourceSiteSearchTree.
        if( sseResult->numConnections==0 ) {
            THFree( sseResult->connection );
            sseResult->connection=NULL;
    
            fSuccess = RtlDeleteElementGenericTable( &m_sourceSiteSearchTree, sseResult );
            Assert( TRUE==fSuccess );
        }
    }
}

void
KCC_CONNECTION_LIST::RemoveFromList(
    IN  KCC_CONNECTION *  pcn
    )
//
// Remove connection from the in-memory connection list.
//
{
    for (DWORD icn = 0; icn < m_ccn; icn++) {
        if (pcn == m_ppcn[icn]) {
            break;
        }
    }

    Assert((icn < m_ccn) && "pcn must be in list!");
    
    RemoveFromList(icn);
}


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_INTRASITE_CONNECTION_LIST methods
//

/* (All inlined.) */


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_INTERSITE_CONNECTION_LIST methods
//

VOID
KCC_INTERSITE_CONNECTION_LIST::UpdateStaleServerCache()
//
// Update the stale server cache with info from the destination bridgeheads.
//
{
    HANDLE                      hDS;
    DSNAME *                    pdnDestDSA;
    DWORD                       err;
    LPWSTR                      pszDestAddr;
    DS_REPL_KCC_DSA_FAILURESW * pFailures = NULL;
    DS_REPL_KCC_DSA_FAILUREW *  pFailure;
    DWORD                       iFail;
    DSNAME *                    pdnLocalDSA = gpDSCache->GetLocalDSADN();
    
    ASSERT_VALID(this);

    if (0 == m_ccn) {
        return;
    }

    pdnDestDSA = m_ppcn[0]->GetDestinationDSADN();

    // Note that we already have a cache of our own failures.
    if (NameMatched(pdnDestDSA, pdnLocalDSA)) {
        return;
    }

    // Contact the inbound bridgehead and ask it how replication is doing.
    pszDestAddr = GuidBasedDNSNameFromDSName(pdnDestDSA);

    err = DsBindW(pszDestAddr, NULL, &hDS);
    if (err) {
        // Inbound bridgehead not reachable.
        DPRINT2(0, "Cannot reach %ls to get staleness info, error %d.\n",
                pdnDestDSA->StringName, err);
        gConnectionFailureCache.Add(pdnDestDSA, err, FALSE);
        return;
    }

    __try {
        // Destination contacted; remove it if it's in the stale cache.
        gConnectionFailureCache.Remove(pdnDestDSA);

        Assert(NULL == pFailures);

        err = DsReplicaGetInfoW(hDS,
                                DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES,
                                NULL,
                                NULL,
                                (void **) &pFailures);
        if (err || !pFailures) {
            DPRINT2(0, "DsReplicaGetInfoW() from %ls failed with error %d.\n",
                    pdnDestDSA->StringName, err);
        }
        else {
            // Update failure cache with any reported failures with respect
            // to remote site bridgeheads we believe the local bridgehead
            // should be replicating from.

            for (iFail = 0; iFail < pFailures->cNumEntries; iFail++) {
                pFailure = &pFailures->rgDsaFailure[iFail];
                if (NULL != GetConnectionFromSourceDSAUUID(
                                &pFailure->uuidDsaObjGuid)) {
                    gConnectionFailureCache.UpdateEntry(pFailure);
                    break;
                }
            }
        }
    
        if (NULL != pFailures) {
            DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES, pFailures);
            pFailures = NULL;
        }

        err = DsReplicaGetInfoW(hDS,
                                DS_REPL_INFO_KCC_DSA_LINK_FAILURES,
                                NULL,
                                NULL,
                                (void **) &pFailures);
        if (err) {
            DPRINT2(0, "DsReplicaGetInfoW() from %ls failed with error %d.\n",
                    pdnDestDSA->StringName, err);
        }
        else {
            // Update failure cache with any reported failures with respect
            // to remote site bridgeheads we believe the local bridgehead
            // should be replicating from.

            for (iFail = 0; iFail < pFailures->cNumEntries; iFail++) {
                pFailure = &pFailures->rgDsaFailure[iFail];
                if (NULL != GetConnectionFromSourceDSAUUID(
                                &pFailure->uuidDsaObjGuid)) {
                    gLinkFailureCache.UpdateEntry(pFailure);
                    break;
                }
            }
        }
    }
    __finally {
        if (NULL != pFailures) {
            // LINK_FAILURES and CONNECT_FAILURES are allocated/freed the
            // same way, so it doesn't matter which it is.
            DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES,
                              pFailures);
            pFailures = NULL;
        }

        DsUnBindW(&hDS);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kcclink.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcclink.cxx

ABSTRACT:

    KCC_LINK and KCC_LINK_LIST classes.

DETAILS:

    These classes represent a single REPLICA_LINK and a collection thereof,
    resp.

    REPLICA_LINKs are the core structures associated with DS replication.
    They are found as the values of Reps-From, Reps-To, and Reps-To-Ext
    properties on NC heads.  Reps-From dictates that the local DSA replicates
    the NC from the server described in the link.  Reps-To dictates that the
    NC is replicated to the server described in the link via RPC.  Reps-To-Ext
    similarly dictates that the NC is replicated to the described server, but
    via mail instead of RPC.

CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include "kcc.hxx"
#include "kcclink.hxx"
#include "kccduapi.hxx"
#include "kccconn.hxx"
#include "kccstale.hxx"
#include "kcctools.hxx"

#define FILENO FILENO_KCC_KCCLINK
#define KCC_REPLICATION_PARTNER_LIMIT       500

///////////////////////////////////////////////////////////////////////////////
//
//  KCC_LINK METHODS
//

void
KCC_LINK::Reset()
//
// Set member variables to their pre-Init() state.
//
{
    m_fIsInitialized = FALSE;
    m_prl            = NULL;
    m_ulModifyFields = 0;
}

void
KCC_LINK::FixupRepsFrom(
    REPLICA_LINK *prl
    )
/*++

Routine Description:

    Converts REPLICA_LINK structures as read from disk (in repsFrom attribute)
    to current version.

Arguments:

    prl-- In repsFrom as read from disk to convert

Return Value:
    Success: modified (& possible re-allocated) RL
    Error: Raises exception

Remarks:
    Taken from ntdsa\dra\drautil.c
    TODO: implement a single conversion routine

--*/
{

    if (prl->V1.cbOtherDraOffset < offsetof(REPLICA_LINK, V1.rgb)) {
        // The REPLICA_LINK structure has been extended since this value
        // was created.  Specifically, it's possible to add new fields to
        // the structure before the dynamically sized rgb field.  In this
        // case, we shift the contents of what was the rgb field to the
        // new offset of the rgb field, then zero out the intervening
        // elements.
        DWORD cbNewFieldsSize = offsetof(REPLICA_LINK, V1.rgb) - prl->V1.cbOtherDraOffset;

        // old formats:
        //  -  missing the uuidTransportObj field (realy old).
        //  -  w/out what used to be dwDrsExt (now dwReserved1)
        Assert(prl->V1.cbOtherDraOffset == offsetof(REPLICA_LINK, V1.uuidTransportObj) ||
               prl->V1.cbOtherDraOffset == offsetof(REPLICA_LINK, V1.dwReserved1) );

        DPRINT1(0, "Converting repsFrom %s from old REPLICA_LINK format.\n",
                RL_POTHERDRA(prl)->mtx_name);

        // Allocate Expand the structure and shift the contents of what what was the
        // rgb field in the old format to where the rgb field is in the new
        // format.

        m_prl = (REPLICA_LINK*)new BYTE[prl->V1.cb + cbNewFieldsSize];
        // copy mutual fields
        CopyMemory(m_prl, prl, prl->V1.cb);

        // and the rest
        CopyMemory(m_prl->V1.rgb, prl->V1.rgb - cbNewFieldsSize,
                   prl->V1.cb - prl->V1.cbOtherDraOffset);

        // Zero out the new fields.
        memset(((BYTE *)m_prl) + m_prl->V1.cbOtherDraOffset, 0, cbNewFieldsSize);

        // And reset the embedded offsets and structure size.
        m_prl->V1.cbOtherDraOffset = offsetof(REPLICA_LINK, V1.rgb);
        m_prl->V1.cb += cbNewFieldsSize;
        if ( 0 != m_prl->V1.cbPASDataOffset ) {
            // struct was extended while there's PAS data in it.
            m_prl->V1.cbPASDataOffset += cbNewFieldsSize;
        }

    }
    else if ( prl->V1.cbOtherDraOffset != offsetof(REPLICA_LINK, V1.rgb) ) {
            Assert(prl->V1.cbOtherDraOffset == offsetof(REPLICA_LINK, V1.rgb));
            KCC_EXCEPT( DRAERR_InternalError, 0 );
    }
    else {
        // simply alloc & copy
        VALIDATE_REPLICA_LINK_SIZE(prl);
        m_prl = (REPLICA_LINK*)new BYTE[prl->V1.cb];
        CopyMemory(m_prl, prl, prl->V1.cb);
    }

    VALIDATE_REPLICA_LINK_VERSION(m_prl);
    VALIDATE_REPLICA_LINK_SIZE(m_prl);
}



BOOL
KCC_LINK::Init(
    IN  REPLICA_LINK *  prl
    )
//
// Initialize internal object from given REPLICA_LINK structure.
// Note: This is copied code from FixupRepsFrom(). Until it is available,
// we must ensure they're in sync.
//
{
    Reset();

    Assert( prl );
    if(!prl) {
        return FALSE;
    }

    // optionally fix offsets, always allocate mem & assign m_prl
    FixupRepsFrom(prl);

    m_fIsInitialized = TRUE;

    return m_fIsInitialized;
}

UUID *
KCC_LINK::GetDSAUUID()
//
// Retrieve immutable UUID associated with source DSA.
//
{
    ASSERT_VALID( this );
    return &m_prl->V1.uuidDsaObj;
}

MTX_ADDR *
KCC_LINK::GetDSAAddr()
//
// Retrieve transport address associated with the source DSA.
//
{
    ASSERT_VALID( this );
    return RL_POTHERDRA( m_prl );
}

BOOL
KCC_LINK::IsEnabled()
//
// Is this link enabled?
//
{
    ASSERT_VALID( this );
    return !( m_prl->V1.ulReplicaFlags & ( DRS_DISABLE_AUTO_SYNC | DRS_DISABLE_PERIODIC_SYNC ) );
}

KCC_LINK &
KCC_LINK::SetEnabled(
    IN  BOOL    fIsEnabled
    )
//
// Set is-enabled flag to the given value.
//
{
    ASSERT_VALID( this );

    if ( fIsEnabled )
    {
        m_prl->V1.ulReplicaFlags &= ~( DRS_DISABLE_AUTO_SYNC | DRS_DISABLE_PERIODIC_SYNC );
    }
    else
    {
        m_prl->V1.ulReplicaFlags |= ( DRS_DISABLE_AUTO_SYNC | DRS_DISABLE_PERIODIC_SYNC );
    }

    m_ulModifyFields |= DRS_UPDATE_FLAGS;

    return *this;
}

REPLTIMES *
KCC_LINK::GetSchedule()
//
// Retrieve periodic replication schedule.
//
{
    ASSERT_VALID( this );
    return &m_prl->V1.rtSchedule;
}

KCC_LINK &
KCC_LINK::SetSchedule(
    IN  REPLTIMES * prt
    )
//
// Set periodic replication schedule.
//
{
    ASSERT_VALID( this );
    memcpy( &m_prl->V1.rtSchedule, prt, sizeof( *prt ) );

    m_ulModifyFields |= DRS_UPDATE_SCHEDULE;

    return *this;
}

BOOL
KCC_LINK::IsDSRPCReplica()
//
// Is replication across this link performed via DS RPC (as opposed to
// via an ISM plug-in transport's send/receive functions)?
//
{
    ASSERT_VALID( this );
    return !(m_prl->V1.ulReplicaFlags & DRS_MAIL_REP);
}

KCC_LINK &
KCC_LINK::SetDSRPCReplica(
    IN  BOOL    fIsDSRPCReplica
    )
//
// Set the IsDSRPCReplica flag to the given value.
//
{
    ASSERT_VALID( this );

    if ( !fIsDSRPCReplica )
    {
        m_prl->V1.ulReplicaFlags |= DRS_MAIL_REP;
    }
    else
    {
        m_prl->V1.ulReplicaFlags &= ~DRS_MAIL_REP;
    }

    m_ulModifyFields |= DRS_UPDATE_FLAGS;

    return *this;
}

BOOL
KCC_LINK::UsesCompression()
//
// Is compression used for replication data?
//
{
    ASSERT_VALID(this);
    return !!(m_prl->V1.ulReplicaFlags & DRS_USE_COMPRESSION);
}

KCC_LINK &
KCC_LINK::SetCompression(
    IN  BOOL    fUseCompression
    )
//
// Set the use-compression flag to the given value.
//
{
    ASSERT_VALID(this);

    if (fUseCompression) {
        m_prl->V1.ulReplicaFlags |= DRS_USE_COMPRESSION;
    }
    else {
        m_prl->V1.ulReplicaFlags &= ~DRS_USE_COMPRESSION;
    }

    m_ulModifyFields |= DRS_UPDATE_FLAGS;

    return *this;
}

BOOL
KCC_LINK::IsNeverNotified()
//
// Are replication notifications never used for this link?
//
{
    ASSERT_VALID(this);
    return !!(m_prl->V1.ulReplicaFlags & DRS_NEVER_NOTIFY);
}

KCC_LINK &
KCC_LINK::SetNeverNotified(
    IN  BOOL    fIsNeverNotified
    )
//
// Set the is-never-notified flag to the given value.
//
{
    ASSERT_VALID(this);

    if (fIsNeverNotified) {
        m_prl->V1.ulReplicaFlags |= DRS_NEVER_NOTIFY;
    }
    else {
        m_prl->V1.ulReplicaFlags &= ~DRS_NEVER_NOTIFY;
    }

    m_ulModifyFields |= DRS_UPDATE_FLAGS;

    return *this;
}

BOOL
KCC_LINK::IsPeriodicSynced()
//
// Is replication across this link performed on a schedule (psossibly in
// addition to notification-based replication)?
//
{
    ASSERT_VALID( this );
    return !!( m_prl->V1.ulReplicaFlags & DRS_PER_SYNC );
}

KCC_LINK &
KCC_LINK::SetPeriodicSync(
    IN  BOOL    fIsPeriodicSync
    )
//
// Set the is-periodically-synced flag to the given value.
//
{
    ASSERT_VALID( this );

    if ( fIsPeriodicSync )
    {
        m_prl->V1.ulReplicaFlags |= DRS_PER_SYNC;
    }
    else
    {
        m_prl->V1.ulReplicaFlags &= ~DRS_PER_SYNC;
    }

    m_ulModifyFields |= DRS_UPDATE_FLAGS;

    return *this;
}

BOOL
KCC_LINK::IsInitSynced()
//
// Is replication across this link performed on DS startup?
//
{
    ASSERT_VALID( this );
    return !!( m_prl->V1.ulReplicaFlags & DRS_INIT_SYNC );
}

// Set the is-init-synced flag to the given value.
KCC_LINK &
KCC_LINK::SetInitSync(
    IN  BOOL    fIsInitSync
    )
{
    ASSERT_VALID( this );

    if ( fIsInitSync )
    {
        m_prl->V1.ulReplicaFlags |= DRS_INIT_SYNC;
    }
    else
    {
        m_prl->V1.ulReplicaFlags &= ~DRS_INIT_SYNC;
    }

    m_ulModifyFields |= DRS_UPDATE_FLAGS;

    return *this;
}

// Does completion of a sync of this NC trigger a sync in the opposite
// direction?
BOOL
KCC_LINK::IsTwoWaySynced()
{
    ASSERT_VALID(this);
    return !!(m_prl->V1.ulReplicaFlags & DRS_TWOWAY_SYNC);
}

// Set the is-two-way-synced flag to the given value.
KCC_LINK &
KCC_LINK::SetTwoWaySync(
    IN  BOOL    fIsTwoWaySynced
    )
{
    ASSERT_VALID(this);

    if (fIsTwoWaySynced) {
        m_prl->V1.ulReplicaFlags |= DRS_TWOWAY_SYNC;
    }
    else {
        m_prl->V1.ulReplicaFlags &= ~DRS_TWOWAY_SYNC;
    }

    m_ulModifyFields |= DRS_UPDATE_FLAGS;

    return *this;
}

// Retrieve the UUID associated with the transport.
UUID *
KCC_LINK::GetTransportUUID()
{
    ASSERT_VALID( this );
    return &m_prl->V1.uuidTransportObj;
}

// Set the transport to that with the given UUID as its objectGuid.
KCC_LINK &
KCC_LINK::SetTransportUUID(
    IN  UUID *  puuidTransportObj
    )
{
    ASSERT_VALID( this );

    m_prl->V1.uuidTransportObj = *puuidTransportObj;

    m_ulModifyFields |= DRS_UPDATE_TRANSPORT;

    return *this;
}

// Is the local NC writeable?
BOOL
KCC_LINK::IsLocalNCWriteable()
{
    ASSERT_VALID( this );
    return !!(m_prl->V1.ulReplicaFlags & DRS_WRIT_REP);
}

DSTIME
KCC_LINK::GetTimeOfLastSuccess()
//
// Get the time of the last successful operation across this link.  For
// Reps-From, this is the time of the last successful inbound replication.
// For Reps-To, this is the last time the Reps-To value was added or
// updated (either directly via IDL_DRSUpdateRefs() or indirectly by setting
// DRS_ADD_REF in the ulFlags for IDL_DRSGetNCChanges()).
//
{
    ASSERT_VALID( this );
    return m_prl->V1.timeLastSuccess;
}

ULONG
KCC_LINK::GetConnectFailureCount()
// Return the number consecutive times a replication attempt has
// failed
{
    ASSERT_VALID( this );

    return m_prl->V1.cConsecutiveFailures;

}

ULONG
KCC_LINK::GetLastResult()
// Return last result status
{
    ASSERT_VALID( this );

    return m_prl->V1.ulResultLastAttempt;

}

KCC_LINK &
KCC_LINK::SetDSAAddr(
    IN  MTX_ADDR *  pmtx
    )
//
// Set transport address of the source DSA.
//
{

    ASSERT_VALID( this );

    INT diff = MTX_TSIZE( pmtx ) - MTX_TSIZE( RL_POTHERDRA(m_prl) );


    // Realloc if necessary.
    // Note: even if there's enough space (diff < 0), we would go ahead & clean
    // the blob up. We assume this op doesn't happen too frequently so the cost is minimal
    if ( diff )
    {
        REPLICA_LINK *poldprl = m_prl;
        DWORD cb = (DWORD)((INT)m_prl->V1.cb + diff);

        // allocate & copy old to new (so that we get all fixed fields)
        // (add DWORD for potential alignment fixup).
        m_prl = (REPLICA_LINK *)new BYTE[cb + sizeof(DWORD)] ;
        CopyMemory(m_prl, poldprl, offsetof(REPLICA_LINK, V1.rgb));
        // set new struct size
        m_prl->V1.cb = cb;

        // dynamic field offsets
        //   - mtx size
        //   - PAS data
        m_prl->V1.cbOtherDra += diff;

        // PAS Data
        if ( poldprl->V1.cbPASDataOffset ) {
            //  We have PAS data:
            //  - fix offsets
            //  - copy over
            //

            // assert: size must be non-zero if offset is set
            Assert(RL_PPAS_DATA(poldprl)->size);
            // assert: invalid PAS data
            Assert(RL_PPAS_DATA(poldprl)->PAS.V1.cAttrs != 0);

            // set new offset
            m_prl->V1.cbPASDataOffset += diff;
            // ensure & fix alignment offsets
            RL_ALIGN_PAS_DATA(m_prl);

            // move data to new location
            CopyMemory(RL_PPAS_DATA(m_prl),
                       (PBYTE)poldprl + poldprl->V1.cbPASDataOffset,
                       RL_PPAS_DATA(poldprl)->size);
        }

        // reset new dra offset
        Assert((INT)(m_prl->V1.cbOtherDraOffset) > diff);

        delete poldprl;
    }

    // Copy new mtx addr.
    memcpy( RL_POTHERDRA( m_prl ), pmtx, MTX_TSIZE( pmtx ) );

    VALIDATE_REPLICA_LINK_SIZE(m_prl);

    m_ulModifyFields |= DRS_UPDATE_ADDRESS;

    return *this;
}

DWORD
KCC_LINK::Delete(
    IN KCC_LINK *           plink,
    IN DSNAME *             pdnNC,
    IN KCC_LINK_DEL_REASON  DeleteReason,
    IN ATTRTYP              attid,
    IN DWORD                dwOptions,
    IN DSNAME *             pdnDSA
    )
//
// Delete the given link from the local DSA.
//
{
    // Map reasons to event log messages.
    // -1 => Condition should never occur.
    //  0 => Do not log an event under this condition.
    static struct {
        KCC_LINK_DEL_REASON Reason;
	DWORD dwMsgCategory;
        struct { 
            DWORD dwMsgSuccess;
            DWORD dwMsgFailure;
        } OnRemoveSource;
        struct {
            DWORD dwMsgSuccess;
            DWORD dwMsgFailure;
        } OnRemoveNC;
    } rgMsgTable[] = {
        // Placeholder only.
        { KCC_LINK_DEL_REASON_NONE,
	    DS_EVENT_CAT_KCC,
          { -1,
            -1 },
          { -1,
            -1 } },

        // Remove source of a read-only NC, as the NC is that of a domain that
        // has been removed from the forest.
        { KCC_LINK_DEL_REASON_READONLY_DOMAIN_REMOVED,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_LINK_DEL_DOMDEL_SUCCESS,
            DIRLOG_CHK_LINK_DEL_DOMDEL_FAILURE },
          { DIRLOG_CHK_LINK_DEL_DOMDEL_TEARDOWN_SUCCESS,
            DIRLOG_CHK_LINK_DEL_DOMDEL_TEARDOWN_FAILURE } },

        // Remove source of a read-only NC, as the local DSA is no longer
        // configured to be a GC. 

        { KCC_LINK_DEL_REASON_READONLY_NOT_GC,
	    DS_EVENT_CAT_GLOBAL_CATALOG,
          { DIRLOG_CHK_LINK_DEL_NOTGC_SUCCESS,
            DIRLOG_CHK_LINK_DEL_NOTGC_FAILURE },
          { DIRLOG_CHK_LINK_DEL_NOTGC_TEARDOWN_SUCCESS,
            DIRLOG_CHK_LINK_DEL_NOTGC_TEARDOWN_FAILURE } },

        // Remove non-domain source/NC, as the corresponding cross ref dictates
        // the local DSA is no longer a host for the NC.
        { KCC_LINK_DEL_REASON_NDNC_NOT_REPLICA_HOST,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_RMSOURCE_SUCCESS,
            DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_RMSOURCE_FAILURE },
          { -1,     // these two cases should go through KCC_LINK::Demote
            -1 } }, // instead

        // Remove source/NC, as we have a writeable replica but need a read-only
        // replica.
        { KCC_LINK_DEL_REASON_HAVE_WRITEABLE_NEED_READONLY,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_LINK_DEL_HAVE_WRITEABLE_NEED_READONLY_RMSOURCE_SUCCESS,
            DIRLOG_CHK_LINK_DEL_HAVE_WRITEABLE_NEED_READONLY_RMSOURCE_FAILURE },
          { DIRLOG_CHK_LINK_DEL_HAVE_WRITEABLE_NEED_READONLY_TEARDOWN_SUCCESS,
            DIRLOG_CHK_LINK_DEL_HAVE_WRITEABLE_NEED_READONLY_TEARDOWN_FAILURE } },

        // Remove source/NC, as we have a read-only replica but need a writeable
        // replica.
        { KCC_LINK_DEL_REASON_HAVE_READONLY_NEED_WRITEABLE,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_LINK_DEL_HAVE_READONLY_NEED_WRITEABLE_RMSOURCE_SUCCESS,
            DIRLOG_CHK_LINK_DEL_HAVE_READONLY_NEED_WRITEABLE_RMSOURCE_FAILURE },
          { DIRLOG_CHK_LINK_DEL_HAVE_READONLY_NEED_WRITEABLE_TEARDOWN_SUCCESS,
            DIRLOG_CHK_LINK_DEL_HAVE_READONLY_NEED_WRITEABLE_TEARDOWN_FAILURE } },

        // Remove source, as there is no longer a connection object dictating
        // that we should replicate from it.
        { KCC_LINK_DEL_REASON_NO_CONNECTION,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_LINK_DEL_NOCONN_SUCCESS,
            DIRLOG_CHK_LINK_DEL_NOCONN_FAILURE },
          { -1,
            -1 } },

        // Remove source, as the source DSA no longer hosts this NC.
        { KCC_LINK_DEL_REASON_SOURCE_NOT_HOST,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_LINK_DEL_NONC_SUCCESS,
            DIRLOG_CHK_LINK_DEL_NONC_FAILURE },
          { -1,
            -1 } },

        // Remove source, as the source DSA host a read-only replica but the
        // local DSA hosts a writeable replica.
        { KCC_LINK_DEL_REASON_SOURCE_READONLY,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_LINK_DEL_SOURCE_READONLY_SUCCESS,
            DIRLOG_CHK_LINK_DEL_SOURCE_READONLY_FAILURE },
          { -1,
            -1 } },

        // Remove repsTo, as the local DSA has no ntdsDsa object corresponding
        // to the destination DSA and the usual grace period has expired.
        { KCC_LINK_DEL_REASON_DANGLING_REPS_TO,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_REPSTO_DEL_SUCCESS,
            DIRLOG_CHK_REPSTO_DEL_FAILURE },
          { -1,
            -1 } },

        // Remove non-domain source/NC, as the corresponding crossRef has been
        // deleted (signalling the partition es kaput).
        { KCC_LINK_DEL_REASON_NDNC_NO_CROSSREF,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_LINK_DEL_NDNC_NOCROSSREF_RMSOURCE_SUCCESS,
            DIRLOG_CHK_LINK_DEL_NDNC_NOCROSSREF_RMSOURCE_FAILURE },
          { DIRLOG_CHK_LINK_DEL_NDNC_NOCROSSREF_TEARDOWN_SUCCESS,
            DIRLOG_CHK_LINK_DEL_NDNC_NOCROSSREF_TEARDOWN_FAILURE } },

        // Remove read-only source/NC, as the crossRef says this NC is not to
        // be hosted on GCs.

        { KCC_LINK_DEL_REASON_READONLY_NOT_HOSTED_BY_GCS,
	    DS_EVENT_CAT_GLOBAL_CATALOG,
          { DIRLOG_CHK_LINK_DEL_READONLY_NOTGCHOSTED_RMSOURCE_SUCCESS,
            DIRLOG_CHK_LINK_DEL_READONLY_NOTGCHOSTED_RMSOURCE_FAILURE },
          { DIRLOG_CHK_LINK_DEL_READONLY_NOTGCHOSTED_TEARDOWN_SUCCESS,
            DIRLOG_CHK_LINK_DEL_READONLY_NOTGCHOSTED_TEARDOWN_FAILURE } },
    };

    DWORD   draError;
    LPWSTR  pszDSA = L"";
    DWORD   dwMsgCategory;
    DWORD   dwMsgSuccess;
    DWORD   dwMsgFailure;

    Assert(KCC_LINK_DEL_REASON_MAX == ARRAY_SIZE(rgMsgTable));
    Assert(KCC_LINK_DEL_REASON_NONE != DeleteReason);
    Assert(rgMsgTable[DeleteReason].Reason == DeleteReason);

    if (NULL == plink) {
        dwOptions |= DRS_NO_SOURCE;
       
        dwMsgSuccess = rgMsgTable[DeleteReason].OnRemoveNC.dwMsgSuccess;
        dwMsgFailure = rgMsgTable[DeleteReason].OnRemoveNC.dwMsgFailure;
    } else {
        ASSERT_VALID(plink);

        pszDSA = TransportAddrFromMtxAddr(RL_POTHERDRA(plink->m_prl));

        if (NULL == pdnDSA) {
            pdnDSA = KccGetDSNameFromGuid(plink->GetDSAUUID());
            // pdnDSA may still be NULL
        }

        dwMsgSuccess = rgMsgTable[DeleteReason].OnRemoveSource.dwMsgSuccess;
        dwMsgFailure = rgMsgTable[DeleteReason].OnRemoveSource.dwMsgFailure;
    }
    dwMsgCategory = rgMsgTable[DeleteReason].dwMsgCategory;

    if ((-1 == dwMsgSuccess) || (-1 == dwMsgFailure)) {
        Assert(!"NC deletion logic error!");
        LogUnhandledError(DeleteReason);
        return ERROR_DS_INTERNAL_FAILURE;
    }

    if (ATT_REPS_FROM == attid) {
        // If we have to tear down the NC, do that part asynchronously.
        dwOptions |= DRS_ASYNC_REP;

        draError = DirReplicaDelete(pdnNC, pszDSA, dwOptions);

        // Remove the from server from the link failure cache
        if (!draError && plink) {
            gLinkFailureCache.Remove( plink->GetDSAUUID() );
        }
    } else {
        Assert(ATT_REPS_TO == attid);
        Assert(NULL != plink);

        dwOptions |= DRS_DEL_REF;
        dwOptions |= (plink->m_prl->V1.ulReplicaFlags & DRS_WRIT_REP);

        draError = DirReplicaReferenceUpdate(pdnNC,
                                             pszDSA,
                                             &plink->m_prl->V1.uuidDsaObj,
                                             dwOptions);
    }

    // The code below assumes we always log errors.
    Assert(0 != dwMsgFailure);

    if (draError) {
        LogEvent8WithData(dwMsgCategory,
                          DS_EVENT_SEV_ALWAYS,
                          dwMsgFailure,
                          szInsertDN(pdnNC),
                          szInsertWC(pszDSA),
                          szInsertWin32Msg(draError),
                          pdnDSA ? szInsertDN(pdnDSA)
                                 : szInsertSz(""),
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          sizeof(draError),
                          &draError);
    } else if (0 != dwMsgSuccess) {
        LogEvent(dwMsgCategory,
                 DS_EVENT_SEV_ALWAYS,
                 dwMsgSuccess,
                 szInsertDN(pdnNC),
                 szInsertWC(pszDSA),
                 pdnDSA ? szInsertDN(pdnDSA)
                        : szInsertSz(""));
    }

    return draError;
}

DWORD
KCC_LINK::Update(
    IN DSNAME * pdnNC,
    IN ATTRTYP  attid
    )
//
// Update the link in the DS.
//
{
    DWORD   draError;
    LPWSTR  pszDSA;

    Assert( 0 != m_ulModifyFields );

    pszDSA = TransportAddrFromMtxAddr(RL_POTHERDRA(m_prl));

    if ( ATT_REPS_FROM == attid )
    {
        draError = DirReplicaModify(
                        pdnNC,
                        &m_prl->V1.uuidDsaObj,
                        &m_prl->V1.uuidTransportObj,
                        pszDSA,
                        &m_prl->V1.rtSchedule,
                        m_prl->V1.ulReplicaFlags,
                        m_ulModifyFields,
                        0
                        );
    }
    else
    {
        Assert( ATT_REPS_TO == attid );

        draError = DirReplicaReferenceUpdate(
                        pdnNC,
                        pszDSA,
                        &m_prl->V1.uuidDsaObj,
                        (DRS_WRIT_REP & m_prl->V1.ulReplicaFlags)
                            | DRS_DEL_REF | DRS_ADD_REF );
    }

    if ( DRAERR_Success == draError )
    {
        m_ulModifyFields = 0;
    }

    return draError;
}

BOOL
KCC_LINK::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

ULONG
KCC_LINK::Demote(
    IN  KCC_CROSSREF *  pCrossRef
    )
/*++

Routine Description:

    Demote the local replica of this NC by first transferring any remaining
    updates or FSMO roles to another replica and then tearing down the NC.

Arguments:

    pCrossRef (IN) - cross ref for the NC being demoted.

Return Values:

    0 or Win32 error.

--*/
{
    DRS_DEMOTE_TARGET_SEARCH_INFO DTSInfo = {0};
    DSNAME * pDemoteTargetDSADN = NULL;
    LPWSTR pszDemoteTargetDNSName = NULL;
    DWORD cNumAttempts = 0;
    DSNAME * pNC = pCrossRef->GetNCDN();
    ULONG err = ERROR_DS_CANT_FIND_DSA_OBJ;
    BOOL fSuccess = FALSE;

    // Currently the KCC should demote only NDNC replicas.
    Assert(KCC_NC_TYPE_NONDOMAIN == pCrossRef->GetNCType());

    while (!fSuccess
           && (0 == DirReplicaGetDemoteTarget(pNC, &DTSInfo,
                                              &pszDemoteTargetDNSName,
                                              &pDemoteTargetDSADN))) {
        cNumAttempts++;
        err = DirReplicaDemote(pNC, pszDemoteTargetDNSName, pDemoteTargetDSADN,
                               DRS_NO_SOURCE);
        
        if (err) {
            // Failure.
            DPRINT3(0, "Failed to demote NC %ls to target %ls, error %d.\n",
                    pNC->StringName, pDemoteTargetDSADN->StringName, err);
            
            LogEvent8WithData(DS_EVENT_CAT_KCC,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_TEARDOWN_FAILURE,
                              szInsertDN(pNC),
                              szInsertDN(pDemoteTargetDSADN),
                              szInsertWin32Msg(err),
                              NULL, NULL, NULL, NULL, NULL,
                              sizeof(err),
                              &err);
        } else {
            // Success!
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_TEARDOWN_SUCCESS,
                     szInsertDN(pNC),
                     szInsertDN(pDemoteTargetDSADN),
                     NULL);
            fSuccess = TRUE;
        }
            
        THFree(pDemoteTargetDSADN);
        pDemoteTargetDSADN = NULL;

        THFree(pszDemoteTargetDNSName);
        pszDemoteTargetDNSName = NULL;
    }

    if (0 == cNumAttempts) {
        // Didn't find any potential demotion targets.
        DPRINT1(0, "Failed to find demote target for NC %ls.\n",
                pNC->StringName);
        
        // Are there any other replicas configured?
        if (0 == pCrossRef->GetNCReplicaLocations()->GetCount()) {
            // No replicas are configured.  Likely a configuration error of some
            // sort -- e.g., meant to delete crossRef to remove partition
            // permanently, forgot to configure a new replica, etc.
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_TEARDOWN_NOREPLICACFG,
                     szInsertDN(pNC),
                     NULL,
                     NULL);
        } else {
            // One or more replicas are configured, but none could be found by
            // the locator.
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_TEARDOWN_NOREPLICAADVERTISING,
                     szInsertDN(pNC),
                     NULL,
                     NULL);
        }
        
        Assert(err);
    }

    return err;
}


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_LINK_LIST METHODS
//

BOOL
KCC_LINK_LIST::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

KCC_LINK *
KCC_LINK_LIST::GetLink(
    IN  DWORD   iLink
    )
//
// Retrieve link at the given index.
//
{
    KCC_LINK *  plink;

    ASSERT_VALID( this );

    if ( iLink < m_cLinks )
    {
        plink = &m_plink[ iLink ];
        ASSERT_VALID( plink );
    }
    else
    {
        plink = NULL;
    }

    return plink;
}

VOID
KCC_LINK_LIST::RemoveLink(
    IN  DWORD   iLink
    )
//
// Remove link at the given index.
// Not very efficient. Hopefully this happens rarely.
//
{
    ASSERT_VALID( this );
    Assert( iLink<m_cLinks );
    memmove( &m_plink[iLink], &m_plink[iLink+1], (m_cLinks-iLink-1)*sizeof(KCC_LINK) );
    m_cLinks--;
}

DWORD
KCC_LINK_LIST::GetCount()
//
// Get number of links in the collection.
//
{
    ASSERT_VALID( this );
    return m_cLinks;
}

BOOL
KCC_LINK_LIST::Init(
    IN  DSNAME *    pdnNC,
    IN  ATTRTYP     attid
    )
//
// Initialize collection of links from the set of REPLICA_LINKs of the given
// attribute type on the specified NC head.
//
{
    Reset();

    Assert((ATT_REPS_FROM == attid) || (ATT_REPS_TO == attid));

    if (gpDSCache->GetLocalDSA()->IsNCInstantiated(pdnNC)) {
        ATTR rgAttrs[] = {
            { 0, { 0, NULL } },
            { ATT_INSTANCE_TYPE, { 0, NULL } }
        };
    
        ENTINFSEL Sel = {
            EN_ATTSET_LIST,
            { ARRAY_SIZE(rgAttrs), rgAttrs },
            EN_INFOTYPES_TYPES_VALS
        };
    
        ULONG       dirError;
        READRES *   pReadRes = NULL;
    
        rgAttrs[0].attrTyp = attid;
        
        dirError = KccRead(pdnNC, &Sel, &pReadRes);
    
        if (0 != dirError) {
            if (nameError == dirError) {
                NAMERR * pnamerr = &pReadRes->CommRes.pErrInfo->NamErr;
    
                if ((NA_PROBLEM_NO_OBJECT == pnamerr->problem)
                    && (DIRERR_OBJ_NOT_FOUND == pnamerr->extendedErr)) {
                    // 'salright; NC head is not yet instantiated
                    m_cLinks = 0;
                    m_InstanceType = IT_UNINSTANT;
                    m_fIsInitialized = TRUE;
                }
            } else if (referralError == dirError) {
                // 'salright; NC head is not yet instantiated
                m_cLinks = 0;
                m_InstanceType = IT_UNINSTANT;
                m_fIsInitialized = TRUE;
            }
    
            if (!m_fIsInitialized) {
                // other error; bail
                KCC_LOG_READ_FAILURE(pdnNC, dirError);
                KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
            }
        } else {
            // found links; create corresponding KCC_LINKs
            m_InstanceType = IT_UNINSTANT;
    
            for (DWORD iAttr = 0;
                 iAttr < pReadRes->entry.AttrBlock.attrCount;
                 iAttr++) {
                ATTR * pattr = &pReadRes->entry.AttrBlock.pAttr[iAttr];
    
                switch (pattr->attrTyp) {
                case ATT_INSTANCE_TYPE:
                    Assert(1 == pattr->AttrVal.valCount);
                    Assert(sizeof(m_InstanceType) == pattr->AttrVal.pAVal->valLen);
                    m_InstanceType = *((SYNTAX_INTEGER *) pattr->AttrVal.pAVal->pVal);
                    break;
    
                case ATT_REPS_FROM:
                case ATT_REPS_TO:
                    Assert(attid == pattr->attrTyp);
    
                    m_plink = new KCC_LINK[pattr->AttrVal.valCount];
                    m_cLinks = 0;
                    for (DWORD iAttrVal = 0;
                         iAttrVal < pattr->AttrVal.valCount;
                         iAttrVal++) {
                        Assert( pattr->AttrVal.pAVal[iAttrVal].pVal );
                        if (m_plink[m_cLinks].Init(
                                (REPLICA_LINK *) pattr->AttrVal.pAVal[iAttrVal].pVal)) {
                            m_cLinks++;
                        }
                    }
    
                    Assert(m_cLinks == pattr->AttrVal.valCount);
                    break;
    
                default:
                    Assert(!"Received unrequested attribute!");
                    DPRINT1(0, "Received unrequested attribute 0x%X.\n",
                            pattr->attrTyp);
                    break;
                }
            }
    
            Assert(ISVALIDINSTANCETYPE(m_InstanceType));
            Assert(!(IT_UNINSTANT & m_InstanceType));
    
            m_fIsInitialized = TRUE;
        }
    } else {
        // NC is not present -- no need to perform the read.
        m_cLinks = 0;
        m_InstanceType = IT_UNINSTANT;
        m_fIsInitialized = TRUE;
    }

    // Check that we don't have too many replication partners for this NC
    if( m_cLinks > KCC_REPLICATION_PARTNER_LIMIT ) {
        LogEvent(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_KCC_TOO_MANY_PARTNERS,
            szInsertUL(m_cLinks),
            szInsertDN(pdnNC),
            szInsertUL(KCC_REPLICATION_PARTNER_LIMIT)
            );
    }

    return m_fIsInitialized;
}

void
KCC_LINK_LIST::Reset()
//
// Set member variables to their pre-Init() values.
//
{
    m_fIsInitialized = FALSE;
    m_cLinks         = 0;
    m_plink          = NULL;
    m_InstanceType   = 0;
}

KCC_LINK *
KCC_LINK_LIST::GetLinkFromSourceDSAAddr(
    IN  MTX_ADDR *  pmtx
    )
//
// Retrieve link with the given transport address.  Returns NULL if none found.
//
{
    KCC_LINK * plink = NULL;

    ASSERT_VALID( this );

    for ( DWORD iLink = 0; iLink < m_cLinks; iLink++ )
    {
        if ( MtxSame( pmtx, GetLink( iLink )->GetDSAAddr() ) )
        {
            plink = GetLink( iLink );
            break;
        }
    }

    return plink;
}

KCC_LINK *
KCC_LINK_LIST::GetLinkFromSourceDSAObjGuid(
    IN  GUID *  pObjGuid
    )
//
// Retrieve the link with the specified source ntdsDsa objectGuid.
// Returns NULL if none found.
//
{
    KCC_LINK * plink = NULL;

    ASSERT_VALID(this);

    for (DWORD iLink = 0; iLink < m_cLinks; iLink++) {
        if (0 == memcmp(pObjGuid, GetLink(iLink)->GetDSAUUID(), sizeof(GUID))) {
            plink = GetLink( iLink );
            break;
        }
    }

    return plink;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kccdynar.cxx ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccdynar.cxx

ABSTRACT:

    This file defines some dynamic array classes           

DETAILS:


CREATED:

    03/27/97    Colin Brace (ColinBr)

REVISION HISTORY:

--*/

#include <NTDSpchx.h>
#include <dsconfig.h>
#include "kcc.hxx"
#include "kcctools.hxx"
#include "kccdsa.hxx"
#include "kccconn.hxx"
#include "kccsite.hxx"
#include "kccsitelink.hxx"
#include "kccbridge.hxx"
#include "kcctrans.hxx"
#include "kccsconn.hxx"
#include "kccdynar.hxx"

#define FILENO FILENO_KCC_KCCDYNAR

int __cdecl
CompareDsName(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are pointers to pointers to DSNAME's
//
//
{
    PDSNAME DsName1 =  *(PDSNAME*)elem1;
    PDSNAME DsName2 =  *(PDSNAME*)elem2;

    Assert(DsName1);
    Assert(DsName2);

    Assert(!fNullUuid(&DsName1->Guid));
    Assert(!fNullUuid(&DsName2->Guid));

    return memcmp(&DsName1->Guid, &DsName2->Guid, sizeof(GUID));
}

int __cdecl
CompareDsNameSortElement(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are pointers DSNAME_SORT_ELEMENTS
//
//
{
    PKCC_DSNAME_SORT_ELEMENT pElem1 =  (PKCC_DSNAME_SORT_ELEMENT)elem1;
    PKCC_DSNAME_SORT_ELEMENT pElem2 =  (PKCC_DSNAME_SORT_ELEMENT)elem2;

    Assert(pElem1);
    Assert(pElem2);

    return strcmp( pElem1->pszStringKey, pElem2->pszStringKey );
}

int __cdecl
CompareDsNameSiteElement(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are pointers DSNAME_SITE_ELEMENTS
//
//
{
    PKCC_DSNAME_SITE_ELEMENT pElem1 =  (PKCC_DSNAME_SITE_ELEMENT)elem1;
    PKCC_DSNAME_SITE_ELEMENT pElem2 =  (PKCC_DSNAME_SITE_ELEMENT)elem2;

    Assert(pElem1);
    Assert(pElem2);

    return strcmp( pElem1->pszStringKey, pElem2->pszStringKey );
}

int __cdecl
CompareDsa(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are pointers to pointers to KCC_DSA objects
//
//
{
    KCC_DSA* Dsa1 =  *(KCC_DSA**)elem1;
    KCC_DSA* Dsa2 =  *(KCC_DSA**)elem2;

    Assert(Dsa1);
    Assert(Dsa2);

    PDSNAME  DsName1 = Dsa1->GetDsName();
    PDSNAME  DsName2 = Dsa2->GetDsName();

    Assert(DsName1);
    Assert(DsName2);

    return CompareDsName(&DsName1, &DsName2);

}

int __cdecl
CompareConnection(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are pointers to pointers to KCC_CONNECTION objects
//
{
    KCC_CONNECTION* pcn1 =  *(KCC_CONNECTION**)elem1;
    KCC_CONNECTION* pcn2 =  *(KCC_CONNECTION**)elem2;

    Assert( pcn1 );
    Assert( pcn2 );

    PDSNAME  pdn1 = pcn1->GetConnectionDN();
    PDSNAME  pdn2 = pcn2->GetConnectionDN();

    Assert( pdn1 );
    Assert( pdn2 );

    return CompareDsName( &pdn1, &pdn2 );

}

int __cdecl
CompareSiteAndSettings(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are pointers to pointers to KCC_SITE objects
//
{

    KCC_SITE* psite1 =  *(KCC_SITE**)elem1;
    KCC_SITE* psite2 =  *(KCC_SITE**)elem2;

    Assert( psite1 );
    Assert( psite2 );

    // NTDS Sites Settings objectGuid originally chosen for sort order because
    // it was the only one at the time that had the objectGuid filled in.  The
    // NTDS Site Settings object may be absent or deleted in some degenerate
    // cases, however, so in which case we use the objectGuid of the site
    // object.  (If it weren't for backwards compatibility we'd just sort by
    // site objectGuid unilaterally.)

    PDSNAME pdn1 = psite1->GetNtdsSettingsDN();
    if (NULL == pdn1) {
        pdn1 = psite1->GetObjectDN();
    }

    PDSNAME pdn2 = psite2->GetNtdsSettingsDN();
    if (NULL == pdn2) {
        pdn2 = psite2->GetObjectDN();
    }

    Assert( pdn1 );
    Assert( pdn2 );

    return CompareDsName( &pdn1, &pdn2 );
}


int __cdecl
CompareIndirectSiteGuid(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are pointers to pointers to KCC_SITE objects
//
{

    KCC_SITE* psite1 =  *(KCC_SITE**)elem1;
    KCC_SITE* psite2 =  *(KCC_SITE**)elem2;

    Assert( psite1 );
    Assert( psite2 );

    // Sort by site object guid in all cases

    PDSNAME pdn1 = psite1->GetObjectDN();
    PDSNAME pdn2 = psite2->GetObjectDN();

    Assert( pdn1 );
    Assert( pdn2 );

    return CompareDsName( &pdn1, &pdn2 );
}

int __cdecl
CompareSiteLink(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are pointers to pointers to KCC_SITE_LINK objects
//
{

    KCC_SITE_LINK* psite1 =  *(KCC_SITE_LINK**)elem1;
    KCC_SITE_LINK* psite2 =  *(KCC_SITE_LINK**)elem2;

    Assert( psite1 );
    Assert( psite2 );

    // Sort by site object guid in all cases

    PDSNAME pdn1 = psite1->GetObjectDN();
    PDSNAME pdn2 = psite2->GetObjectDN();

    Assert( pdn1 );
    Assert( pdn2 );

    return CompareDsName( &pdn1, &pdn2 );
}

int __cdecl
CompareBridge(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are pointers to pointers to KCC_SITE_LINK objects
//
{

    KCC_BRIDGE* pBridge1 =  *(KCC_BRIDGE**)elem1;
    KCC_BRIDGE* pBridge2 =  *(KCC_BRIDGE**)elem2;

    Assert( pBridge1 );
    Assert( pBridge2 );

    // Sort by site object guid in all cases

    PDSNAME pdn1 = pBridge1->GetObjectDN();
    PDSNAME pdn2 = pBridge2->GetObjectDN();

    Assert( pdn1 );
    Assert( pdn2 );

    return CompareDsName( &pdn1, &pdn2 );
}


int __cdecl
CompareSiteConnections(
    const void *elem1, 
    const void *elem2
    )
{

    KCC_SITE_CONNECTION* psconn1 =  *(KCC_SITE_CONNECTION**)elem1;
    KCC_SITE_CONNECTION* psconn2 =  *(KCC_SITE_CONNECTION**)elem2;

    Assert( psconn1 );
    Assert( psconn2 );

    //
    // The ordering is not really important since these are just in memory
    // objects
    //

    if ( psconn1 == psconn2 )
    {
        return 0;
    }
    else if ( psconn1 < psconn2 )
    {
        return -1;
    }
    else
    {
        return 1;
    }

}

int __cdecl
CompareCrossRefIndirectByNCDN(
    const void *elem1,
    const void *elem2
    )
{
    KCC_CROSSREF * pCR1 = *((KCC_CROSSREF **) elem1);
    KCC_CROSSREF * pCR2 = *((KCC_CROSSREF **) elem2);

    ASSERT_VALID(pCR1);
    ASSERT_VALID(pCR2);

    DSNAME * pdn1 = pCR1->GetNCDN();
    DSNAME * pdn2 = pCR2->GetNCDN();

    return CompareDsName(&pdn1, &pdn2);
}

VOID
KCC_DYNAMIC_ARRAY::Add(
    VOID* pElement
    )
{
    Assert(pElement);
    Assert( m_Count <= m_ElementsAllocated );

    if (m_Count == m_ElementsAllocated) {
        //
        // Allocate some more memory
        //
        BYTE* NewArray;
        // Exponential growth
        if (m_ElementsAllocated) {
            m_ElementsAllocated *= 2;
        } else {
            m_ElementsAllocated = m_InitialElements;
        }
        NewArray = new BYTE[m_ElementsAllocated*KccDwordAlignUlong(m_SizeOfElement)];

        //
        // Allocator should throw an exception if allocation failed
        // Allocator will initialize elements to zero.
        //

        //
        // Copy over existing elements
        //
        if (m_Count > 0) {
            Assert(m_Array);
            memcpy(NewArray, m_Array, m_Count*KccDwordAlignUlong(m_SizeOfElement));
        }

        //
        // Remove the old one and replace
        //
        if (m_Array) {
            delete [] m_Array;
        }
        m_Array = NewArray;
    }

    memcpy(&m_Array[m_Count*KccDwordAlignUlong(m_SizeOfElement)], pElement, m_SizeOfElement);
    m_Count++;

    m_fIsSorted = FALSE;
}


VOID
KCC_DYNAMIC_ARRAY::Remove(
    VOID* pElement
    )
{
    DWORD i = -1;
    
    Find(pElement, &i);
    Assert((-1 != i) && "pElement must be in the array!");

    Remove(i);
}


VOID
KCC_DYNAMIC_ARRAY::Remove(
    DWORD i
    )
{
    DWORD cbElement = KccDwordAlignUlong(m_SizeOfElement);

    Assert(i < m_Count);

    memmove(&m_Array[i * cbElement],
            &m_Array[(i+1) * cbElement],
            (m_Count - i - 1) * cbElement);
    m_Count--;
}


VOID *
KCC_DYNAMIC_ARRAY::Find(
    IN  VOID *  pElement,
    OUT DWORD * piElementIndex
    )
{
    VOID * pReturn = NULL;

    Assert(pElement);
    
    if (m_fIsSorted) {
        pReturn = bsearch(pElement,
                          m_Array,
                          m_Count,
                          KccDwordAlignUlong(m_SizeOfElement),
                          m_CompareFunction);
        if (NULL != piElementIndex) {
            *piElementIndex =
                ((DWORD)(((BYTE *) pReturn) - ((BYTE *) m_Array))) /
                KccDwordAlignUlong(m_SizeOfElement);
        }
    }
    else {
        for (ULONG i = 0; i < m_Count; i++) {
            VOID * pCurrent = Get(i);

            if (0 == m_CompareFunction(pElement, pCurrent)) {
                pReturn = pCurrent;
                if (NULL != piElementIndex) {
                    *piElementIndex = i;
                }
                break;
            }
        }
    }
    
    return pReturn;
}


VOID
KCC_DSA_ARRAY::GetLocalDsasHoldingNC(
    IN     KCC_CROSSREF        *pCrossRef,
    IN     BOOL                 fMasterOnly
    )
/*++

Routine Description:

    Given the crossref for an NC, find all DSAs in the local site
    hosting the NC. If 'fMasterOnly' is true, we only accept
    DSAs which host a master copy. The previous contents of this
    DSA array are removed.

Parameters:

    pCrossRef        - The Crossref for the NC we're searching on
    fMasterOnly      - If this is true, we only accept DSAs holding a
                       master copy
                       
Returns:

    None - the only errors are unexpected errors - so an exception is thrown
    
--*/
{
    KCC_DSA_LIST   *pDsaList = gpDSCache->GetLocalSite()->GetDsaList();
    KCC_DSA        *pDsa, *pLocalDsa = gpDSCache->GetLocalDSA();
    BOOL            fIsMaster;
    DWORD           idsa, cdsa;

    ASSERT_VALID( this );
    ASSERT_VALID( pDsaList );
    ASSERT_VALID( pCrossRef );

    this->RemoveAll();

    cdsa = pDsaList->GetCount();
    for( idsa=0; idsa<cdsa; idsa++ ) {
        pDsa = pDsaList->GetDsa(idsa);
        ASSERT_VALID(pDsa);

        if(    pDsa->IsNCHost(pCrossRef, (pDsa==pLocalDsa), &fIsMaster)
           && (!fMasterOnly || fIsMaster) )
        {
            this->Add(pDsa);
        }
    }
}

VOID
KCC_DSA_ARRAY::GetLocalGCs(
    VOID
    )
/*++

Routine Description:

    Find all GCs in the local site and add them this DSA Array.
    All previous contents of this array are removed.

Parameters:

    None

Return values:

    None
    
--*/
{
    KCC_DSA_LIST   *pDsaList = gpDSCache->GetLocalSite()->GetDsaList();
    KCC_DSA        *pDsa;
    DWORD           idsa, cdsa;

    ASSERT_VALID( this );
    ASSERT_VALID( pDsaList );

    this->RemoveAll();

    cdsa = pDsaList->GetCount();
    for( idsa=0; idsa<cdsa; idsa++ )
    {
        pDsa = pDsaList->GetDsa(idsa);
        ASSERT_VALID(pDsa);
        
        if(pDsa->IsGC()) {
            this->Add(pDsa);
        }
    }
}


VOID
KCC_DSA_ARRAY::GetViableISTGs(
    VOID
    )
/*++

Routine Description:

    Find all DCs in the local site which are acceptable ISTGs.
    All previous contents of the array are removed.

Parameters:

    None

Return values:

    None

--*/
{
    KCC_DSA_LIST   *pDsaList = gpDSCache->GetLocalSite()->GetDsaList();
    KCC_DSA        *pDsa, *pLocalDSA = gpDSCache->GetLocalDSA();
    DWORD           idsa, cdsa;

    ASSERT_VALID( this );
    ASSERT_VALID( pDsaList );
    Assert( 0 != pDsaList->GetCount() );
    Assert( pLocalDSA == pDsaList->GetDsa(pLocalDSA->GetDsName()) );
    Assert( pLocalDSA->IsViableSiteGenerator() );

    this->RemoveAll();

    // Of the DSAs in this site, which are viable ISTGs?
    cdsa = pDsaList->GetCount();
    for( idsa=0; idsa<cdsa; idsa++ ) {
        pDsa = pDsaList->GetDsa(idsa);
        if( pDsa->IsViableSiteGenerator() ) {
            this->Add(pDsa);
        }
    }

    // At minimum the local DSA should be in this list.
    Assert(0 != this->GetCount());
    Assert(NULL != this->Find(pLocalDSA->GetDsName()));
}


KCC_DSA *
KCC_DSA_ARRAY::Find(
    IN  DSNAME *  pDsName,
    OUT DWORD *   piElementIndex
    )
{
    Assert(pDsName);

    KCC_DSA     DsaKey;
    KCC_DSA *   pDsaKey = &DsaKey;
    KCC_DSA **  ppDsaFound;
    KCC_DSA *   pDsaFound = NULL;

    DsaKey.InitForKey(pDsName);

    ppDsaFound = (KCC_DSA **) KCC_DYNAMIC_ARRAY::Find(&pDsaKey, piElementIndex);

    if (NULL != ppDsaFound) {
        pDsaFound = *ppDsaFound;
    }

    return pDsaFound;
}


KCC_SITE *
KCC_SITE_ARRAY::Find(
    IN  DSNAME *  pDsName
    )
{
    Assert(pDsName);

    KCC_SITE     SiteKey;
    KCC_SITE *   pSiteKey = &SiteKey;
    KCC_SITE **  ppSiteFound;
    KCC_SITE *   pSiteFound = NULL;

    Assert( m_fIsSorted );

    // This routine only initialzes the site object dn part of the key.
    // It only works with a sorting scheme that is based on the site
    // object dn only. Thus it cannot be used with the legacy CompareSite
    // sorting function.
    Assert( m_CompareFunction != CompareSiteAndSettings );

    SiteKey.InitForKey(pDsName);

    ppSiteFound = (KCC_SITE **) KCC_DYNAMIC_ARRAY::Find(&pSiteKey);

    if (NULL != ppSiteFound) {
        pSiteFound = *ppSiteFound;
    }

    return pSiteFound;
}

KCC_SITE_LINK *
KCC_SITE_LINK_ARRAY::Find(
    IN  DSNAME *  pDsName
    )
{
    Assert(pDsName);

    KCC_SITE_LINK     SiteKey;
    KCC_SITE_LINK *   pSiteKey = &SiteKey;
    KCC_SITE_LINK **  ppSiteFound;
    KCC_SITE_LINK *   pSiteFound = NULL;

    Assert( m_fIsSorted );

    SiteKey.InitForKey(pDsName);

    ppSiteFound = (KCC_SITE_LINK **) KCC_DYNAMIC_ARRAY::Find(&pSiteKey);

    if (NULL != ppSiteFound) {
        pSiteFound = *ppSiteFound;
    }

    return pSiteFound;
}

KCC_BRIDGE *
KCC_BRIDGE_ARRAY::Find(
    IN  DSNAME *  pDsName
    )
{
    Assert(pDsName);

    KCC_BRIDGE     BridgeKey;
    KCC_BRIDGE *   pBridgeKey = &BridgeKey;
    KCC_BRIDGE **  ppBridgeFound;
    KCC_BRIDGE *   pBridgeFound = NULL;

    Assert( m_fIsSorted );

    BridgeKey.InitForKey(pDsName);

    ppBridgeFound = (KCC_BRIDGE **) KCC_DYNAMIC_ARRAY::Find(&pBridgeKey);

    if (NULL != ppBridgeFound) {
        pBridgeFound = *ppBridgeFound;
    }

    return pBridgeFound;
}



VOID
KCC_DSNAME_ARRAY::Add(
    IN DSNAME * pdn
    )
{
    KCC_DSNAME_SORT_ELEMENT dse;

    dse.pszStringKey = DSNAMEToMappedStrExternal( pdn );
    dse.pDn = pdn;

    KCC_DYNAMIC_ARRAY::Add(&dse);
}

BOOL
KCC_DSNAME_ARRAY::IsElementOf(
    IN DSNAME * pdn
    )
{
    KCC_DSNAME_SORT_ELEMENT dse;
    VOID *pvElement;

    // This is a dummy search key
    dse.pszStringKey = DSNAMEToMappedStrExternal( pdn );
    dse.pDn = NULL;

    pvElement = KCC_DYNAMIC_ARRAY::Find(&dse);

    THFree( dse.pszStringKey );

    return pvElement != NULL;
}





VOID
KCC_DSNAME_SITE_ARRAY::Add(
    IN DSNAME * pdn,
    IN KCC_SITE *pSite
    )
{
    KCC_DSNAME_SITE_ELEMENT dse;

    dse.pszStringKey = DSNAMEToMappedStrExternal( pdn );
    dse.pSite = pSite;

    KCC_DYNAMIC_ARRAY::Add(&dse);
}

KCC_SITE *
KCC_DSNAME_SITE_ARRAY::Find(
    IN DSNAME * pdn
    )
{
    KCC_DSNAME_SITE_ELEMENT dse;
    VOID *pvElement;

    // This is a dummy search key
    dse.pszStringKey = DSNAMEToMappedStrExternal( pdn );
    dse.pSite = NULL;

    pvElement = KCC_DYNAMIC_ARRAY::Find(&dse);

    THFree( dse.pszStringKey );

    if (pvElement) {
        return ((KCC_DSNAME_SITE_ELEMENT *) pvElement)->pSite;
    } else {
        return NULL;
    }
}

BOOL
KCC_DSNAME_SITE_ARRAY::IsElementOf(
    IN DSNAME * pdn
    )
{
    return (Find( pdn ) != NULL);
}





KCC_REPLICATED_NC *
KCC_REPLICATED_NC_ARRAY::Find(
    IN DSNAME * pNC
    )
{
    KCC_REPLICATED_NC keybase;
    KCC_REPLICATED_NC *key = &keybase;
    VOID *pvElement;

    keybase.pNC = pNC;
    keybase.fReadOnly = FALSE; // ignored

    pvElement = KCC_DYNAMIC_ARRAY::Find(&key);

    if (pvElement) {
        return *((KCC_REPLICATED_NC **) pvElement);
    } else {
        return NULL;
    }
}

int __cdecl
KCC_REPLICATED_NC_ARRAY::CompareIndirect(
    IN const void *elem1,
    IN const void *elem2
    )
{
    KCC_REPLICATED_NC * p1 = *(KCC_REPLICATED_NC **) elem1;
    KCC_REPLICATED_NC * p2 = *(KCC_REPLICATED_NC **) elem2;
    int nDiff;

    Assert(!fNullUuid(&p1->pNC->Guid));
    Assert(!fNullUuid(&p2->pNC->Guid));

    nDiff = CompareDsName(&p1->pNC, &p2->pNC);
    
    return nDiff;
}

BOOL
KCC_NC_TRANSPORT_BRIDGEHEAD_ARRAY::Find(
     IN  DSNAME *        pNC,
     IN  KCC_TRANSPORT * pTransport,
     IN  BOOL            fGCTopology,
     OUT KCC_DSA **      ppDSA
     )
{
    KCC_NC_TRANSPORT_BRIDGEHEAD_ENTRY Key = {pNC, pTransport, fGCTopology, NULL};
    KCC_NC_TRANSPORT_BRIDGEHEAD_ENTRY * pFound;

    pFound = (KCC_NC_TRANSPORT_BRIDGEHEAD_ENTRY *) KCC_DYNAMIC_ARRAY::Find(&Key);
    if (NULL != pFound) {
        *ppDSA = pFound->pDSA;
    }

    return (NULL != pFound);
}

int __cdecl
KCC_NC_TRANSPORT_BRIDGEHEAD_ARRAY::Compare(
    const void *elem1, 
    const void *elem2
    )
{
    KCC_NC_TRANSPORT_BRIDGEHEAD_ENTRY * p1 = (KCC_NC_TRANSPORT_BRIDGEHEAD_ENTRY *) elem1;
    KCC_NC_TRANSPORT_BRIDGEHEAD_ENTRY * p2 = (KCC_NC_TRANSPORT_BRIDGEHEAD_ENTRY *) elem2;
    int nDiff;

    nDiff = p1->fGCTopology - p2->fGCTopology;

    if (0 == nDiff) {
        if (p1->pTransport > p2->pTransport) {
            nDiff = 1;
        } else if (p1->pTransport < p2->pTransport) {
            nDiff = -1;
        } else {
            nDiff = 0;
        }
    }
    
    if (0 == nDiff) {
        nDiff = CompareDsName(&p1->pNC, &p2->pNC);
    }

    return nDiff;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kccsconn.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccsconn.cxx

ABSTRACT:

    KCC_SITE_CONNECTION

                       
    This class does not represent a ds object.  It represents a transport 
    connection between two sites in an enterprise.  Typically the information
    will get filled in from calls to transport plugin via ntism

CREATED:

    12/05/97    Colin Brace ( ColinBr )

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include "kcc.hxx"
#include "kccsite.hxx"
#include "kccconn.hxx"
#include "kcclink.hxx"
#include "kccdsa.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include "kcccref.hxx"
#include "kccstale.hxx"
#include "kcctrans.hxx"

#include "kccsconn.hxx"


#define FILENO FILENO_KCC_KCCSCONN


void
KCC_SITE_CONNECTION::Reset()
// Set member variables to pre-init state
//
// Note, if this function is called on an initialized object, memory will
// be orphaned.  This may not matter since the memory is on the thread heap.
{
    TOPL_SCHEDULE_CACHE     scheduleCache;
   
    scheduleCache = gpDSCache->GetScheduleCache();
    Assert( NULL!=scheduleCache );

    m_fIsInitialized   = FALSE;

    m_pTransport       = NULL;
    m_pSourceSite      = NULL;
    m_pDestinationSite = NULL;
    m_pSourceDSA       = NULL;
    m_pDestinationDSA  = NULL;
    m_ulReplInterval   = 0;
    m_pToplSchedule    = ToplGetAlwaysSchedule( scheduleCache );
    m_ulOptions        = 0;
}

BOOL
KCC_SITE_CONNECTION::IsValid()
{
    return m_fIsInitialized;
}

KCC_SITE_CONNECTION&
KCC_SITE_CONNECTION::SetSchedule(
    TOPL_SCHEDULE toplSchedule,
    ULONG         ReplInterval
    )
//
// We convert the schedule from a range of availability to a schedule of polls.
// We map the generic schedule of availability, plus the replication interval
// (in minutes) into the number of 15 minute intervals to skip.
//
{
    TOPL_SCHEDULE_CACHE     scheduleCache;

    ASSERT_VALID( this );
    
    scheduleCache = gpDSCache->GetScheduleCache();
    Assert( NULL!=scheduleCache );
    
    m_pToplSchedule = ToplScheduleCreate(scheduleCache, ReplInterval, toplSchedule);    

    return *this;
}

KCC_SITE_CONNECTION&
KCC_SITE_CONNECTION::SetDefaultSchedule(
    ULONG ReplInterval
    )
//
// Construct a default schedule based on the cost
// We convert the schedule from a range of availability to a schedule of polls.
// We always construct a schedule: we never leave it NULL.
//
{
    TOPL_SCHEDULE_CACHE     scheduleCache;

    ASSERT_VALID( this );
    
    scheduleCache = gpDSCache->GetScheduleCache();
    Assert( NULL!=scheduleCache );
    
    m_pToplSchedule = ToplScheduleCreate(scheduleCache, ReplInterval, NULL);    

    return *this;
}

KCC_SITE_CONNECTION&
KCC_SITE_CONNECTION::SetSourceSite(
    IN KCC_SITE *pSite
    )
{
    ASSERT_VALID( this );

    Assert( pSite );

    //
    // This CTOPL_EDGE method links the edge part
    // of this site connection to the vertex part
    // object pSite
    //
    CTOPL_EDGE::SetFrom( pSite );

    m_pSourceSite = pSite;

    return *this;
}

KCC_SITE_CONNECTION&
KCC_SITE_CONNECTION::SetDestinationSite(
    IN KCC_SITE *pSite
    )
{
    ASSERT_VALID( this );

    Assert( pSite );

    //
    // This CTOPL_EDGE method links the edge part
    // of this site connection to the vertex part
    // object pSite
    //
    CTOPL_EDGE::SetTo( pSite );

    m_pDestinationSite = pSite;

    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kccsite.cxx ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccsite.cxx

ABSTRACT:

    KCC_SITE class.

DETAILS:

    This class represents the DS notion of sites -- specifically,
    NTDS-Site-Settings DS objects (and perhaps later also properties from 
    their parent Site DS objects).

    NTDS-Site-Settings DS objects hold site-specific DS configuration 
    information; e.g., whether automatic generation of connection objects 
    is enabled for the site.

CREATED:

    03/12/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include "kcc.hxx"
#include "kccdynar.hxx"
#include "kccsite.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include "kccdsa.hxx"
#include "kcctrans.hxx"
#include "kccconn.hxx"
#include "kccsconn.hxx"
#include "dsconfig.h"
#include "dsutil.h"

#define FILENO FILENO_KCC_KCCSITE


/*++

Inline Logging Functions

Below are a list of macros which log information using the debugging facilities
and the event log functions. The use of these functions helps to keep the
actual code more readable.

--*/

#define InlineLogWhistlerElectionAlgorithm \
    DPRINT( 3, "KCC is using the Whistler ISTG Election Algorithm\n" ); \
    LogEvent(DS_EVENT_CAT_KCC, \
             DS_EVENT_SEV_INTERNAL, \
             DIRLOG_KCC_WHISTLER_ELECTION_ALG, \
             0, 0, 0);

#define InlineLogISTGNotViable \
    DPRINT1(0, "Site generator %ls is not in the local site or does not" \
               " understand NDNCs.\n", \
            m_pdnSiteGenerator->StringName); \
    LogEvent(DS_EVENT_CAT_KCC, \
             DS_EVENT_SEV_EXTENSIVE, \
             DIRLOG_KCC_SITE_GENERATOR_NOT_VIABLE, \
             szInsertDN(m_pdnSiteGenerator), 0, 0);      

#define InlineLogLocalDSAIsISTG \
    DPRINT1(3, "The local DSA is still the site generator.\n", \
        m_pdnSiteGenerator->StringName);

#define InlineLogISTGNotInUTD \
    DPRINT1(0, "No up-to-dateness information for site generator %ls\n", \
            m_pdnSiteGenerator->StringName); \
    LogEvent(DS_EVENT_CAT_KCC, \
             DS_EVENT_SEV_EXTENSIVE, \
             DIRLOG_KCC_SITE_GENERATOR_NO_UTD, \
             szInsertDN(m_pdnSiteGenerator), 0, 0);

#define InlineLogISTGReplicatedInFuture \
    {   CHAR szTime[SZDSTIME_LEN]; \
        DSTimeToDisplayString(m_timeSiteGenSet, szTime); \
        DPRINT2(0, "We replicated from the site generator %ls in " \
                   "the future at %s!\n", \
                   pDsa->GetDsName()->StringName, szTime ); \
    }

#define InlineLogISTGClaimValid \
    {   CHAR szTime[SZDSTIME_LEN]; \
        DSTimeToDisplayString(m_timeSiteGenSet, szTime); \
        DPRINT2(2, "The site generator claim by %ls was last " \
                   "updated at %s. This claim is still valid.\n", \
                   m_pdnSiteGenerator->StringName, szTime); \
        LogEvent(DS_EVENT_CAT_KCC, \
                 DS_EVENT_SEV_EXTENSIVE, \
                 DIRLOG_KCC_SITE_GENERATOR_CLAIM_VALID, \
                 szInsertDN(m_pdnSiteGenerator), \
                 szInsertSz(szTime), 0); \
    }

#define InlineLogISTGClaimExpired \
    {   CHAR szTime[SZDSTIME_LEN]; \
        DSTimeToDisplayString(m_timeSiteGenSet, szTime); \
        DPRINT2(0, "The site generator claim by %ls has expired; " \
                   "last claim update was at %s.\n", \
                m_pdnSiteGenerator->StringName, szTime); \
        LogEvent(DS_EVENT_CAT_KCC, \
                 DS_EVENT_SEV_EXTENSIVE, \
                 DIRLOG_KCC_SITE_GENERATOR_CLAIM_EXPIRED, \
                 szInsertDN(m_pdnSiteGenerator), \
                 szInsertSz(szTime), 0); \
    }

#define InlineLogClaimedISTGRole \
    DPRINT(2, "Assumed site generator role.\n"); \
    LogEvent(DS_EVENT_CAT_KCC, \
             DS_EVENT_SEV_ALWAYS, \
             DIRLOG_CHK_CLAIMED_SITE_GENERATOR_ROLE, \
             0, 0, 0);

#define InlineLogISTGFailOver \
    DPRINT1(2, "Site generator should fail-over to %ls.\n", \
            pDsa->GetDsName()->StringName); \
    LogEvent(DS_EVENT_CAT_KCC, \
             DS_EVENT_SEV_EXTENSIVE, \
             DIRLOG_KCC_ISTG_FAIL_OVER, \
             szInsertDN(pDsa->GetDsName()), 0, 0);

#define InlineLogUTDVecWrongVersion \
    DPRINT1(0, "The Uptodate Vector has version %d (expected 2)!.\n", \
             pUTDVec->dwVersion ); \
    LogEvent(DS_EVENT_CAT_KCC, \
             DS_EVENT_SEV_ALWAYS, \
             DIRLOG_KCC_ISTG_FAIL_OVER, \
             szInsertUL( pUTDVec->dwVersion ), 0, 0);

#define InlineLogBadSchedule \
    DPRINT1(0, "Invalid schedule on %ls!\n", \
            m_pdnNtdsSiteSettings->StringName); \
    LogEvent(DS_EVENT_CAT_KCC, \
             DS_EVENT_SEV_ALWAYS, \
             DIRLOG_CHK_BAD_SCHEDULE, \
             szInsertDN(m_pdnNtdsSiteSettings), \
             0, 0);

#define InlineLogIntrasiteUnavailable \
    LogEvent(DS_EVENT_CAT_KCC, \
             DS_EVENT_SEV_ALWAYS, \
             DIRLOG_KCC_INTRASITE_UNAVAILABLE, \
             szInsertDN(m_pdnSiteObject), \
             szInsertUL(maxUnavail), \
             szInsertUL(cSuggestedFailOver));


typedef struct _KCC_ENTINFLIST_AND_DSA {
    ENTINFLIST *  pEntInfList;
    KCC_DSA *     pDSA;
} KCC_ENTINFLIST_AND_DSA;

int __cdecl
CompareEntInfListAndDsaByDsaGuid(
    IN  const void *  pv1,
    IN  const void *  pv2
    )
{
    DSNAME * pDSADN1 = ((KCC_ENTINFLIST_AND_DSA *) pv1)->pDSA->GetDsName();
    DSNAME * pDSADN2 = ((KCC_ENTINFLIST_AND_DSA *) pv2)->pDSA->GetDsName();

    return CompareDsName(&pDSADN1, &pDSADN2);
}

int __cdecl
CompareIndirectEntinfDsnameString(
    IN  const void *  pv1,
    IN  const void *  pv2
    )
{
    ENTINF *pEntinf1 = *((ENTINF **) pv1);
    ENTINF *pEntinf2 = *((ENTINF **) pv2);

    return wcscmp( pEntinf1->pName->StringName, pEntinf2->pName->StringName );
}

///////////////////////////////////////////////////////////////////////////////
//
//  KCC_SITE methods
//

void
KCC_SITE::Reset()
//
// Set member variables to their pre-Init() state.
//
{
    m_fIsInitialized                = FALSE;
    m_dwOptions                     = 0;
    m_pdnSiteObject                 = NULL;
    m_pdnNtdsSiteSettings           = NULL;
    m_pSiteGeneratorDSA             = NULL;
    m_pdnSiteGenerator              = NULL;
    m_timeSiteGenSet                = 0;
    m_pDsaList                      = NULL;
    m_pTransportDsaLists            = NULL;
    m_cNumTransportDsaLists         = 0;
    m_pDestSiteConnMap              = NULL;
    m_destSiteConnMapSize           = 0;
    m_siteLinkBitmap                = 0;
    m_cSecsUntilSiteGenFailOver     = 0;
    m_cSecsUntilSiteGenRenew        = 0;
    m_fUnreachable                  = FALSE;
    
    m_NCTransportBridgeheadList.RemoveAll();
}

BOOL
KCC_SITE::InitForKey(
    IN  DSNAME   *    pdnSite
    )
//
// Init a KCC_SITE object for use as a key (i.e., solely for comparison use
// by bsearch()).
//
// WARNING: The DSNAME argument pdnSite must be valid for the lifetime of this
// object!
//
{
    Reset();

    m_pdnSiteObject = pdnSite;

    m_fIsInitialized = TRUE;

    return TRUE;
}


BOOL
KCC_SITE::InitSite(
    IN  DSNAME * pdnSite,
    IN  ENTINF * pSettingsEntInf
    )
// Initialize the object from an entinf
//
// Note, when called from KCC_SITE_LIST::Init, pSettingsEntinf->pName may have
// been changed to a different name for sorting purposes. Avoid this field.
{
    const PROPERTY_META_DATA    MetaDataKey = {ATT_INTER_SITE_TOPOLOGY_GENERATOR};
    
    PROPERTY_META_DATA_VECTOR  *pMetaDataVec = NULL;
    SCHEDULE                   *pSchedule = NULL;
    DWORD                       cMinsUntilSiteGenRenew    = 0;
    DWORD                       cMinsUntilSiteGenFailOver = 0;

    DSNAME                     *pdnLocalDSA = gpDSCache->GetLocalDSADN();

    Assert(NULL != pdnSite);
    Assert(!fNullUuid(&pdnSite->Guid));
    Reset();

    m_pdnSiteObject = (DSNAME *) new BYTE [pdnSite->structLen];
    memcpy( m_pdnSiteObject, pdnSite, pdnSite->structLen );

    if (NULL != pSettingsEntInf) {
        // Iterate through the returned atttributes
        for ( DWORD iAttr = 0; iAttr < pSettingsEntInf->AttrBlock.attrCount; iAttr++ )
        {
            ATTR *  pattr = &pSettingsEntInf->AttrBlock.pAttr[ iAttr ];
    
            switch ( pattr->attrTyp )
            {
            case ATT_OPTIONS:
                Assert( 1 == pattr->AttrVal.valCount );
                Assert( sizeof( DWORD ) == pattr->AttrVal.pAVal->valLen );
                m_dwOptions = *( (DWORD *) pattr->AttrVal.pAVal->pVal );
                break;
    
            case ATT_OBJ_DIST_NAME:
            {
                DSNAME *pDn = (DSNAME *) pattr->AttrVal.pAVal->pVal;
                Assert( 1 == pattr->AttrVal.valCount );

                m_pdnNtdsSiteSettings = (DSNAME *) new BYTE [pDn->structLen];
                memcpy( m_pdnNtdsSiteSettings, pDn, pDn->structLen );
                break;
            }
            case ATT_INTER_SITE_TOPOLOGY_GENERATOR:
            {
                DSNAME *pDn = (DSNAME *) pattr->AttrVal.pAVal->pVal;
                Assert(1 == pattr->AttrVal.valCount);

                m_pdnSiteGenerator = (DSNAME *) new BYTE [pDn->structLen];
                memcpy( m_pdnSiteGenerator, pDn, pDn->structLen );
                break;
            }
            case ATT_INTER_SITE_TOPOLOGY_RENEW:
                Assert(1 == pattr->AttrVal.valCount);
                cMinsUntilSiteGenRenew = *(DWORD *) pattr->AttrVal.pAVal->pVal;
                break;
    
            case ATT_INTER_SITE_TOPOLOGY_FAILOVER:
                Assert(1 == pattr->AttrVal.valCount);
                cMinsUntilSiteGenFailOver = *(DWORD *) pattr->AttrVal.pAVal->pVal;
                break;
    
            case ATT_REPL_PROPERTY_META_DATA:
                Assert(1 == pattr->AttrVal.valCount);
                pMetaDataVec = (PROPERTY_META_DATA_VECTOR *) pattr->AttrVal.pAVal->pVal;
                Assert(1 == pMetaDataVec->dwVersion);
                break;
    
            case ATT_SCHEDULE:
                Assert(1 == pattr->AttrVal.valCount);
                pSchedule = (SCHEDULE *) pattr->AttrVal.pAVal->pVal;
                Assert( IS_VALID_SCHEDULE(pSchedule) );
                break;
    
            default:
                DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp );
                break;
            }
        }
    }

    // Search the meta-data to find out when the ISTG attribute was last set.
    if (m_pdnNtdsSiteSettings) {
        Assert(NULL != pMetaDataVec);
        if (NULL!=pMetaDataVec && NULL!=m_pdnSiteGenerator) {
            // A site generator has been specified -- when was it last set?
            PROPERTY_META_DATA * pMetaData;
            
            pMetaData = (PROPERTY_META_DATA *)
                            bsearch(&MetaDataKey,
                                    &pMetaDataVec->V1.rgMetaData[0],
                                    pMetaDataVec->V1.cNumProps,
                                    sizeof(*pMetaData),
                                    KccCompareMetaData);
            Assert(NULL != pMetaData);

            m_timeSiteGenSet = pMetaData->timeChanged;
        }
    }

    // We retrieve the local DSA's DN from the cache to determine if this
    // site is the local site. It would be preferable to load the local site
    // from the cache to avoid the call to NamePrefix(), but we cannot do so
    // because we're in the middle of initializing the sites right now.
    if( NamePrefix(m_pdnSiteObject, pdnLocalDSA) ) {

        // Update our failover config.
        m_cSecsUntilSiteGenRenew    = MINS_IN_SECS * cMinsUntilSiteGenRenew;
        m_cSecsUntilSiteGenFailOver = MINS_IN_SECS * cMinsUntilSiteGenFailOver;

        SetIntrasiteSchedule( pSchedule );
    }

    m_fIsInitialized = TRUE;
    return m_fIsInitialized;
}


VOID
KCC_SITE::SetIntrasiteSchedule(
    IN  PSCHEDULE   pSchedule
    )
// 
// Set the intra-site schedule for use in the local site.
// The parameter may be NULL.
//
{
    DSNAME *pdnLocalDSA = gpDSCache->GetLocalDSADN();
    BOOL    fUseDefaultSchedule = TRUE;

    // This must be the local site.
    Assert( NamePrefix(m_pdnSiteObject, pdnLocalDSA) );

    if( pSchedule ) {
        if( !IS_VALID_SCHEDULE(pSchedule) ) {
            InlineLogBadSchedule;
        } else {
            // Update our cached intrasite schedule.
            gpIntrasiteSchedule = ToplScheduleImport(
                gpDSCache->GetScheduleCache(),
                pSchedule );
            fUseDefaultSchedule = FALSE;
        }
    }
    
    if( fUseDefaultSchedule ) {
        gpIntrasiteSchedule = ToplScheduleImport(
            gpDSCache->GetScheduleCache(),
            (PSCHEDULE) gpDefaultIntrasiteSchedule );
    }

    if( ToplScheduleDuration(gpIntrasiteSchedule)==0 ) {
        // If the site is configured to use an never schedule,
        // use the always schedule instead.
        gpIntrasiteSchedule = ToplGetAlwaysSchedule(
            gpDSCache->GetScheduleCache() );
    }

    gfIntrasiteSchedInited = TRUE;
}


VOID
KCC_SITE::CheckIntrasiteSchedule()
{
    DSNAME *pdnLocalDSA = gpDSCache->GetLocalDSADN();
    DWORD   maxUnavail, cMinsUntilSiteGenFailOver, cSuggestedFailOver;

    // This must be the local site.
    Assert( NamePrefix(m_pdnSiteObject, pdnLocalDSA) );

    // If we're using the Whistler ISTG Election algorithm, ensure that
    // the intra-site replication schedule won't cause the ISTG role
    // to fail-over unnecessarily.
    if( UseWhistlerElectionAlg() )
    {

        // Find out the longest contiguous number of minutes for which this
        // schedule in unavailable. From this value, compute a suggested
        // value for the ISTG failover period. If the actual ISTG failover
        // period is less than the suggested value, log an event.
        maxUnavail = ToplScheduleMaxUnavailable(gpIntrasiteSchedule);
        cSuggestedFailOver = maxUnavail + KCC_ISTG_FAILOVER_PADDING;
        cMinsUntilSiteGenFailOver = GetSecsUntilSiteGenFailOver() / 60;

        if( cMinsUntilSiteGenFailOver < cSuggestedFailOver ) {
            InlineLogIntrasiteUnavailable;
        }
    }
}


BOOL
KCC_SITE::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

BOOL
KCC_SITE::IsAutoTopologyEnabled()
//
// Is the automatic generation of connection objects (intra-site)
// currently enabled?
//
{
    ASSERT_VALID( this );

    return !( m_dwOptions & NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED );
}

BOOL
KCC_SITE::IsInterSiteAutoTopologyEnabled()
//
// Is the automatic generation of inter site connection objects
// currently enabled?
//
{
    ASSERT_VALID( this );

    return !( m_dwOptions & NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED );
}

BOOL
KCC_SITE::ForceWhistlerBehavior()
//
// Should we force the KCC to run in Whistler mode at this site?
//
{
    return !!( m_dwOptions & NTDSSETTINGS_OPT_FORCE_KCC_WHISTLER_BEHAVIOR );
}

BOOL
KCC_SITE::ForceW2KElection()
{
    return !!( m_dwOptions & NTDSSETTINGS_OPT_FORCE_KCC_W2K_ELECTION );
}

BOOL
KCC_SITE::UseWhistlerElectionAlg() {
    return gpDSCache->GetForestVersion() >= DS_BEHAVIOR_WHISTLER
        && !ForceW2KElection();
}

DWORD
KCC_SITE::GetSecsUntilSiteGenRenew() {
    if( 0==m_cSecsUntilSiteGenRenew ) {
        m_cSecsUntilSiteGenRenew = MINS_IN_SECS * KCC_DEFAULT_SITEGEN_RENEW;
    }
    Assert( 0!=m_cSecsUntilSiteGenRenew );
    return m_cSecsUntilSiteGenRenew;
}

DWORD
KCC_SITE::GetSecsUntilSiteGenFailOver() {
    if( 0==m_cSecsUntilSiteGenFailOver ) {
        m_cSecsUntilSiteGenFailOver =
              ( UseWhistlerElectionAlg() )
            ? ( MINS_IN_SECS * KCC_DEFAULT_SITEGEN_FAILOVER_WHISTLER )
            : ( MINS_IN_SECS * KCC_DEFAULT_SITEGEN_FAILOVER );
    }
    Assert( 0!=m_cSecsUntilSiteGenFailOver );
    return m_cSecsUntilSiteGenFailOver;
}

BOOL
KCC_SITE::IsRemoveConnectionsDisabled()
//
// Is the remove dead connections disabled?
//
{
    ASSERT_VALID( this );

    return !!( m_dwOptions & NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED );
}

BOOL
KCC_SITE::IsMinimizeHopsDisabled()
//
// Is the create creations to minimize hops disabled?
//
{
    ASSERT_VALID( this );

    return !!( m_dwOptions & NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED );
}

BOOL
KCC_SITE::IsDetectStaleServersDisabled()
//
// Is the detection of stale server disabled?
//
{
    ASSERT_VALID( this );
                             
    return !!( m_dwOptions & NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED );
}


PDSNAME
KCC_SITE::GetObjectDN()
{
    ASSERT_VALID( this );

    return m_pdnSiteObject;
}

PDSNAME
KCC_SITE::GetNtdsSettingsDN()
{
    ASSERT_VALID( this );

    return m_pdnNtdsSiteSettings;
}


int __cdecl
CompareCursorUUID(
    const void *p1,
    const void *p2
    )
/*++

Routine Description:

    Compare two Up-To-Date Cursors by the GUID of the DSA that
    they correspond to.

Parameters:

    Pointers to the two cursors.   

Return Values:

    <0  If Cursor1's DSA's GUID is less than Cursor2's DSA's GUID
    0   If the GUIDs are the same
    >0  If Cursor1's DSA's GUID is greater than Cursor2's DSA's GUID
    
--*/
{
    UPTODATE_CURSOR_V1 *pCursor1 = (UPTODATE_CURSOR_V1*) p1;
    UPTODATE_CURSOR_V1 *pCursor2 = (UPTODATE_CURSOR_V1*) p2;
    RPC_STATUS          rpcStatus;
    int                 result;
    
    result = UuidCompare( &pCursor1->uuidDsa,
                          &pCursor2->uuidDsa,
                          &rpcStatus );
    Assert( RPC_S_OK==rpcStatus );

    return result;
}


UPTODATE_VECTOR_V2*
KCC_SITE::GetUTDVector(
    VOID
    )
/*++

Routine Description:

    Load the Up-To-Date Vector from Config NC and return it to
    the caller.

Parameters:

    None

Return Values:

    If we successfully read the Up-To-Dateness vector we return a
    pointer to it. If we could not read it, we return NULL.

--*/
{
    READRES            *pReadRes = NULL;
    ATTR               *pAttr;
    UPTODATE_VECTOR    *pUTDVec = NULL;
    ULONG               dirError;

    ATTR                rgAttrs[] = {
                            { ATT_REPL_UPTODATE_VECTOR, {0, NULL} }
                        };    
    ENTINFSEL           Sel = {
                            EN_ATTSET_LIST,
                            { ARRAY_SIZE(rgAttrs), rgAttrs },
                            EN_INFOTYPES_TYPES_VALS
                        };
        
    // Search for the Up-To-Date Vector on the Config NC Head
    dirError = KccRead(gpDSCache->GetConfigNC(), &Sel, &pReadRes);
    if( 0 != dirError ) {
        if( attributeError==dirError ) {
            INTFORMPROB * pprob = &pReadRes->CommRes.pErrInfo->
                                        AtrErr.FirstProblem.intprob;

            if(   (PR_PROBLEM_NO_ATTRIBUTE_OR_VAL==pprob->problem)
               && (DIRERR_NO_REQUESTED_ATTS_FOUND==pprob->extendedErr))
            {
                // No value for this attribute; return 0.
                return NULL;
            }
        }

        KCC_LOG_READ_FAILURE(gpDSCache->GetConfigNC(), dirError);
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }

    // Check that the search results are reasonably consistent.
    Assert( pReadRes->entry.AttrBlock.attrCount==1 );
    if( pReadRes->entry.AttrBlock.attrCount!=1 ) {
        return NULL;
    }
    pAttr = &pReadRes->entry.AttrBlock.pAttr[0];
    Assert( pAttr->attrTyp==ATT_REPL_UPTODATE_VECTOR );
    Assert( 1==pAttr->AttrVal.valCount );
    if( pAttr->AttrVal.valCount!=1 ) {
        return NULL;
    }
        
    // Check that we have a Version 2 Up-To-Dateness Vector. 
    pUTDVec = (UPTODATE_VECTOR*) pAttr->AttrVal.pAVal[0].pVal;
    Assert( NULL!=pUTDVec );                
    Assert( 2==pUTDVec->dwVersion );
    if( 2!=pUTDVec->dwVersion ) {
        InlineLogUTDVecWrongVersion;
        return NULL;
    }
    return &pUTDVec->V2;
}


BOOL
AssertNoISTG(
    UPTODATE_CURSOR_V2  *istgKey,
    UPTODATE_CURSOR_V2  *rgCursor,
    DWORD                cNumCursors
    )
/*++

Routine Description:

    Verify with a linear-search that an entry for the ISTG does _not_
    exist in the array of cursors. This is for checking an assertion.

--*/
{
    for( DWORD i=0; i<cNumCursors; i++ ) {
        if( 0==CompareCursorUUID(istgKey, &rgCursor[i]) ) {
            // The assertion is false -- the ISTG _does_ exist.
            return FALSE;
        }
    }

    // The assertion is true -- the ISTG did _not_ exist.
    return TRUE;
}


DSTIME
KCC_SITE::GetLastISTGSyncTime(
    VOID
    )
/*++

Routine Description:

    Load the Up-To-Date Vector from Config NC and find out when the
    last time we synced with the ISTG was.

    If the current ISTG is NULL we return 0. If we have never synced
    with the current ISTG we return 0.

Parameters:

    None

Return Values:

    If the current ISTG is NULL we return 0. If we have never synced
    with the current ISTG we return 0. Otherwise we return the time
    of the last sync.

--*/
{    
    KCC_DSA            *pDsaISTG;
    UPTODATE_VECTOR_V2 *pUTDVec2 = NULL;
    UPTODATE_CURSOR_V2  istgKey, *pIstg;
    GUID               *pISTGInvId;

    // If there is no current ISTG, return 0
    if( NULL==m_pdnSiteGenerator ) {
        // No current ISTG. This could happen if the attribute were deleted.
        // Later an event will be logged stating that the DSA was not viable.
        return 0;
    }

    // Find the invocation ID of the current ISTG
    pDsaISTG = gpDSCache->GetGlobalDSAListByGUID()->GetDsa( m_pdnSiteGenerator );
    if( NULL==pDsaISTG ) {
        // Did not find the current ISTG in the cache. This could happen if 
        // the DSA were deleted. Later an event will be logged stating that 
        // the DSA was not viable.
        return 0;
    }
    pISTGInvId = pDsaISTG->GetInvocationId();
    Assert( !fNullUuid(pISTGInvId) );

    // Load the Up-To-Dateness Vector from the Config NC.
    pUTDVec2 = GetUTDVector();
    if( NULL==pUTDVec2 ) {
        // No Up-To-Dateness Vector therefore we haven't synced from ISTG.
        return 0;
    }

    // Now find the ISTG in the Up-To-Date Vector
    memcpy( &istgKey.uuidDsa, pISTGInvId, sizeof(GUID) );
    pIstg = (UPTODATE_CURSOR_V2*) bsearch( &istgKey, pUTDVec2->rgCursors,
        pUTDVec2->cNumCursors, sizeof(UPTODATE_CURSOR_V2), CompareCursorUUID );

    if( pIstg ) {
        // Found it: return the last successful sync time
        return pIstg->timeLastSyncSuccess;
    } else {
        Assert( AssertNoISTG(&istgKey, pUTDVec2->rgCursors, pUTDVec2->cNumCursors) );
    }

    return 0;
}


VOID
KCC_SITE::GetLastGeneratorWhistler(
    IN  KCC_DSA_ARRAY  *pViableISTGs,
    IN  DSTIME          timeNow,
    OUT KCC_DSA       **ppLastGenerator,
    OUT BOOL           *pfStillValid
    )
/*++

Routine Description:


    Look at the 'm_pdnSiteGenerator' member to determine which DSA last
    staked the ISTG claim. This member comes from the attribute 
    ATT_INTER_SITE_TOPOLOGY_GENERATOR on the NTDS Settings object.
    Then, look at the up-to-dateness vector on the Config NC to determine
    the last time we synced with that server.

    Using the two variables mentioned above, we can determine who the
    last ISTG claim was made by and also determine if the claim is still
    valid. If the last claim was staked by a viable DSA, and we have
    replicated the Config NC with that DSA within the past
    GetSecsUntilSiteGenFailOver() seconds then it is still a valid claim.
    
    Note: The only class member altered by this function is m_timeSiteGenSet.
    This is because, with the Whistler behavior, we are not interested in the
    last time the ISTG attribute was written, we're interested in the last time
    we replicated with the ISTG. 

Parameters:

    pViableISTGs      - The list of viable ISTGs for this site
    timeNow           - The current time

Return Values:

    ppLastGenerator   - The last DSA to stake the ISTG claim
    fStillValid       - Set to TRUE if the claim is still valid;
                        otherwise set to FALSE.
                        
--*/
{
    KCC_DSA    *pDsa;
    KCC_DSA    *pLocalDsa = gpDSCache->GetLocalDSA();

    // Check parameters
    ASSERT_VALID( pViableISTGs );
    Assert( NULL!=ppLastGenerator );
    Assert( NULL!=pfStillValid );

    InlineLogWhistlerElectionAlgorithm;
    
    // Default return values.
    *ppLastGenerator = NULL;
    *pfStillValid = FALSE;
    
    if( NULL!=m_pdnSiteGenerator ) {

        // The NTDS Site Settings object indicates a DSA has laid claim to
        // the ISTG role at some point in the past.
        pDsa = pViableISTGs->Find(m_pdnSiteGenerator, NULL);
        m_timeSiteGenSet = GetLastISTGSyncTime();

        if( NULL==pDsa ) {
            
            // Previous site generator has been moved out of the site or is
            // not a viable site generator (e.g., because it does not understand
            // non-domain NCs).
            // This claim is not valid.
            InlineLogISTGNotViable;

        } else if( pDsa==pLocalDsa ) {

            // Local DSA is the ISTG. No need to do anything. In particular,
            // we do not update our claim as is done in GetLastGenerator().
            InlineLogLocalDSAIsISTG;
            *ppLastGenerator = pLocalDsa;
            *pfStillValid = TRUE;            

        } else if( 0==m_timeSiteGenSet ) {

            // No Up-To-Dateness vector or never replicated from the current ISTG
            InlineLogISTGNotInUTD;          
            ASSERT_VALID( pDsa );
            *ppLastGenerator = pDsa;
            *pfStillValid = FALSE;

        } else {
        
            // A site generator was specified and it's viable.
            // Is the claim still valid?
            Assert(0 != m_timeSiteGenSet);
            ASSERT_VALID( pDsa );
            Assert( pDsa!=pLocalDsa );  // (This case is handled above)
            
            if (m_timeSiteGenSet > timeNow + GetSecsUntilSiteGenFailOver()) {
                
                // We replicated from the ISTG in the future! Reject the claim.
                // ISSUE-2001/01/23-nickhar Is it really necessary to reject this
                // claim here? This should only happen if the clock moves
                // backward (as it may do if the clocks are adjusted), and
                // doesn't necessarily indicate a problem.
                InlineLogISTGReplicatedInFuture;

            } else if (m_timeSiteGenSet > timeNow - GetSecsUntilSiteGenFailOver()) {

                // We have replicated from the current ISTG recently, so it
                // must still be alive. Its claim is therefore valid.
                InlineLogISTGClaimValid;
                *ppLastGenerator = pDsa;
                *pfStillValid = TRUE;

            } else {

                // We have not replicated from the current ISTG in such a long
                // time that we must assume it is dead. 
                InlineLogISTGClaimExpired;
                *ppLastGenerator = pDsa;
                *pfStillValid = FALSE;

            }
        }
    } else {
        // No site generator is set for this site.
        DPRINT(0, "No site generator is set for local site.\n");
    }
}

VOID
KCC_SITE::GetLastGenerator(
    IN  KCC_DSA_ARRAY  *pViableISTGs,
    IN  DSTIME          timeNow,
    OUT KCC_DSA       **ppLastGenerator,
    OUT BOOL           *pfStillValid
    )
/*++

Routine Description:

    Look at the 'm_pdnSiteGenerator' member to determine which DSA last
    staked the ISTG claim. This member comes from the attribute 
    ATT_INTER_SITE_TOPOLOGY_GENERATOR on the NTDS Settings object.
    The other relevant member 'm_timeSiteGenSet' gives the time at which
    the last claim was staked, as determined by reading the metadata on
    the NTDS Settings object.

    Using the two data members mentioned above, we can determine who the
    last ISTG claim was made by and also determine if the claim is still
    valid. If the last claim was staked by a viable DSA within the past
    GetSecsUntilSiteGenFailOver() seconds then it is still a valid claim.
    If the local DSA is the ISTG and GetSecsUntilSiteGenRenew() seconds have
    elapsed since our last claim then we re-stake our claim.

    This function does not modify any members of the KCC_SITE object.
    
Parameters:

    pViableISTGs      - The list of viable ISTGs for this site
    timeNow           - The current time

Return Values:

    ppLastGenerator   - The last DSA to stake the ISTG claim
    fStillValid       - Set to TRUE if the claim is still valid;
                        otherwise set to FALSE.

--*/
{
    KCC_DSA    *pDsa;
    KCC_DSA    *pLocalDsa = gpDSCache->GetLocalDSA();

    // Check parameters
    ASSERT_VALID( pViableISTGs );
    Assert( NULL!=ppLastGenerator );
    Assert( NULL!=pfStillValid );

    // Default return values.
    *ppLastGenerator = NULL;
    *pfStillValid = FALSE;
    
    if (NULL != m_pdnSiteGenerator) {
        // The NTDS Site Settings object indicates a DSA has laid claim to
        // the ISTG role at some point in the past.
        pDsa = pViableISTGs->Find(m_pdnSiteGenerator, NULL);

        if (NULL == pDsa) {
            
            // Previous site generator has been moved out of the site or is
            // not a viable site generator (e.g., because it does not understand
            // non-domain NCs).
            InlineLogISTGNotViable;
            
        } else {
            // A site generator was specified and it's in this site and viable.
            // Is the claim still valid?
            Assert(0 != m_timeSiteGenSet);
            ASSERT_VALID( pDsa );
            
            if (m_timeSiteGenSet > timeNow + GetSecsUntilSiteGenFailOver()) {
            
                // Claim was made in the future! This claim is not valid.
                InlineLogISTGReplicatedInFuture;
                        
            } else if (m_timeSiteGenSet > timeNow - GetSecsUntilSiteGenFailOver()) {
            
                // Claim was (re-)made recently and is still valid.
                InlineLogISTGClaimValid;
                *ppLastGenerator = pDsa;
                *pfStillValid = TRUE;
                
                if(   (pDsa == pLocalDsa)
                   && (   (timeNow < m_timeSiteGenSet)
                       || (timeNow-m_timeSiteGenSet > GetSecsUntilSiteGenRenew()) ) )
                {
                    // We are the site generator for this site and it is time to
                    // renew our claim.
                    m_pSiteGeneratorDSA = pDsa;
                    UpdateSiteGenerator();
                    DPRINT(1, "Renewed claim to site generator role.\n");
                }

            } else {
            
                // Claim was made so far in the past that it has expired.
                InlineLogISTGClaimExpired;
                *ppLastGenerator = pDsa;
                *pfStillValid = FALSE;
                
            }
        }
    } else {
        // No site generator is set for this site.
        DPRINT(0, "No site generator is set for local site.\n");
    }
}


KCC_DSA *
KCC_SITE::GetSiteGenerator(
    VOID
    )
/*++

Routine Description:

    Return the current site generator for this site -- i.e., the machine
    responsible for creating and maintaining the inbound intersite replication
    connections for this site.
    
    The algorithm is fairly simple: if the last designated site generator
    is no longer deemed to be alive or acceptable, the next DSA in the
    site (ordered by increasing objectGuid) is considered to be the site
    generator.
    
    If this next machine is the local DSA, the site generator
    designation on the NTDS Site Settings object is updated such that the
    remaining DSAs in the site know that this machine has claimed the role and
    is alive and well.
    
    If the next DSA is other than the local DSA, and if this next DSA fails to
    claim the role within the timeout interval, the designation roles over to
    the next-next DSA, and so on.
    
    Typically, (1) each DSA will have the same notion of what the other DSAs in
    the site are, (2) each DSA that is currently alive and well will be
    replicating with the other DSAs in the site, and thus will have the same
    value and timestamp for the "last site generator" claim, and (3) the clocks
    on each running DSA will be approximately the same, thanks to the time
    service.  The factors combine such that typically each DSA will agree on
    which DSA should be the current site generator, even if that DSA is not
    currently available.  Thus it is rare for there to be more than one DSA in
    the site to believe it is the site generator.
    
    Multiple site generators are a distinct possibility, however.  This
    situation causes no real harm.  The implications are (1) more than one DSA
    is spinning cycles doing the same job, and (2) duplicate intersite
    connection objects can be generated.  Duplicate connections will be cleaned
    up (i.e., all but one deleted) when the various DSAs once again agree on who
    the site generator is.  Agreement is reached once the various machines are
    replicating with each other in a timely fashion.

Arguments:

    None.    

Return Values:

    The current site generator, or NULL if none could be determined.

--*/
{
    KCC_DSA_ARRAY   ViableISTGs;
    KCC_DSA        *pLastGenerator, *pDsa;
    KCC_DSA        *pLocalDSA = gpDSCache->GetLocalDSA();
    DSTIME          timeNow = GetSecondsSince1601();
    BOOL            fStillValid=FALSE;
    DWORD           iDsa, cSecsUntilSiteGenFailOver;

    // Check parameters
    ASSERT_VALID(this);
    Assert(this == gpDSCache->GetLocalSite());

    if (NULL == m_pdnNtdsSiteSettings) {
        // No site settings, no place to read/set the site generator.
        return NULL;
    }

    // Check for cached answer
    if (NULL != m_pSiteGeneratorDSA) {
        // We've already figured out who the site generator is; return it.
        return m_pSiteGeneratorDSA;
    }
        
    // Get the list of all DSAs in the site which are viable ISTGs.
    // At the moment, this means all DSAs which understand NDNCs.
    ViableISTGs.GetViableISTGs();

    // Call a helper function to find who the last generator was. If the
    // last claim is still valid, the 'fStillValid' flag is set accordingly.
    if( !UseWhistlerElectionAlg() ) {
        GetLastGenerator( &ViableISTGs, timeNow,
                          &pLastGenerator, &fStillValid );
    } else {
        GetLastGeneratorWhistler( &ViableISTGs, timeNow,
                                  &pLastGenerator, &fStillValid );
    }

    // Now we have one of the following cases:
    // (1) We know who the current site generator is and the claim is valid.
    // (2) We know who the last site generator was, but the claim is no
    //     longer valid.
    // (3) We have no idea who the last site generator was (if there was one).

    if( fStillValid ) {

        // Case (1) -- The last ISTG is still valid
        ASSERT_VALID( pLastGenerator );
        m_pSiteGeneratorDSA = pLastGenerator;

    } else {
    
        // Cases (2) and (3) are handled here
        
        if( pLastGenerator ) {

            // Case (2) -- We found the last ISTG, but it's not valid.
            ASSERT_VALID( pLastGenerator );
            
            // Find the index of pLastGenerator in the list of viable ISTGs.
            // This will be used down below.
            for( iDsa=0; iDsa<ViableISTGs.GetCount(); iDsa++ ) {
                if( ViableISTGs[iDsa]==pLastGenerator ) {
                    break;
                }
            }            
            Assert( iDsa<ViableISTGs.GetCount() && "pLastGenerator not found" );
            
        } else {
        
            // Case (3) -- We have no idea who the last valid site generator was
            // (if there was one).  In this case we assume the first DSA in the
            // list was designated as site generator at time 0.
            m_timeSiteGenSet = 0;
            iDsa = 0;

        }
                
        // Note: m_timeSiteGenSet can be 0 here.
        cSecsUntilSiteGenFailOver = GetSecsUntilSiteGenFailOver();
        Assert(timeNow >= m_timeSiteGenSet+cSecsUntilSiteGenFailOver);
        if( 0==cSecsUntilSiteGenFailOver ) {
            // Avoid a fatal division by 0 below.
            cSecsUntilSiteGenFailOver = 1;
        }
        
        // For each fail-over interval that has passed since someone claimed
        // themselves to be site-generator, we skip over one DSA. E.g.,
        // after one fail-over period, we move on to the next DSA; after
        // two, we move on to the next-next DSA; three, the next-next-next
        // DSA; etc.
        iDsa += (DWORD) (timeNow - m_timeSiteGenSet)/cSecsUntilSiteGenFailOver;
        iDsa %= ViableISTGs.GetCount();
        pDsa = ViableISTGs[iDsa];
        ASSERT_VALID(pDsa);
        m_pSiteGeneratorDSA = pDsa;
    
        if (pDsa == pLocalDSA) {
            // Hey, *we* are the new site generator!  Stake our claim.
            UpdateSiteGenerator();
            InlineLogClaimedISTGRole;
        } else {
            InlineLogISTGFailOver;
        }
    }

    ASSERT_VALID(m_pSiteGeneratorDSA);
    return m_pSiteGeneratorDSA;
}


VOID
KCC_SITE::UpdateSiteGenerator()
//
// Update the site generator designation for this site.
//
{
    USHORT      cMods = 0;
    ATTRMODLIST rgMods[2];
    ATTRVAL     AttrVal;
    ULONG       dirError;

    if (NULL == m_pdnNtdsSiteSettings) {
        Assert(!"Cannot set site generator w/o NTDS Site Settings object!");
        return;
    }

    Assert(NULL != m_pSiteGeneratorDSA);
    Assert(m_pSiteGeneratorDSA == gpDSCache->GetLocalDSA());

    // Note that we do *not* use ATT_CHOICE_REPLACE_ATT.  ATT_CHOICE_REPLACE_ATT
    // does not update the meta data for the attribute if the new value is the
    // same as the old value, but sometimes we intentionally rewrite the same
    // value here to update the "keep-alive" time in the meta data (and thereby
    // renew our claim to be the current site generator).
    
    memset(rgMods, 0, sizeof(rgMods));

    rgMods[cMods].choice          = AT_CHOICE_REMOVE_ATT;
    rgMods[cMods].AttrInf.attrTyp = ATT_INTER_SITE_TOPOLOGY_GENERATOR;

    rgMods[cMods].pNextMod = &rgMods[cMods+1];
    cMods++;

    rgMods[cMods].choice                   = AT_CHOICE_ADD_ATT;
    rgMods[cMods].AttrInf.attrTyp          = ATT_INTER_SITE_TOPOLOGY_GENERATOR;
    rgMods[cMods].AttrInf.AttrVal.valCount = 1;
    rgMods[cMods].AttrInf.AttrVal.pAVal    = &AttrVal;
    AttrVal.valLen = m_pSiteGeneratorDSA->GetDsName()->structLen;
    AttrVal.pVal   = (BYTE *) m_pSiteGeneratorDSA->GetDsName();

    cMods++;
        
    dirError = KccModifyEntry(m_pdnNtdsSiteSettings, cMods, rgMods);
    if (0 != dirError) {
        KCC_LOG_MODIFYENTRY_FAILURE( m_pdnNtdsSiteSettings, dirError );
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }

    m_pdnSiteGenerator = m_pSiteGeneratorDSA->GetDsName();
}


BOOL
KCC_SITE::InitDsaList(
    IN  KCC_DSA_LIST   *pDsaList,
    IN  DWORD           left,
    IN  DWORD           right )
/*++

Routine Description:

    Load this site's DSAs from 'pDsaList'. The DSAs with indices in
    [left, right] belong to this site.

Arguments:

    None.

Return Values:

    The list of DSAs for the site.
    
--*/
{
    // This site must be valid but have no DSA list
    ASSERT_VALID( this );
    Assert( NULL==m_pDsaList );
    
    // The new DSA list must be valid and have at least one DSA
    ASSERT_VALID( pDsaList );
    Assert( pDsaList->GetCount()>0 );

    if (NULL==m_pdnNtdsSiteSettings) {
        // This site has no NTDS Site Settings object.  If it contains any
        // ntdsDsa objects it needs one! This is not a fatal error however.
        DPRINT1(0, "Site %ls has no NTDS Site Settings object!\n",
                m_pdnSiteObject->StringName);
        LogEvent(DS_EVENT_CAT_KCC,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_CHK_SITE_HAS_NO_NTDS_SETTINGS,
                 szInsertDN(m_pdnSiteObject),
                 0,
                 0); 
    }

    m_pDsaList = new KCC_DSA_LIST;
    return m_pDsaList->InitSubsequence( pDsaList, left, right );
}


KCC_DSA_LIST *
KCC_SITE::GetDsaList()
/*++

Routine Description:

    Retrieves the list of DSAs in this site.  If the list has not been
    initialized yet, that means that this site has no DSAs, so we create
    an empty list.

Arguments:

    None.

Return Values:

    The list of DSAs for the site.
    
--*/
{
    Assert( gpDSCache->IsValid(KCC_CACHE_STAGE_3_COMPLETE) );
    if (NULL == m_pDsaList) {
        // Initialize an empty list.
        m_pDsaList = new KCC_DSA_LIST;
        m_pDsaList->InitEmpty();
    }
    return m_pDsaList;
}


KCC_DSA_LIST *
KCC_SITE::GetTransportDsaList(
    IN  KCC_TRANSPORT * pTransport,
    OUT BOOL *          pfExplicitBridgeheadsDefined    OPTIONAL
    )
/*++

Routine Description:

    Get list of DSAs in the site valid for the given transport.

Arguments:

    pTransport - Transport for which DSAs are desired.

Return Values:

    The list of DSAs valid for this transport.
    
--*/
{
    DWORD i;
    KCC_DSA_LIST * pDsaList = NULL;
    BOOL fExplicitBridgeheadsDefined=FALSE;

    for (i = 0; i < m_cNumTransportDsaLists; i++) {
        ASSERT_VALID(m_pTransportDsaLists[i].pTransport);

        if (pTransport == m_pTransportDsaLists[i].pTransport) {
            // This is it!
            pDsaList = m_pTransportDsaLists[i].pDsaList;
            ASSERT_VALID(pDsaList);

            fExplicitBridgeheadsDefined
                = m_pTransportDsaLists[i].fExplicitBridgeheadsDefined;
            break;
        }
        else {
            // For expediency we assume that different KCC_TRANSPORT *'s imply
            // different transports; i.e., that there aren't two KCC_TRANSPORT
            // objects corresponding to the same transport.  (There shouldn't
            // be, for performance reasons if nothing else.)
            Assert(!NameMatched(m_pTransportDsaLists[i].pTransport->GetDN(),
                                pTransport->GetDN()));
        }
    }

    if (NULL == pDsaList) {
        // We have not yet cached the transport DSA list for this transport.
        // Do so now.
        pDsaList = new KCC_DSA_LIST;

        if (!pDsaList->InitBridgeheads(this,
                                       pTransport,
                                       &fExplicitBridgeheadsDefined)) {
            // DSA list failed to initialize.
            KCC_EXCEPT( ERROR_DS_DATABASE_ERROR, 0);
        }

        // Add pDsaList to the cache.
        KCC_TRANSPORT_DSA_LIST * pNewTransportDsaLists
            = new KCC_TRANSPORT_DSA_LIST[1 + m_cNumTransportDsaLists];

        if (m_cNumTransportDsaLists) {
            memcpy(pNewTransportDsaLists,
                   m_pTransportDsaLists,
                   m_cNumTransportDsaLists * sizeof(KCC_TRANSPORT_DSA_LIST));
            delete [] m_pTransportDsaLists;
        }

        pNewTransportDsaLists[m_cNumTransportDsaLists].pTransport = pTransport;
        pNewTransportDsaLists[m_cNumTransportDsaLists].pDsaList = pDsaList;
        pNewTransportDsaLists[m_cNumTransportDsaLists].fExplicitBridgeheadsDefined
            = fExplicitBridgeheadsDefined;

        m_pTransportDsaLists = pNewTransportDsaLists;
        m_cNumTransportDsaLists++;
    }

    if (NULL != pfExplicitBridgeheadsDefined) {
        *pfExplicitBridgeheadsDefined = fExplicitBridgeheadsDefined;
    }

    return pDsaList;
}

void
KCC_SITE::PopulateInterSiteConnectionLists()
//
// Search for all intersite ntdsConnection objects inbound to this site and
// populate the individual instersite connection lists associated with each
// KCC_DSA in the site.
//
// Logically this is the same as enumerating the DSAs in the site's DSA list
// and calling GetInterSiteCnList() on each to populate its connection
// list cache.  (The implementation differs however for performance reasons --
// i.e., to avoid so many inidividual searches/transactions.)
//
{
    ENTINFSEL Sel = {
        EN_ATTSET_LIST,
        { ARRAY_SIZE(KCC_CONNECTION::AttrList), KCC_CONNECTION::AttrList },
        EN_INFOTYPES_TYPES_VALS
    };

    BOOL          fSuccess = FALSE;
    ULONG         dirError;
    FILTER        filtTop = {0};
    FILTER        filtConnectionObject = {0};
    FILTER        filtIntersite = {0};
    FILTER        filtFromServer = {0};
    SEARCHRES *   pResults;
    ENTINFLIST *  pEntInfList;
    DSNAME *      pdnConnObjCat;
    DSNAME *      pLocalDSADN = gpDSCache->GetLocalDSADN();
    
    filtTop.choice                       = FILTER_CHOICE_AND;
    filtTop.FilterTypes.And.count        = 3;
    filtTop.FilterTypes.And.pFirstFilter = &filtConnectionObject;
    
    pdnConnObjCat = DsGetDefaultObjCategory(CLASS_NTDS_CONNECTION);
    if( NULL==pdnConnObjCat) {
        Assert( !"DsGetDefaultObjCategory() returned NULL" );
        KCC_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
    }

    // (objectCategory=ntdsConnection)
    filtConnectionObject.choice                                     = FILTER_CHOICE_ITEM;
    filtConnectionObject.FilterTypes.Item.choice                    = FI_CHOICE_EQUALITY;
    filtConnectionObject.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CATEGORY;
    filtConnectionObject.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnConnObjCat->structLen;
    filtConnectionObject.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) pdnConnObjCat;
    filtConnectionObject.pNextFilter                                = &filtIntersite;

    // (transportType=*)
    filtIntersite.choice                            = FILTER_CHOICE_ITEM;
    filtIntersite.FilterTypes.Item.choice           = FI_CHOICE_PRESENT;
    filtIntersite.FilterTypes.Item.FilTypes.present = ATT_TRANSPORT_TYPE;
    filtIntersite.pNextFilter                       = &filtFromServer;

    // (fromServer=*)
    // (I.e., ignore connections where from source server has been deleted --
    //  these objects are deleted by the corresponding destination DSA via
    //  a different code path.)
    filtFromServer.choice                            = FILTER_CHOICE_ITEM;
    filtFromServer.FilterTypes.Item.choice           = FI_CHOICE_PRESENT;
    filtFromServer.FilterTypes.Item.FilTypes.present = ATT_FROM_SERVER;

    dirError = KccSearch(m_pdnSiteObject,
                         SE_CHOICE_WHOLE_SUBTREE,
                         &filtTop,
                         &Sel,
                         &pResults);

    if (0 != dirError) {
        KCC_LOG_SEARCH_FAILURE(m_pdnSiteObject, dirError);
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }

    // Cache the list of DSAs for this site if they haven't been cached
    // already.
    GetDsaList();
    
    // Build an array of pointers to each individual ENTINFLIST element
    // returned.  Associate the dest DSA with each.
    KCC_ENTINFLIST_AND_DSA *  pObjects = NULL;
    DWORD                     cNumObjects = 0;

    if (pResults->count) {
        pObjects = new KCC_ENTINFLIST_AND_DSA [pResults->count];

        for (pEntInfList = &pResults->FirstEntInf;
             NULL != pEntInfList;
             pEntInfList = pEntInfList->pNextEntInf) {
            // Extract string DN of parent object (the dest DSA DN).
            DSNAME * pGuidlessParentDN
                = (DSNAME *) new BYTE[pEntInfList->Entinf.pName->structLen];
            TrimDSNameBy(pEntInfList->Entinf.pName, 1, pGuidlessParentDN);

            KCC_DSA * pDestDSA = m_pDsaList->GetDsa(pGuidlessParentDN);
            
            if (NULL != pDestDSA) {
                pObjects[cNumObjects].pEntInfList = pEntInfList;
                pObjects[cNumObjects].pDSA = pDestDSA;
                cNumObjects++;
            } else {
                // Cache coherency problem induced by performing connection
                // list and DSA list searches in different transactions.
                // Destination DSA was moved, renamed, or deleted in between
                // transactions.  Play it safe and abort this run.
                KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
            }
        }
    }

    // Sort the list by destination DSA.
    qsort(pObjects, cNumObjects, sizeof(*pObjects),
          CompareEntInfListAndDsaByDsaGuid);

    // DSA list is already sorted by DSA guid.
    Assert((0 == m_pDsaList->GetCount())
           || (m_pDsaList->GetSortFn() == KCC_DSA::CompareIndirectByNtdsDsaGuid));

    // For each set of inbound connections common to a given destination
    // DSA, initialize the corresponding KCC_DSA's intersite connection
    // list.
    DWORD iObject = 0;
    for (DWORD iDSA = 0; iDSA < m_pDsaList->GetCount(); iDSA++) {
        KCC_DSA * pDSA = m_pDsaList->GetDsa(iDSA);
        DWORD     iObjectNextDSA;
        
        // Build the linked ENTINFLISTs describing connection objects
        // inbound to this DSA.  (This list may be empty.)
        for (iObjectNextDSA = iObject;
             (iObjectNextDSA < cNumObjects)
                && (pObjects[iObjectNextDSA].pDSA == pDSA);
             iObjectNextDSA++) {
            if (iObjectNextDSA > iObject) {
                // Update ENTINFLIST linked list to put this ENTINFLIST
                // after the previous ENTINFLIST that matched this same
                // DSA.
                pObjects[iObjectNextDSA - 1].pEntInfList->pNextEntInf
                    = pObjects[iObjectNextDSA].pEntInfList;
            }
            
            // This is the end of the linked list (so far).
            pObjects[iObjectNextDSA].pEntInfList->pNextEntInf = NULL;
        }

        if (pDSA->IsIntersiteConnectionListCached()) {
            // Intersite connections already cached.  This is the case
            // for our own local DSA.
            Assert(pDSA == gpDSCache->GetLocalDSA());
        } else {
            DWORD        cNumObjectsThisDSA = iObjectNextDSA - iObject;
            ENTINFLIST * pObjectsThisDSA = cNumObjectsThisDSA
                                                ? pObjects[iObject].pEntInfList
                                                : NULL;
            KCC_INTERSITE_CONNECTION_LIST * pCnList
                = new KCC_INTERSITE_CONNECTION_LIST;

            // Initialize the connection list from the constructed
            // ENTINFLIST.
            if (!pCnList->Init(pDSA->GetDsName(),
                               cNumObjectsThisDSA,
                               pObjectsThisDSA)) {
                KCC_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
            }

            // Associate the newly created connection list with the DSA.
            pDSA->SetIntersiteConnectionList(pCnList);
        }

        iObject = iObjectNextDSA;
    }
}

KCC_DSA *
KCC_SITE::GetNCBridgeheadForTransportHelp(
    IN  KCC_CROSSREF *  pCrossRef,
    IN  KCC_DSA_LIST *  pDsaList,
    IN  KCC_TRANSPORT * Transport,
    IN  BOOL            fGCTopology,
    OUT BOOL *          pfStaleBridgeheadsFound
    )
/*++

Routine Description:

    This is a helper routine for GetNCBridgeheadForTransport(), below.
    
    Its task is to iterate through the given list of DSAs and return the first
    DSA that supports replication of the given NC.  "Stale" bridgeheads are not
    returned.
    
    If no bridgehead could be found that's currently viable,
    *pfStaleBridgeheadsFound will be TRUE iff one or more bridgeheads that could
    support replication of the given NC are present but are currently stale.

    For the local site, we return the first acceptable bridgehead that we find.
    For remote sites, bridgeheads are prioritized by whether or not the NC has
    been instantiated there. Bridgeheads which fully host the NC have highest
    priority.
    
Parameters:

    pCrossRef (IN) - CrossRef of NC for which replication is desired.
    
    pDsaList (IN) - DSAs to consider.
    
    pTransport (IN) - Transport being considered.
    
    fGCTopology (IN) - Tells if this is for GC topology generation.  If FALSE,
        read-only replicas are not viable.
    
    pfStaleBridgeheadsFound (OUT) - If the function return value is NULL,
        indicates if bridgeheads that support all the criteria other than being
        stale were found.

Returns:

    Pointer to the KCC_DSA object that fits the bill, or NULL if none could be
    found.
    
--*/
{
    KCC_DSA            *pdsa, *bestdsa=NULL;
    DWORD               idsa, cdsa;
    BOOL                fIsMaster;
    KCC_NC_COMING_TYPE  isComing, bestIsComing;
    LPWSTR              pszTransportAddr;
    BOOL                fIsLocal = (this == gpDSCache->GetLocalSite());
    BOOL                fIsInstantiated;
    DSNAME             *pdnnc = pCrossRef->GetNCDN();

    ASSERT_VALID(this);
    ASSERT_VALID(pCrossRef);
    ASSERT_VALID(pDsaList);
    ASSERT_VALID(Transport);
    ASSERT_VALID(gpDSCache->GetLocalSite());
    Assert((this == gpDSCache->GetLocalSite())
           == !!NameMatched(GetObjectDN(),
                            gpDSCache->GetLocalSite()->GetObjectDN()));
    
    *pfStaleBridgeheadsFound = FALSE;
    
    cdsa = pDsaList->GetCount();

    for (idsa = 0; idsa < cdsa; idsa++) {
        pdsa = pDsaList->GetDsa(idsa);
        ASSERT_VALID(pdsa);

        fIsMaster = FALSE;

        // Bridgehead is viable if the following conditions are met:
        //
        // 1. The NC we want to replicate is instantiated, or if we've
        //    specifically been told it's okay for it not to be (e.g., local
        //    GC).
        // 2. The NC instantiation is of the required type -- i.e., is writeable
        //    for writeable NC topology, or read-only or writeable for GC
        //    topology.
        // 3. The DSA has an address for this transport.
        // 4. The bridgehead is not stale.

        if (pdsa->IsNCHost(pCrossRef, fIsLocal, &fIsMaster)
            && (fIsMaster || fGCTopology)
            && (NULL != (pszTransportAddr = pdsa->GetTransportAddr(Transport)))) {
            
            if (KccIsBridgeheadStale(pdsa->GetDsName())) {
                // Bridgehead is stale; it's not a viable candidate.
                DPRINT1(0, "Ignoring stale bridgehead %ls as possible candidate.\n",
                        pdsa->GetDsName()->StringName);
                *pfStaleBridgeheadsFound = TRUE;
            }
            else {
                if( fIsLocal ) {
                    // For the local bridgehead, we don't care if the NC is coming
                    // or not so we can immediately accept this bridgehead.
                    bestdsa = pdsa;
                    break;
                } else {
                    // This bridgehead is acceptable. Let's find out if the NC has
                    // been fully instantiated at this DSA or if it is still coming.
                    fIsInstantiated = pdsa->IsNCInstantiated(pdnnc, NULL, &isComing);

                    // Since this server is in the remote site, the NC must be
                    // instantiated on it.
                    Assert( fIsInstantiated && KCC_NC_NOT_INSTANTIATED!=isComing );

                    // Remember this dsa if it is the best one so far.
                    if(NULL==bestdsa || isComing>bestIsComing) {
                        bestdsa = pdsa;
                        bestIsComing = isComing;
                    }
                }
            }
        }
    }

    return bestdsa;
}

BOOL
KCC_SITE::GetNCBridgeheadForTransport( 
    IN  KCC_CROSSREF *  pCrossRef,
    IN  KCC_TRANSPORT * pTransport,
    IN  BOOL            fGCTopology,
    OUT KCC_DSA **      ppBridgeheadDsa
    )
/*++

Routine Description:

    This routine returns a DSA in the site that is capable of replicating the
    given NC over the specified transport for the particular topology type (GC
    or not), or NULL if no such DSA can be found.  "Stale" DSAs are not
    returned.
    
Parameters:

    pCrossRef (IN) - CrossRef of NC for which replication is desired.
    
    pTransport (IN) - Transport being considered.
    
    fGCTopology (IN) - Tells if this is for GC topology generation.  If FALSE,
        read-only replicas are not viable.
    
    ppBridgeheadDSA (OUT) - On successful return, holds a pointer to the KCC_DSA
        object for the DSA that fits the criteria.
        
Returns:

    TRUE - Viable bridgehead found.
    FALSE - No viable bridgehead could be found.
    
--*/
{
    KCC_DSA_LIST *  pDsaList;   
    KCC_DSA *       pdsa;
    BOOL            fExplicitBridgeheadsDefined;
    BOOL            fStaleBridgeheadsFound;

    ASSERT_VALID(this);
    ASSERT_VALID(pCrossRef);
    ASSERT_VALID(pTransport);
    Assert(ppBridgeheadDsa);
    
    // First check the cache.
    if (m_NCTransportBridgeheadList.Find(pCrossRef->GetNCDN(),
                                         pTransport,
                                         fGCTopology,
                                         ppBridgeheadDsa)) {
        // We have already cached the qualifying bridgehead or lack thereof.
        // (I.e., this is both a positive and a negative cache.)
        return (NULL != *ppBridgeheadDsa);
    }

    // Bridgehead for this NC/transport/GC-ness has not yet been determined --
    // do so now and cache the result.

    // Get the list of servers that can use this transport for this site.
    // Note that this list has already been sorted according to bridgehead
    // preference, so the DSAs at the beginning of the list are generally
    // "better" than those found later in the list.  Thus we iterate from the
    // beginning and stop when we find the first viable candidate.

    pDsaList = GetTransportDsaList(pTransport,
                                   &fExplicitBridgeheadsDefined);
    ASSERT_VALID(pDsaList);
    
    pdsa = GetNCBridgeheadForTransportHelp(pCrossRef,
                                           pDsaList,
                                           pTransport,
                                           fGCTopology,
                                           &fStaleBridgeheadsFound);
        
    if (NULL == pdsa) {
        // Failed to find a viable bridgehead.
        if (fStaleBridgeheadsFound) {
            // There are appropriate bridgeheads defined, but all of them are
            // currently stale.
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_KCC_ALL_TRANSPORT_BRIDGEHEADS_STALE,
                     szInsertDN(GetObjectDN()),
                     szInsertDN(pTransport->GetDN()),
                     szInsertDN(pCrossRef->GetNCDN()));
        } else {
            if (fExplicitBridgeheadsDefined) {
                // The admin has defined explicit bridgeheads for this site &
                // transport, but none of them could possibly replicate the
                // needed information.  This is a configuration error.
                LogEvent(DS_EVENT_CAT_KCC,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_KCC_EXPLICIT_BRIDGEHEAD_LIST_INCOMPLETE,
                         szInsertDN(GetObjectDN()),
                         szInsertDN(pTransport->GetDN()),
                         szInsertDN(pCrossRef->GetNCDN()));
    
                // Try again, considering all DSAs as potential candidates.
                pDsaList = GetDsaList();
                ASSERT_VALID(pDsaList);
                if( pDsaList ) {                
                    pdsa = GetNCBridgeheadForTransportHelp(pCrossRef,
                                                           pDsaList,
                                                           pTransport,
                                                           fGCTopology,
                                                           &fStaleBridgeheadsFound);
                }
            }

            if (NULL == pdsa) {
                // 1. This site is connected to other sites via this transport,
                //    as indicated by ISM (and the underlying siteLinks for this
                //    transport).
                // 2. We previously determined that this site contained a DSA
                //    that contained a read-only or writeable copy of this NC
                //    and thus the site needed to be included in the applicable
                //    sites list.
                // 3. We considered all DSAs in the site, not just those that
                //    were explicitly defined (if any).
                // 4. No otherwise viable bridgeheads are stale.
                // 5. No bridgehead could be found to support replication of
                //    this NC over this transport.
    
                // From the above we can conclude that the admin has told us
                // that this site is connected over a particular transport (by
                // publishing appropriate siteLinks), but no DSAs that support
                // both this transport *and* the required replication criteria
                // (NC, read-only/writeable) are present in the site.  We do
                // know from 2. that there are DSAs that contain the appropriate
                // NC, so we can conclude that  there are DSAs in the site that
                // support the required replication criteria, but none of those
                // DSAs support this transport.

                // This likely indicates that we're looking for a bridgehead for
                // the SMTP transport, but none of the DSAs' server objects has
                // a mailAddress attribute.
                
                // This shouldn't occur for the IP transport, since all DSAs
                // support IP replication.
                Assert(!pTransport->IsIntersiteIP());

                LogEvent(DS_EVENT_CAT_KCC,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_KCC_NO_BRIDGEHEADS_ENABLED_FOR_TRANSPORT,
                         szInsertDN(GetObjectDN()),
                         szInsertDN(pTransport->GetDN()),
                         szInsertDN(pCrossRef->GetNCDN()));
            }
        }
    }

    if (NULL != pdsa) {
        // Viable bridgehead found.
        ASSERT_VALID(pdsa);
        *ppBridgeheadDsa = pdsa;

        // Supportability logging event 8
        LogEvent8(DS_EVENT_CAT_KCC,
                  DS_EVENT_SEV_VERBOSE,
                  DIRLOG_KCC_BRIDGEHEAD_CHOSEN,
                  szInsertDN(pdsa->GetDsName()),
                  szInsertDN(GetObjectDN()),
                  szInsertDN(pCrossRef->GetNCDN()),
                  szInsertDN(pTransport->GetDN()),
                  0, 0, 0, 0);
    }

    // Add the result (found or not) to the cache.
    m_NCTransportBridgeheadList.Add(pCrossRef->GetNCDN(),
                                    pTransport,
                                    fGCTopology,
                                    pdsa);
    
    return (NULL != pdsa);
}


VOID
KCC_SITE::SetSiteLinkFlag(
    DWORD transportIndex
    )
/*++

Routine Description:

    Set a flag indicating that there is a site-link connected to this
    site for the transport specified by 'transportIndex'.

Parameters:

    transportIndex  - The transport for which a site-link was found.

Return Value:

    None

--*/
{
    DWORD mask;

    ASSERT_VALID( this );
    Assert( transportIndex<32 );

    mask = 1<<transportIndex;
    m_siteLinkBitmap |= mask;
}


BOOLEAN
KCC_SITE::GetSiteLinkFlag(
    DWORD transportIndex
    )
/*++

Routine Description:

    Returns a flag indicating if this site has any site links for the
    transport specified by 'transportIndex'.

Parameters:

    transportIndex  - The index transport which we are querying.

Return Value:

    TRUE  - This site has a site-link for the specified transport
    FALSE - This site does not have a site-link for the specified transport

--*/
{
    DWORD mask;

    Assert( transportIndex<32 );
    ASSERT_VALID( this );
    
    mask = 1<<transportIndex;
    return !!(m_siteLinkBitmap & mask);
}


BOOLEAN
KCC_SITE::GetAnySiteLinkFlag(
    VOID
    )
/*++

Routine Description:

    Returns a flag indicating if this site has any site links at all    

Parameters:

    None

Return value:

    TRUE  - This site has a site-link for any transport
    FALSE - This site has no site-link for any transport

--*/
{
    ASSERT_VALID( this );
    return !!(m_siteLinkBitmap);
}


VOID
KCC_SITE::SetUnreachable(
    VOID
    )
/*++

Routine Description:

    Marks this site as being unreachable from the local site for some NC.

Parameters:

    None

Return value:

    None

--*/
{
    ASSERT_VALID( this );
    Assert( this != gpDSCache->GetLocalSite() );
    m_fUnreachable = TRUE;
}


BOOL
KCC_SITE::IsUnreachable(
    VOID
    )
/*++

Routine Description:

    If this site has been marked as unreachable, returns true.

Parameters:

    None

Return value:

    TRUE  - If the site has been marked as unreachable.
    FALSE - Otherwise.

--*/
{
    Assert( gpDSCache->IsReachableMarkingComplete() );
    return m_fUnreachable;
}



int __cdecl SiteConnMapCmp( const void* pa, const void* pb )
/*++

Routine Description:

    For comparing SITE_CONN_MAP objects. Used to qsort() the SITE_CONN_MAP list.
    The elements are sorted by comparing the 'site' pointers.

--*/
{
    KCC_SITE::KCC_SITE_CONN_MAP *a, *b;

    a = (KCC_SITE::KCC_SITE_CONN_MAP*) pa;
    b = (KCC_SITE::KCC_SITE_CONN_MAP*) pb;
    if( a->site-b->site > 0 ) return 1;
    if( a->site-b->site < 0 ) return -1;

    // If doing qsort(), we should never return 0. There cannot be two connections
    // sourcing from the same site.
    // If we're doing bsearch(), then one of a or b is our search key, and
    // should have its conn field initialized to NULL.
    Assert( a->conn==NULL || b->conn==NULL );
    return 0;
}


void
KCC_SITE::BuildSiteConnMap()
/*++

Routine Description:

    Build a DestSiteConnMap. Each element maps from a site to a connection which has
    that site as its destination site. All connections will have this site as their
    source site.
    
    This map is used so that we can rapidly answer the following query:
    Given a remote site, quickly find an a connection between this site and the
    remote site.
    
Parameters:

    none
        
Returns:

    nothing
    
--*/
{
    DWORD iEdge;

    // We expect that no map will exist at this point, since DestroySiteConnMap()
    // should be called when it is no longer needed. However, in exceptional
    // circumstances m_pDestSiteConnMap may be non-null, so we attempt to delete it. 
    if(m_pDestSiteConnMap) {
        delete [] m_pDestSiteConnMap;
        m_pDestSiteConnMap = NULL;
    }

    // We initialize this mapping using all the edges incident with this site
    m_destSiteConnMapSize = NumberOfOutEdges();
    if(m_destSiteConnMapSize) {
        m_pDestSiteConnMap = new KCC_SITE_CONN_MAP[ m_destSiteConnMapSize ];

        for( iEdge=0; iEdge<m_destSiteConnMapSize; iEdge++ ) {
            m_pDestSiteConnMap[iEdge].conn = (KCC_SITE_CONNECTION*) GetOutEdge(iEdge);
            ASSERT_VALID(m_pDestSiteConnMap[iEdge].conn);
            m_pDestSiteConnMap[iEdge].site = m_pDestSiteConnMap[iEdge].conn->GetDestinationSite();
            ASSERT_VALID(m_pDestSiteConnMap[iEdge].site);
        }

        qsort( m_pDestSiteConnMap, m_destSiteConnMapSize, sizeof(KCC_SITE::KCC_SITE_CONN_MAP), SiteConnMapCmp );
    }
}
    

KCC_SITE_CONNECTION*
KCC_SITE::FindConnInMap( 
    KCC_SITE* destSite
    )
/*++

Routine Description:

    Search for a connection using the mapping built by BuildConnMap
    NOTE: After calling BuildConnMap, if edges are dissociated from this site
    then deleted, the map will contain dangling pointers. Thus, unless care
    is taken, this function could return invalid pointers. 
    
Parameters:

    destSite (IN) - we want to find the connection between (this,destSite)
        
Returns:

    a pointer to the connection if one was found, NULL otherwise.
    
--*/
{
    KCC_SITE_CONN_MAP srch, *result;

    if(m_destSiteConnMapSize==0) return NULL;
    Assert( m_pDestSiteConnMap!=NULL );

    // Create our search key
    srch.site = destSite;
    srch.conn = NULL;

    result = (KCC_SITE_CONN_MAP*) bsearch( &srch, m_pDestSiteConnMap, m_destSiteConnMapSize,
        sizeof(KCC_SITE::KCC_SITE_CONN_MAP), SiteConnMapCmp );
    if(result) {                                
        ASSERT_VALID( result->site );
        Assert( result->site == destSite );
        ASSERT_VALID( result->conn );
        return result->conn;
    } else {
        return NULL;
    }
}


VOID
KCC_SITE::DestroySiteConnMap()
/*++

Routine Description:

    Search for a connection using the mapping built by BuildConnMap
    
Parameters:

    destSite (IN) - we want to find the connection between (this,destSite)
        
Returns:

    a pointer to the connection if one was found, NULL otherwise.
    
--*/
{
    if(m_destSiteConnMapSize==0) return;
    Assert( m_pDestSiteConnMap!=NULL );

    delete [] m_pDestSiteConnMap;
    m_pDestSiteConnMap = NULL;
    m_destSiteConnMapSize=0;
}


VOID
KCC_SITE::DeleteEdges()
{
    KCC_SITE_CONNECTION *   pEdge;
    ULONG                   iEdge, cEdge;

    cEdge = NumberOfOutEdges();
    for( iEdge=0; iEdge < cEdge; iEdge++ )
    {
        pEdge = (KCC_SITE_CONNECTION*) GetOutEdge(iEdge);
        delete pEdge;
    }
    ClearEdges();
}


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_SITE_LIST methods
//

BOOL
KCC_SITE_LIST::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

BOOL
KCC_SITE_LIST::InitAllSites()
//
// Initialize the collection
//
{
    ENTINFSEL SiteSel = {
        EN_ATTSET_LIST,
        {0, NULL},
        EN_INFOTYPES_TYPES_VALS
    };

    ATTR      rgSettingsAttrs[] =
    {
        { ATT_OPTIONS,       { 0, NULL } },
        { ATT_OBJ_DIST_NAME, { 0, NULL } },
        { ATT_REPL_PROPERTY_META_DATA, { 0, NULL } },
        { ATT_INTER_SITE_TOPOLOGY_GENERATOR, { 0, NULL } },
        { ATT_INTER_SITE_TOPOLOGY_FAILOVER, { 0, NULL } },
        { ATT_INTER_SITE_TOPOLOGY_RENEW, { 0, NULL } },
        { ATT_SCHEDULE, { 0, NULL } }
    };

    ENTINFSEL SettingsSel =
    {
        EN_ATTSET_LIST,
        {ARRAY_SIZE(rgSettingsAttrs), rgSettingsAttrs},
        EN_INFOTYPES_TYPES_VALS
    };

    WCHAR       szSitesRDN[] = L"Sites";
    DWORD       cchSitesRDN  = ARRAY_SIZE(szSitesRDN) - 1;
    
    WCHAR       szNtdsSiteSettingsRDN[] = L"NTDS Site Settings";
    DWORD       cbNtdsSiteSettingsRDN
                    = sizeof(szNtdsSiteSettingsRDN) - sizeof(*szNtdsSiteSettingsRDN);

    DSNAME *    pdnConfigNC = gpDSCache->GetConfigNC();
    ULONG       cbSitesContainer = pdnConfigNC->structLen +
                                     (MAX_RDN_SIZE+MAX_RDN_KEY_SIZE)*(sizeof(WCHAR));
    DSNAME *    pdnSitesContainer = (DSNAME *) new BYTE[cbSitesContainer];
    
    ULONG               dirError;
    FILTER              filtNameAndObjCat = {0};
    FILTER              filtName = {0};
    FILTER              filtObjCat = {0};
    SEARCHRES *         pSitesResults;
    SEARCHRES *         pSettingsResults;
    ENTINFLIST *        pSiteEntInfList;
    ENTINFLIST *        pSettingsEntInfList;
    ENTINF **           ppSettingEntinfArray = NULL;
    ENTINF **           ppCurrentEntinf;

    // Clear the member variables
    Reset();

    // Set up the root search dn
    AppendRDN(pdnConfigNC,
              pdnSitesContainer,
              cbSitesContainer,
              szSitesRDN,
              cchSitesRDN,
              ATT_COMMON_NAME);

    // Find all the site objects.
    DSNAME * pdnSiteCat = DsGetDefaultObjCategory(CLASS_SITE);
    Assert(NULL != pdnSiteCat);

    // Set up the search filter
    filtObjCat.choice                  = FILTER_CHOICE_ITEM;
    filtObjCat.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    filtObjCat.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CATEGORY;
    filtObjCat.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnSiteCat->structLen;
    filtObjCat.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) pdnSiteCat;

    dirError = KccSearch(pdnSitesContainer,
                         SE_CHOICE_IMMED_CHLDRN,
                         &filtObjCat,
                         &SiteSel,
                         &pSitesResults);

    if (0 != dirError) {
        KCC_LOG_SEARCH_FAILURE(pdnSitesContainer, dirError);
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    };

    if (0 == pSitesResults->count) {
        Assert(!"No site objects found!");
        LogUnhandledError(ERROR_DS_DATABASE_ERROR);
    };
    
    // Find all the NTDS Site Settings objects.
    filtNameAndObjCat.choice                       = FILTER_CHOICE_AND;
    filtNameAndObjCat.FilterTypes.And.count        = 2;
    filtNameAndObjCat.FilterTypes.And.pFirstFilter = &filtName;
        
    filtName.choice                                     = FILTER_CHOICE_ITEM;
    filtName.FilterTypes.Item.choice                    = FI_CHOICE_EQUALITY;
    filtName.FilterTypes.Item.FilTypes.ava.type         = ATT_RDN;
    filtName.FilterTypes.Item.FilTypes.ava.Value.valLen = cbNtdsSiteSettingsRDN;
    filtName.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) szNtdsSiteSettingsRDN;
    filtName.pNextFilter                                = &filtObjCat;
        
    DSNAME * pdnSiteSetCat = DsGetDefaultObjCategory(CLASS_NTDS_SITE_SETTINGS);
    if( NULL==pdnSiteSetCat ) {
        Assert( !"DsGetDefaultObjCategory() returned NULL unexpectedly" );
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }
    
    Assert(filtObjCat.choice == FILTER_CHOICE_ITEM);
    Assert(filtObjCat.FilterTypes.Item.choice == FI_CHOICE_EQUALITY);
    Assert(filtObjCat.FilterTypes.Item.FilTypes.ava.type == ATT_OBJECT_CATEGORY);
    filtObjCat.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnSiteSetCat->structLen;
    filtObjCat.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) pdnSiteSetCat;
    
    dirError = KccSearch(pdnSitesContainer,
                         SE_CHOICE_WHOLE_SUBTREE,
                         &filtNameAndObjCat,
                         &SettingsSel,
                         &pSettingsResults);
            
    if (0 != dirError) {
        KCC_LOG_SEARCH_FAILURE(pdnSitesContainer, dirError);
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    };

    // Sort the settings objects so we can find them efficiently

    if (pSettingsResults->count) {
        ppSettingEntinfArray = new ENTINF *[pSettingsResults->count];

        ppCurrentEntinf = ppSettingEntinfArray;
        for (pSettingsEntInfList = &pSettingsResults->FirstEntInf;
             NULL != pSettingsEntInfList;
             pSettingsEntInfList = pSettingsEntInfList->pNextEntInf) {

            // WARNING. MAINTENANCE ISSUE.
            // Rename each Entinf to have the name of its site
            // This makes matching settings to site easier later
            // We free the old name here.
            // Since new uses the thread-allocator, it is ok that the new
            // name is released below using FreeSearchRes()
            DSNAME *pdnSettings = pSettingsEntInfList->Entinf.pName;
            DSNAME *pdnSite = (DSNAME *) new BYTE[pdnSettings->structLen];
            TrimDSNameBy(pdnSettings, 1, pdnSite);

            // Free the orphaned memory of the old name. The new name will be
            // freed when the search results are released.
            THFree( pdnSettings );

            pSettingsEntInfList->Entinf.pName = pdnSite;

            *ppCurrentEntinf++ = &(pSettingsEntInfList->Entinf);
        }
        qsort( ppSettingEntinfArray, pSettingsResults->count, sizeof( ENTINF * ),
               CompareIndirectEntinfDsnameString );
    }

    // Create each site.

    for (pSiteEntInfList = &pSitesResults->FirstEntInf;
         NULL != pSiteEntInfList;
         pSiteEntInfList = pSiteEntInfList->pNextEntInf) {

        ENTINF *pKeyEntinf = &(pSiteEntInfList->Entinf);
        DSNAME * pdnSite = pKeyEntinf->pName;
        ENTINF * pSettingsEntInf = NULL;
        VOID *pElement;

        // For each site, match it to its corresponding site settings object.
        if (pSettingsResults->count) {
            pElement = bsearch( &pKeyEntinf,
                                ppSettingEntinfArray,
                                pSettingsResults->count,
                                sizeof(ENTINF *),
                                CompareIndirectEntinfDsnameString );

            if (pElement) {
                pSettingsEntInf = *((ENTINF **) pElement);
            } else {
                // pSettingsEntInf will be NULL in this case, which is permitted.
                // Event will be logged in KCC_SITE::InitSite()
            }
        }
        // else pSettingsEntInf will be NULL, indicating there is none

        KCC_SITE * psite = new KCC_SITE;
        
        if (psite->InitSite(pdnSite, pSettingsEntInf)) {
            m_SiteArray.Add( psite );
            m_SiteNameArray.Add( pdnSite, psite );
        }
        else {
            DPRINT1(0, "Initialization of site object %ls failed\n",
                    pdnSite->StringName);
        }

    } // end for
            
    // Free search results
    DirFreeSearchRes( pSitesResults );
    DirFreeSearchRes( pSettingsResults );

    // There are no compatibility issues with sorting this array using the
    // new CompareSite function. The KCC_SITE_LIST was never sorted previously,
    // and its order is not significant in computing the old spanning tree.
    // The array is sorted so that the Find function will work efficiently.
    m_SiteArray.Sort( CompareIndirectSiteGuid );

    // Sort the names using the default sorting function
    m_SiteNameArray.Sort();

    m_fIsInitialized = TRUE;

    if (ppSettingEntinfArray) {
        delete [] ppSettingEntinfArray;
    }

    delete [] (BYTE *) pdnSitesContainer;

    return m_fIsInitialized;
}


BOOL
KCC_SITE_LIST::PopulateDSAs()
//
// Load all DSAs in the forest, then build a DSA list for each site.
//
{
    KCC_DSA_LIST    allDSAs;
    DSNAME         *pdnCurSite=NULL;
    KCC_SITE       *pSite;
    DWORD           iDSA=0, cDSA, siteStart;
    BOOL            fStartOfList, fEndOfList, fNameMatchesCurSite;

    // Initialize a list of all DSAs in the forest.
    // Claim: For a given site, all its DSAs are contiguous in this list.
    allDSAs.InitAllDSAs();
    cDSA = allDSAs.GetCount();
    if( 0==cDSA ) {
        Assert( !"Failed to find any DSAs in the forest!" );
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }


    // Loop over all DSAs in order to find ones that are in the same site.
    // Then, call that site's InitDsaList() function so that the site knows
    // who its DSAs are.
    for(;;) {
        Assert( iDSA<=cDSA );

        fStartOfList = (iDSA==0);
        fEndOfList = (iDSA==cDSA);
        if( fEndOfList ) {
            Assert( !fStartOfList );
        }
        if( !fStartOfList && !fEndOfList ) {
            fNameMatchesCurSite =
                NameMatched(allDSAs.GetDsa(iDSA)->GetSiteDN(),pdnCurSite);
        }
        
        // Check if we're at the end of a site:
        //  - This DSA is at the end of the list
        //  - This DSA's site is not the same as the current site (if any)
        if( fEndOfList || (!fStartOfList && !fNameMatchesCurSite) )
        {
            Assert( iDSA>0 && NULL!=pdnCurSite );
            pSite = GetSite( pdnCurSite );      // Uses binary-search
            if( pSite ) {
                if( ! pSite->InitDsaList(&allDSAs, siteStart, iDSA-1) ) {
                    DPRINT1( 0, "Failed to initialize DSA list for site %ls!\n",
                        pdnCurSite->StringName );
                }
            } else {
                // We have read inconsistent data from the database. We have
                // a DSA whose site does not exist. While this is not strictly
                // a fatal situation, we stop the KCC run so that we don't
                // mess up the topology by using these inconsistent objects.
                DPRINT1( 0, "Site %ls not found!\n", pdnCurSite->StringName );
                KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
            }

            if( iDSA==cDSA ) {
                break;
            }
        }

        Assert( iDSA<cDSA );

        // Check if we're at the start of a new site:
        //  - This is the first DSA in the list
        //  - This DSA's site is not the same as the current site (if any)
        if( fStartOfList || !fNameMatchesCurSite ) {
            pdnCurSite = allDSAs.GetDsa(iDSA)->GetSiteDN();
            siteStart = iDSA;
        }

        iDSA++;
    }

    // The contents of the list allDSAs are now stored in the per-site
    // lists. However, if the allDSAs list is destroyed now, it will
    // destroy those objects. Since we want to keep the DSA objects, we
    // clear the allDSAs list before it goes out of scope.
    allDSAs.Reset();

    return TRUE;
}


void
KCC_SITE_LIST::Reset()
//
// Set member variables to their pre-Init() state.
//
{
    m_fIsInitialized = FALSE;
    m_SiteArray.RemoveAll();
    m_SiteNameArray.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kccstale.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccstale.cxx

ABSTRACT:

    KCC_LINK_FAILURE_CACHE class.
    KCC_CONNECTION_FAILURE_CACHE class.

DETAILS:

    This class is holds information pertaining to staleness of the servers
    that the current dsa currently replicated with. Essentially given the ds name
    of an msft-dsa object that this server may replicate with, this class with have 
    methods that indicate whether the particular msft-dsa is a useful replication
    partner.                                                             
    

CREATED:

    10/20/97    Colin Brace (ColinBr)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include "kcc.hxx"
#include "kccdsa.hxx"
#include "kcclink.hxx"
#include "kccconn.hxx"
#include "kcctools.hxx"
#include "kccstale.hxx"
#include "kccstetl.hxx"
#include <dsconfig.h>
#include <dsutil.h>

#define FILENO FILENO_KCC_KCCTOPL

//
// Some small helper functions
//
BOOL
KccExtractCacheInfo(
    IN  PCACHE_ENTRY pEntry,
    OUT ULONG  *     TimeSinceFirstFailure,    OPTIONAL
    OUT ULONG  *     NumberOfFailures,         OPTIONAL
    OUT BOOL   *     fUserNotifiedOfStaleness, OPTIONAL
    OUT DWORD  *     pdwLastResult,            OPTIONAL
    OUT BOOL   *     pfErrorOccurredThisRun    OPTIONAL
    )
{
    if ( pEntry )
    {
        if ( TimeSinceFirstFailure )
        {
            *TimeSinceFirstFailure = (ULONG)(GetSecondsSince1601() -
                                             pEntry->TimeOfFirstFailure);
        }

        if ( NumberOfFailures )
        {
            *NumberOfFailures = pEntry->NumberOfFailures;
        }

        if ( fUserNotifiedOfStaleness )
        {
            *fUserNotifiedOfStaleness = pEntry->fUserNotifiedOfStaleness;
        }

        if ( pdwLastResult )
        {
            *pdwLastResult = pEntry->dwLastResult;
        }

        if( pfErrorOccurredThisRun )
        {
            *pfErrorOccurredThisRun = pEntry->fErrorOccurredThisRun;
        }

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

DWORD
KccAssignStatusImportance(
    IN DWORD dwStatus
    )
// Compute an integer according to how bad the status is
{
    DWORD dwWeight = 0;

    switch (dwStatus) {

        // Same as no value - least importance
    case ERROR_SUCCESS:
        dwWeight = 0;
        break;

        // Normal errors
    case ERROR_DS_DRA_REPL_PENDING:
    case ERROR_DS_DRA_PREEMPTED:
    case ERROR_DS_DRA_ABANDON_SYNC:
    case ERROR_DS_DRA_SHUTDOWN:
        dwWeight = 1;
        break;

        // Call not made errors
    case RPC_S_SERVER_UNAVAILABLE:
    case ERROR_DS_DNS_LOOKUP_FAILURE:
    case ERROR_DS_DRA_RPC_CANCELLED:
    case EPT_S_NOT_REGISTERED:
        dwWeight = 2;
        break;

        // Call failed type errors
    case ERROR_DS_DRA_OUT_OF_MEM:
    case ERROR_NOT_ENOUGH_MEMORY:
    case ERROR_BUSY:
    case ERROR_DS_DRA_BUSY:
    case ERROR_DS_DRA_SCHEMA_INFO_SHIP:
    case ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT:
    case ERROR_DS_DRA_SCHEMA_MISMATCH:
    case ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET:
    case ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA:
    case ERROR_DS_DRA_SOURCE_DISABLED:
    case ERROR_DS_DRA_SINK_DISABLED:
    case RPC_S_SERVER_TOO_BUSY:
    case RPC_S_CALL_FAILED:
        dwWeight = 3;
        break;

        // Security type errors
    case ERROR_TIME_SKEW:
    case ERROR_DS_DRA_ACCESS_DENIED:
    case ERROR_LOGON_FAILURE:
    case ERROR_WRONG_TARGET_NAME:
    case ERROR_DOMAIN_CONTROLLER_NOT_FOUND:
    case ERROR_ENCRYPTION_FAILED:
    case ERROR_ACCESS_DENIED:
    case ERROR_NOT_AUTHENTICATED:
    case ERROR_INVALID_PASSWORD:
    case ERROR_PASSWORD_EXPIRED:
    case ERROR_ACCOUNT_DISABLED:
    case ERROR_ACCOUNT_LOCKED_OUT:
        dwWeight = 3;
        break;

        // Everything else
    default:
        dwWeight = 100;
    }

    return dwWeight;
}

//
// Method definitions
// 


VOID
KCC_CACHE_LINKED_LIST::Add(
    IN PCACHE_ENTRY pEntry
    )
// Put the entry in the linked list
{
    ASSERT_VALID(this);
    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock));

    Assert( pEntry );
    if ( pEntry )
    {           
        PushEntryList( &m_ListHead, &(pEntry->Link) );
    }
}

PCACHE_ENTRY
KCC_CACHE_LINKED_LIST::Find(
    IN  GUID   *    pGuid,
    IN  BOOL        fDelete
    )
// Find the entry in the linked list and delete if asked to
{

    PCACHE_ENTRY pEntry = NULL;
    PCACHE_ENTRY pLastEntry = NULL;

    ASSERT_VALID( this );
    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock)
           || (!fDelete && OWN_RESOURCE_SHARED(&m_resLock)));
    Assert( pGuid );

    if ( !m_ListHead.Next )
    {
        // empty list - CONTAINING_RECORD does not detect this
        return NULL;
    }

    pEntry = CONTAINING_RECORD(m_ListHead.Next,
                               CACHE_ENTRY,
                               Link);

    pLastEntry = pEntry;

    while ( pEntry )
    {

        if ( KccIsEqualGUID( &pEntry->Guid,
                             pGuid ) )
        {
            //
            // This is it
            //
            break;
        }
        else 
        {
            pLastEntry = pEntry;

            if ( pEntry->Link.Next )
            {
                pEntry = CONTAINING_RECORD(pEntry->Link.Next,
                                           CACHE_ENTRY,
                                           Link);
            } 
            else 
            {
                pEntry = NULL;
            }

        }
        
    }

    if ( fDelete && pEntry )
    {

        //
        // Remove this entry from the list
        // 

        if ( pEntry == pLastEntry )
        {
            Assert( &(pEntry->Link) == m_ListHead.Next );
            m_ListHead.Next = pEntry->Link.Next;
        }
        else
        {
            pLastEntry->Link.Next = pEntry->Link.Next;
        }
        
    }

    return pEntry;
}

PCACHE_ENTRY
KCC_CACHE_LINKED_LIST::Pop(
    VOID
    )
// Pop the first entry from the list
{
    PCACHE_ENTRY       pEntry = NULL;
    PSINGLE_LIST_ENTRY pLink;

    ASSERT_VALID( this );
    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock));

    pLink =  PopEntryList(&m_ListHead);

    if ( pLink )
    {
        pEntry = CONTAINING_RECORD(pLink,
                                   CACHE_ENTRY,
                                   Link);
    }

    return pEntry;

}

VOID
KCC_CACHE_LINKED_LIST::IncrementFailureCounts(
    VOID
    )
// Increment the failure count for every entry in the cache
{

    PCACHE_ENTRY pEntry = NULL;

    ASSERT_VALID( this );
    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock));

    if ( !m_ListHead.Next )
    {
        // empty list - CONTAINING_RECORD does not detect this
        return;
    }

    pEntry = CONTAINING_RECORD(m_ListHead.Next,
                               CACHE_ENTRY,
                               Link);

    while ( pEntry )
    {

        pEntry->NumberOfFailures++;

        if ( pEntry->Link.Next )
        {
            pEntry = CONTAINING_RECORD(pEntry->Link.Next,
                                       CACHE_ENTRY,
                                       Link);
        } 
        else 
        {
            pEntry = NULL;
        }
    }

    return;
}

void
KCC_CACHE_LINKED_LIST::ResetFailureCounts()
//
// Reset all failure counts in the cache (but preserve the entries and in
// particular the flag telling us if an event has been logged).
//
{
    SINGLE_LIST_ENTRY * pList = m_ListHead.Next;
    
    ASSERT_VALID(this);
    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock));

    while (NULL != pList) {
        PCACHE_ENTRY pEntry = CONTAINING_RECORD(pList, CACHE_ENTRY, Link);
        pEntry->NumberOfFailures = 0;

        pList = pEntry->Link.Next;
    }
}

BOOL
KCC_CACHE_LINKED_LIST::IsValid()
{
    return m_fIsInitialized;
}

BOOL
KCC_CACHE_LINKED_LIST::Init()
// Empty the list and start from scratch
{
    RtlZeroMemory( &m_ListHead, sizeof(SINGLE_LIST_ENTRY) );

    __try {
        RtlInitializeResource(&m_resLock);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        LogUnhandledError(GetExceptionCode());
        return FALSE;
    }

    m_fIsInitialized = TRUE;

    return m_fIsInitialized;
}

BOOL
KCC_CACHE_LINKED_LIST::ResetUserNotificationFlag(
    IN  DSNAME *    pdnFromServer
    )
// Set the fUserNotifiedOfStaleness to FALSE on pdnFromServer
{

    PCACHE_ENTRY pEntry;

    ASSERT_VALID(this);
    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock));

    if ( pdnFromServer )
    {
        pEntry = Find( pdnFromServer, 
                       FALSE ); // don't delete the entry
    
        if ( pEntry )
        {
            pEntry->fUserNotifiedOfStaleness = FALSE;
    
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    return FALSE;

}

DWORD
KCC_CACHE_LINKED_LIST::Extract(
    OUT DS_REPL_KCC_DSA_FAILURESW **  ppFailures
    )
/*++

Routine Description:

    Returns the contents of the cache in external form.

Arguments:

    ppFailures (OUT) - On successful return, holds the external form of the
        contents of the cache.
    
Return Values:

    Win32 error code.

--*/
{
    SINGLE_LIST_ENTRY * pList;
    PCACHE_ENTRY pEntry = NULL;
    DWORD cNumEntries;
    DWORD cbFailures;
    DS_REPL_KCC_DSA_FAILUREW * pFailure;
    
    ASSERT_VALID(this);
    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock)
           || OWN_RESOURCE_SHARED(&m_resLock));

    // Count the number of entries.  Yes, we should probably maintain a count.
    cNumEntries = 0;
    for (pList = m_ListHead.Next; NULL != pList; pList = pList->Next) {
        cNumEntries++;
    }

    cbFailures = offsetof(DS_REPL_KCC_DSA_FAILURESW, rgDsaFailure)
                 + cNumEntries * sizeof((*ppFailures)->rgDsaFailure[0]);
    
    *ppFailures = (DS_REPL_KCC_DSA_FAILURESW *) new BYTE[cbFailures];
    (*ppFailures)->cNumEntries = cNumEntries;

    // Add each entry to the list.
    for (pList = m_ListHead.Next, pFailure = &(*ppFailures)->rgDsaFailure[0];
         NULL != pList;
         pList = pList->Next, pFailure++) {
        pEntry = CONTAINING_RECORD(pList, CACHE_ENTRY, Link);
        
        DSTimeToFileTime(pEntry->TimeOfFirstFailure,
                         &pFailure->ftimeFirstFailure);
        
        pFailure->cNumFailures   = pEntry->NumberOfFailures;
        pFailure->uuidDsaObjGuid = pEntry->Guid;
        pFailure->dwLastResult   = pEntry->dwLastResult;
    }

    return 0;
}


VOID
KCC_CACHE_LINKED_LIST::Dump(
    BOOL ( *IsStale )( DSNAME * ) OPTIONAL
    )
// Prints out the current list via DPRINT
{

    PCACHE_ENTRY       pEntry;
    PSINGLE_LIST_ENTRY pLink;

    ULONG              rpcStatus;

    ULONG              TimeElasped;
    WCHAR              *GuidString;
    WCHAR              *DefaultGuidString = L"Unreadable guid";
    DSNAME             DsName;

    ASSERT_VALID( this );
    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock)
           || OWN_RESOURCE_SHARED(&m_resLock));

    pLink = m_ListHead.Next;

    while ( pLink )
    {

        pEntry = CONTAINING_RECORD(pLink,
                                   CACHE_ENTRY,
                                   Link);

        TimeElasped = (ULONG)(GetSecondsSince1601() - pEntry->TimeOfFirstFailure);

        rpcStatus = UuidToStringW( &(pEntry->Guid),  &GuidString );

        if ( 0 != rpcStatus )
        {
            GuidString = DefaultGuidString;
        }

        DPRINT1( 0, "\tGuid: %ws\n", GuidString);
        DPRINT1( 0, "\tTime Elasped: %d\n", TimeElasped );
        DPRINT1( 0, "\tFailureCount: %d\n", pEntry->NumberOfFailures);
        DPRINT1( 0, "\tLastResult: %d\n", pEntry->dwLastResult);
        DPRINT1( 0, "\tUser Has Been Notified: %d\n", pEntry->fUserNotifiedOfStaleness );

        if ( IsStale )
        {
            //
            // Construct a guid only dsname
            //
            RtlZeroMemory( &DsName, sizeof( DSNAME ) );

            DsName.structLen = DSNameSizeFromLen( 0 );

            RtlCopyMemory( &DsName.Guid, &(pEntry->Guid), sizeof(GUID) );

            if ( (*IsStale)( &DsName ) )
            {
                DPRINT( 0, "\tStatus: Stale\n" );
            }
            else 
            {
                DPRINT( 0, "\tStatus: Not Stale\n" );
            }
        }

        DPRINT( 0, "\n" );
    

        if ( 0 == rpcStatus )
        {
            RpcStringFreeW( &GuidString );
        }

        pLink = pEntry->Link.Next;
        
    }

    //
    // Empty case
    //
    if ( !m_ListHead.Next )
    {
        DPRINT( 0, "\t< Empty >\n" );
        DPRINT( 0, "\n" );
    }

    return;
}

#if DBG
BOOL
KCC_CACHE_LINKED_LIST::RefreshFromRegistry(
    IN  LPSTR   pszRegKey
    )
//
// Test hook -- read stale server list from the registry.
//
// Reads REG_MULTI_SZ strings from the registry in the format:
//      <ntdsDsa guid>,<dsTime of first failure/last success>,<num failures>,<event generated>
// e.g., "04baf40a-8f0c-11d2-b38b-0000f87a46c8,12557642897,5,0".
//
{
    HKEY          hk;
    BOOL          fSuccess = FALSE;
    CHAR *        pchVals = NULL;
    DWORD         cbVals;
    DWORD         dwType;
    LPSTR         pszVal;
    DWORD         err;
    CACHE_ENTRY * pEntry;

    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock));
    
    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       DSA_CONFIG_SECTION,
                       0,
                       KEY_ALL_ACCESS,
                       &hk);
    if (err) {
        return FALSE;
    }

    __try {
        err = RegQueryValueEx(hk, pszRegKey, NULL, &dwType, NULL, &cbVals);
        if (err) {
            __leave;
        }

        pchVals = (CHAR *) new BYTE[cbVals];
        
        err = RegQueryValueEx(hk, pszRegKey, NULL, &dwType, (BYTE *) pchVals, &cbVals);
        if (err) {
            __leave;
        }

        if (REG_MULTI_SZ != dwType) {
            Assert(!"Test failure -- stale cache reg value must be REG_MULTI_SZ!");
            __leave;
        }

        // Clear out the current contents of the cache.
        while (pEntry = Pop()) {
            free(pEntry);
        }

        // Iterate through each string in the multi-valued list.
        for (pszVal = pchVals; '\0' != *pszVal; pszVal += strlen(pszVal) + 1) {
            CHAR            szGuid[37];
            ULONGLONG       dsTime;
            ULONG           cNumFailures;
            BOOL            fUserNotified;
            GUID            Guid;

            if (4 > sscanf(pszVal, "%36s,%I64u,%u,%u", szGuid, &dsTime,
                           &cNumFailures, &fUserNotified)) {
                DPRINT1(0, "Bad stale cache reg entry: \"%s\"\n", pszVal);
                Assert(!"Test failure -- bad stale cache reg value!");
                __leave;
            }

            err = UuidFromString((UCHAR *) szGuid, &Guid);
            if (err) {
                DPRINT2(0, "Bad guid \"%s\" in stale cache reg entry: \"%s\"\n",
                        szGuid, pszVal);
                Assert(!"Test failure -- bad stale cache reg value!");
                __leave;
            }

            pEntry = Find(&Guid, FALSE);

            if (NULL == pEntry) {
                // Entry does not yet exist -- add it.
                pEntry = (CACHE_ENTRY *) malloc(sizeof(CACHE_ENTRY));
                if (NULL == pEntry) {
                    KCC_MEM_EXCEPT(sizeof(CACHE_ENTRY));
                }
            
                memset(pEntry, 0, sizeof(CACHE_ENTRY));
                pEntry->Guid = Guid;
            
                Add(pEntry);
            }
                
            Assert(0 == memcmp(&Guid, &pEntry->Guid, sizeof(GUID)));
            
            pEntry->TimeOfFirstFailure       = dsTime;
            pEntry->NumberOfFailures         = cNumFailures;
            pEntry->fUserNotifiedOfStaleness = fUserNotified;
        }

        DPRINT1(0, "Stale cache initialized from key %s.\n", pszRegKey);
        fSuccess = TRUE;
    }
    __finally {
        if (NULL != pchVals) {
            delete [] pchVals;
        }
        
        RegCloseKey(hk);
    }

    return fSuccess;
}
#endif

void
KCC_LINK_FAILURE_CACHE::UpdateEntry(
    IN  GUID *  pDsaObjGuid,
    IN  DSTIME  timeLastSuccess,
    IN  DWORD   cNumConsecutiveFailures,
    IN  DWORD   dwLastResult,
    IN  BOOL    fImported
    )
//
// Update entry in the cache (creating it if necessary).
// fImported should be set to TRUE (its default value) if this failure
// was imported from a bridgehead.
//
{
    m_List.AcquireLockExclusive();

    __try {
        UpdateEntryLockHeld(pDsaObjGuid,
                            timeLastSuccess,
                            cNumConsecutiveFailures,
                            dwLastResult,
                            fImported);
    }
    __finally {
        m_List.ReleaseLock();
    }
}

void
KCC_LINK_FAILURE_CACHE::UpdateEntryLockHeld(
    IN  GUID *  pDsaObjGuid,
    IN  DSTIME  timeLastSuccess,
    IN  DWORD   cNumConsecutiveFailures,
    IN  DWORD   dwLastResult,
    IN  BOOL    fImported
    )
//
// Update entry in the cache (creating it if necessary).
// Assumes exclusive lock is already held.
//
{
    PCACHE_ENTRY pEntry;

    if (!cNumConsecutiveFailures) {
        // No failures, no need to cache.
        return;
    }

    pEntry = m_List.Find( pDsaObjGuid,
                          FALSE // don't delete
                          );

    if ( pEntry )
    {
        if ( 0 == pEntry->NumberOfFailures )
        {
            //
            // Entry exists - replace with new data
            //
            pEntry->TimeOfFirstFailure = timeLastSuccess;
            pEntry->NumberOfFailures = cNumConsecutiveFailures;
            pEntry->dwLastResult = dwLastResult;

            // Since the number of failures is 0, we can consider this an
            // abandoned entry, so we set the fEntryIsImported flag to be in
            // accordance with this new failure information.
            // First check that the current value is not garbage though
            Assert( pEntry->fEntryIsImported==!!pEntry->fEntryIsImported );
            pEntry->fEntryIsImported = !!fImported;
        }
        else 
        {
            //
            // Entry exists - replace with worse data if possible
            //
            if ( pEntry->TimeOfFirstFailure < timeLastSuccess )
            {
                pEntry->TimeOfFirstFailure = timeLastSuccess;
            }

            if ( pEntry->NumberOfFailures < cNumConsecutiveFailures )
            {
                pEntry->NumberOfFailures = cNumConsecutiveFailures;
            }

            if ( KccAssignStatusImportance( pEntry->dwLastResult ) <
                 KccAssignStatusImportance( dwLastResult ) ) {
                pEntry->dwLastResult = dwLastResult;
            }

            // Since non-imported trumps imported, set fEntryIsImported to FALSE
            // if fImported is false. Check that the current value is not garbage first
            Assert( pEntry->fEntryIsImported==!!pEntry->fEntryIsImported );
            if( !fImported ) {
                pEntry->fEntryIsImported = FALSE;
            }
        }
        
        // No need to set fErrorOccurredThisRun or fUnneeded here -- any entry
        // in the cache should already have these field set to FALSE
        Assert( !pEntry->fErrorOccurredThisRun );
        Assert( !pEntry->fUnneeded );
    }
    else
    {
        //
        // New entry
        //

        pEntry = (PCACHE_ENTRY) malloc( sizeof( CACHE_ENTRY ) );
        if (NULL == pEntry) {
            KCC_MEM_EXCEPT(sizeof(CACHE_ENTRY));
        }

        memset( pEntry, 0, sizeof( CACHE_ENTRY ) );

        RtlCopyMemory( &pEntry->Guid, pDsaObjGuid, sizeof(GUID) );

        pEntry->TimeOfFirstFailure = timeLastSuccess;
        pEntry->NumberOfFailures = cNumConsecutiveFailures;
        pEntry->dwLastResult = dwLastResult;
        pEntry->fUserNotifiedOfStaleness = FALSE;

        // fErrorOccurredThisRun and fUnneeded are not used in the
        // link-failure cache so we just set them to FALSE.
        pEntry->fErrorOccurredThisRun = FALSE;
        pEntry->fUnneeded = FALSE;

        // Set the fEntryIsImported flag appropriately for this new failure.
        pEntry->fEntryIsImported = !!fImported;

        m_List.Add( pEntry );
    }
}

void
KCC_LINK_FAILURE_CACHE::UpdateEntry(
    IN  DS_REPL_KCC_DSA_FAILUREW *  pFailure
    )
//
// Update entry in the cache (creating it if necessary).
//
{
    DSTIME dsTime;

    if (pFailure && pFailure->cNumFailures) {
        FileTimeToDSTime(pFailure->ftimeFirstFailure, &dsTime);
        
        UpdateEntry(&pFailure->uuidDsaObjGuid,
                    dsTime,
                    pFailure->cNumFailures,
                    pFailure->dwLastResult );
    }
}

BOOL
KCC_LINK_FAILURE_CACHE::Refresh(
    VOID
    )
// Reads in the current reps-from info to make a cache
// of all from servers and their current state.
{
    BOOL        fSuccess;
    ULONG       NCCount, NCIndex;
    ULONG       RepsFromCount, RepsFromIndex;
    DSNAME *    pdnNC;
    KCC_DSA *   pLocalDSA = gpDSCache->GetLocalDSA();

    m_List.AcquireLockExclusive();

    __try {
#if DBG
        if (m_List.RefreshFromRegistry(KCC_LINK_FAILURE_KEY)) {
            // Test hook -- stale servers were enumerated in the registry.
            return TRUE;
        }
#endif
        //
        // Assume the worst
        //
        fSuccess = FALSE;
    
        NCCount = pLocalDSA->GetNCCount();
    
        // Reset failure counts of existing cache entries, so that we can
        // re-seed the cache with fresh failure counts/times.  (And still
        // maintain the "has event been logged" state.)
        m_List.ResetFailureCounts();
    
        for ( NCIndex = 0; NCIndex < NCCount; NCIndex++ )
        {
            KCC_CROSSREF  *pCrossRef;
            KCC_LINK_LIST *pLinkList, *pLinkListNotCached=NULL;
            KCC_LINK      *pLink;
    
            pdnNC = pLocalDSA->GetNC( NCIndex );
            Assert( pdnNC );

            //
            // Retrieve the reps-froms for this naming context
            //

            // Find the link list for this NC
            pCrossRef = gpDSCache->GetCrossRefList()->GetCrossRefForNC(pdnNC);
            if (NULL == pCrossRef) {
                // Local NC with no corresponding crossRef.
                pLinkList = new KCC_LINK_LIST;
                if (pLinkList->Init(pdnNC)) {
                    // Remember to free this later.
                    pLinkListNotCached = pLinkList;
                } else {
                    // Failed to initialize list (e.g., DS error, memory pressure,
                    // etc.).
                    delete pLinkList;
                    pLinkList = NULL;
                }
            } else {
                // NC has a corresponding crossRef -- get the cached link list.
                pLinkList = pCrossRef->GetLinkList();
            }
    
            if ( !pLinkList ) {
                goto End;
            }
    
            RepsFromCount = pLinkList->GetCount();
    
            for ( RepsFromIndex = 0; RepsFromIndex < RepsFromCount; RepsFromIndex++ )
            {
                PCACHE_ENTRY pEntry;
                pLink = pLinkList->GetLink( RepsFromIndex );
                Assert( pLink );
    
                UpdateEntryLockHeld(pLink->GetDSAUUID(),
                                    pLink->GetTimeOfLastSuccess(),
                                    pLink->GetConnectFailureCount(),
                                    pLink->GetLastResult(),
                                    FALSE);
            }

            // Free the link list if we did not get it from the cache
            if( pLinkListNotCached ) {
                delete pLinkListNotCached;
                pLinkListNotCached = NULL;
            }
        }
    }
    __finally {
        m_List.ReleaseLock();
    }

    fSuccess = TRUE;

End:

    return fSuccess;
}

BOOL
KCC_LINK_FAILURE_CACHE::Get(
    IN  DSNAME *    pdnFromServer,
    OUT ULONG  *    TimeSinceFirstFailure,    OPTIONAL
    OUT ULONG  *    NumberOfFailures,         OPTIONAL
    OUT BOOL   *    fUserNotifiedOfStaleness, OPTIONAL
    OUT DWORD  *    LastResult                OPTIONAL
    )
// Return the data of the ENTRY if it exists
{

    PCACHE_ENTRY pEntry;
    BOOL bReturn = FALSE;

    ASSERT_VALID(this);

    m_List.AcquireLockShared();
    
    __try {
        pEntry = m_List.Find(pdnFromServer, 
                             FALSE  // don't delete the entry
                             );
    
        if ( pEntry )
        {
            KccExtractCacheInfo(pEntry,
                                TimeSinceFirstFailure,
                                NumberOfFailures,
                                fUserNotifiedOfStaleness,
                                LastResult,
                                NULL
                                );
    
            bReturn = TRUE;        
        }
    }
    __finally {
        m_List.ReleaseLock();
    }

    return bReturn;
}

BOOL
KCC_LINK_FAILURE_CACHE::Remove(
    IN  GUID *    pGuid
    )
// Remove pdnFromServer from the cache
{
    PCACHE_ENTRY pEntry;
    BOOL bReturn = FALSE;

    ASSERT_VALID(this);

    m_List.AcquireLockExclusive();

    __try {
        pEntry = m_List.Find(pGuid, 
                             TRUE  // delete the entry
                             );
    
        if ( pEntry )
        {
            free( pEntry );
    
            bReturn = TRUE;
        }
    }
    __finally {
        m_List.ReleaseLock();
    }

    return bReturn;
}

KCC_LINK_FAILURE_CACHE::NotifyUserOfStaleness(
    IN  DSNAME *    pdnFromServer
    )
// Make an event log entry indicating the KCC thinks a server is stale
{

    PCACHE_ENTRY pEntry;
    BOOL bReturn = FALSE;
    ULONG        FailureTimeInMinutes;

    ASSERT_VALID(this);

    m_List.AcquireLockExclusive();

    __try {
        pEntry = m_List.Find(pdnFromServer, 
                             FALSE  // don't delete the entry
                             );
    
        if ( pEntry )
        {
            //
            // If the user hasn't been notified and there is a name associated
            // with this dsname, do it.
            //
            if ( !pEntry->fUserNotifiedOfStaleness && pdnFromServer->NameLen > 0 )
            {
    
                FailureTimeInMinutes = (ULONG)(GetSecondsSince1601() -
                                               pEntry->TimeOfFirstFailure);
                FailureTimeInMinutes /= 60;    
    
                LogEvent8WithData(DS_EVENT_CAT_KCC,
                                  DS_EVENT_SEV_ALWAYS,
                                  DIRLOG_KCC_REPLICA_LINK_DOWN,
                                  szInsertUL( pEntry->NumberOfFailures ),
                                  szInsertDN( pdnFromServer ),
                                  szInsertUL( FailureTimeInMinutes ),
                                  szInsertWin32Msg( pEntry->dwLastResult ),
                                  NULL, NULL, NULL, NULL,
                                  sizeof( pEntry->dwLastResult ),
                                  &(pEntry->dwLastResult)
                    );
    
                pEntry->fUserNotifiedOfStaleness = TRUE;
                
            }
    
            bReturn = TRUE;
        }
    }
    __finally {
        m_List.ReleaseLock();
    }

    return bReturn;

}

BOOL
KCC_LINK_FAILURE_CACHE::IsValid(
    VOID
    )
// Is this object internally consistent?
{
    return m_fIsInitialized;
}

VOID
KCC_LINK_FAILURE_CACHE::Reset(
    VOID
    )
{
    m_fIsInitialized = FALSE;
    return;
}

DWORD
KCC_LINK_FAILURE_CACHE::Extract(
    OUT DS_REPL_KCC_DSA_FAILURESW **  ppFailures
    )
{
    DWORD winError;

    m_List.AcquireLockShared();

    __try {
        winError = m_List.Extract(ppFailures);
    }
    __finally {
        m_List.ReleaseLock();
    }

    return winError;
}

VOID
KCC_LINK_FAILURE_CACHE::Dump(
    VOID
    )
// Prints out the current list via DPRINT
{
    DPRINT( 0, "This is the cache of servers with whom we have established\n" );
    DPRINT( 0, "a replication link.\n");
    DPRINT( 0, "\n");

    m_List.AcquireLockShared();

    __try {
        // Now dump the list
        m_List.Dump( KccCriticalLinkServerIsStale );
    }
    __finally {
        m_List.ReleaseLock();
    }

    return;
}

BOOL
KCC_LINK_FAILURE_CACHE::ResetUserNotificationFlag(
    IN  DSNAME *    pdnFromServer
    )
{
    BOOL fSuccess;

    m_List.AcquireLockExclusive();

    __try {
        fSuccess = m_List.ResetUserNotificationFlag( pdnFromServer );
    }
    __finally {
        m_List.ReleaseLock();
    }

    return fSuccess;
}


BOOL
KCC_CONNECTION_FAILURE_CACHE::Add(
    IN  DSNAME *    pdnFromServer,
    IN  DWORD       dwLastResult,
    IN  BOOL        fImported
    )
// Add to the cache if it is not there.
// The fImported flag indicates if the error was caused by a DirReplicaAdd()
// or DsBind() operation performed at the _local_ DSA, or if the error was
// imported from a bridgehead.
{

    PCACHE_ENTRY pEntry;
    BOOL bReturn = FALSE;

    ASSERT_VALID(this);

    m_List.AcquireLockExclusive();

    __try {
        pEntry = m_List.Find(pdnFromServer, 
                             FALSE  // don't delete the entry
                             );
    
        if ( !pEntry )
        {
            //
            // No entry exists, create one with initial values
            //
            pEntry = (PCACHE_ENTRY) malloc(sizeof(CACHE_ENTRY));
            if ( pEntry )
            {
                memset(pEntry, 0, sizeof(CACHE_ENTRY));
                pEntry->TimeOfFirstFailure = GetSecondsSince1601();
                pEntry->NumberOfFailures = 0;
                memcpy(&pEntry->Guid, &pdnFromServer->Guid, sizeof(GUID));
                pEntry->dwLastResult = dwLastResult;
                pEntry->fEntryIsImported = fImported;

                //
                // Put the entry in the cache
                //
                m_List.Add( pEntry );
            }
        }
    
        //
        // Return TRUE if the addition was successful
        //
        if ( pEntry )
        {
            bReturn = TRUE;
            
            // Check that the 'imported' flag is not garbage
            Assert( pEntry->fEntryIsImported==!!pEntry->fEntryIsImported );

            if( !fImported ) {
                pEntry->fErrorOccurredThisRun = TRUE;
                pEntry->fEntryIsImported = FALSE;
            }

            // Clear the unneeded flag on this entry, if it was set
            pEntry->fUnneeded = FALSE;
        }
    }
    __finally {
        m_List.ReleaseLock();
    }

    return bReturn;

}
    
void
KCC_CONNECTION_FAILURE_CACHE::UpdateEntry(
    IN  DS_REPL_KCC_DSA_FAILUREW *  pFailure
    )
//
// Update entry in the cache (creating it if necessary).
//
{
    DSTIME dsTime;

    if (pFailure && pFailure->cNumFailures) {
        DSNAME dn = {0};

        dn.structLen = DSNameSizeFromLen(0);
        dn.NameLen = 0;
        dn.Guid = pFailure->uuidDsaObjGuid;

        Add(&dn, pFailure->dwLastResult, TRUE);
    }
}

BOOL
KCC_CONNECTION_FAILURE_CACHE::Get(
    IN  DSNAME *    pdnFromServer,
    OUT ULONG  *    TimeSinceFirstFailure,    OPTIONAL
    OUT ULONG  *    NumberOfFailures,         OPTIONAL
    OUT BOOL   *    fUserNotifiedOfStaleness, OPTIONAL
    OUT DWORD  *    pdwLastResult,            OPTIONAL
    OUT BOOL   *    pfErrorOccurredThisRun    OPTIONAL
    )
// Return the data of the ENTRY if it exists
{

    PCACHE_ENTRY pEntry;
    BOOL bReturn = FALSE;

    ASSERT_VALID(this);

    m_List.AcquireLockShared();

    __try {
        pEntry = m_List.Find(pdnFromServer, 
                             FALSE  // don't delete the entry
                             );
    
        if ( pEntry )
        {
            KccExtractCacheInfo(pEntry,
                                TimeSinceFirstFailure,
                                NumberOfFailures,
                                fUserNotifiedOfStaleness,
                                pdwLastResult,
                                pfErrorOccurredThisRun
                                );
    
            bReturn = TRUE;        
        }
    }
    __finally {
        m_List.ReleaseLock();
    }

    return bReturn;
}

BOOL
KCC_CONNECTION_FAILURE_CACHE::Remove(
    IN  DSNAME *    pdnFromServer
    )
// Remove pdnFromServer from the cache
{
    PCACHE_ENTRY pEntry;
    BOOL bReturn = FALSE;

    ASSERT_VALID(this);

    m_List.AcquireLockExclusive();

    __try {
        pEntry = m_List.Find(pdnFromServer, 
                             TRUE  // delete the entry
                             );
    
        if ( pEntry )
        {
            free( pEntry );
            bReturn = TRUE;
        }
    }
    __finally {
        m_List.ReleaseLock();
    }

    return bReturn;

}

BOOL
KCC_CONNECTION_FAILURE_CACHE::NotifyUserOfStaleness(
    IN  DSNAME *    pdnFromServer
    )
// Make an event log entry indicating the KCC thinks a server is stale
{

    PCACHE_ENTRY pEntry;
    ULONG        FailureTimeInMinutes;
    BOOL bReturn = FALSE;

    ASSERT_VALID(this);
    
    m_List.AcquireLockExclusive();

    __try {
        pEntry = m_List.Find(pdnFromServer, 
                             FALSE  // don't delete the entry
                             );
    
        if ( pEntry )
        {
            //
            // If the user hasn't been notified and there is a name associated
            // with this dsname, do it.
            //
            if ( !pEntry->fUserNotifiedOfStaleness && pdnFromServer->NameLen > 0 )
            {
    
                FailureTimeInMinutes = (ULONG)(GetSecondsSince1601() -
                                               pEntry->TimeOfFirstFailure);
                FailureTimeInMinutes /= 60;    
    
                LogEvent8WithData(DS_EVENT_CAT_KCC,
                                  DS_EVENT_SEV_ALWAYS,
                                  DIRLOG_KCC_CONNECTION_NOT_INSTANTIATED,
                                  szInsertUL( pEntry->NumberOfFailures ),
                                  szInsertDN( pdnFromServer ),
                                  szInsertUL( FailureTimeInMinutes ),
                                  szInsertWin32Msg( pEntry->dwLastResult ),
                                  NULL, NULL, NULL, NULL,
                                  sizeof( pEntry->dwLastResult ),
                                  &(pEntry->dwLastResult)
                    );
    
                pEntry->fUserNotifiedOfStaleness = TRUE;
                
            }
    
            bReturn = TRUE;
        }
    }
    __finally {
        m_List.ReleaseLock();
    }

    return bReturn;

}

BOOL
KCC_CONNECTION_FAILURE_CACHE::ResetUserNotificationFlag(
    IN  DSNAME *    pdnFromServer
    )
{
    BOOL fSuccess;

    m_List.AcquireLockExclusive();

    __try {
        fSuccess = m_List.ResetUserNotificationFlag( pdnFromServer );
    }
    __finally {
        m_List.ReleaseLock();
    }

    return fSuccess;
}

VOID
KCC_CONNECTION_FAILURE_CACHE::IncrementFailureCounts(
    VOID
    )
{
    m_List.AcquireLockExclusive();

    __try {
        m_List.IncrementFailureCounts();
    }
    __finally {
        m_List.ReleaseLock();
    }
}

BOOL
KCC_CONNECTION_FAILURE_CACHE::IsValid(
    VOID
    )
// Is this object internally consistent?
{
    return m_fIsInitialized;
}

DWORD
KCC_CONNECTION_FAILURE_CACHE::Extract(
    OUT DS_REPL_KCC_DSA_FAILURESW **  ppFailures
    )
{
    DWORD winError;

    m_List.AcquireLockShared();

    __try {
        winError = m_List.Extract(ppFailures);
    }
    __finally {
        m_List.ReleaseLock();
    }

    return winError;
}

VOID
KCC_CONNECTION_FAILURE_CACHE::Dump(
    VOID
    )
// Prints out the current list via DPRINT
{

    DPRINT( 0, "This is the cache of servers that we have not been\n" );
    DPRINT( 0, "able to establish contact with.\n" );
    DPRINT( 0, "\n");

    m_List.AcquireLockShared();

    __try {
        // Now dump the list
        m_List.Dump( KccCriticalConnectionServerIsStale );
    }
    __finally {
        m_List.ReleaseLock();
    }
}


BOOL
KCC_CONNECTION_FAILURE_CACHE::Refresh(
    VOID
)
// Reverifies staleness of failed servers in the non-imported cache entries.
// This function also initializes members of the cache that must be reset
// on a per-run basis, such as 'fErrorOccurredThisRun'.
{
    //
    //  DsBind() to each machine in non-imported cache entries.  If the bind
    //  succeeds, the DSA is deemed no longer stale.
    // 

    Assert( this );

    m_List.AcquireLockExclusive();

    __try {
#if DBG
        if (m_List.RefreshFromRegistry(KCC_CONNECTION_FAILURE_KEY)) {
            // Test hook -- stale servers were enumerated in the registry.
            return TRUE;
        }
#endif

        SINGLE_LIST_ENTRY * pList = m_List.m_ListHead.Next;
        PCACHE_ENTRY pLastEntry = NULL;
        PCACHE_ENTRY pEntry = NULL;
        DSNAME DN = {0};
        
        DN.structLen = DSNameSizeFromLen(0);

        while (NULL != pList) {
            LPWSTR pszDsaAddr;
            HANDLE hDS;
            DWORD err;
    
            pEntry = CONTAINING_RECORD(pList, CACHE_ENTRY, Link);
            pList = pEntry->Link.Next;
            
            // Initialize per-KCC-run members of the cache entry.
            pEntry->fErrorOccurredThisRun = FALSE;

            // Don't reverify staleness for imported entries
            if( pEntry->fEntryIsImported ) {
                continue;
            }
            
            Assert(!fNullUuid(&pEntry->Guid));
            DN.Guid = pEntry->Guid;
            
            pszDsaAddr = GuidBasedDNSNameFromDSName(&DN);
            if (NULL == pszDsaAddr) {
                KCC_MEM_EXCEPT(100);
            }
    
            err = DsBindW(pszDsaAddr, NULL, &hDS);
            if (0 == err) {
                DsUnBindW(&hDS);
                
                DPRINT1(0, "Contacted %ls -- removing from stale connection cache.\n",
                        pszDsaAddr);
                
                if (NULL == pLastEntry) {
                    // Remove list head.
                    m_List.m_ListHead.Next = pEntry->Link.Next;
                }
                else {
                    // Remove entry other than list head.
                    pLastEntry->Link.Next = pEntry->Link.Next;
                }
            
                free(pEntry);
            
                // Note that pLastEntry remains unchanged.
            }
            else {
                pLastEntry = pEntry;
            }
            
            THFree(pszDsaAddr);
        }
    }
    __finally {
        m_List.ReleaseLock();
    }

    return TRUE;
}

VOID
KCC_CONNECTION_FAILURE_CACHE::MarkUnneeded(
    IN  BOOL    fImported
    )
// Mark all entries of the appropriate type (either imported
// or non-imported) as unneeded.
{
    Assert( this );
    m_List.AcquireLockExclusive();

    fImported = !!fImported;

    __try {
        SINGLE_LIST_ENTRY * pList = m_List.m_ListHead.Next;
        PCACHE_ENTRY pEntry = NULL;

        while (NULL != pList) {   
            pEntry = CONTAINING_RECORD(pList, CACHE_ENTRY, Link);
            pList = pEntry->Link.Next;

             // Check that the 'imported' flag is not garbage
            Assert( pEntry->fEntryIsImported==!!pEntry->fEntryIsImported );

            if( pEntry->fEntryIsImported==fImported ) {
                pEntry->fUnneeded = TRUE;
            }
        }
    }
    __finally {
        m_List.ReleaseLock();
    }
}


VOID
KCC_CONNECTION_FAILURE_CACHE::FlushUnneeded(
    IN  BOOL    fImported
    )
// Flush out all entries of the appropriate type (either imported
// or non-imported) which are still marked as unneeded.
{
    Assert( this );
    m_List.AcquireLockExclusive();

    fImported = !!fImported;

    __try {
        SINGLE_LIST_ENTRY * pList = m_List.m_ListHead.Next;
        PCACHE_ENTRY pLastEntry = NULL;
        PCACHE_ENTRY pEntry = NULL;

        while (NULL != pList) {
            pEntry = CONTAINING_RECORD(pList, CACHE_ENTRY, Link);
            pList = pEntry->Link.Next;

             // Check that the 'imported' flag is not garbage
            Assert( pEntry->fEntryIsImported==!!pEntry->fEntryIsImported );

            if(   pEntry->fEntryIsImported==fImported
               && pEntry->fUnneeded )
            {
                if (NULL == pLastEntry) {
                    // Remove list head.
                    m_List.m_ListHead.Next = pEntry->Link.Next;
                }
                else {
                    // Remove entry other than list head.
                    pLastEntry->Link.Next = pEntry->Link.Next;
                }
                
                free(pEntry);
                // Note that pLastEntry remains unchanged.
            } else {
                pLastEntry = pEntry;
            }
        }
    }
    __finally {
        m_List.ReleaseLock();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kcctask.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcctask.cxx

ABSTRACT:

    KCC_TASK class.

DETAILS:

    The KCC_TASK class is the base class of all KCC tasks (both periodic and
    notificatication-based).

    It's purpose is to provide a common interface and some common routines
    for all tasks.

CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
extern "C" {
#include <ntsam.h>
#include <lsarpc.h>
#include <lsaisrv.h>
}

#include <dsconfig.h>
#include "kcc.hxx"
#include "kcctask.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include <dstrace.h>

#define FILENO FILENO_KCC_KCCTASK

typedef struct {
    KCC_TASK *  pTask;
    HANDLE      hevDone;
    DWORD *     pdwResult;
} KCC_TASK_TRIGGER_INFO;

// Five minutes
ULONG ulDefaultTaskRestartPeriod = (5*60);


DWORD
KCC_TASK::Execute(
    OUT DWORD * pcSecsUntilNextIteration
    )
//
// Wrapper for ExecuteBody().  Handles allocating and destroying thread
// states, binding, catching exceptions, and logging task start and
// finish.
//
{
    DWORD         ret = 0;
    DWORD         dwExceptionCode;
    void *        pvEA;
    DWORD         dsid;

    //
    // In case the inherited task mistakenly does not set the time of the next
    // occurance, or does not even get a chance to, make sure
    // pcSecsUntilNextIteration is  set to a value so the task will run again.
    //
    Assert(pcSecsUntilNextIteration);
    *pcSecsUntilNextIteration = ulDefaultTaskRestartPeriod;

    if (KCC_STARTED != geKccState) {
        return ERROR_DS_SHUTTING_DOWN;
    }

    DWORD dirError = THCreate(CALLERTYPE_KCC);

    if (0 != dirError) {
        return ERROR_OUTOFMEMORY;
    }

    // Set w32topl allocator routines.
    ToplSetAllocator(&THAlloc, &THReAlloc, &THFree);

    __try {
        LogAndTraceEvent(TRUE,
                         DS_EVENT_CAT_KCC,
                         DS_EVENT_SEV_INTERNAL,
                         DIRLOG_KCC_TASK_ENTRY,
                         EVENT_TRACE_TYPE_START,
                         DsGuidKccTask,
                         NULL, NULL, NULL, NULL,
                         NULL, NULL, NULL, NULL);
        
        //
        // Execute the task, bracketed by appropriate logged events (if the
        // KCC logging level is turned up high enough).
        //
        __try {
            LogBegin();
            ret = ExecuteBody(pcSecsUntilNextIteration);
            LogEndNormal();
        } __except(GetExceptionData(GetExceptionInformation(), &dwExceptionCode,
                                    &pvEA, &ret, &dsid)) {
            if (0 == ret) {
                ret = ERROR_DS_GENERIC_ERROR;
            }

            LogEndAbnormal(ret, dsid);
        }
    }
    __finally {
        // Reset w32topl allocator routines.
        ToplSetAllocator(NULL, NULL, NULL);
        
        LogAndTraceEvent(TRUE,
                         DS_EVENT_CAT_KCC,
                         DS_EVENT_SEV_INTERNAL,
                         DIRLOG_KCC_TASK_EXIT,
                         EVENT_TRACE_TYPE_END,
                         DsGuidKccTask,
                         NULL, NULL, NULL, NULL,
                         NULL, NULL, NULL, NULL);

        THDestroy();
    }

    return ret;
}

BOOL
KCC_TASK::Schedule(
    IN  DWORD   cSecsUntilFirstIteration
    )
//
// Schedule the first execution of the task.  Normally called as part
// of Init().
//
{
    return ::DoInsertInTaskQueue( &TaskQueueCallback, this, cSecsUntilFirstIteration, FALSE, "KCC_Task" );
}

void
KCC_TASK::TaskQueueCallback(
    IN  void *  pvThis,
    OUT void ** ppvThisNext,
    OUT DWORD * pcSecsUntilNext
    )
//
// Callback for TaskQueue.  Wraps Execute().
//
{
    *ppvThisNext = pvThis;

    ( ( KCC_TASK * ) pvThis )->Execute( pcSecsUntilNext );
}

DWORD
KCC_TASK::Trigger(
    IN  DWORD   dwFlags
    )
//
// Execute this task (but serialize it with other tasks running in the task
// queue, esp. other runs of this same task).  Caller may optionally wait
// for the task to complete (i.e., if !(dwFlags & KCC_FLAG_ASYNC_OP)).
//
{
    HANDLE                  hevDone = NULL;
    HANDLE                  rgWaitHandles[2];
    DWORD                   waitStatus;
    KCC_TASK_TRIGGER_INFO * pTriggerInfo = NULL;
    DWORD                   ret = 0;

    pTriggerInfo = (KCC_TASK_TRIGGER_INFO *) malloc(sizeof(*pTriggerInfo));
    if (NULL == pTriggerInfo) {
        return ERROR_OUTOFMEMORY;
    }

    if (!(DS_KCC_FLAG_ASYNC_OP & dwFlags)) {
        // Waiting for completion; create synchronization event.
        hevDone = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL == hevDone) {
            free(pTriggerInfo);
            return GetLastError();
        }
    }

    pTriggerInfo->hevDone   = hevDone;
    pTriggerInfo->pTask     = this;
    pTriggerInfo->pdwResult = &ret;

    if (!::DoInsertInTaskQueue(&TriggerCallback, pTriggerInfo, 0, FALSE, "KCC_Task_Trigger")) {
        free(pTriggerInfo);
        CloseHandle(hevDone);
        return ERROR_OUTOFMEMORY;
    }

    if (NULL != hevDone) {
        // Wait for completion.
        rgWaitHandles[0] = ghKccShutdownEvent;
        rgWaitHandles[1] = hevDone;

        waitStatus = WaitForMultipleObjects(ARRAY_SIZE(rgWaitHandles),
                                            rgWaitHandles,
                                            FALSE,
                                            INFINITE);
        switch (waitStatus) {
        case WAIT_OBJECT_0:
            // Shutdown.
            ret = ERROR_DS_SHUTTING_DOWN;
            break;
        case WAIT_OBJECT_0 + 1:
            // Task completed!  Return value (ret) set by callback function.
            break;
        case WAIT_FAILED:
            ret = GetLastError();
            break;
        default:
            ret = ERROR_DS_INTERNAL_FAILURE;
            break;
        }

        CloseHandle(hevDone);
    }

    return ret;
}

void
KCC_TASK::TriggerCallback(
    IN  void *  pvTriggerInfo,
    OUT void ** ppvNextParam,
    OUT DWORD * pcSecsUntilNext
    )
//
// TaskQueue callback for triggered execution.  Wraps Execute().
//
{
    KCC_TASK_TRIGGER_INFO * pTriggerInfo;
    DWORD                   dwResult;

    pTriggerInfo = (KCC_TASK_TRIGGER_INFO *) pvTriggerInfo;

    // Execute our task.
    dwResult = pTriggerInfo->pTask->Execute(pcSecsUntilNext);

    // This is a one-shot execution; don't reschedule.
    *pcSecsUntilNext = TASKQ_DONT_RESCHEDULE;

    if (NULL != pTriggerInfo->hevDone) {
        // Tell waiting thread that we're done.
        *pTriggerInfo->pdwResult = dwResult;
        SetEvent(pTriggerInfo->hevDone);
    }

    free(pTriggerInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kccnctl.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccnctl.cxx

ABSTRACT:

    Routines to perform the automated NC topology

DETAILS:

CREATED:

    03/27/97    Colin Brace (ColinBr)

REVISION HISTORY:

--*/

#include <NTDSpchx.h>
#include "kcc.hxx"
#include "kcctask.hxx"
#include "kccconn.hxx"
#include "kcctopl.hxx"
#include "kcccref.hxx"
#include "kccdsa.hxx"
#include "kcctools.hxx"
#include "kcctrans.hxx"
#include "kccsconn.hxx"
#include "kccdynar.hxx"
#include "kccsite.hxx"
#include "kccduapi.hxx"

#include "w32topl.h"

#define FILENO FILENO_KCC_KCCNCTL

//
// Define an array of possible NCList types in the DS
ATTRTYP g_rgAttidNCListType[] = 
{
    ATT_HAS_MASTER_NCS,
    ATT_HAS_PARTIAL_REPLICA_NCS,
};

#define g_cAttidNCListType (sizeof(g_rgAttidNCListType) / sizeof(ATTRTYP))

//
// Prototypes of local functions
//

VOID
KccConstructRingTopology(
    IN     KCC_DSA_ARRAY *                  pDsaArray,
    IN     KCC_CROSSREF *                   pCrossRef,
    IN     BOOL                             fMasterOnly,
    IN OUT KCC_INTRASITE_CONNECTION_LIST *  pConnectionList
    );

VOID
KccConstructEfficientNCTopology(
    IN     KCC_CROSSREF *                   pCrossRef,
    IN     KCC_DSA_LIST &                   DsaList,
    IN     BOOL                             fRefresh,
    IN OUT KCC_INTRASITE_CONNECTION_LIST *  pConnectionList
    );

KCC_DSA*
KccDsaInGraph(
    IN DSNAME*    SourceDsName,
    IN TOPL_GRAPH Graph
    );

VOID
KccGetDsasInNC(
    IN  KCC_CROSSREF *  pCrossRef,
    IN  KCC_DSA_LIST &  dsaList,
    OUT KCC_DSA_ARRAY & dsaArray
    );

BOOL
KccCreateRandomConnection(
    IN  DSNAME             *pNC,
    IN  KCC_DSA_ARRAY       &dsaArray,
    IN OUT KCC_DSNAME_ARRAY &dnFromServers
    );


BOOL
KccIsTimeToRefreshTopology(
    IN KCC_DSA_LIST& dsaList
    );

//
// Function definitions
//

VOID
KccConstructMasterNCTopologiesForSite(
    IN OUT  KCC_INTRASITE_CONNECTION_LIST * pConnectionList
    )
/*++

Routine Description:

    This routine will determine what master naming contexts are
    hosted by the local dsa, and then construct a ring topology for all
    of those naming contexts.
    
Parameters:

    pConnectionList (IN/OUT)

Returns:

    None - the only errors are unexpected errors - so an exception is thrown
    
--*/
{
    //
    // NCArray is an array of pointers to DSNAME's off all naming
    // contexts hosted in by the local dsa.
    //
    KCC_CROSSREF_ARRAY  MasterHostedCrossRefArray;
    ULONG               i;
    KCC_SITE *          pLocalSite = gpDSCache->GetLocalSite();
    KCC_DSA_LIST *      pDsaList = pLocalSite->GetDsaList();
    KCC_DSA *           pLocalDSA = gpDSCache->GetLocalDSA();
    KCC_CROSSREF_LIST * pCrossRefList = gpDSCache->GetCrossRefList();
    BOOL                fRefresh;

    //
    // Make a list of all the master nc's the dsa hosts
    //
    for (i = 0; i < pCrossRefList->GetCount(); i++) {
        KCC_CROSSREF * pCrossRef = pCrossRefList->GetCrossRef(i);
        BOOL           fIsMaster;

        if (pLocalDSA->IsNCHost(pCrossRef, TRUE /* fIsLocal */, &fIsMaster)
            && fIsMaster) {
            MasterHostedCrossRefArray.Add(pCrossRef);
        }
    }

    // We should have at least three naming contexts
    Assert(MasterHostedCrossRefArray.GetCount() >= 3);

    //
    // Sort the array of naming contexts (by guid)
    // 2000-04-04 JeffParh - Why is sorting necessary?
    //
    MasterHostedCrossRefArray.Sort();

    //
    // Have so many new servers been added that we need to refresh our 
    // existing connections?
    //
    fRefresh = KccIsTimeToRefreshTopology(*pDsaList);

    //
    // For each naming context construct a ring topology
    //
    for (i = 0; i < MasterHostedCrossRefArray.GetCount(); i++) {
        KCC_CROSSREF * pCrossRef = MasterHostedCrossRefArray[i];
        KCC_DSA_ARRAY  DsaArray;
        DWORD ErrorCode;

        DPRINT1(3, "Constructing topology for %ws\n", pCrossRef->GetNCDN()->StringName);

        __try {

            DsaArray.GetLocalDsasHoldingNC( pCrossRef, TRUE );
            KccConstructRingTopology(&DsaArray,
                                     pCrossRef,
                                     TRUE,
                                     pConnectionList);

        } 
        __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) ) {
            //
            // If an error occur in the w32topl, then the objects were somehow
            // mishandled.  Log the error and continue with the next
            // naming context
            //

            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_KCC_AUTO_TOPL_GENERATION_INCOMPLETE,
                szInsertDN(pCrossRef->GetNCDN()),
                szInsertHex(ErrorCode),
                0
                );
        }
    }

    //
    // Add some more connections to minimize hops between servers.  Note that 
    // this is done after the ring topology so an nc can consider connections 
    // for other nc's ring topology as optimizing connections for their own 
    // topology.
    //
    if (!pLocalSite->IsMinimizeHopsDisabled()) {
        for (i = 0; i < MasterHostedCrossRefArray.GetCount(); i++) {
            KCC_CROSSREF * pCrossRef = MasterHostedCrossRefArray[i];
            BOOL fRefreshThisNc = FALSE;
            
            // By refreshing the configuration naming context, we
            // have refreshed the schema nc, too, so don't do it
            // twice.
            fRefreshThisNc = fRefresh
                             && (KCC_NC_TYPE_SCHEMA != pCrossRef->GetNCType());

            KccConstructEfficientNCTopology(pCrossRef,
                                            *pDsaList,
                                            fRefreshThisNc,
                                            pConnectionList);

        }
    }
}

VOID 
KccConstructPartialReplicaNCTopologiesForSite(
    IN OUT  KCC_INTRASITE_CONNECTION_LIST * pConnectionList
    )
/*++

Routine Description:

    This routine will determine what partial replica naming contexts are
    hosted by the local dsa, and then construct a ring topology for all
    of those naming contexts.
    
Parameters:

    pConnectionList (IN/OUT)

Returns:

    None - the only errors are unexpected errors - so an exception is thrown
    
--*/
{
    DWORD               icref;
    ULONG               i;
    KCC_DSA *           pLocalDSA = gpDSCache->GetLocalDSA();
    KCC_CROSSREF_LIST * pCrossRefList = gpDSCache->GetCrossRefList();
    BOOL                fIsMaster;

    if (!pLocalDSA->IsGC()) {
        // no partial replicas to process if this is not a GC
        return;
    }

    // We are going to iterate through partial replica NCs
    // we should get the list partial replica NCs that should
    // be hosted by this DSA by iterating through the crossref 
    // objects

    for (icref = 0; icref < pCrossRefList->GetCount(); icref++) {
        KCC_CROSSREF * pCrossRef = pCrossRefList->GetCrossRef(icref);
        KCC_DSA_ARRAY  DsaArray;
        DWORD ErrorCode;

        ASSERT_VALID(pCrossRef);

        if (pLocalDSA->IsNCHost(pCrossRef, TRUE /* fIsLocal */, &fIsMaster)
            && !fIsMaster) {
            // This is a partial replica NC that needs to be 
            // hosted by this GC.

            DPRINT1(3, "Constructing topology for %ws\n", pCrossRef->GetNCDN()->StringName);
    
            __try {

                DsaArray.GetLocalDsasHoldingNC( pCrossRef, FALSE );
                KccConstructRingTopology(&DsaArray,
                                         pCrossRef,
                                         FALSE,
                                         pConnectionList);
    
            } __except(ToplIsToplException(ErrorCode=GetExceptionCode())) {
                //
                // If an error occur in the w32topl, then the objects were somehow
                // mishandled.  Log the error and continue with the next
                // naming context
                //
    
                LogEvent(
                    DS_EVENT_CAT_KCC,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_KCC_AUTO_TOPL_GENERATION_INCOMPLETE,
                    szInsertDN(pCrossRef->GetNCDN()),
                    szInsertHex(ErrorCode),
                    0
                    );
            }
        }
    }
}

VOID 
KccConstructGCTopologyForSite(
    IN OUT  KCC_INTRASITE_CONNECTION_LIST * pConnectionList
    )
/*++

Routine Description:

    This function creates a ring topology for all GCs in the local site.
    
Parameters:

    pConnectionList (IN/OUT)

Returns:

    None - the only errors are unexpected errors - so an exception is thrown
    
--*/
{
    KCC_DSA_ARRAY       DsaArray;
    KCC_CROSSREF_LIST  *pCrossRefList = gpDSCache->GetCrossRefList();
    KCC_CROSSREF       *pConfigCR;
    DSNAME             *pConfigDN = gpDSCache->GetConfigNC();
    KCC_DSA *           pLocalDSA = gpDSCache->GetLocalDSA();
    DWORD               ErrorCode;


    // No need to process GC topology if this is not a GC
    if (!pLocalDSA->IsGC()) {
        return;
    }


    // Find the CrossRef for Config
    pConfigCR = pCrossRefList->GetCrossRefForNC( pConfigDN );
    ASSERT_VALID(pConfigCR);
    if(!pConfigCR) {
        KCC_EXCEPT(ERROR_DS_OBJ_NOT_FOUND, 0);
    }


    DPRINT(3, "Constructing GC topology\n");
    
    __try {
    
        DsaArray.GetLocalGCs();
        KccConstructRingTopology(&DsaArray,
                                 pConfigCR,
                                 FALSE,
                                 pConnectionList);
                               
    } __except(ToplIsToplException(ErrorCode=GetExceptionCode())) {

        //
        // If an error occur in the w32topl, then the objects were somehow
        // mishandled.  Log the error and continue with the next
        // naming context
        //    
        LogEvent(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_KCC_AUTO_TOPL_GENERATION_INCOMPLETE,
            szInsertDN(pConfigDN),
            szInsertHex(ErrorCode),
            0
            );
    }
}

VOID
KccConstructTopologiesForSite(
    IN OUT  KCC_INTRASITE_CONNECTION_LIST * pConnectionList
    )
/*++

Routine Description:

    Given the DSNAME of a site, this routine will determine what
    naming contexts are hosted by the local dsa, and then construct
    a list of all dsa's in this site for another function to analyse.
    
Parameters:

    pSite : the DSNAME of the site to constuct the topology for

Returns:

    None - the only errors are unexpected errors - so an exception is thrown
    
--*/
{
    // The local site is never empty because the local DSA is always in
    // the local site. This is checked when initializing the KCC_CACHE
    Assert( gpDSCache->GetLocalSite()->GetDsaList()->GetCount()>0 );

    KccConstructMasterNCTopologiesForSite(pConnectionList);
    
    KccConstructPartialReplicaNCTopologiesForSite(pConnectionList);
    
    KccConstructGCTopologyForSite(pConnectionList);
}
      
VOID
KccConstructRingTopology(
    IN     KCC_DSA_ARRAY *                  pDsaArray,
    IN     KCC_CROSSREF *                   pCrossRef,
    IN     BOOL                             fMasterOnly,
    IN OUT KCC_INTRASITE_CONNECTION_LIST *  pConnectionList
    )
/*++

Routine Description:

    Connect all servers in pDsaArray in a ring.

Parameters:

    pDsaArray       - This is a list of servers to connect in a ring.

    pCrossRef       - If we're building the topology for a particular NC, this
                      is the crossref of the NC.
                     
    fMasterOnly     - If we're building the topology for a particular NC, this
                      indicates whether pDsaArray contains just Masters or
                      Readonly copies too.
                      
    pConnectionList - a list of servers to mark if this function doesn't want
                      them removed                     
                      
[wlees 6/25/99 RAID 356844]
Note that because the kcc does not read all of its data in a single transaction,
there can be inconsistencies if other changes are occuring at the same time.
A common inconsistency we see in this routine is that even though the DsaList
is supposed to be a list of servers in the current local site, we sometimes see
the names of those servers (their DSNAMEs) showing them in other sites.
[Jeff Parham]  We find the site by GUID when we do the search, so if the DSA
shows up in the site it's really in the site at the time the search is performed.
What causes the possible name incosistency in this case is if the site has been
renamed between the time the site list was read and the time the DSA list for
that site was read -- i.e., the DSNAMEs of the DSAs may indicate a more recent
name for the site than the site list does.

Returns:

--*/
{
    KCC_DSA       *pDsa;
    CTOPL_GRAPH   Graph;
    TOPL_ITERATOR VertexIter = NULL;
    KCC_DSA_ARRAY HostingDsaArray;
    ULONG         i, j;
    KCC_DSA *     pLocalDsa = gpDSCache->GetLocalDSA();
    BOOL          fIsMaster;

    ASSERT_VALID(pCrossRef);
    ASSERT_VALID(pDsaArray);
    ASSERT_VALID(pConnectionList);
            
    // If there aren't any servers in the list, don't do anything
    if (pDsaArray->GetCount() == 0) {
        DPRINT1(0, "ConstructNCTopology for %ws called with empty pDsaArray\n"
                "Server objects moved while KCC was running.",
                pCrossRef->GetNCDN()->StringName);
        return;
    }
    
    //
    // Iterate through the dsa's and for each dsa that is not
    // stale, add that dsa to the HostingDsaArray
    //
    for (i = 0; i < pDsaArray->GetCount(); i++) {
        pDsa = (*pDsaArray)[i];
        ASSERT_VALID(pDsa);

        pDsa->ClearEdges();

        if (!KccCriticalLinkServerIsStale(pDsa->GetDsName())
            && !KccCriticalConnectionServerIsStale(pDsa->GetDsName()))
        {
            // Dsa is online and should be included in the topology.
            HostingDsaArray.Add(pDsa);
            DPRINT2(4, "Dsa %ws is a candidate to source nc %ws\n",
                pDsa->GetDsName()->StringName,
                pCrossRef->GetNCDN()->StringName);
        } else {
            // We still want to keep connection objects inbound to the local
            // DSA from "stale" servers so we keep trying to replicate from
            // them.
            KCC_CONNECTION *pcn = pConnectionList
                                        ->GetConnectionFromSourceDSAUUID(
                                                &pDsa->GetDsName()->Guid);
            if (pcn) {
                pcn->AddReplicatedNC(pCrossRef->GetNCDN(), !fMasterOnly);
                pcn->SetReasonForConnection(KCC_STALE_SERVERS_TOPOLOGY);
                DPRINT2(4, "keeping connection %ws because of stale source %ws\n",
                        pcn->GetConnectionDN()->StringName,
                        pDsa->GetDsName()->StringName);
            }
        }
    }

    //
    // Sort the dsa's by guid
    //
    HostingDsaArray.Sort();

    //
    // Now find all the edges that connect two servers in 
    // the graph
    //
    for ( i = 0; i < HostingDsaArray.GetCount(); i++) {

        pDsa = HostingDsaArray[i];
        Assert(pDsa);

        //
        // The array of Dsa objects have already been sorted, so assign
        // an id for the graph routines
        //
        pDsa->SetId(i);

        //
        // Insert the Dsa into the graph
        //
        Graph.AddVertex( pDsa, pDsa );

        //
        // Now determine if any connections already exist for this naming
        // context's topology inbound to the local DSA.
        //
        if (pDsa == pLocalDsa) {
            KCC_CONNECTION *  Conn;
            KCC_DSA *         SourceDsa;
    
            for (j = 0; j < pConnectionList->GetCount(); j++) {
    
                Conn = pConnectionList->GetConnection(j);
    
                Assert(Conn);
                Assert(Conn->GetSourceDSADN());
    
                SourceDsa = HostingDsaArray.Find(Conn->GetSourceDSADN());
                
                if (SourceDsa) {
    
                    //
                    // This connection object connects two 
                    // servers in the graph
                    //
                    Conn->SetTo(pDsa);
                    Conn->SetFrom(SourceDsa);
    
                    //
                    // This makes the edge appear in the vertices
                    // list of head and tail vertices
                    //
                    Conn->Associate();
                }
            }
        }
    }

    //
    //  Determine what new connections need to be made and what old
    //  ones can be kept
    //
    TOPL_LIST     EdgeToAddList = ToplListCreate();
    TOPL_ITERATOR EdgeIter = ToplIterCreate();
    TOPL_EDGE    *EdgesToKeep = NULL;
    ULONG         cEdgesToKeep;

    __try {

        Graph.MakeRing(TOPL_RING_TWO_WAY,
                       EdgeToAddList,
                       &EdgesToKeep,
                       &cEdgesToKeep);
    
        //
        // For each connection returned that has to be created
        // check to see if it should be created on this dsa
        // then create it.
        //
        CTOPL_EDGE *Edge;
        for (Edge = NULL, ToplListSetIter(EdgeToAddList, EdgeIter);
            (Edge = (CTOPL_EDGE*) ToplIterGetObject(EdgeIter)) != NULL;
                ToplIterAdvance(EdgeIter)) {
    
            Assert(Edge);
    
            //
            // Is connection one that sources the local DSA - if so, create the
            // connection object locally
            //
            if( (CTOPL_VERTEX*)ToplEdgeGetToVertex(Edge) == (CTOPL_VERTEX*) pLocalDsa ) {
    
                //
                // This connection object should be made locally
                //
                KCC_DSA *         SourceDSA = (KCC_DSA*) Edge->GetFrom();
                KCC_CONNECTION *  pcnNew = new KCC_CONNECTION;
    
                Assert( gfIntrasiteSchedInited );
                pcnNew->SetEnabled(       TRUE                         );
                pcnNew->SetGenerated(     TRUE                         );
                pcnNew->SetSourceDSA(     SourceDSA                    );
                pcnNew->SetSchedule(      gpIntrasiteSchedule          );
                pcnNew->AddReplicatedNC(  pCrossRef->GetNCDN(), !fMasterOnly);
                pcnNew->SetReasonForConnection( KCC_RING_TOPOLOGY );
    
                DWORD dirError = pcnNew->Add(pLocalDsa->GetDsName());
    
                if (0 != dirError) {
                    DPRINT1( 0, "Failed to add connection object, error %d.\n", dirError );
    
                    LogEvent(
                        DS_EVENT_CAT_KCC,
                        DS_EVENT_SEV_VERBOSE,
                        DIRLOG_KCC_ERROR_CREATING_CONNECTION_OBJECT,
                        szInsertDN(SourceDSA->GetDsName()),
                        szInsertDN(pLocalDsa->GetDsName()),
                        0
                        );
                } else {
                    pConnectionList->AddToList(pcnNew);
    
                    DPRINT2( 3,
                             "KCC: created local connection object, localdsa:%ws, sourcedsa:%ws\n",
                             pLocalDsa->GetDsName()->StringName,
                             SourceDSA->GetDsName()->StringName
                        );
                    LogEvent(
                        DS_EVENT_CAT_KCC,
                        DS_EVENT_SEV_ALWAYS,
                        DIRLOG_KCC_CONNECTION_OBJECT_CREATED,
                        szInsertDN(SourceDSA->GetDsName()),
                        szInsertDN(pLocalDsa->GetDsName()),
                        0
                        );
                }
            }
        }

        //
        // Now flag all the connections in pConnectionList we want to keep
        //
        if ( pConnectionList )
        {
            for ( i = 0; i < cEdgesToKeep; i++)
            {
                KCC_CONNECTION *pcnKeep;
                KCC_CONNECTION *pcn = (KCC_CONNECTION*)((CTOPL_EDGE*)EdgesToKeep[ i ]);
    
                pcnKeep = pConnectionList->GetConnectionWithSameGUID(pcn);
                if (pcnKeep)
                {
                    pcnKeep->AddReplicatedNC( pCrossRef->GetNCDN(), !fMasterOnly );
                    pcnKeep->SetReasonForConnection(KCC_RING_TOPOLOGY);
                }
                // else 
                //
                //  A connection object got added in between the time the deletion
                //  candidate list was created and now.  Fine - it is not in the list
                //  and it won't be deleted.
                //
            }
        }

    }
    __finally
    {

        //
        // Free the list and all the edges contained in the list
        // 
        ToplListFree(EdgeToAddList, TRUE);
        ToplIterFree(EdgeIter);
        if (EdgesToKeep)
        {
            ToplFree(EdgesToKeep);
        }

    }                

    return;

}

VOID
KccConstructEfficientNCTopology(
    IN      KCC_CROSSREF *                  pCrossRef,
    IN      KCC_DSA_LIST &                  dsaList,
    IN      BOOL                            fRefresh,
    IN OUT  KCC_INTRASITE_CONNECTION_LIST * pConnectionList 
    )
/*++

Routine Description:

    This routine looks at all the connections coming into the local server
    and makes sure there is at least n number of connections. n is determined by
    a special purpose function, KccGetNumberOfOptimizingEdges().
    
    Each server must have at least at least two incoming edges for the ring topology.
    This function adds KccGetNumberOfOptimizingEdges more to the server, sourced from
    random servers within the site that host the NC specified.
    
    This function has 3 sections:  Determing what connections are still considered
    useful, marking existing connections are useful so they won't get deleted, and
    creating any new connections if necessary.
    
Parameters:

    pCrossRef       - the crossref for the NC to build a topology for
    
    dsaList         - this is a list of servers from which to connect all 
                      servers that host this NC

    fRefresh        - refresh an old optimization connection if one exists
    
    pConnectionList - a list of servers to mark if this function doesn't want
                      them removed                     
                      
Returns:

    VOID

--*/
{
    KCC_INTRASITE_CONNECTION_LIST *pcnlist;
    KCC_CONNECTION       *pcn, *pcn2, *pcnOldest = NULL;
    KCC_DSA              *pdsa;
    DSNAME               *pdnFromServer;
    ULONG                cConnections, iConnection;
    BOOL                 fIsMaster;
    KCC_CONNECTION_ARRAY cnArray;
    KCC_DSNAME_ARRAY     dnFromServers;
    KCC_DSA_ARRAY        dsaArray;
    ULONG                TotalConnectionsNeeded = 0;
    ULONG                NewConnectionsNeeded = 0;
    ULONG                Index;
    BOOL                 fStatus;
    ULONG                Reason;
    BOOL                 fDeletionCandidate;
    DSNAME *             pdnLocalDSA = gpDSCache->GetLocalDSADN();

    Assert( pConnectionList );

    //
    // Bail out right away if we don't need more than the ring topology
    //
    if ( KccGetNumberOfOptimizingEdges( dsaList.GetCount() ) == 0 )
    {
        return;
    }

    //
    // In the initial part of the analysis, we keep track of all servers we have
    // connections from so if we have to randomly create a new connection, we
    // won't choose a server that we are already connected to.  For starters,
    // add the local machine to the list
    //
    dnFromServers.Add(pdnLocalDSA);

    //
    // Determine what connections we can consider that we already have.
    //

    pcnlist = gpDSCache->GetLocalDSA()->GetIntraSiteCnList();

    cConnections = pcnlist->GetCount();

    for ( iConnection = 0; iConnection < cConnections; iConnection++ )
    {
        pcn = pcnlist->GetConnection( iConnection );

        pdnFromServer = pcn->GetSourceDSADN();

        pdsa = dsaList.GetDsa( pdnFromServer );

        if (pdsa
            && pdsa->IsNCHost(pCrossRef, FALSE /* fIsLocal */, &fIsMaster)
            && fIsMaster) {
            //
            // Record this server in our list of servers that we
            // we have a connection from
            //
            dnFromServers.Add( pdsa->GetDsName() );

            //
            // Ok, this connection is from a server is the
            // current naming context - now, is this a connection
            // that is considered good?
            //
            
            if ( KccNonCriticalLinkServerIsStale( pdnFromServer )
              || KccNonCriticalConnectionServerIsStale( pdnFromServer ) )
            {

                //
                // This connection is no good, don't mark it as useful
                // so it gets deleted at the end of this iteration
                //
                NOTHING;
            }
            else
            {
                //
                // This connection can be considered
                //
                cnArray.Add( pcn );

            }

            //
            // While we are looping through all the connections, let's find
            // the likeliest candidate for deletion in case we want to
            // refresh the topology.
            //
            fDeletionCandidate = FALSE;
            pcn2 = pConnectionList->GetConnectionWithSameGUID( pcn );
            if ( pcn2 )
            {
                Reason = pcn2->GetReasonForConnection();

                if ( (Reason & ~KCC_MINIMIZE_HOPS_TOPOLOGY) == 0 )
                {
                    //
                    // This connection is only used to minimize
                    // hops
                    //
                    fDeletionCandidate = TRUE;
                    
                }
            }
    
            if ( fDeletionCandidate )
            {
                //
                // This is a connection that we could delete
                //
                if ( pcnOldest )
                {
                    if ( pcn2->GetWhenCreated() < pcnOldest->GetWhenCreated() )
                    {
                        pcnOldest = pcn2;
                    }
                }
                else
                {
                    pcnOldest = pcn2;
                }
            }
        }
    }

    if ( cnArray.GetCount() < 2 )
    {
        //
        // less than two connections => less than 3 servers are hosting this NC
        // in this site. No need to continue with Optimizing Edges algo.
        //
        return;
        
    }

    //
    // Ok, we have now constructed a list of connection objects
    // that source from servers in this site from the given naming
    // context that are not stale.  How many total connections
    // do we need?
    //
    TotalConnectionsNeeded = KccGetNumberOfOptimizingEdges( dsaList.GetCount() )
                             + 2;

    //        
    // Now determine if we need to create connections and how many current
    // connection we should mark as needed.
    //
    if ( cnArray.GetCount() < TotalConnectionsNeeded ) 
    {
        //
        // Create some new connections, randomly sourced
        //
        NewConnectionsNeeded = TotalConnectionsNeeded - cnArray.GetCount();

    }
    else 
    {
        //
        // We have exactly enough or too many
        //
        
        //
        // See if we want to replace an old connection
        //
        if ( fRefresh )
        {
            if ( pcnOldest )
            {
#if DBG
                //
                // This edge should only be used for optimizing purposes
                //
                {
                    DWORD Reason;
            
                    Reason = pcnOldest->GetReasonForConnection(); 
                    Assert( (Reason & ~KCC_MINIMIZE_HOPS_TOPOLOGY) == 0 );
                }
#endif


                //
                // Delete it
                //
                pcnOldest->Remove();
                cnArray.Remove(pcnOldest);
                pcnlist->RemoveFromList(pcnOldest);
                delete pcnOldest;

                //
                // Make a new connection
                //
                NewConnectionsNeeded = 1;
            }
            else
            {
                //
                //  We could not find an appropriate edge to delete.
                //
                NOTHING;
            }
        }
        else
        {
            //
            //  No desire to refresh this iteration
            //
            NOTHING;
        }

    }

    //
    // At this point, we have determined if any new connections need to be created
    // and if any edges need to be kept. 
    //

    //
    // First mark the minimum number of edges we need; this is a two pass algorithm:
    //

    //
    // First we mark all the edges that already have a reason to exist - use
    // these first; second mark edges with no reason
    //
    ULONG ccn, icn;
    ULONG cValidConnections = 0;

    ccn = cnArray.GetCount();

    for ( icn = 0; 
            icn < ccn && cValidConnections < TotalConnectionsNeeded; 
                icn++ )
    {
        pcn = cnArray[icn];
        Assert( pcn );
        
        //
        // Find the reason for this connection, if there is one
        //
        pcn2 = pConnectionList->GetConnectionWithSameGUID( pcn );
        if ( pcn2 )
        {
            Reason = pcn2->GetReasonForConnection();

            if ( Reason != KCC_NO_REASON )
            {
                Reason |= KCC_MINIMIZE_HOPS_TOPOLOGY;
                
                pcn2->AddReplicatedNC( pCrossRef->GetNCDN(), FALSE /* NOT GC */ );
                pcn2->SetReasonForConnection( Reason );

                cValidConnections++;
            
            }
        }
        else
        {
            //
            // Since this connection was not in the original list of
            // connections, it must have been created on this iteration
            // of the KCC; it fits the criteria of an optimizing connection
            // so let's use it
            //
            cValidConnections++;

        }
    }

    //
    // Second, if we have to, mark connections with no reason
    //
    for ( icn = 0; 
            icn < ccn && cValidConnections < TotalConnectionsNeeded; 
                icn++ )
    {
        pcn = cnArray[icn];
        Assert( pcn );
        
        //
        // Find the reason for this connection, if there is one
        //
        pcn2 = pConnectionList->GetConnectionWithSameGUID( pcn );
        if ( pcn2 )
        {
            DWORD Reason = pcn2->GetReasonForConnection();

            //
            // If the connection has no reason and it is not the connection 
            // that we want to delete then mark it as needed.
            //
            if ( Reason == KCC_NO_REASON 
              && !(fRefresh && pcn2 == pcnOldest ) )
            {
                Reason |= KCC_MINIMIZE_HOPS_TOPOLOGY;
                
                pcn2->AddReplicatedNC( pCrossRef->GetNCDN(), FALSE /* NOT GC */ );
                pcn2->SetReasonForConnection( Reason );

                cValidConnections++;
            }
        }
    }

    Assert( cValidConnections <= TotalConnectionsNeeded );
    
    // If we haven't decided to pick a new source for an old optimizing
    // connection, then if all current connections are valid we shouldn't
    // need to add any more.
    Assert(fRefresh
           || (cValidConnections != TotalConnectionsNeeded)
           || (0 == NewConnectionsNeeded));

    //
    // Now, create any connections we need to
    //
    if ( NewConnectionsNeeded > 0 )
    {

       //
       // First, make the array of servers that are possible candidates
       //
       KccGetDsasInNC(pCrossRef,     // the nc we are interested in 
                      dsaList,       // the list of servers in the current site
                      dsaArray);     // out - the servers hosting the nc

       for ( Index = 0; Index < NewConnectionsNeeded; Index++ )
       {
           fStatus = KccCreateRandomConnection( pCrossRef->GetNCDN(),
                                                dsaArray,
                                                dnFromServers );

           if ( !fStatus )
           {
               //
               // We were not able to find or create a new connection
               // try on the next KCC iteration
               //
               break;
               
            }
        }
    }
}


VOID
KccGetDsasInNC(
    IN  KCC_CROSSREF *  pCrossRef,
    IN  KCC_DSA_LIST &  dsaList,
    OUT KCC_DSA_ARRAY & dsaArray
    )
//
// Extract the servers from dsaList that host pNC and put them in
// dsaArray.
//
{

    ULONG    idsa, cdsa;
    KCC_DSA  *pdsa;
    BOOL     fIsMaster;
    KCC_DSA *pLocalDSA = gpDSCache->GetLocalDSA();

    cdsa = dsaList.GetCount();

    for (idsa = 0; idsa < cdsa; idsa++) {
        pdsa = dsaList.GetDsa(idsa);

        if (pdsa
            && pdsa->IsNCHost(pCrossRef, (pdsa == pLocalDSA), &fIsMaster)
            && fIsMaster) {
            //
            // This is a candidate
            //
            dsaArray.Add( pdsa );
        }
    }
}

BOOL
KccCreateRandomConnection(
    IN     DSNAME          *pNC,
    OUT    KCC_DSA_ARRAY    &dsaArray,
    IN OUT KCC_DSNAME_ARRAY &dnFromServers
    )
//
// Randomly choose a server from dsaArray that is not known to be stale
// and not server from whom we already have a connection. Once chosen
// make a connection from this server.
//
{
    ULONG    iSource;
    KCC_DSA *pdsa;
    ULONG    Count, cdsa;
    ULONG    cMaxRandomTries;
    BOOL     fSuccess = FALSE;
    DSNAME * pdnLocalDSA = gpDSCache->GetLocalDSADN();
    KCC_INTRASITE_CONNECTION_LIST * pConnectionList = gpDSCache->GetLocalDSA()->GetIntraSiteCnList();

    cMaxRandomTries = dsaArray.GetCount() * 2;

    for (Count = 0, pdsa = NULL; Count < cMaxRandomTries && !fSuccess; Count++) {

        iSource = rand() % dsaArray.GetCount();

        pdsa = dsaArray[ iSource ];

        if (!KccNonCriticalConnectionServerIsStale(pdsa->GetDsName())
            && !dnFromServers.IsElementOf(pdsa->GetDsName())) {
            //
            // Ok, this is a server that we don't have a connection
            // for.  Make a connection.
            //

            KCC_CONNECTION * pcnNew = new KCC_CONNECTION;
            
            Assert( gfIntrasiteSchedInited );
            pcnNew->SetEnabled(       TRUE                         );
            pcnNew->SetGenerated(     TRUE                         );
            pcnNew->SetSourceDSA(     pdsa                         );
            pcnNew->SetSchedule(      gpIntrasiteSchedule          );
            pcnNew->AddReplicatedNC(  pNC, FALSE /* not gc */ );
            pcnNew->SetReasonForConnection( KCC_MINIMIZE_HOPS_TOPOLOGY );

            DWORD dirError = pcnNew->Add( pdnLocalDSA );

            if (0 != dirError) {
                DPRINT1( 0, "Failed to add connection object, error %d.\n", dirError );

                LogEvent(
                    DS_EVENT_CAT_KCC,
                    DS_EVENT_SEV_VERBOSE,
                    DIRLOG_KCC_ERROR_CREATING_CONNECTION_OBJECT,
                    szInsertDN(pdsa->GetDsName()),
                    szInsertDN(pdnLocalDSA),
                    0
                    );
            } else {
                pConnectionList->AddToList(pcnNew);
                
                DPRINT3(3,
                        "KCC: created random connection object, localdsa:%ws, sourcedsa:%ws, nc:%ws\n",
                        pdnLocalDSA->StringName,
                        pdsa->GetDsName()->StringName,
                        pNC->StringName);

                LogEvent(
                    DS_EVENT_CAT_KCC,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_KCC_CONNECTION_OBJECT_CREATED,
                    szInsertDN(pdsa->GetDsName()),
                    szInsertDN(pdnLocalDSA),
                    0
                    );

                fSuccess = TRUE;
            }

            //
            // Don't use this source server again
            //
            dnFromServers.Add( pdsa->GetDsName() );
            
        } else {
            pdsa = NULL;
        }
    }

    if (!pdsa) {
        //
        // We didn't find one after the maximum number of random tries
        // Go through iteratively
        //
        Assert( Count == cMaxRandomTries );

        cdsa = dsaArray.GetCount();

        for (iSource = 0; !fSuccess && iSource < cdsa; iSource++) {

            pdsa = dsaArray[iSource];
    
            if (!KccNonCriticalConnectionServerIsStale(pdsa->GetDsName()) 
                && !dnFromServers.IsElementOf(pdsa->GetDsName())) {
                //
                // Ok, this is a server that we don't have a connection
                // for.  Make a connection.
                //
                KCC_CONNECTION * pcnNew = new KCC_CONNECTION;
                
                Assert( gfIntrasiteSchedInited );
                pcnNew->SetEnabled(       TRUE                         );
                pcnNew->SetGenerated(     TRUE                         );
                pcnNew->SetSourceDSA(     pdsa                         );
                pcnNew->SetSchedule(      gpIntrasiteSchedule          );
                pcnNew->AddReplicatedNC(  pNC, FALSE /* not gc */ );
                pcnNew->SetReasonForConnection( KCC_MINIMIZE_HOPS_TOPOLOGY );
    
                DWORD dirError = pcnNew->Add( pdnLocalDSA );
    
                if ( 0 != dirError ) {
                    DPRINT1( 0, "Failed to add connection object, error %d.\n", dirError );
    
                    LogEvent(
                        DS_EVENT_CAT_KCC,
                        DS_EVENT_SEV_VERBOSE,
                        DIRLOG_KCC_ERROR_CREATING_CONNECTION_OBJECT,
                        szInsertDN(pdsa->GetDsName()),
                        szInsertDN(pdnLocalDSA),
                        0
                        );
                } else {
                    pConnectionList->AddToList(pcnNew);
                    
                    DPRINT3(3,
                            "KCC: created first available connection object, localdsa:%ws, sourcedsa:%ws, nc:%ws\n",
                            pdnLocalDSA->StringName,
                            pdsa->GetDsName()->StringName,
                            pNC->StringName);

                    LogEvent(
                        DS_EVENT_CAT_KCC,
                        DS_EVENT_SEV_ALWAYS,
                        DIRLOG_KCC_CONNECTION_OBJECT_CREATED,
                        szInsertDN(pdsa->GetDsName()),
                        szInsertDN(pdnLocalDSA),
                        0
                        );

                    fSuccess = TRUE;
                }
    
                //
                // Don't use this source server again
                //
                dnFromServers.Add( pdsa->GetDsName() );
            }
        }
    }

    return fSuccess;
}


BOOL
KccIsTimeToRefreshTopology(
    IN KCC_DSA_LIST& dsaList
    )
//
// Every 9 to 11 new servers, refresh the optimizing topology
//
{
    #define KCC_SERVER_REFRESH_DELTA (((rand() % 3) + 10))

    if ( gfLastServerCountSet && gLastServerCount > 7 )
    {
        if ( dsaList.GetCount() > gLastServerCount + KCC_SERVER_REFRESH_DELTA )
        {
            gLastServerCount = dsaList.GetCount();
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kccsitelink.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccsitelink.cxx

ABSTRACT:

    KCC_SITE_LINK class.

DETAILS:

    This class represents the DS notion of site links.

CREATED:

    03/12/97    Jeff Parham (jeffparh)

REVISION HISTORY:

    06/21/00    Will Lees (wlees)

--*/

#include <ntdspchx.h>
#include "kcc.hxx"
#include "kccdynar.hxx"
#include "kccsite.hxx"
#include "kccsitelink.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include "kccdsa.hxx"
#include "kcctrans.hxx"
#include "kccconn.hxx"
#include "kccsconn.hxx"
#include "dsconfig.h"
#include "dsutil.h"

#define FILENO FILENO_KCC_KCCSITELINK


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_SITE methods
//

void
KCC_SITE_LINK::Reset()
//
// Set member variables to their pre-Init() state.
//
{
    m_fIsInitialized        = FALSE;
    m_pdnSiteLinkObject     = NULL;
    m_dwOptions             = 0;
    m_dwCost                = 0;
    m_dwReplInterval        = 0;
    m_hSchedule             = NULL;
    m_pEdge                 = NULL;
    m_SiteArray.RemoveAll();
}

BOOL
KCC_SITE_LINK::Init(
    IN  ENTINF *    pEntInf
    )
// Init the object given its ds properties
// Note, do not store any pointers to the memory in the pEntInf.
// It will be deallocated shortly.
{

    DWORD   iAttr, cAttr, iAttrVal;
    ATTR *  pAttr;
    DWORD   cbVal;
    BYTE *  pbVal;
    TOPL_SCHEDULE_CACHE scheduleCache;

    Reset();

    m_pdnSiteLinkObject = (DSNAME *) new BYTE [pEntInf->pName->structLen];
    memcpy( m_pdnSiteLinkObject, pEntInf->pName, pEntInf->pName->structLen );

    for ( iAttr = 0, cAttr = pEntInf->AttrBlock.attrCount; 
            iAttr < cAttr; 
                iAttr++ )
    {
        pAttr = &pEntInf->AttrBlock.pAttr[ iAttr ];
        cbVal = pAttr->AttrVal.pAVal->valLen;
        pbVal = pAttr->AttrVal.pAVal->pVal;

        Assert( pAttr->attrTyp == ATT_SITE_LIST || 1 == pAttr->AttrVal.valCount ); // all should be single-valued
        Assert( pbVal );

        switch ( pAttr->attrTyp )
        {
        case ATT_SITE_LIST:
            for ( iAttrVal = 0; iAttrVal < pAttr->AttrVal.valCount; iAttrVal++ )
            {
                DSNAME *pdnSite = (DSNAME *) pAttr->AttrVal.pAVal[ iAttrVal ].pVal;
                KCC_SITE *pSite = gpDSCache->GetSiteList()->GetSite( pdnSite );
                if (pSite) {
                    m_SiteArray.Add( pSite );
                } else {
                    DPRINT2(0, "Site link %ls references site %ls, but not found in site list.\n",
                            m_pdnSiteLinkObject->StringName,
                            pdnSite->StringName );
                    LogEvent(DS_EVENT_CAT_KCC,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_KCC_SITE_LINK_SITE_NOT_IN_SITE_LIST,
                             szInsertDN(m_pdnSiteLinkObject),
                             szInsertDN(pdnSite),
                             0); 
                    // keep going
                }
            }
            // This does not need to be sorted
            break;

        case ATT_SCHEDULE:
            scheduleCache = gpDSCache->GetScheduleCache();
            Assert( scheduleCache );
            __try {
                m_hSchedule = ToplScheduleImport( scheduleCache,
                                                (SCHEDULE *) pbVal );
                // Site links with unavailable schedules are assumed to have
                // fully available schedules. (Somewhat strange, but that's
                // the current behaviour).
                if( ToplScheduleDuration(m_hSchedule)==0 ) {
                    m_hSchedule = ToplGetAlwaysSchedule( scheduleCache );
                }
            } __except( EXCEPTION_EXECUTE_HANDLER ) {
                // Bad schedule.
                DPRINT1(0, "Invalid schedule on %ls!\n",
                        m_pdnSiteLinkObject->StringName);
                LogEvent(DS_EVENT_CAT_KCC,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_CHK_BAD_SCHEDULE,
                         szInsertDN(m_pdnSiteLinkObject),
                         0,
                         0);
                m_hSchedule = ToplGetAlwaysSchedule( scheduleCache );
            }
            break;

        case ATT_OPTIONS:
            Assert( cbVal == sizeof(DWORD) );
            m_dwOptions = *((DWORD *) pbVal);
            break;

        case ATT_COST:
            Assert( cbVal == sizeof(DWORD) );
            m_dwCost = *((DWORD *) pbVal);
            break;

        case ATT_REPL_INTERVAL:
            Assert( cbVal == sizeof(DWORD) );
            m_dwReplInterval = *((DWORD *) pbVal);
            break;

        default:
            DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pAttr->attrTyp );
            break;
        }
    }

    if (m_SiteArray.GetCount() >= 2) {
        m_fIsInitialized = TRUE;
    } else if( gpDSCache->GetSiteList()->GetCount()>1 ) {
    	// This site link contains only 1 site (or less), but there are
    	// 2 or more sites in the forest. Give a warning.
        DPRINT1(0, "Site link %ls does not have enough sites.\n",
                m_pdnSiteLinkObject->StringName );
        LogEvent(DS_EVENT_CAT_KCC,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_KCC_SITE_LINK_TOO_SMALL,
                 szInsertDN(m_pdnSiteLinkObject),
                 0,
                 0); 

        delete [] m_pdnSiteLinkObject;
        m_pdnSiteLinkObject = NULL;
    }
       
    return m_fIsInitialized;
}

BOOL
KCC_SITE_LINK::InitForKey(
    IN  DSNAME   *    pdnSiteLink
    )
//
// Init a KCC_SITE_LINK object for use as a key (i.e., solely for comparison use
// by bsearch()).
//
// WARNING: The DSNAME argument pdnSite must be valid for the lifetime of this
// object!
//
{
    Reset();

    m_pdnSiteLinkObject = pdnSiteLink;

    m_fIsInitialized = TRUE;

    return TRUE;
}


BOOL
KCC_SITE_LINK::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

PDSNAME
KCC_SITE_LINK::GetObjectDN()
{
    ASSERT_VALID( this );

    return m_pdnSiteLinkObject;
}


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_SITE_LINK_LIST methods
//

BOOL
KCC_SITE_LINK_LIST::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

BOOL
KCC_SITE_LINK_LIST::Init(
    IN KCC_TRANSPORT *pTransport
    )
{

    ATTR      rgAttrs[] =
    {
        { ATT_SITE_LIST, { 0, NULL } },
        { ATT_COST, { 0, NULL } },
        { ATT_OPTIONS, { 0, NULL } },
        { ATT_REPL_INTERVAL, { 0, NULL } },
        { ATT_SCHEDULE, { 0, NULL } }
    };

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    // Find all the site objects.
    DSNAME * pdnSiteLinkCat = DsGetDefaultObjCategory(CLASS_SITE_LINK);

    ULONG               dirError;
    FILTER              filtObjCat;
    SEARCHRES *         pResults;
    ENTINFLIST *        pEntInfList;

    // Clear the member variables
    Reset();

    Assert(NULL != pdnSiteLinkCat);

    // Set up the search filter
    memset( &filtObjCat, 0, sizeof( filtObjCat ) );
    filtObjCat.choice                  = FILTER_CHOICE_ITEM;
    filtObjCat.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    filtObjCat.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CATEGORY;
    filtObjCat.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnSiteLinkCat->structLen;
    filtObjCat.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) pdnSiteLinkCat;

    dirError = KccSearch(
        pTransport->GetDN(),
        SE_CHOICE_IMMED_CHLDRN,
        &filtObjCat,
        &Sel,
        &pResults
        );

    if ( 0 != dirError )
    {
        KCC_LOG_SEARCH_FAILURE( pTransport->GetDN(), dirError );

        return FALSE;
    }
    else
    {
        if ( 0 == pResults->count )
        {
           DPRINT1( 1, "No site link objects found for transport %ls.\n",
               pTransport->GetDN()->StringName );
        }
        else
        {
            for ( pEntInfList = &pResults->FirstEntInf;
                  NULL != pEntInfList;
                  pEntInfList = pEntInfList->pNextEntInf
                )
            {
                KCC_SITE_LINK * pSiteLink = new KCC_SITE_LINK;

                if ( pSiteLink->Init( &pEntInfList->Entinf ) )
                {
                    m_SiteLinkArray.Add( pSiteLink );
                } else {
                    delete pSiteLink;
                    // Error already logged
                    // Keep going
                }
            }
        }

        DirFreeSearchRes( pResults );

        // Sort the array
        m_SiteLinkArray.Sort();

        m_fIsInitialized = TRUE;
    }

    return m_fIsInitialized;
}

ULONG
KCC_SITE_LINK_LIST::GetCount()
//
// Get the number of site.
//
{
    return m_SiteLinkArray.GetCount();
}

KCC_SITE_LINK *
KCC_SITE_LINK_LIST::GetSiteLink(
        IN  DWORD   iSite
        )
//
// Get the site requested
//
{
    ASSERT_VALID( this );

    return m_SiteLinkArray[iSite];
}

KCC_SITE_LINK *
KCC_SITE_LINK_LIST::GetSiteLink(
    IN  DSNAME *  pdnSite
    )
//
// Retrieve the KCC_SITE object with the given DSNAME.
//
{
    ASSERT_VALID(this);

    return m_SiteLinkArray.Find( pdnSite );
}

void
KCC_SITE_LINK_LIST::Reset()
//
// Set member variables to their pre-Init() state.
//
{
    m_fIsInitialized = FALSE;
    m_SiteLinkArray.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kccmain.cxx ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccmain.cxx

ABSTRACT:

    The KCC serves as an automated administrator.  It performs directory
    management tasks both periodically and based upon notifications.

    It is designed to live in-process with NTDSA.DLL (i.e., inside
    the LSA process).

DETAILS:

    All KCC tasks are performed indirectly by the task queue, and thus are
    processed one at a time.  Periodic tasks are registered at KCC
    initialization and reschedule themselves when they complete.
    Notifications similarly cause tasks to be added to the task queue
    (which do not automatically reschedule themselves).

CREATED:

    01/13/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpchx.h>
#pragma  hdrstop

#include <limits.h>
#include <dsconfig.h>

#include "kcc.hxx"
#include "kcctask.hxx"
#include "kccconn.hxx"
#include "kcctopl.hxx"
#include "kccsite.hxx"
#include "kccstale.hxx"
#include "kcctools.hxx"

#define  FILENO FILENO_KCC_KCCMAIN



#define MAX_WAIT_THREAD_STOP    ( 3000 ) /* in msec */


//
// Stuff needed by DSCOMMON.LIB
//

BOOL  gfRunningInsideLsa = TRUE;
DWORD ImpersonateAnyClient(   void ) { return ERROR_CANNOT_IMPERSONATE; }
VOID  UnImpersonateAnyClient( void ) { ; }


//
// KCC global variables
//

KCC_STATE   geKccState                  = KCC_STOPPED;
HANDLE      ghKccShutdownEvent          = NULL;
BOOL        gfRunningUnderAltID         = FALSE;
WCHAR *     gpszRootDomainDnsName       = NULL;
UUID        guuidNull                   = { 0 };


// Time after boot of first replication topology update and the interval between
// subsequent executions of this task.
#define KCC_DEFAULT_UPDATE_TOPL_DELAY   (5 * MINS_IN_SECS)          // Seconds.
#define KCC_MIN_UPDATE_TOPL_DELAY       (20)                        // Seconds.
#define KCC_MAX_UPDATE_TOPL_DELAY       (ULONG_MAX)                 // Seconds.

#define KCC_DEFAULT_UPDATE_TOPL_PERIOD  (15 * MINS_IN_SECS)         // Seconds.
#define KCC_MIN_UPDATE_TOPL_PERIOD      (20)                        // Seconds.
#define KCC_MAX_UPDATE_TOPL_PERIOD      (ULONG_MAX)                 // Seconds.

DWORD gcSecsUntilFirstTopologyUpdate  = 0;
DWORD gcSecsBetweenTopologyUpdates    = 0;


// These global values are the thresholds by which servers necessary for the
// ring topology and servers needed for gc topology are measured against when
// determing if they are valid source servers.
#define KCC_DEFAULT_CRIT_FAILOVER_TRIES     (0)
#define KCC_MIN_CRIT_FAILOVER_TRIES         (0)
#define KCC_MAX_CRIT_FAILOVER_TRIES         (ULONG_MAX)

#define KCC_DEFAULT_CRIT_FAILOVER_TIME      (2 * HOURS_IN_SECS)     // Seconds.
#define KCC_MIN_CRIT_FAILOVER_TIME          (0)                     // Seconds.
#define KCC_MAX_CRIT_FAILOVER_TIME          (ULONG_MAX)             // Seconds.

#define KCC_DEFAULT_NONCRIT_FAILOVER_TRIES  (1)
#define KCC_MIN_NONCRIT_FAILOVER_TRIES      (0)
#define KCC_MAX_NONCRIT_FAILOVER_TRIES      (ULONG_MAX)

#define KCC_DEFAULT_NONCRIT_FAILOVER_TIME   (12 * HOURS_IN_SECS)    // Seconds.
#define KCC_MIN_NONCRIT_FAILOVER_TIME       (0)                     // Seconds.
#define KCC_MAX_NONCRIT_FAILOVER_TIME       (ULONG_MAX)             // Seconds.

#define KCC_DEFAULT_INTERSITE_FAILOVER_TRIES  (1)
#define KCC_MIN_INTERSITE_FAILOVER_TRIES      (0)
#define KCC_MAX_INTERSITE_FAILOVER_TRIES      (ULONG_MAX)

#define KCC_DEFAULT_INTERSITE_FAILOVER_TIME   (2 * HOURS_IN_SECS)   // Seconds.
#define KCC_MIN_INTERSITE_FAILOVER_TIME       (0)                   // Seconds.
#define KCC_MAX_INTERSITE_FAILOVER_TIME       (ULONG_MAX)           // Seconds.

#define KCC_DEFAULT_CONNECTION_PROBATION_TIME (8 * HOURS_IN_SECS)   // Seconds.
#define KCC_MIN_CONNECTION_PROBATION_TIME     (0)                   // Seconds.
#define KCC_MAX_CONNECTION_PROBATION_TIME     (ULONG_MAX)           // Seconds.

DWORD gcCriticalLinkFailuresAllowed     = 0;
DWORD gcSecsUntilCriticalLinkFailure    = 0;
DWORD gcNonCriticalLinkFailuresAllowed  = 0;
DWORD gcSecsUntilNonCriticalLinkFailure = 0;
DWORD gcIntersiteLinkFailuresAllowed    = 0;
DWORD gcSecsUntilIntersiteLinkFailure   = 0;
DWORD gcConnectionProbationSecs         = 0;


// Do we allow asynchronous replication (e.g., over SMTP) of writeable domain
// NC info?  We currently inhibit this, ostensibly to reduce our test matrix.

#define KCC_DEFAULT_ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN    (FALSE)
#define KCC_MIN_ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN        (0)
#define KCC_MAX_ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN        (ULONG_MAX)

BOOL gfAllowMbrBetweenDCsOfSameDomain = FALSE;


// What priority does the topology generation thread run at? The thread priorities
// are values in the range (-2,..,2), but the registry can only store DWORDs, so
// we bias the stored priority values with KCC_THREAD_PRIORITY_BIAS.
#define KCC_DEFAULT_THREAD_PRIORITY 2
#define KCC_MIN_THREAD_PRIORITY     0
#define KCC_MAX_THREAD_PRIORITY     4

DWORD gdwKccThreadPriority;


// Registry key and event to track changes to our registry parameters.
HKEY    ghkParameters = NULL;
HANDLE  ghevParametersChange = NULL;
        

// Default Intra-site schedule.  This determines the polling interval that
// destinations use to ask for changes from their sources.
// Since notifications are the perferred mechanism to disseminating changes,
// make the interval relatively infrequent.
//
// Note:- If you change this, please make sure to change the
//        g_defaultSchedDBData[] defined in dsamain\boot\addobj.cxx
//        which defines the intrasite schedule in global NT schedule format.

const DWORD rgdwDefaultIntrasiteSchedule[] = {
    sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES,       // Size (in bytes)
    0,                                              // Bandwidth
    1,                                              // NumberOfSchedules
    SCHEDULE_INTERVAL,                              // Schedules[0].Type
    sizeof(SCHEDULE),                               // Schedules[0].Offset
    0x01010101, 0x01010101, 0x01010101, 0x01010101, // Schedule 0 data
    0x01010101, 0x01010101, 0x01010101, 0x01010101, //   (once an hour)
    0x01010101, 0x01010101, 0x01010101, 0x01010101, // 4 DWORDs * 4 bytes/DWORD
    0x01010101, 0x01010101, 0x01010101, 0x01010101, //   * 10.5 rows
                                                    //   = 168 bytes
    0x01010101, 0x01010101, 0x01010101, 0x01010101, //   = SCHEDULE_DATA_ENTRIES
    0x01010101, 0x01010101, 0x01010101, 0x01010101,
    0x01010101, 0x01010101, 0x01010101, 0x01010101,
    0x01010101, 0x01010101, 0x01010101, 0x01010101,
    
    0x01010101, 0x01010101, 0x01010101, 0x01010101,
    0x01010101, 0x01010101, 0x01010101, 0x01010101,
    0x01010101, 0x01010101
};
const SCHEDULE * gpDefaultIntrasiteSchedule = (SCHEDULE *) rgdwDefaultIntrasiteSchedule;

// The intrasite schedule object is first created when we read the local
// NTDS Site Settings object, which always precedes its use. 
TOPL_SCHEDULE gpIntrasiteSchedule = NULL;
BOOLEAN       gfIntrasiteSchedInited = FALSE;


KCC_TASK_UPDATE_REPL_TOPOLOGY   gtaskUpdateReplTopology;
KCC_CONNECTION_FAILURE_CACHE    gConnectionFailureCache;
KCC_LINK_FAILURE_CACHE          gLinkFailureCache;
KCC_DS_CACHE *                  gpDSCache = NULL;

//
// For efficiency sake, don't start refreshing until we have at least
// 8 seven servers, since we trypically won't have any optimizing edges
// to refresh.
//
BOOL  gfLastServerCountSet = FALSE;
ULONG gLastServerCount = 0;

#ifdef ANALYZE_STATE_SERVER
BOOL                            gfDumpStaleServerCaches = FALSE;
BOOL                            gfDumpConnectionReason  = FALSE;
#endif

// Event logging config (as exported from ntdsa.dll).
DS_EVENT_CONFIG * gpDsEventConfig = NULL;

void KccLoadParameters();


NTSTATUS
KccInitialize()
{
    NTSTATUS      ntStatus = STATUS_SUCCESS;
    UINT          uThreadID;
    LPSTR         rgpszDebugParams[] = {"lsass.exe", "-noconsole"};
    DWORD         cNumDebugParams = sizeof(rgpszDebugParams)/sizeof(rgpszDebugParams[0]);
    SPAREFN_INFO  rgSpareInfo[1];
    DWORD         cSpares = sizeof(rgSpareInfo) / sizeof(rgSpareInfo[0]);
    DWORD         winError;

    if ( KCC_STOPPED != geKccState )
    {
        Assert( !"Attempt to reinitialize KCC while it's running!" );
        ntStatus = STATUS_INTERNAL_ERROR;
    }
    else
    {
        // initialize KCC state
        ghKccShutdownEvent = NULL;

        // Initialize logging (as exported from ntdsa.dll).
        gpDsEventConfig = DsGetEventConfig();

        // Open parameters reg key.
        winError = RegOpenKey(HKEY_LOCAL_MACHINE,
                              DSA_CONFIG_SECTION,
                              &ghkParameters);
        if (0 != winError) {
            LogUnhandledError(winError);
        }
            
        // Create an event to signal changes in the parameters reg key.
        ghevParametersChange = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (NULL == ghevParametersChange) {
            winError = GetLastError();
            LogUnhandledError(winError);
        }
        
        // Watch for changes in the parameters reg key.
        rgSpareInfo[0].hevSpare = ghevParametersChange;
        rgSpareInfo[0].pfSpare  = KccLoadParameters;

        // Get our current config parameters from the registry.
        KccLoadParameters();

        ghKccShutdownEvent = CreateEvent(
                                NULL,   // no security descriptor
                                TRUE,   // is manual-reset
                                FALSE,  // !is initially signalled
                                NULL    // no name
                                );

        if ( NULL == ghKccShutdownEvent )
        {
            ntStatus = GetLastError();
            LogUnhandledErrorAnonymous( ntStatus );
        }
        else
        {
            // Initialize debug library.
            DEBUGINIT(cNumDebugParams, rgpszDebugParams, "kcc" );
#if 0
            DebugInfo.severity = 3;
            strcpy( DebugInfo.DebSubSystems, "KCC:" ); 
#endif
            
            if (!InitTaskScheduler(cSpares, rgSpareInfo)) {
                ntStatus = STATUS_NO_MEMORY;

                LogUnhandledErrorAnonymous( ntStatus );
            }
            else
            {
                // initialize global ConnectionFailureCache
                if ( !gConnectionFailureCache.Init() ) {
                    // don't bail out
                    DPRINT( 0, "gConnectionFailureCache.Init failed\n" );
                }
                
                // initialize global ConnectionFailureCache
                if ( !gLinkFailureCache.Init() ) {
                    // don't bail out
                    DPRINT( 0, "gLinkFailureCache.Init failed\n" );
                }
                    
                // register periodic tasks
                if ( !gtaskUpdateReplTopology.Init() ) {
                    ntStatus = STATUS_NO_MEMORY;
                    LogUnhandledErrorAnonymous( ntStatus );
                }
            }
        }

        if ( NT_SUCCESS( ntStatus ) )
        {
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_EXTENSIVE,
                DIRLOG_CHK_INIT_SUCCESS,
                0,
                0,
                0
                );

            geKccState = KCC_STARTED;
        }
        else
        {
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_CHK_INIT_FAILURE,
                szInsertHex( ntStatus ),
                0,
                0
                );

            // initialization failed; shut down
            Assert( !"KCC could not be initialized!" );
            KccUnInitializeTrigger( );
            KccUnInitializeWait( INFINITE );
        }
    }

    return ntStatus;
}


void
KccUnInitializeTrigger( )
{
    if (NULL != ghKccShutdownEvent)
    {
        // KCC was started -- trigger shutdown.
        geKccState = KCC_STOPPING;
        
        // signal logging change monitor to shut down
        SetEvent( ghKccShutdownEvent );
        ShutdownTaskSchedulerTrigger( );
    }
    else
    {
        // KCC was never started.  Don't log events, as eventing (specifically
        // ntdskcc!gpDsEventConfig) has not been initialized.
        Assert(KCC_STOPPED == geKccState);
    }
}


NTSTATUS
KccUnInitializeWait(
    DWORD   dwMaxWaitInMsec
    )
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    DWORD       waitStatus;

    if (NULL != ghKccShutdownEvent)
    {
        // KCC was started -- wait for shutdown, if it hasn't completed yet.
        if (KCC_STOPPED != geKccState)
        {
    
            if ( !ShutdownTaskSchedulerWait( dwMaxWaitInMsec ) )
            {
                ntStatus = STATUS_UNSUCCESSFUL;
            }
            else
            {
                CloseHandle( ghKccShutdownEvent );
    
                ghKccShutdownEvent = NULL;
                geKccState         = KCC_STOPPED;
            }
        }
    
        if ( NT_SUCCESS( ntStatus ) )
        {
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_EXTENSIVE,
                DIRLOG_CHK_STOP_SUCCESS,
                0,
                0,
                0
                );
        }
        else
        {
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_CHK_STOP_FAILURE,
                szInsertHex( ntStatus ),
                0,
                0
                );
    
            Assert( !"KCC could not be stopped!" );
        }
    }
    else
    {
        // KCC was never started.  Don't log events, as eventing (specifically
        // ntdskcc!gpDsEventConfig) has not been initialized.
        Assert(KCC_STOPPED == geKccState);
    }

    DEBUGTERM();

    return ntStatus;
}


void
KccLoadParameters()
/*++

Routine Description:

    Refreshes intenal globals derived from our registry config.

Arguments:

    None.

Return Values:

    None.

--*/
{
    const struct {
        LPSTR   pszValueName;
        DWORD   dwDefaultValue;
        DWORD   dwMinValue;
        DWORD   dwMaxValue;
        DWORD   dwMultiplier;
        DWORD * pdwMultipliedValue;
    } rgValues[] =  {   { KCC_UPDATE_TOPL_DELAY,
                          KCC_DEFAULT_UPDATE_TOPL_DELAY,
                          KCC_MIN_UPDATE_TOPL_DELAY,
                          KCC_MAX_UPDATE_TOPL_DELAY,
                          SECS_IN_SECS,
                          &gcSecsUntilFirstTopologyUpdate },
                        
                        { KCC_UPDATE_TOPL_PERIOD,
                          KCC_DEFAULT_UPDATE_TOPL_PERIOD,
                          KCC_MIN_UPDATE_TOPL_PERIOD,
                          KCC_MAX_UPDATE_TOPL_PERIOD,
                          SECS_IN_SECS,
                          &gcSecsBetweenTopologyUpdates },
                        
                        { KCC_CRIT_FAILOVER_TRIES,
                          KCC_DEFAULT_CRIT_FAILOVER_TRIES,
                          KCC_MIN_CRIT_FAILOVER_TRIES,
                          KCC_MAX_CRIT_FAILOVER_TRIES,
                          1,
                          &gcCriticalLinkFailuresAllowed },

                        { KCC_CRIT_FAILOVER_TIME,
                          KCC_DEFAULT_CRIT_FAILOVER_TIME,
                          KCC_MIN_CRIT_FAILOVER_TIME,
                          KCC_MAX_CRIT_FAILOVER_TIME,
                          SECS_IN_SECS,
                          &gcSecsUntilCriticalLinkFailure },

                        { KCC_NONCRIT_FAILOVER_TRIES,
                          KCC_DEFAULT_NONCRIT_FAILOVER_TRIES,
                          KCC_MIN_NONCRIT_FAILOVER_TRIES,
                          KCC_MAX_NONCRIT_FAILOVER_TRIES,
                          1,
                          &gcNonCriticalLinkFailuresAllowed },

                        { KCC_NONCRIT_FAILOVER_TIME,
                          KCC_DEFAULT_NONCRIT_FAILOVER_TIME,
                          KCC_MIN_NONCRIT_FAILOVER_TIME,
                          KCC_MAX_NONCRIT_FAILOVER_TIME,
                          SECS_IN_SECS,
                          &gcSecsUntilNonCriticalLinkFailure },

                        { KCC_INTERSITE_FAILOVER_TRIES,
                          KCC_DEFAULT_INTERSITE_FAILOVER_TRIES,
                          KCC_MIN_INTERSITE_FAILOVER_TRIES,
                          KCC_MAX_INTERSITE_FAILOVER_TRIES,
                          1,
                          &gcIntersiteLinkFailuresAllowed },

                        { KCC_INTERSITE_FAILOVER_TIME,
                          KCC_DEFAULT_INTERSITE_FAILOVER_TIME,
                          KCC_MIN_INTERSITE_FAILOVER_TIME,
                          KCC_MAX_INTERSITE_FAILOVER_TIME,
                          SECS_IN_SECS,
                          &gcSecsUntilIntersiteLinkFailure },

#ifdef ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN_IF_REGKEY_SET
                        { KCC_ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN,
                          KCC_DEFAULT_ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN,
                          KCC_MIN_ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN,
                          KCC_MAX_ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN,
                          1,
                          (DWORD *) &gfAllowMbrBetweenDCsOfSameDomain },
#endif

                        { KCC_THREAD_PRIORITY,
                          KCC_DEFAULT_THREAD_PRIORITY,
                          KCC_MIN_THREAD_PRIORITY,
                          KCC_MAX_THREAD_PRIORITY,
                          1,
                          &gdwKccThreadPriority },
                          
                        { KCC_CONNECTION_PROBATION_TIME,
                          KCC_DEFAULT_CONNECTION_PROBATION_TIME,
                          KCC_MIN_CONNECTION_PROBATION_TIME,
                          KCC_MAX_CONNECTION_PROBATION_TIME,
                          SECS_IN_SECS,
                          &gcConnectionProbationSecs },

                    };
    const DWORD cValues = sizeof(rgValues) / sizeof(rgValues[0]);

    DWORD dwValue;
    DWORD err;
    
    Assert(NULL != ghkParameters);
    Assert(NULL != ghevParametersChange);

    err = RegNotifyChangeKeyValue(ghkParameters,
                                  TRUE,
                                  REG_NOTIFY_CHANGE_LAST_SET,
                                  ghevParametersChange,
                                  TRUE);
    Assert(0 == err);
    
    for (DWORD i = 0; i < cValues; i++) {
        if (GetConfigParam(rgValues[i].pszValueName, &dwValue, sizeof(dwValue))) {
            dwValue = rgValues[i].dwDefaultValue;
            Assert(dwValue >= rgValues[i].dwMinValue);
            Assert(dwValue <= rgValues[i].dwMaxValue);
        }
        else if (dwValue < rgValues[i].dwMinValue) {
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CHK_CONFIG_PARAM_TOO_LOW,
                     szInsertWC(rgValues[i].pszValueName),
                     szInsertUL(dwValue),
                     szInsertUL(rgValues[i].dwMinValue));
            dwValue = rgValues[i].dwMinValue;
        }
        else if (dwValue > rgValues[i].dwMaxValue) {
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CHK_CONFIG_PARAM_TOO_HIGH,
                     szInsertWC(rgValues[i].pszValueName),
                     szInsertUL(dwValue),
                     szInsertUL(rgValues[i].dwMaxValue));
            dwValue = rgValues[i].dwMaxValue;
        }
        
        *(rgValues[i].pdwMultipliedValue) = dwValue * rgValues[i].dwMultiplier;
    }
}


DWORD
KccExecuteTask(
    IN  DWORD                   dwInVersion,
    IN  DRS_MSG_KCC_EXECUTE *   pMsgIn
    )
{
    DWORD dwFlags;

    if ((1 != dwInVersion)
        || (DS_KCC_TASKID_UPDATE_TOPOLOGY != pMsgIn->V1.dwTaskID)) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( !gfIsTqRunning ) {
        return ERROR_DS_NOT_INSTALLED;
    }

    dwFlags = pMsgIn->V1.dwFlags & DS_KCC_FLAG_ASYNC_OP;
    
    return gtaskUpdateReplTopology.Trigger(dwFlags);
}


DWORD
KccGetFailureCache(
    IN  DWORD                         InfoType,
    OUT DS_REPL_KCC_DSA_FAILURESW **  ppFailures
    )
/*++

Routine Description:

    Returns the contents of the connection or link failure cache.

Arguments:

    InfoType (IN) - Identifies the cache to return -- either
        DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES or
        DS_REPL_INFO_KCC_DSA_LINK_FAILURES.
    
    ppFailures (OUT) - On successful return, holds the contents of the cache.
    
Return Values:

    Win32 error code.

--*/
{
    DWORD                   winError;
    KCC_CACHE_LINKED_LIST * pFailureCache;

    if (DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES == InfoType) {
        winError = gConnectionFailureCache.Extract(ppFailures);
    }
    else if (DS_REPL_INFO_KCC_DSA_LINK_FAILURES == InfoType) {
        winError = gLinkFailureCache.Extract(ppFailures);
    }
    else {
        winError = ERROR_INVALID_PARAMETER;
    }
    
    return winError;
}


void *
__cdecl
operator new(
    size_t  cb
    )
{
    void * pv;

    pv = THAlloc( cb );
    if ( NULL == pv )
    {
        DPRINT1( 0, "Failed to allocate %d bytes\n", cb );
        KCC_MEM_EXCEPT( cb );
    }

    return pv;
}


void
__cdecl
operator delete(
    void *   pv
    )
{
    THFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kccstetl.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccstetl.cxx

ABSTRACT:

    Routines to perform the automated NC topology across sites

DETAILS:

CREATED:

    12/05/97    Colin Brace (ColinBr)

REVISION HISTORY:

--*/

#include <NTDSpchx.h>
#include "w32topl.h"
#include "kcc.hxx"
#include "kcctask.hxx"
#include "kccconn.hxx"
#include "kcctopl.hxx"
#include "kcccref.hxx"
#include "kccdsa.hxx"
#include "kcctools.hxx"
#include "kcctrans.hxx"
#include "kccsconn.hxx"
#include "kccdynar.hxx"
#include "kccsite.hxx"
#include "kccduapi.hxx"
#include "ismapi.h"
#include "kccsitelink.hxx"
#include "kccwalg.hxx"
#include "kccstale.hxx"

#include "kccstetl.hxx"

#define FILENO FILENO_KCC_KCCSTETL

#define DWORD_INFINITY ((DWORD)~0)


//
// Prototypes of local functions
//
BOOL
KccAmISiteGenerator(
    VOID
    );

VOID
KccCreateInterSiteConnectionsForNc(
    IN  KCC_CROSSREF *          pCrossRef,
    IN  KCC_SITE *              pLocalSite,
    IN  BOOL                    fGCTopology,
    IN  KCC_SITE_ARRAY &        SiteArray,
    IN  KCC_TRANSPORT_LIST &    TransportList
    );

VOID
KccGetSiteConnections(
    IN  KCC_CROSSREF *          pCrossRef,
    IN  KCC_TRANSPORT_LIST *    pTransportList,
    IN  KCC_SITE_ARRAY &        SiteArray,
    IN  DSNAME *                pDNLocalSite,
    IN  BOOL                    fGCTopology
    );

VOID
KccCreateConnectionToSite(
    IN  KCC_CROSSREF *          pCrossRef,
    IN  KCC_SITE *              pLocalSite,
    IN  KCC_SITE_CONNECTION *   pSiteConnection,   
    IN  BOOL                    fGCTopology,    
    IN  KCC_TRANSPORT_LIST &    TransportList
    );

VOID
KccRemoveUnneededInterSiteConnections();


//
// Function definitions
//
VOID
KccConstructSiteTopologiesForEnterprise()
/*++

Routine Description:

    This routine will construct a minimum cost spanning tree across sites for
    naming context in the enterprise
    
Parameters:

    None.    

Returns:

    None; all errors interesting to the admin are logged.
    
--*/
{
    KCC_SITE_LIST *     pSiteList = gpDSCache->GetSiteList();
    KCC_SITE *          pLocalSite = gpDSCache->GetLocalSite();
    KCC_CROSSREF_LIST * pCrossRefList = gpDSCache->GetCrossRefList();
    KCC_TRANSPORT_LIST *pTransportList = gpDSCache->GetTransportList();
    KCC_DSA *           pLocalDSA = gpDSCache->GetLocalDSA();
    KCC_DSA_LIST *      pLocalSiteDSAList = pLocalSite->GetDsaList();
    
    ULONG               icr, ccr, isite, idsa;

    //
    //  Now perform site wide operation of creating inter site connection
    //  objects
    //
    if ( !KccAmISiteGenerator() ) {
        DPRINT( 3, "Local dsa is not the site connection generator.\n" );
        return;
    }
    
    DPRINT( 3, "Local dsa is the site connection generator.\n" );
    // Supportability logging event 1
    LogEvent(
        DS_EVENT_CAT_KCC,
        DS_EVENT_SEV_EXTENSIVE,
        DIRLOG_KCC_SITE_GENERATOR,
        szInsertDN(pLocalSite->GetObjectDN()),
        0,
        0
        ); 

    gpDSCache->GetLocalSite()->CheckIntrasiteSchedule();
    
    if (pSiteList->GetCount() < 2) {
        // A single-site enterprise.  No need to run intersite topology
        // generation.
        Assert(1 == pSiteList->GetCount());
        return;
    }

    //
    // Sort the list of cross-ref objects and look for orphaned NCs.
    //
    pCrossRefList->Sort();
    ccr = pCrossRefList->GetCount();
    for( icr=0; icr<ccr; icr++ ) {
        pCrossRefList->GetCrossRef(icr)->CheckForOrphans();
    }

    //
    // Get all intersite connections in the site (hopefully small)
    //
    pLocalSite->PopulateInterSiteConnectionLists();

    //
    // Update staleness info from the bridgeheads in our site.
    // Use mark-sweep garbage collection to flush out any
    // unneeded imported entries.
    //
    gConnectionFailureCache.MarkUnneeded( TRUE );
    for (idsa = 0; idsa < pLocalSiteDSAList->GetCount(); idsa++) {
        pLocalSiteDSAList->GetDsa(idsa)->GetInterSiteCnList()
            ->UpdateStaleServerCache();
    }
    gConnectionFailureCache.FlushUnneeded( TRUE );
    

    if( gpDSCache->GetForestVersion() >= DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS ) {
        
        KccGenerateTopologiesWhistler();

    } else {

        //
        // For each NC that is shared between two or more sites, create inter site 
        // connections between sites with that NC
        //
        for ( icr = 0; icr < ccr; icr++ )
        {
            KCC_CROSSREF *    pCrossRef = pCrossRefList->GetCrossRef(icr);
            KCC_SITE_ARRAY *  pSiteArrayWriteable = pCrossRef->GetWriteableSites();
            KCC_SITE_ARRAY *  pSiteArrayPartial = pCrossRef->GetPartialSites();
            
            if( icr==ccr-2 ) {
                // Schema should always be the penultimate crossref.
                // We skip it, because it has the same requirements as Config.
                Assert( KCC_NC_TYPE_SCHEMA==pCrossRef->GetNCType() );
                continue;
            }
            if( icr==ccr-1 ) {
                // Config should always be the last crossref.
                Assert( KCC_NC_TYPE_CONFIG==pCrossRef->GetNCType() );
            }
            
            DPRINT3( 3, "Naming Context %ls is in %d writable sites, %d partial sites\n", 
                     pCrossRef->GetNCDN()->StringName,
                     pSiteArrayWriteable->GetCount(),
                     pSiteArrayPartial->GetCount() );   
            // Supportability logging event 2
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_EXTENSIVE,
                DIRLOG_KCC_NC_SITE_TOPOLOGY,
                szInsertDN(pCrossRef->GetNCDN()),
                szInsertUL(pSiteArrayWriteable->GetCount()),
                szInsertUL(pSiteArrayPartial->GetCount())
                ); 
                
            if ( ( pSiteArrayWriteable->GetCount() > 1 ) &&
                 (pSiteArrayWriteable->IsElementOf(pLocalSite)) )
            {
                //
                // More than one site hosts a writeable replica of this NC.
                // And, this site is one of the sites holding a writeable copy.
                // Create a minimum cost spanning tree for this NC
                // using all sites that host at least one writeable replica
                // of the NC
    
                // 
                // The elements are sorted by site object guid so that every
                // KCC arrives at the same result.
                //
                // Note that for spanning tree compatibility when using the old
                // algorithm, we must always use this comparision function here
                // to establish the cannonical site ordering.
                //
                pSiteArrayWriteable->Sort( CompareSiteAndSettings );
    
                KccCreateInterSiteConnectionsForNc(pCrossRef,
                                                   pLocalSite,
                                                   FALSE,                  // non-GC topology
                                                   *pSiteArrayWriteable,
                                                   *pTransportList);
            } else {
                DPRINT1(3, "Writeable intersite topology not needed for NC %ws.\n",
                        pCrossRef->GetNCDN()->StringName);
            }
            
            if ( (pSiteArrayPartial->GetCount() > 0) &&
                 (pSiteArrayPartial->IsElementOf(pLocalSite)) )
            {
                // 
                // There is at least one site in the enterprise that hosts a partial
                // replica of this NC without any writeable copies on the same site.
                // And, this site is a candidate to hold a partial copy.
                // Create a minimum cost spanning tree for this NC using all sites
                // that host this NC (both writeable & partial)
                // 
    
                // Local site in partial list => it will not be in the writeable list
                Assert( (!(pSiteArrayWriteable->IsElementOf(pLocalSite))) );

                for (isite = 0; isite < pSiteArrayWriteable->GetCount(); isite++)
                {
                    pSiteArrayPartial->Add((*pSiteArrayWriteable)[isite]);
                }
    
                //
                // The elements are sorted by site object guid so that every KCC arrives
                // at the same result
                //
                // Note that for spanning tree compatibility when using the old
                // algorithm, we must always use this comparision function here
                // to establish the cannonical site ordering.
                //
                pSiteArrayPartial->Sort( CompareSiteAndSettings );
    
                KccCreateInterSiteConnectionsForNc(pCrossRef,
                                                   pLocalSite,
                                                   TRUE,                   // GC topology
                                                   *pSiteArrayPartial,
                                                   *pTransportList);
    
            } else {
                DPRINT1(3, "GC intersite topology not needed for NC %ws.\n",
                        pCrossRef->GetNCDN()->StringName );
            }
        
        }        
    
    }

    //
    // All sites that were unreachable have been appropriately marked.
    //
    gpDSCache->SetReachableMarkingComplete();
    
    //
    // Remove all inter-site connections within this site that are not
    // needed anymore. 
    //
    KccRemoveUnneededInterSiteConnections();
    
    return;
}

BOOL
KccAmISiteGenerator(
    VOID
    )
/*++

Routine Description:

    This function determines if the local server is the one server in the site
    designated to generate inbound connections from other sites.

Returns:

    TRUE if the local DSA should perform inter site connection generation.
    
--*/
{
    KCC_DSA * pLocalSiteGenerator;
    KCC_DSA * pLocalDSA = gpDSCache->GetLocalDSA();

    pLocalSiteGenerator = gpDSCache->GetLocalSite()->GetSiteGenerator();

    // Note that if no site generator can be determined (e.g., due to lack of
    // NTDS Site Settings object for our site), every DSA in the site will
    // take on this role until the NTDS Site Settings object is created.  (An
    // event has already been logged.)

    return (NULL == pLocalSiteGenerator)
           || (pLocalSiteGenerator == pLocalDSA);
}


VOID
KccCreateInterSiteConnectionsForNc(
    IN     KCC_CROSSREF *               pCrossRef,
    IN     KCC_SITE *                   pLocalSite,
    IN     BOOL                         fGCTopology,
    IN     KCC_SITE_ARRAY &             SiteArray,
    IN     KCC_TRANSPORT_LIST &         TransportList
    )
/*++

Routine Description:

    This routine will construct a minimum cost spanning tree across sites that
    have writable copy of the naming context specified.

    Or in the case of a GCTopology, across sites that have a writable or readable
    copy of the naming context specified.

Parameters:

    pCrossRef            - crossref for the naming context in question
    pLocalSite           - site in which the local DSA resides
    fGCTopology          - tells if the call is for generating GC topology
    SiteArray            - an array of sites that host this naming context
    TransportList        - the list of transports available
    SiteconnectorsToKeep - a list of intersite connectors to keep

Returns:

    None; all errors interesting to the admin are logged.
    
--*/
{
    DWORD       ErrorCode;
    CTOPL_GRAPH SiteGraph;
    KCC_SITE    *RootSite, *CurrentSite;
    TOPL_COMPONENTS *pComponents;
    CTOPL_EDGE  **EdgesNeeded;
    ULONG       cEdgesNeeded;
    ULONG       iSite, cSite, Index;

    RootSite = CurrentSite = NULL;

    // Site array is already sorted by site GUID. So, let us randomely
    // pick the site with the lowest guid as the root site. As long as
    // the logic to pick the rootsite is consitent on all site generators
    // it is good enough.
    RootSite = SiteArray[0];
    
    //
    // Routines from w32topl will throw exceptions on error, so this try is to
    // catch them
    //
    __try
    {
    
        //
        // Put all the nodes into a graph
        //
        for ( iSite = 0, cSite = SiteArray.GetCount();
                iSite < cSite;
                    iSite++ )
        {                   
            //
            // Make sure all edges are cleared from the last iteration
            //
            SiteArray[ iSite ]->ClearEdges();

            SiteGraph.AddVertex( SiteArray[iSite], SiteArray[iSite] ); 
            
            Assert(!!NameMatched(pLocalSite->GetObjectDN(),
                                 SiteArray[iSite]->GetObjectDN())
                   == (pLocalSite == SiteArray[iSite]));

            if (pLocalSite == SiteArray[iSite]) {
                // we are interested in creating site connections for the local site
                Assert(NULL == CurrentSite);
                CurrentSite = SiteArray[iSite];
            }
        }

        if (NULL == CurrentSite)
        {
            // LocalSite does not host (nor required to host) this NC -
            // no need to run the MST algo for this NC in this site generator           
            return;
        }

        // sanity asserts
        Assert(NULL != RootSite);
    
        //
        // For each site, determine what edges exists to/from other sites
        // put each edge into graph
        //
        KccGetSiteConnections( pCrossRef,
                               &TransportList,
                               SiteArray,
                               pLocalSite->GetObjectDN(),
                               fGCTopology );
    
        //
        // Call abstract graph function to create a minimum spanning tree
        //
        pComponents = SiteGraph.FindEdgesForMST( RootSite,
                                                 CurrentSite,
                                                &EdgesNeeded,
                                                &cEdgesNeeded );

        Assert( NULL!=pComponents );                                      
        if ( pComponents->numComponents==1 ) {
            if ( cEdgesNeeded < 1 ) {
                DPRINT( 3, "Spanning tree exists but no edges needed for this site.\n" );
                // (or no edges could be determined due to I_ISMGetConnectivity
                // failure, for example)
            }
        } else {
            KccNoSpanningTree( pCrossRef, pComponents );
        }

        ToplDeleteComponents(pComponents);
        DPRINT1( 3, "%d edges are needed.\n", cEdgesNeeded );
    
        //                                                      
        // For all such edges source from another site to us
        // call CreateConnectionToSite
        //
        for ( Index = 0; Index < cEdgesNeeded; Index++ )
        {
            KCC_SITE_CONNECTION  *SiteConnection;

            //
            // This SiteConnection object tells us what site
            // and by which servers to create a ntdsconnection
            //
    
            SiteConnection =  (KCC_SITE_CONNECTION *) EdgesNeeded[Index];
            ASSERT_VALID( SiteConnection );
    
            // Supportability logging event 4
            LogEvent8(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_EXTENSIVE,
                DIRLOG_KCC_CONNECTION_EDGE_NEEDED,
                szInsertDN(SiteConnection->GetSourceSite()->GetObjectDN()),
                szInsertDN(SiteConnection->GetDestinationDSA()->GetDsName()),
                szInsertDN(SiteConnection->GetSourceDSA()->GetDsName()),
                szInsertDN(SiteConnection->GetTransport()->GetDN()),
                0, 0, 0, 0
                ); 
            //
            // Create the ntdsconnection if one does not already exist
            //
            KccCreateConnectionToSite(pCrossRef,
                                      pLocalSite,
                                      SiteConnection,
                                      fGCTopology,
                                      TransportList);
        }

        //
        // Graph edges are not needed any more -- free them
        //
        for ( iSite = 0, cSite = SiteArray.GetCount(); iSite < cSite; iSite++ ) {
            SiteArray[iSite]->DeleteEdges();
        }

    }
    __except( ToplIsToplException( ( ErrorCode=GetExceptionCode() ) ) )
    {
        //
        // The w32topl library threw an occur code; the implies an internal
        // mishandling of the objects.  Log an error indicated the inter-site
        // topology failed for this NC
        //

        DPRINT1( 0, "W32TOPL routines threw a %d exception during inter-site topology creation.\n", 
                 ErrorCode );

        LogEvent( DS_EVENT_CAT_KCC,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_KCC_AUTO_TOPL_GENERATION_INCOMPLETE,
                  szInsertDN(pCrossRef->GetNCDN()),
                  szInsertHex(ErrorCode),
                  0
                  );

    }

    return;
}


VOID
KccGetSiteConnections(
   IN  KCC_CROSSREF *       pCrossRef,
   IN  KCC_TRANSPORT_LIST * pTransportList,
   IN  KCC_SITE_ARRAY &     SiteArray,
   IN  DSNAME *             pDNLocalSite,
   IN  BOOL                 fGCTopology
   )
/*++

Routine Description:

    This routine queries available transports to determine what physical
    connection exist between the sites listed in SiteArray. These connections
    are also used by the w32topl graph routine to create a minimum spanning tree
    
Parameters:

    pCrossRef            - crossref for the naming context in question
    SiteArray            - an array of sites that host this naming context
    TransportList        - the list of transports available
    pDNLocalSite         - DN of the local site
    fGCTopology          - TRUE, if this is for GC topology

Returns:

    None; all errors interesting to the admin are logged.
    
--*/
{

    DWORD               WinError;
    ISM_CONNECTIVITY    *IsmConnectivity = NULL;
    ULONG               iTransport, cTransports;
    KCC_SITE            *SiteSource, *SiteDest;
    ULONG               iSiteSource, iSiteDest, cSites;
    BOOL                fDataMismatch = FALSE;
    ULONG               *TransportIndexArray = NULL;
    KCC_DSA             *DsaSource, *DsaDest;
    KCC_SITE_CONNECTION *OtherConnection;
    ISM_SCHEDULE        *IsmSchedule = NULL;
    KCC_NC_TYPE         NCType = pCrossRef->GetNCType();

    ASSERT_VALID(pCrossRef);
    ASSERT_VALID(pTransportList);
    ASSERT_VALID(&SiteArray);

    cSites = SiteArray.GetCount();

    __try 
    {

        //
        // For each transport, consider the link
        //
        for ( iTransport = 0, cTransports = pTransportList->GetCount();
                iTransport < cTransports;
                    iTransport++ )
        {
            KCC_TRANSPORT *Transport;

            Transport = pTransportList->GetTransport(iTransport);
            ASSERT_VALID( Transport );
    
            if (!gfAllowMbrBetweenDCsOfSameDomain
                && !fGCTopology
                && !Transport->IsIntersiteIP()
                && (KCC_NC_TYPE_SCHEMA != NCType)
                && (KCC_NC_TYPE_CONFIG != NCType)) {
                // This is not a viable transport for this NC; skip it.
                DPRINT2(3, "Cannot replicate writeable domain NC %ls over non-IP transport %ls.\n",
                        pCrossRef->GetNCDN()->StringName,
                        Transport->GetDN()->StringName);
                continue;
            }

            WinError = I_ISMGetConnectivity( Transport->GetDN()->StringName,
                                            &IsmConnectivity );
            if ((ERROR_SUCCESS != WinError)
                || (NULL == IsmConnectivity)) {
                DPRINT1( 0, "I_ISMGetConnectivity failed with %d\n", WinError );
    
                if (ERROR_SUCCESS == WinError) {
                    WinError = ERROR_DS_DRA_GENERIC;
                }

                LogEvent8WithData(DS_EVENT_CAT_KCC,
                                  DS_EVENT_SEV_ALWAYS,
                                  DIRLOG_ISM_TRANSPORT_FAILURE,
                                  szInsertDN(Transport->GetDN()),
                                  szInsertWin32Msg(WinError),
                                  NULL, NULL, NULL, NULL, NULL, NULL,
                                  sizeof(WinError),
                                  &WinError);

                __leave;
            }

            //
            // This next segment of code is bit confusing, but sadly necessary
            // 
            // SiteArray is a list of sites that all have a dc that hosts a given
            // naming context.  We want to know how they are connected.
            //
            // IsmConnectivity contains information about how each site in the
            // enterprise is joined.
            //
            // TransportIndexArray is mapping from an element in SiteArray to
            // an element in IsmConnectivity.
            //

            TransportIndexArray = (ULONG*) new BYTE[ cSites * sizeof(ULONG) ];
    
            for ( iSiteSource = 0; iSiteSource < cSites; iSiteSource++ )
            {
                ULONG i;
    
                SiteSource = SiteArray[ iSiteSource ];
                ASSERT_VALID( SiteSource );
    
                for ( i = 0; i < IsmConnectivity->cNumSites; i++ )
                {
                    if ( !_wcsicmp( SiteSource->GetObjectDN()->StringName, IsmConnectivity->ppSiteDNs[i] ) )
                    {
                        //
                        // This is it!
                        // 
                        TransportIndexArray[ iSiteSource ] = i;
                        break;
                    }
                }
            }
                                                                
            //
            // Now the determine the site connectivity
            //
            for ( iSiteSource = 0; iSiteSource < cSites; iSiteSource++ )
            {
                SiteSource = SiteArray[ iSiteSource ];
                ASSERT_VALID( SiteSource );
    
                KccCheckSite( SiteSource );
                SiteSource->BuildSiteConnMap();

                for ( iSiteDest = 0; iSiteDest < cSites; iSiteDest++)
                {

                    //
                    // Don't bother with connections to the same site
                    //
                    if ( iSiteSource == iSiteDest )
                    {
                        continue;
                    }

                    PISM_LINK pLink;
                    ULONG   Cost, ReplInterval, LinkOptions;
                    BOOL fUseThisTransport = TRUE;
                    
                    SiteDest = SiteArray[ iSiteDest ];
                    ASSERT_VALID( SiteDest );
                    KccCheckSite( SiteDest );

                    //
                    // Is there a connection between SiteSource and SiteDest ?
                    //
                    pLink = &( IsmConnectivity->pLinkValues[ ( TransportIndexArray[ iSiteSource ]
                                                   *  IsmConnectivity->cNumSites )
                                                   +  TransportIndexArray[ iSiteDest ] ] );
                    Cost = pLink->ulCost;
                    ReplInterval = pLink->ulReplicationInterval;
                    LinkOptions = pLink->ulOptions;

                    if ( Cost < DWORD_INFINITY )
                    {
                        DPRINT4( 4, "There exists a connection between sites %ls and %ls using transport %ls at cost %d\n",
                                SiteSource->GetObjectDN()->StringName, SiteDest->GetObjectDN()->StringName, 
                                Transport->GetDN()->StringName, Cost );

                        //
                        // Is this cost cheaper than any connection already found?
                        //
                        // We want to quickly find the connection between SiteSource
                        // and SiteDest, so we use the map built earlier. Note that the
                        // map will contain stale entries when edges are deleted below,
                        // but this will not cause problems because once an edge has been
                        // deleted, we will search look for it again.
                        //
                        OtherConnection = SiteSource->FindConnInMap( SiteDest );

                        if ( OtherConnection )
                        {
                            if ( Cost < OtherConnection->GetCost() )
                            {
                                DPRINT4( 4, "Transport %ls between sites %ls and %ls is cheaper than transport %ls\n",
                                         Transport->GetDN()->StringName,
                                         SiteSource->GetObjectDN()->StringName,
                                         SiteDest->GetObjectDN()->StringName,
                                         OtherConnection->GetTransport()->GetDN()->StringName);
                            }
                            else
                            {
                                DPRINT4( 4, "Transport %ls between sites %ls and %ls is same or greater cost than transport %ls\n",
                                         Transport->GetDN()->StringName, 
                                         SiteSource->GetObjectDN()->StringName, 
                                         SiteDest->GetObjectDN()->StringName,
                                         OtherConnection->GetTransport()->GetDN()->StringName);
                                
                                fUseThisTransport = FALSE;
                            }
                        }

                        if (fUseThisTransport)
                        {

                            //
                            // Ok this is the cheapest transport yet, now are there any
                            // servers in both sites that can use this transport
                            // and host the nc in question?
                            //
                            if (SiteSource->GetNCBridgeheadForTransport(pCrossRef,
                                                                        Transport,
                                                                        fGCTopology,
                                                                        &DsaSource)) {
                                DPRINT2(4, "Server %ls selected as bridgehead for site %ls.\n",
                                        DsaSource->GetDsName()->StringName,
                                        SiteSource->GetObjectDN()->StringName);
        
                                if (SiteDest->GetNCBridgeheadForTransport(pCrossRef,
                                                                          Transport,
                                                                          fGCTopology,
                                                                          &DsaDest)) {
                                    DPRINT2(4, "Server %ls selected as bridgehead for site %ls.\n",
                                            DsaDest->GetDsName()->StringName,
                                            SiteDest->GetObjectDN()->StringName);
    
                                    //
                                    // Create a new site connection object to represent this information
                                    //
                                    KCC_SITE_CONNECTION *SiteConnection;
                
                                    SiteConnection = new KCC_SITE_CONNECTION;

                                    if (!SiteConnection->Init())
                                    {
                                        DPRINT( 0, "Unable to initialize site connection\n");
                                        __leave;
                                    }

                                    //
                                    // Get the schedule
                                    //
                                    if( Transport->UseSiteLinkSchedules() ) {
                                        WinError = I_ISMGetConnectionSchedule( Transport->GetDN()->StringName,
                                                                               SiteSource->GetObjectDN()->StringName,
                                                                               SiteDest->GetObjectDN()->StringName,
                                                                               &IsmSchedule );
                                    } else {
                                        // Skip the call to the ISM if the transport options attribute
                                        // has the 'ignore schedules' bit set.
                                        WinError = ERROR_SUCCESS;
                                        IsmSchedule = NULL;
                                    }

                                    if ( ERROR_SUCCESS == WinError )
                                    {
                                        TOPL_SCHEDULE       toplSchedule;
                                        TOPL_SCHEDULE_CACHE scheduleCache;

                                        scheduleCache = gpDSCache->GetScheduleCache();
                                        Assert( NULL!=scheduleCache );

                                        if( NULL!=IsmSchedule && NULL!=IsmSchedule->pbSchedule ) {

                                            __try {
                                                toplSchedule = ToplScheduleImport(
                                                        scheduleCache,
                                                        (PSCHEDULE) IsmSchedule->pbSchedule );
                                            } __except( EXCEPTION_EXECUTE_HANDLER ) {
                                                // Bad schedule.
                                                DPRINT2( 4,
                                                   "ISM returned invalid schedule between sites %ls and %ls\n",
                                                   SiteSource->GetObjectDN()->StringName,
                                                   SiteDest->GetObjectDN()->StringName );
                                                LogEvent(DS_EVENT_CAT_KCC,
                                                         DS_EVENT_SEV_ALWAYS,
                                                         DIRLOG_CHK_BAD_ISM_SCHEDULE,
                                                         szInsertDN(SiteSource->GetObjectDN()),
                                                         szInsertDN(SiteDest->GetObjectDN()),
                                                         0);
                                                toplSchedule = ToplGetAlwaysSchedule(
                                                        gpDSCache->GetScheduleCache() );
                                            }
                                            
                                            if( 0==ToplScheduleDuration(toplSchedule) ) {
                                                DPRINT3( 4, "I_ISMGetConnectionSchedule returned a NEVER schedule for "
                                                         "transport %ls between sites %ls %ls. Using default schedule.\n",
                                                         Transport->GetDN()->StringName, 
                                                         SiteSource->GetObjectDN()->StringName, 
                                                         SiteDest->GetObjectDN()->StringName );
                                                SiteConnection->SetDefaultSchedule( ReplInterval );
                                            } else {
                                                SiteConnection->SetSchedule( toplSchedule,
                                                                             ReplInterval );
                                            }

                                            I_ISMFree( IsmSchedule );
                                        }
                                        else
                                        {
                                            DPRINT3( 4, "I_ISMGetConnectionSchedule returned no schedule for transport "
                                                     "%ls between sites %ls %ls. Using default schedule.\n",
                                                     Transport->GetDN()->StringName, 
                                                     SiteSource->GetObjectDN()->StringName, 
                                                     SiteDest->GetObjectDN()->StringName );
                                            SiteConnection->SetDefaultSchedule( ReplInterval );
                                        }
                                        
                                    }
                                    else
                                    {
                                        //
                                        // Error - just use default
                                        //
                                        DPRINT3( 0, "I_ISMGetConnectionSchedule failed for transport %ls between sites %ls %ls\n",
                                                 Transport->GetDN()->StringName, 
                                                 SiteSource->GetObjectDN()->StringName, 
                                                 SiteDest->GetObjectDN()->StringName );
                                        SiteConnection->SetDefaultSchedule( ReplInterval );
                                    }

                                    SiteConnection->SetSourceSite( SiteSource );
                                    SiteConnection->SetDestinationSite( SiteDest );
                                    SiteConnection->SetSourceDSA( DsaSource );
                                    SiteConnection->SetDestinationDSA( DsaDest );
                                    SiteConnection->SetTransport( Transport );
                                    SiteConnection->SetCost( Cost );
                                    SiteConnection->SetReplInterval( ReplInterval );

                                    SiteConnection->SetUsesNotification( LinkOptions & NTDSSITELINK_OPT_USE_NOTIFY );
                                    SiteConnection->SetTwoWaySync( LinkOptions & NTDSSITELINK_OPT_TWOWAY_SYNC );
                                    SiteConnection->SetDisableCompression( LinkOptions & NTDSSITELINK_OPT_DISABLE_COMPRESSION );

                                    //
                                    // This makes the sites objects aware of this
                                    // physical connection
                                    //
                                    SiteConnection->Associate();

                                    KccCheckSite( SiteSource );
                                    KccCheckSite( SiteDest );

                                    //
                                    // Make the other site objects unaware of the old 
                                    // more expensive transport
                                    //
                                    if ( OtherConnection )
                                    {
                                        OtherConnection->Disassociate();

                                        KccCheckSite( SiteSource );
                                        KccCheckSite( SiteDest );

                                        delete OtherConnection;
                                    }

                                }
                                else
                                {
                                    DPRINT2( 3, "No bridgehead found for site %ls transport %ls.\n",
                                            SiteDest->GetObjectDN()->StringName,  Transport->GetDN()->StringName );
                                }
                            }
                            else
                            {
                                DPRINT2( 3, "No bridgehead found for site %ls transport %ls.\n",
                                        SiteSource->GetObjectDN()->StringName,  Transport->GetDN()->StringName );
                            }
                        }
                        else
                        {
                            //
                            // The existing link used a cheaper transport
                            //
                            NOTHING;
                        }
                    }
                    else
                    {
                        DPRINT3( 4, "No connection exists between %ls and %ls using transport %ls.\n",
                                SiteSource->GetObjectDN()->StringName, SiteDest->GetObjectDN()->StringName, Transport->GetDN()->StringName );
                    }

                } // iterate over sites

                SiteSource->DestroySiteConnMap();

            } // iterate over sites


            if ( TransportIndexArray )
            {
                delete [] TransportIndexArray;
                TransportIndexArray = NULL;
            }

            if ( IsmConnectivity )
            {
                I_ISMFree( IsmConnectivity );
                IsmConnectivity = NULL;
            }

        } // iterate over transports

    }
    __finally
    {

        if ( IsmConnectivity )
        {
            I_ISMFree( IsmConnectivity );
        }

        if ( TransportIndexArray )
        {
            delete [] TransportIndexArray;
        }

    }

    return;
}
                                                            

KCC_CONNECTION_ARRAY*
KccFindCandidateConnections(
    IN  KCC_CROSSREF *              pCrossRef,
    IN  KCC_SITE_CONNECTION *       pSiteConnection,   
    IN  BOOL                        fGCTopology
    )
/*++

Routine Description:

    The spanning tree algorithm (either Win2K or Whistler) has run and decided what
    connections it desires. pSiteConnection describes a desired connection. We want
    to examine the existing connections and see if any of them match the desired
    connection.
    
    The precise requirements for a connection to match are too numerous to list here; see
    the comments in the code below for details. The general requirements are:

        - Must source from the right site
        - Must be inbound to the local site
        - Source DSA must be an acceptable BH, host the NC, and (if necessary) be writeable
        - Dest DSA must be an acceptable BH, host the NC, and (if necessary) be writeable

    The overriding rule is that this function should never disqualify a connection which is
    identical to the desired connection.
    
    Note that a connection doesn't have to source to/from the desired servers,
    it just has to source to/from the desired sites.

Parameters:

    pCrossRef            - crossref for the naming context in question
    pSiteConnection      - the desired site connection
    fGCTopology          - tells if the create connection is for a GC topology
    
Returns:

    An pointer to an object which is an array of connection objects.
    If an error occurred (i.e. data read from the directory was inconsistent),
    NULL is returned.
    
--*/
{
    KCC_CONNECTION_LIST::SOURCE_SITE_CONN_ARRAY   *pSiteConnArray;
    KCC_INTERSITE_CONNECTION_LIST                 *pISiteConnList;
    KCC_CONNECTION_ARRAY                          *pCandidateConnArr;
    KCC_SITE                                      *pLocalSite = gpDSCache->GetLocalSite();
    KCC_TRANSPORT_LIST                            *pTransportList = gpDSCache->GetTransportList();
    
    // Desired attributes
    KCC_SITE               *pDesiredSourceSite = pSiteConnection->GetSourceSite();
    DSNAME                 *pdnDesiredSourceSite = pDesiredSourceSite->GetObjectDN();
    KCC_DSA                *pDesiredSourceDsa = pSiteConnection->GetSourceDSA();
    DSNAME                 *pdnDesiredRemoteServer, *pdnDesiredDestServer;

    // Connection attributes
    KCC_CONNECTION         *pcn;
    KCC_DSA                *pConnSourceServer, *pConnDestServer;
    DSNAME                 *pdnConnSourceServer;
    KCC_TRANSPORT          *pTransport;
    LPWSTR                  pszTransportAddr;

    ULONG                   iconn, cconn, idsa, cdsa;
    BOOL                    fIsMaster, fSameSourceDSA, fSameDestDSA;
    const BOOL              IS_LOCAL=TRUE, NOT_LOCAL=FALSE;

    
    // Allocate an array of candidate connections which we will fill up below.
    pCandidateConnArr = new KCC_CONNECTION_ARRAY;
        
    // Iterate over all DSAs in the local site and examine inbound intersite connections.
    cdsa = pLocalSite->GetDsaList()->GetCount();
    for( idsa=0; idsa<cdsa; idsa++ )
    {
        // Get the intersite connection list for this DSA, and then extract the
        // subset of those connections that source from our desired site.
        pISiteConnList = pLocalSite->GetDsaList()->GetDsa(idsa)->GetInterSiteCnList();
        ASSERT_VALID( pISiteConnList );
        pSiteConnArray = pISiteConnList->GetConnectionsFromSite( pdnDesiredSourceSite );

        // If there are no connections at the local DSA idsa which source from our
        // desired site just skip to next DSA.
        if( NULL==pSiteConnArray ) {
            continue;
        }
                       
        // Scan the list of connections from the desired site inbound to the DSA 'idsa',
        // looking for candidates which match pSiteConnection.
        cconn = pSiteConnArray->numConnections;
        for( iconn=0; iconn<cconn; iconn++ )
        {
            pcn = pSiteConnArray->connection[iconn];
            ASSERT_VALID( pcn );

            // Confirm that pdnConnSourceServer is in the site that we desired.
            pdnConnSourceServer = pcn->GetSourceDSADN();
            Assert( pdnConnSourceServer );
            Assert( NamePrefix(pDesiredSourceSite->GetObjectDN(),pdnConnSourceServer) );

            // Find this connection's transport
            Assert( NULL != pcn->GetTransportDN() );
            pTransport = pTransportList->GetTransport(pcn->GetTransportDN());
            if( NULL==pTransport ) {
                Assert( 0 && "Connection had an invalid transport DN" );
                KCC_EXCEPT( ERROR_DS_MISSING_REQUIRED_ATT, 0);
            }
                                 
            // Find the KCC_DSA object for the connection's source server. If the connection
            // is KCC-generated and the connection's source DSA is not the same as the
            // desired source DSA, check that the the DSA is acceptable. Here, acceptable
            // means the DSA is a preferred bridgehead, if preferred BHs are enabled.
            // If the connection is manually created, or if the connection's source DSA
            // is the same as the desired source DSA, we skip the acceptability check.
            pdnDesiredRemoteServer = pSiteConnection->GetSourceDSA()->GetDsName();
            fSameSourceDSA = (0==CompareDsName(&pdnConnSourceServer,&pdnDesiredRemoteServer));
            if( pcn->IsGenerated() && !fSameSourceDSA )
            {
                pConnSourceServer = pDesiredSourceSite
                                    ->GetTransportDsaList(pTransport)
                                    ->GetDsa(pdnConnSourceServer);
                if(!pConnSourceServer) {
                    DPRINT3(0, "%ls is no longer a bridgehead for transport %ls in site %ls.\n",
                            pdnConnSourceServer->StringName,
                            pTransport->GetDN()->StringName,
                            pDesiredSourceSite->GetObjectDN()->StringName);
                    continue;
                }
            } else {    
                pConnSourceServer = pDesiredSourceSite->GetDsaList()->GetDsa(pdnConnSourceServer);
                if(!pConnSourceServer) {
                    DPRINT2(0, "%ls is no longer a server in site %ls.\n",
                            pdnConnSourceServer->StringName,
                            pDesiredSourceSite->GetObjectDN()->StringName);
                    continue;
                }
            }
    
            // A valid source DSA must meet the following requirements:
            //  - it must host the desired NC
            //  - it must be master for a non-gc topology
            //  - it may be master or partial for a gc-topology.
            //  - it must have a valid transport address for its transport
            // If the connection's source DSA does not meet these requirements, we skip it.
            pszTransportAddr = pConnSourceServer->GetTransportAddr(pTransport);
            if(    !(pConnSourceServer->IsNCHost(pCrossRef, NOT_LOCAL, &fIsMaster))
                || (!fIsMaster && !fGCTopology)
                || !pszTransportAddr )
            {
                Assert( pConnSourceServer!=pDesiredSourceDsa );
                continue;
            }

            // We need to further see if the destination end of the connection in the local
            // site hosts the required NC correctly. Get a pointer to the DSA object here.   
            Assert( pSiteConnection->GetDestinationSite() == pLocalSite );
            pConnDestServer = pLocalSite->GetDsaList()->GetDsa(pcn->GetDestinationDSADN());
            if (NULL == pConnDestServer) {
                // Cache coherency problem.  This can occur due to the fact
                // that the intersite connections and DSAs are enumerated in
                // different transactions.  Bail and try again later.
                DPRINT1(0, "Cannot find DSA object %ls in cache\n",
                        pcn->GetDestinationDSADN()->StringName);
                delete pCandidateConnArr;
                return NULL;
            }

            // If the connection is KCC-generated and the connection's destination DSA is not
            // the same as the desired destination DSA, check that the the DSA is acceptable.
            // Here, acceptable means the DSA is a preferred bridgehead, if preferred BHs are enabled.
            // If the connection is manually created, or if the connection's destination DSA
            // is the same as the desired destination DSA, we skip the acceptability check.
            pdnDesiredDestServer = pSiteConnection->GetDestinationDSA()->GetDsName();
            fSameDestDSA = NameMatched(pcn->GetDestinationDSADN(), pdnDesiredDestServer);
            if( pcn->IsGenerated() && !fSameDestDSA )
            {
                if( NULL == pSiteConnection->GetDestinationSite()
                                ->GetTransportDsaList(pTransport)
                                ->GetDsa(pConnDestServer->GetDsName()) )
                {
                    DPRINT2(0, "%ls is no longer a BH for transport %ls in the local site.\n",
                            pConnDestServer->GetDsName()->StringName,
                            pTransport->GetDN()->StringName);
                    continue;
                }
            }
            
            // A valid destination DSA must meet the following requirements:
            //  - it must host the desired NC
            //  - it must be master for a non-gc topology
            //  - it must be partial for a gc-topology (Note: different from source DSA case)
            //  - it must have a valid transport address for its transport
            // If the connection's source DSA does not meet these requirements, we skip it.
            pszTransportAddr = pConnDestServer->GetTransportAddr(pTransport);
            if(    !pConnDestServer->IsNCHost(pCrossRef, IS_LOCAL, &fIsMaster)
                || (!fIsMaster && !fGCTopology)
                || (fIsMaster && fGCTopology)
                || (NULL == pszTransportAddr) )
            {
                // NC not instantiated on local bridgehead
                DPRINT3(3, "Connection %ws is not a candidate because NC %ws not instantiated on %ws.\n",
                        pcn->GetConnectionDN()->StringName,
                        pCrossRef->GetNCDN()->StringName,
                        pConnDestServer->GetDsName()->StringName );
                continue;
            }
            
            pCandidateConnArr->Add( pcn );
        }
    }

    return pCandidateConnArr;
}


VOID
KccUpdateCandidates(
    IN OUT KCC_CONNECTION_ARRAY*       pCandidateConnArr,
    IN     KCC_SITE_CONNECTION *       pSiteConnection
    )
/*++

Routine Description:

    This function examines all candidate connections and fixes up their schedules
    and options. We only do this if the candidate is KCC-generated and has the
    same transport as the desired connection.

Parameters:

    pCandidateConnArr    - the list of candidates
    pSiteConnection      - the desired site connection
    
Returns:

    None
    
--*/
{
    TOPL_SCHEDULE_CACHE     scheduleCache = gpDSCache->GetScheduleCache();
    TOPL_SCHEDULE           connSched, sconnSched;                
    KCC_CONNECTION         *pcn;
    DWORD                   iconn, cconn;
 
    ASSERT_VALID( pCandidateConnArr );
    ASSERT_VALID( pSiteConnection );
    Assert( NULL!=scheduleCache );                        

    cconn = pCandidateConnArr->GetCount();
    for ( iconn=0; iconn<cconn; iconn++ )
    {
        pcn = (*pCandidateConnArr)[ iconn ];
        Assert( pcn );
        
        if(   pcn->IsGenerated()
           && KccIsEqualGUID(&pcn->GetTransportDN()->Guid,
                             &pSiteConnection->GetTransport()->GetDN()->Guid))
        {
            // KCC-generated object with the desired transport.  Verify that
            // the schedule and flags on the connection object are
            // what we think they should be, and if not then update
            // the object in the DS.
            BOOL        fUpdateConnectionInDS = FALSE;

            connSched  = pcn->GetSchedule();
            sconnSched = pSiteConnection->GetSchedule();
                        
            if (!ToplScheduleIsEqual(scheduleCache,connSched,sconnSched)) {
                // Wrong schedule -- fix it.
                pcn->SetSchedule(sconnSched);
                fUpdateConnectionInDS = TRUE;
            }

            if (pcn->UsesNotification() != pSiteConnection->UsesNotification()) {
                // Wrong notification setting -- fix it.
                pcn->SetOverrideNotification(pSiteConnection->UsesNotification());
                fUpdateConnectionInDS = TRUE;
            }

            if (pcn->IsTwoWaySynced() != pSiteConnection->IsTwoWaySynced()) {
                // Wrong two-way sync setting -- fix it.
                pcn->SetTwoWaySync(pSiteConnection->IsTwoWaySynced());
                fUpdateConnectionInDS = TRUE;
            }

            if (pcn->IsCompressionEnabled() != (!pSiteConnection->IsCompressionDisabled())) {
                // Wrong disable compression setting -- fix it.
                pcn->SetDisableIntersiteCompression(pSiteConnection->IsCompressionDisabled());
                fUpdateConnectionInDS = TRUE;
            }
               
            if (fUpdateConnectionInDS) {
                // Flush changes to this object back to the DS.
                pcn->UpdateDS();
            }                
        }
    }
}


VOID
KccCreateConnectionToSite(
    IN  KCC_CROSSREF *              pCrossRef,
    IN  KCC_SITE *                  pLocalSite,
    IN  KCC_SITE_CONNECTION *       pSiteConnection,   
    IN  BOOL                        fGCTopology,    
    IN  KCC_TRANSPORT_LIST &        TransportList
    )
/*++

Routine Description:

    This routine will create a connection between the local site and the
    site specified between machines that hold the given nc if such a
    connection does not already exist.
    
Parameters:

    pCrossRef            - crossref for the naming context in question
    pLocalSite           - site in which the local DSA resides
    pSiteConnection      - the site connection to instantiate
    fGCTopology          - tells if the create connection is for a GC topology
    TransportList        - list of intersite transports
    
Returns:

    None - the only errors are unexpected errors - so an exception is thrown
    
--*/
{     
    KCC_CONNECTION_ARRAY    *pConnArray;
    KCC_SITE *              pDesiredSourceSite = pSiteConnection->GetSourceSite();
    KCC_NC_TYPE             NCType = pCrossRef->GetNCType();
    KCC_DSA                 *pDesiredSourceDsa;
    DSNAME                  *pNCDN;
    BOOL                    fAtLeastOneValidConnectionExists = FALSE;
    ULONG                   iconn, cconn;


    // We should not be trying to add a connection if either of the bridgeheads
    // are considered stale, because this will cause us to disregard an existing
    // connections and potentially create a duplicate.
    //
    // Although the bridgeheads were not considered stale earlier, their
    // staleness is time-dependent so we check again. If either of them are now
    // stale, we just don't bother creating this new connection. The connection
    // should be created on the next KCC run, because we shouldn't hit the same
    // race-condition twice in a row.
    pDesiredSourceDsa = pSiteConnection->GetSourceDSA();
    Assert( NULL!=pDesiredSourceDsa );
    if (   KccIsBridgeheadStale(pDesiredSourceDsa->GetDsName())
        || KccIsBridgeheadStale(pSiteConnection->GetDestinationDSA()->GetDsName()) )
    {
        return;
    }

    // Verify that the NC is instantiated on the source DSA.
    pNCDN = pCrossRef->GetNCDN();
    Assert( NULL!=pNCDN );
    Assert( pDesiredSourceDsa->IsNCInstantiated(pNCDN, NULL) );


    pConnArray = KccFindCandidateConnections( pCrossRef, pSiteConnection, fGCTopology );
    if( NULL==pConnArray ) {
        // An error must have occurred -- bail out.
        return;
    }
    KccUpdateCandidates( pConnArray, pSiteConnection );
    

    DPRINT3(3, "There are %d candidate connections that replicate naming context %ls from site %ls\n",
            pConnArray->GetCount(), pCrossRef->GetNCDN()->StringName,
            pDesiredSourceSite->GetObjectDN()->StringName);
    // Supportability logging event 5
    LogEvent(
        DS_EVENT_CAT_KCC,
        DS_EVENT_SEV_EXTENSIVE,
        DIRLOG_KCC_CANDIDATE_CONNECTIONS,
        szInsertUL(pConnArray->GetCount()),
        szInsertDN(pCrossRef->GetNCDN()),
        szInsertDN(pDesiredSourceSite->GetObjectDN())
        ); 
    

    //
    // From the list of existing replication connections see if they 
    // are over the cheapest transport available
    //
    cconn=pConnArray->GetCount();
    for ( iconn=0; iconn<cconn; iconn++ )
    {
        KCC_CONNECTION *pcn;
        pcn = (*pConnArray)[ iconn ];
        Assert( pcn );

        // If the connection was not autogenerated then assume this is
        // what the admin wants; otherwise if the connection uses the
        // transport we want then that is good, too.
        //
        // We will also re-use an in-use KCC-generated IP connection if
        // we're trying to add SMTP (even though SMTP was cheaper). Why?
        //
        // Suppose there is an in-use (ie, it doesn't replicate nothing) IP connection.
        // It must have been required by a writeable domain NC. Adding the SMTP connection
        // (which is cheaper) desired by the partial NCs would be redundant, because the
        // IP connection _has_ to be there. So, we accept the in-use IP connection.

        if (!pcn->IsGenerated() 
            || KccIsEqualGUID(&pcn->GetTransportDN()->Guid,
                              &pSiteConnection->GetTransport()->GetDN()->Guid)
            || (   !pSiteConnection->GetTransport()->IsIntersiteIP()
                && KCC_TRANSPORT::IsIntersiteIP(pcn->GetTransportDN())
                && !pcn->ReplicatesNothing()) )
        {
            
            if (KccIsBridgeheadStale(pcn->GetSourceDSADN())) {
                // Source server is stale.
                DPRINT2(0, "Ignoring connection %ls using stale outbound bridgehead %ls.\n",
                        pcn->GetConnectionDN()->StringName,
                        pcn->GetSourceDSADN()->StringName);
                pcn->SetReasonForConnection(KCC_STALE_SERVERS_TOPOLOGY);
            }
            else if (KccIsBridgeheadStale(pcn->GetDestinationDSADN())) {
                // Destination server is stale.
                DPRINT2(0, "Ignoring connection %ls using stale inbound bridgehead %ls.\n",
                        pcn->GetConnectionDN()->StringName,
                        pcn->GetDestinationDSADN()->StringName);
                pcn->SetReasonForConnection(KCC_STALE_SERVERS_TOPOLOGY);
            }
            else {
                // This is the first "live" connection we've found that allows
                // us to replicate this NC -- it's a keeper!
                DPRINT3( 3, "Connection %ls is the connection object that we need"\
                            " to replicate over nc %ls over transport %ls\n", 
                         pcn->GetConnectionDN()->StringName,
                         pCrossRef->GetNCDN()->StringName, 
                         pcn->GetTransportDN()->StringName );
                
                fAtLeastOneValidConnectionExists = TRUE;
                // Supportability logging event 6
                LogEvent8(
                    DS_EVENT_CAT_KCC,
                    DS_EVENT_SEV_EXTENSIVE,
                    DIRLOG_KCC_LIVE_CONNECTION,
                    szInsertDN(pcn->GetConnectionDN()),
                    szInsertDN(pCrossRef->GetNCDN()),
                    szInsertDN(pcn->GetTransportDN()),
                    szInsertDN(pDesiredSourceSite->GetObjectDN()),
                    0, 0, 0, 0
                    ); 
            }

            // Supportability logging event 7, dump reason for connection
            LogEvent8(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_EXTENSIVE,
                DIRLOG_KCC_CONNECTION_REPLICATES_NC,
                szInsertDN(pcn->GetConnectionDN()),
                szInsertDN(pCrossRef->GetNCDN()),
                szInsertDN(pcn->GetTransportDN()),
                szInsertDN(pDesiredSourceSite->GetObjectDN()),
                szInsertUL(pcn->GetReasonForConnection()),
                szInsertUL(fGCTopology),
                0, 0
                ); 
            pcn->AddReplicatedNC(pCrossRef->GetNCDN(), fGCTopology);
        }
    }

    if ( !fAtLeastOneValidConnectionExists )
    {
        //
        // No such connection exists - create one
        //
        KCC_INTERSITE_CONNECTION_LIST      *pConnList;
        KCC_CONNECTION                     *pDuplicateConn;
        GUID                               *pSourceDSAGuid;

        pConnList = pSiteConnection->GetDestinationDSA()->GetInterSiteCnList();
        pSourceDSAGuid = &pSiteConnection->GetSourceDSA()->GetDsName()->Guid;
        
        // Check to see if an inbound connection exists from the same DSA
        pDuplicateConn = pConnList->GetConnectionFromSourceDSAUUID(pSourceDSAGuid);
        if( NULL!=pDuplicateConn ) {
            DSNAME *pTransDN1, *pTransDN2;
            pTransDN1 = pDuplicateConn->GetTransportDN();
            pTransDN2 = pSiteConnection->GetTransport()->GetDN();

            // A duplicate connection exists! If the connection has the same transport
            // type as the connection we are trying to create, then we definitely don't
            // want to create a new connection, so we bail out.
            // If the transports are different, then we are basically switching from
            // one transport to another. We allow creation of the (duplicate) connection
            // with the new transport, because the old one will be removed later on.
            
            if( NameMatched(pTransDN1,pTransDN2) ) {

                Assert( NULL==pDuplicateConn );
                DPRINT1(0, "Almost created a duplicate connection of %ls but prevented it",
                    pDuplicateConn->GetConnectionDN()->StringName );
                LogEvent(
                        DS_EVENT_CAT_KCC,
                        DS_EVENT_SEV_ALWAYS,
                        DIRLOG_KCC_ALMOST_MADE_DUP_CONNECTION,
                        szInsertDN(pDuplicateConn->GetConnectionDN()),
                        0, 0
                        );
                return;
            }
        }
        
        KCC_CONNECTION *pcnNew = new KCC_CONNECTION;

        pcnNew->SetEnabled(       TRUE                              );
        pcnNew->SetGenerated(     TRUE                              );

        pcnNew->SetOverrideNotification( pSiteConnection->UsesNotification() );
        pcnNew->SetTwoWaySync(    pSiteConnection->IsTwoWaySynced() );
        pcnNew->SetDisableIntersiteCompression( pSiteConnection->IsCompressionDisabled() );
        pcnNew->SetTransport(     pSiteConnection->GetTransport()->GetDN() );
        pcnNew->SetSourceDSA(     pSiteConnection->GetSourceDSA()   );
        pcnNew->AddReplicatedNC(  pCrossRef->GetNCDN(), fGCTopology );
        pcnNew->SetSchedule(      pSiteConnection->GetSchedule() );

        DWORD dirError = pcnNew->Add( pSiteConnection->GetDestinationDSA()->GetDsName() );
    
        if ( 0 != dirError )
        {
            DPRINT1( 0, "Failed to add connection object, error %d.\n", dirError );
    
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_KCC_ERROR_CREATING_CONNECTION_OBJECT,
                szInsertDN(pSiteConnection->GetSourceDSA()->GetDsName()),
                szInsertDN(pSiteConnection->GetDestinationDSA()->GetDsName()),
                0
                ); 
        }
        else
        {
            DPRINT3( 3,
                     "Created connection object, localdsa:%ws, sourcedsa:%ws, transportdn:%ws\n",
                     pSiteConnection->GetDestinationDSA()->GetDsName()->StringName,
                     pSiteConnection->GetSourceDSA()->GetDsName()->StringName,
                     pSiteConnection->GetTransport()->GetDN()->StringName
                );
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_KCC_CONNECTION_OBJECT_CREATED,
                szInsertDN(pSiteConnection->GetSourceDSA()->GetDsName()),
                szInsertDN(pSiteConnection->GetDestinationDSA()->GetDsName()),
                0
            );
            
            // Add new connection to the cache.
            pLocalSite
                ->GetDsaList()
                ->GetDsa(pSiteConnection->GetDestinationDSA()->GetDsName())
                ->GetInterSiteCnList()
                ->AddToList(pcnNew);
        }
    }                                    
}


VOID
KccRemoveIntersiteConnection(
    KCC_CONNECTION *pcn
    )
/*++

Routine Description:

    Remove a connection from the directory and in-memory data structures

Parameters:

    pcn - The connection to be removed

Return value:

    None

--*/
{
    KCC_DSA    *pDestDSA;
    KCC_SITE   *pLocalSite = gpDSCache->GetLocalSite();
    DWORD       dirError;

    dirError = pcn->Remove();

    pDestDSA = pLocalSite->GetDsaList()->GetDsa(pcn->GetDestinationDSADN());
    ASSERT_VALID( pDestDSA );
    pDestDSA->GetInterSiteCnList()->RemoveFromList(pcn);

    delete pcn;
}


VOID
KccRemoveUnneededInterSiteConnections(
    VOID
    )
/*++

Routine Description:

    This function examines all connections inbound to the local site.
    It removes connections which are deemed to be unnecessary and
    updates the NCReason attribute on connections that must be kept.
    
Parameters:

    pLocalSite (IN) - internal representation of site object for our site

Returns:

    None - all significant errors are logged
    
--*/
{
    ULONG                 iconn, cconn, iconn2, idsa;
    KCC_CONNECTION_ARRAY  connArray;
    KCC_CONNECTION       *pcn, *pcn2;
    KCC_SITE             *pLocalSite = gpDSCache->GetLocalSite();
    BOOL                  fRemove=FALSE;

    // Check connection list for redundant or unused connections.  E.g., no need
    // to keep  a connection that replicates only config & schema if another
    // connection exists from the same site that sources config, schema, & GC
    // info.

    // Sort by source site.  For connections from the same source, order by
    // increasing GC-ness.  If same GC-ness, sort admin-generated connections
    // last.
    //
    // The assertion is that if a connection A is superseded by connection B
    // and connection B is not superseded by A, then A must precede B in the
    // sorted list.

    // Build array containing all connections inbound to this site.
    for( idsa=0; idsa<pLocalSite->GetDsaList()->GetCount(); idsa++ ) {
        KCC_INTERSITE_CONNECTION_LIST * pISiteConnList
            = pLocalSite->GetDsaList()->GetDsa(idsa)->GetInterSiteCnList();
        
        for( iconn=0, cconn=pISiteConnList->GetCount(); iconn<cconn; iconn++ ) {
            connArray.Add(pISiteConnList->GetConnection(iconn));
        }
    }

    // Sort them as detailed above.
    connArray.Sort(KCC_CONNECTION::CompareForRemoval);

    for( iconn=0, cconn=connArray.GetCount(); iconn<cconn; iconn++ ) {

        // Get the connection from the array and check it
        pcn = connArray[ iconn ];
        ASSERT_VALID( pcn );
        Assert( NULL!=pcn->GetTransportDN() );
        fRemove=FALSE;
        
        if( !pcn->IsGenerated() ) {
        	// Connections manually created by the Administrator (i.e. non-KCC
        	// generated connections) must always be kept.
        } else {
            if( !pcn->IsSourceSiteUnreachable() ) {
                if( pcn->ReplicatesNothing() ) {
                    fRemove=TRUE;
                } else {

                    // Examine other connection from the same site, looking for ones which
                    // supercede this connection.
                    for( iconn2=iconn+1; iconn2<cconn; iconn2++ ) {
                        pcn2 = connArray[ iconn2 ];
                        ASSERT_VALID( pcn2 );                  
                        if(!NameMatched(pcn->GetSourceSiteDN(),pcn2->GetSourceSiteDN())) {
                            // We've examined all connections that source from this site
                            break;
                        }
                        if( pcn2->Supercedes(pcn) ) {
                            // pcn is unnecessary, since it is superceded by pcn2
                            fRemove=TRUE;
                            break;
                        } else {
                            // pcn2 does not supercede pcn.  In this case pcn should not
                            // supercede pcn2, either (else our sort is incorrect). 
                            Assert( !pcn->Supercedes(pcn2) );
                        }
                    }
                    
                }
            } else {

                // The source site is reachable

            }
        }

        if( fRemove ) {
            // This connection was determined to be superfluous. Remove it.
            KccRemoveIntersiteConnection(pcn);
        } else {
            pcn->UpdateReason();
        }

    }
}


#if DBG
VOID
KccCheckSite(
    IN KCC_SITE *Site
    )
/*++

Routine Description:
    
    This routine does some sanity checking of the Site and
    connections to other sites

Parameters:

    Site  - pointer to site object
    
Returns:

    Nothing

--*/
{
    KCC_SITE_CONNECTION *SiteConn = NULL;
    KCC_SITE            *OtherSite;
    ULONG                iEdge, cEdges;

    ASSERT_VALID( Site );


    for ( iEdge = 0, cEdges = Site->NumberOfOutEdges();
            iEdge < cEdges;
                iEdge++ )
    {
        SiteConn =  (KCC_SITE_CONNECTION *) Site->GetOutEdge( iEdge );
        ASSERT_VALID( SiteConn );

        OtherSite = (KCC_SITE*) SiteConn->GetFrom();
        ASSERT_VALID( OtherSite );
        Assert( OtherSite == Site ); 

        OtherSite = (KCC_SITE*) SiteConn->GetTo();
        ASSERT_VALID( OtherSite );
    }

    for ( iEdge = 0, cEdges = Site->NumberOfInEdges();
            iEdge < cEdges;
                iEdge++ )
    {
        KCC_SITE *ToSite;

        SiteConn =  (KCC_SITE_CONNECTION *) Site->GetInEdge( iEdge );
        ASSERT_VALID( SiteConn );

        OtherSite = (KCC_SITE*) SiteConn->GetFrom();
        ASSERT_VALID( OtherSite );

        OtherSite = (KCC_SITE*) SiteConn->GetTo();
        ASSERT_VALID( OtherSite );
        Assert( OtherSite == Site ); 

    }

    return;

}
#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kcctools.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcctools.cxx

ABSTRACT:

    Miscellaneous global utility functions.

DETAILS:


CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpchx.h>
#include <dsconfig.h>
#include "kcc.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include "kccconn.hxx"
#include "kccstale.hxx"
#include "kccsite.hxx"
#include <w32toplsched.h>

#define FILENO FILENO_KCC_KCCTOOLS

BOOL
KccIsDSAInStayOfExecution(
    IN  UUID *  puuidDSA,
    OUT BOOL *  pfIsDeleted
    )
//
// Is the DSA with the given Object-Guid / Invocation-ID deleted _and_ deleted
// less than KccGetStayOfExecution() seconds ago?
//
{
    BOOL        fIsInStayOfExecution = FALSE;
    BYTE   *    rgbDSADN = (BYTE *)alloca(DSNameSizeFromLen(0));
    DSNAME *    pdnDSA = (DSNAME *) rgbDSADN;
    DWORD       dwStayOfExecutionLen;

    dwStayOfExecutionLen = gpDSCache->GetStayOfExecution();
    if( 0==dwStayOfExecutionLen ) {
        // Special case: Stay of Execution has been disabled.
        return FALSE;
    }

    // Construct a DSNAME for the object.
    // Note that string name is not used, so a DSNAME sized memory suffices
    memset( rgbDSADN, 0, DSNameSizeFromLen(0) );
    pdnDSA->Guid      = *puuidDSA;
    pdnDSA->structLen = DSNameSizeFromLen( 0 );

    // What is the earliest time the NTDS-DSA object could have been deleted
    // and still be within its stay of execution?
    DSTIME timeDeletedAfter = GetSecondsSince1601() - dwStayOfExecutionLen;

    // Does this object exist and match our criteria to be considered in a
    // stay of execution?

    ATTR      rgAttrs[] =
    {
        { ATT_IS_DELETED,   { 0, NULL } },
        { ATT_WHEN_CHANGED, { 0, NULL } }
    };

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    ULONG       dirError;
    READRES *   pReadRes = NULL;
    BOOL        fIsDeleted = FALSE;
    DSTIME      timeChanged = 0;

    dirError = KccRead( pdnDSA, &Sel, &pReadRes, KCC_INCLUDE_DELETED_OBJECTS );

    if (0 != dirError )
    {

        if ( ( referralError == dirError )
         || (    ( nameError == dirError )
              && (    pReadRes->CommRes.pErrInfo->NamErr.extendedErr
                   == DIRERR_OBJ_NOT_FOUND )
              && (    pReadRes->CommRes.pErrInfo->NamErr.problem
                   == NA_PROBLEM_NO_OBJECT ) ) )
        {

            //
            // This is the case where the object really does not exist
            //
            fIsInStayOfExecution = FALSE;
    
            if ( NULL != pfIsDeleted )
            {
                //
                // The object was deleted at some point.
                //
                *pfIsDeleted = TRUE;
            }
    
        }
        else
        {
            //
            // We will want to understand these cases as they should not happen
            //
            KCC_LOG_READ_FAILURE( pdnDSA, dirError );
            KCC_EXCEPT( DIRERR_MISSING_EXPECTED_ATT, dirError );
        }
    }
    else
    {
        // Read succeeded; parse returned attributes.
        for ( DWORD iAttr = 0; iAttr < pReadRes->entry.AttrBlock.attrCount; iAttr++ )
        {
            ATTR *  pattr = &pReadRes->entry.AttrBlock.pAttr[ iAttr ];

            switch ( pattr->attrTyp )
            {
            case ATT_IS_DELETED:
                Assert( 1 == pattr->AttrVal.valCount );
                Assert( sizeof( fIsDeleted ) == pattr->AttrVal.pAVal->valLen );
                fIsDeleted = *( (BOOL *) pattr->AttrVal.pAVal->pVal );
                break;

            case ATT_WHEN_CHANGED:
                Assert( 1 == pattr->AttrVal.valCount );
                Assert( sizeof( timeChanged ) == pattr->AttrVal.pAVal->valLen );
                timeChanged = *( (DSTIME *) pattr->AttrVal.pAVal->pVal );
                break;

            default:
                DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp );
                break;
            }
        }

        // ATT_WHEN_CHANGED must be present
        if (!timeChanged) {
            Assert(!"NTDSKCC: KccRead did not return ATT_WHEN_CHANGED\n");
            KCC_EXCEPT( ERROR_DS_MISSING_REQUIRED_ATT, 0);
        }

        fIsInStayOfExecution = fIsDeleted && ( timeChanged >= timeDeletedAfter );

        if ( NULL != pfIsDeleted )
        {
            *pfIsDeleted = fIsDeleted;
        }
    }

    return fIsInStayOfExecution;
}


BOOL
KccIsDeleted(
    IN  DSNAME *    pdn
    )
//
// Is the given object logically deleted?
// If the object does not exist, or if there is an unexpected error, an
// exception is raised.
//
{
    ATTR      rgAttrs[] =
    {
        { ATT_IS_DELETED, { 0, NULL } }
    };

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    BOOL        fIsDeleted = FALSE;
    ULONG       dirError;
    READRES *   pReadRes = NULL;

    dirError = KccRead( pdn, &Sel, &pReadRes, KCC_INCLUDE_DELETED_OBJECTS );

    if ( 0 != dirError )
    {
        if ( attributeError == dirError )
        {
            INTFORMPROB * pprob = &pReadRes->CommRes.pErrInfo->AtrErr.FirstProblem.intprob;

            if (    ( PR_PROBLEM_NO_ATTRIBUTE_OR_VAL == pprob->problem )
                 && ( DIRERR_NO_REQUESTED_ATTS_FOUND == pprob->extendedErr )
               )
            {
                // ATT_IS_DELETED is not present; the object is live.
                fIsDeleted = FALSE;
                dirError = 0;
            }
        }
        else if (    ( referralError == dirError )
                 || (    ( nameError == dirError )
                      && (    pReadRes->CommRes.pErrInfo->NamErr.extendedErr
                           == DIRERR_OBJ_NOT_FOUND )
                      && (    pReadRes->CommRes.pErrInfo->NamErr.problem
                           == NA_PROBLEM_NO_OBJECT ) ) )
        {
            //
            // This is the case where the object really does not exist
            //
#if DBG
            if (referralError == dirError) {
                //
                // We should only get referrals when there is a guid and
                // no string name.
                //
                GUID NullGuid;
                RtlZeroMemory(&NullGuid, sizeof(GUID));

                Assert(!memcmp(&pdn->Guid, &NullGuid, sizeof(GUID)) 
                     && pdn->NameLen == 0);
            }
#endif
            fIsDeleted = TRUE;
            dirError = 0;
    
        }
        else
        {

            //
            // We will want to understand these cases as they should not happen
            //
            KCC_LOG_READ_FAILURE( pdn, dirError );
            KCC_EXCEPT( DIRERR_MISSING_EXPECTED_ATT, dirError );
        }
    }
    else
    {
        // Read succeeded; parse returned attributes.
        for ( DWORD iAttr = 0; iAttr < pReadRes->entry.AttrBlock.attrCount; iAttr++ )
        {
            ATTR *  pattr = &pReadRes->entry.AttrBlock.pAttr[ iAttr ];

            switch ( pattr->attrTyp )
            {
            case ATT_IS_DELETED:
                Assert( 1 == pattr->AttrVal.valCount );
                Assert( sizeof( BOOL ) == pattr->AttrVal.pAVal->valLen );
                fIsDeleted = *( (BOOL *) pattr->AttrVal.pAVal->pVal );
                break;

            default:
                DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp );
                break;
            }
        }
    }

    return fIsDeleted;
}

BOOL
KccObjectExists(
    IN  UUID *  puuid,
    OUT BOOL *  pfIsDeleted OPTIONAL
    )
/*++

Routine Description:

    Determine whether an object with the given GUID exists (deleted or not) in
    the local DS.

Arguments:

    puuid (IN) - UUID of object to look for.

    pfIsDeleted (OUT, OPTIONAL) - On return, is set to TRUE if the object was
        found but is deleted.  Set to FALSE otherwise.

    pulLastChangeTime (OUT, OPTIONAL) - On return, holds the time the object
        was last changed if it exists.  Set to 0 otherwise.

Return Values:

    TRUE - object exists locally (deleted or not).
    FALSE - otherwise.

--*/
{
    ATTR      rgAttrs[] =
    {
        { ATT_WHEN_CHANGED, { 0, NULL } },
        { ATT_IS_DELETED,   { 0, NULL } }
    };

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    BOOL        fExists = FALSE;
    BOOL        fIsDeleted = FALSE;
    ULONG       dirError;
    READRES *   pReadRes = NULL;
    DSNAME      dn;

    Assert( NULL != puuid );

    memset( &dn, 0, sizeof( dn ) );
    dn.Guid = *puuid;
    dn.structLen = DSNameSizeFromLen( 0 );

    dirError = KccRead( &dn, &Sel, &pReadRes, KCC_INCLUDE_DELETED_OBJECTS );

    if ( 0 != dirError )
    {
        if (    ( referralError == dirError )
             || (    ( nameError == dirError )
                  && (    pReadRes->CommRes.pErrInfo->NamErr.extendedErr
                       == DIRERR_OBJ_NOT_FOUND )
                  && (    pReadRes->CommRes.pErrInfo->NamErr.problem
                       == NA_PROBLEM_NO_OBJECT ) ) )
        {
            // Object does not exist locally.
            Assert( !fExists );
            Assert( !fIsDeleted );
        }
        else
        {
            // Other error; bail.
            KCC_LOG_READ_FAILURE( &dn, dirError );
            KCC_EXCEPT( DIRERR_MISSING_EXPECTED_ATT, dirError );
        }
    }
    else
    {
        // Read succeeded; parse returned attributes.
        fExists = TRUE;
        Assert( !fIsDeleted );

        for ( DWORD iAttr = 0; iAttr < pReadRes->entry.AttrBlock.attrCount; iAttr++ )
        {
            ATTR *  pattr = &pReadRes->entry.AttrBlock.pAttr[ iAttr ];

            switch ( pattr->attrTyp )
            {
            case ATT_WHEN_CHANGED:
                break;

            case ATT_IS_DELETED:
                Assert( 1 == pattr->AttrVal.valCount );
                Assert( sizeof( BOOL ) == pattr->AttrVal.pAVal->valLen );
                fIsDeleted = *( (BOOL *) pattr->AttrVal.pAVal->pVal );
                break;

            default:
                DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp );
                break;
            }
        }
    }

    if ( NULL != pfIsDeleted )
    {
        *pfIsDeleted = fIsDeleted;
    }

    return fExists;
}


BOOL
KccLinkServerIsStale(
    IN DSNAME* pdnFromServer,
    IN ULONG   FailuresAllowed,
    IN ULONG   MaxFailureTime
    )
//
// Determine if the specified server is considered to be stale to be
// part of the ring topology
//
{

    BOOL  fStale = FALSE;
    DWORD NumberOfFailures;
    DWORD TimeSinceLastSuccess;
    DWORD LastResult;
    BOOL  fUserNotifiedOfStaleness;

    if ( gpDSCache->GetLocalSite()->IsDetectStaleServersDisabled() )
    {
        // Nothing is stale when this option is turned off
        return FALSE;
    }

    if ( pdnFromServer )
    {

        if ( gLinkFailureCache.Get( pdnFromServer,
                                    &TimeSinceLastSuccess,
                                    &NumberOfFailures,
                                    &fUserNotifiedOfStaleness,
                                    &LastResult) )
        {

            //
            // The object is in the cache; has it been too long?
            //
            if (NumberOfFailures >  FailuresAllowed
             && TimeSinceLastSuccess > MaxFailureTime )
            {
                // Too bad
                fStale = TRUE;

                DPRINT4( 4, "KCC: (link server) Server %ws is stale, allowed=%d, time=%d, result=%d.\n",
                        pdnFromServer->StringName,
                        FailuresAllowed, MaxFailureTime, LastResult );

                if (!fUserNotifiedOfStaleness)
                {
                    gLinkFailureCache.NotifyUserOfStaleness( pdnFromServer );
                }
            }
            else
            {

                if ( fUserNotifiedOfStaleness )
                {
                    //
                    // At one point, this server was stale and the user was notified.
                    // Reset the flag so if the server becomes stale again, the
                    // user will be notified
                    //

                    gLinkFailureCache.ResetUserNotificationFlag( pdnFromServer );
                    
                }
            }
        }
    }

    return fStale;
}

BOOL
KccConnectionServerIsStale(
    IN  DSNAME * pdnFromServer,
    IN ULONG     FailuresAllowed,
    IN ULONG     MaxFailureTime
    )
//
// Determine if the specified server has failed DirReplicaAdd too many times 
// in a row to be considered for the ring topology
//
{

    BOOL  fStale = FALSE;

    DWORD NumberOfFailures;
    DWORD TimeSinceFirstAttempt;
    BOOL  fUserNotifiedOfStaleness;

    if ( gpDSCache->GetLocalSite()->IsDetectStaleServersDisabled() )
    {
        // Nothing is stale when this option is turned off
        return FALSE;
    }

    if ( pdnFromServer )
    {

        if ( gConnectionFailureCache.Get( pdnFromServer,
                                          &TimeSinceFirstAttempt,
                                          &NumberOfFailures,
                                          &fUserNotifiedOfStaleness,
                                          NULL /* dwLastResult */,
                                          NULL /* fErrorOccurredThisRun */ ) )
        {

            //
            // The object is in the cache; has it been to long?
            //
            if (NumberOfFailures >  FailuresAllowed
             && TimeSinceFirstAttempt > MaxFailureTime )
            {
                // Too bad
                fStale = TRUE;
                DPRINT3( 4, "KCC: (connection) Server %ws is stale, allowed=%d, time=%d.\n",
                        pdnFromServer->StringName,
                        FailuresAllowed, MaxFailureTime );

                if ( !fUserNotifiedOfStaleness )
                {
                    gConnectionFailureCache.NotifyUserOfStaleness( pdnFromServer );
                }
            }
            else
            {
                if ( fUserNotifiedOfStaleness )
                {
                    //
                    // At one point, this server was stale and the user was notified.
                    // Reset the flag so if the server becomes stale again, the
                    // user will be notified
                    //

                    gConnectionFailureCache.ResetUserNotificationFlag( pdnFromServer );
                    
                }
            }
        }
    }

    return fStale;
}

BOOL
KccCriticalLinkServerIsStale(
    IN  DSNAME *    pdnFromServer
    )
//
// Determine if the specified server is considered to be stale to be
// part of the ring topology
//
{
    return KccLinkServerIsStale( pdnFromServer, 
                                 gcCriticalLinkFailuresAllowed,
                                 gcSecsUntilCriticalLinkFailure );
}

BOOL
KccCriticalConnectionServerIsStale(
    IN  DSNAME *    pdnFromServer
    )
//
// Determine if the specified server is considered to be stale to be
// part of the ring topology
//
{
    return KccConnectionServerIsStale( pdnFromServer, 
                                       gcCriticalLinkFailuresAllowed,
                                       gcSecsUntilCriticalLinkFailure );
}


BOOL
KccNonCriticalLinkServerIsStale(
    IN  DSNAME *    pdnFromServer
    )
//
// Determine if the specified server is considered to stale 
// for optimization connections
//
{
    return KccLinkServerIsStale( pdnFromServer, 
                                 gcNonCriticalLinkFailuresAllowed,
                                 gcSecsUntilNonCriticalLinkFailure );
}

BOOL
KccNonCriticalConnectionServerIsStale(
    IN  DSNAME *    pdnFromServer
    )
//
// Determine if the specified server has failed DirReplicaAdd too many times
// in a row to be considered as an optimization connection
//
{

    return KccConnectionServerIsStale( pdnFromServer, 
                                       gcNonCriticalLinkFailuresAllowed,
                                       gcSecsUntilNonCriticalLinkFailure );
}


BOOL
KccIsBridgeheadStale(
    IN  DSNAME *    pdnFromServer
    )
//
// Determine if the specified server is considered to be stale to be
// part of the intersite topology
//
{
    return (KccLinkServerIsStale(pdnFromServer, 
                                 gcIntersiteLinkFailuresAllowed,
                                 gcSecsUntilIntersiteLinkFailure)
            || KccConnectionServerIsStale(pdnFromServer, 
                                          gcIntersiteLinkFailuresAllowed,
                                          gcSecsUntilIntersiteLinkFailure));
}


ULONG
KccGetNumberOfOptimizingEdges(
    IN ULONG  cServers
    )
//
// See toplmgnt.doc for more info.  The general idea here is that we want each
// server to be not more than 3 server hops from any other server. Assuming
// the ring connection between all servers in a given nc and site, let n 
// be the number of extra connections per server. Then let f(n) be the
// number of servers reachable from a given server within 3 hops.
//
// f(n) = 2*n^2 + 6*n + 6
//
// So the idea here is if the number of servers EXCLUDING the local server
// (hence the +1, below) is less than or equal to f(n) then given an idea
// placement of edges, each server can reach each other in 3 hops.  We have the
// number of servers and f(n), so we return n.
//
{
    #define f(x)  ( 2*(x)*(x) + 6*(x) + 6 )

    ULONG n;

    for ( n = 0; ; n++ )
    {
        if ( cServers <= f(n) + 1 )
        {
            return n;            
        }
    }

}


REPLTIMES*
KccConvertToplScheduleToReplTimes(
    IN TOPL_SCHEDULE toplSchedule
    )
/*++

Routine Description:

    Given a TOPL_SCHEDULE, allocate an equivalent ReplTimes structure and return it
    to the user. If the TOPL_SCHEDULE is NULL, an 'always available' ReplTimes
    structure will be returned.

Arguments:

    toplSchedule - the topl schedule to convert

Return Value:

    REPLTIMES - Allocated with new[]. Should be freed by caller using delete[].
    Never returns NULL.

--*/
{
    PSCHEDULE psched;
    REPLTIMES* replTimes;

    psched = ToplScheduleExportReadonly( gpDSCache->GetScheduleCache(), toplSchedule );
    replTimes = (REPLTIMES*) new BYTE[ sizeof(REPLTIMES) ];

    if (psched && ((sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES) <= psched->Size))
    {
        // We don't expect BANDWIDTH or PRIORITY schedule to be present in the DS Replication Schedule
        // But if they do we will ignore them and use only the INTERVAL schedule part
        if ((1 <= psched->NumberOfSchedules) && (3 >= psched->NumberOfSchedules))
            
        {
            // locate the interval schedule in the struct and ignore bandwidth & priority
            int nInterval = -1;
            for (int j = 0; j < (int) psched->NumberOfSchedules; j++)
            {
                if (SCHEDULE_INTERVAL == psched->Schedules[j].Type)
                {
                    // located the INTERVAL schedule - if there are more than one INTERVAL schedules
                    // in the blob, we will use only the first one.
                    nInterval = j;
                    break;
                }
            }

            if (nInterval >= 0)
            {
                // sanity check to see if all the interval schedule data is present
                if ((psched->Schedules[nInterval].Offset + SCHEDULE_DATA_ENTRIES) <= psched->Size)
                {
                    // Everything in the blob is as expected and we found a valid INTERVAL schedule
                    // - convert the 168 byte schedule data to the internal 84 byte format
                    PBYTE pbSchedule = ((PBYTE) psched) + psched->Schedules[nInterval].Offset;
                    for (int i = 0, j = 0; j < SCHEDULE_DATA_ENTRIES; ++i, j += 2)
                    {
                        replTimes->rgTimes[i] = (((pbSchedule[j] & 0x0F) << 4) | (pbSchedule[j+1] & 0x0F));
                    }

                    return replTimes;
                }
            }
        }
    }

    // given schedule is invalid or incorrectly formated - use default (always)
    memset(replTimes, 0xff, sizeof(REPLTIMES));
    return replTimes;
}
            

int __cdecl
KccCompareMetaData(
    IN  const void *  pvMetaData1,
    IN  const void *  pvMetaData2
    )
//
// Compare meta data (for use by bsearch()).
//
{
    PROPERTY_META_DATA * pMetaData1 = (PROPERTY_META_DATA *) pvMetaData1;
    PROPERTY_META_DATA * pMetaData2 = (PROPERTY_META_DATA *) pvMetaData2;

    if( pMetaData1->attrType < pMetaData2->attrType ) {
        return -1;
    } else if( pMetaData1->attrType > pMetaData2->attrType ) {
        return 1;
    } else {
        return 0;
    }
}


BOOL
KccFillGuidAndSid(
    IN OUT  DSNAME *    pdn
    )
//
// Find the object in the DS and add its GUID and SID to its in-memory DSNAME.
//
{
    ATTR rgAttrs[] = {
        { ATT_OBJ_DIST_NAME, { 0, NULL } }
    };

    ENTINFSEL Sel = {
        EN_ATTSET_LIST,
        { ARRAY_SIZE(rgAttrs), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    ULONG       dirError;
    READRES *   pReadRes = NULL;
    DSNAME *    pdnFromDB;
    BOOL        fSuccess = FALSE;

    dirError = KccRead(pdn, &Sel, &pReadRes, KCC_INCLUDE_DELETED_OBJECTS);

    if (0 != dirError) {
        if ((referralError == dirError)
            || ((nameError == dirError)
                && (pReadRes->CommRes.pErrInfo->NamErr.extendedErr
                    == DIRERR_OBJ_NOT_FOUND)
                && (pReadRes->CommRes.pErrInfo->NamErr.problem
                    == NA_PROBLEM_NO_OBJECT))) {
            // Object does not exist locally.
            Assert(!fSuccess);
        }
        else {
            // Other error; bail.
            KCC_LOG_READ_FAILURE( pdn, dirError );
            KCC_EXCEPT( DIRERR_MISSING_EXPECTED_ATT, dirError );
        }
    }
    else {
        // Read succeeded; parse returned attributes.
        for (DWORD iAttr = 0; iAttr < pReadRes->entry.AttrBlock.attrCount; iAttr++) {
            ATTR *  pattr = &pReadRes->entry.AttrBlock.pAttr[ iAttr ];

            switch (pattr->attrTyp) {
            case ATT_OBJ_DIST_NAME:
                Assert(1 == pattr->AttrVal.valCount);
                pdnFromDB = (DSNAME *) pattr->AttrVal.pAVal->pVal;
                pdn->Guid   = pdnFromDB->Guid;
                pdn->Sid    = pdnFromDB->Sid;
                pdn->SidLen = pdnFromDB->SidLen;
                fSuccess = TRUE;
                break;

            default:
                DPRINT1(0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp);
                break;
            }
        }

        Assert(fSuccess);
    }

    return fSuccess;
}


DSNAME *
KccGetDSNameFromGuid(
    IN  GUID *  pObjGuid
    )
/*++

Routine Description:

    Look up the DSNAME of the object in the database with the given objectGuid.

Arguments:

    pObjGuid (IN) - objectGuid of object to look for.

Return Values:

    The DSNAME of the object if it could be found, or NULL otherwise.

--*/
{
    ATTR rgAttrs[] = {
        { ATT_OBJ_DIST_NAME, { 0, NULL } }
    };

    ENTINFSEL Sel = {
        EN_ATTSET_LIST,
        { ARRAY_SIZE(rgAttrs), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    ULONG       dirError;
    READRES *   pReadRes = NULL;
    BOOL        fSuccess = FALSE;
    DSNAME      dnGuidOnly = {0};
    DSNAME *    pdnFull = NULL;

    dnGuidOnly.structLen = DSNameSizeFromLen(0);
    dnGuidOnly.Guid = *pObjGuid;

    dirError = KccRead(&dnGuidOnly, &Sel, &pReadRes, KCC_INCLUDE_DELETED_OBJECTS);

    if (0 != dirError) {
        if ((referralError == dirError)
            || ((nameError == dirError)
                && (pReadRes->CommRes.pErrInfo->NamErr.extendedErr
                    == DIRERR_OBJ_NOT_FOUND)
                && (pReadRes->CommRes.pErrInfo->NamErr.problem
                    == NA_PROBLEM_NO_OBJECT))) {
            // Object does not exist locally.
            Assert(NULL == pdnFull);
        }
        else {
            // Other error; bail.
            KCC_LOG_READ_FAILURE( &dnGuidOnly, dirError );
            KCC_EXCEPT( DIRERR_MISSING_EXPECTED_ATT, dirError );
        }
    }
    else {
        // Read succeeded; parse returned attributes.
        for (DWORD iAttr = 0; iAttr < pReadRes->entry.AttrBlock.attrCount; iAttr++) {
            ATTR *  pattr = &pReadRes->entry.AttrBlock.pAttr[ iAttr ];

            switch (pattr->attrTyp) {
            case ATT_OBJ_DIST_NAME:
                Assert(1 == pattr->AttrVal.valCount);
                pdnFull = (DSNAME *) pattr->AttrVal.pAVal->pVal;
                break;

            default:
                DPRINT1(0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp);
                break;
            }
        }

        Assert(NULL != pdnFull);
    }

    return pdnFull;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kcctopl.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcctopl.cxx

ABSTRACT:

    KCC_TASK_UPDATE_REPL_TOPOLOGY class.

DETAILS:

    This task performs routine maintenance on the replication topology.
    This includes:
    
    .   generating a topology of NTDS-Connection objects,
    .   updating existing replication links with changes made to NTDS-
        Connection objects
    .   translating new NTDS-Connection objects into new replication
        links, and
    .   removing replication links for which there is no NTDS-Connection
        object.

    This list of duties will undoubtedly grow.

CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpchx.h>
#include <dsconfig.h>
#include "kcc.hxx"
#include "kcctask.hxx"
#include "kccconn.hxx"
#include "kcctopl.hxx"
#include "kcccref.hxx"
#include "kccdsa.hxx"
#include "kccsite.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include "kccnctl.hxx"
#include "kcclink.hxx"
#include "kccstale.hxx"
#include "kccstetl.hxx"

#define FILENO FILENO_KCC_KCCTOPL

BOOL
KCC_TASK_UPDATE_REPL_TOPOLOGY::Init()
//
// Initialize this task.
//
{
    return Schedule(gcSecsUntilFirstTopologyUpdate);
}

BOOL
KCC_TASK_UPDATE_REPL_TOPOLOGY::IsValid()
//
// Is this object internally consistent?
//
{
    return TRUE;
}

void
KCC_TASK_UPDATE_REPL_TOPOLOGY::LogBegin()
//
// Log task begin.
//
{
    DPRINT( 3, "Beginning to update replication topology.\n" );

    LogEvent(
        DS_EVENT_CAT_KCC,
        DS_EVENT_SEV_EXTENSIVE,
        DIRLOG_CHK_UPDATE_REPL_TOPOLOGY_BEGIN,
        0,
        0,
        0
        );
}

void
KCC_TASK_UPDATE_REPL_TOPOLOGY::LogEndNormal()
//
// Log normal task termination.
//
{
    DPRINT( 3, "Update replication topology terminated normally.\n" );

    LogEvent(
        DS_EVENT_CAT_KCC,
        DS_EVENT_SEV_EXTENSIVE,
        DIRLOG_CHK_UPDATE_REPL_TOPOLOGY_END_NORMAL,
        0,
        0,
        0
        );
}

void
KCC_TASK_UPDATE_REPL_TOPOLOGY::LogEndAbnormal(
    IN DWORD dwErrorCode,
    IN DWORD dsid
    )
//
// Log abnormal task termination.
//
{
    DPRINT2(
        0,
        "Update replication topology terminated abnormally (%d, DSID %x).\n",
        dwErrorCode,
        dsid
        );

    LogEvent8WithData(
        DS_EVENT_CAT_KCC,
        (geKccState == KCC_STARTED) ? DS_EVENT_SEV_ALWAYS : DS_EVENT_SEV_MINIMAL,
        DIRLOG_CHK_UPDATE_REPL_TOPOLOGY_END_ABNORMAL,
        szInsertWin32Msg(dwErrorCode),
        szInsertHex(dsid),
        NULL, NULL, NULL, NULL, NULL, NULL,
        sizeof(dwErrorCode),
        &dwErrorCode
        );
}

DWORD
KCC_TASK_UPDATE_REPL_TOPOLOGY::ExecuteBody(
    OUT DWORD * pcSecsUntilNextIteration
    )
//
// Execute the task.
//
{
    KCC_INTRASITE_CONNECTION_LIST * pIntraSiteCnList;
    KCC_INTERSITE_CONNECTION_LIST * pInterSiteCnList;
    DWORD                           cMinsBetweenRuns;
    BOOL                            fKeepCurrentIntrasiteConnections;
    KCC_SITE *                      pLocalSite;
    KCC_DS_CACHE                    DSCache;
    int                             nPriority;
    DWORD                           dwErrCode;

    __try {
        nPriority = ((int) gdwKccThreadPriority) - KCC_THREAD_PRIORITY_BIAS;
        if( ! SetThreadPriority(GetCurrentThread(),nPriority) ) {
            dwErrCode = GetLastError();
            DPRINT1(0, "Failed to set the thread priority. Err=%d\n", dwErrCode);
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_KCC_SET_PRIORITY_ERROR,
                szInsertWin32Msg(dwErrCode),
                NULL,
                NULL
                );
        }

        // Initialize our DS cache.
        gpDSCache = &DSCache;
        if (!gpDSCache->Init()) {
            DPRINT(0, "Cache init failed!\n");
            KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
        }

        pLocalSite = gpDSCache->GetLocalSite();

        if (!gfLastServerCountSet) {
            gLastServerCount = pLocalSite->GetDsaList()->GetCount();
            gfLastServerCountSet = TRUE;
        }

        pIntraSiteCnList
            = gpDSCache->GetLocalDSA()->GetIntraSiteCnList();
            
        pInterSiteCnList
            = gpDSCache->GetLocalDSA()->GetInterSiteCnList();
            
        // For all connections inbound to the local DSA:
        //
        // 1. Make sure that if the source is in a different site, a transport
        //    type is set.  If not, set to IP and move the KCC_CONNECTION from
        //    the intra-site list to the inter-site list.
        //
        // 2. Make sure that if the source is in the same site, no transport
        //    type is set.  If it is, remote the transport type and move the
        //    KCC_CONNECTION from the inter-site list to the intra-site list.
        
        pIntraSiteCnList->UpdateTransportTypeForSite(pInterSiteCnList);
        pInterSiteCnList->UpdateTransportTypeForSite(pIntraSiteCnList);
        
        // Remove any duplicate intra-site connections from the list and from
        // the DS.
        pIntraSiteCnList->RemoveDuplicates(TRUE);

        if (!gLinkFailureCache.Refresh()) {
            DPRINT(0, "KCC_LINK_FAILURE_CACHE::Init failed.\n");
        }
        
        // Try to verify the staleness of all servers in the connection cache.
        // While we're at it, clear the 'fErrorOccurredThisRun' flags so that we know
        // if the errors occurred during this run of the KCC, or during an earlier run.
        if (!gConnectionFailureCache.Refresh()) {
            DPRINT(0, "KCC_LINK_FAILURE_CACHE::Init failed.\n");
        }


        // We use mark-sweep garbage collection to flush out any
        // unneeded non-imported connection failure cache entries.
        // First mark all non-imported entries as unneeded.
        // If we later have a DsBind() failure (contacting bridgeheads) or
        // a DirReplicaAdd() failure, they entries will be marked as needed.
        // Unneeded entries are flushed out at the end of the KCC run.
        gConnectionFailureCache.MarkUnneeded( FALSE );


        // For every naming context in the current site, build a topology
        // between DC's hosting each individual naming context; If the NC
        // we are considering at the local DC is a writeable NC include 
        // only DCs that hold master replicas of this NC in the site while 
        // generating the topology. If the NC we are considering at the local 
        // DC is a read-only NC (i.e. Partial NC) include both read-only & writeable
        // replicas of this NC in the site.
        GenerateIntraSiteTopologies(pIntraSiteCnList,
                                    &fKeepCurrentIntrasiteConnections);


        // Create connection objects as necessary to create spanning tree
        // of sites across enterprise
        GenerateInterSiteTopologies();

        // Remove the connection objects that existed at the beginning
        // of this task that were not needed by the current topology
        if (!pLocalSite->IsRemoveConnectionsDisabled()) {
            RemoveUnnecessaryConnections(pIntraSiteCnList,
                                         pLocalSite->GetObjectDN(),
                                         fKeepCurrentIntrasiteConnections);
        }

        // Coalesce replication links to topology implied by NTDS-Connection
        // objects.
        UpdateLinks();

        // Update Reps-To's with any changed network addresses and remove those
        // left as dangling references.
        UpdateRepsToReferences();

#ifdef ANALYZE_STATE_SERVER
        if (gfDumpStaleServerCaches) {
            gLinkFailureCache.Dump();
            gConnectionFailureCache.Dump();
        }
#endif

        // We use mark-sweep garbage collection to flush out any
        // unneeded non-imported connection failure cache entries.
        // All needed entries have been marked as such. We flush
        // out the unneeded entries now.
        gConnectionFailureCache.FlushUnneeded( FALSE );

    }
    __finally {
        *pcSecsUntilNextIteration = gcSecsBetweenTopologyUpdates;
        gpDSCache = NULL;
        gfIntrasiteSchedInited = FALSE;
        if( ! SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL) ) {
            dwErrCode = GetLastError();
            DPRINT1(0, "Failed to set the thread priority. Err=%d\n", dwErrCode);
        }
    }

    return 0;
}


VOID
KCC_TASK_UPDATE_REPL_TOPOLOGY::GenerateIntraSiteTopologies(
    IN OUT KCC_INTRASITE_CONNECTION_LIST *  pConnectionList,
    OUT    BOOL *                           pfKeepCurrentIntrasiteConnections
    )
/*++

Routine Description:

    This routine determines the site of the local dsa and then proceeds to
    make sure that the local DSA has connection objects necessary for the
    intra site configuration

Parameters:

    pConnectionList - a list of connections at the start of the topology
                      generator

Returns:

    None - the only errors are unexpected errors, a debug print or event log is
           made.
    
--*/
{
    KCC_SITE *  pLocalSite = gpDSCache->GetLocalSite();
    DSNAME *    pdnLocalSite = pLocalSite->GetObjectDN();
    DWORD       dwExceptionCode, ulErrorCode, dsid;
    PVOID       dwEA;

    // Unless we're entirely successful, keep the current intrasite connections.
    *pfKeepCurrentIntrasiteConnections = TRUE;

    if (pLocalSite->IsAutoTopologyEnabled()) {
        DPRINT1(1, "Building topology for site %ws\n",
                pdnLocalSite->StringName);
        __try {
            KccConstructTopologiesForSite(pConnectionList);

            // Intrasite topology constructed; okay to delete superfluous
            // connections.
            *pfKeepCurrentIntrasiteConnections = FALSE;
        }
        __except (GetExceptionData(GetExceptionInformation(), &dwExceptionCode,
                                   &dwEA, &ulErrorCode, &dsid)) {
            // Any exception is fatal - log that the automatic topology
            // did not complete for this site
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_KCC_AUTO_TOPL_GENERATION_INCOMPLETE,
                     szInsertDN(pdnLocalSite),
                     szInsertHex(ulErrorCode),
                     szInsertHex(dsid));
        }
    }
}

VOID
KCC_TASK_UPDATE_REPL_TOPOLOGY::GenerateInterSiteTopologies()
/*++

Routine Description:

    This routine determines the site of the local dsa and then proceeds to
    make sure that the local DSA has connection objects necessary for the
    intra site configuration

Parameters:

    None.

Returns:

    None - the only errors are unexpected errors, a debug print or event log is
           made.
    
--*/
{
    KCC_SITE *  pLocalSite = gpDSCache->GetLocalSite();
    DWORD       dwExceptionCode, ulErrorCode, dsid;
    PVOID       dwEA;

    if ( pLocalSite->IsInterSiteAutoTopologyEnabled() ) {

        DPRINT( 1, "Building site topology\n" );
        __try
        {
            KccConstructSiteTopologiesForEnterprise();
        }
        __except (GetExceptionData(GetExceptionInformation(), &dwExceptionCode,
                                   &dwEA, &ulErrorCode, &dsid)) {
            //
            // Any exception is fatal - log that the automatic topology
            // did not complete for this site
            //

            DSNAME * pdnLocalSite = pLocalSite->GetObjectDN();

            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_KCC_AUTO_TOPL_GENERATION_INCOMPLETE,
                szInsertDN(pdnLocalSite),
                szInsertHex(ulErrorCode),
                szInsertHex(dsid)
                );
        }
    }
}

void
KCC_TASK_UPDATE_REPL_TOPOLOGY::UpdateRepsToReferences()
/*++

Routine Description:

    Update Reps-To's with any changed network addresses and remove those
    left as dangling references.

Arguments:

    None.

Return Values:

    None.

--*/
{
    KCC_LINK_LIST   RepsToList;
    DSNAME *        pdnNC;
    DWORD           cLinks;
    DSTIME          timeNow;
    KCC_DSA *       pLocalDSA = gpDSCache->GetLocalDSA();

    ASSERT_VALID( this );

    timeNow = GetSecondsSince1601();

    // For each local NC...
    for ( DWORD iNC = 0; iNC < pLocalDSA->GetNCCount(); iNC++ )
    {
        // Get the NC name.
        pdnNC = pLocalDSA->GetNC( iNC );

        DPRINT1(
            2,
            "Checking for Reps-To updates on %ls.\n",
            pdnNC->StringName
            );

        if ( RepsToList.Init( pdnNC, ATT_REPS_TO ) )
        {
            // For each Reps-To value for this NC...
            cLinks = RepsToList.GetCount();

            for ( DWORD iLink = 0; iLink < cLinks; iLink++ )
            {
                KCC_LINK * plink = RepsToList.GetLink( iLink );
                ASSERT_VALID( plink );

                // If the server object corresponding to this NC does not
                // exist, and if the Reps-To was added/updated more than
                // 24 hours ago, delete the Reps-To value.

                // Also, if the server object does exist but is deleted,
                // delete the Reps-To value.

                BOOL fExists;
                BOOL fIsDeleted;

                fExists = KccObjectExists(
                                plink->GetDSAUUID(),
                                &fIsDeleted
                                );

                if (    (    !fExists
                          && (   plink->GetTimeOfLastSuccess()
                               < timeNow - 24*60*60 ) )
                     || ( fExists && fIsDeleted ) )
                {
                    plink->Delete(pdnNC,
                                  KCC_LINK_DEL_REASON_DANGLING_REPS_TO,
                                  ATT_REPS_TO,
                                  0);
                }
                else
                {
                    // This one's a keeper; does it have the right network
                    // address for the target server?

                    if ( fExists )
                    {
                        MTX_ADDR * pmtxRemote
                            = KCC_DSA::GetMtxAddr( plink->GetDSAUUID() );

                        if ( !MtxSame( pmtxRemote,
                                       plink->GetDSAAddr() ) )
                        {
                            // Wrong address; change it!
                            plink->SetDSAAddr( pmtxRemote );
                            plink->Update( pdnNC, ATT_REPS_TO );
                        }
                    }
                }
            }
        }
    }
}


VOID
KCC_TASK_UPDATE_REPL_TOPOLOGY::RemoveUnnecessaryConnections(
    IN OUT KCC_INTRASITE_CONNECTION_LIST *  pConnectionList,
    IN     DSNAME *                         pdnLocalSite,
    IN     BOOL                             fKeepCurrentIntrasiteConnections
    )
//
// Delete all intrasite KCC-generated connection objects that don't have a
// reason for existence
//
{
    ULONG Index;
    DSNAME * pdnLocalDSA = gpDSCache->GetLocalDSADN();

    Assert( pConnectionList );

    // If more than one connection exists from the same source DSA, keep the
    // best one and delete the others from the database.
    pConnectionList->RemoveDuplicates(TRUE);

    for (Index = 0;
         Index < pConnectionList->GetCount();
         /* Index++/count-- below */) {
        
        KCC_CONNECTION *pcn = pConnectionList->GetConnection( Index );

        // Inter-site connections are not present in the list.
        Assert(NULL == pcn->GetTransportDN());
        // If a server is moved to a different site while the KCC is running, it
        // is possible that a connection in this list may have a grandparent DN
        // which is different than the local site. The previous assertion is
        // good enough to guarantee that this is still an intra-site connection.
        
        // Remove unneeded intra-site connections.
        if (pcn->IsGenerated() 
            && pcn->GetReasonForConnection() == KCC_NO_REASON
            && !fKeepCurrentIntrasiteConnections) {
            // Ok, delete this
            pcn->Remove();
            pConnectionList->RemoveFromList(Index);
            delete pcn;
        } else {
            // We're keeping this connection
            // Update its reasons for living on the object itself
            pcn->UpdateReason();
            Index++;
        }
    }
}


KCC_DSA*
KCC_TASK_UPDATE_REPL_TOPOLOGY::GetDsaFromGuid(
    GUID       *pDsaGuid
    )
//
// Find the KCC_DSA object matching 'pDsaGuid'. If the object is in the
// cache, we return it. If the object is not found, return NULL.
//
{
    KCC_DSA    *pDsa;
    DSNAME      DN = {0};

    Assert(!fNullUuid(pDsaGuid));
    DN.Guid = *pDsaGuid;
    DN.structLen = DSNameSizeFromLen(0);

    // Do an in-memory search of all DSA objects.
    pDsa = gpDSCache->GetGlobalDSAListByGUID()->GetDsa( &DN, NULL );

    // Note: pDsa may be NULL if the server was not found.
    return pDsa;
}


void
KCC_TASK_UPDATE_REPL_TOPOLOGY::UpdateLinks()
//
// Create/update/delete local links based on connection objects.
//
// Internally the KCC keeps track of which NC's use a connection by the
// ReplicatesNC array. However, externally, applications depend on the fact
// that if a connection is present, replica links are created for all
// common NC's between those two systems. Thus the KCC can sometimes create
// extra replica links that are not strictly required according to the
// spanning tree.
//
{
    KCC_LINK_LIST                   *pLinkListLocal;
    DSNAME *                        pdnTransport;
    KCC_DSA *                       pLocalDSA = gpDSCache->GetLocalDSA();
    KCC_CROSSREF_LIST *             pCrossRefList = gpDSCache->GetCrossRefList();
    KCC_TRANSPORT_LIST *            pTransportList = gpDSCache->GetTransportList();
    KCC_INTRASITE_CONNECTION_LIST * pIntraSiteCnList = pLocalDSA->GetIntraSiteCnList();
    KCC_INTERSITE_CONNECTION_LIST * pInterSiteCnList = pLocalDSA->GetInterSiteCnList();
    DWORD                           iCR;
    KCC_LINK *                      pLink;
    #ifdef DBG
        struct LINKLISTCHECK {
            DWORD cr;
            GUID guid;
        };
        LINKLISTCHECK   *pLLCheck;
        DWORD           LLCMax, LLCSize, iLLC;
    #endif // DBG

    if (pLocalDSA->IsConnectionObjectTranslationDisabled()) {
        DPRINT(0, "Logical connection-to-replication link translation is disabled.\n");
        LogEvent(DS_EVENT_CAT_KCC,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_KCC_CONNECTION_OBJ_TRANSLATION_DISABLED,
                 NULL, NULL, NULL);
        return;
    }

    // Note that duplicates have already been removed from the intra-site list.
    // We remove the inter-site duplicates from the in-memory list only, not from
    // the DS -- deletion of inter-site objects is left to the ISTG.
    pInterSiteCnList->RemoveDuplicates();

    //
    // Ensure that existing links are in sync with the corresponding connection
    // objects.
    //

    for (DWORD iNC = 0; iNC < pLocalDSA->GetNCCount(); iNC++) {
        BOOL            fIsNCWriteable;
        DSNAME *        pdnNC = pLocalDSA->GetNC(iNC, &fIsNCWriteable);
        KCC_CROSSREF *  pCrossRef = pCrossRefList->GetCrossRefForNC(pdnNC);
        BOOL            fIsMaster;
        BOOL            fIsNCHost;
        KCC_LINK_LIST * pLinkListLocalNotCached = NULL;
        
        fIsNCHost = (NULL != pCrossRef)
                    && pLocalDSA->IsNCHost(pCrossRef,
                                           TRUE /* fIsLocal */,
                                           &fIsMaster);
        
        DPRINT1(2, "Checking for Reps-From updates on %ls.\n", pdnNC->StringName);

        // Find the link list for this NC
        if (NULL == pCrossRef) {
            // Local NC with no corresponding crossRef.
            pLinkListLocal = new KCC_LINK_LIST;
            if (pLinkListLocal->Init(pdnNC)) {
                // Remember to free this later.
                pLinkListLocalNotCached = pLinkListLocal;
            } else {
                // Failed to initialize list (e.g., DS error, memory pressure,
                // etc.).
                delete pLinkListLocal;
                pLinkListLocal = NULL;
            }
        } else {
            // NC has a corresponding crossRef -- get the cached link list.
            pLinkListLocal = pCrossRef->GetLinkList();
        }
        
        if (pLinkListLocal == NULL) {
            // Failed to construct link list due to low memory, etc.  We do
            // *not* get here if there simply are no links for this NC -- in
            // that case we have a valid, initialized link list with 0 entries.
            continue;
        }

        // Iterate through each link, then execute one more pass with
        // pLink == NULL (wherein we can do such things as tear down
        // NCs with no remaining sources, etc.).

        for (DWORD iLink = 0; iLink < (pLinkListLocal->GetCount() + 1);
             /* We update the index below because we might remove items from the list */
             )
        {
            KCC_LINK_DEL_REASON DeleteReason = KCC_LINK_DEL_REASON_NONE;

            if (iLink < pLinkListLocal->GetCount()) {
                pLink = pLinkListLocal->GetLink(iLink);
                ASSERT_VALID(pLink);
                Assert(!!pLink->IsLocalNCWriteable() == !!fIsNCWriteable);
            } else {
                pLink = NULL;
            }

            if (pLinkListLocal->IsNCGoing()) {
                // NC is in the process of being removed -- let it be.
                Assert(0 == pLinkListLocal->GetCount());
            } else if (!fIsNCHost) {
                if (NULL == pCrossRef) {
                    if (fIsNCWriteable) {
                        // NDNC crossRef has been deleted; remove replica.
                        // (Note we do not allow our domain crossRef to be
                        // deleted -- be it by an originating or replicated
                        // change.)
                        DeleteReason = KCC_LINK_DEL_REASON_NDNC_NO_CROSSREF;
                    } else {
                        // Domain has been removed from the enterprise;
                        // remove from GCs.
                        DeleteReason = KCC_LINK_DEL_REASON_READONLY_DOMAIN_REMOVED;
                    }
                } else if (!fIsNCWriteable) {
                    if (!pLocalDSA->IsGC()) {
                        // Remove read-only NC as local DSA is no longer a
                        // GC.
                        DeleteReason = KCC_LINK_DEL_REASON_READONLY_NOT_GC;
                    } else if (!pCrossRef->IsReplicatedToGCs()) {
                        // We're a GC and have instantiated a read-only
                        // replica of this NC, but it's not configured to
                        // be replicated to GCs.
                        DeleteReason = KCC_LINK_DEL_REASON_READONLY_NOT_HOSTED_BY_GCS;
                    }
                } else if ((KCC_NC_TYPE_NONDOMAIN == pCrossRef->GetNCType())
                           && !pCrossRef->IsDSAPresentInNCReplicaLocations(
                                                               pLocalDSA)) {
                    if (NULL != pLink) {
                        // Local DSA is no longer configured to be a replica
                        // of this NDNC.  Stop replicating from this source.
                        DeleteReason = KCC_LINK_DEL_REASON_NDNC_NOT_REPLICA_HOST;
                    } else {
                        // Local DSA is no longer configured to be a replica
                        // of this NDNC.  Rather than tearing down the NC
                        // outright, demote it such that any remaining
                        // updates and FSMO roles are transferred to another
                        // replica.
                        Assert(KCC_LINK_DEL_REASON_NONE == DeleteReason);
                        KCC_LINK::Demote(pCrossRef);
                    }
                } else {
                    // Why did we once decide to host this NC and now decide
                    // not to host it?
                    Assert(!"Can't determine why we should no longer host NC!");
                    LogUnhandledError(0);
                }
            } else if (!!fIsMaster != !!fIsNCWriteable) {
                // We should and do host a replica of this NC, but it is of
                // the wrong flavor -- i.e., we have a writeable replica and
                // need a read-only replica or vice versa.  This should
                // currently never happen, as NDNCs are the only writeable
                // NCs that can be added or removed from a DSA other than
                // during DCPROMO and NDNCs are currently speced never to
                // replicate to GCs (and therefore have no read-only
                // replicas).
                
                if (fIsMaster) {
                    // If this becomes a real supported path we should
                    // consider optimizing the transition from writeable to
                    // read-only (which should require no wire traffic).
                    DeleteReason = KCC_LINK_DEL_REASON_HAVE_WRITEABLE_NEED_READONLY;
                } else {
                    DeleteReason = KCC_LINK_DEL_REASON_HAVE_READONLY_NEED_WRITEABLE;
                }
            } else if (NULL != pLink) {
                // Attempt to find a connection object corresponding to this
                // link.
                KCC_CONNECTION * pcn;
                KCC_DSA *pSourceServer;
                BOOL fSourceIsMaster;
                UUID *pDsaUUID;

                pDsaUUID = pLink->GetDSAUUID();
                pSourceServer = GetDsaFromGuid( pDsaUUID );
                // Note: pSourceServer may be NULL if the server was not found.
                
                pcn = pIntraSiteCnList->GetConnectionFromSourceDSAUUID(pDsaUUID);
                if (NULL == pcn) {
                    pcn = pInterSiteCnList->GetConnectionFromSourceDSAUUID(pDsaUUID);
                }
                if (NULL == pcn) {
                    // No connection object for this link.
                    //
                    // Does it source from a DSA that is currently in a stay
                    // of execution (i.e., a DSA that has been recently
                    // deleted but still has time to revive its NTDS-DSA
                    // object)?
                    //
                    // When a server object is deleted, we keep trying to
                    // replicate from it for a certain period of time to
                    // allow it to see the deletion of its NTDS-DSA object
                    // and undelete it, which offers some measure of
                    // protection against inadvertent server deletion.
                    //
                    // Note that we provide an exception for the last source
                    // of a read-only NC so as to prevent the NC from being
                    // torn down, given that we've already evaluated that we
                    // should continue to host this NC.  In this case we're
                    // presumably shortly going to add a new source for this
                    // NC, after which point we'll be free to delete the
                    // old source.
                    //
                    // If pSourceServer is non-NULL, then this repsFrom's
                    // source server was found in the cache. This means that
                    // the server is not deleted, so the server is not in a
                    // stay of execution. So, we delete the repsFrom.
                    //
                    // If pSourceServer is NULL (i.e. it was not found in
                    // the cache), then the DSA must have been deleted.
                    // We check if the server is in a stay of execution.
                    // If it is not, then the repsFrom should be deleted.
                    // If the server is in a stay of execution, then we keep
                    // the repsFrom.
                    
                    if(   NULL!=pSourceServer
                       || !KccIsDSAInStayOfExecution(pDsaUUID))
                    {
                        // No connection object and not in stay of execution.
                        // Delete the replication link.
                        DeleteReason = KCC_LINK_DEL_REASON_NO_CONNECTION;
                    }
                } else if (NULL!=pSourceServer) {
                    if (!pSourceServer->IsNCHost(pCrossRef,
                                                 FALSE /* fIsLocal */,
                                                 &fSourceIsMaster)) {
                        // The NC is no longer instantiated on the source
                        // (e.g., we're a GC and the source was but is no
                        // longer a GC).
                        DeleteReason = KCC_LINK_DEL_REASON_SOURCE_NOT_HOST;
                    } else if (fIsNCWriteable && !fSourceIsMaster) {
                        // The source has a read-only replica and the local
                        // replica is writeable.
                        DeleteReason = KCC_LINK_DEL_REASON_SOURCE_READONLY;
                    } else if (!gfAllowMbrBetweenDCsOfSameDomain
                               && pLink->IsLocalNCWriteable()
                               && (KCC_NC_TYPE_SCHEMA != pCrossRef->GetNCType())
                               && (KCC_NC_TYPE_CONFIG != pCrossRef->GetNCType())
                               && (NULL != (pdnTransport = pcn->GetTransportDN()))
                               && !KCC_TRANSPORT::IsIntersiteIP(pdnTransport)) {
                        // This is not a viable transport for this NC.  By
                        // decree, writeable domain NCs must be replicated
                        // over IP.
                        LogEvent8(DS_EVENT_CAT_KCC,
                                  DS_EVENT_SEV_ALWAYS,
                                  DIRLOG_CHK_INVALID_TRANSPORT_FOR_WRITEABLE_DOMAIN_NC,
                                  szInsertDN(pcn->GetConnectionDN()),
                                  szInsertDN(pcn->GetSourceDSADN()),
                                  szInsertDN(pLocalDSA->GetDsName()),
                                  szInsertDN(pdnNC),
                                  szInsertDN(pdnTransport),
                                  NULL, NULL, NULL);
                    } else {
                        // Update link with any changes implied by this
                        // ntdsConnection object.
                        pcn->UpdateLink(pLink,
                                        pCrossRef,
                                        pLocalDSA->GetSiteDN(),
                                        pTransportList);
                    }
                }
            }

            // Delete the link if we deemed there to be a reason to do so.
            if (KCC_LINK_DEL_REASON_NONE != DeleteReason) {
                KCC_LINK::Delete(pLink, pdnNC, DeleteReason);

                if (NULL != pLink) {
                    // Now we remove this link from pLinkListLocal to keep our
                    // cache consistent.
                    pLinkListLocal->RemoveLink(iLink);
                
                    // Don't increment index because list has shrunk
                } else {
                    // This was the "NC granular" rather than "(NC,source)
                    // granular" pass, which is now complete.
                    iLink++;
                }
            } else {
                iLink++;
            }

        }

        if (NULL != pLinkListLocalNotCached) {
            delete pLinkListLocalNotCached;
        }
    }

    
    //
    // Now that we have done our best to synchronize existing links with
    // their corresponding connection objects, create any links that
    // do not yet exist.
    //

    #ifdef DBG
        // Allocate a list of LINKLISTCHECK objects
        // When we go to look up an item in a link list
        LLCSize = 0;
        LLCMax = (pIntraSiteCnList->GetCount() + pInterSiteCnList->GetCount())
            * pCrossRefList->GetCount();
        pLLCheck = new LINKLISTCHECK[ LLCMax ];
    #endif // DBG
    

    for (DWORD icn = 0;
         icn < pIntraSiteCnList->GetCount() + pInterSiteCnList->GetCount();
         icn++) {
        KCC_CONNECTION * pcn;

        pcn = (icn < pIntraSiteCnList->GetCount())
                ? pIntraSiteCnList->GetConnection(icn)
                : pInterSiteCnList->GetConnection(icn - pIntraSiteCnList->GetCount());
        Assert(NULL != pcn);

        DPRINT2(4, "Checking for new Reps-From on connection %ws source %ws\n",
                pcn->GetConnectionDN()->StringName,
                pcn->GetSourceDSADN()->StringName);

        if (0 == memcmp(&pLocalDSA->GetDsName()->Guid,
                        &pcn->GetSourceDSADN()->Guid,
                        sizeof(GUID))) {
            // Can't replicate from self!
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CHK_CANT_REPLICATE_FROM_SELF,
                     szInsertDN(pcn->GetConnectionDN()),
                     NULL,
                     NULL);
        } else if (pcn->IsEnabled()) {
            KCC_DSA *pdsaRemote = pcn->GetSourceDSA();
            for (iCR = 0; iCR < pCrossRefList->GetCount(); iCR++) {
                KCC_CROSSREF * pCrossRef = pCrossRefList->GetCrossRef(iCR);
                BOOL fIsRemoteMaster;
                BOOL fIsLocalMaster;

                if (pdsaRemote->IsNCHost(pCrossRef,
                                       FALSE /* fIsLocal */,
                                       &fIsRemoteMaster)
                    && pLocalDSA->IsNCHost(pCrossRef,
                                           TRUE /* fIsLocal */,
                                           &fIsLocalMaster)
                    && (!fIsLocalMaster || fIsRemoteMaster)) {
                    
                    // now we know we _should_ have a link; do we?
                    pLinkListLocal = pCrossRef->GetLinkList();
                    if ((NULL != pLinkListLocal)
                        && (NULL == pLinkListLocal->GetLinkFromSourceDSAObjGuid(
                                            &pcn->GetSourceDSADN()->Guid))) {
                        // We don't yet have a link to replicate this NC from
                        // pcn->GetSourceDSADN().
#if DBG
                        for( iLLC=0; iLLC<LLCSize; iLLC++ ) {
                            int cmp;
                            cmp = memcmp(
                                    &pLLCheck[iLLC].guid,
                                    &pcn->GetSourceDSADN()->Guid,
                                    sizeof(GUID) );
                            if( pLLCheck[iLLC].cr==iCR && 0==cmp ) {
                                Assert( 0 && "Didn't add entry to link list but should have!" );
                            }
                        }
#endif // DBG
                        if (!gfAllowMbrBetweenDCsOfSameDomain
                            && fIsLocalMaster
                            && (KCC_NC_TYPE_DOMAIN == pCrossRef->GetNCType())
                            && (NULL != (pdnTransport = pcn->GetTransportDN()))
                            && !KCC_TRANSPORT::IsIntersiteIP(pdnTransport)) {
                            // This is not a viable transport for this
                            // NC.  By decree, writeable domain NCs must
                            // be replicated over IP.
                            DPRINT3(0, "Connection %ls cannot replicate writeable domain NC %ls over non-IP transport %ls.\n",
                                    pcn->GetConnectionDN()->StringName,
                                    pCrossRef->GetNCDN()->StringName,
                                    pdnTransport->StringName);
                            LogEvent8(DS_EVENT_CAT_KCC,
                                      DS_EVENT_SEV_ALWAYS,
                                      DIRLOG_CHK_INVALID_TRANSPORT_FOR_WRITEABLE_DOMAIN_NC,
                                      szInsertDN(pcn->GetConnectionDN()),
                                      szInsertDN(pcn->GetSourceDSADN()),
                                      szInsertDN(pLocalDSA->GetDsName()),
                                      szInsertDN(pCrossRef->GetNCDN()),
                                      szInsertDN(pdnTransport),
                                      NULL, NULL, NULL);
                        } else {
                            // Link doesn't yet exist; add it.
                            pcn->AddLink(pCrossRef,
                                         fIsLocalMaster,
                                         pLocalDSA->GetSiteDN(),
                                         pLocalDSA,
                                         pdsaRemote,
                                         pTransportList);
                            // 
                            // After adding the link to the DS, we should also update the link cache
                            // for this NC. However, we will never search the cache for this new link,
                            // so we don't actually need to update the cache.
                            //
                            // Why do we never search the cache for this link? Earlier, we removed all
                            // duplicate connections from the pIntra/InterSiteCnList lists. Therefore all
                            // connections will have distinct source DSA's. Therefore, the above function
                            // ppLinkListCache[ NC ]->GetLinkFromSourceDSAObjGuid( DSA ) will never be
                            // called with the same (NC,DSA) parameters.
                            // 
                            
                            // The following bit of code adds the cross-ref index and the guid for
                            // the link we just created into an array called 'pLLCheck'. Later, when
                            // we search for links, we check this cache to make sure we're not searching
                            // for a link we should have added.
                            #if DBG
                                Assert( LLCSize<LLCMax );
                                pLLCheck[LLCSize].cr = iCR;
                                pLLCheck[LLCSize].guid = pcn->GetSourceDSADN()->Guid;
                                LLCSize++;
                            #endif
                        }
                    }
                }
            }
        }
    }

    #ifdef DBG
        delete [] pLLCheck;
    #endif
    

    // Update any servers that didn't repond to our attempts
    // to initiate a replication connection
    gConnectionFailureCache.IncrementFailureCounts();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kcctrans.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcctrans.cxx

              
ABSTRACT:

    KCC_TRANSPORT

DETAILS:

    This class represents the ds object Inter-Site Transport Type

CREATED:

    12/05/97    Colin Brace ( ColinBr )

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include "kcc.hxx"
#include "kccconn.hxx"
#include "kcclink.hxx"
#include "kccdsa.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include "kcccref.hxx"


#include "kcctrans.hxx"


#define FILENO FILENO_KCC_KCCTRANS

//
// KCC_TRANSPORT methods
//

void
KCC_TRANSPORT::Reset()
// Reset member variables to their pre-Init() state.
{
    m_fIsInitialized = FALSE;
    m_pdn = NULL;
    m_attAddressType = 0;
    m_dwOptions = 0;
    m_dwReplInterval = 0;
    m_fIsSiteLinkListInitialized = FALSE;
    m_SiteLinkList.Reset();
    m_fIsBridgeListInitialized = FALSE;
    m_BridgeList.Reset();
    m_AllExplicitBridgeheadArray.RemoveAll();
}


BOOL
KCC_TRANSPORT::Init(
    IN  ENTINF *    pEntInf
    )
// Init the object given its ds properties
{

    DWORD   iAttr, cAttr, iAttrVal;
    ATTR *  pAttr;
    DWORD   cbVal;
    BYTE *  pbVal;

    Reset();

    m_pdn = pEntInf->pName;

    if( IsIntersiteIP(m_pdn) ) {
        // Default is schedules significant, bridges not required (transitive)
        m_dwOptions = 0;
    } else {
        // Default is schedules not significant, bridges not required (transitive)
        m_dwOptions = NTDSTRANSPORT_OPT_IGNORE_SCHEDULES;
    }

    for ( iAttr = 0, cAttr = pEntInf->AttrBlock.attrCount; 
            iAttr < cAttr; 
                iAttr++ )
    {
        pAttr = &pEntInf->AttrBlock.pAttr[ iAttr ];
        cbVal = pAttr->AttrVal.pAVal->valLen;
        pbVal = pAttr->AttrVal.pAVal->pVal;

        Assert( pAttr->attrTyp == ATT_BRIDGEHEAD_SERVER_LIST_BL ||
                1 == pAttr->AttrVal.valCount ); // most should be single-valued

        switch ( pAttr->attrTyp )
        {
        case ATT_BRIDGEHEAD_SERVER_LIST_BL:
            for ( iAttrVal = 0; iAttrVal < pAttr->AttrVal.valCount; iAttrVal++ )
            {
                DSNAME *pdnServer = (DSNAME *) pAttr->AttrVal.pAVal[ iAttrVal ].pVal;

                m_AllExplicitBridgeheadArray.Add( pdnServer );
            }
            // This does not need to be sorted
            break;

        case ATT_TRANSPORT_ADDRESS_ATTRIBUTE:
            Assert( cbVal == sizeof(ATTRTYP) );
            m_attAddressType = *((ATTRTYP *) pbVal);
            break;

        case ATT_OPTIONS:
            Assert( cbVal == sizeof(DWORD) );
            m_dwOptions = *((DWORD *) pbVal);
            break;

        case ATT_REPL_INTERVAL:
            Assert( cbVal == sizeof(DWORD) );
            m_dwReplInterval = *((DWORD *) pbVal);
            break;

        default:
            DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pAttr->attrTyp );
            break;
        }
    }

    m_fIsInitialized = TRUE;

    return m_fIsInitialized;
}

BOOL
KCC_TRANSPORT::IsValid()
// Is the object initialized and internally consistent ?
{
    return m_fIsInitialized;
}

DSNAME*
KCC_TRANSPORT::GetDN()
// Retrieve the DN of the object
{
    ASSERT_VALID( this );

    return m_pdn;
}

ATTRTYP
KCC_TRANSPORT::GetAddressType()
// Retrieve the ATTRTYP of the transport-specific address attribute.
// This ATTRTYP is an optional attribute of server objects.
{
    ASSERT_VALID( this );

    return m_attAddressType;
}

void
KCC_TRANSPORT::ReadSiteLinkList()
{
    ASSERT_VALID(this);
    Assert(!m_fIsSiteLinkListInitialized);

    if (!m_SiteLinkList.Init(this)) {
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }

    m_fIsSiteLinkListInitialized = TRUE;
}

void
KCC_TRANSPORT::ReadBridgeList()
{
    ASSERT_VALID(this);
    Assert(!m_fIsBridgeListInitialized);

    if (!m_BridgeList.Init(this)) {
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }

    m_fIsBridgeListInitialized = TRUE;
}

KCC_DSNAME_ARRAY *
KCC_TRANSPORT::GetExplicitBridgeheadsForSite(
    KCC_SITE *pSite
    )
//
// An array of DSNAMES of DSA objects is returned
//
// This is not currently cached on the assumption that higher level caching
// prevents this from being called more than once per site
//
// This approach to generating the list of explicit bridgeheads for a site is
// to walk the list of all bridgeheads on the transport. The alternative is to
// do a deep search for the set of server objects which have that bridgehead
// transport. I think it will be cheaper to read the per-transport list in once
// and seach that in memory. What makes this funky is that it is the SERVER
// object that is marked.  Since the KCC deals with the DSA object, a means is
// required to map the server to its corresponding DSA.
{
    DWORD iServer;
    KCC_DSNAME_ARRAY *pSiteArray = NULL;
    WCHAR       szRDN[]  = L"NTDS Settings";
    DWORD       cchRDN   = lstrlenW(szRDN);
    ULONG       cbNtdsDsaSettings;
    DSNAME *    pdnNtdsDsaSettings;

    for( iServer =0; iServer < m_AllExplicitBridgeheadArray.GetCount(); iServer++ ) {
        DSNAME *pdnServer = m_AllExplicitBridgeheadArray[iServer];

        if (NamePrefix(pSite->GetObjectDN(), pdnServer)) {

            if (!pSiteArray) {
                // Allocate array first time, only if needed
                pSiteArray = new KCC_DSNAME_ARRAY;
            }

            // Prepend NTDS Settings to server dn to make DSA dn
            cbNtdsDsaSettings = pdnServer->structLen
                + (MAX_RDN_SIZE + MAX_RDN_KEY_SIZE)
                * sizeof(WCHAR);
            pdnNtdsDsaSettings = (DSNAME *) new BYTE [cbNtdsDsaSettings];
        
            AppendRDN(pdnServer,
                      pdnNtdsDsaSettings,
                      cbNtdsDsaSettings,
                      szRDN,
                      cchRDN,
                      ATT_COMMON_NAME);

            // Note, these DSNAMES have no GUIDs. This is ok.
            pSiteArray->Add( pdnNtdsDsaSettings );

            pdnNtdsDsaSettings = NULL;
        }
    }

    // Sort the array so that isElementOf will work efficiently
    if (pSiteArray) {
        pSiteArray->Sort();
    }

    return pSiteArray;
}














//
// KCC_TRANSPORT_LIST methods
//
void
KCC_TRANSPORT_LIST::Reset()
{
    m_fIsInitialized = FALSE;
    m_pTransports = NULL;
    m_cTransports = 0;
}

BOOL
KCC_TRANSPORT_LIST::IsValid()
// Is the object initialized and internally consistent ?
{
    return m_fIsInitialized;
}

BOOL
KCC_TRANSPORT_LIST::Init()
{

    ATTR      rgAttrs[] =
    {
        { ATT_TRANSPORT_ADDRESS_ATTRIBUTE, { 0, NULL } },
        { ATT_OPTIONS, { 0, NULL } },
        { ATT_REPL_INTERVAL, { 0, NULL } },
        { ATT_BRIDGEHEAD_SERVER_LIST_BL, { 0, NULL } }
    };

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    DWORD               dwTransportClass = CLASS_INTER_SITE_TRANSPORT;


    DSNAME *    pdnConfigNC = gpDSCache->GetConfigNC();
    WCHAR       szTransportsContainerPrefix[]  = L"CN=Inter-Site Transports,CN=Sites,";
    ULONG       cbTransportsContainer = pdnConfigNC->structLen +
                                     ARRAY_SIZE(szTransportsContainerPrefix) * sizeof(WCHAR);
    DSNAME *    pdnTransportsContainer = (DSNAME *) new BYTE[cbTransportsContainer];


    ULONG               dirError;
    FILTER              Filter;
    SEARCHRES *         pResults;
    ENTINFLIST *        pEntInfList;

    // Clear the member variables
    Reset();

    // Set up the search filter
    memset( &Filter, 0, sizeof( Filter ) );

    Filter.choice                  = FILTER_CHOICE_ITEM;
    Filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;

    Filter.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CLASS;
    Filter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof( dwTransportClass );
    Filter.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) &dwTransportClass;

    // Set up the root search dn
    wcscpy(pdnTransportsContainer->StringName, szTransportsContainerPrefix);
    wcscat(pdnTransportsContainer->StringName, pdnConfigNC->StringName);
    pdnTransportsContainer->NameLen = wcslen(pdnTransportsContainer->StringName);
    pdnTransportsContainer->structLen = DSNameSizeFromLen(pdnTransportsContainer->NameLen);
    Assert(0 == pdnTransportsContainer->SidLen);
    Assert(fNullUuid(&pdnTransportsContainer->Guid));
    
    dirError = KccSearch(
        pdnTransportsContainer,
        SE_CHOICE_IMMED_CHLDRN,
        &Filter,
        &Sel,
        &pResults
        );

    if ( 0 != dirError )
    {
        KCC_LOG_SEARCH_FAILURE( pdnTransportsContainer, dirError );
    }
    else
    {
        if ( 0 == pResults->count )
        {
           DPRINT( 0, "No transport objects found.\n" );
        }
        else
        {
            // Note that the internal representation of the transport list is a
            // little non-standard. Instead of being a pointer to an array of
            // pointers to objects, this is an array of the objects themselves.
            m_pTransports = new KCC_TRANSPORT[ pResults->count ];

            m_cTransports = 0;
            for ( pEntInfList = &pResults->FirstEntInf;
                  NULL != pEntInfList;
                  pEntInfList = pEntInfList->pNextEntInf
                )
            {
                KCC_TRANSPORT * pTransport = &(m_pTransports)[ m_cTransports ];

                if ( pTransport->Init( &pEntInfList->Entinf ) )
                {
                    m_cTransports++;
                }
                else
                {
                    if (  pEntInfList->Entinf.pName
                       && pEntInfList->Entinf.pName->StringName )
                    {
                        DPRINT1( 0, "Initialization of transport object %ls failed\n",
                                pEntInfList->Entinf.pName->StringName );
                    }
                    else
                    {
                        DPRINT( 0, "Initialization of transport object (NULL) failed\n" );
                    }
                }
            }
        }

        m_fIsInitialized = TRUE;

    }

    return m_fIsInitialized;

}

ULONG
KCC_TRANSPORT_LIST::GetCount()
{

    ASSERT_VALID( this );

    return m_cTransports;
}

KCC_TRANSPORT*
KCC_TRANSPORT_LIST::GetTransport(
    ULONG i
    )
{

    ASSERT_VALID( this );

    Assert( i < m_cTransports );

    if ( i < m_cTransports )
    {
        return &m_pTransports[ i ];
    }

    return NULL;
}



KCC_TRANSPORT*
KCC_TRANSPORT_LIST::GetTransport(
    DSNAME *pdnTransport
    )
{
    KCC_TRANSPORT * ptp;
    KCC_TRANSPORT * ptpReturn = NULL;
    DSNAME        * pdnCurrent;
    ULONG           itp;

    ASSERT_VALID( this );

    Assert( pdnTransport );

    for ( itp = 0; itp < m_cTransports; itp++ )
    {
        ptp  = &m_pTransports[ itp ];
        ASSERT_VALID( ptp );

        pdnCurrent = ptp->GetDN();
        Assert( pdnCurrent );

        if ( KccIsEqualGUID( &pdnCurrent->Guid, 
                             &pdnTransport->Guid ) )
        {
            //
            // This is it; pcn is the one we want
            //
            ptpReturn = ptp;
            break;
        }
    }

    return ptpReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\buildcfg.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    buildcfg.c

ABSTRACT:

    Configuration Builder.  Loads INI files.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <attids.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "ldif.h"
#include "user.h"
#include "buildcfg.h"

BUILDCFG_GLOBALS                    globals;

RTL_GENERIC_COMPARE_RESULTS
NTAPI
BuildCfgCompareUuids (
    IN  PRTL_GENERIC_TABLE          pTable,
    IN  PVOID                       pFirstStruct,
    IN  PVOID                       pSecondStruct
    )
/*++

Routine Description:

    Compares two UUIDs.  For use with an RTL_GENERIC_TABLE.

Arguments:

    pTable              - The table containing the UUIDs.
    pFirstStruct        - The first UUID.
    pSecondStruct       - The second UUID.

Return Value:

    GenericLessThan, GenericEqual or GenericGreaterThan.

--*/
{
    INT                             iCmp;
    RTL_GENERIC_COMPARE_RESULTS     result;

    iCmp = memcmp (pFirstStruct, pSecondStruct, sizeof (UUID));
    if (iCmp < 0) {
        result = GenericLessThan;
    } else if (iCmp > 0) {
        result = GenericGreaterThan;
    } else {
        Assert (iCmp == 0);
        result = GenericEqual;
    }

    return result;
}

VOID
BuildCfgMakeUuids (
    IN  ULONG                       ulNumUuids
    )
/*++

Routine Description:

    Creates a bunch of UUIDs and sorts them in ascending order.

Arguments:

    ulNumUuids          - The number of UUIDs to make.

Return Value:

    None.

--*/
{
    UUID                            uuid;
    ULONG                           ul;

    RtlInitializeGenericTable (
        &globals.tableUuids,
        BuildCfgCompareUuids,
        KCCSimTableAlloc,
        KCCSimTableFree,
        NULL
        );

    for (ul = 0; ul < ulNumUuids; ul++) {
        KCCSIM_CHKERR (UuidCreate (&uuid));
        RtlInsertElementGenericTable (
            &globals.tableUuids,
            &uuid,
            sizeof (UUID),
            NULL
            );
    }

    RtlEnumerateGenericTable (&globals.tableUuids, TRUE);
}

LPCWSTR
BuildCfgGetFirstStringByKey (
    IN  LPCWSTR                     pwszStringBlock,
    IN  LPCWSTR                     pwszKey
    )
/*++

Routine Description:

    When parsing INI files, we want to avoid GetPrivateProfileStringW for
    two reasons: first, it is very slow, and second, it does not recognize
    keys with multiple values.  This function provides a substitute.  It
    scans through a multi-string returned by GetPrivateProfileSectionW for
    a given key and returns the associated value.  Additional values can be
    obtained by calling BuildCfgGetNextStringByKey.

Arguments:

    pwszStringBlock     - A block of strings returned by
                          GetPrivateProfileSectionW.
    pwszKey             - The key to search for.

Return Value:

    The associated value, or NULL if the key cannot be found.

--*/
{
    LPCWSTR                         pwszKeyAt = pwszStringBlock;
    LPCWSTR                         pwszString = NULL;
    ULONG                           ulKeyAtLen;

    while (*pwszKeyAt != L'\0') {

        // Get the key length of this entry
        for (ulKeyAtLen = 0; pwszKeyAt[ulKeyAtLen] != L'='; ulKeyAtLen++) {
            // We should never hit a \0 or space before an =
            Assert (pwszKeyAt[ulKeyAtLen] != L' ');
            Assert (pwszKeyAt[ulKeyAtLen] != L'\0');
        }

        if (wcslen (pwszKey) == ulKeyAtLen &&
            _wcsnicmp (pwszKey, pwszKeyAt, ulKeyAtLen) == 0) {
            pwszString = pwszKeyAt + (ulKeyAtLen + 1);
            break;
        }

        // Advance to the next string
        pwszKeyAt += (wcslen (pwszKeyAt) + 1);
    }

    return pwszString;
}

LPCWSTR
BuildCfgDemandFirstStringByKey (
    IN  LPCWSTR                     pwszFn,
    IN  LPCWSTR                     pwszSection,
    IN  LPCWSTR                     pwszStringBlock,
    IN  LPCWSTR                     pwszKey
    )
/*++

Routine Description:

    Same as BuildCfgGetFirstStringByKey, but raises an exception if they key
    is not found.

Arguments:

    pwszFn              - The filename of the INI file.  Used for error
                          reporting.
    pwszSection         - The name of the INI file section.  Also used for
                          error reporting.
    pwszStringBlock     - A block of strings returned by
                          GetPrivateProfileSectionW.
    pwszKey             - The key to search for.

Return Value:

    The associated value.  Never returns NULL.

--*/
{
    LPCWSTR                         pwszString;

    pwszString = BuildCfgGetFirstStringByKey (pwszStringBlock, pwszKey);
    if (pwszString == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_KEY_ABSENT,
            pwszFn,
            pwszSection,
            pwszKey
            );
    }

    return pwszString;
}

LPCWSTR
BuildCfgGetNextStringByKey (
    IN  LPCWSTR                     pwszString,
    IN  LPCWSTR                     pwszKey
    )
/*++

Routine Description:

    Returns the next value associated with a particular key.

Arguments:

    pwszString          - The previous value, returned by
                          BuildCfgGetFirstStringByKey or
                          BuildCfgGetNextStringByKey.
    pwszKey             - The key to search for.

Return Value:

    The next associated value, or NULL if no more exist.

--*/
{
    // Advance to the next string
    pwszString += (wcslen (pwszString) + 1);
    return BuildCfgGetFirstStringByKey (pwszString, pwszKey);
}

LPWSTR
BuildCfgAllocGetSection (
    IN  LPCWSTR                     pwszFn,
    IN  LPCWSTR                     pwszSection
    )
/*++

Routine Description:

    Retrieves a section from the INI file, allocating space to hold it.

Arguments:

    pwszFn              - The filename of the INI file.
    pwszSection         - The name of the section.

Return Value:

    The section, as a multisz string, or NULL if it does not exist.

--*/
{
    DWORD                           dwBufSize;
    DWORD                           dwBufUsed;
    LPWSTR                          pwszBuf = NULL;

    dwBufSize = 0;
    while (TRUE) {
        dwBufSize += 1024;
        pwszBuf = KCCSimAlloc (sizeof (WCHAR) * dwBufSize);
        dwBufUsed = GetPrivateProfileSectionW (
            pwszSection,
            pwszBuf,
            dwBufSize,
            pwszFn
            );
        if (dwBufUsed == dwBufSize - 2) {
            KCCSimFree (pwszBuf);
        } else {
            break;
        }
    }

    return pwszBuf;
}

LPWSTR
BuildCfgAllocDemandSection (
    IN  LPCWSTR                     pwszFn,
    IN  LPCWSTR                     pwszSection
    )
/*++

Routine Description:

    Same as BuildCfgAllocGetSection, but raises an exception if the section
    does not exist.

Arguments:

    pwszFn              - The filename of the INI file.
    pwszSection         - The name of the section.

Return Value:

    The section, as a multisz string.  Never returns NULL.

--*/
{
    LPWSTR                          pwszBuf;

    pwszBuf = BuildCfgAllocGetSection (pwszFn, pwszSection);

    if (pwszBuf[0] == L'\0') {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_SECTION_ABSENT,
            pwszFn,
            pwszSection
            );
    }

    return pwszBuf;
}

VOID
BuildCfgProcessServers (
    IN  LPCWSTR                     pwszFn,
    IN  LPCWSTR                     pwszSiteName,
    IN  PSIM_ENTRY                  pEntryServersContainer,
    IN  LPCWSTR                     pwszServerType,
    IN  ULONG                       ulNumServers,
    IN  PSIM_ENTRY                  pEntryNTDSSiteSettings
    )
/*++

Routine Description:

    Creates servers within a site.

Arguments:

    pwszFn              - The filename of the INI file.
    pwszSiteName        - The name of the site in which to place the servers.
    pEntryServersContainer - The entry that corresponds to the servers
                          container of this site.
    pwszServerType      - The server type (section heading) to create.
    ulNumServers        - The number of servers to create.
    pEntryNTDSSiteSettings - The entry that corresponds to the NTDS Site
                          Settings object of this site.

Return Value:

    None.

--*/
{
    LPWSTR                          pwszSectionServer = NULL;

    LPCWSTR                         pwszServerOptions, pwszDomain, pwszRDNMask,
                                    pwszBridgehead[BUILDCFG_NUM_TRANSPORTS];

    PSIM_ENTRY                      pEntryServer;
    ULONG                           ulServerOptions, ulServerNum, ul,
                                    ulBridgeheadAt;

    Assert (globals.pdnRootDomain != NULL);

    Assert (pEntryServersContainer != NULL);

    if (pwszServerType[0] == L'\0') {
        // Generic servers.
        ulServerOptions = 0;
        pwszRDNMask = BUILDCFG_GENERIC_SERVER_ID;
        pwszDomain = globals.pdnRootDomain->StringName;
        pwszBridgehead[0] = NULL;
    } else {

        ulServerOptions = 0;

        pwszSectionServer = BuildCfgAllocDemandSection (
            pwszFn,
            pwszServerType
            );
        pwszServerOptions = BuildCfgGetFirstStringByKey (
            pwszSectionServer,
            BUILDCFG_KEY_SERVEROPTIONS
            );

        if (pwszServerOptions != NULL) {
            for (ul = 0; pwszServerOptions[ul] != L'\0'; ul++) {
                switch (towupper (pwszServerOptions[ul])) {
                    case KCCSIM_CID_NTDSDSA_OPT_IS_GC:
                        ulServerOptions |= NTDSDSA_OPT_IS_GC;
                        break;
                    case KCCSIM_CID_NTDSDSA_OPT_DISABLE_INBOUND_REPL:
                        ulServerOptions |= NTDSDSA_OPT_DISABLE_INBOUND_REPL;
                        break;
                    case KCCSIM_CID_NTDSDSA_OPT_DISABLE_OUTBOUND_REPL:
                        ulServerOptions |= NTDSDSA_OPT_DISABLE_OUTBOUND_REPL;
                        break;
                    case KCCSIM_CID_NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE:
                        ulServerOptions |= NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE;
                        break;
                    case L' ':
                        break;
                    default:
                        KCCSimException (
                            KCCSIM_ETYPE_INTERNAL,
                            BUILDCFG_ERROR_INVALID_SERVER_OPTION,
                            pwszFn,
                            pwszServerType,
                            pwszServerOptions
                            );
                        break;
                }
            }
        }

        pwszDomain = BuildCfgGetFirstStringByKey (
            pwszSectionServer,
            BUILDCFG_KEY_DOMAIN
            );
        if (pwszDomain == NULL) {
            pwszDomain = globals.pdnRootDomain->StringName;
        }

        pwszRDNMask = BuildCfgGetFirstStringByKey (
            pwszSectionServer,
            BUILDCFG_KEY_RDNMASK
            );
        if (pwszRDNMask == NULL) {
            pwszRDNMask = pwszServerType;
        }

        // Determine the transports for which this type of server is an
        // explicit bridgehead.
        ulBridgeheadAt = 0;
        for (pwszBridgehead[ulBridgeheadAt] = BuildCfgGetFirstStringByKey (
                pwszSectionServer, BUILDCFG_KEY_BRIDGEHEAD);
             pwszBridgehead[ulBridgeheadAt] != NULL;
             pwszBridgehead[ulBridgeheadAt] = BuildCfgGetNextStringByKey (
                pwszBridgehead[ulBridgeheadAt-1], BUILDCFG_KEY_BRIDGEHEAD)) {
            ulBridgeheadAt++;
        }

    }

    // Now actually add the servers.

    ulServerNum = 0;
    for (ul = 0; ul < ulNumServers; ul++) {

        pEntryServer = BuildCfgMakeServer (
            &ulServerNum,
            pwszRDNMask,
            pwszSiteName,
            pwszDomain,
            pEntryServersContainer,
            ulServerOptions
            );

        // For each transport that we're an explicit bridgehead for, add us
        // to the explicit bridgeheads list.
        for (ulBridgeheadAt = 0;
             pwszBridgehead[ulBridgeheadAt] != NULL;
             ulBridgeheadAt++) {
            BuildCfgAddAsBridgehead (
                pwszServerType,
                pEntryServer,
                pwszBridgehead[ulBridgeheadAt]
                );
        }

        ulServerNum++;
    }

    KCCSimFree (pwszSectionServer);
}

VOID
BuildCfgProcessSite (
    IN  LPCWSTR                     pwszFn,
    IN  LPCWSTR                     pwszSiteName
    )
/*++

Routine Description:

    Create a site.

Arguments:

    pwszFn              - The filename of the INI file.
    pwszSiteName        - The name of the site.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntrySite, pEntryServersContainer,
                                    pEntryNTDSSiteSettings, pEntryServer;

    LPWSTR                          pwszSectionSite;

    LPCWSTR                         pwszSiteOptions, pwszISTG,
                                    pwszServersInfo, pwszPos;
    ULONG                           ulSiteOptions,
                                    ulNumServers, ulServerOptions, ul;
    LPWSTR                          pwszNumEnd;

    Assert (globals.pEntrySitesContainer != NULL);

    pwszSectionSite = BuildCfgAllocDemandSection (
        pwszFn,
        pwszSiteName
        );
    pwszSiteOptions = BuildCfgGetFirstStringByKey (
        pwszSectionSite,
        BUILDCFG_KEY_SITEOPTIONS
        );
    ulSiteOptions = 0;
    if (pwszSiteOptions != NULL) {
        for (ul = 0; pwszSiteOptions[ul] != L'\0'; ul++) {
            switch (towupper (pwszSiteOptions[ul])) {
                case KCCSIM_CID_NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED:
                    ulSiteOptions |=
                    NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED;
                    break;
                case KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED:
                    ulSiteOptions |=
                    NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED;
                    break;
                case KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED:
                    ulSiteOptions |=
                    NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED;
                    break;
                case KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED:
                    ulSiteOptions |=
                    NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED;
                    break;
                case KCCSIM_CID_NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED:
                    ulSiteOptions |=
                    NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED;
                    break;
                case L' ':
                    break;
                default:
                    KCCSimException (
                        KCCSIM_ETYPE_INTERNAL,
                        BUILDCFG_ERROR_INVALID_SITE_OPTION,
                        pwszFn,
                        pwszSiteName,
                        pwszSiteOptions
                        );
                    break;
            }
            pwszSiteOptions++;
        }
    }

    pEntrySite = BuildCfgMakeSite (pwszSiteName, ulSiteOptions);
    pEntryServersContainer = KCCSimFindFirstChild (
        pEntrySite, CLASS_SERVERS_CONTAINER, NULL);
    pEntryNTDSSiteSettings = KCCSimFindFirstChild (
        pEntrySite, CLASS_NTDS_SITE_SETTINGS, NULL);
    Assert (pEntryServersContainer != NULL);
    Assert (pEntryNTDSSiteSettings != NULL);

    // Create the servers for this site
    for (pwszServersInfo = BuildCfgDemandFirstStringByKey (
            pwszFn, pwszSiteName, pwszSectionSite, BUILDCFG_KEY_SERVERS);
         pwszServersInfo != NULL;
         pwszServersInfo = BuildCfgGetNextStringByKey (
            pwszServersInfo, BUILDCFG_KEY_SERVERS)) {

        ulNumServers = wcstoul (pwszServersInfo, &pwszNumEnd, 10);
        if (ulNumServers == 0) {
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                BUILDCFG_ERROR_INVALID_SERVERS,
                pwszFn,
                pwszSiteName,
                pwszServersInfo
                );
        }

        while (*pwszNumEnd == L',' || *pwszNumEnd == L' ') {
            pwszNumEnd++;
        }

        BuildCfgProcessServers (
            pwszFn,
            pwszSiteName,
            pEntryServersContainer,
            pwszNumEnd,
            ulNumServers,
            pEntryNTDSSiteSettings
            );

    }

    // Set the inter-site topology generator.

    pwszISTG = BuildCfgDemandFirstStringByKey (
        pwszFn, pwszSiteName, pwszSectionSite, BUILDCFG_KEY_ISTG);

    if (!BuildCfgISTG (pEntryNTDSSiteSettings, pEntryServersContainer, pwszISTG)) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_INVALID_ISTG,
            pwszFn,
            pwszSiteName,
            pwszISTG
            );
    }

    KCCSimFree (pwszSectionSite);
}


BYTE CharToNibble( char c ) {
    if( c>='0' && c<='9' ) {
        return c-'0';
    }
    if( c>='A' && c<='F' ) {
        return c-'A'+10;
    }
    return 0;
}


VOID
BuildCfgProcessSiteLink (
    IN  LPCWSTR                     pwszFn,
    IN  LPCWSTR                     pwszSiteLink
    )
/*++

Routine Description:

    Create a site-link.

Arguments:

    pwszFn              - The filename of the INI file.
    pwszSiteLink        - The name of the site-link.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntrySiteLink;

    LPWSTR                          pwszSectionSiteLink;
    LPCWSTR                         pwszTransport, pwszSiteName,
                                    pwszSiteLinkOptions, pwszSchedule;
    ULONG                           ulCost, ulReplInterval,
                                    ulSiteLinkOptions, ul;
    DWORD                           cbSchedule, cbSchedData;
    DWORD                           iChar, cChar, iData;
    PSCHEDULE                       pSchedule;
    BYTE                           *pData,x;
    char*                           mbstr;

    pwszSectionSiteLink = BuildCfgAllocDemandSection (
        pwszFn,
        pwszSiteLink
        );

    pwszTransport = BuildCfgDemandFirstStringByKey (
        pwszFn,
        pwszSiteLink,
        pwszSectionSiteLink,
        BUILDCFG_KEY_TRANSPORT
        );
    ulCost = wcstoul (BuildCfgDemandFirstStringByKey (
        pwszFn,
        pwszSiteLink,
        pwszSectionSiteLink,
        BUILDCFG_KEY_COST
        ), NULL, 10);
    ulReplInterval = wcstoul (BuildCfgDemandFirstStringByKey (
        pwszFn,
        pwszSiteLink,
        pwszSectionSiteLink,
        BUILDCFG_KEY_REPLINTERVAL
        ), NULL, 10);
    pwszSiteLinkOptions = BuildCfgGetFirstStringByKey (
        pwszSectionSiteLink,
        BUILDCFG_KEY_SITELINKOPTIONS
        );
    ulSiteLinkOptions = 0;
    if (pwszSiteLinkOptions != NULL) {
        for (ul = 0; pwszSiteLinkOptions[ul] != L'\0'; ul++) {
            switch (towupper (pwszSiteLinkOptions[ul])) {
                case KCCSIM_CID_NTDSSITELINK_OPT_USE_NOTIFY:
                    ulSiteLinkOptions |= NTDSSITELINK_OPT_USE_NOTIFY;
                    break;
                case KCCSIM_CID_NTDSSITELINK_OPT_TWOWAY_SYNC:
                    ulSiteLinkOptions |= NTDSSITELINK_OPT_TWOWAY_SYNC;
                    break;
                case L' ':
                    break;
                default:
                    KCCSimException (
                        KCCSIM_ETYPE_INTERNAL,
                        BUILDCFG_ERROR_INVALID_SITELINK_OPTION,
                        pwszFn,
                        pwszSiteLink,
                        pwszSiteLinkOptions
                        );
                    break;
            }
        }
    }

    pwszSchedule = BuildCfgGetFirstStringByKey (
        pwszSectionSiteLink,
        BUILDCFG_KEY_SCHEDULE
        );
    if( pwszSchedule==NULL ) {
        pSchedule = NULL;
    } else {
        /* Create a schedule object */
        cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
        cbSchedData = SCHEDULE_DATA_ENTRIES;
        pSchedule = KCCSimAlloc( cbSchedule );
        pSchedule->Size = cbSchedule;
        pSchedule->NumberOfSchedules = 1;
        pSchedule->Schedules[0].Type = SCHEDULE_INTERVAL;
        pSchedule->Schedules[0].Offset = sizeof(SCHEDULE);
        pData = ((char*)pSchedule)+sizeof(SCHEDULE);
        memset( pData, 0, cbSchedData );

        cChar = wcslen(pwszSchedule);
        mbstr = KCCSimAlloc( 2*(cChar+1) );
        wcstombs( mbstr, pwszSchedule, 2*(cChar+1) );
        
        iChar=0; iData=0;
        while( iChar<cChar && iData<cbSchedData) {
            x = CharToNibble( mbstr[iChar++] );
            x <<= 4;
            if( iChar<cChar ) {
                x |= CharToNibble( mbstr[iChar++] );                
            }
            pData[iData++] = x;
        }

        KCCSimFree( mbstr );
    }

    pEntrySiteLink = BuildCfgMakeSiteLink (
        pwszTransport,
        pwszSiteLink,
        ulCost,
        ulReplInterval,
        ulSiteLinkOptions,
        pSchedule
        );

    if( pSchedule ) {
        KCCSimFree( pSchedule );
    }

    for (pwszSiteName = BuildCfgDemandFirstStringByKey (
            pwszFn, pwszSiteLink, pwszSectionSiteLink, BUILDCFG_KEY_SITE);
         pwszSiteName != NULL;
         pwszSiteName = BuildCfgGetNextStringByKey (
            pwszSiteName, BUILDCFG_KEY_SITE)) {

        BuildCfgAddSiteToSiteLink (pwszSiteLink, pEntrySiteLink, pwszSiteName);

    }

    KCCSimFree (pwszSectionSiteLink);
}

VOID
BuildCfgProcessBridge (
    IN  LPCWSTR                     pwszFn,
    IN  LPCWSTR                     pwszBridge
    )
/*++

Routine Description:

    Create a bridge.

Arguments:

    pwszFn              - The filename of the INI file.
    pwszBridge          - The name of the bridge.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntryBridge;
    PSIM_ENTRY                      pEntryTransportContainer;

    LPWSTR                          pwszSectionBridge;
    LPCWSTR                         pwszTransport, pwszSiteLinkName;
    ULONG                           ul;
    
    pwszSectionBridge = BuildCfgAllocDemandSection (
        pwszFn,
        pwszBridge
        );

    pwszTransport = BuildCfgDemandFirstStringByKey (
        pwszFn,
        pwszBridge,
        pwszSectionBridge,
        BUILDCFG_KEY_TRANSPORT
        );

    pEntryBridge = BuildCfgMakeBridge (
        pwszTransport,
        pwszBridge,
        &pEntryTransportContainer
        );

    for (pwszSiteLinkName = BuildCfgDemandFirstStringByKey (
            pwszFn, pwszBridge, pwszSectionBridge, BUILDCFG_KEY_SITELINK);
         pwszSiteLinkName != NULL;
         pwszSiteLinkName = BuildCfgGetNextStringByKey (
            pwszSiteLinkName, BUILDCFG_KEY_SITELINK)) {

        BuildCfgAddSiteLinkToBridge (pwszBridge, pEntryTransportContainer,
                                     pEntryBridge, pwszSiteLinkName);

    }

    KCCSimFree (pwszSectionBridge);
}

VOID
BuildCfgProcessTransport (
    IN  LPCWSTR                     pwszFn,
    IN  LPCWSTR                     pwszTransportName
    )
/*++

Routine Description:

    Create a site.

Arguments:

    pwszFn              - The filename of the INI file.
    pwszTransportName   - The name of the transport.

Return Value:

    None.

--*/
{
    LPWSTR                          pwszSectionTransport;

    LPCWSTR                         pwszTransportOptions;

    DWORD                           ulTransportOptions, ul;

    pwszSectionTransport = BuildCfgAllocDemandSection (
        pwszFn,
        pwszTransportName
        );
    pwszTransportOptions = BuildCfgGetFirstStringByKey (
        pwszSectionTransport,
        BUILDCFG_KEY_TRANSPORTOPTIONS
        );
    ulTransportOptions = 0;
    if (pwszTransportOptions != NULL) {
        for (ul = 0; pwszTransportOptions[ul] != L'\0'; ul++) {
            switch (towupper (pwszTransportOptions[ul])) {
            case KCCSIM_CID_NTDSTRANSPORT_OPT_IGNORE_SCHEDULES:
                ulTransportOptions |= NTDSTRANSPORT_OPT_IGNORE_SCHEDULES;
                break;
            case KCCSIM_CID_NTDSTRANSPORT_OPT_BRIDGES_REQUIRED:
                ulTransportOptions |= NTDSTRANSPORT_OPT_BRIDGES_REQUIRED;
                break;
            case L' ':
                break;
            default:
                KCCSimException (
                    KCCSIM_ETYPE_INTERNAL,
                    BUILDCFG_ERROR_INVALID_SITE_OPTION,
                    pwszFn,
                    pwszTransportName,
                    pwszTransportOptions
                    );
                break;
            }
            pwszTransportOptions++;
        }
    }

    BuildCfgUpdateTransport( pwszTransportName, ulTransportOptions );

    KCCSimFree (pwszSectionTransport);
}

VOID
BuildCfg (
    IN  LPCWSTR                     pwszFnRaw
    )
/*++

Routine Description:

    Builds a complete configuration.

Arguments:

    pwszFnRaw           - The input filename as specified by the user.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntryConfig, pEntryDomain;
    LPWSTR                          pwszFn = NULL;

    LPWSTR                          pwszSectionConfig, pwszSectionSite;
    LPCWSTR                         pwszNumUuids, pwszRootDn, pwszDomainName,
                                    pwszSiteName,
                                    pwszSiteLinkName, pwszExplicitBridgeheads,
                                    pwszForestVersion, pwszBridgeName,
                                    pwszTransportName;

    ULONG                           ulNumUuids, ulForestVersion;

    // Prepend ".\" onto the beginning of the filename, so that the ini
    // parsing routines won't search for it in the windows directory
    pwszFn = KCCSimAlloc (sizeof (WCHAR) * (3 + wcslen (pwszFnRaw)));
    swprintf (pwszFn, L".\\%s", pwszFnRaw);

    // First reinitialize the directory, destroying any existing contents.
    KCCSimInitializeDir ();

    pwszSectionConfig = BuildCfgAllocDemandSection (
        pwszFn,
        BUILDCFG_SECTION_CONFIG
        );

    // Make some Uuids.
    pwszNumUuids = BuildCfgGetFirstStringByKey (
        pwszSectionConfig,
        BUILDCFG_KEY_MAX_UUIDS
        );
    if (pwszNumUuids == NULL) {
        ulNumUuids = BUILDCFG_DEFAULT_MAX_UUIDS;
    } else {
        ulNumUuids = wcstoul (pwszNumUuids, NULL, 10);
    }
    BuildCfgMakeUuids (ulNumUuids);

    pwszForestVersion = BuildCfgGetFirstStringByKey (
        pwszSectionConfig,
        BUILDCFG_KEY_FOREST_VERSION
        );
    if (pwszForestVersion == NULL) {
        ulForestVersion = DS_BEHAVIOR_WIN2000;
    } else {
        ulForestVersion = wcstoul (pwszForestVersion, NULL, 10);
        if (ulForestVersion > DS_BEHAVIOR_VERSION_CURRENT) {
            ulForestVersion = DS_BEHAVIOR_VERSION_CURRENT;
        }
    }

    pwszRootDn = BuildCfgDemandFirstStringByKey (
        pwszFn,
        BUILDCFG_SECTION_CONFIG,
        pwszSectionConfig,
        BUILDCFG_KEY_ROOT_DOMAIN
        );
    pEntryConfig = BuildCfgMakeConfig (pwszRootDn, ulForestVersion);

    // Enable explicit bridgeheads
    for (pwszExplicitBridgeheads = BuildCfgGetFirstStringByKey (
            pwszSectionConfig, BUILDCFG_KEY_EXPLICITBRIDGEHEADS);
         pwszExplicitBridgeheads != NULL;
         pwszExplicitBridgeheads = BuildCfgGetNextStringByKey (
            pwszExplicitBridgeheads, BUILDCFG_KEY_EXPLICITBRIDGEHEADS)) {

        if (!BuildCfgUseExplicitBridgeheads (pwszExplicitBridgeheads)) {
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                BUILDCFG_ERROR_UNKNOWN_TRANSPORT,
                BUILDCFG_SECTION_CONFIG,
                pwszExplicitBridgeheads
                );
        }

    }

    // Create the domains
    for (pwszDomainName = BuildCfgGetFirstStringByKey (
            pwszSectionConfig, BUILDCFG_KEY_DOMAIN);
         pwszDomainName != NULL;
         pwszDomainName = BuildCfgGetNextStringByKey (
            pwszDomainName, BUILDCFG_KEY_DOMAIN)) {

        pEntryDomain = BuildCfgMakeDomain (pwszDomainName);
        BuildCfgMakeCrossRef (pEntryDomain, NULL, TRUE);

    }

    // Create the sites
    for (pwszSiteName = BuildCfgDemandFirstStringByKey (
            pwszFn, BUILDCFG_SECTION_CONFIG, pwszSectionConfig, BUILDCFG_KEY_SITE);
         pwszSiteName != NULL;
         pwszSiteName = BuildCfgGetNextStringByKey (
            pwszSiteName, BUILDCFG_KEY_SITE)) {

        BuildCfgProcessSite (
            pwszFn,
            pwszSiteName
            );

    }

    // Create the site-links
    for (pwszSiteLinkName = BuildCfgGetFirstStringByKey (
            pwszSectionConfig, BUILDCFG_KEY_SITELINK);
         pwszSiteLinkName != NULL;
         pwszSiteLinkName = BuildCfgGetNextStringByKey (
            pwszSiteLinkName, BUILDCFG_KEY_SITELINK)) {

        BuildCfgProcessSiteLink (
            pwszFn,
            pwszSiteLinkName
            );

    }

    // Create the bridges
    for (pwszBridgeName = BuildCfgGetFirstStringByKey (
            pwszSectionConfig, BUILDCFG_KEY_BRIDGE);
         pwszBridgeName != NULL;
         pwszBridgeName = BuildCfgGetNextStringByKey (
            pwszBridgeName, BUILDCFG_KEY_BRIDGE)) {

        BuildCfgProcessBridge (
            pwszFn,
            pwszBridgeName
            );

    }

    // Transport characteristics
    for (pwszTransportName = BuildCfgGetFirstStringByKey (
            pwszSectionConfig, BUILDCFG_KEY_TRANSPORT);
         pwszTransportName != NULL;
         pwszTransportName = BuildCfgGetNextStringByKey (
            pwszTransportName, BUILDCFG_KEY_TRANSPORT)) {

        BuildCfgProcessTransport (
            pwszFn,
            pwszTransportName
            );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\kccwalg.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccwalg.cxx

ABSTRACT:

    This file implements new algorithms for Whistler to generate inter-site
    topologies. Uses new spanning-tree algorithms available in W32TOPL.

DETAILS:

CREATED:

    07/26/00    Nick Harvey (NickHar)

REVISION HISTORY:

--*/

#include <NTDSpchx.h>
#include "w32topl.h"
#include "kcc.hxx"
#include "kcctask.hxx"
#include "kccconn.hxx"
#include "kcctopl.hxx"
#include "kcccref.hxx"
#include "kccdsa.hxx"
#include "kcctools.hxx"
#include "kcctrans.hxx"
#include "kccsconn.hxx"
#include "kccdynar.hxx"
#include "kccsite.hxx"
#include "kccduapi.hxx"
#include "ismapi.h"
#include "kccsitelink.hxx"
#include "kccstetl.hxx"


#define FILENO FILENO_KCC_KCCSTETL


PTOPL_GRAPH_STATE
KccSetupGraphState(
    VOID
    )
/*++

Routine Description:

    This function creates a W32TOPL 'graph state' object, which is a
    representation of the enterprise. The vertices of the graph are represented
    by site names. The edges of the graph correspond to site links, and the
    edge sets correspond to bridges. This graph state is used for calculating
    the inter-site topology in Whistler forests.

Parameters:

    None.    

Returns:

    A pointer to the graph state object that is created.
        
--*/
{
    KCC_SITE_LIST          *pSiteList = gpDSCache->GetSiteList();
    KCC_TRANSPORT_LIST     *pTransportList = gpDSCache->GetTransportList();
    KCC_TRANSPORT          *pTransport;
    KCC_SITE_LINK_LIST     *pSiteLinkList;
    KCC_SITE_LINK          *pSiteLink;
    KCC_SITE               *pSite;
    KCC_BRIDGE_LIST        *pBridgeList;
    KCC_BRIDGE             *pBridge;
    PTOPL_GRAPH_STATE       pGraphState;
    PTOPL_MULTI_EDGE        pEdge;
    PTOPL_MULTI_EDGE_SET    pEdgeSet;
    TOPL_REPL_INFO          replInfo;
    PVOID                  *vertexNames;
    DWORD                   iVtx,cVtx;
    DWORD                   iTnpt,cTnpt;
    DWORD                   iStlk,cStlk;
    DWORD                   iBrdg,cBrdg;
    DWORD                   numEdgesAdded;


    /* Set up the list of vertices and the graph state object */
    Assert( pSiteList!=NULL && pTransportList!=NULL );
    cVtx = pSiteList->GetCount();
    vertexNames = new PVOID[ cVtx ];
    for( iVtx=0; iVtx<cVtx; iVtx++ ) {
        pSite = pSiteList->GetSite(iVtx);
        ASSERT_VALID( pSite );
        vertexNames[iVtx] = pSite;
    }
    
    /* Create the actual graph state object (which includes the list of
     * vertices). This function should never return NULL. */
    Assert( gpDSCache->GetScheduleCache() );
    pGraphState = ToplMakeGraphState( vertexNames, cVtx,
        CompareIndirectSiteGuid, gpDSCache->GetScheduleCache() );

    /* The W32TOPL algorithms only support up to 32 transports. */
    cTnpt = pTransportList->GetCount();
    Assert( cTnpt<32 );

    /* This somewhat lengthy loop adds site links and bridges for every transport */
    for( iTnpt=0; iTnpt<cTnpt; iTnpt++ ) {

        pTransport = pTransportList->GetTransport(iTnpt);
        ASSERT_VALID( pTransport );

        /* Get all site links for this transport */
        pSiteLinkList = pTransport->GetSiteLinkList();
        cStlk = pSiteLinkList->GetCount();

        /* Ignore transports with no site links */
        if( cStlk<1 ) {
            continue;
        }

        /* If auto-bridging is on, we can build the edge set as we process the
         * site links. We create the edge set now. */
        if( pTransport->PerformAutomaticBridging() ) {
            pEdgeSet = new TOPL_MULTI_EDGE_SET;
            pEdgeSet->multiEdgeList = new PTOPL_MULTI_EDGE[ cStlk ];
        }

        /* Create a graph edge for each site link and add it to the graph */
        numEdgesAdded = 0;
        for( iStlk=0; iStlk<cStlk; iStlk++ ) {

            pSiteLink = pSiteLinkList->GetSiteLink(iStlk);
            ASSERT_VALID( pSiteLink );

            /* Although it shouldn't be possible to create site links with fewer
             * than two vertices, we try to handle this possibility. */
            cVtx = pSiteLink->GetSiteCount();
            if( cVtx < 2 ) {
                DPRINT1(0, "The site link %ls is invalid and will be ignored.\n",
                    pSiteLink->GetObjectDN()->StringName );
                LogEvent( DS_EVENT_CAT_KCC,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_KCC_SITE_LINK_TOO_SMALL,
                          szInsertDN( pSiteLink->GetObjectDN() ),
                          0, 0 );
                pSiteLink->SetGraphEdge( NULL );
                continue;
            }

            /* Set up the replication info for this edge */
            replInfo.cost = pSiteLink->GetCost();
            replInfo.options = pSiteLink->GetOptions();
            replInfo.repIntvl = pSiteLink->GetReplInterval();
            if( pTransport->UseSiteLinkSchedules() ) { 
                replInfo.schedule = pSiteLink->GetSchedule();
            } else {
                replInfo.schedule = NULL;
            }

            /* We have already checked all the parameters above, so this function
             * should not return any errors or NULL. */
            pEdge = ToplAddEdgeToGraph( pGraphState, cVtx, iTnpt, &replInfo );

            /* Add all vertices in this site link to the edge */
            for( iVtx=0; iVtx<cVtx; iVtx++ ) {
                pSite = pSiteLink->GetSite(iVtx);
                ASSERT_VALID( pSite );
                pSite->SetSiteLinkFlag( iTnpt );

                /* Since we have checked all the parameters above, we don't expect
                 * any errors here */
                ToplEdgeSetVtx( pGraphState, pEdge, iVtx, pSite );
            }

            /* There is a one-to-one correspondence between site links and graph
             * edges (except for site-links which were deemed invalid). When we add
             * edge sets to the graph below, we need to be able to find the graph edge
             * given a site link. We use the 'SetGraphEdge' function to specify this
             * correspondence. */
            pSiteLink->SetGraphEdge( pEdge );

            /* If automatic bridging was enabled for this transport, we go ahead and
             * add this graph edge to the edge set that we are building up. */
            if( pTransport->PerformAutomaticBridging() ) {
                Assert( pEdgeSet!=NULL && pEdgeSet->multiEdgeList!=NULL );
                Assert( numEdgesAdded<cStlk );
                pEdgeSet->multiEdgeList[numEdgesAdded++] = pEdge;
            }
        }

        /* Create the edge sets (bridges) for this transport */
        if( pTransport->PerformAutomaticBridging() ) {
            
            if( numEdgesAdded>1 ) {
                Assert( pEdgeSet!=NULL && pEdgeSet->multiEdgeList!=NULL );
                Assert( numEdgesAdded<=cStlk );
                pEdgeSet->numMultiEdges = numEdgesAdded;
                ToplAddEdgeSetToGraph( pGraphState, pEdgeSet );
            } else {
                delete[] pEdgeSet->multiEdgeList;
                delete pEdgeSet;
                pEdgeSet = NULL;
            }

            /* If automatic bridging is enabled, then any other bridges are
             * redundant, so we don't bother to process them. */

        } else {

            pBridgeList = pTransport->GetBridgeList();
            ASSERT_VALID( pBridgeList );
            
            cBrdg = pBridgeList->GetCount();
            for( iBrdg=0; iBrdg<cBrdg; iBrdg++) {

                pBridge = pBridgeList->GetBridge(iBrdg);
                ASSERT_VALID( pBridge );
                cStlk = pBridge->GetSiteLinkCount();

                /* Create an edge set corresponding to this bridge */
                pEdgeSet = new TOPL_MULTI_EDGE_SET;
                pEdgeSet->multiEdgeList = new PTOPL_MULTI_EDGE[ cStlk ];
                
                /* Find all the edges that this bridge contains, and add
                 * them to the edge set. */
                numEdgesAdded = 0;
                for( iStlk=0; iStlk<cStlk; iStlk++ ) {
                    pEdge = pBridge->GetSiteLink(iStlk)->GetGraphEdge();
                    if( pEdge!=NULL ) {
                        Assert( pEdgeSet!=NULL && pEdgeSet->multiEdgeList!=NULL );
                        Assert( numEdgesAdded<cStlk );
                        pEdgeSet->multiEdgeList[numEdgesAdded++] = pEdge;
                    }
                }

                /* Any bridge containing fewer than 2 edges is useless, so we
                 * don't bother to add it to the graph state. */
                if( numEdgesAdded>1 ) {
                    Assert( pEdgeSet!=NULL && pEdgeSet->multiEdgeList!=NULL );
                    Assert( numEdgesAdded<=cStlk );
                    pEdgeSet->numMultiEdges = numEdgesAdded;
                    ToplAddEdgeSetToGraph( pGraphState, pEdgeSet );
                } else {
                    delete[] pEdgeSet->multiEdgeList;
                    delete pEdgeSet;
                    pEdgeSet = NULL;
                }

            }   /* For each Bridge */

        }       /* Not Auto-Bridging */

    }           /* For each Transport */

    return pGraphState;
}


VOID
KccCheckSiteConnectivity(
    VOID
    )
/*++

Routine Description:

    This function iterates over all sites in the enterprise and checks if they
    are in any site links. If they are not, and they contain one or more DCs, this
    is logged as a configuration error.

Parameters:

    None.    

Returns:

    Nothing.
        
--*/
{
    KCC_SITE_LIST          *pSiteList = gpDSCache->GetSiteList();
    KCC_SITE               *pSite;
    DWORD                   iSite, cSite;

    ASSERT_VALID( pSiteList );
    cSite = pSiteList->GetCount();

    if( cSite<2 ) {
        // If there are fewer than two sites, then we don't need any site links,
        // so we don't bother to check for them.
        return;
    }

    for( iSite=0; iSite<cSite; iSite++ ) {

        pSite = pSiteList->GetSite(iSite);
        ASSERT_VALID( pSite );

        if ( pSite->GetAnySiteLinkFlag()==FALSE
          && pSite->GetDsaList()->GetCount()>0 )
        {
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_KCC_SITE_WITH_NO_LINKS,
                szInsertDN( pSite->GetObjectDN() ),
                0, 0
                ); 
        }

    }
    
}

    
TOPL_VERTEX_COLOR
KccSetupColorVtx(
     IN KCC_CROSSREF *       pCrossRef,
     IN KCC_SITE_ARRAY *     pSiteArrayWriteable,
     IN KCC_SITE_ARRAY *     pSiteArrayPartial,
    OUT PTOPL_COLOR_VERTEX  &colorVtxArray,
    OUT DWORD               &numColorVtx
    )
/*++

Routine Description:

    This function allocates a list of colored vertices, in preparation for calling
    the spanning-tree generation function. The colored vertices are sites which
    contain a writeable or partial replica of the NC specified by pCrossRef. Sites
    which contain at least one writeable replica are considered 'red' vertices.
    Sites which contain at least one partial replica but no writeable replicas are
    considered 'black' vertices. All other sites are considered 'white' vertices,
    and are not given a color.

Parameters:

    pCrossRef       - The cross-ref for the NC that we are currently processing.
                      This is needed to determine bridgehead availability at the
                      sites hosting this NC.

    pSiteArrayWriteable / pSiteArrayPartial
                    - These array contain all the sites containing writeable and partial
                      replicas of this NC, respectively.

    colorVtxArray   - A pointer to the array of color vertices that is created.

    numColorVtx     - The number of vertices in the colored vertex array.

Returns:

    The color of the local site.
        
--*/
{
    KCC_TRANSPORT_LIST  *pTransportList = gpDSCache->GetTransportList();
    KCC_TRANSPORT       *pTransport;
    KCC_SITE            *pSite, *pLocalSite = gpDSCache->GetLocalSite();
    KCC_DSA             *pBridgehead;
    BOOLEAN              fAllowReadonlyBridgeheads;
    TOPL_VERTEX_COLOR    localSiteColor;
    DWORD                numWriteable = pSiteArrayWriteable->GetCount();
    DWORD                maxNumColorVtx;
    DWORD                NCType = pCrossRef->GetNCType();
    DWORD                acceptRedRed, acceptBlack, mask;
    DWORD                isite, iTnpt;


    Assert( pSiteArrayWriteable!=NULL && pSiteArrayPartial!=NULL );

    // Check if this NC is hosted in the local site, and thus determine the
    // 'color' of this site, as required by the W32TOPL algorithms.
    if( pSiteArrayWriteable->IsElementOf(pLocalSite) ) {

        // Local site hosts a writeable copy -- we generate the spanning
        // tree between all writeable copies.
        localSiteColor = COLOR_RED;
        maxNumColorVtx = numWriteable;
        fAllowReadonlyBridgeheads = FALSE;

    } else if( pSiteArrayPartial->IsElementOf(pLocalSite) ) {

        // Local site hosts a partial copy -- we must generate the spanning
        // tree between all writeable and partial copies.
        localSiteColor = COLOR_BLACK;
        maxNumColorVtx = numWriteable + pSiteArrayPartial->GetCount();

        // The local site contains only a partial replica of this NC, so it is
        // considered to be generating a 'GC Topology'. This means that we allow
        // bridgeheads to be read-only replicas.
        fAllowReadonlyBridgeheads = TRUE;

    } else {

        // The local site doesn't host this NC, so it is white.
        // This site doesn't need to construct the topology for this NC, so
        // we don't need to build the list of color vertices.
        numColorVtx = 0;
        colorVtxArray = NULL;

        return COLOR_WHITE;
    }

    numColorVtx = 0;
    colorVtxArray = new TOPL_COLOR_VERTEX[ maxNumColorVtx ];

    // Process each site in the pSiteArrayWriteable/Partial arrays, as appropriate.
    for (isite = 0; isite < maxNumColorVtx; isite++)
    {
        if( isite < numWriteable ) {
            Assert( isite < pSiteArrayWriteable->GetCount() );
            pSite = (*pSiteArrayWriteable)[ isite ];
        } else {
            Assert( isite-numWriteable < pSiteArrayPartial->GetCount() );
            pSite = (*pSiteArrayPartial)[ isite-numWriteable ];
        }
        ASSERT_VALID( pSite );
        KccCheckSite( pSite );

        acceptRedRed = acceptBlack = 0;

        // The W32TOPL algorithms only support up to 32 transports.
        Assert( pTransportList->GetCount()<32 );

        for (iTnpt = 0; iTnpt < pTransportList->GetCount(); iTnpt++ )
        {
            pTransport = pTransportList->GetTransport(iTnpt);
            ASSERT_VALID( pTransport );

            // By default, allow this transport at this site
            mask = 1 << iTnpt;

            // 'acceptRedRed' is meaningless for sites which are black (since they
            // will never have any red-red edges), but we compute the bitmap anyways.
            acceptRedRed |= mask;
            acceptBlack |= mask;

            if (!gfAllowMbrBetweenDCsOfSameDomain
                && !fAllowReadonlyBridgeheads
                && !pTransport->IsIntersiteIP()
                && (KCC_NC_TYPE_SCHEMA != NCType)
                && (KCC_NC_TYPE_CONFIG != NCType))
            {
                // Disallow this transport at this site between writeable copies
                // (i.e., disable along red-red edges).
                acceptRedRed &= ~mask;

                // This is not a viable transport for this NC
                DPRINT2(3, "Cannot replicate writeable domain NC %ls over non-IP transport %ls.\n",
                    pCrossRef->GetNCDN()->StringName,
                    pTransport->GetDN()->StringName);
                continue;
            }

            if( FALSE==pSite->GetSiteLinkFlag(iTnpt) )
            {
                // If there are no site-links to this site, then disable this transport
                // at this site.
                acceptRedRed &= ~mask;
                acceptBlack &= ~mask;

                DPRINT2( 3, "No site-links at site %ls for transport %ls.\n",
                    pSite->GetObjectDN()->StringName,  pTransport->GetDN()->StringName );
                continue;
            }

            // If there are site-links for this transport at this site, then
            // try to get a bridgehead for this transport at this site.
            if ( pSite->GetSiteLinkFlag(iTnpt)
                 && !pSite->GetNCBridgeheadForTransport(pCrossRef,
                                                        pTransport,
                                                        fAllowReadonlyBridgeheads,
                                                       &pBridgehead) )
            {
                // No bridgehead, so disable this transport at this site completely.
                acceptRedRed &= ~mask;
                acceptBlack &= ~mask;

                DPRINT2( 3, "No bridgehead found for site %ls transport %ls.\n",
                    pSite->GetObjectDN()->StringName,  pTransport->GetDN()->StringName );
            }

        }   // for each transport


        // Add entry for this site to the array of colored vertices
        Assert( numColorVtx < maxNumColorVtx );
        colorVtxArray[ numColorVtx ].name = pSite;
        colorVtxArray[ numColorVtx ].acceptRedRed = acceptRedRed;
        colorVtxArray[ numColorVtx ].acceptBlack = acceptBlack;

        if( isite < numWriteable ) {
            colorVtxArray[ numColorVtx ].color = COLOR_RED;
        } else {
            colorVtxArray[ numColorVtx ].color = COLOR_BLACK;
        }

        numColorVtx++;

    }       // for each site

    return localSiteColor;
}


VOID
KccCreateConnectionsFromSTEdges(
    IN KCC_CROSSREF        *pCrossRef,
    IN TOPL_VERTEX_COLOR    localSiteColor,
    IN PTOPL_MULTI_EDGE    *stEdgeList,
    IN DWORD                numStEdges
    )
/*++

Routine Description:

    This function examines the output of the spanning-tree generation algorithm,
    and creates the appropriate connection objects.

Parameters:

    pCrossRef       - The cross-ref for the NC that we are currently processing.
                      This is needed to determine bridgehead availability at the
                      sites hosting this NC.

    localSiteColor  - Specifies the color of the local site. We use this information
                      to determine if we will accept read-only bridgeheads or not.

    stEdgeList      - The list of spanning-tree edges which was output from the
                      spanning-tree generation algorithm.

    numStEdges      - The number of edges in stEdgeList

Returns:

    Nothing
        
--*/
{
    KCC_TRANSPORT_LIST  *pTransportList = gpDSCache->GetTransportList();
    KCC_SITE            *pLocalSite = gpDSCache->GetLocalSite();
    KCC_SITE_CONNECTION  siteConnection;
    KCC_DSA             *pBridgehead;
    KCC_SITE            *pRemoteSite, *pSite, *pDestSite;
    KCC_TRANSPORT       *pTransport;
    DWORD                iEdge, iVtx, iTnpt;
    DWORD                options;
    BOOLEAN              fEdgeContainsLocalSite=FALSE, fAllowReadonlyBridgeheads;


    fAllowReadonlyBridgeheads = ( localSiteColor == COLOR_BLACK );

    // Examine the output edges, and create a site-connection object for each edge
    for( iEdge=0; iEdge<numStEdges; iEdge++ )
    {
        // The vertex names in the output edge are sorted by their name (i.e. GUID).
        // We need to examine them both to determine which is the local site and
        // which is the remote site
        Assert( stEdgeList[iEdge]->numVertices==2 );
        pRemoteSite = NULL;
        for( iVtx=0; iVtx<2; iVtx++ ) {

            pSite = (KCC_SITE*) stEdgeList[iEdge]->vertexNames[iVtx].name;
            ASSERT_VALID( pSite );
            KccCheckSite( pSite );
            
            if( pSite == pLocalSite ) {
                fEdgeContainsLocalSite = TRUE;
            } else {
                pRemoteSite = pSite;
            }
        }
        Assert( fEdgeContainsLocalSite );

        // If W32TOPL passed back a directed edge and the local site is not
        // the destination of this directed edge, we don't create a connection.
        if( stEdgeList[iEdge]->fDirectedEdge ) {
            pDestSite = (KCC_SITE*) stEdgeList[iEdge]->vertexNames[1].name;
            if( pDestSite!=pLocalSite ) {
                continue;
            }
        }

        siteConnection.Init();

        // Determine which transport should be used
        iTnpt = stEdgeList[iEdge]->edgeType;
        if( iTnpt >= pTransportList->GetCount() ) {
            Assert( !"A TOPL_MULTI_EDGE passed into KccCreateConnectionsFromSTEdges "
                    "had an invalid edgeType." );
            continue;
        }

        pTransport = pTransportList->GetTransport( iTnpt );
        if( NULL==pTransport ) {
            Assert( !"pTransportList->GetTransport() returned NULL unexpectedly" );
            continue;
        }

        siteConnection.SetTransport( pTransport );


        // Find the source (i.e. remote) site and bridgehead
        ASSERT_VALID( pRemoteSite );
        siteConnection.SetSourceSite( pRemoteSite );
        if( ! pRemoteSite->GetNCBridgeheadForTransport( pCrossRef, pTransport,
                    fAllowReadonlyBridgeheads, &pBridgehead ) )
        {
            // We failed to find a bridgehead for pLocalSite.
            // This should never happen, since we already found a bridgehead above.
            DPRINT2( 3, "No bridgehead found for site %ls transport %ls.\n",
                pRemoteSite->GetObjectDN()->StringName,  pTransport->GetDN()->StringName );
            Assert( FALSE && "No bridgehead found when processing output" );
            continue;
        }
        siteConnection.SetSourceDSA( pBridgehead );


        // Find the destination (i.e. local) site and bridgehead            
        siteConnection.SetDestinationSite( pLocalSite );
        if (!pLocalSite->GetNCBridgeheadForTransport( pCrossRef, pTransport,
                    fAllowReadonlyBridgeheads, &pBridgehead ) )
        {
            // We failed to find a bridgehead for pLocalSite.
            // This should never happen, since we already found a bridgehead above.
            DPRINT2( 3, "No bridgehead found for site %ls transport %ls.\n",
                pLocalSite->GetObjectDN()->StringName,  pTransport->GetDN()->StringName );
            Assert( FALSE && "No bridgehead found when processing output" );
            continue;
        }
        siteConnection.SetDestinationDSA( pBridgehead );


        // Set the various replication options
        options = stEdgeList[iEdge]->ri.options;
        siteConnection.SetCost( stEdgeList[iEdge]->ri.cost );
        siteConnection.SetReplInterval( stEdgeList[iEdge]->ri.repIntvl );
        siteConnection.SetUsesNotification( options & NTDSSITELINK_OPT_USE_NOTIFY );
        siteConnection.SetTwoWaySync( options & NTDSSITELINK_OPT_TWOWAY_SYNC );
        siteConnection.SetDisableCompression( options & NTDSSITELINK_OPT_DISABLE_COMPRESSION );

        // Set up the schedule
        siteConnection.SetSchedule( stEdgeList[iEdge]->ri.schedule,
            stEdgeList[iEdge]->ri.repIntvl );


        // Supportability logging event 4
        LogEvent8(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_EXTENSIVE,
            DIRLOG_KCC_CONNECTION_EDGE_NEEDED,
            szInsertDN(siteConnection.GetSourceSite()->GetObjectDN()),
            szInsertDN(siteConnection.GetDestinationDSA()->GetDsName()),
            szInsertDN(siteConnection.GetSourceDSA()->GetDsName()),
            szInsertDN(siteConnection.GetTransport()->GetDN()),
            0, 0, 0, 0
            ); 

        //
        // Create the ntdsconnection if one does not already exist
        //
        KccCreateConnectionToSite( pCrossRef,
                                   pLocalSite,
                                  &siteConnection,
                                   fAllowReadonlyBridgeheads,
                                  *pTransportList );
    }

}


/***** NonintersectingScheduleExceptionHandler *****/
/* Check if this exception is the 'non-intersecting schedule' exception from
 * W32TOPL. If it is, extract the information (site pointers) which describes
 * where the non-intersecting schedules were found, and log an error. */
LONG
NonintersectingScheduleExceptionHandler(
    PEXCEPTION_POINTERS  pep,
    KCC_CROSSREF        *pCrossRef
    )
{
    EXCEPTION_RECORD *per=pep->ExceptionRecord;
    KCC_SITE         *pSite[3];
    DWORD             i;

    if( per->ExceptionCode==TOPL_EX_NONINTERSECTING_SCHEDULES )
    {
        Assert( per->NumberParameters==3 );
        Assert( sizeof(PVOID)==sizeof(ULONG_PTR) );

        for( i=0; i<3; i++ ) {
            pSite[i] = ((KCC_SITE**) per->ExceptionInformation)[i];
            ASSERT_VALID( pSite[i] );
            KccCheckSite( pSite[i] );
        }        

        DPRINT4( 0, "When processing the topology for NC %ls, a shortest-path with "
                "non-intersecting schedules was found. The path originated at site %ls "
                "and the non-intersecting schedules were discovered between sites %ls "
                "and %ls. This path is considered invalid and be ignored.\n",
                pCrossRef->GetNCDN()->StringName,
                pSite[0]->GetObjectDN()->StringName,
                pSite[1]->GetObjectDN()->StringName,
                pSite[2]->GetObjectDN()->StringName,
                );
        
        LogEvent8( DS_EVENT_CAT_KCC,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_KCC_NONINTERSECTING_SCHEDULES,
                  szInsertDN( pCrossRef->GetNCDN() ),
                  szInsertDN( pSite[0]->GetObjectDN() ),
                  szInsertDN( pSite[1]->GetObjectDN() ),
                  szInsertDN( pSite[2]->GetObjectDN() ),
                  0, 0, 0, 0
                  );

        return EXCEPTION_CONTINUE_EXECUTION;
    }
    
    return EXCEPTION_CONTINUE_SEARCH;
}


/***** KccNoSpanningTree *****/
VOID
KccNoSpanningTree(
    IN KCC_CROSSREF    *pCrossRef,
    IN PTOPL_COMPONENTS pComponentInfo
    )
/*++

Routine Description:

    We could not build a spanning tree which connects the whole enterprise.
    In this function we mark all sites which are not in the local component
    as unreachable. We also log an event stating this problem and the DNs of
    at most 8 sites that could not be reached.

Parameters:

    pCrossRef       The crossref for the NC that we are currently proccessing
    pComponentInfo  Info about the components as returned by W32TOPL
                      
Returns:

    None
    
--*/
{
    KCC_SITE        *pSite, *pLocalSite = gpDSCache->GetLocalSite();
    BOOL            fFoundLocalSite=FALSE;
    TOPL_COMPONENT *pComp;
    DWORD           iComp, iVtx, iDN, curDN=0;
    const int       kMaxDNs = 8;
    DSNAME         *pdnArray[kMaxDNs];

    Assert( NULL!=pComponentInfo );

    /* Log a generic event about the failure to create a spanning tree */
    DPRINT1(1, "Minimum spanning tree does not exist for NC %ls.\n",
            pCrossRef->GetNCDN()->StringName );
    LogEvent(
        DS_EVENT_CAT_KCC,
        DS_EVENT_SEV_ALWAYS,
        DIRLOG_KCC_NO_SPANNING_TREE,
        szInsertDN(pCrossRef->GetNCDN()),
        0, 0 ); 

    /* Verify that the local site is in the first component */
    #ifdef DBG
        Assert( pComponentInfo->numComponents>=2 );
        pComp = &pComponentInfo->pComponent[0];
        for( iVtx=0; iVtx<pComp->numVertices; iVtx++ ) {
            if( pComp->vertexNames[iVtx]==pLocalSite ) {
                fFoundLocalSite = TRUE;
                break;
            }
        }
        Assert( fFoundLocalSite );
    #endif

    /* Clear the array of DNs */
    for( iDN=0; iDN<kMaxDNs; iDN++ ) {
        pdnArray[iDN] = NULL;
    }
    
    /* Find at most 'kMaxDNs' sites which cannot be reached. Any site in 
     * Component0 can be reached, so we start looking in Component1.
     * Also mark all sites in other components as unreachable. */
    for( iComp=1; iComp<pComponentInfo->numComponents; iComp++ ) {
        pComp = &pComponentInfo->pComponent[iComp];
        for( iVtx=0; iVtx<pComp->numVertices; iVtx++ ) {
            pSite = (KCC_SITE*) pComp->vertexNames[iVtx];
            ASSERT_VALID(pSite);
            Assert( pSite!=gpDSCache->GetLocalSite() );
            pSite->SetUnreachable();
            if( curDN<kMaxDNs ) {
                pdnArray[curDN++] = pSite->GetObjectDN();
            }
        }
    }

    /* Log those DNs in one single log event */
    Assert( 7<kMaxDNs );
    LogEvent8(
        DS_EVENT_CAT_KCC,
        DS_EVENT_SEV_ALWAYS,
        DIRLOG_KCC_DISCONNECTED_SITE,
        pdnArray[0] ? szInsertDN(pdnArray[0]) : szInsertSz(""),
        pdnArray[1] ? szInsertDN(pdnArray[1]) : szInsertSz(""),
        pdnArray[2] ? szInsertDN(pdnArray[2]) : szInsertSz(""),
        pdnArray[3] ? szInsertDN(pdnArray[3]) : szInsertSz(""),
        pdnArray[4] ? szInsertDN(pdnArray[4]) : szInsertSz(""),
        pdnArray[5] ? szInsertDN(pdnArray[5]) : szInsertSz(""),
        pdnArray[6] ? szInsertDN(pdnArray[6]) : szInsertSz(""),
        pdnArray[7] ? szInsertDN(pdnArray[7]) : szInsertSz("")
        ); 
}


VOID
KccGenerateTopologiesWhistler( VOID )
/*++

Routine Description:

    This function generates the inter-site topology when the forest is in
    Whistler mode. A single graph state object is created to represent the
    network structure, then for each NC we calculate a minimum-cost spanning
    tree. We create connection objects for each edge in the spanning tree
    which is incident with the local site.

Parameters:

    None
                      
Returns:

    If topology generation was not completely successful, we return true
    so that existing connections will be kept.
    
--*/
{
    KCC_CROSSREF_LIST *  pCrossRefList = gpDSCache->GetCrossRefList();
    KCC_SITE_ARRAY *     pSiteArrayWriteable;
    KCC_SITE_ARRAY *     pSiteArrayPartial;
    KCC_SITE *           pLocalSite = gpDSCache->GetLocalSite();
    KCC_CROSSREF *       pCrossRef;
    PTOPL_GRAPH_STATE    pGraphState;
    TOPL_VERTEX_COLOR    localSiteColor;
    TOPL_COLOR_VERTEX   *colorVtxArray;
    PTOPL_MULTI_EDGE    *stEdgeList;
    TOPL_COMPONENTS      componentInfo;
    DWORD                numColorVtx, numVtxStEdges;
    DWORD                icr, ccr;
    DWORD                errCode;


    DPRINT( 3, "KCC is using the Whistler Topology Generation Algorithm\n" );
    LogEvent(DS_EVENT_CAT_KCC,
             DS_EVENT_SEV_EXTENSIVE,
             DIRLOG_KCC_WHISTLER_TOPOLOGY_ALG,
             0, 0, 0);

    pGraphState = KccSetupGraphState();
    KccCheckSiteConnectivity();

    //
    // For each NC that is shared between two or more sites, create inter site 
    // connections between sites with that NC.
    //
    ccr = pCrossRefList->GetCount();
    for( icr=0; icr<ccr; icr++ )
    {
        pCrossRef = pCrossRefList->GetCrossRef(icr);
        pSiteArrayWriteable = pCrossRef->GetWriteableSites();
        pSiteArrayPartial = pCrossRef->GetPartialSites();

        if( icr==ccr-2 ) {
            // Schema should always be the penultimate crossref.
            // We skip it, because it has the same requirements as Config.
            Assert( KCC_NC_TYPE_SCHEMA==pCrossRef->GetNCType() );
            continue;
        }
        if( icr==ccr-1 ) {
            // Config should always be the last crossref.
            Assert( KCC_NC_TYPE_CONFIG==pCrossRef->GetNCType() );
        }

        DPRINT3( 3, "Naming Context %ls is in %d writable sites, %d partial sites\n", 
                 pCrossRef->GetNCDN()->StringName,
                 pSiteArrayWriteable->GetCount(),
                 pSiteArrayPartial->GetCount() );   

        // Supportability logging event 2
        LogEvent(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_EXTENSIVE,
            DIRLOG_KCC_NC_SITE_TOPOLOGY,
            szInsertDN(pCrossRef->GetNCDN()),
            szInsertUL(pSiteArrayWriteable->GetCount()),
            szInsertUL(pSiteArrayPartial->GetCount())
            );

        __try {

            // Setup a 'color vertex' list, which contains information about all sites
            // which host this NC, and the bridgeheads which are available at those sites.
            localSiteColor = KccSetupColorVtx( pCrossRef,
                                               pSiteArrayWriteable,
                                               pSiteArrayPartial,
                                               colorVtxArray,
                                               numColorVtx );
            
            if( localSiteColor==COLOR_WHITE || numColorVtx<2 ) {
    
                DPRINT1(3, "Do not need to build spanning tree for NC %ls.\n",
                        pCrossRef->GetNCDN()->StringName );
    
                // Either the local site does not host this NC, or
                // the spanning tree would not have any edges. In
                // either case, we do not need to compute the topology.
                // Skip to the next NC.
                __leave;
    
            }
    
            DPRINT2(3, "Running spanning tree algorithm for NC %ls. There are "
                       "%d colored vertices.\n",
                       pCrossRef->GetNCDN()->StringName,
                       numColorVtx );
    
            // Call W32TOPL's new spanning tree algorithm
            __try {

                stEdgeList = ToplGetSpanningTreeEdgesForVtx( pGraphState, pLocalSite,
                    colorVtxArray, numColorVtx, &numVtxStEdges, &componentInfo );

            } __except( NonintersectingScheduleExceptionHandler(
                            GetExceptionInformation(), pCrossRef) )
            {
                // Do nothing here -- exception was handled in handler function
            }
    
            DPRINT2(3, "Topology generation finished. There are %d graph components, "
                       "and %d edges at the local site.\n",
                       componentInfo.numComponents, numVtxStEdges );
                
            // If there is more than one component, then the enterprise is not
            // fully connected by the tree (i.e. the tree is not spanning).
            if( componentInfo.numComponents > 1 ) {    
    
                KccNoSpanningTree( pCrossRef, &componentInfo );

            }
    
            KccCreateConnectionsFromSTEdges( pCrossRef, localSiteColor,
                stEdgeList, numVtxStEdges );
    
            // Clean up the memory that we used while processing this NC
            Assert( colorVtxArray!=NULL );
            delete[] colorVtxArray;
            ToplDeleteSpanningTreeEdges( stEdgeList, numVtxStEdges );
            ToplDeleteComponents( &componentInfo );

        } __except( ToplIsToplException( ( errCode=GetExceptionCode() ) ) ) {

            //
            // The w32topl library threw an occur code; the implies an internal
            // mishandling of the objects.  Log an error indicated the inter-site
            // topology failed for this NC
            //
    
            DPRINT1( 1, "W32TOPL routines threw a %d exception during inter-site topology creation.\n", 
                     errCode );
    
            LogEvent( DS_EVENT_CAT_KCC,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_KCC_AUTO_TOPL_GENERATION_INCOMPLETE,
                      szInsertDN(pCrossRef->GetNCDN()),
                      szInsertHex(errCode),
                      0 );

        }

    }   // Build topology for each NC

    ToplDeleteGraphState( pGraphState );

    // Note: We have not freed the memory for:
    //      The array of vertex names
    //      The edge sets
    // This memory will be cleared up when the thread exits
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\buildcfg.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    buildcfg.h

ABSTRACT:

    Header file for buildcfg.c.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/
               
// Header files
#include <schedule.h>
#include <mdglobal.h>

// Config section
#define BUILDCFG_SECTION_CONFIG             L"Configuration"
#define BUILDCFG_KEY_ROOT_DOMAIN            L"RootDomain"
#define BUILDCFG_KEY_DOMAIN                 L"Domain"
#define BUILDCFG_KEY_SITE                   L"Site"
#define BUILDCFG_KEY_SITELINK               L"SiteLink"
#define BUILDCFG_KEY_BRIDGE                 L"SiteLinkBridge"
#define BUILDCFG_KEY_EXPLICITBRIDGEHEADS    L"ExplicitBridgeheads"
#define BUILDCFG_KEY_MAX_UUIDS              L"MaxUuids"
#define BUILDCFG_KEY_FOREST_VERSION         L"ForestVersion"

// Site section
#define BUILDCFG_KEY_SERVERS                L"Servers"
#define BUILDCFG_KEY_SITEOPTIONS            L"SiteOptions"
#define BUILDCFG_KEY_ISTG                   L"ISTG"

// Server type section
#define BUILDCFG_KEY_SERVEROPTIONS          L"ServerOptions"
#define BUILDCFG_KEY_BRIDGEHEAD             L"Bridgehead"
#define BUILDCFG_KEY_DOMAIN                 L"Domain"
#define BUILDCFG_KEY_RDNMASK                L"RDNMask"

// Site-link section
#define BUILDCFG_KEY_TRANSPORT              L"Transport"
#define BUILDCFG_KEY_COST                   L"Cost"
#define BUILDCFG_KEY_REPLINTERVAL           L"ReplInterval"
#define BUILDCFG_KEY_SITELINKOPTIONS        L"SiteLinkOptions"
#define BUILDCFG_KEY_SCHEDULE               L"Schedule"

// Bridge section

// Transport section
#define BUILDCFG_KEY_TRANSPORTOPTIONS            L"TransportOptions"

// RDNs
#define BUILDCFG_RDN_CONFIG                 L"Configuration"
#define BUILDCFG_RDN_SITES_CONTAINER        L"Sites"
#define BUILDCFG_RDN_NTDS_SITE_SETTINGS     L"NTDS Site Settings"
#define BUILDCFG_RDN_SERVERS_CONTAINER      L"Servers"
#define BUILDCFG_RDN_NTDS_SETTINGS          L"NTDS Settings"
#define BUILDCFG_RDN_INTERSITE_TRANSPORTS   L"Inter-Site Transports"
#define BUILDCFG_RDN_DMD                    L"Schema"
#define BUILDCFG_RDN_CROSS_REF_CONTAINER    L"Partitions"
#define BUILDCFG_RDN_CROSS_REF_CONFIG       L"Enterprise Configuration"
#define BUILDCFG_RDN_CROSS_REF_DMD          L"Enterprise Schema"
#define BUILDCFG_RDN_SERVICES               L"Services"
#define BUILDCFG_RDN_WINDOWS_NT             L"Windows NT"
#define BUILDCFG_RDN_DIRECTORY_SERVICE      L"Directory Service"
#define BUILDCFG_NAME_MAIL_ADDRESS          L"_IsmService"

// Some #defines
#define BUILDCFG_NUM_TRANSPORTS     2
#define BUILDCFG_GENERIC_SERVER_ID  L"SERVER"
#define BUILDCFG_DEFAULT_MAX_UUIDS  1000

// Internal structures

typedef struct {
    const WCHAR                     wszRDN[1+MAX_RDN_SIZE];
    const ATTRTYP                   transportAddressAttribute;
    const WCHAR                     transportDLLName[15];
    PSIM_ENTRY                      pEntry;
} BUILDCFG_TRANSPORT_INFO;

typedef struct {
    PDSNAME                         pdnRootDomain;
    PDSNAME                         pdnConfig;
    PDSNAME                         pdnDmd;
    LPWSTR                          pwszRootDomainDNSName;
    PSIM_ENTRY                      pEntrySitesContainer;
    PSIM_ENTRY                      pEntryCrossRefContainer;
    RTL_GENERIC_TABLE               tableUuids;
} BUILDCFG_GLOBALS;

extern BUILDCFG_GLOBALS             globals;

const BUILDCFG_TRANSPORT_INFO *
BuildCfgGetTransportInfo (
    IN  LPCWSTR                     pwszTransportRDN
    );

BOOL
BuildCfgUseExplicitBridgeheads (
    IN  LPCWSTR                     pwszTransportRDN
    );

PSIM_ENTRY
BuildCfgMakeCrossRef (
    IN  PSIM_ENTRY                  pEntryNc,
    IN  LPCWSTR                     pwszRDN OPTIONAL,
    IN  BOOL                        bIsDomain
    );

PSIM_ENTRY
BuildCfgMakeDomain (
    IN  LPCWSTR                     pwszDomain
    );

PSIM_ENTRY
BuildCfgMakeSite (
    IN  LPCWSTR                     pwszSiteRDN,
    IN  ULONG                       ulSiteOptions
    );

PSIM_ENTRY
BuildCfgMakeSiteLink (
    IN  LPCWSTR                     pwszTransport,
    IN  LPCWSTR                     pwszSiteLink,
    IN  ULONG                       ulCost,
    IN  ULONG                       ulReplInterval,
    IN  ULONG                       ulOptions,
    IN  PSCHEDULE                   pSchedule
    );

VOID
BuildCfgAddSiteToSiteLink (
    IN  LPCWSTR                     pwszSiteLinkRDN,
    IN  PSIM_ENTRY                  pEntrySiteLink,
    IN  LPCWSTR                     pwszSiteRDN
    );

PSIM_ENTRY
BuildCfgMakeBridge (
    IN  LPCWSTR                     pwszTransport,
    IN  LPCWSTR                     pwszBridge,
    OUT PSIM_ENTRY *                ppEntryTransport
    );

VOID
BuildCfgAddSiteLinkToBridge (
    IN  LPCWSTR                     pwszBridgeRDN,
    IN  PSIM_ENTRY                  pEntryTransportContainer,
    IN  PSIM_ENTRY                  pEntryBridge,
    IN  LPCWSTR                     pwszSiteLinkRDN
    );

BOOL
BuildCfgISTG (
    IN  PSIM_ENTRY                  pEntryNTDSSiteSettings,
    IN  PSIM_ENTRY                  pEntryServersContainer,
    IN  LPCWSTR                     pwszServerRDN
    );

VOID
BuildCfgAddAsBridgehead (
    IN  LPCWSTR                     pwszServerType,
    IN  PSIM_ENTRY                  pEntryServer,
    IN  LPCWSTR                     pwszTransportRDN
    );

PSIM_ENTRY
BuildCfgMakeServer (
    IO  PULONG                      pulServerNum,
    IN  LPCWSTR                     pwszServerRDNMask,
    IN  LPCWSTR                     pwszSiteRDN,
    IN  LPCWSTR                     pwszDomain,
    IN  PSIM_ENTRY                  pEntryServersContainer,
    IN  ULONG                       ulServerOptions
    );

PSIM_ENTRY
BuildCfgMakeConfig (
    IN  LPCWSTR                     pwszRootDn,
    IN  DWORD                       ulForestVersion
    );

VOID
BuildCfgUpdateTransport (
    IN  LPCWSTR                     pwszTransport,
    IN  ULONG                       ulTransportOptions
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\dir.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dir.c

ABSTRACT:

    Contains routines for interfacing the simulated
    directory.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <ismapi.h>
#include <attids.h>
#include <objids.h>
#include <filtypes.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "state.h"
#include "ldif.h"

BOOL fNullUuid (const UUID *pUuid);

struct _GUID_TABLE_ENTRY {
    GUID                            guid;
    PSIM_ENTRY                      pEntry;
};

struct _DSNAME_TABLE_ENTRY {
    LPSTR                           mappedName;
    PSIM_ENTRY                      pEntry;
};

struct _KCCSIM_ANCHOR {
    PDSNAME                     pdnDmd;
    PDSNAME                     pdnDsa;
    PDSNAME                     pdnDomain;
    PDSNAME                     pdnConfig;
    PDSNAME                     pdnRootDomain;
    PDSNAME                     pdnLdapDmd;
    PDSNAME                     pdnPartitions;
    PDSNAME                     pdnDsSvcConfig;
    PDSNAME                     pdnSite;
    LPWSTR                      pwszDomainName;
    LPWSTR                      pwszDomainDNSName;
    LPWSTR                      pwszRootDomainDNSName;
};

typedef struct {
    PSIM_ENTRY                  pRootEntry;
    struct _KCCSIM_ANCHOR       anchor;
    RTL_GENERIC_TABLE           tableGuid;
    RTL_GENERIC_TABLE           tableDsname;
} SIM_DIRECTORY, * PSIM_DIRECTORY;

PSIM_DIRECTORY                      g_pSimDir = NULL;

RTL_GENERIC_COMPARE_RESULTS
NTAPI
KCCSimGuidTableCompare (
    IN  const RTL_GENERIC_TABLE *   pTable,
    IN  const VOID *                pFirstStruct,
    IN  const VOID *                pSecondStruct
    )
/*++

Routine Description:

    KCCSim maintains an RTL_GENERIC_TABLE that maps GUIDs to
    directory entries.  This enables fast searches by GUID.
    This function binary-compares two GUIDs.

Arguments:

    pTable              - Always &g_pSimDir->tableGuid
    pFirstStruct        - The first GUID to compare
    pSecondStruct       - The second GUID

Return Value:

    GenericLessThan, GenericGreaterThan, or GenericEqual

--*/
{
    struct _GUID_TABLE_ENTRY *      pFirstEntry;
    struct _GUID_TABLE_ENTRY *      pSecondEntry;
    int                             iCmp;
    RTL_GENERIC_COMPARE_RESULTS     result;

    pFirstEntry = (struct _GUID_TABLE_ENTRY *) pFirstStruct;
    pSecondEntry = (struct _GUID_TABLE_ENTRY *) pSecondStruct;

    // We do a simple byte-by-byte comparison.
    iCmp = memcmp (&pFirstEntry->guid, &pSecondEntry->guid, sizeof (GUID));
    if (iCmp < 0) {
        result = GenericLessThan;
    } else if (iCmp > 0) {
        result = GenericGreaterThan;
    } else {
        Assert (iCmp == 0);
        result = GenericEqual;
    }

    return result;
}

RTL_GENERIC_COMPARE_RESULTS
NTAPI
KCCSimDsnameTableCompare (
    IN  const RTL_GENERIC_TABLE *   pTable,
    IN  const VOID *                pFirstStruct,
    IN  const VOID *                pSecondStruct
    )
/*++

Routine Description:

    KCCSim maintains an RTL_GENERIC_TABLE that maps DSNAMEs to
    directory entries.  This enables fast searches by DSNAME.
    This function binary-compares two DSNAMEs.

Arguments:

    pTable              - Always &g_pSimDir->tableDsname
    pFirstStruct        - The first Dsname to compare
    pSecondStruct       - The second Dsname

Return Value:

    GenericLessThan, GenericGreaterThan, or GenericEqual

--*/
{
    struct _DSNAME_TABLE_ENTRY *    pFirstEntry;
    struct _DSNAME_TABLE_ENTRY *    pSecondEntry;
    int                             iCmp;
    RTL_GENERIC_COMPARE_RESULTS     result;

    Assert( pFirstStruct!=NULL && pSecondStruct!=NULL );
    pFirstEntry = (struct _DSNAME_TABLE_ENTRY *) pFirstStruct;
    pSecondEntry = (struct _DSNAME_TABLE_ENTRY *) pSecondStruct;

    Assert( pFirstEntry->mappedName!=NULL && pSecondEntry->mappedName!=NULL );
    iCmp = strcmp( pFirstEntry->mappedName, pSecondEntry->mappedName );

    if (iCmp < 0) {
        result = GenericLessThan;
    } else if (iCmp > 0) {
        result = GenericGreaterThan;
    } else {
        Assert (iCmp == 0);
        result = GenericEqual;
    }

    return result;
}

PSIM_ENTRY
KCCSimLookupEntryByGuid (
    IN  const GUID *                pGuid
    )
/*++

Routine Description:

    Searches the GUID table for the associated entry.

Arguments:

    pGuid               - The GUID to use as a key

Return Value:

    The associated entry, or NULL if none exists.

--*/
{
    struct _GUID_TABLE_ENTRY        lookup;
    struct _GUID_TABLE_ENTRY *      pFound;

    Assert (pGuid != NULL);

    memcpy (&lookup.guid, pGuid, sizeof (GUID));
    lookup.pEntry = NULL;
    pFound = RtlLookupElementGenericTable (&g_pSimDir->tableGuid, &lookup);

    if (pFound == NULL) {
        return NULL;
    } else {
        return pFound->pEntry;
    }
}

PSIM_ENTRY
KCCSimLookupEntryByDsname (
    IN  const DSNAME *               pdn
    )
/*++

Routine Description:

    Searches the Dsname table for the associated entry.

Arguments:

    pdn                 - The Dsname to use as a key

Return Value:

    The associated entry, or NULL if none exists.

--*/
{
    struct _DSNAME_TABLE_ENTRY        lookup;
    struct _DSNAME_TABLE_ENTRY *      pFound;

    Assert (pdn != NULL);

    lookup.mappedName = SimDSNAMEToMappedStrExternal( (DSNAME*) pdn, TRUE );
    lookup.pEntry = NULL;
    pFound = RtlLookupElementGenericTable( &g_pSimDir->tableDsname, &lookup );
    KCCSimFree( lookup.mappedName );

    if (pFound == NULL) {
        return NULL;
    } else {
        Assert( pFound->pEntry!=NULL );
        return pFound->pEntry;
    }
}

VOID
KCCSimInsertEntryIntoGuidTable (
    IN  PSIM_ENTRY                  pEntry
    )
/*++

Routine Description:

    Inserts an entry into the GUID table.

Arguments:

    pEntry              - The entry to insert.

Return Value:

    None.

--*/
{
    struct _GUID_TABLE_ENTRY        insert;
    PVOID                           pOld;

    Assert (pEntry != NULL);

    if (fNullUuid (&pEntry->pdn->Guid)) {
        return;
    }

    memcpy (&insert.guid, &pEntry->pdn->Guid, sizeof (GUID));
    insert.pEntry = pEntry;

    pOld = RtlInsertElementGenericTable (
        &g_pSimDir->tableGuid,
        (PVOID) &insert,
        sizeof (struct _GUID_TABLE_ENTRY),
        NULL
        );
}

VOID
KCCSimInsertEntryIntoDsnameTable (
    IN  PSIM_ENTRY                  pEntry
    )
/*++

Routine Description:

    Inserts an entry into the Dsname table.

Arguments:

    pEntry              - The entry to insert.

Return Value:

    None.

--*/
{
    struct _DSNAME_TABLE_ENTRY      insert;
    PVOID                           pOld;

    Assert (pEntry != NULL);

    insert.mappedName = SimDSNAMEToMappedStrExternal( pEntry->pdn, TRUE );
    insert.pEntry = pEntry;

    pOld = RtlInsertElementGenericTable (
        &g_pSimDir->tableDsname,
        (PVOID) &insert,
        sizeof (struct _DSNAME_TABLE_ENTRY),
        NULL
        );
}

BOOL
KCCSimRemoveEntryFromGuidTable (
    IN  PSIM_ENTRY                  pEntry
    )
/*++

Routine Description:

    Removes an entry from the GUID table.

Arguments:

    pEntry              - The entry to remove.

Return Value:

    TRUE if the entry was found and removed.
    FALSE if the entry was not found in the GUID table.

--*/
{
    struct _GUID_TABLE_ENTRY        remove;

    Assert (pEntry != NULL);
    if (fNullUuid (&pEntry->pdn->Guid)) {
        return FALSE;
    }

    memcpy (&remove.guid, &pEntry->pdn->Guid, sizeof (GUID));
    
    return RtlDeleteElementGenericTable (&g_pSimDir->tableGuid, &remove);
}
  
BOOL
KCCSimRemoveEntryFromDsnameTable (
    IN  PSIM_ENTRY                  pEntry
    )
/*++

Routine Description:

    Removes an entry from the Dsname table.

Arguments:

    pEntry              - The entry to remove.

Return Value:

    TRUE if the entry was found and removed.
    FALSE if the entry was not found in the Dsname table.

--*/
{
    struct _DSNAME_TABLE_ENTRY        remove, *pFound;
    LPSTR                             mappedName;
    BOOLEAN                           fSuccess;

    Assert (pEntry != NULL);
    Assert (pEntry->pdn != NULL);

    remove.mappedName = SimDSNAMEToMappedStrExternal( pEntry->pdn, TRUE );
    remove.pEntry = NULL;
    
    pFound = RtlLookupElementGenericTable( &g_pSimDir->tableDsname, &remove );
    if( NULL==pFound || NULL==pFound->mappedName ) {
        Assert( !"RtlLookupElementGenericTable() returned NULL unexpectedly" );
        return FALSE;
    }
    mappedName = pFound->mappedName;
    
    fSuccess = RtlDeleteElementGenericTable( &g_pSimDir->tableDsname, &remove );
    Assert( fSuccess );

    KCCSimFree( mappedName );
    KCCSimFree( remove.mappedName );

    return fSuccess;
}
    

VOID
KCCSimFreeValue (
    IO  PSIM_VALUE *                ppVal
    )
/*++

Routine Description:

    Frees a single attribute value.

Arguments:

    ppVal               - Pointer to the attribute value to free.

Return Value:

    None.

--*/
{
    if (ppVal == NULL || *ppVal == NULL) {
        return;
    }

    KCCSimFree ((*ppVal)->pVal);
    KCCSimFree (*ppVal);
    *ppVal = NULL;
}

BOOL
KCCSimAttRefIsValid (
    IN  PSIM_ATTREF                 pAttRef
    )
/*++

Routine Description:

    Determines whether an ATTREF struct refers to a valid
    attribute.  This function tests for three conditions:
        1) The entry is non-null.
        2) The attribute is non-null.
        3) The attribute exists somewhere in the entry's
           linked list of attributes.
    This function is intended primarily for use within Asserts.

Arguments:

    pAttRef             - Pointer to the attribute
                          reference to test.

Return Value:

    TRUE if the attribute reference is valid.

--*/
{
    PSIM_ATTRIBUTE                  pAttrAt;

    if (pAttRef == NULL         ||
        pAttRef->pEntry == NULL ||
        pAttRef->pAttr == NULL   ) {
        return FALSE;
    }

    pAttrAt = pAttRef->pEntry->pAttrFirst;
    while (pAttrAt != NULL) {
        if (pAttrAt == pAttRef->pAttr) {
            return TRUE;
        }
        pAttrAt = pAttrAt->next;
    }
    
    return FALSE;
}

BOOL
KCCSimGetAttribute (
    IN  PSIM_ENTRY                  pEntry,
    IN  ATTRTYP                     attrType,
    OUT PSIM_ATTREF                 pAttRef OPTIONAL
    )
/*++

Routine Description:

    Returns an attribute reference corresponding to the desired
    entry and attribute type.

Arguments:

    pEntry              - The entry to search.
    attrType            - The attribute type to search for.
    pAttRef             - OPTIONAL.  Pointer to a preallocated
                          attribute reference that will be filled
                          with information about this attribute.
                          If the attribute does not exist,
                          pAttRef->pAttr will be set to NULL.

Return Value:

    TRUE if the attribute exists.

--*/
{
    PSIM_ATTRIBUTE                  pAttrAt;

    Assert (pEntry != NULL);

    pAttrAt = pEntry->pAttrFirst;
    while (pAttrAt != NULL &&
           pAttrAt->attrType != attrType) {
        pAttrAt = pAttrAt->next;
    }

    if (pAttRef != NULL) {
        pAttRef->pEntry = pEntry;
        pAttRef->pAttr = pAttrAt;       // May be NULL
    }

    return (pAttrAt != NULL);
}

VOID
KCCSimNewAttribute (
    IN  PSIM_ENTRY                  pEntry,
    IN  ATTRTYP                     attrType,
    OUT PSIM_ATTREF                 pAttRef OPTIONAL
    )
/*++

Routine Description:

    Creates a new attribute with no values.

Arguments:

    pEntry              - The entry in which to create the attribute.
    attrType            - The attribute type.
    pAttRef             - OPTIONAL.  Pointer to a preallocated
                          attribute reference that will be filled
                          with information about this attribute.

Return Value:

    None.

--*/
{
    PSIM_ATTRIBUTE                  pNewAttr;

    Assert (pEntry != NULL);

    pNewAttr = KCCSIM_NEW (SIM_ATTRIBUTE);
    pNewAttr->attrType = attrType;
    pNewAttr->pValFirst = NULL;

    // For speed, we add the attribute on to the beginning of the list
    pNewAttr->next = pEntry->pAttrFirst;
    pEntry->pAttrFirst = pNewAttr;

    if (pAttRef != NULL) {
        pAttRef->pEntry = pEntry;
        pAttRef->pAttr = pNewAttr;
    }
}

VOID
KCCSimFreeAttribute (
    IO  PSIM_ATTRIBUTE *            ppAttr
    )
/*++

Routine Description:

    Frees a single attribute.  Routines outside of dir.c should
    call KCCSimRemoveAttribute instead.

Arguments:

    ppAttr              - Pointer to the attribute to free.

Return Value:

    None.

--*/
{
    PSIM_VALUE                      pValAt, pValNext;

    if (ppAttr == NULL || *ppAttr == NULL) {
        return;
    }

    pValAt = (*ppAttr)->pValFirst;
    while (pValAt != NULL) {
        pValNext = pValAt->next;
        KCCSimFreeValue (&pValAt);
        pValAt = pValNext;
    }

    KCCSimFree (*ppAttr);
    *ppAttr = NULL;
}

VOID
KCCSimRemoveAttribute (
    IO  PSIM_ATTREF                 pAttRef
    )
/*++

Routine Description:

    Removes an attribute from the directory.  This will
    also set pAttRef->pAttr to NULL.

Arguments:

    pAttRef             - Pointer to a valid attribute reference.

Return Value:

    None.

--*/
{
    PSIM_ATTRIBUTE                  pAttrAt;

    Assert (KCCSimAttRefIsValid (pAttRef));

    // Base case: First attribute in entry
    if (pAttRef->pAttr == pAttRef->pEntry->pAttrFirst) {
        // The new first attribute becomes this one's child.
        pAttRef->pEntry->pAttrFirst = pAttRef->pEntry->pAttrFirst->next;
    } else {

        // It's not the first attribute in the entry.
        // So, search for the parent of this attribute.
        pAttrAt = pAttRef->pEntry->pAttrFirst;
        while (pAttrAt != NULL &&
               pAttrAt->next != pAttRef->pAttr) {
            pAttrAt = pAttrAt->next;
        }

        // If we didn't find its parent, something is seriously
        // wrong (since this was Asserted to be a valid attref.)
        Assert (pAttrAt != NULL);
        Assert (pAttrAt->next != NULL);

        // Skip over this attribute
        pAttrAt->next = pAttrAt->next->next;

    }

    KCCSimFreeAttribute (&(pAttRef->pAttr));
}

VOID
KCCSimAddValueToAttribute (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  PBYTE                       pValData
    )
/*++

Routine Description:

    Adds a preallocated data block to the directory.  The caller
    should NOT deallocate it after calling this function (or else
    the directory will be corrupted.)  To copy data into the
    directory, use KCCSimAllocAddValueToAttribute.

Arguments:

    pAttRef             - Pointer to a valid attribute reference.
    ulValLen            - The length of the data block.
    pValData            - The data to add.

Return Value:

    None.

--*/
{
    PSIM_VALUE                      pNewVal;

    Assert (KCCSimAttRefIsValid (pAttRef));
    Assert (pValData != NULL);

    pNewVal = KCCSIM_NEW (SIM_VALUE);
    pNewVal->ulLen = ulValLen;
    pNewVal->pVal = pValData;

    // For speed, we add the value on to the beginning of the list
    pNewVal->next = pAttRef->pAttr->pValFirst;
    pAttRef->pAttr->pValFirst = pNewVal;

    // Now we check for special attribute types.

    // Are we adding a GUID?
    if (pAttRef->pAttr->attrType == ATT_OBJECT_GUID) {
        Assert (pNewVal->ulLen == sizeof (GUID));
        // Copy this value into the entry's DSNAME struct.
        memcpy (&pAttRef->pEntry->pdn->Guid,
                (GUID *) pNewVal->pVal,
                sizeof (GUID));
        KCCSimInsertEntryIntoGuidTable (pAttRef->pEntry);
    }

    // Are we adding a SID?
    if (pAttRef->pAttr->attrType == ATT_OBJECT_SID) {
        // Copy the SID into the entry's DSNAME struct.
        strncpy (pAttRef->pEntry->pdn->Sid.Data,
                 (SYNTAX_SID *) pNewVal->pVal,
                 min (ulValLen, MAX_NT4_SID_SIZE));
        pAttRef->pEntry->pdn->SidLen = min (ulValLen, MAX_NT4_SID_SIZE);
    }

    // If the attribute is an LDAP Display Name, it means we've found
    // an attribute descriptor in the schema.  So, we should add its
    // objectCategory to the schema mapping.
    if (pAttRef->pAttr->attrType == ATT_LDAP_DISPLAY_NAME) {
        KCCSimSetObjCategory (
            KCCSimStringToAttrType ((SYNTAX_UNICODE *) pNewVal->pVal),
            pAttRef->pEntry->pdn
            );
    }

}

VOID
KCCSimAllocAddValueToAttribute (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  PBYTE                       pValData
    )
/*++

Routine Description:

    Copies a data block into the directory.

Arguments:

    pAttRef             - Pointer to a valid attribute reference.
    ulValLen            - The length of the data block.
    pValData            - The data to copy.

Return Value:

    None.

--*/
{
    PBYTE                           pValCopy;

    pValCopy = KCCSimAlloc (ulValLen);
    memcpy (pValCopy, pValData, ulValLen);
    KCCSimAddValueToAttribute (pAttRef, ulValLen, pValCopy);
}

BOOL
KCCSimIsValueInAttribute (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  PBYTE                       pValData
    )
/*++

Routine Description:

    Determines whether or not a particular value is in an attribute.

Arguments:

    pAttRef             - Pointer to a valid attribute reference.
    ulValLen            - The length of the value.
    pValData            - The value to check.

Return Value:

    TRUE if the specified value is in the attribute.

--*/
{
    PSIM_VALUE                      pValAt;
    BOOL                            bFound;

    Assert (KCCSimAttRefIsValid (pAttRef));
    Assert (pValData != NULL);

    bFound = FALSE;

    for (pValAt = pAttRef->pAttr->pValFirst;
         pValAt != NULL;
         pValAt = pValAt->next) {
        
        if (KCCSimCompare (
                pAttRef->pAttr->attrType,
                FI_CHOICE_EQUALITY,
                pValAt->ulLen,
                pValAt->pVal,
                ulValLen,
                pValData)) {
            bFound = TRUE;
            break;
        }

    }

    return bFound;
}

BOOL
KCCSimRemoveValueFromAttribute (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  PBYTE                       pValData
    )
/*++

Routine Description:

    Removes an attribute value from the directory.

Arguments:

    pAttRef             - Pointer to a valid attribute reference.
    ulValLen            - The length of the data block.
    pValData            - The data to remove.

Return Value:

    TRUE if the value was found and removed.
    FALSE if the value could not be found in the attribute.

--*/
{
    PSIM_VALUE                      pValAt, pValFound;
    BOOL                            bRemoved;

    Assert (KCCSimAttRefIsValid (pAttRef));
    Assert (pValData != NULL);

    // No values:
    if (pAttRef->pAttr->pValFirst == NULL) {
        return FALSE;
    }

    bRemoved = FALSE;

    // Base case: Check if the first value in the attribute matches
    if (KCCSimCompare (
            pAttRef->pAttr->attrType,
            FI_CHOICE_EQUALITY,
            pAttRef->pAttr->pValFirst->ulLen,
            pAttRef->pAttr->pValFirst->pVal,
            ulValLen,
            pValData)) {
        pValFound = pAttRef->pAttr->pValFirst;
        pAttRef->pAttr->pValFirst = pAttRef->pAttr->pValFirst->next;
        bRemoved = TRUE;
    } else {
    
        // Search for the parent of the matching value    
        pValAt = pAttRef->pAttr->pValFirst;
        while (pValAt->next != NULL) {

            if (KCCSimCompare (
                    pAttRef->pAttr->attrType,
                    FI_CHOICE_EQUALITY,
                    pValAt->next->ulLen,
                    pValAt->next->pVal,
                    ulValLen,
                    pValData)) {

                // pValAt is the parent of the matching value.
                pValFound = pValAt->next;
                pValAt->next = pValAt->next->next;
                bRemoved = TRUE;
                break;

            }
        }
    }

    if (bRemoved) {
        KCCSimFreeValue (&pValFound);
    }

    return bRemoved;
}

VOID
KCCSimFreeEntryAttributes (
    IN  PSIM_ENTRY                  pEntry
    )
/*++

Routine Description:

    Frees all the attributes associated with an entry.

Arguments:

    pEntry              - The entry to free.

Return Value:

    None.

--*/
{
    PSIM_ATTRIBUTE                  pAttrAt, pAttrNext;

    if (pEntry == NULL) {
        return;
    }

    pAttrAt = pEntry->pAttrFirst;
    while (pAttrAt != NULL) {
        pAttrNext = pAttrAt->next;
        KCCSimFreeAttribute (&pAttrAt);
        pAttrAt = pAttrNext;
    }

    pEntry->pAttrFirst = NULL;
    return;
}

VOID
KCCSimFreeEntryTree (
    IO  PSIM_ENTRY *                ppEntry
    )
/*++

Routine Description:

    Frees an entry and all its children.  Routines outside of
    dir.c should call KCCSimRemoveEntry instead.

Arguments:

    ppEntry             - Pointer to the entry to free.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pChildAt, pChildNext;

    if (ppEntry == NULL || *ppEntry == NULL)
        return;

    KCCSimRemoveEntryFromGuidTable (*ppEntry);
    KCCSimRemoveEntryFromDsnameTable (*ppEntry);
    KCCSimFreeEntryAttributes (*ppEntry);
    
    if ((*ppEntry)->pdn != NULL) {
        KCCSimFree ((*ppEntry)->pdn);
    }

    pChildAt = (*ppEntry)->children;
    while (pChildAt != NULL) {
        pChildNext = pChildAt->next;
        KCCSimFreeEntryTree (&pChildAt);
        pChildAt = pChildNext;
    }

    KCCSimFree (*ppEntry);
    *ppEntry = NULL;
}

SHORT
KCCSimNthAncestor (
    IN  const DSNAME *              pdn1,
    IN  const DSNAME *              pdn2
    )
/*++

Routine Description:

    Determines the number of levels separating pdn2 from pdn1.
    Operates purely syntactically and does not access the directory.

Arguments:

    pdn1, pdn2          - The DSNAMEs to compare.

Return Value:

    -1 if pdn1 is not an ancestor of pdn2.
     0 if pdn1 == pdn2.
     n if pdn1 is n levels above pdn2.
          (1 for parent, 2 for grandparent, etc)

--*/
{
    PDSNAME                         pdnTrimmed;
    unsigned                        count1, count2;
    SHORT                           iResult;

    if (CountNameParts (pdn1, &count1) ||
        CountNameParts (pdn2, &count2)) {
        // There was a parse error trying to count one of them
        return -1;
    }

    iResult = -1;   // Assume the worst

    if (count1 == count2) {         // Same level
        if (NameMatchedStringNameOnly (pdn1, pdn2)) {
            iResult = 0;            // They're identical
        }
    } else {

        // They're not on the same level.  See if pdn1 is an
        // ancestor of pdn2

        pdnTrimmed = (PDSNAME) KCCSimAlloc (pdn2->structLen);
        // _WHY_ isn't the first argument to TrimDSNameBy
        // a (const DSNAME *) instead of a (DSNAME *)???
        TrimDSNameBy ((PDSNAME) pdn2, count2-count1, pdnTrimmed);
        if (NameMatchedStringNameOnly (pdn1, pdnTrimmed)) {
            iResult = count2-count1;
        }
        KCCSimFree (pdnTrimmed);

    }

    return iResult;
}

PSIM_ENTRY
KCCSimDsnameToEntry (
    IN  const DSNAME *              pdn,
    IN  ULONG                       ulOptions
    )
/*++

Routine Description:

    Finds the directory entry associated with a DSNAME.

Arguments:

    pdn                 - The DSNAME to search for.
    ulOptions           - Several options ORed together.

    KCCSIM_NO_OPTIONS:
        Normal behavior.
    KCCSIM_WRITE:
        If no entry exists that corresponds to the specified DSNAME,
        create one.  If an entry does exist, destroy its contents.
    KCCSIM_STRING_NAME_ONLY:
        Ignores GUIDs in DSNAMEs and searches only by string name.

Return Value:

    The associated entry, or NULL if none exists.
    Note that if KCCSIM_WRITE is specified, this function will never
    return NULL.

--*/
{
    PSIM_ENTRY                      pCurEntry, pChildAt, pNewEntry;
    PDSNAME                         pdnParent;
    BOOL                            bIsParent, bNewEntry;
    DWORD                           dwRootParts, dwPdnParts;

    // If pdn is NULL, we return the root entry.  If the directory
    // is empty, this will just return NULL.
    if (pdn == NULL) {
        return g_pSimDir->pRootEntry;
    }

    // If this is an empty pdn, we have nothing to go on.
    // So we just return NULL
    if (pdn->NameLen == 0 &&
        fNullUuid (&pdn->Guid)) {
        return NULL;
    }

    // If WRITE is enabled, we must have a stringname and a NULL GUID.
    Assert (!((ulOptions & KCCSIM_WRITE) && (pdn->NameLen == 0)));
    Assert (!((ulOptions & KCCSIM_WRITE) && !fNullUuid (&pdn->Guid)));

    bNewEntry = FALSE;
    pCurEntry = NULL;

    // We prefer to search by GUID whenever possible.
    if (    (!(ulOptions & KCCSIM_STRING_NAME_ONLY))
         && (!fNullUuid (&pdn->Guid))) {
        pCurEntry = KCCSimLookupEntryByGuid (&pdn->Guid);
    }

    // Try searching our Dsname cache
    if( pCurEntry==NULL && pdn->NameLen>0 ) {
        pCurEntry = KCCSimLookupEntryByDsname( pdn );

        if(pCurEntry==NULL) {

            bNewEntry = TRUE;

            if( ulOptions&KCCSIM_WRITE ) {

                if( g_pSimDir->pRootEntry == NULL ) {
                    
                    // If the directory is empty, create the root entry
                    g_pSimDir->pRootEntry = KCCSIM_NEW (SIM_ENTRY);
                    pCurEntry = g_pSimDir->pRootEntry;
                                                                       
                } else {
    
                    // The root exists, but pdn didn't.
                    
                    // Check if we're trying to add an entry which is a sibling
                    // (or worse, parent) of the root entry. We want to allow
                    // root siblings so that we can support domain trees which
                    // are disjoint from the root. First we count the number of
                    // parts of the root name and the pdn we want to add.
                    if(CountNameParts(g_pSimDir->pRootEntry->pdn, &dwRootParts)) {
                        KCCSimException (
                            KCCSIM_ETYPE_INTERNAL,
                            KCCSIM_ERROR_INVALID_DSNAME,
                            g_pSimDir->pRootEntry->pdn
                            );
                    }

                    if(CountNameParts(pdn, &dwPdnParts)) {
                        KCCSimException (
                            KCCSIM_ETYPE_INTERNAL,
                            KCCSIM_ERROR_INVALID_DSNAME,
                            pdn
                            );
                    }

                    if( dwPdnParts <= dwRootParts ) {
                        
                        // We create a new entry, which will be added to our
                        // Dsname and Guid indices, but it won't be accessible
                        // as a child or sibling of any other entry.
                        pCurEntry = KCCSIM_NEW(SIM_ENTRY);
                    
                    } else {

                        // Look for the parent of pdn so that we can create pdn.
                        pdnParent = KCCSimAlloc( pdn->structLen );
                        TrimDSNameBy( (DSNAME*) pdn, 1, pdnParent );
        
                        pCurEntry = KCCSimLookupEntryByDsname( pdnParent );
                        if( NULL==pCurEntry ) {
                            KCCSimException (
                                KCCSIM_ETYPE_INTERNAL,
                                KCCSIM_ERROR_NO_PARENT_FOR_OBJ,
                                pdn->StringName
                                );
                        }
    
                        if( pCurEntry->children ) {
                            Assert( pCurEntry->lastChild->next == NULL );
                            pCurEntry->lastChild->next = KCCSIM_NEW (SIM_ENTRY);
                            pCurEntry->lastChild = pCurEntry->lastChild->next;
                            pCurEntry = pCurEntry->lastChild;
                        } else {
                            Assert( pCurEntry->lastChild == NULL );
                            pCurEntry->children = KCCSIM_NEW (SIM_ENTRY);
                            pCurEntry->lastChild = pCurEntry->children;
                            pCurEntry = pCurEntry->lastChild;                        
                        }
        
                        KCCSimFree( pdnParent );
                    }
                }

            } else {
                // Object was not found, and the write option is not on.
                // We just return NULL.
            }
        }
    }

    if (ulOptions & KCCSIM_WRITE) {
        if (pCurEntry == NULL) {
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_COULD_NOT_WRITE_ENTRY
                );
        }
        if (bNewEntry) {
            Assert (pCurEntry != NULL);
            pCurEntry->pdn = KCCSimAlloc (pdn->structLen);
            memcpy (pCurEntry->pdn, pdn, pdn->structLen);
            pCurEntry->pAttrFirst = NULL;
            pCurEntry->children = NULL;
            pCurEntry->next = NULL;
            KCCSimInsertEntryIntoGuidTable (pCurEntry);
            KCCSimInsertEntryIntoDsnameTable (pCurEntry);
        } else {
            // This is not a new entry.  Destroy the existing contents.
            Assert (pCurEntry != NULL);
            KCCSimRemoveEntryFromGuidTable (pCurEntry);
            KCCSimRemoveEntryFromDsnameTable (pCurEntry);
            KCCSimFreeEntryAttributes (pCurEntry);
            KCCSimCopyGuidAndSid (pCurEntry->pdn, pdn);
            KCCSimInsertEntryIntoGuidTable (pCurEntry);
            KCCSimInsertEntryIntoDsnameTable (pCurEntry);
        }
    }

    return pCurEntry;
}

VOID
KCCSimRemoveEntry (
    IO  PSIM_ENTRY *                ppEntry
    )
/*++

Routine Description:

    Removes an entry from the directory.

Arguments:

    ppEntry             - Pointer to the entry to remove.

Return Value:

    None.

--*/
{
    PDSNAME                         pdnParent;
    PSIM_ENTRY                      pEntry;
    PSIM_ENTRY                      pEntryParent;
    PSIM_ENTRY                      pEntryAt;

    Assert (ppEntry != NULL);
    pEntry = *ppEntry;              // Just for convenience
    Assert (pEntry != NULL);

    // Is this entry the root?
    if (pEntry == g_pSimDir->pRootEntry) {
        // The caller had better know what he's doing . . .
        g_pSimDir->pRootEntry = NULL;
    } else {

        // We want this entry's parent.
        pdnParent = KCCSimAlloc (pEntry->pdn->structLen);
        TrimDSNameBy (pEntry->pdn, 1, pdnParent);
        pEntryParent = KCCSimDsnameToEntry (pdnParent, KCCSIM_NO_OPTIONS);

        // Something is very wrong if the parent isn't in the dir
        Assert (pEntryParent != NULL);

        // Base case: This is the first child of the parent
        if (pEntry == pEntryParent->children) {
            pEntryParent->children = pEntryParent->children->next;
            
            // If the entry was the only one in the list, update
            // the tail pointer
            if( pEntryParent->children==NULL ) {
                pEntryParent->lastChild = NULL;
            }

        } else {

            // Find the child immediately before this one
            pEntryAt = pEntryParent->children;
            while (pEntryAt != NULL &&
                   pEntryAt->next != pEntry) {
                pEntryAt = pEntryAt->next;
            }

            // If we didn't find this entry's older sibling,
            // that means this entry isn't linked to its parent --
            // which should never happen
            Assert (pEntryAt != NULL);
            Assert (pEntryAt->next != NULL);

            // We found the entry -- it is pEntryAt->next
            Assert (pEntryAt->next == pEntry);

            // Skip over this entry in the list of siblings
            pEntryAt->next = pEntryAt->next->next;

            // Update the tail pointer
            if( pEntryAt->next==NULL ) {
                pEntryParent->lastChild = pEntryAt;
            }

        }


    }

    KCCSimFreeEntryTree (ppEntry);      // poof
}

PDSNAME
KCCSimAlwaysGetObjCategory (
    IN  ATTRTYP                     objClass
    )
/*++

Routine Description:

    Returns the object category associated with an object class.
    When we initially populated the directory, we may have found
    an entry in the schema tree corresponding to this object class.
    If this is the case, we'll use the object category that we
    already know.
    
    However, since the schema tree is huge, it takes quite a while
    to load from an ldif file.  We don't want the user to have to do
    this every time KCCSim is run.  So, it's quite possible that we
    don't know the object category at this point.  If that's the case,
    we make an educated guess by appending the default schema RDN
    to the DMD DN stored in the anchor.  We store the result in the
    schema table for easy lookup later on.

Arguments:

    objClass            - The object class to look for.

Return Value:

    The DSNAME of the object category.

--*/
{
    PDSNAME                         pdnObjCategory;
    LPCWSTR                         pwszSchemaRDN;

    Assert (g_pSimDir->anchor.pdnDmd != NULL);

    // Do we already know the object category?
    pdnObjCategory = KCCSimAttrObjCategory (objClass);

    if (pdnObjCategory == NULL) {

        // No, we don't.  This means it wasn't found in the schema.
        // This is ok: since we're running off of a simulated
        // directory, it's possible that the user just didn't want
        // to load the entire schema.  So we make an educated guess,
        // and store it in the global table for future reference.
        pwszSchemaRDN = KCCSimAttrSchemaRDN (objClass);
        // This objClass had better be in the table
        Assert (pwszSchemaRDN != NULL);

        pdnObjCategory = KCCSimAllocAppendRDN (
            g_pSimDir->anchor.pdnDmd,
            pwszSchemaRDN,
            ATT_COMMON_NAME
            );
        // Store this object category in the schema table.
        KCCSimSetObjCategory (objClass, pdnObjCategory);

        // We want to return a pointer to the DSNAME struct
        // that's stored in the schema table, since the user
        // isn't expected to free the return value.
        KCCSimFree (pdnObjCategory);
        pdnObjCategory = KCCSimAttrObjCategory (objClass);
        Assert (pdnObjCategory != NULL);

    }

    return pdnObjCategory;
}

LPWSTR
KCCSimAllocGuidBasedDNSNameFromDSName (
    IN  const DSNAME *              pdn
    )
/*++

Routine Description:

    This function does just what it says -- transforms a
    DSNAME to a guid-based DNS name.

Arguments:

    pdn                 - The DSNAME to convert.

Return Value:

    An allocated buffer that holds the guid-based DNS name.

--*/
{
    GUID                            guidCopy;
    LPWSTR                          pwszStringizedGuid;
    LPWSTR                          pwszGuidBasedDNSName;
    ULONG                           ulLen;

    Assert (g_pSimDir->anchor.pwszRootDomainDNSName != NULL);

    // UuidToStringW isn't very nice.  It wants a GUID * when it
    // should really only need a const GUID *.  So we have to make a copy.
    memcpy (&guidCopy, &pdn->Guid, sizeof (GUID));
    KCCSIM_CHKERR (UuidToStringW (
        &guidCopy,
        &pwszStringizedGuid
        ));

    Assert (36 == wcslen (pwszStringizedGuid));
    ulLen = 36 /* guid */ + 8 /* "._mcdcs." */ +
      wcslen (g_pSimDir->anchor.pwszRootDomainDNSName) /* root DNS */ + 1 /* \0 */;
    pwszGuidBasedDNSName = KCCSimAlloc (sizeof (WCHAR) * ulLen);
    swprintf (
        pwszGuidBasedDNSName,
        L"%s._msdcs.%s",
        pwszStringizedGuid,
        g_pSimDir->anchor.pwszRootDomainDNSName
        );

    RpcStringFreeW (&pwszStringizedGuid);

    return pwszGuidBasedDNSName;
}

// This little routine:
// (1) Checks to see if the specified DSNAME is in the directory (by string)
// (2) If it is, copies the GUID and SID out of the directory

BOOL
KCCSimUpdateDsnameFromDirectory (
    IO  PDSNAME                     pdn
    )
/*++

Routine Description:

    Updates a DSNAME's GUID and SID from the directory.

Arguments:

    pdn                 - The DSNAME to update

Return Value:

    TRUE if the DSNAME was found and updated.
    FALSE if the DSNAME could not be found in the directory.

--*/
{
    PSIM_ENTRY                      pEntry;

    pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_STRING_NAME_ONLY);

    if (pEntry != NULL) {
        KCCSimCopyGuidAndSid (pdn, pEntry->pdn);
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
KCCSimIsEntryOfObjectClass (
    IN  PSIM_ENTRY                  pEntry,
    IN  ATTRTYP                     objClass,
    IN  const DSNAME *              pdnObjCategory OPTIONAL
    )
/*++

Routine Description:

    Determines if an entry matches a specified object class.
    If pdnObjCategory is specified, the function will first
    search by object category, then by object class.  If
    pdnObjCategory is NULL, it will search only by object class.

Arguments:

    pEntryStart         - The first entry to search.
    objClass            - The object class to search for.
    pdnObjCategory      - The object category to search for.

Return Value:

    TRUE if the entry matches the specified object class.

--*/
{
    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pValAt;
    ATTRTYP                         curObjClass;
    BOOL                            bFound;

    // First try to use the object category.
    if (pdnObjCategory != NULL) {

        KCCSimGetAttribute (pEntry, ATT_OBJECT_CATEGORY, &attRef);
        if (attRef.pAttr != NULL &&
            attRef.pAttr->pValFirst != NULL &&
            NameMatched (pdnObjCategory, (SYNTAX_DISTNAME *) attRef.pAttr->pValFirst->pVal)) {
            // Found it!
            return TRUE;
        }
        
    }

    // We failed to find it by object category.  So search by object class.
    bFound = FALSE;
    KCCSimGetAttribute (pEntry, ATT_OBJECT_CLASS, &attRef);
    if (attRef.pAttr != NULL &&
        attRef.pAttr->pValFirst != NULL) {
        for (pValAt = attRef.pAttr->pValFirst;
             pValAt != NULL;
             pValAt = pValAt->next) {
            Assert (pValAt->pVal != NULL);
            curObjClass = *((SYNTAX_OBJECT_ID *) pValAt->pVal);
            if (curObjClass == objClass) {
                bFound = TRUE;
                break;
            }
        }
    }
    return bFound;
}

PSIM_ENTRY
KCCSimFindFirstChild (
    IN  PSIM_ENTRY                  pEntryParent,
    IN  ATTRTYP                     objClass,
    IN  const DSNAME *              pdnObjCategory OPTIONAL
    )
/*++

Routine Description:

    Finds the oldest child of a directory entry that matches
    the specified object class or object category.

Arguments:

    pEntryParent        - The parent entry to search from.
    objClass            - The object class to search for.
    pdnObjCategory      - The object category to search for.

Return Value:

    The first matching entry, or NULL if none exist.

--*/
{
    PSIM_ENTRY                      pEntryAt;

    Assert (pEntryParent != NULL);

    for (pEntryAt = pEntryParent->children;
         pEntryAt != NULL;
         pEntryAt = pEntryAt->next) {

        if (KCCSimIsEntryOfObjectClass (
                pEntryAt, objClass, pdnObjCategory)) {
            break;
        }

    }

    return pEntryAt;
}

PSIM_ENTRY
KCCSimFindNextChild (
    IN  PSIM_ENTRY                  pEntryThisChild,
    IN  ATTRTYP                     objClass,
    IN  const DSNAME *              pdnObjCategory OPTIONAL
    )
/*++

Routine Description:

    This function should be called after KCCSimFindFirstChild.
    It finds the next child that matches the specified object
    class or object category.

Arguments:

    pEntryThisChild     - The return value of a call to
                          KCCSimFindFirstChild or KCCSimFindNextChild.
    objClass            - The object class to search for.
    pdnObjCategory      - The object category to search for.

Return Value:

    The next matching entry, or NULL if no more exist.

--*/
{
    PSIM_ENTRY                      pEntryAt;

    Assert (pEntryThisChild != NULL);

    for (pEntryAt = pEntryThisChild->next;
         pEntryAt != NULL;
         pEntryAt = pEntryAt->next) {

        if (KCCSimIsEntryOfObjectClass (
                pEntryAt, objClass, pdnObjCategory)) {
            break;
        }

    }

    return pEntryAt;
}

const DSNAME *
KCCSimAnchorDn (
    IN  KCCSIM_ANCHOR_ID            anchorId
    )
/*++

Routine Description:

    Fetches a DN from the anchor.

Arguments:

    anchorId            - The DN to fetch, KCCSIM_ANCHOR_*_DN.

Return Value:

    The DSNAME from the anchor.

--*/
{
    PDSNAME                         pdn = NULL;

    switch (anchorId) {
        case KCCSIM_ANCHOR_DMD_DN:
            pdn = g_pSimDir->anchor.pdnDmd;
            break;
        case KCCSIM_ANCHOR_DSA_DN:
            pdn = g_pSimDir->anchor.pdnDsa;
            break;
        case KCCSIM_ANCHOR_DOMAIN_DN:
            pdn = g_pSimDir->anchor.pdnDomain;
            break;
        case KCCSIM_ANCHOR_CONFIG_DN:
            pdn = g_pSimDir->anchor.pdnConfig;
            break;
        case KCCSIM_ANCHOR_ROOT_DOMAIN_DN:
            pdn = g_pSimDir->anchor.pdnRootDomain;
            break;
        case KCCSIM_ANCHOR_LDAP_DMD_DN:
            pdn = g_pSimDir->anchor.pdnLdapDmd;
            break;
        case KCCSIM_ANCHOR_PARTITIONS_DN:
            pdn = g_pSimDir->anchor.pdnPartitions;
            break;
        case KCCSIM_ANCHOR_DS_SVC_CONFIG_DN:
            pdn = g_pSimDir->anchor.pdnDsSvcConfig;
            break;
        case KCCSIM_ANCHOR_SITE_DN:
            pdn = g_pSimDir->anchor.pdnSite;
            break;
        default:
            Assert (!L"Invalid parameter in KCCSimAnchorDn.");
            break;
    }

    Assert (pdn != NULL);
    return pdn;
}

LPCWSTR
KCCSimAnchorString (
    IN  KCCSIM_ANCHOR_ID            anchorId
    )
/*++

Routine Description:

    Fetches a string from the anchor.

Arguments:

    anchorId            - The string to fetch, KCCSIM_ANCHOR_*_NAME.

Return Value:

    The string from the anchor.

--*/
{
    LPCWSTR                         pwsz = NULL;

    switch (anchorId) {
        case KCCSIM_ANCHOR_DOMAIN_NAME:
            pwsz = g_pSimDir->anchor.pwszDomainName;
            break;
        case KCCSIM_ANCHOR_DOMAIN_DNS_NAME:
            pwsz = g_pSimDir->anchor.pwszDomainDNSName;
            break;
        case KCCSIM_ANCHOR_ROOT_DOMAIN_DNS_NAME:
            pwsz = g_pSimDir->anchor.pwszRootDomainDNSName;
            break;
        default:
            Assert (!L"Invalid parameter in KCCSimAnchorString.");
            break;
    }

    Assert (pwsz != NULL);
    return pwsz;
}

VOID
KCCSimFreeAnchor (
    VOID
    )
/*++

Routine Description:

    Frees the anchor.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Assert (g_pSimDir != NULL);

    KCCSimFree (g_pSimDir->anchor.pdnDomain);
    g_pSimDir->anchor.pdnDomain = NULL;
    KCCSimFree (g_pSimDir->anchor.pdnConfig);
    g_pSimDir->anchor.pdnConfig = NULL;
    KCCSimFree (g_pSimDir->anchor.pdnRootDomain);
    g_pSimDir->anchor.pdnRootDomain = NULL;
    KCCSimFree (g_pSimDir->anchor.pdnLdapDmd);
    g_pSimDir->anchor.pdnLdapDmd = NULL;
    KCCSimFree (g_pSimDir->anchor.pdnPartitions);
    g_pSimDir->anchor.pdnPartitions = NULL;
    KCCSimFree (g_pSimDir->anchor.pdnDsSvcConfig);
    g_pSimDir->anchor.pdnDsSvcConfig = NULL;
    KCCSimFree (g_pSimDir->anchor.pdnSite);
    g_pSimDir->anchor.pdnSite = NULL;
    KCCSimFree (g_pSimDir->anchor.pwszDomainName);
    g_pSimDir->anchor.pwszDomainName = NULL;
    KCCSimFree (g_pSimDir->anchor.pwszDomainDNSName);
    g_pSimDir->anchor.pwszDomainDNSName = NULL;
    KCCSimFree (g_pSimDir->anchor.pwszRootDomainDNSName);
    g_pSimDir->anchor.pwszRootDomainDNSName = NULL;
}

VOID
KCCSimBuildAnchor (
    IN  LPCWSTR                     pwszDsaDn
    )
/*++

Routine Description:

    Builds the anchor.  This should be called after a
    directory has been loaded.  It populates the anchor with
    information from the directory, from the viewpoint of
    pwszDsaDn.

    If this is called again with a different DSA DN, it will
    free the existing anchor before building a new one.

Arguments:

    pwszDsaDn           - The DN of a valid NTDS Settings object.

Return Value:

    None.

--*/
{
    WCHAR                          *wszBuf;
    PSIM_ENTRY                      pEntryDsa, pEntryPartitions, pEntryCrossRef;
    SIM_ATTREF                      attRef, attRefNcName;
    PSIM_VALUE                      pValNCAt;

    // Free the existing anchor, if present.
    KCCSimFreeAnchor ();

    // If there is no DSA DN, it means the user failed to specify one
    // on the commandline.  We can't do anything, so just give up
    if (pwszDsaDn == NULL || pwszDsaDn[0] == '\0') {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_NO_DSA_DN
            );
    }

    g_pSimDir->anchor.pdnDsa = KCCSimAllocDsname (pwszDsaDn);
    // Check that the specified DSA DN really is in the directory.
    // If not, give up
    pEntryDsa = KCCSimDsnameToEntry (g_pSimDir->anchor.pdnDsa, KCCSIM_NO_OPTIONS);
    if (pEntryDsa == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_DN_NOT_IN_DIRECTORY,
            pwszDsaDn
            );
    }
    KCCSimUpdateDsnameFromDirectory (g_pSimDir->anchor.pdnDsa);

    // Derive the site DN from the DSA DN.
    g_pSimDir->anchor.pdnSite =
      (PDSNAME) KCCSimAlloc (g_pSimDir->anchor.pdnDsa->structLen);
    if (0 != TrimDSNameBy (g_pSimDir->anchor.pdnDsa, 3, g_pSimDir->anchor.pdnSite)) {
        // We couldn't trim 3 RDNs off of the DSA DN.  That must be because the
        // DSA DN is not valid.
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_INVALID_DSA_DN
            );
    }
    KCCSimUpdateDsnameFromDirectory (g_pSimDir->anchor.pdnSite);

    // Derive the config DN from the Site DN.  It must be shorter.
    g_pSimDir->anchor.pdnConfig =
      (PDSNAME) KCCSimAlloc (g_pSimDir->anchor.pdnSite->structLen);
    if (0 != TrimDSNameBy (g_pSimDir->anchor.pdnSite, 2, g_pSimDir->anchor.pdnConfig)) {
        // We couldn't trim 2 RDNs off of the Site DN.  That's the DSA DN's problem
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_INVALID_DSA_DN
            );
    }
    KCCSimUpdateDsnameFromDirectory (g_pSimDir->anchor.pdnConfig);

    // Derive the root DN from the config DN.  It must be shorter
    g_pSimDir->anchor.pdnRootDomain =
      (PDSNAME) KCCSimAlloc (g_pSimDir->anchor.pdnConfig->structLen);
    if (0 != TrimDSNameBy (g_pSimDir->anchor.pdnConfig, 1, g_pSimDir->anchor.pdnRootDomain)) {
        // We couldn't trim 1 RDN off of the Config DN.
        // Again that's a problem with the DSA DN.
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_INVALID_DSA_DN
            );
    }

    // Check that the derived root DN really is in the directory.
    // If not, something's wrong with the DSA DN
    if (!KCCSimUpdateDsnameFromDirectory (g_pSimDir->anchor.pdnRootDomain)) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_INVALID_DSA_DN
            );
    }

    // Partitions:
    g_pSimDir->anchor.pdnPartitions = KCCSimAllocAppendRDN (
        g_pSimDir->anchor.pdnConfig,
        KCCSIM_PARTITIONS_RDN,
        ATT_COMMON_NAME
        );
    pEntryPartitions = KCCSimDsnameToEntry (g_pSimDir->anchor.pdnPartitions, KCCSIM_NO_OPTIONS);
    if (pEntryPartitions == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_DN_NOT_IN_DIRECTORY,
            g_pSimDir->anchor.pdnPartitions->StringName
            );
    }

    // Service config:
    wszBuf = (WCHAR*) KCCSimAlloc( sizeof(WCHAR)*
        (  1 + wcslen(KCCSIM_SERVICES_CONTAINER)
         + g_pSimDir->anchor.pdnConfig->structLen)
        );
    swprintf (
        wszBuf,
        L"%s%s",
        KCCSIM_SERVICES_CONTAINER,
        g_pSimDir->anchor.pdnConfig->StringName
        );
    g_pSimDir->anchor.pdnDsSvcConfig = KCCSimAllocDsname( wszBuf );
    KCCSimFree( wszBuf );
    KCCSimUpdateDsnameFromDirectory (g_pSimDir->anchor.pdnDsSvcConfig);

    // Now we get the DMD location.  This will be an attribute of the
    // DSA entry.  It also gives us the LDAP DMD location.
    KCCSimGetAttribute (
        pEntryDsa,
        ATT_DMD_LOCATION,
        &attRef
        );
    if (attRef.pAttr == NULL ||
        attRef.pAttr->pValFirst == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_NO_DMD_LOCATION
            );
    }

    g_pSimDir->anchor.pdnDmd = (PDSNAME) KCCSimAlloc
        (attRef.pAttr->pValFirst->ulLen);
    memcpy (
        g_pSimDir->anchor.pdnDmd,
        attRef.pAttr->pValFirst->pVal,
        attRef.pAttr->pValFirst->ulLen
        );
    if (!KCCSimUpdateDsnameFromDirectory (g_pSimDir->anchor.pdnDmd)) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_DN_NOT_IN_DIRECTORY,
            g_pSimDir->anchor.pdnDmd->StringName
            );
    }

    // Now we make the LDAP DMD Dn
    g_pSimDir->anchor.pdnLdapDmd = KCCSimAllocAppendRDN (
        g_pSimDir->anchor.pdnDmd,
        KCCSIM_AGGREGATE_RDN,
        ATT_COMMON_NAME
        );
    KCCSimUpdateDsnameFromDirectory (g_pSimDir->anchor.pdnLdapDmd);

    // Next we get the local domain name.  This DSA will have 3 writable NCs:
    // The config dn, the DMD dn and the local dn.  So we look at its NCs, and
    // whichever is neither the config nor the DMD dn is the one we want.
    KCCSimGetAttribute (
        pEntryDsa,
        ATT_HAS_MASTER_NCS,
        &attRef
        );
    if (attRef.pAttr != NULL) {
        for (pValNCAt = attRef.pAttr->pValFirst;
             pValNCAt != NULL;
             pValNCAt = pValNCAt->next) {
            if (!NameMatched (
                    (PDSNAME) pValNCAt->pVal,
                    g_pSimDir->anchor.pdnConfig) &&
                !NameMatched (
                    (PDSNAME) pValNCAt->pVal,
                    g_pSimDir->anchor.pdnDmd)) {
                g_pSimDir->anchor.pdnDomain = (PDSNAME) KCCSimAlloc
                    (pValNCAt->ulLen);
                memcpy (
                    g_pSimDir->anchor.pdnDomain,
                    pValNCAt->pVal,
                    pValNCAt->ulLen
                    );
                if (!KCCSimUpdateDsnameFromDirectory (g_pSimDir->anchor.pdnDomain)) {
                    KCCSimException (
                        KCCSIM_ETYPE_INTERNAL,
                        KCCSIM_ERROR_CANT_INIT_DN_NOT_IN_DIRECTORY,
                        g_pSimDir->anchor.pdnDomain->StringName
                        );
                }
                break;
            }
        }
    }

    if (g_pSimDir->anchor.pdnDomain == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_INVALID_MASTER_NCS
            );
    }

    // Now, we want to get some information out of the partitions container.

    for (pEntryCrossRef = KCCSimFindFirstChild (
            pEntryPartitions, CLASS_CROSS_REF, NULL);
         pEntryCrossRef != NULL;
         pEntryCrossRef = KCCSimFindNextChild (
            pEntryCrossRef, CLASS_CROSS_REF, NULL)) {

        // See if this is the root domain cross-ref.
        KCCSimGetAttribute (
            pEntryCrossRef,
            ATT_NC_NAME,
            &attRefNcName
            );
        if (attRefNcName.pAttr != NULL &&
            attRefNcName.pAttr->pValFirst != NULL &&
            NameMatched (
                g_pSimDir->anchor.pdnRootDomain,
                (PDSNAME) attRefNcName.pAttr->pValFirst->pVal)) {
            // It is.
            KCCSimGetAttribute (
                pEntryCrossRef,
                ATT_DNS_ROOT,
                &attRef
                );
            if (attRef.pAttr != NULL &&
                attRef.pAttr->pValFirst != NULL) {
                g_pSimDir->anchor.pwszRootDomainDNSName = KCCSIM_WCSDUP
                    ((LPWSTR) attRef.pAttr->pValFirst->pVal);
            }
        }

        // See if this is the local domain cross-ref.
        if (attRefNcName.pAttr != NULL &&
            attRefNcName.pAttr->pValFirst != NULL &&
            NameMatched (
                g_pSimDir->anchor.pdnDomain,
                (PDSNAME) attRefNcName.pAttr->pValFirst->pVal)) {
            // It is.
            KCCSimGetAttribute (
                pEntryCrossRef,
                ATT_DNS_ROOT,
                &attRef
                );
            if (attRef.pAttr != NULL &&
                attRef.pAttr->pValFirst != NULL) {
                g_pSimDir->anchor.pwszDomainDNSName = KCCSIM_WCSDUP
                    ((LPWSTR) attRef.pAttr->pValFirst->pVal);
            }
            KCCSimGetAttribute (
                pEntryCrossRef,
                ATT_NETBIOS_NAME,
                &attRef
                );
            if (attRef.pAttr != NULL &&
                attRef.pAttr->pValFirst != NULL) {
                g_pSimDir->anchor.pwszDomainName = KCCSIM_WCSDUP
                    ((LPWSTR) attRef.pAttr->pValFirst->pVal);
            }
        }

    }

    if (g_pSimDir->anchor.pwszRootDomainDNSName == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_NO_CROSS_REF,
            g_pSimDir->anchor.pdnRootDomain->StringName
            );
    }
    if (g_pSimDir->anchor.pwszDomainName == NULL ||
        g_pSimDir->anchor.pwszDomainDNSName == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_NO_CROSS_REF,
            g_pSimDir->anchor.pdnDomain->StringName
            );
    }

}

ATTRTYP
KCCSimUpdateObjClassAttr (
    IN  PSIM_ATTREF                 pAttRef
    )
/*++

Routine Description:

    Updates an object class attribute, i.e. fills in all super-classes
    if they are missing.  So if the only value in the attribute is
    CLASS_NTDS_SITE_SETTINGS, this routine will add
    CLASS_APPLICATION_SITE_SETTINGS and CLASS_TOP.

Arguments:

    pAttr               - The attribute to update.

Return Value:

    The most specific object class in the attribute.  In the above
    example, this would return CLASS_NTDS_SITE_SETTINGS.

--*/
{
    #define MAX_CLASSES             10  // The maximum number of values
                                        // in an objClass attribute

    PSIM_VALUE                      pValAt;
    ATTRTYP                         objClass[MAX_CLASSES],
                                    superClass[MAX_CLASSES];
    ATTRTYP                         objClassMostSpecific = INVALID_ATT;
    BOOL                            bFoundSuperClass, bFoundMostSpecific;
    ULONG                           ulNumClasses, ulClass, ul;

    Assert (KCCSimAttRefIsValid (pAttRef));
    Assert (pAttRef->pAttr->attrType == ATT_OBJECT_CLASS);

    // Count the number of object classes, copy them into a convenient
    // array, and create another array that contains the superclass of
    // each object class.
    ulNumClasses = 0;
    for (pValAt = pAttRef->pAttr->pValFirst;
         pValAt != NULL;
         pValAt = pValAt->next) {
        // If this assert is ever fired, we need to raise MAX_CLASSES
        Assert (ulNumClasses < MAX_CLASSES);
        objClass[ulNumClasses] = *((SYNTAX_OBJECT_ID *) pValAt->pVal);
        superClass[ulNumClasses] = KCCSimAttrSuperClass (objClass[ulNumClasses]);
        ulNumClasses++;
    }

    // Now make sure that, for each class, its super-class is in the
    // attribute (objClass array).  If it isn't, then add it
    for (ulClass = 0; ulClass < ulNumClasses; ulClass++) {
        bFoundSuperClass = FALSE;
        for (ul = 0; ul < ulNumClasses; ul++) {
            if (objClass[ul] == superClass[ulClass]) {
                bFoundSuperClass = TRUE;
                break;
            }
        }
        if (!bFoundSuperClass) {
            KCCSimAllocAddValueToAttribute (
                pAttRef,
                sizeof (ATTRTYP),
                (PBYTE) &superClass[ulClass]
                );
            // Now the new class we just added might have its own
            // superclass that differs from anything we've seen before.
            // We may need to add that in as well - so stick it on the
            // end of the array, and increase ulNumClasses.
            Assert (ulNumClasses < MAX_CLASSES);
            objClass[ulNumClasses] = superClass[ulClass];
            superClass[ulNumClasses] = KCCSimAttrSuperClass (objClass[ulNumClasses]);
            ulNumClasses++;
        }
    }

    // Now we pick the most specific object class.  If there is only
    // one, then it is obviously the one we want; otherwise we find the class
    // that does not appear as the super-class of anything in the attribute.

    if (ulNumClasses == 1) {
        objClassMostSpecific = objClass[0];
    } else {
        bFoundMostSpecific = FALSE;
        for (ulClass = 0; ulClass < ulNumClasses; ulClass++) {
            // Assume it's the most specific until proven otherwise
            bFoundMostSpecific = TRUE;
            for (ul = 0; ul < ulNumClasses; ul++) {
                if (superClass[ul] == objClass[ulClass]) {
                    bFoundMostSpecific = FALSE;
                    break;
                }
            }
            if (bFoundMostSpecific) {
                objClassMostSpecific = objClass[ulClass];
                break;
            }
        }
        // And unless there are class-inheritance loops in the schema
        // table (in which case we have bigger problems):
        Assert (bFoundMostSpecific);
    }

    return objClassMostSpecific;
}

VOID
KCCSimAddMissingAttributes (
    IN  PSIM_ENTRY                  pEntry
    )
/*++

Routine Description:

    Checks to see if certain vital attributes (e.g. objectGUID,
    distinguishedName) are present, and fills them in if they are
    absent.

Arguments:

    pEntry              - The entry to fill in.

Return Value:

    None.

--*/
{
    SIM_ATTREF                      attRef;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];

    ATTRTYP                         objClassForCategory;
    PDSNAME                         pdnObjCategory;

    Assert (pEntry != NULL);

    KCCSimQuickRDNOf (pEntry->pdn, wszRDN);

    // objectGUID:
    if (!KCCSimGetAttribute (pEntry, ATT_OBJECT_GUID, NULL)) {

        KCCSimNewAttribute (pEntry, ATT_OBJECT_GUID, &attRef);
        // First make sure there is a GUID in the object dn.
        if (fNullUuid (&pEntry->pdn->Guid)) {
            // The dn has no GUID either!  So we'll have to make one up.
            KCCSIM_CHKERR (UuidCreate (&pEntry->pdn->Guid));
        }
        // Now add the dn's GUID to the attribute.
        KCCSimAllocAddValueToAttribute (
            &attRef,
            sizeof (GUID),
            (PBYTE) &pEntry->pdn->Guid
            );

    }

    // distinguishedName:
    if (!KCCSimGetAttribute (pEntry, ATT_OBJ_DIST_NAME, NULL)) {
        KCCSimNewAttribute (pEntry, ATT_OBJ_DIST_NAME, &attRef);
        KCCSimAllocAddValueToAttribute (
            &attRef,
            pEntry->pdn->structLen,
            (PBYTE) pEntry->pdn
            );
    }
    // name:
    if (!KCCSimGetAttribute (pEntry, ATT_RDN, NULL)) {
        KCCSimNewAttribute (pEntry, ATT_RDN, &attRef);
        KCCSimAllocAddValueToAttribute (
            &attRef,
            KCCSIM_WCSMEMSIZE (wszRDN),
            (PBYTE) wszRDN
            );
    }
    // cn:
    if (!KCCSimGetAttribute (pEntry, ATT_COMMON_NAME, NULL)) {
        KCCSimNewAttribute (pEntry, ATT_COMMON_NAME, &attRef);
        KCCSimAllocAddValueToAttribute (
            &attRef,
            KCCSIM_WCSMEMSIZE (wszRDN),
            (PBYTE) wszRDN
            );
    }

    // Finally, we do objectClass and objectCategory.
    
    if (KCCSimGetAttribute (pEntry, ATT_OBJECT_CLASS, &attRef)) {

        objClassForCategory = KCCSimUpdateObjClassAttr (&attRef);

        // Finally, add the category, if necessary
        if (!KCCSimGetAttribute (pEntry, ATT_OBJECT_CATEGORY, NULL)) {
            KCCSimNewAttribute (pEntry, ATT_OBJECT_CATEGORY, &attRef);
            pdnObjCategory = KCCSimAlwaysGetObjCategory (objClassForCategory);
            KCCSimAllocAddValueToAttribute (
                &attRef,
                pdnObjCategory->structLen,
                (PBYTE) pdnObjCategory
                );
        }

    }
}

VOID
KCCSimUpdatePropertyMetaData (
    IN  PSIM_ATTREF                 pAttRef,
    IN  const UUID *                puuidDsaOriginating OPTIONAL
    )
/*++

Routine Description:

    Updates the property meta data for an attribute.

Arguments:

    pAttRef             - Pointer to the attribute reference for the attribute
                          to update.
    puuidDsaOriginating - The originating DSA's UUID.  A null uuid is used
                          if this parameter is omitted.

Return Value:

    None.

--*/
{
    SIM_ATTREF                      attRefPropertyMetaData;
    PROPERTY_META_DATA_VECTOR *     pMetaDataVector;
    PROPERTY_META_DATA *            pThisMetaData;
    ATTRMODLIST                     attrModList;

    ULONG                           ulMDAt;

    Assert (KCCSimAttRefIsValid (pAttRef));

    // First get this entry's property meta data.
    if (KCCSimGetAttribute (
            pAttRef->pEntry,
            ATT_REPL_PROPERTY_META_DATA,
            &attRefPropertyMetaData
            )) {

        // There exists a property meta data vector attribute.
        Assert (attRefPropertyMetaData.pAttr->pValFirst != NULL);
        pMetaDataVector = (PROPERTY_META_DATA_VECTOR *)
            attRefPropertyMetaData.pAttr->pValFirst->pVal;
        Assert (pMetaDataVector->dwVersion == 1);

        // Find this attribute in the vector.
        pThisMetaData = NULL;
        for (ulMDAt = 0; ulMDAt < pMetaDataVector->V1.cNumProps; ulMDAt++) {
            if (pMetaDataVector->V1.rgMetaData[ulMDAt].attrType ==
                pAttRef->pAttr->attrType) {
                pThisMetaData = &pMetaDataVector->V1.rgMetaData[ulMDAt];
                break;
            }
        }

        if (pThisMetaData == NULL) {
            // We didn't find it, so allocate space for a new one.
            attRefPropertyMetaData.pAttr->pValFirst->pVal = KCCSimReAlloc (
                attRefPropertyMetaData.pAttr->pValFirst->pVal,
                attRefPropertyMetaData.pAttr->pValFirst->ulLen +
                    sizeof (PROPERTY_META_DATA)
            );
            pMetaDataVector = (PROPERTY_META_DATA_VECTOR *)
                attRefPropertyMetaData.pAttr->pValFirst->pVal;
            pMetaDataVector->V1.cNumProps++;
            pThisMetaData = &pMetaDataVector->V1.rgMetaData
                [pMetaDataVector->V1.cNumProps-1];
            pThisMetaData->dwVersion = 0;
        }

    } else {

        // No property meta data vector exists; we must create a new one.
        KCCSimNewAttribute (
            pAttRef->pEntry,
            ATT_REPL_PROPERTY_META_DATA,
            &attRefPropertyMetaData
            );
        pMetaDataVector = KCCSIM_NEW (PROPERTY_META_DATA_VECTOR);
        KCCSimAddValueToAttribute (
            &attRefPropertyMetaData,
            sizeof (PROPERTY_META_DATA_VECTOR),
            (PBYTE) pMetaDataVector
            );
        pMetaDataVector->dwVersion = 1;
        pMetaDataVector->V1.cNumProps = 1;
        pThisMetaData = &pMetaDataVector->V1.rgMetaData[0];
        pThisMetaData->dwVersion = 0;

    }

    // Do the actual updating.
    pThisMetaData->attrType = pAttRef->pAttr->attrType;
    pThisMetaData->dwVersion++;
    pThisMetaData->timeChanged = SimGetSecondsSince1601 ();
    if (puuidDsaOriginating == NULL) {
        RtlZeroMemory (&pThisMetaData->uuidDsaOriginating, sizeof (UUID));
    } else {
        memcpy (
            &(pThisMetaData->uuidDsaOriginating),
            puuidDsaOriginating,
            sizeof (UUID)
            );
    }
    pThisMetaData->usnOriginating = 0;
    pThisMetaData->usnProperty = 0;

    return;
}

VOID
KCCSimUpdateWholeDirectoryRecurse (
    IN  PSIM_ENTRY                  pEntry
    )
/*++

Routine Description:

    Updates the directory starting at pEntry.
    When ldifldap supplies us with DSNAMEs, it neglects to include
    GUIDs and SIDs.  When a DSNAME-valued attribute is read, we do
    not necessarily know anything about the actual directory entry
    that it refers to (since the reference may occur sooner in the
    LDIF file than the actual entry.)  Therefore, after reading in
    a simulated directory, we must scan through all DSNAME-valued
    attributes and, where appropriate, update them with the
    corresponding GUIDs and SIDs.

Arguments:

    pEntry              - The base of the tree.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pChildAt;
    PSIM_ATTRIBUTE                  pAttrAt;
    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pValAt;

    if (pEntry == NULL) {
        return;
    }

    // We begin by updating the current entry.  We cycle through
    // and update each attribute.

    for (pAttrAt = pEntry->pAttrFirst;
         pAttrAt != NULL;
         pAttrAt = pAttrAt->next) {

        if (ATT_OBJ_DIST_NAME == pAttrAt->attrType) {

            // If the attribute is a distinguishedName, we simply copy the GUID
            // and SID out of this entry's Dsname.

            Assert (pAttrAt->pValFirst != NULL);
            Assert (pAttrAt->pValFirst->pVal != NULL);
            Assert (NameMatchedStringNameOnly (
                            (SYNTAX_DISTNAME *) pAttrAt->pValFirst->pVal,
                            pEntry->pdn));

            KCCSimCopyGuidAndSid (
                (SYNTAX_DISTNAME *) pAttrAt->pValFirst->pVal,
                pEntry->pdn
                );

        } else if (KCCSimAttrSyntaxType (pAttrAt->attrType) == SYNTAX_DISTNAME_TYPE) {

            // If this is a DISTNAME that is not a distinguishedName attribute,
            // we call UpdateDsnameFromDirectory.

            for (pValAt = pAttrAt->pValFirst;
                 pValAt != NULL;
                 pValAt = pValAt->next) {
                KCCSimUpdateDsnameFromDirectory (
                    (SYNTAX_DISTNAME *) pValAt->pVal
                    );
            }

        }

        // If this attribute is an inter-site topology generator attribute, we
        // need to update its metadata to appease the KCC.
        // We cannot rely on the metadata being present, because ldifde doesn't
        // (and shouldn't) export metadata by default.  Forcing the user to
        // supply metadata for every entry in the directory would create
        // enormous overhead.
        if (pAttrAt->attrType == ATT_INTER_SITE_TOPOLOGY_GENERATOR) {
            attRef.pEntry = pEntry;
            attRef.pAttr = pAttrAt;
            KCCSimUpdatePropertyMetaData (&attRef, NULL);
        }

    }

    // Now update this entry's children.

    pChildAt = pEntry->children;
    while (pChildAt != NULL) {

        KCCSimUpdateWholeDirectoryRecurse (pChildAt);
        pChildAt = pChildAt->next;

    }
}

VOID
KCCSimUpdateWholeDirectory (
    VOID
    )
/*++

Routine Description:

    Refreshes the directory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // Free the server state table; it may no longer be valid.
    KCCSimFreeStates ();
    KCCSimUpdateWholeDirectoryRecurse (g_pSimDir->pRootEntry);
}

VOID
KCCSimFreeDirectory (
    VOID
    )
/*++

Routine Description:

    Frees the entire directory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (g_pSimDir == NULL) {
        return;
    }

    KCCSimFreeEntryTree (&g_pSimDir->pRootEntry);
    // That should also free the GUID and Dsname tables
    Assert (RtlIsGenericTableEmpty (&g_pSimDir->tableGuid));
    Assert (RtlIsGenericTableEmpty (&g_pSimDir->tableDsname));
    KCCSimFreeAnchor ();

    KCCSimFree (g_pSimDir);
    g_pSimDir = NULL;
}

VOID
KCCSimInitializeDir (
    VOID
    )
/*++

Routine Description:

    Initializes the simulated directory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KCCSimFreeDirectory ();

    Assert (g_pSimDir == NULL);

    g_pSimDir = KCCSIM_NEW (SIM_DIRECTORY);

    g_pSimDir->pRootEntry = NULL;
    g_pSimDir->anchor.pdnDmd = NULL;
    g_pSimDir->anchor.pdnDsa = NULL;
    g_pSimDir->anchor.pdnDomain = NULL;
    g_pSimDir->anchor.pdnConfig = NULL;
    g_pSimDir->anchor.pdnRootDomain = NULL;
    g_pSimDir->anchor.pdnLdapDmd = NULL;
    g_pSimDir->anchor.pdnPartitions = NULL;
    g_pSimDir->anchor.pdnDsSvcConfig = NULL;
    g_pSimDir->anchor.pdnSite = NULL;
    g_pSimDir->anchor.pwszDomainName = NULL;
    g_pSimDir->anchor.pwszDomainDNSName = NULL;
    g_pSimDir->anchor.pwszRootDomainDNSName = NULL;
    RtlInitializeGenericTable (
        &g_pSimDir->tableGuid,
        KCCSimGuidTableCompare,
        KCCSimTableAlloc,
        KCCSimTableFree,
        NULL
        );
    RtlInitializeGenericTable (
        &g_pSimDir->tableDsname,
        KCCSimDsnameTableCompare,
        KCCSimTableAlloc,
        KCCSimTableFree,
        NULL
        );

}

VOID
KCCSimAllocGetAllServers (
    OUT ULONG *                     pulNumServers,
    OUT PSIM_ENTRY **               papEntryNTDSSettings
    )
/*++

Routine Description:

    Allocates an array containing the directory entries of
    all NTDS DSA objects in the enterprise.  The user is
    expected to call KCCSimFree (*papEntryNTDSSettings).

Arguments:

    pulNumServers       - The number of servers in the enterprise.
    papdnServers        - Pointer to an array containing the entry
                          of each server in the enterprise.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntryConfig, pEntrySitesContainer,
                                    pEntrySite, pEntryServersContainer,
                                    pEntryServer, pEntryNTDSSettings;

    ULONG                           ulNumServers, ul;
    PSIM_ENTRY *                    apEntryNTDSSettings;

    Assert (pulNumServers != NULL);
    Assert (papEntryNTDSSettings != NULL);

    if (g_pSimDir->anchor.pdnConfig != NULL) {
        pEntryConfig = KCCSimDsnameToEntry (g_pSimDir->anchor.pdnConfig, KCCSIM_NO_OPTIONS);
    } else {
        pEntryConfig = KCCSimFindFirstChild (
            g_pSimDir->pRootEntry, CLASS_CONFIGURATION, NULL);
    }
    Assert (pEntryConfig != NULL);
    pEntrySitesContainer = KCCSimFindFirstChild (
        pEntryConfig, CLASS_SITES_CONTAINER, NULL);
    if (pEntrySitesContainer == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_SITES_CONTAINER_MISSING
            );
    }

    // Count the number of servers.
    ulNumServers = 0;
    for (pEntrySite = KCCSimFindFirstChild (
            pEntrySitesContainer, CLASS_SITE, NULL);
         pEntrySite != NULL;
         pEntrySite = KCCSimFindNextChild (
            pEntrySite, CLASS_SITE, NULL)) {

        pEntryServersContainer = KCCSimFindFirstChild (
            pEntrySite, CLASS_SERVERS_CONTAINER, NULL);
        Assert (pEntryServersContainer != NULL);
        for (pEntryServer = KCCSimFindFirstChild (
                pEntryServersContainer, CLASS_SERVER, NULL);
             pEntryServer != NULL;
             pEntryServer = KCCSimFindNextChild (
                pEntryServer, CLASS_SERVER, NULL)) {
            ulNumServers++;
        }

    }

    apEntryNTDSSettings = KCCSIM_NEW_ARRAY (PSIM_ENTRY, ulNumServers);

    // Fill in the entries.
    ul = 0;
    for (pEntrySite = KCCSimFindFirstChild (
            pEntrySitesContainer, CLASS_SITE, NULL);
         pEntrySite != NULL;
         pEntrySite = KCCSimFindNextChild (
            pEntrySite, CLASS_SITE, NULL)) {

        pEntryServersContainer = KCCSimFindFirstChild (
            pEntrySite, CLASS_SERVERS_CONTAINER, NULL);
        Assert (pEntryServersContainer != NULL);
        for (pEntryServer = KCCSimFindFirstChild (
                pEntryServersContainer, CLASS_SERVER, NULL);
             pEntryServer != NULL;
             pEntryServer = KCCSimFindNextChild (
                pEntryServer, CLASS_SERVER, NULL)) {
            
            Assert (ul < ulNumServers);
            pEntryNTDSSettings = KCCSimFindFirstChild (
                pEntryServer, CLASS_NTDS_DSA, NULL);
            if( NULL==pEntryNTDSSettings ) {
                KCCSimPrintMessage (
                    KCCSIM_ERROR_SERVER_BUT_NO_SETTINGS,
                    pEntryServer->pdn->StringName
                );                
            } else {
                apEntryNTDSSettings[ul] = pEntryNTDSSettings;
                ul++;
            }
        }

    }
    Assert (ul <= ulNumServers);

    *pulNumServers = ul;
    *papEntryNTDSSettings = apEntryNTDSSettings;
}

PSIM_ENTRY
KCCSimMatchChildForCompare (
    IN  PSIM_ENTRY                  pEntryParent,
    IN  PSIM_ENTRY                  pEntryMatch
    )
/*++

Routine Description:

    Searches for a child entry that matches another entry.
    Used for regression testing.

Arguments:

    pEntryParent        - The entry whose children we are to search.
    pEntryMatch         - The entry we are trying to match.

Return Value:

    The child of pEntryParent that matches pEntryMatch, if one exists;
    otherwise NULL.

--*/
{
    PSIM_ENTRY                      pEntryChild;
    SIM_ATTREF                      attRef;
    const DSNAME *                  pdnMatchFromServerAtt;
    BOOL                            bIsMatch;

    pdnMatchFromServerAtt = NULL;
    if (KCCSimIsEntryOfObjectClass (
            pEntryMatch,
            CLASS_NTDS_CONNECTION,
            NULL
            )) {
        // If we're trying to match a connection object, then its
        // RDN will be a stringized GUID.  Since GUIDs can vary
        // unpredictably, we match using the fromserver attribute
        // instead (assuming there is one.)
        KCCSimGetAttribute (pEntryMatch, ATT_FROM_SERVER, &attRef);
        if (attRef.pAttr != NULL &&
            attRef.pAttr->pValFirst != NULL) {
            pdnMatchFromServerAtt =
                (const DSNAME *) attRef.pAttr->pValFirst->pVal;
        }
    }

    for (pEntryChild = pEntryParent->children;
         pEntryChild != NULL;
         pEntryChild = pEntryChild->next) {

        bIsMatch = FALSE;

        if (pdnMatchFromServerAtt == NULL) {
            // We haven't set a fromserver attribute, so we want to
            // match by DN.
            bIsMatch = NameMatchedStringNameOnly (pEntryChild->pdn, pEntryMatch->pdn);
        } else {

            // We want to match by fromserver attribute.
            KCCSimGetAttribute (pEntryChild, ATT_FROM_SERVER, &attRef);
            if (attRef.pAttr != NULL &&
                attRef.pAttr->pValFirst != NULL) {
                bIsMatch = NameMatchedStringNameOnly (
                    (const DSNAME *) attRef.pAttr->pValFirst->pVal,
                    pdnMatchFromServerAtt
                    );
            }

        }

        if (bIsMatch) {
            break;
        }

    }

    return pEntryChild;
}

BOOL
KCCSimCompareEntries (
    IN  PSIM_ENTRY                  pEntryReal,
    IN  PSIM_ENTRY                  pEntryStored
    )
/*++

Routine Description:

    Compares two entries for regression testing.

Arguments:

    pEntryReal          - The entry from the real (in-memory) directory.
    pEntryStored        - The entry loaded from the LDIF file.

Return Value:

    TRUE if the entries are identical; false otherwise.

--*/
{
    BOOL                            bIdentical;
    PSIM_ENTRY                      pChild, pEntryChildReal;
    PSIM_ATTRIBUTE                  pAttrAt;
    SIM_ATTREF                      attRefStored, attRefReal;
    PSIM_VALUE                      pValAt;
    ULONG                           ulSyntax;

    ULONG                           ulNumVals;
    WCHAR                           wszLtowBuf[1+KCCSIM_MAX_LTOA_CHARS];

    bIdentical = TRUE;

    // Check for extraneous attributes.
    for (pAttrAt = pEntryReal->pAttrFirst;
         pAttrAt != NULL;
         pAttrAt = pAttrAt->next) {
        if (!KCCSimGetAttribute (pEntryStored, pAttrAt->attrType, NULL)) {
            KCCSimPrintMessage (
                KCCSIM_MSG_DIRCOMPARE_EXTRANEOUS_ATTRIBUTE,
                pEntryReal->pdn->StringName,
                KCCSimAttrTypeToString (pAttrAt->attrType)
                );
            
            // For regression test purposes, we need to consider some extraneous
            // attributes as being harmless. These attributes are:
            // msDS-Behavior-Version, replPropertyMetaData, mS-DS-ReplicatesNCReason
            // 
            if( pAttrAt->attrType != ATT_MS_DS_BEHAVIOR_VERSION         &&
                pAttrAt->attrType != ATT_MS_DS_REPLICATES_NC_REASON     &&
                pAttrAt->attrType != ATT_REPL_PROPERTY_META_DATA
                )
            {
                bIdentical = FALSE;
            }
        }
    }

    attRefStored.pEntry = pEntryStored;

    // Verify the attributes.
    for (pAttrAt = pEntryStored->pAttrFirst;
         pAttrAt != NULL;
         pAttrAt = pAttrAt->next) {

        attRefStored.pAttr = pAttrAt;
        if (!KCCSimGetAttribute (pEntryReal, pAttrAt->attrType, &attRefReal)) {
            KCCSimPrintMessage (
                KCCSIM_MSG_DIRCOMPARE_MISSING_ATTRIBUTE,
                pEntryReal->pdn->StringName,
                KCCSimAttrTypeToString (pAttrAt->attrType)
                );
            bIdentical = FALSE;
        } else {

            ulSyntax = KCCSimAttrSyntaxType (pAttrAt->attrType);

            // Note that we compare values of only those attributes with
            // specific syntaxes.
            // We don't compare attribute values of connection objects at all.
            if (!KCCSimIsEntryOfObjectClass (pEntryStored, CLASS_NTDS_CONNECTION, NULL) &&
                pAttrAt->attrType != ATT_OBJECT_GUID             &&
                pAttrAt->attrType != ATT_INVOCATION_ID           &&
                pAttrAt->attrType != ATT_SMTP_MAIL_ADDRESS       &&
                pAttrAt->attrType != ATT_REPL_PROPERTY_META_DATA &&
                (ulSyntax == SYNTAX_OBJECT_ID_TYPE     ||
                 ulSyntax == SYNTAX_NOCASE_STRING_TYPE ||
                 ulSyntax == SYNTAX_OCTET_STRING_TYPE  ||
                 ulSyntax == SYNTAX_UNICODE_TYPE)) {

                // Check for extraneous attribute values.
                ulNumVals = 0;
                // In the real database, the object class contains all super-classes.
                // In the stored file, only the most specific class is present.
                // Skip checking this direction since real db is a super-set
                if (pAttrAt->attrType != ATT_OBJECT_CLASS) {
                    for (pValAt = attRefReal.pAttr->pValFirst;
                         pValAt != NULL;
                         pValAt = pValAt->next) {
                        if (!KCCSimIsValueInAttribute (
                            &attRefStored,
                            pValAt->ulLen,
                            pValAt->pVal
                            )) {
                            ulNumVals++;
                        }
                    }
                }
                if (ulNumVals != 0) {
                    KCCSimPrintMessage (
                        KCCSIM_MSG_DIRCOMPARE_EXTRANEOUS_VALUES,
                        pEntryReal->pdn->StringName,
                        KCCSimAttrTypeToString (pAttrAt->attrType),
                        _ultow (ulNumVals, wszLtowBuf, 10)
                        );
                }

                // Verify the attribute values.
                ulNumVals = 0;
                for (pValAt = pAttrAt->pValFirst;
                     pValAt != NULL;
                     pValAt = pValAt->next) {
                    if (!KCCSimIsValueInAttribute (
                            &attRefReal,
                            pValAt->ulLen,
                            pValAt->pVal
                            )) {
                        ulNumVals++;
                    }
                }
                if (ulNumVals != 0) {
                    KCCSimPrintMessage (
                        KCCSIM_MSG_DIRCOMPARE_MISSING_VALUES,
                        pEntryReal->pdn->StringName,
                        KCCSimAttrTypeToString (pAttrAt->attrType),
                        _ultow (ulNumVals, wszLtowBuf, 10)
                        );
                }

            }

        }

    }

    // Check for extraneous children.
    for (pChild = pEntryReal->children;
         pChild != NULL;
         pChild = pChild->next) {
        if (KCCSimMatchChildForCompare (pEntryStored, pChild) == NULL) {
            KCCSimPrintMessage (
                KCCSIM_MSG_DIRCOMPARE_EXTRANEOUS_DN,
                pChild->pdn->StringName
                );
            bIdentical = FALSE;
        }
    }

    // Recurse.
    for (pChild = pEntryStored->children;
         pChild != NULL;
         pChild = pChild->next) {

        pEntryChildReal = KCCSimMatchChildForCompare (pEntryReal, pChild);
        if (pEntryChildReal == NULL) {
            KCCSimPrintMessage (
                KCCSIM_MSG_DIRCOMPARE_MISSING_DN,
                pChild->pdn->StringName
                );
            bIdentical = FALSE;
        } else {
            bIdentical &= KCCSimCompareEntries (pEntryChildReal, pChild);
        }

    }

    return bIdentical;
}

VOID
KCCSimCompareDirectory (
    IN  LPWSTR                      pwszFn
    )
/*++

Routine Description:

    Compares the in-memory directory with one stored in an LDIF file.

Arguments:

    pwszFn              - The LDIF file to compare against.

Return Value:

    None.

--*/
{
    PSIM_DIRECTORY                  pRealDirectory = NULL;
    BOOL                            bIdentical;

    __try {

        // All of our directory functions are hard-coded to use g_pSimDir.
        // We want to load an LDIF file into a blank directory.  So, we
        // store the real pseudo-directory in a safe place, null out
        // g_pSimDir, load the stored directory into g_pSimDir, and after
        // we finish our comparison, restore things to normal.
        pRealDirectory = g_pSimDir;
        g_pSimDir = NULL;
        KCCSimInitializeDir ();
        KCCSimLoadLdif (pwszFn);

        if (pRealDirectory == NULL ||
            pRealDirectory->pRootEntry == NULL ||
            !NameMatchedStringNameOnly (
                pRealDirectory->pRootEntry->pdn,
                g_pSimDir->pRootEntry->pdn
                )) {
            bIdentical = FALSE;
            KCCSimPrintMessage (KCCSIM_ERROR_CANT_COMPARE_DIFFERENT_ROOTS);
        } else {
            bIdentical = KCCSimCompareEntries (pRealDirectory->pRootEntry, g_pSimDir->pRootEntry);
        }

        if (bIdentical) {
            KCCSimPrintMessage (KCCSIM_MSG_DIRCOMPARE_IDENTICAL);
        }

    } __finally {

        // Restore things to normal!
        KCCSimFreeDirectory ();
        g_pSimDir = pRealDirectory;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\buildmak.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    buildmak.c

ABSTRACT:

    Accessory to buildcfg.c that performs the actual
    construction of the simulated directory.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <attids.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "simtime.h"
#include "buildcfg.h"
#include "objids.h"
#include "schedule.h"


BUILDCFG_TRANSPORT_INFO             transportInfo[BUILDCFG_NUM_TRANSPORTS] = {
    { L"IP",    ATT_DNS_HOST_NAME,      L"ismip.dll",  NULL },
    { L"SMTP",  ATT_SMTP_MAIL_ADDRESS,  L"",           NULL }
};

VOID
BuildCfgGetNextUuid (
    OUT UUID *                      puuid
    )
/*++

Routine Description:

    Gets the next UUID stored in the table.  UUIDs obtained through this
    function will always be returned in ascending order.

Arguments:

    puuid               - Pointer to a UUID structure that will hold the
                          result.

Return Value:

    None.

--*/
{
    PVOID                           p;

    p = RtlEnumerateGenericTable (&globals.tableUuids, FALSE);
    if (p == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_NOT_ENOUGH_UUIDS
            );
    }
    memcpy (puuid, p, sizeof (UUID));
}

const BUILDCFG_TRANSPORT_INFO *
BuildCfgGetTransportInfo (
    IN  LPCWSTR                     pwszTransportRDN
    )
/*++

Routine Description:

    Gets the information associated with a particular transport.

Arguments:

    pwszTransportRDN    - The RDN of this inter-site transport.

Return Value:

    The transport info structure, or NULL if the supplied RDN is not valid.

--*/
{
    const BUILDCFG_TRANSPORT_INFO * pTransport;

    ULONG                           ul;

    pTransport = NULL;
    for (ul = 0; ul < ARRAY_SIZE (transportInfo); ul++) {
        if (_wcsicmp (pwszTransportRDN, transportInfo[ul].wszRDN) == 0) {
            pTransport = &transportInfo[ul];
            break;
        }
    }

    return pTransport;
}

BOOL
BuildCfgUseExplicitBridgeheads (
    IN  LPCWSTR                     pwszTransportRDN
    )
/*++

Routine Description:

    Flags a particular transport as using explicit bridgeheads.

Arguments:

    pwszTransportRDN    - The RDN of the transport that will use explicit
                          bridgeheads.

Return Value:

    TRUE if the transport was successfully flagged.
    FALSE if the supplied RDN is not valid.

--*/
{
    const BUILDCFG_TRANSPORT_INFO * pTransport;

    pTransport = BuildCfgGetTransportInfo (pwszTransportRDN);

    if (pTransport == NULL) {
        return FALSE;
    }

    if (!KCCSimGetAttribute (
            pTransport->pEntry,
            ATT_BRIDGEHEAD_SERVER_LIST_BL,
            NULL
            )) {
        KCCSimNewAttribute (
            pTransport->pEntry,
            ATT_BRIDGEHEAD_SERVER_LIST_BL,
            NULL
            );
    }

    return TRUE;
}

PSIM_ENTRY
BuildCfgSetupNewEntry (
    IN  const DSNAME *              pdnParent,
    IN  LPCWSTR                     pwszRDN OPTIONAL,
    IN  ATTRTYP                     objClass
    )
/*++

Routine Description:

    Establishes a new directory entry.

Arguments:

    pdnParent           - The dn of this entry's parent.
    pwszRDN             - The RDN of this entry.  If omitted, pdnParent
                          is interpreted as the DN of this entry.
    objClass            - The most specific object class of this entry.

Return Value:

    The newly created entry in the directory.

--*/
{
    PDSNAME                         pdn = NULL;
    PSIM_ENTRY                      pEntry;
    SIM_ATTREF                      attRef;

    WCHAR                           wszRDN[1+MAX_RDN_SIZE];
    DSTIME                          dsTime;
    ATTRTYP                         objClassAt;

    Assert (globals.pdnDmd != NULL);

    Assert (pdnParent != NULL);

    if (pwszRDN == NULL) {
        pEntry = KCCSimDsnameToEntry (pdnParent, KCCSIM_WRITE);
    } else {
        pdn = KCCSimAllocAppendRDN (
            pdnParent,
            pwszRDN,
            ATT_COMMON_NAME
            );
        pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_WRITE);
        KCCSimFree (pdn);
        pdn = NULL;
    }

    // objectGUID:
    BuildCfgGetNextUuid (&pEntry->pdn->Guid);
    KCCSimNewAttribute (pEntry, ATT_OBJECT_GUID, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (GUID),
        (PBYTE) &pEntry->pdn->Guid
        );

    // distinguishedName:
    KCCSimNewAttribute (pEntry, ATT_OBJ_DIST_NAME, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        pEntry->pdn->structLen,
        (PBYTE) pEntry->pdn
        );

    KCCSimQuickRDNOf (pEntry->pdn, wszRDN);

    // cn:
    KCCSimNewAttribute (pEntry, ATT_COMMON_NAME, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        KCCSIM_WCSMEMSIZE (wszRDN),
        (PBYTE) wszRDN
        );

    // name:
    KCCSimNewAttribute (pEntry, ATT_RDN, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        KCCSIM_WCSMEMSIZE (wszRDN),
        (PBYTE) wszRDN
        );

    dsTime = KCCSimGetRealTime ();

    // whenCreated:
    KCCSimNewAttribute (pEntry, ATT_WHEN_CREATED, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (DSTIME),
        (PBYTE) &dsTime
        );

    // whenChanged:
    KCCSimNewAttribute (pEntry, ATT_WHEN_CHANGED, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (DSTIME),
        (PBYTE) &dsTime
        );

    // objClass:
    KCCSimNewAttribute (pEntry, ATT_OBJECT_CLASS, &attRef);
    for (objClassAt = objClass;
         ;
         objClassAt = KCCSimAttrSuperClass (objClassAt)) {

        KCCSimAllocAddValueToAttribute (
            &attRef,
            sizeof (ATTRTYP),
            (PBYTE) &objClassAt
            );
        if (KCCSimAttrSuperClass (objClassAt) == objClassAt) {
            break;
        }

    }

    // objCategory:
    KCCSimNewAttribute (pEntry, ATT_OBJECT_CATEGORY, &attRef);
    pdn = KCCSimAllocAppendRDN (
        globals.pdnDmd,
        KCCSimAttrSchemaRDN (objClass),
        ATT_COMMON_NAME
        );
    KCCSimAddValueToAttribute (
        &attRef,
        pdn->structLen,
        (PBYTE) pdn
        );

    // instanceType: 
    if( objClass==CLASS_DOMAIN_DNS
        || objClass==CLASS_CONFIGURATION
        || objClass==CLASS_DMD ) {
        DWORD  instType;

        switch(objClass) {
            case CLASS_DOMAIN_DNS:
                instType=NC_MASTER;
                break;
            case CLASS_CONFIGURATION:
            case CLASS_DMD:
                instType=NC_MASTER_SUBREF;
                break;
        }

        // BUGBUG: Should also handle child domains, and
        // config in child domains here

        KCCSimNewAttribute (pEntry, ATT_INSTANCE_TYPE, &attRef);
        KCCSimAllocAddValueToAttribute (
            &attRef, sizeof(DWORD), (PBYTE) &instType );
    }

    return pEntry;
}

PSIM_ENTRY
BuildCfgGetCrossRef (
    IN  LPCWSTR                     pwszCrossRefRDN
    )
/*++

Routine Description:

    Gets a cross-ref from the directory.

Arguments:

    pwszCrossRefRDN     - The RDN of the cross-ref.

Return Value:

    The entry of the cross-ref in the directory, or NULL if it does not exist.

--*/
{
    PSIM_ENTRY                      pEntryCrossRef;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];

    Assert (globals.pEntryCrossRefContainer != NULL);
    Assert (pwszCrossRefRDN != NULL);

    for (pEntryCrossRef = KCCSimFindFirstChild (
            globals.pEntryCrossRefContainer, CLASS_CROSS_REF, NULL);
         pEntryCrossRef != NULL;
         pEntryCrossRef = KCCSimFindNextChild (
            pEntryCrossRef, CLASS_CROSS_REF, NULL)) {

        KCCSimQuickRDNOf (pEntryCrossRef->pdn, wszRDN);
        if (wcscmp (pwszCrossRefRDN, wszRDN) == 0) {
            break;
        }

    }

    return pEntryCrossRef;
}

PSIM_ENTRY
BuildCfgGetSite (
    IN  LPCWSTR                     pwszSiteRDN
    )
/*++

Routine Description:

    Locates a site by RDN.

Arguments:

    pwszSiteRDN         - The RDN of the site.

Return Value:

    The entry of the site in the directory, or NULL if it does not exist.

--*/
{
    PSIM_ENTRY                      pEntrySiteAt;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];
    
    Assert (globals.pEntrySitesContainer != NULL);
    Assert (pwszSiteRDN != NULL);

    for (pEntrySiteAt = KCCSimFindFirstChild (
            globals.pEntrySitesContainer, CLASS_SITE, NULL);
         pEntrySiteAt != NULL;
         pEntrySiteAt = KCCSimFindNextChild (
            pEntrySiteAt, CLASS_SITE, NULL)) {

        KCCSimQuickRDNOf (pEntrySiteAt->pdn, wszRDN);
        if (wcscmp (pwszSiteRDN, wszRDN) == 0) {
            break;
        }

    }

    return pEntrySiteAt;
}

PSIM_ENTRY
BuildCfgGetSiteLink (
    IN  PSIM_ENTRY                  pEntryTransportContainer,
    IN  LPCWSTR                     pwszSiteLinkRDN
    )
/*++

Routine Description:

    Locates a site-link by RDN.

Arguments:

    pEntryTransportContainer - container to search
    pwszSiteLinkRDN         - The RDN of the site.

Return Value:

    The entry of the site-link in the directory, or NULL if it does not exist.

--*/
{
    PSIM_ENTRY                      pEntrySiteAt;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];
    
    Assert (globals.pEntrySitesContainer != NULL);
    Assert (pwszSiteLinkRDN != NULL);

    for (pEntrySiteAt = KCCSimFindFirstChild (
        pEntryTransportContainer, CLASS_SITE_LINK, NULL);
         pEntrySiteAt != NULL;
         pEntrySiteAt = KCCSimFindNextChild (
             pEntrySiteAt, CLASS_SITE_LINK, NULL))
    {

        KCCSimQuickRDNOf (pEntrySiteAt->pdn, wszRDN);
        if (wcscmp (pwszSiteLinkRDN, wszRDN) == 0) {
            break;
        }

    }

    return pEntrySiteAt;
}

PSIM_ENTRY
BuildCfgGetServer (
    IN  PSIM_ENTRY                  pEntryServersContainer,
    IN  LPCWSTR                     pwszServerRDN
    )
/*++

Routine Description:

    Locates a server by RDN.

Arguments:

    pEntryServersContainer - The entry of the servers container to search.
    pwszServerRDN       - The RDN of the server.

Return Value:

    The entry of the server in the directory, or NULL if it does not exist
    in this servers container.

--*/
{
    PSIM_ENTRY                      pEntryServerAt;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];

    for (pEntryServerAt = KCCSimFindFirstChild (
            pEntryServersContainer, CLASS_SERVER, NULL);
         pEntryServerAt != NULL;
         pEntryServerAt = KCCSimFindNextChild (
            pEntryServerAt, CLASS_SERVER, NULL)) {

        KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDN);
        if (wcscmp (pwszServerRDN, wszRDN) == 0) {
            break;
        }

    }

    return pEntryServerAt;
}

PSIM_ENTRY
BuildCfgGetNTDSSettings (
    IN  PSIM_ENTRY                  pEntryServersContainer,
    IN  LPCWSTR                     pwszServerRDN
    )
/*++

Routine Description:

    Locates a NTDS-Settings object by server RDN.

Arguments:

    pEntryServersContainer - The entry of the servers container to search.
    pwszServerRDN       - The RDN of the server.

Return Value:

    The entry of the NTDS Settings of the server in the directory,
    or NULL if it does not exist in this servers container.

--*/
{
    PSIM_ENTRY                      pEntryServerAt;
    PSIM_ENTRY                      pEntryNTDSSettings;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];
    PDSNAME                         pdn = NULL;
    BOOL                            fFound = FALSE;

    for (pEntryServerAt = KCCSimFindFirstChild (
            pEntryServersContainer, CLASS_SERVER, NULL);
         pEntryServerAt != NULL;
         pEntryServerAt = KCCSimFindNextChild (
            pEntryServerAt, CLASS_SERVER, NULL)) {

        KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDN);
        if (wcscmp (pwszServerRDN, wszRDN) == 0) {
            fFound = TRUE;
            break;
        }
    }

    if (!fFound) {
        // Server RDN not found!
        return NULL;
    }

    pdn = KCCSimAllocAppendRDN (
        pEntryServerAt->pdn,
        BUILDCFG_RDN_NTDS_SETTINGS,
        ATT_COMMON_NAME
        );
    pEntryNTDSSettings = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
    Assert( pEntryNTDSSettings );

    KCCSimFree (pdn);

    return pEntryNTDSSettings;
}

PSIM_ENTRY
BuildCfgMakeCrossRef (
    IN  PSIM_ENTRY                  pEntryNc,
    IN  LPCWSTR                     pwszRDN OPTIONAL,
    IN  BOOL                        bIsDomain
    )
/*++

Routine Description:

    Creates a cross-ref entry.

Arguments:

    pEntryNc            - The entry in the directory corresponding to NC
                          to which this cross-ref refers.
    pwszRDN             - The RDN of this cross-ref object.  Defaults to the
                          RDN of pEntryNc.
    bIsDomain           - TRUE if this cross-ref represents a domain; FALSE
                          if it represents a non-domain NC (e.g. the schema.)

Return Value:

    The newly created cross-ref.

--*/
{
    PSIM_ENTRY                      pEntryCrossRef;
    SIM_ATTREF                      attRef;
    WCHAR                           wszNcRDN[1+MAX_RDN_SIZE];
    ULONG                           ul;
    LPWSTR                          pwzDnsRoot;
    PDS_NAME_RESULTW                pResult = NULL;

    Assert (globals.pEntryCrossRefContainer != NULL);
    Assert (pEntryNc != NULL);

    __try {
        KCCSimQuickRDNOf (pEntryNc->pdn, wszNcRDN);
        if (pwszRDN == NULL) {
            pwszRDN = wszNcRDN;
        }

        pEntryCrossRef = BuildCfgGetCrossRef (pwszRDN);
        if (pEntryCrossRef != NULL) {
            // Already exists, return it
            __leave;
        }

        pEntryCrossRef = BuildCfgSetupNewEntry (
            globals.pEntryCrossRefContainer->pdn,
            pwszRDN,
            CLASS_CROSS_REF
            );

        // netBIOSName:
        if (bIsDomain) {
            KCCSimNewAttribute (pEntryCrossRef, ATT_NETBIOS_NAME, &attRef);
            KCCSimAllocAddValueToAttribute (
                &attRef,
                KCCSIM_WCSMEMSIZE (wszNcRDN),
                (PBYTE) wszNcRDN
                );
        }

        // dNSRoot:
        // For domain nc's, construct the dns root syntactically based on the dn
        KCCSimNewAttribute (pEntryCrossRef, ATT_DNS_ROOT, &attRef);
        if (bIsDomain) {
            DWORD status;
            LPWSTR pwzDn = pEntryNc->pdn->StringName;
            status = DsCrackNamesW( NULL,
                                    DS_NAME_FLAG_SYNTACTICAL_ONLY,
                                    DS_FQDN_1779_NAME,
                                    DS_CANONICAL_NAME_EX,
                                    1,
                                    &pwzDn,
                                    &pResult);
            if ( (status != ERROR_SUCCESS) ||
                 (pResult == NULL) ||
                 (pResult->cItems == 0) ||
                 (pResult->rItems[0].pDomain == NULL) ) {
                KCCSimException (
                    KCCSIM_ETYPE_INTERNAL,
                    BUILDCFG_ERROR_INVALID_DOMAIN_DN,
                    pEntryNc->pdn->StringName
                    );
            }
            pwzDnsRoot = pResult->rItems[0].pDomain;
        } else {
            pwzDnsRoot = globals.pwszRootDomainDNSName;
        }
        KCCSimAllocAddValueToAttribute (
            &attRef,
            KCCSIM_WCSMEMSIZE(pwzDnsRoot),
            (PBYTE) pwzDnsRoot
            );

        // systemFlags:
        KCCSimNewAttribute (pEntryCrossRef, ATT_SYSTEM_FLAGS, &attRef);
        ul = FLAG_CR_NTDS_NC;
        if (bIsDomain) {
            ul |= FLAG_CR_NTDS_DOMAIN;
        }
        KCCSimAllocAddValueToAttribute (
            &attRef,
            sizeof (ULONG),
            (PBYTE) &ul
            );

        // nCName:
        KCCSimNewAttribute (pEntryCrossRef, ATT_NC_NAME, &attRef);
        KCCSimAllocAddValueToAttribute (
            &attRef,
            pEntryNc->pdn->structLen,
            (PBYTE) pEntryNc->pdn
            );

    } __finally {
        if (pResult != NULL) {
            DsFreeNameResultW(pResult);
        }
    }

    return pEntryCrossRef;
}

PSIM_ENTRY
BuildCfgMakeDomain (
    IN  LPCWSTR                     pwszDomain
    )
/*++

Routine Description:

    Creates a domain.

Arguments:

    pwszDomain          - The DN of the domain.

Return Value:

    The newly created entry.

--*/
{
    PDSNAME                         pdnDomain = NULL;
    PDSNAME                         pdnParent = NULL;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];
    PSIM_ENTRY                      pEntryDomain = NULL;

    __try {

        pdnDomain = KCCSimAllocDsname (pwszDomain);
        pdnParent = KCCSimAlloc (pdnDomain->structLen);

        if (TrimDSNameBy (pdnDomain, 1, pdnParent) != 0) {
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                BUILDCFG_ERROR_INVALID_DOMAIN_DN,
                pdnDomain->StringName
                );
        }

        if (KCCSimDsnameToEntry (pdnParent, KCCSIM_NO_OPTIONS) == NULL) {
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                BUILDCFG_ERROR_INVALID_DOMAIN_DN,
                pdnDomain->StringName
                );
        }

        pEntryDomain = BuildCfgSetupNewEntry (
            pdnDomain,
            NULL,
            CLASS_DOMAIN_DNS
            );

    } __finally {

        KCCSimFree (pdnDomain);
        KCCSimFree (pdnParent);

    }

    return pEntryDomain;
}

PSIM_ENTRY
BuildCfgMakeSite (
    IN  LPCWSTR                     pwszSiteRDN,
    IN  ULONG                       ulSiteOptions
    )
/*++

Routine Description:

    Creates a site.

Arguments:

    pwszSiteRDN         - The RDN of the site.
    ulSiteOptions       - Site options.

Return Value:

    The newly created site entry.

--*/
{
    PSIM_ENTRY                      pEntrySite, pEntryNTDSSiteSettings,
                                    pEntryServersContainer;
    SIM_ATTREF                      attRef;

    ULONG                           ulSiteAt, ulServerAt;

    pEntrySite = BuildCfgSetupNewEntry (
        globals.pEntrySitesContainer->pdn,
        pwszSiteRDN,
        CLASS_SITE
        );

    pEntryNTDSSiteSettings = BuildCfgSetupNewEntry (
        pEntrySite->pdn,
        BUILDCFG_RDN_NTDS_SITE_SETTINGS,
        CLASS_NTDS_SITE_SETTINGS
        );

    // options:
    KCCSimNewAttribute (pEntryNTDSSiteSettings, ATT_OPTIONS, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (ULONG),
        (PBYTE) &ulSiteOptions
        );

    pEntryServersContainer = BuildCfgSetupNewEntry (
        pEntrySite->pdn,
        BUILDCFG_RDN_SERVERS_CONTAINER,
        CLASS_SERVERS_CONTAINER
        );

    return pEntrySite;
}

PSIM_ENTRY
BuildCfgMakeSiteLink (
    IN  LPCWSTR                     pwszTransport,
    IN  LPCWSTR                     pwszSiteLinkRDN,
    IN  ULONG                       ulCost,
    IN  ULONG                       ulReplInterval,
    IN  ULONG                       ulOptions,
    IN  PSCHEDULE                   pSchedule
    )
/*++

Routine Description:

    Creates a site-link.

Arguments:

    pwszTransport       - Transport type of this site-link.
    pwszSiteLinkRDN     - RDN of this site-link.
    ulCost              - cost attribute.
    ulReplInterval      - replInterval attribute.
    ulOptions           - options attribute.

Return Value:

    The newly created site-link entry.

--*/
{
    const BUILDCFG_TRANSPORT_INFO * pTransport;
    PSIM_ENTRY                      pEntrySiteLink;
    SIM_ATTREF                      attRef;

    // Validate this transport type.
    pTransport = BuildCfgGetTransportInfo (pwszTransport);
    if (pTransport == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_UNKNOWN_TRANSPORT,
            pwszSiteLinkRDN,
            pwszTransport
            );
    }

    pEntrySiteLink = BuildCfgSetupNewEntry (
        pTransport->pEntry->pdn,
        pwszSiteLinkRDN,
        CLASS_SITE_LINK
        );

    // cost:
    KCCSimNewAttribute (pEntrySiteLink, ATT_COST, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (ULONG),
        (PBYTE) &ulCost
        );

    // replInterval:
    KCCSimNewAttribute (pEntrySiteLink, ATT_REPL_INTERVAL, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (ULONG),
        (PBYTE) &ulReplInterval
        );

    // options:
    KCCSimNewAttribute (pEntrySiteLink, ATT_OPTIONS, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (ULONG),
        (PBYTE) &ulOptions
        );
    // schedule:
    if( pSchedule ) {
        KCCSimNewAttribute (pEntrySiteLink, ATT_SCHEDULE, &attRef);
        KCCSimAllocAddValueToAttribute (
            &attRef,
            sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES,
            (PBYTE) pSchedule
            );
    }

    return pEntrySiteLink;
}    

VOID
BuildCfgAddSiteToSiteLink (
    IN  LPCWSTR                     pwszSiteLinkRDN,
    IN  PSIM_ENTRY                  pEntrySiteLink,
    IN  LPCWSTR                     pwszSiteRDN
    )
/*++

Routine Description:

    Places a site in a site-link.

Arguments:

    pwszSiteLinkRDN     - The RDN of the site-link.  Used for error reporting.
    pEntrySiteLink      - The site-link entry.
    pwszSiteRDN         - The RDN of the site to add.

Return Value:

    

--*/
{
    PSIM_ENTRY                      pEntrySite;
    SIM_ATTREF                      attRef;

    pEntrySite = BuildCfgGetSite (pwszSiteRDN);

    if (pEntrySite == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_INVALID_SITE,
            pwszSiteLinkRDN,
            pwszSiteRDN
            );
    }

    if (!KCCSimGetAttribute (pEntrySiteLink, ATT_SITE_LIST, &attRef)) {
        KCCSimNewAttribute (pEntrySiteLink, ATT_SITE_LIST, &attRef);
    }
    KCCSimAllocAddValueToAttribute (
        &attRef,
        pEntrySite->pdn->structLen,
        (PBYTE) pEntrySite->pdn
        );
}

PSIM_ENTRY
BuildCfgMakeBridge (
    IN  LPCWSTR                     pwszTransport,
    IN  LPCWSTR                     pwszBridgeRDN,
    OUT PSIM_ENTRY *                ppEntryTransport
    )
/*++

Routine Description:

    Creates a site-link.

Arguments:

    pwszTransport       - Transport type of this site-link.
    pwszBridgeRDN       - RDN of this bridge.
    ppEntryTransport    - Entry corresponding to the named transport

Return Value:

    The newly created bridge entry.

--*/
{
    const BUILDCFG_TRANSPORT_INFO * pTransport;
    PSIM_ENTRY                      pEntryBridge;
    SIM_ATTREF                      attRef;

    // Validate this transport type.
    pTransport = BuildCfgGetTransportInfo (pwszTransport);
    if (pTransport == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_UNKNOWN_TRANSPORT,
            pwszBridgeRDN,
            pwszTransport
            );
    }

    pEntryBridge = BuildCfgSetupNewEntry (
        pTransport->pEntry->pdn,
        pwszBridgeRDN,
        CLASS_SITE_LINK_BRIDGE
        );

    // Return transport entry
    *ppEntryTransport = pTransport->pEntry;

    return pEntryBridge;
}    

VOID
BuildCfgAddSiteLinkToBridge (
    IN  LPCWSTR                     pwszBridgeRDN,
    IN  PSIM_ENTRY                  pEntryTransportContainer,
    IN  PSIM_ENTRY                  pEntryBridge,
    IN  LPCWSTR                     pwszSiteLinkRDN
    )
/*++

Routine Description:

    Places a site-link in a bridge.

Arguments:

    pwszBridgeRDN     - The RDN of the bridge.  Used for error reporting.
    pEntryTransportContainer - container to search for site links
    pEntryBridge      - The bridge entry.
    pwszSiteLinkRDN   - The RDN of the site-link to add.

Return Value:

    

--*/
{
    PSIM_ENTRY                      pEntrySiteLink;
    SIM_ATTREF                      attRef;

    pEntrySiteLink = BuildCfgGetSiteLink (pEntryTransportContainer,
                                          pwszSiteLinkRDN);

    if (pEntrySiteLink == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_INVALID_SITE,
            pwszBridgeRDN,
            pwszSiteLinkRDN
            );
    }

    if (!KCCSimGetAttribute (pEntryBridge, ATT_SITE_LINK_LIST, &attRef)) {
        KCCSimNewAttribute (pEntryBridge, ATT_SITE_LINK_LIST, &attRef);
    }
    KCCSimAllocAddValueToAttribute (
        &attRef,
        pEntrySiteLink->pdn->structLen,
        (PBYTE) pEntrySiteLink->pdn
        );
}

BOOL
BuildCfgISTG (
    IN  PSIM_ENTRY                  pEntryNTDSSiteSettings,
    IN  PSIM_ENTRY                  pEntryServersContainer,
    IN  LPCWSTR                     pwszServerRDN
    )
/*++

Routine Description:

    Sets the inter-site topology generator for a site.

Arguments:

    pEntryNTDSSiteSettings - The entry of the NTDS Site Settings object.
    pEntryServersContainer - The entry of the servers container for this site.
    pwszServerRDN       - The RDN of the server that is to be the ISTG.

Return Value:

    TRUE if the ISTG was properly set.
    FALSE if the server does not exist in this site.

--*/
{
    PSIM_ENTRY                      pEntryNTDSSettings;

    SIM_ATTREF                      attRef;

    PROPERTY_META_DATA_VECTOR *     pMetaDataVector;
    PROPERTY_META_DATA *            pMetaData;

    Assert (pEntryNTDSSiteSettings != NULL);
    Assert (pEntryServersContainer != NULL);

    pEntryNTDSSettings = BuildCfgGetNTDSSettings (pEntryServersContainer, pwszServerRDN);
    if (pEntryNTDSSettings == NULL) {
        return FALSE;
    }

    KCCSimGetAttribute (
        pEntryNTDSSiteSettings,
        ATT_INTER_SITE_TOPOLOGY_GENERATOR,
        &attRef
        );

    if (attRef.pAttr == NULL) {

        // interSiteTopologyGenerator
        KCCSimNewAttribute (
            pEntryNTDSSiteSettings,
            ATT_INTER_SITE_TOPOLOGY_GENERATOR,
            &attRef
            );
        KCCSimAllocAddValueToAttribute (
            &attRef,
            pEntryNTDSSettings->pdn->structLen,
            (PBYTE) pEntryNTDSSettings->pdn
            );

        // replPropertyMetaData for ATT_INTER_SITE_TOPOLOGY_GENERATOR
        KCCSimNewAttribute (
            pEntryNTDSSiteSettings,
            ATT_REPL_PROPERTY_META_DATA,
            &attRef
            );
        pMetaDataVector = KCCSimAlloc (MetaDataVecV1SizeFromLen (1));
        pMetaDataVector->dwVersion = VERSION_V1;
        pMetaDataVector->V1.cNumProps = 1;
        pMetaData = &pMetaDataVector->V1.rgMetaData[0];
        pMetaData->attrType = ATT_INTER_SITE_TOPOLOGY_GENERATOR;
        pMetaData->dwVersion = 1;
        pMetaData->timeChanged = KCCSimGetRealTime ();
        memcpy (
            &pMetaData->uuidDsaOriginating,
            &pEntryNTDSSettings->pdn->Guid,
            sizeof (UUID)
            );
        pMetaData->usnOriginating = 1;
        pMetaData->usnProperty = 1;
        KCCSimAddValueToAttribute (
            &attRef,
            MetaDataVecV1SizeFromLen (1),
            (PBYTE) pMetaDataVector
            );

    }

    return TRUE;
}

VOID
BuildCfgAddAsBridgehead (
    IN  LPCWSTR                     pwszServerType,
    IN  PSIM_ENTRY                  pEntryServer,
    IN  LPCWSTR                     pwszTransportRDN
    )
/*++

Routine Description:

    Establishes a server as a bridgehead for a given transport.

Arguments:

    pwszServerType      - The server type of this server.  Used for
                          error reporting.
    pEntryServer        - The entry of this server.
    pwszTransportRDN    - The transport for which this server is a bridgehead.

Return Value:

    None.

--*/
{
    const BUILDCFG_TRANSPORT_INFO * pTransport;
    SIM_ATTREF                      attRef;

    Assert (pwszTransportRDN != NULL);

    pTransport = BuildCfgGetTransportInfo (pwszTransportRDN);
    if (pTransport == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_UNKNOWN_TRANSPORT,
            pwszServerType,
            pwszTransportRDN
            );
    }

    if (!KCCSimGetAttribute (
            pTransport->pEntry,
            ATT_BRIDGEHEAD_SERVER_LIST_BL,
            &attRef
            )) {
        KCCSimPrintMessage (
            BUILDCFG_WARNING_NO_EXPLICIT_BRIDGEHEADS,
            pwszServerType,
            pwszTransportRDN
            );
        return;
    }

    Assert (attRef.pAttr != NULL);

    KCCSimAllocAddValueToAttribute (
        &attRef,
        pEntryServer->pdn->structLen,
        (PBYTE) pEntryServer->pdn
        );
}


PSIM_ENTRY
BuildCfgMakeServer (
    IO  PULONG                      pulServerNum,
    IN  LPCWSTR                     pwszServerRDNMask,
    IN  LPCWSTR                     pwszSiteRDN,
    IN  LPCWSTR                     pwszDomain,
    IN  PSIM_ENTRY                  pEntryServersContainer,
    IN  ULONG                       ulServerOptions
    )
/*++

Routine Description:

    Creates a server.

Arguments:

    pulServerNum        - Pointer to the server number.  If this is nonzero on
                          input, it represents the current server number and is
                          not changed on output.  If it is zero on input, then
                          the current server number is set to the first
                          available server number for this site and server
                          type, and *pulServerNum is changed to the current
                          server number on output.
    pwszServerRDNMask   - The RDN mask of this server.
    pwszSiteRDN         - The RDN of this site.
    pwszDomain          - The DN of the domain to which the server belongs.
    pEntryServersContainer - The servers container of the site to which this
                          server should be added.
    ulServerOptions     - options attribute.

Return Value:

    The newly created server entry.

--*/
{
    PSIM_ENTRY                      pEntryCrossRef;
    PSIM_ENTRY                      pEntryServer, pEntryNTDSSettings;
    SIM_ATTREF                      attRef;
    PDSNAME                         pdnNc, pdnOtherNc;

    WCHAR                           wszServerRDN[1+MAX_RDN_SIZE];
    LPWSTR                          pwsz, pwszStringizedGuid;
    ULONG                           ulBytes, ulDsaVersion;

    Assert (globals.pwszRootDomainDNSName != NULL);
    Assert (globals.pEntryCrossRefContainer != NULL);
    Assert (pwszSiteRDN != NULL);
    Assert (pEntryServersContainer != NULL);

    // Get this domain
    pdnNc = KCCSimAllocDsname (pwszDomain);
    if (KCCSimDsnameToEntry (pdnNc, KCCSIM_NO_OPTIONS) == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_INVALID_DOMAIN,
            pwszSiteRDN,
            pwszDomain
            );
    }

    if (*pulServerNum == 0) {
        // Find the first available server ID
        do {
            (*pulServerNum)++;
            swprintf (
                wszServerRDN,
                L"%s-%s%d",
                pwszSiteRDN,
                pwszServerRDNMask,
                *pulServerNum
                );
            pEntryServer = BuildCfgGetServer (pEntryServersContainer, wszServerRDN);
        } while (pEntryServer != NULL);
    } else {
        swprintf (
            wszServerRDN,
            L"%s-%s%d",
            pwszSiteRDN,
            pwszServerRDNMask,
            *pulServerNum
            );
    }

    pEntryServer = BuildCfgSetupNewEntry (
        pEntryServersContainer->pdn,
        wszServerRDN,
        CLASS_SERVER
        );

    // dNSHostName:
    ulBytes = sizeof (WCHAR) * (
        wcslen (wszServerRDN) +
        1 +     // For the '.'
        wcslen (globals.pwszRootDomainDNSName) +
        1       // For the '\0'
        );
    pwsz = KCCSimAlloc (ulBytes);
    swprintf (
        pwsz,
        L"%s.%s",
        wszServerRDN,
        globals.pwszRootDomainDNSName
        );
    KCCSimNewAttribute (pEntryServer, ATT_DNS_HOST_NAME, &attRef);
    KCCSimAddValueToAttribute (&attRef, ulBytes, (PBYTE) pwsz);

    pEntryNTDSSettings = BuildCfgSetupNewEntry (
        pEntryServer->pdn,
        BUILDCFG_RDN_NTDS_SETTINGS,
        CLASS_NTDS_DSA
        );

    // mailAddress:
    UuidToStringW (&pEntryNTDSSettings->pdn->Guid, &pwszStringizedGuid);
    Assert (36 == wcslen (pwszStringizedGuid));
    ulBytes = sizeof (WCHAR) * (
        wcslen (BUILDCFG_NAME_MAIL_ADDRESS) +
        1 +     // For the '@'
        36 +    // For the stringized GUID
        1 +     // For the '.'
        wcslen (globals.pwszRootDomainDNSName) +
        1       // For the '\0'
        );
    pwsz = KCCSimAlloc (ulBytes);
    swprintf (
        pwsz,
        L"%s@%s.%s",
        BUILDCFG_NAME_MAIL_ADDRESS,
        pwszStringizedGuid,
        globals.pwszRootDomainDNSName
        );
    RpcStringFreeW (&pwszStringizedGuid);
    KCCSimNewAttribute (pEntryServer, ATT_SMTP_MAIL_ADDRESS, &attRef);
    KCCSimAddValueToAttribute (&attRef, ulBytes - sizeof (WCHAR), (PBYTE) pwsz);

    // hasMasterNCs:
    KCCSimNewAttribute (pEntryNTDSSettings, ATT_HAS_MASTER_NCS, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        globals.pdnConfig->structLen,
        (PBYTE) globals.pdnConfig
        );
    KCCSimAllocAddValueToAttribute (
        &attRef,
        globals.pdnDmd->structLen,
        (PBYTE) globals.pdnDmd
        );
    KCCSimAllocAddValueToAttribute (
        &attRef,
        pdnNc->structLen,
        (PBYTE) pdnNc
        );

    // hasPartialReplicaNCs:
    if (ulServerOptions & NTDSDSA_OPT_IS_GC) {
        for (pEntryCrossRef = KCCSimFindFirstChild (
                globals.pEntryCrossRefContainer, CLASS_CROSS_REF, NULL);
             pEntryCrossRef != NULL;
             pEntryCrossRef = KCCSimFindNextChild (
                pEntryCrossRef, CLASS_CROSS_REF, NULL)) {

            KCCSimGetAttribute (pEntryCrossRef, ATT_NC_NAME, &attRef);
            pdnOtherNc = (PDSNAME) attRef.pAttr->pValFirst->pVal;

            if (!NameMatched (pdnOtherNc, globals.pdnConfig) &&
                !NameMatched (pdnOtherNc, globals.pdnDmd) &&
                !NameMatched (pdnOtherNc, pdnNc)) {
                if (!KCCSimGetAttribute (pEntryNTDSSettings,
                        ATT_HAS_PARTIAL_REPLICA_NCS, &attRef)) {
                    KCCSimNewAttribute (pEntryNTDSSettings,
                        ATT_HAS_PARTIAL_REPLICA_NCS, &attRef);
                }
                KCCSimAllocAddValueToAttribute (
                    &attRef,
                    pdnOtherNc->structLen,
                    (PBYTE) pdnOtherNc
                    );
            }

        }
    }

    // dMDLocation:
    KCCSimNewAttribute (pEntryNTDSSettings, ATT_DMD_LOCATION, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        globals.pdnDmd->structLen,
        (PBYTE) globals.pdnDmd
        );

    // invocationID: Same as GUID for NTDS Settings object
    KCCSimNewAttribute (pEntryNTDSSettings, ATT_INVOCATION_ID, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (GUID),
        (PBYTE) &pEntryNTDSSettings->pdn->Guid
        );

    // options
    KCCSimNewAttribute (pEntryNTDSSettings, ATT_OPTIONS, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (ULONG),
        (PBYTE) &ulServerOptions
        );

    // msDS-Behavior-Version
    ulDsaVersion = DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS;
    KCCSimNewAttribute( pEntryNTDSSettings, ATT_MS_DS_BEHAVIOR_VERSION, &attRef );
    KCCSimAllocAddValueToAttribute( &attRef, sizeof (ULONG), (PBYTE) &ulDsaVersion );

    return pEntryServer;
}

VOID
BuildCfgUpdateTransport (
    IN  LPCWSTR                     pwszTransportRDN,
    IN  ULONG                       ulTransportOptions
    )
/*++

Routine Description:

    Update transport properties

Arguments:

    pwszTransportRDN - Transport being modified
    ulTransportOptions - New value of options

Return Value:

    None.

--*/
{
    const BUILDCFG_TRANSPORT_INFO * pTransport;
    SIM_ATTREF                      attRef;

    Assert (pwszTransportRDN != NULL);

    pTransport = BuildCfgGetTransportInfo (pwszTransportRDN);
    if (pTransport == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_UNKNOWN_TRANSPORT,
            pwszTransportRDN,
            pwszTransportRDN
            );
    }

    Assert( pTransport->pEntry );

    // options:
    KCCSimNewAttribute (pTransport->pEntry, ATT_OPTIONS, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (ULONG),
        (PBYTE) &ulTransportOptions
        );

} /* BuildCfgUpdateTransport  */


PSIM_ENTRY
BuildCfgMakeConfig (
    IN  LPCWSTR                     pwszRootDn,
    IN  DWORD                       ulForestVersion
    )
/*++

Routine Description:

    Sets up the initial config & associated containers.

Arguments:

    pwszRootDn          - The root DN of the enterprise.
    ulForestVersion     - Version number to write for the forest

Return Value:

    The entry of the configuration container.

--*/
{
    PSIM_ENTRY                      pEntryRoot, pEntryConfig, pEntryIntersiteTransports,
                                    pEntryTransport, pEntryDmd, pEntryContainer;
    SIM_ATTREF                      attRef;

    ULONG                           ulTransportAt;

    globals.pdnRootDomain = KCCSimAllocDsname (pwszRootDn);
    globals.pdnConfig = KCCSimAllocAppendRDN (
        globals.pdnRootDomain,
        BUILDCFG_RDN_CONFIG,
        ATT_COMMON_NAME
        );
    globals.pdnDmd = KCCSimAllocAppendRDN (
        globals.pdnConfig,
        BUILDCFG_RDN_DMD,
        ATT_COMMON_NAME
        );
    globals.pwszRootDomainDNSName
        = KCCSimAllocDsnameToDNSName (globals.pdnRootDomain);

    // Create the root domain container

    pEntryRoot = BuildCfgSetupNewEntry (
        globals.pdnRootDomain,
        NULL,
        CLASS_DOMAIN_DNS
        );

    pEntryConfig = BuildCfgSetupNewEntry (
        pEntryRoot->pdn,
        BUILDCFG_RDN_CONFIG,
        CLASS_CONFIGURATION
        );

    // Create the sites container & sub-containers

    globals.pEntrySitesContainer = BuildCfgSetupNewEntry (
        pEntryConfig->pdn,
        BUILDCFG_RDN_SITES_CONTAINER,
        CLASS_SITES_CONTAINER
        );

    pEntryIntersiteTransports = BuildCfgSetupNewEntry (
        globals.pEntrySitesContainer->pdn,
        BUILDCFG_RDN_INTERSITE_TRANSPORTS,
        CLASS_INTER_SITE_TRANSPORT_CONTAINER
        );

    for (ulTransportAt = 0;
         ulTransportAt < ARRAY_SIZE (transportInfo);
         ulTransportAt++) {

        pEntryTransport = BuildCfgSetupNewEntry (
            pEntryIntersiteTransports->pdn,
            transportInfo[ulTransportAt].wszRDN,
            CLASS_INTER_SITE_TRANSPORT
            );
        transportInfo[ulTransportAt].pEntry = pEntryTransport;

        KCCSimNewAttribute (pEntryTransport, ATT_TRANSPORT_ADDRESS_ATTRIBUTE, &attRef);
        KCCSimAllocAddValueToAttribute (
            &attRef,
            sizeof (ATTRTYP),
            (PBYTE) &transportInfo[ulTransportAt].transportAddressAttribute
            );

        KCCSimNewAttribute (pEntryTransport, ATT_TRANSPORT_DLL_NAME, &attRef);
        KCCSimAllocAddValueToAttribute (
            &attRef,
            KCCSIM_WCSMEMSIZE (transportInfo[ulTransportAt].transportDLLName),
            (PBYTE) transportInfo[ulTransportAt].transportDLLName
            );

    }

    // Create the DMD container

    pEntryDmd = BuildCfgSetupNewEntry (
        pEntryConfig->pdn,
        BUILDCFG_RDN_DMD,
        CLASS_DMD
        );

    // Create the cross-ref container
    globals.pEntryCrossRefContainer = BuildCfgSetupNewEntry (
        pEntryConfig->pdn,
        BUILDCFG_RDN_CROSS_REF_CONTAINER,
        CLASS_CROSS_REF_CONTAINER
        );

    // Create msDsBehaviorVersion attribute
    KCCSimNewAttribute (globals.pEntryCrossRefContainer,
                        ATT_MS_DS_BEHAVIOR_VERSION, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef, sizeof(DWORD), (PBYTE) &ulForestVersion );

    // Create the root domain cross-ref
    BuildCfgMakeCrossRef (
        pEntryRoot,
        NULL,
        TRUE
        );

    // Create the enterprise config cross-ref
    BuildCfgMakeCrossRef (
        pEntryConfig,
        BUILDCFG_RDN_CROSS_REF_CONFIG,
        FALSE
        );

    // Create the enterprise schema cross-ref
    BuildCfgMakeCrossRef (
        pEntryDmd,
        BUILDCFG_RDN_CROSS_REF_DMD,
        FALSE
        );

    // Create the services container & sub-containers

    pEntryContainer = BuildCfgSetupNewEntry (
        pEntryConfig->pdn,
        BUILDCFG_RDN_SERVICES,
        CLASS_CONTAINER
        );
    pEntryContainer = BuildCfgSetupNewEntry (
        pEntryContainer->pdn,
        BUILDCFG_RDN_WINDOWS_NT,
        CLASS_CONTAINER
        );
    BuildCfgSetupNewEntry (
        pEntryContainer->pdn,
        BUILDCFG_RDN_DIRECTORY_SERVICE,
        CLASS_NTDS_SERVICE
        );

    return pEntryConfig;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\dir.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dir.h

ABSTRACT:

    Header to be included by all files that access
    the simulated directory.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#ifndef _KCCSIM_DIR_H_
#define _KCCSIM_DIR_H_

typedef struct _SIM_VALUE {
    ULONG                           ulLen;
    PBYTE                           pVal;
    struct _SIM_VALUE *             next;
} SIM_VALUE, * PSIM_VALUE;

typedef struct _SIM_ATTRIBUTE {
    ATTRTYP                         attrType;
    PSIM_VALUE                      pValFirst;
    struct _SIM_ATTRIBUTE *         next;
} SIM_ATTRIBUTE, * PSIM_ATTRIBUTE;

typedef struct _SIM_ENTRY {
    PDSNAME                         pdn;
    PSIM_ATTRIBUTE                  pAttrFirst;
    struct _SIM_ENTRY *             children, *lastChild;
    struct _SIM_ENTRY *             next;
} SIM_ENTRY, * PSIM_ENTRY;

typedef enum {
    KCCSIM_ANCHOR_DMD_DN,
    KCCSIM_ANCHOR_DSA_DN,
    KCCSIM_ANCHOR_DOMAIN_DN,
    KCCSIM_ANCHOR_CONFIG_DN,
    KCCSIM_ANCHOR_ROOT_DOMAIN_DN,
    KCCSIM_ANCHOR_LDAP_DMD_DN,
    KCCSIM_ANCHOR_PARTITIONS_DN,
    KCCSIM_ANCHOR_DS_SVC_CONFIG_DN,
    KCCSIM_ANCHOR_SITE_DN,
    KCCSIM_ANCHOR_DOMAIN_NAME,
    KCCSIM_ANCHOR_DOMAIN_DNS_NAME,
    KCCSIM_ANCHOR_ROOT_DOMAIN_DNS_NAME
} KCCSIM_ANCHOR_ID;

// SIM_ATTREF is how the user references an attribute

typedef struct {
    PSIM_ENTRY                  pEntry;
    PSIM_ATTRIBUTE              pAttr;
} SIM_ATTREF, * PSIM_ATTREF;

// Function prototypes

// From eval.c:

BOOL
KCCSimCompare (
    IN  ULONG                       ulSyntax,
    IN  UCHAR                       ucChoice,
    IN  ULONG                       ulLen1,
    IN  const BYTE *                pVal1,
    IN  ULONG                       ulLen2,
    IN  const BYTE *                pVal2
    );

// From dir.c:

VOID
KCCSimFreeValue (
    IO  PSIM_VALUE *                ppVal
    );

BOOL
KCCSimAttRefIsValid (
    IN  PSIM_ATTREF                 pAttRef
    );

BOOL
KCCSimGetAttribute (
    IN  PSIM_ENTRY                  pEntry,
    IN  ATTRTYP                     attrTyp,
    OUT PSIM_ATTREF                 pAttRef OPTIONAL
    );

VOID
KCCSimNewAttribute (
    IN  PSIM_ENTRY                  pEntry,
    IN  ATTRTYP                     attrType,
    OUT PSIM_ATTREF                 pAttRef OPTIONAL
    );

VOID
KCCSimRemoveAttribute (
    IO  PSIM_ATTREF                 pAttRef
    );

VOID
KCCSimAddValueToAttribute (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  PBYTE                       pValData
    );

VOID
KCCSimAllocAddValueToAttribute (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  PBYTE                       pValData
    );

BOOL
KCCSimRemoveValueFromAttribute (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  PBYTE                       pValData
    );

SHORT
KCCSimNthAncestor (
    IN  const DSNAME *              pdn1,
    IN  const DSNAME *              pdn2
    );

PSIM_ENTRY
KCCSimDsnameToEntry (
    IN  const DSNAME *              pdn,
    IN  ULONG                       ulOptions
    );

PDSNAME
KCCSimAlwaysGetObjCategory (
    IN  ATTRTYP                     objClass
    );

LPWSTR
KCCSimAllocGuidBasedDNSNameFromDSName (
    IN  const DSNAME *              pdn
    );

BOOL
KCCSimUpdateDsnameFromDirectory (
    IO  PDSNAME                     pdn
    );

VOID
KCCSimRemoveEntry (
    IO  PSIM_ENTRY *                pEntry
    );

const DSNAME *
KCCSimAnchorDn (
    IN  KCCSIM_ANCHOR_ID            anchorId
    );

LPCWSTR
KCCSimAnchorString (
    IN  KCCSIM_ANCHOR_ID            anchorId
    );

PSIM_ENTRY
KCCSimFindFirstChild (
    IN  PSIM_ENTRY                  pEntryParent,
    IN  ATTRTYP                     objClass,
    IN  const DSNAME *              pdnCategory OPTIONAL
    );

PSIM_ENTRY
KCCSimFindNextChild (
    IN  PSIM_ENTRY                  pEntryParent,
    IN  ATTRTYP                     objClass,
    IN  const DSNAME *              pdnCategory OPTIONAL
    );

ATTRTYP
KCCSimUpdateObjClassAttr (
    IN  PSIM_ATTREF                 pAttRef
    );

VOID
KCCSimAddMissingAttributes (
    IN  PSIM_ENTRY                  pEntry
    );

VOID
KCCSimUpdatePropertyMetaData (
    IN  PSIM_ATTREF                 pAttRef,
    IN  const UUID *                puuidDsaOriginating OPTIONAL
    );

VOID
KCCSimBuildAnchor (
    IN  LPCWSTR                     pwszDnDsa
    );

VOID
KCCSimUpdateWholeDirectory (
    VOID
    );

VOID
KCCSimInitializeDir (
    VOID
    );

VOID
KCCSimAllocGetAllServers (
    OUT ULONG *                     pulNumServers,
    OUT PSIM_ENTRY **               papEntryNTDSSettings
    );

VOID
KCCSimCompareDirectory (
    IN  LPWSTR                      pwszFn
    );

#endif // _KCCSIM_DIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\ldif.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ldif.c

ABSTRACT:

    Contains routines for importing and exporting the
    simulated directory (or portions of it) to/from an
    ldif file.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <winldap.h>
#include <dsutil.h>
#include <ldifext.h>
#include <attids.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"

/***

    Ldap formats attribute values differently
    from the directory.  Therefore some conversion is necessary.
    It would be nice if conversion routines were exposed somewhere;
    unfortunately, they are not, so kccsim needs to do its own
    conversions.  This is an unpleasant duplicated code issue.

    Ldifldap does not export LDIF_Records to files, but it
    really should.  To support the possibility that such support is
    added in the future, kccsim packages everything into LDIF_Records
    before exporting.  The existing export routines should be
    regarded as stubs, to be replaced when the appropriate routines
    are exposed in ldifldap (if they ever are.)

***/

WORD
KCCSimLdapTimeAsciiToInt (
    IN  CHAR                        cAscii
    )
/*++

Routine Description:

    A cheap hack for converting an ascii representation of
    an integer to a word.  This method seems marginally
    safer (but more annoying) than the simple identity
    (WORD = CHAR - '0').

Arguments:

    cAscii              - An ascii representation of an integer.

Return Value:

    The associated WORD.

--*/
{
    WORD                            wRet;

    switch (cAscii) {

        case '0': wRet = 0; break;
        case '1': wRet = 1; break;
        case '2': wRet = 2; break;
        case '3': wRet = 3; break;
        case '4': wRet = 4; break;
        case '5': wRet = 5; break;
        case '6': wRet = 6; break;
        case '7': wRet = 7; break;
        case '8': wRet = 8; break;
        case '9': wRet = 9; break;
        
        default:
            Assert (!"ldif.c: KCCSimLdapTimeAsciiToInt: invalid input.");
            wRet = 0;
            break;

    }

    return wRet;
}

BOOL
KCCSimLdapTimeToDSTime (
    IN  LPCSTR                  pszLdapTime,
    IN  ULONG                   ulLdapValLen,
    OUT DSTIME *                pdsTime
    )
/*++

Routine Description:

    Converts an ldif time string ("YYYYMMDDhhmmss.0Z") to
    a DSTIME.

Arguments:

    pszLdapTime         - The ldap time string.
    ulLdapValLen        - Length of the time string, in bytes.
    pdsTime             - Pointer to a DSTIME that will hold
                          the result.

Return Value:

    TRUE if the conversion was successful.
    FALSE if the ldif time string was improperly formatted.

--*/
{
    SYSTEMTIME                  systemTime;
    FILETIME                    fileTime;
    DSTIME                      dsTime;
    ULONG                       ul;
    BOOL                        bValid;

    // Check that this is a valid ldif time, i.e.
    // a string of the form "YYYYMMDDhhmmss.0Z"

    bValid = TRUE;
    if (ulLdapValLen < 17             ||
        pszLdapTime[14] != '.'     ||
        pszLdapTime[15] != '0'     ||
        pszLdapTime[16] != 'Z') {
        bValid = FALSE;
    }
    for (ul = 0; ul < 14; ul++) {
        if (!isdigit (pszLdapTime[ul])) {
            bValid = FALSE;
            break;
        }
    }

    if (!bValid) {
        return FALSE;
    }

    systemTime.wYear =
        1000 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++)) +
         100 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++)) +
          10 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++)) +
           1 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++));

    systemTime.wMonth =
          10 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++)) +
           1 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++));

    systemTime.wDay =
          10 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++)) +
           1 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++));

    systemTime.wHour =
          10 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++)) +
           1 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++));

    systemTime.wMinute =
          10 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++)) +
           1 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++));

    systemTime.wSecond =
          10 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++)) +
           1 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++));

    systemTime.wMilliseconds = 0;

    SystemTimeToFileTime (&systemTime, &fileTime);
    FileTimeToDSTime (fileTime, pdsTime);

    return TRUE;
}


BOOL
KccSimDecodeLdapDistnameBinary(
    const BYTE * pszLdapDistnameBinaryValue,
    PVOID *ppvData,
    LPDWORD pcbLength,
    LPSTR *ppszDn
    )

/*++

Routine Description:

    Description

Arguments:

    pszLdapDistnameBinaryValue - Incoming ldap encoded distname binary value
    ppvData - Newly allocated data. Caller must deallocate
    pcbLength - length of returned data
    ppszDn - pointer to dn within incoming buffer, do not deallocate

Return Value:

    BOOL - 

--*/

{
    LPSTR pszColon, pszData;
    DWORD length, i;

    // Check for 'B'
    if (*pszLdapDistnameBinaryValue != 'B') {
        return FALSE;
    }

    // Check for 1st :
    pszLdapDistnameBinaryValue++;
    if (*pszLdapDistnameBinaryValue != ':') {
        return FALSE;
    }

    // Get the length
    pszLdapDistnameBinaryValue++;
    length = strtol(pszLdapDistnameBinaryValue, NULL, 10);
    if (length & 1) {
        // Length should be even
        return FALSE;
    }
    *pcbLength = length / 2;

    // Check for 2nd :
    pszColon = strchr(pszLdapDistnameBinaryValue, L':');
    if (!pszColon) {
        return FALSE;
    }

    // Make sure length is correct
    pszData = pszColon + 1;
    if (pszData[length] != ':') {
        return FALSE;
    }
    pszColon = strchr(pszData, ':');
    if (!pszColon) {
        return FALSE;
    }
    if (pszColon != pszData + length) {
        return FALSE;
    }

    // Decode the data
    *ppvData = KCCSimAlloc( *pcbLength );

    for( i = 0; i < *pcbLength; i++ ) {
        CHAR szHexString[3];
        szHexString[0] = *pszData++;
        szHexString[1] = *pszData++;
        szHexString[2] = '\0';
        ((PCHAR) (*ppvData))[i] = (CHAR) strtol(szHexString, NULL, 16);
    }

    Assert( pszData == pszColon );

    // Return pointer to dn
    *ppszDn = pszColon + 1;

    return TRUE;
} /* decodeLdapDistnameBinary */


BOOL
KCCSimAllocConvertDNBFromLdapVal (
    IN  const BYTE *            pLdapVal,
    OUT PULONG                  pulValLen,
    OUT PBYTE *                 ppVal
    )

/*++

Routine Description:

    Description

Arguments:

    pLdapVal - 
    pulValLen - 
    ppVal - 

Return Value:

    None

--*/

{
    PVOID pvPayload = NULL, pvData = NULL, pvDNB;
    DWORD cbPayload, cbData, cbDNB;
    LPSTR pszDn = NULL;
    PDSNAME pDn = NULL;
    SYNTAX_ADDRESS *pSA;
    SYNTAX_DISTNAME_BINARY *pDNB;

    if (!KccSimDecodeLdapDistnameBinary( pLdapVal,
                                         &pvPayload, &cbPayload, &pszDn )) {
        return FALSE;
    }
    // pszDn is not allocated, but points into pLdapVal
    pDn = KCCSimAllocDsnameFromNarrow (pszDn);

    cbData = STRUCTLEN_FROM_PAYLOAD_LEN( cbPayload );
    pvData = KCCSimAlloc( cbData );
    pSA = (SYNTAX_ADDRESS *)pvData;
    pSA->structLen = cbData;
    memcpy( &(pSA->byteVal), pvPayload, cbPayload );

    cbDNB = DERIVE_NAME_DATA_SIZE( pDn, pSA );
    pvDNB = KCCSimAlloc( cbDNB );
    pDNB = (SYNTAX_DISTNAME_BINARY *)pvDNB;

    BUILD_NAME_DATA( pDNB, pDn, pSA );

    *pulValLen = cbDNB;
    *ppVal = (PBYTE) pDNB;

    if (pvPayload) {
        KCCSimFree( pvPayload );
    }
    if (pvData) {
        KCCSimFree( pvData );
    }
    if (pDn) {
        KCCSimFree( pDn );
    }

    return TRUE;
} /* KCCSimAllocConvertDNBFromLdapVal  */

VOID
KCCSimAllocConvertFromLdapVal (
    IN  LPCWSTR                 pwszFn,
    IN  LPCWSTR                 pwszDn,
    IN  ATTRTYP                 attrType,
    IN  ULONG                   ulLdapValLen,
    IN  const BYTE *            pLdapVal,
    OUT PULONG                  pulValLen,
    OUT PBYTE *                 ppVal
    )
/*++

Routine Description:

    Converts an ldap-formatted value to a properly
    formatted attribute value, allocating space.

Arguments:

    pwszFn              - The filename of the ldif file being processed.  Used
                          for error reporting purposes.
    pwszDn              - The DN of the entry being processed.  Used for error
                          reporting purposes.
    attrType            - Attribute type of the value being converted.
    ulLdapValLen        - Length of the ldap value buffer.
    pLdapVal            - LDAP value.
    pulValLen           - Pointer to a ULONG that will hold the length of the
                          newly allocated buffer.
    ppVal               - Pointer to a PBYTE that will hold the newly allocated
                          buffer.

Return Value:

    None.

--*/
{
    PBYTE                       pVal;

    PDSNAME                     pdn;
    ULONG                       ulSize;

    switch (KCCSimAttrSyntaxType (attrType)) {

        case SYNTAX_DISTNAME_TYPE:
            // The incoming value is a narrow string.  We want the
            // associated DN.  We do not add a GUID to the DN at this
            // stage, since we don't necessarily know it.  That will
            // be done later, when the directory is updated.
            pdn = KCCSimAllocDsnameFromNarrow (pLdapVal);
            *pulValLen = pdn->structLen;
            ((SYNTAX_DISTNAME *) pVal) =
                pdn;
            break;

        case SYNTAX_DISTNAME_BINARY_TYPE:
        {
            if (!KCCSimAllocConvertDNBFromLdapVal(
                pLdapVal,
                pulValLen,
                &pVal)) {

                // This is a warning because W2K kccsim generates DNB
                // as base64, which we don't support.
                KCCSimPrintMessage (                    
                    KCCSIM_WARNING_LDIF_INVALID_DISTNAME_BINARY,
                    pwszFn,
                    pwszDn,
                    KCCSimAttrTypeToString (attrType)
                    );
                *pulValLen = 0;
                pVal = NULL;
            }
            break;
        }

        case SYNTAX_OBJECT_ID_TYPE:
            // The incoming value is a narrow string.  We want the
            // attribute type associated with that string.
            *pulValLen = sizeof (SYNTAX_OBJECT_ID);
            pVal = KCCSimAlloc (*pulValLen);
            *((SYNTAX_OBJECT_ID *) pVal) =
                KCCSimNarrowStringToAttrType (pLdapVal);
            // Print a warning if we failed to convert the string;
            // it will default to 0.
            if (*((SYNTAX_OBJECT_ID *) pVal) == 0) {
                KCCSimPrintMessage (
                    KCCSIM_WARNING_LDIF_INVALID_OBJECT_ID,
                    pwszFn,
                    pwszDn,
                    KCCSimAttrTypeToString (attrType)
                    );
            }
            break;

        case SYNTAX_BOOLEAN_TYPE:
            // Here the incoming value is either "TRUE" or "FALSE".
            *pulValLen = sizeof (SYNTAX_BOOLEAN);
            pVal = KCCSimAlloc (*pulValLen);
            if (strcmp (pLdapVal, "TRUE") == 0) {
                *((SYNTAX_BOOLEAN *) pVal) = TRUE;
            } else if (strcmp (pLdapVal, "FALSE") == 0) {
                *((SYNTAX_BOOLEAN *) pVal) = FALSE;
            } else {
                // It wasn't "TRUE" or "FALSE"; print
                // a warning and default to FALSE.
                KCCSimPrintMessage (
                    KCCSIM_WARNING_LDIF_INVALID_BOOLEAN,
                    pwszFn,
                    pwszDn,
                    KCCSimAttrTypeToString (attrType)
                    );
                *((SYNTAX_BOOLEAN *) pVal) = FALSE;
            }
            break;

        case SYNTAX_INTEGER_TYPE:
            // The incoming value is a narrow string.
            *pulValLen = sizeof (SYNTAX_INTEGER);
            pVal = KCCSimAlloc (*pulValLen);
            *((SYNTAX_INTEGER *) pVal) =
                atol (pLdapVal);
            break;

        case SYNTAX_TIME_TYPE:
            // The incoming value is an LDAP formatted time.
            *pulValLen = sizeof (SYNTAX_TIME);
            pVal = KCCSimAlloc (*pulValLen);
            if (!KCCSimLdapTimeToDSTime (
                    (LPSTR) pLdapVal,
                    ulLdapValLen,
                    (SYNTAX_TIME *) pVal
                    )) {
                // It was improperly formatted; print
                // a warning and default to 0 (never).
                KCCSimPrintMessage (
                    KCCSIM_WARNING_LDIF_INVALID_TIME,
                    pwszFn,
                    pwszDn,
                    KCCSimAttrTypeToString (attrType)
                    );
                *((SYNTAX_TIME *) pVal) = 0;
            }
            break;

        case SYNTAX_UNICODE_TYPE:
            // The incoming value is a narrow string; we must
            // convert to a wide string.
            pVal = (PBYTE) KCCSimAllocWideStr (
                CP_UTF8, (LPSTR) pLdapVal);
            *pulValLen = KCCSIM_WCSMEMSIZE ((LPWSTR) pVal);
            break;

        case SYNTAX_I8_TYPE:
            // The incoming value is a narrow string; we want
            // a large integer, so we use atoli.
            *pulValLen = sizeof (LARGE_INTEGER);
            pVal = KCCSimAlloc (*pulValLen);
            *((SYNTAX_I8 *) pVal) =
                atoli ((LPSTR) pLdapVal);
            break;

        // For all of the below, we want either a binary or a
        // narrow string.  So we can just do a direct block-copy.
        case SYNTAX_UNDEFINED_TYPE:
        case SYNTAX_CASE_STRING_TYPE:
        case SYNTAX_NOCASE_STRING_TYPE:
        case SYNTAX_PRINT_CASE_STRING_TYPE:
        case SYNTAX_NUMERIC_STRING_TYPE:
        case SYNTAX_OCTET_STRING_TYPE:
        case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:
        case SYNTAX_SID_TYPE:
            *pulValLen = ulLdapValLen;
            pVal = KCCSimAlloc (*pulValLen);
            memcpy (pVal, pLdapVal, ulLdapValLen);
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_SYNTAX_TYPE,
                KCCSimAttrTypeToString (attrType)
                );
            pVal = NULL;
            break;

    }

    *ppVal = pVal;

}


VOID
KCCSimAllocConvertDNBToLdapVal(
    IN  const BYTE *            pVal,
    OUT PULONG                  pulLdapValLen,
    OUT PBYTE *                 ppLdapVal
    )

/*++

Routine Description:

    Convert a directory entry value to a LDAP Distname Binary

    Copied and modified from ldapcore.cxx:LDAP_LDAPDNBlobToDirDNBlob

Arguments:

    ulValLen - binary length
    pVal - binary value
    pulLdapValLen - Updated string length in chars
    ppLdapVal - ascii string

Return Value:

    None

--*/

{
    DWORD cbPayload, cbName, cbTotal, j;
    SYNTAX_ADDRESS *pSA;
    PDSNAME pDn;
    LPSTR pszName = NULL, pszLdap = NULL, p;

    pDn = NAMEPTR( (SYNTAX_DISTNAME_BINARY *) pVal );
    pSA = DATAPTR( (SYNTAX_DISTNAME_BINARY *) pVal );

    cbPayload = PAYLOAD_LEN_FROM_STRUCTLEN( pSA->structLen );

    // Convert wide string to narrow string.
    pszName = (LPSTR) KCCSimAllocNarrowStr(CP_UTF8, pDn->StringName);
    cbName = KCCSIM_STRMEMSIZE(pszName);

    cbTotal = 2 + 10 + 1 + (2*cbPayload) + 1 + cbName;

    p = pszLdap = (LPSTR) KCCSimAlloc( cbTotal );
    
    *p++ = 'B';
    *p++ = ':';

    // There are two hex digits for each byte of data
    _ltoa( cbPayload * 2, p, 10 );
    p += strlen( p );

    *p++ = ':';

    for(j=0; j < cbPayload ; j++) {
        sprintf(p,"%02X", pSA->byteVal[j]);
        p += 2;
    }

    *p++ = ':';

    strcpy( p, pszName );

    *pulLdapValLen = ((DWORD) (pszLdap - p)) + cbName;
    *ppLdapVal = (PBYTE) pszLdap;

    // cbTotal is an upper limit, because we estimate the length
    // of the string-ized count of digits
    Assert( *pulLdapValLen <= cbTotal );

    KCCSimFree( pszName );

} /* KCCSimAllocConvertDNBToLdapVal */

VOID
KCCSimAllocConvertToLdapVal (
    IN  ATTRTYP                 attrType,
    IN  ULONG                   ulValLen,
    IN  const BYTE *            pVal,
    OUT PULONG                  pulLdapValLen,
    OUT PBYTE *                 ppLdapVal
    )
/*++

Routine Description:

    Converts a value from the directory to an ldap-formatted value.

Arguments:

    attrType            - Attribute type of the value being converted.
    pulValLen           - The length of the value in the directory.
    ppVal               - The value in the directory.
    pulLdapValLen       - Pointer to a ULONG that will hold the length of the
                          newly allocated buffer.
    ppLdapVal           - Pointer to a PBYTE that will hold the newly allocated
                          buffer.

Return Value:

    None.

--*/
{
    PBYTE                       pLdapVal;

    SYSTEMTIME                  systemTime;
    struct tm                   tmTime;

    switch (KCCSimAttrSyntaxType (attrType)) {

        case SYNTAX_DISTNAME_TYPE:
            // Convert wide string to narrow string.
            pLdapVal = (PBYTE) KCCSimAllocNarrowStr (
                CP_UTF8, ((SYNTAX_DISTNAME *) pVal)->StringName);
            *pulLdapValLen = KCCSIM_STRMEMSIZE ((LPSTR) pLdapVal);
            break;

        case SYNTAX_OBJECT_ID_TYPE:
            // Convert object ID to wide string to narrow string.
            pLdapVal = (PBYTE) KCCSimAllocNarrowStr (
                CP_UTF8,
                KCCSimAttrTypeToString (*((SYNTAX_OBJECT_ID *) pVal))
                );
            *pulLdapValLen = KCCSIM_STRMEMSIZE ((LPSTR) pLdapVal);
            break;

        case SYNTAX_BOOLEAN_TYPE:
            // Convert BOOL to "TRUE" or "FALSE".
            if (*((SYNTAX_BOOLEAN *) pVal)) {
                pLdapVal = KCCSIM_STRDUP ("TRUE");
            } else {
                pLdapVal = KCCSIM_STRDUP ("FALSE");
            }
            *pulLdapValLen = KCCSIM_STRMEMSIZE ((LPSTR) pLdapVal);
            break;

        case SYNTAX_INTEGER_TYPE:
            // Convert integer to narrow string.
            pLdapVal = KCCSimAlloc (sizeof (CHAR) * (1 + KCCSIM_MAX_LTOA_CHARS));
            _ltoa (*((SYNTAX_INTEGER *) pVal), (LPSTR) pLdapVal, 10);
            *pulLdapValLen = KCCSIM_STRMEMSIZE ((LPSTR) pLdapVal);
            break;

        case SYNTAX_TIME_TYPE:
            // Convert the time using strftime.
            pLdapVal = KCCSimAlloc (18);
            DSTimeToUtcSystemTime (
                *((SYNTAX_TIME *) pVal),
                &systemTime
                );
            tmTime.tm_year = systemTime.wYear - 1900;
            tmTime.tm_mon = systemTime.wMonth - 1;
            tmTime.tm_wday = systemTime.wDayOfWeek;
            tmTime.tm_mday = systemTime.wDay;
            tmTime.tm_hour = systemTime.wHour;
            tmTime.tm_min = systemTime.wMinute;
            tmTime.tm_sec = systemTime.wSecond;
            tmTime.tm_isdst = 0;
            tmTime.tm_yday = 0;
            strftime ((LPSTR) pLdapVal, 17, "%Y%m%d%H%M%S.0Z", &tmTime);
            *pulLdapValLen = KCCSIM_STRMEMSIZE ((LPSTR) pLdapVal);
            break;

        case SYNTAX_UNICODE_TYPE:
            // Convert wide string to narrow string.
            pLdapVal = (PBYTE) KCCSimAllocNarrowStr (CP_UTF8, (SYNTAX_UNICODE *) pVal);
            *pulLdapValLen = KCCSIM_STRMEMSIZE ((LPSTR) pLdapVal);
            break;

        case SYNTAX_I8_TYPE:
            // Convert large integer to narrow string.
            pLdapVal = KCCSimAlloc (sizeof (CHAR) * (1 + KCCSIM_MAX_LITOA_CHARS));
            litoa (*((SYNTAX_I8 *) pVal), pLdapVal, 10);
            *pulLdapValLen = KCCSIM_STRMEMSIZE ((LPSTR) pLdapVal);
            break;

        case SYNTAX_DISTNAME_BINARY_TYPE:
            KCCSimAllocConvertDNBToLdapVal(
                pVal,
                pulLdapValLen,
                &pLdapVal
                );
            break;

        // All the rest can be done using block-copy.
        case SYNTAX_UNDEFINED_TYPE:
        case SYNTAX_CASE_STRING_TYPE:
        case SYNTAX_NOCASE_STRING_TYPE:
        case SYNTAX_PRINT_CASE_STRING_TYPE:
        case SYNTAX_NUMERIC_STRING_TYPE:
        case SYNTAX_OCTET_STRING_TYPE:
        case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:
        case SYNTAX_SID_TYPE:
            *pulLdapValLen = ulValLen;
            pLdapVal = KCCSimAlloc (*pulLdapValLen);
            memcpy (pLdapVal, pVal, ulValLen);
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_SYNTAX_TYPE
                );
            pLdapVal = NULL;
            break;

    }

    *ppLdapVal = pLdapVal;
}

VOID
KCCSimAddMods (
    IN  LPCWSTR                 pwszFn,
    IN  PSIM_ENTRY              pEntry,
    IN  PLDAPModW *             pLdapMods
    )
/*++

Routine Description:

    Inserts an array of PLDAPModW structures into the directory.

Arguments:

    pwszFn              - The filename of the LDIF file being processed.
                          Used for error reporting purposes.
    pEntry              - The entry into which to insert the mods.
    pLdapMods           - NULL-terminated array of PLDAPModW structures.

Return Value:

    None.

--*/
{
    ATTRTYP                     attrType;
    ULONG                       mod_op;

    SIM_ATTREF                  attRef;
    ULONG                       ulAttrAt, ulValAt;

    ULONG                       ulValLen;
    PBYTE                       pVal;

    for (ulAttrAt = 0; pLdapMods[ulAttrAt] != NULL; ulAttrAt++) {

        if (!(pLdapMods[ulAttrAt]->mod_op & LDAP_MOD_BVALUES)) {
            // We don't support string values yet, since ldifldap
            // only returns bervals.
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_LDAPMOD_STRINGVAL_NOT_SUPPORTED
                );
        }

        // Get this attribute
        attrType = KCCSimStringToAttrType (pLdapMods[ulAttrAt]->mod_type);
        KCCSimGetAttribute (
            pEntry,
            attrType,
            &attRef
            );
        mod_op = pLdapMods[ulAttrAt]->mod_op & (~LDAP_MOD_BVALUES);

        switch (mod_op) {

            case LDAP_MOD_REPLACE:
                // Replace this attribute, so delete the existing one.
                if (attRef.pAttr != NULL) {
                    KCCSimRemoveAttribute (&attRef);
                }
                // Deliberate fall-through to LDAP_MOD_ADD:

            case LDAP_MOD_ADD:
                if (attRef.pAttr == NULL) {
                    // Create this attribute if it doesn't exist.
                    KCCSimNewAttribute (
                        pEntry,
                        attrType,
                        &attRef
                        );
                }
                Assert (attRef.pAttr != NULL);
                for (ulValAt = 0;
                     pLdapMods[ulAttrAt]->mod_bvalues[ulValAt] != NULL;
                     ulValAt++) {
                    KCCSimAllocConvertFromLdapVal (
                        pwszFn,
                        pEntry->pdn->StringName,
                        attrType,
                        pLdapMods[ulAttrAt]->mod_bvalues[ulValAt]->bv_len,
                        pLdapMods[ulAttrAt]->mod_bvalues[ulValAt]->bv_val,
                        &ulValLen,
                        &pVal
                        );
                    if( NULL!=pVal ) {
                        KCCSimAddValueToAttribute (
                            &attRef,
                            ulValLen,
                            pVal
                            );
                    }
                }
                break;

            case LDAP_MOD_DELETE:
                if (attRef.pAttr == NULL) {
                    break;
                }
                if (pLdapMods[ulAttrAt]->mod_bvalues == NULL) {
                    // No values specified; delete the entire attribute.
                    KCCSimRemoveAttribute (&attRef);
                } else {
                    // Delete specific attribute values.
                    for (ulValAt = 0;
                         pLdapMods[ulAttrAt]->mod_bvalues[ulValAt] != NULL;
                         ulValAt++) {
                        KCCSimAllocConvertFromLdapVal (
                            pwszFn,
                            pEntry->pdn->StringName,
                            attrType,
                            pLdapMods[ulAttrAt]->mod_bvalues[ulValAt]->bv_len,
                            pLdapMods[ulAttrAt]->mod_bvalues[ulValAt]->bv_val,
                            &ulValLen,
                            &pVal
                            );
                        KCCSimRemoveValueFromAttribute (
                            &attRef,
                            pLdapMods[ulAttrAt]->mod_bvalues[ulValAt]->bv_len,
                            pLdapMods[ulAttrAt]->mod_bvalues[ulValAt]->bv_val
                            );
                        if (pVal != NULL) {
                            KCCSimFree (pVal);
                        }
                    }
                }
                break;

            default:
                KCCSimException (
                    KCCSIM_ETYPE_INTERNAL,
                    KCCSIM_ERROR_LDAPMOD_UNSUPPORTED_MODIFY_CHOICE
                    );
                break;

        }

    }

}

PLDAPModW
KCCSimAllocAttrToLdapMod (
    IN  ULONG                       mod_op,
    IN  LPCWSTR                     pwszLdapDisplayName,
    IN  ATTR *                      pAttr
    )
/*++

Routine Description:

    Converts an ATTR structure to a PLDAPModW.  This function
    allocates space to hold the PLDAPModW structure.

Arguments:

    mod_op              - The operation being performed.
    pwszLdapDisplayName - LDAP display name of the attribute.
    pAttr               - Pointer to the attribute in question.
                          May be NULL to indicate no attribute values.

Return Value:

    The newly allocated PLDAPModW.

--*/
{
    PLDAPModW                       pLdapMod;
    ULONG                           ulValAt;

    pLdapMod = KCCSIM_NEW (LDAPModW);
    pLdapMod->mod_op = mod_op | LDAP_MOD_BVALUES;
    pLdapMod->mod_type = KCCSIM_WCSDUP (pwszLdapDisplayName);

    if (pAttr == NULL) {
        pLdapMod->mod_bvalues = NULL;
    } else {

        pLdapMod->mod_bvalues = KCCSIM_NEW_ARRAY
            (struct berval *, 1 + pAttr->AttrVal.valCount);

        for (ulValAt = 0; ulValAt < pAttr->AttrVal.valCount; ulValAt++) {

            pLdapMod->mod_bvalues[ulValAt] = KCCSIM_NEW (struct berval);
            KCCSimAllocConvertToLdapVal (
                pAttr->attrTyp,
                pAttr->AttrVal.pAVal[ulValAt].valLen,
                pAttr->AttrVal.pAVal[ulValAt].pVal,
                &(pLdapMod->mod_bvalues[ulValAt]->bv_len),
                &(pLdapMod->mod_bvalues[ulValAt]->bv_val)
                );

        }

        pLdapMod->mod_bvalues[ulValAt] = NULL;

    }

    return pLdapMod;
}

VOID
KCCSimFreeLdapMods (
    IN  PLDAPModW *                 ppLdapMod
    )
/*++

Routine Description:

    Frees a NULL-terminated array of PLDAPModWs.

Arguments:

    ppLdapMod           - The array to free.

Return Value:

    None.

--*/
{
    ULONG                           ulModAt, ulValAt;

    if (ppLdapMod == NULL) {
        return;
    }

    for (ulModAt = 0;
         ppLdapMod[ulModAt] != NULL;
         ulModAt++) {

        Assert (ppLdapMod[ulModAt]->mod_op & LDAP_MOD_BVALUES);

        if (ppLdapMod[ulModAt]->mod_type != NULL) {
            KCCSimFree (ppLdapMod[ulModAt]->mod_type);
        }

        if (ppLdapMod[ulModAt]->mod_bvalues != NULL) {

            for (ulValAt = 0;
                 ppLdapMod[ulModAt]->mod_bvalues[ulValAt] != NULL;
                 ulValAt++) {

                if (ppLdapMod[ulModAt]->mod_bvalues[ulValAt]->bv_val != NULL) {
                    KCCSimFree (ppLdapMod[ulModAt]->mod_bvalues[ulValAt]->bv_val);
                }
                KCCSimFree (ppLdapMod[ulModAt]->mod_bvalues[ulValAt]);

            }
            KCCSimFree (ppLdapMod[ulModAt]->mod_bvalues);

        }

        KCCSimFree (ppLdapMod[ulModAt]);

    }

    KCCSimFree (ppLdapMod);
}

/***

    The next several routines are concerned with maintaining a list of
    changes to the directory.  KCCSim supports an export mode where only
    the changes made to the directory since the last export are reported.
    Every time a function (such as a SimDir* API) modifies the simulated
    directory, it calls KCCSimLogDirectory*.  The change is then added
    to a global list of changes.  This global list is written out when
    KCCSimExportChanges () is called.

***/

struct _KCCSIM_CHANGE {
    LPWSTR                          pwszDn;
    int                             operation;
    LDAPModW **                     ppLdapMod;
    struct _KCCSIM_CHANGE *         next;
};

struct _KCCSIM_CHANGE *             gMostRecentChange = NULL;

VOID
KCCSimFreeChanges (
    IN  struct _KCCSIM_CHANGE *     pChanges
    )
/*++

Routine Description:

    Frees a list of changes.

Arguments:

    pChanges            - The list to free.

Return Value:

    None.

--*/
{
    struct _KCCSIM_CHANGE *         pChangeNext;
    ULONG                           ulModAt;

    while (pChanges != NULL) {

        pChangeNext = pChanges->next;

        if (pChanges->pwszDn != NULL) {
            KCCSimFree (pChanges->pwszDn);
        }
        KCCSimFreeLdapMods (pChanges->ppLdapMod);
        KCCSimFree (pChanges);

        pChanges = pChangeNext;

    }
}

VOID
KCCSimLogDirectoryAdd (
    IN  const DSNAME *              pdn,
    IN  ATTRBLOCK *                 pAddBlock
    )
/*++

Routine Description:

    Logs an add to the global change list.

Arguments:

    pdn                 - The affected DN.
    pAddBlock           - The ATTRBLOCK corresponding to the add.

Return Value:

    None.

--*/
{
    struct _KCCSIM_CHANGE *         pChange;
    ULONG                           ulAttrAt, ulValAt;

    Assert (pAddBlock != NULL);

    pChange = KCCSIM_NEW (struct _KCCSIM_CHANGE);
    pChange->pwszDn = KCCSIM_WCSDUP (pdn->StringName);
    pChange->operation = CHANGE_ADD;
    pChange->ppLdapMod = KCCSIM_NEW_ARRAY (PLDAPModW, 1 + pAddBlock->attrCount);

    for (ulAttrAt = 0; ulAttrAt < pAddBlock->attrCount; ulAttrAt++) {

        pChange->ppLdapMod[ulAttrAt] =
        KCCSimAllocAttrToLdapMod (
            LDAP_MOD_ADD,
            KCCSimAttrTypeToString (pAddBlock->pAttr[ulAttrAt].attrTyp),
            &(pAddBlock->pAttr[ulAttrAt])
            );

    }

    pChange->ppLdapMod[ulAttrAt] = NULL;

    pChange->next = gMostRecentChange;
    gMostRecentChange = pChange;
}

VOID
KCCSimLogDirectoryRemove (
    IN  const DSNAME *              pdn
    )
/*++

Routine Description:

    Logs a remove to the global change list.

Arguments:

    pdn                 - The affected DN.

Return Value:

    None.

--*/
{
    struct _KCCSIM_CHANGE *         pChange;
    pChange = KCCSIM_NEW (struct _KCCSIM_CHANGE);
    pChange->pwszDn = KCCSIM_WCSDUP (pdn->StringName);
    pChange->operation = CHANGE_DEL;
    pChange->ppLdapMod = NULL;

    pChange->next = gMostRecentChange;
    gMostRecentChange = pChange;
}

VOID
KCCSimLogDirectoryModify (
    IN  const DSNAME *              pdn,
    IN  ULONG                       ulCount,
    IN  ATTRMODLIST *               pModifyList
    )
/*++

Routine Description:

    Logs a modify to the global change list.

Arguments:

    pdn                 - The affected DN.
    ulCount             - The number of modifications present.
    pModifyList         - The list of modifications.

Return Value:

    None.

--*/
{
    ATTRMODLIST *                   pModifyAt;
    struct _KCCSIM_CHANGE *         pChange;
    LPCWSTR                         pwszLdapDisplayName;
    ULONG                           ulModAt;

    Assert (ulCount > 0);

    pChange = KCCSIM_NEW (struct _KCCSIM_CHANGE);
    pChange->pwszDn = KCCSIM_WCSDUP (pdn->StringName);
    pChange->operation = CHANGE_MOD;
    pChange->ppLdapMod = KCCSIM_NEW_ARRAY (PLDAPModW, 1 + ulCount);

    pModifyAt = pModifyList;
    for (ulModAt = 0; ulModAt < ulCount; ulModAt++) {

        // If ulCount is correct, we should still be non-null
        Assert (pModifyAt != NULL);
        pwszLdapDisplayName = KCCSimAttrTypeToString (pModifyAt->AttrInf.attrTyp);

        switch (pModifyAt->choice) {

            case AT_CHOICE_ADD_ATT:
                pChange->ppLdapMod[ulModAt] =
                KCCSimAllocAttrToLdapMod (
                    LDAP_MOD_ADD,
                    pwszLdapDisplayName,
                    &(pModifyAt->AttrInf)
                    );
                break;

            case AT_CHOICE_REMOVE_ATT:
                pChange->ppLdapMod[ulModAt] =
                KCCSimAllocAttrToLdapMod (
                    LDAP_MOD_DELETE,
                    pwszLdapDisplayName,
                    NULL
                    );
                break;

            case AT_CHOICE_ADD_VALUES:
                pChange->ppLdapMod[ulModAt] =
                KCCSimAllocAttrToLdapMod (
                    LDAP_MOD_ADD,
                    pwszLdapDisplayName,
                    &(pModifyAt->AttrInf)
                    );
                break;

            case AT_CHOICE_REMOVE_VALUES:
                pChange->ppLdapMod[ulModAt] =
                KCCSimAllocAttrToLdapMod (
                    LDAP_MOD_DELETE,
                    pwszLdapDisplayName,
                    &(pModifyAt->AttrInf)
                    );
                break;

            case AT_CHOICE_REPLACE_ATT:
                pChange->ppLdapMod[ulModAt] =
                KCCSimAllocAttrToLdapMod (
                    LDAP_MOD_REPLACE,
                    pwszLdapDisplayName,
                    &(pModifyAt->AttrInf)
                    );
                break;

            default:
                KCCSimException (
                    KCCSIM_ETYPE_INTERNAL,
                    KCCSIM_ERROR_UNSUPPORTED_MODIFY_CHOICE
                    );
                break;

        }

        pModifyAt = pModifyAt->pNextMod;

    }

    pChange->ppLdapMod[ulModAt] = NULL;

    pChange->next = gMostRecentChange;
    gMostRecentChange = pChange;
}

VOID
KCCSimLogSingleAttValChange (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  PBYTE                       pValData,
    IN  USHORT                      choice
    )
/*++

Routine Description:

    Shortcut routine to log a single modification of an attribute value.

Arguments:

    pAttRef             - A valid reference to the attribute being modified.
    ulValLen            - Length of the buffer containing the affected value.
    pValData            - The affected attribute value.
    choice              - One of AT_CHOICE_*.

Return Value:

    None.

--*/
{
    ATTRMODLIST                     attrModList;

    Assert (KCCSimAttRefIsValid (pAttRef));
    Assert (pValData != NULL);

    attrModList.pNextMod = NULL;
    attrModList.choice = choice;
    attrModList.AttrInf.attrTyp = pAttRef->pAttr->attrType;
    attrModList.AttrInf.AttrVal.valCount = 1;
    attrModList.AttrInf.AttrVal.pAVal = KCCSIM_NEW (ATTRVAL);
    attrModList.AttrInf.AttrVal.pAVal[0].valLen = ulValLen;
    attrModList.AttrInf.AttrVal.pAVal[0].pVal = pValData;
    KCCSimLogDirectoryModify (
        pAttRef->pEntry->pdn,
        1,
        &attrModList
        );
    KCCSimFree (attrModList.AttrInf.AttrVal.pAVal);
}    

VOID
KCCSimHandleLdifError (
    IN  LPCWSTR                 pwszFn,
    IN  LDIF_Error *            pLdifError
    )
/*++

Routine Description:

    Checks the return struct of an LDIF_* call, and takes the
    appropriate action (i.e. raises an exception on error.)

Arguments:

    pwszFn              - The LDIF file being processed.  Used for error
                          reporting purposes.
    pLdifError          - The error struct.

Return Value:

    None.

--*/
{
    WCHAR                       wszLtowBuf[1+KCCSIM_MAX_LTOA_CHARS];

    switch (pLdifError->error_code) {

        case LL_SUCCESS:
            break;

        case LL_SYNTAX:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_LDIF_SYNTAX,
                pwszFn,
                _ltow (pLdifError->line_number, wszLtowBuf, 10)
                );
            break;

        case LL_FILE_ERROR:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_LDIF_FILE_ERROR,
                pwszFn
                );
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_LDIF_UNEXPECTED,
                pwszFn,
                _ultow (pLdifError->error_code, wszLtowBuf, 16)
                );
            break;

    }
}

VOID
KCCSimLoadLdif (
    IN  LPCWSTR                 pwszFn
    )
/*++

Routine Description:

    Loads an ldif file into the directory.

Arguments:

    pwszFn              - The ldif file to load.

Return Value:

    None.

--*/
{
    LDIF_Error                  ldifError;
    LDIF_Record                 ldifRecord;
    PDSNAME                     pdn;
    PSIM_ENTRY                  pEntry;
    struct change_list *        changeAt;
    ULONG                       ulCount = 0;

    RtlZeroMemory (&ldifRecord, sizeof (LDIF_Record));

    // This is an ugly typecast; LDIF_InitializeImport should
    // accept a constant string as the filename.
    ldifError = LDIF_InitializeImport (NULL, (LPWSTR) pwszFn, NULL, NULL, NULL);
    if (ldifError.error_code != LL_SUCCESS) {
        KCCSimHandleLdifError (pwszFn, &ldifError);
    }

    do {

        ldifError = LDIF_Parse (&ldifRecord);

        if (ldifError.error_code != LL_SUCCESS &&
            ldifError.error_code != LL_EOF) {
            KCCSimHandleLdifError (pwszFn, &ldifError);
        }

        pdn = KCCSimAllocDsname (ldifRecord.dn);

        if (ldifRecord.fIsChangeRecord) {

            changeAt = ldifRecord.changes;
            while (changeAt != NULL) {
                switch (changeAt->operation) {

                    case CHANGE_ADD:
                        if (KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS) != NULL) {
                            KCCSimPrintMessage (
                                KCCSIM_WARNING_LDIF_ENTRY_ALREADY_EXISTS,
                                pwszFn,
                                pdn->StringName
                                );
                        }
                        pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_WRITE);
                        KCCSimAddMods (pwszFn, pEntry, changeAt->mods_mem);
                        break;

                    case CHANGE_DEL:
                        pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
                        if (pEntry == NULL) {
                            KCCSimPrintMessage (
                                KCCSIM_WARNING_LDIF_NO_ENTRY_TO_DELETE,
                                pwszFn,
                                pdn->StringName
                                );
                            break;
                        }
                        KCCSimRemoveEntry (&pEntry);
                        break;

                    case CHANGE_MOD:
                        pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
                        if (pEntry == NULL) {
                            KCCSimPrintMessage (
                                KCCSIM_WARNING_LDIF_NO_ENTRY_TO_MODIFY,
                                pwszFn,
                                pdn->StringName
                                );
                            break;
                        }
                        KCCSimAddMods (pwszFn, pEntry, changeAt->mods_mem);
                        break;

                    default:
                        KCCSimException (
                            KCCSIM_ETYPE_INTERNAL,
                            KCCSIM_ERROR_UNSUPPORTED_LDIF_OPERATION
                            );
                        break;

                }
                changeAt = changeAt->next;
            }

        } else {        // !fIsChangeRecord

            pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
            if (pEntry != NULL) {
                KCCSimPrintMessage (
                    KCCSIM_WARNING_LDIF_REPLACING_TREE,
                    pwszFn,
                    pdn->StringName
                    );
                KCCSimRemoveEntry (&pEntry);
            }
            pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_WRITE);
            KCCSimAddMods (pwszFn, pEntry, ldifRecord.content);

        }

        KCCSimFree (pdn);
        LDIF_ParseFree (&ldifRecord);

    } while (ldifError.error_code != LL_EOF);

    LDIF_CleanUp();
}

// A string is safe if:
// Every character is between ASCII 0x20 and 0x7e
// The first character is neither ':', ' ' nor '<'.
BOOL
KCCSimIsSafe (
    IN  LPCSTR                      psz
    )
/*++

Routine Description:

    Verifies that a string is safe to write into an LDIF file.  A string
    is safe if both of these conditions are satisfied:
        (1) Every character is between ASCII 0x20 and 0x78
        (2) The first character is neither ':', ' ' nor '<'.

Arguments:

    psz                 - The string to verify.

Return Value:

    TRUE if the string is safe.

--*/
{
    ULONG                           ul;

    Assert (psz != NULL);

    if (psz[0] == ':' ||
        psz[0] == ' ' ||
        psz[0] == '<') {
        return FALSE;
    }

    for (ul = 0; psz[ul] != '\0'; ul++) {
        if (psz[ul] < 0x20 || psz[ul] > 0x7e) {
            return FALSE;
        }
    }

    return TRUE;
}

VOID
KCCSimExportVals (
    IN  FILE *                      fpOut,
    IN  PLDAPModW                   pLdapMod
    )
/*++

Routine Description:

    Exports the data contained in an LDAPModW structure to
    an output file.

Arguments:

    fpOut               - File pointer of the output file.
    pLdapMod            - Pointer to the LDAPModW to export.

Return Value:

    None.

--*/
{
    ULONG                           ulValAt;

    NTSTATUS                        ntStatus;
    PWSTR                           pwsz;
    ULONG                           cb;
    BOOL                            bBinary;
    
    Assert (pLdapMod->mod_op & LDAP_MOD_BVALUES);

    if (pLdapMod->mod_bvalues == NULL) {
        return;
    }

    for (ulValAt = 0;
         pLdapMod->mod_bvalues[ulValAt] != NULL;
         ulValAt++) {

        fwprintf (fpOut, L"%s:", pLdapMod->mod_type);
        switch (KCCSimAttrSyntaxType (KCCSimStringToAttrType (pLdapMod->mod_type))) {

            case SYNTAX_DISTNAME_TYPE:
            case SYNTAX_DISTNAME_BINARY_TYPE:
            case SYNTAX_OBJECT_ID_TYPE:
            case SYNTAX_CASE_STRING_TYPE:
            case SYNTAX_NOCASE_STRING_TYPE:
            case SYNTAX_PRINT_CASE_STRING_TYPE:
            case SYNTAX_NUMERIC_STRING_TYPE:
            case SYNTAX_BOOLEAN_TYPE:
            case SYNTAX_INTEGER_TYPE:
            case SYNTAX_TIME_TYPE:
            case SYNTAX_UNICODE_TYPE:
            case SYNTAX_I8_TYPE:
                bBinary = !KCCSimIsSafe (
                    (LPSTR) pLdapMod->mod_bvalues[ulValAt]->bv_val);
                break;

            case SYNTAX_UNDEFINED_TYPE:
            case SYNTAX_OCTET_STRING_TYPE:
            case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:
            case SYNTAX_SID_TYPE:
                bBinary = TRUE;
                break;

            default:
                KCCSimException (
                    KCCSIM_ETYPE_INTERNAL,
                    KCCSIM_ERROR_UNSUPPORTED_SYNTAX_TYPE,
                    pLdapMod->mod_type
                    );
                bBinary = TRUE;
                break;

        }

        if (bBinary) {

            pwsz = base64encode (
                pLdapMod->mod_bvalues[ulValAt]->bv_val,
                pLdapMod->mod_bvalues[ulValAt]->bv_len
                );
            Assert( pwsz != NULL );
            fwprintf (
                fpOut,
                L": %s\n",
                pwsz
                );
            MemFree( pwsz );

        } else {

            fwprintf (
                fpOut,
                L" %S\n",
                (LPSTR) pLdapMod->mod_bvalues[ulValAt]->bv_val
                );

        }

    }

}

VOID
KCCSimStubExport (
    IN  FILE *                      fpOut,
    IN  LDIF_Record *               pLdifRecord
    )
/*++

Routine Description:

    Stub routine to export an LDIF_Record.  This shouldn't be necessary;
    a routine with the same functionality should be a part of ldifldap.
    (As is, this results in a lot of duplicate code.)

Arguments:

    fpOut               - File pointer of the output file.
    pLdifRecord         - The ldif record to export.

Return Value:

    None.

--*/
{
    struct change_list *            changeAt;
    ULONG                           ulModAt;

    fwprintf (
        fpOut,
        L"dn: %s\n",
        pLdifRecord->dn
        );

    if (pLdifRecord->fIsChangeRecord) {

        for (changeAt = pLdifRecord->changes;
             changeAt != NULL;
             changeAt = changeAt->next) {

            switch (changeAt->operation) {

                case CHANGE_ADD:
                    fwprintf (fpOut, L"changetype: add\n");
                    for (ulModAt = 0;
                         changeAt->mods_mem[ulModAt] != NULL;
                         ulModAt++) {
                        KCCSimExportVals (fpOut, changeAt->mods_mem[ulModAt]);
                    }
                    break;

                case CHANGE_DEL:
                    fwprintf (fpOut, L"changetype: delete\n");
                    break;

                case CHANGE_MOD:
                    fwprintf (fpOut, L"changetype: modify\n");
                    for (ulModAt = 0;
                         changeAt->mods_mem[ulModAt] != NULL;
                         ulModAt++) {
                        switch (changeAt->mods_mem[ulModAt]->mod_op & (~LDAP_MOD_BVALUES)) {
                            case LDAP_MOD_ADD:
                                fwprintf (fpOut, L"add");
                                break;
                            case LDAP_MOD_DELETE:
                                fwprintf (fpOut, L"delete");
                                break;
                            case LDAP_MOD_REPLACE:
                                fwprintf (fpOut, L"replace");
                                break;
                            default:
                                Assert (FALSE);
                                break;
                        }
                        fwprintf (fpOut, L": %s\n", changeAt->mods_mem[ulModAt]->mod_type);
                        KCCSimExportVals (fpOut, changeAt->mods_mem[ulModAt]);
                        fwprintf (fpOut, L"-\n");
                    }
                    break;

                default:
                    Assert (FALSE);
                    break;

            }

        }

    } else {    // !fIsChangeRecord

        for (ulModAt = 0;
             pLdifRecord->content[ulModAt] != NULL;
             ulModAt++) {
            KCCSimExportVals (fpOut, pLdifRecord->content[ulModAt]);
        }

    }

    fwprintf (fpOut, L"\n");

}

BOOL
KCCSimExportChanges (
    IN  LPCWSTR                     pwszFn,
    IN  BOOL                        bOverwrite
    )
/*++

Routine Description:

    Exports the global list of changes to the directory.  This function
    also empties the list.

    This function will package the changes into an LDIF_Record before
    exporting; this is done to maintain future compatibility with ldif
    export routines.

Arguments:

    pwszFn              - Filename of the export file.
    bOverwrite          - If TRUE, the file will be overwritten if it exists.
                          If FALSE and the file exists, changes will be
                          appended to the end of the file.

Return Value:

    TRUE if changes were exported.
    FALSE if there were no changes to export.

--*/
{
    FILE *                          fpOut;
    struct _KCCSIM_CHANGE *         pChangeReversed;
    struct _KCCSIM_CHANGE *         pChangeThis;
    struct _KCCSIM_CHANGE *         pChangeLessRecent;

    LDIF_Record                     ldifRecord;
    struct change_list              ldifChange;

    if (gMostRecentChange == NULL) {
        return FALSE;
    }

    fpOut = _wfopen (pwszFn, bOverwrite ? L"wt" : L"a+t");
    if (fpOut == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_WIN32,
            GetLastError ()
            );
    }

    // First we reverse the list of changes.  In the reversed list,
    // pChangeReversed will be the oldest change.
    pChangeThis = gMostRecentChange;
    pChangeReversed = NULL;
    while (pChangeThis != NULL) {
        pChangeLessRecent = pChangeThis->next;
        pChangeThis->next = pChangeReversed;
        pChangeReversed = pChangeThis;
        pChangeThis = pChangeLessRecent;
    }

    // Now package everything into an LDIF_Record
    ldifChange.next = NULL;
    ldifChange.deleteold = 0;
    ldifRecord.fIsChangeRecord = TRUE;
    ldifRecord.changes = &ldifChange;

    for (pChangeThis = pChangeReversed;
         pChangeThis != NULL;
         pChangeThis = pChangeThis->next) {

        ldifRecord.dn = pChangeThis->pwszDn;
        ldifRecord.changes->operation = pChangeThis->operation;
        ldifRecord.changes->mods_mem = pChangeThis->ppLdapMod;
        KCCSimStubExport (
            fpOut,
            &ldifRecord
            );

    }

    KCCSimFreeChanges (pChangeReversed);
    gMostRecentChange = NULL;

    fclose (fpOut);

    return TRUE;
}

BOOL
KCCSimIsAttrOkForConfigOnly (
    IN  PSIM_ATTRIBUTE              pAttr
    )
{
    return (
           pAttr->attrType != ATT_OBJECT_GUID
        && pAttr->attrType != ATT_OBJ_DIST_NAME
        && pAttr->attrType != ATT_WHEN_CREATED
        && pAttr->attrType != ATT_WHEN_CHANGED
        );
}

BOOL
KCCSimIsEntryOkForConfigOnly (
    IN  PSIM_ENTRY                  pEntry
    )
{
    SIM_ATTREF                      attRef;
    ATTRTYP                         attrType;

    // In config-only mode, we only export certain object classes.
    if (!KCCSimGetAttribute (pEntry, ATT_OBJECT_CLASS, &attRef)) {
        return FALSE;
    }
    // Get the most specific object class.
    attrType = KCCSimUpdateObjClassAttr (&attRef);

    // Object classes that we always include:
    if (attrType == CLASS_SITE               ||
        attrType == CLASS_NTDS_SITE_SETTINGS ||
        attrType == CLASS_SERVERS_CONTAINER  ||
        attrType == CLASS_SERVER             ||
        attrType == CLASS_NTDS_DSA           ||
        attrType == CLASS_NTDS_CONNECTION    ||
        attrType == CLASS_SITE_LINK
        ) {
        return TRUE;
    }

    // Object classes that we sometimes include:

    if (attrType == CLASS_CROSS_REF &&
        KCCSimGetAttribute (pEntry, ATT_SYSTEM_FLAGS, &attRef) &&
        (*((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal) & FLAG_CR_NTDS_DOMAIN)
        ) {
        // It's a cross-ref object for a domain.
        return TRUE;
    }

    // Reject everything else.
    return FALSE;
}

VOID
KCCSimRecursiveExport (
    IN  FILE *                      fpOut,
    IN  BOOL                        bExportConfigOnly,
    IN  PSIM_ENTRY                  pEntry
    )
/*++

Routine Description:

    Recursively exports the entire directory.

Arguments:

    fpOut               - File pointer of the output file.
    bExportConfigOnly   - TRUE if we should only export configuration
                          data so that the result can be loaded onto
                          a real server later.
    pEntry              - The entry to start at.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pChildAt;
    PSIM_ATTRIBUTE                  pAttr;
    PSIM_VALUE                      pVal;
    SIM_ATTREF                      attRef;
    ULONG                           ulNumAttrs, ulNumVals, ulAttrAt, ulValAt;

    ATTRTYP                         objClassToUse;

    LDIF_Record                     ldifRecord;

    if (!bExportConfigOnly ||
        KCCSimIsEntryOkForConfigOnly (pEntry)) {

        // First we export this entry.

        ldifRecord.dn = pEntry->pdn->StringName;
        ldifRecord.fIsChangeRecord = FALSE;

        // Count the number of attributes.
        ulNumAttrs = 0;
        for (pAttr = pEntry->pAttrFirst;
             pAttr != NULL;
             pAttr = pAttr->next) {
            if (!bExportConfigOnly ||
                KCCSimIsAttrOkForConfigOnly (pAttr)) {
                ulNumAttrs++;
            }
        }
        ldifRecord.content = KCCSIM_NEW_ARRAY (PLDAPModW, 1 + ulNumAttrs);

        ulAttrAt = 0;
        for (pAttr = pEntry->pAttrFirst;
             pAttr != NULL;
             pAttr = pAttr->next) {

            if (bExportConfigOnly &&
                !KCCSimIsAttrOkForConfigOnly (pAttr)) {
                continue;
            }

            Assert (ulAttrAt < ulNumAttrs);
            ldifRecord.content[ulAttrAt] = KCCSIM_NEW (LDAPModW);
            ldifRecord.content[ulAttrAt]->mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
            ldifRecord.content[ulAttrAt]->mod_type =
                KCCSIM_WCSDUP (KCCSimAttrTypeToString (pAttr->attrType));
        
            // Count the number of attribute values.
            if (pAttr->attrType == ATT_OBJECT_CLASS) {
                ulNumVals = 1;
            } else {
                ulNumVals = 0;
                for (pVal = pAttr->pValFirst;
                     pVal != NULL;
                     pVal = pVal->next) {
                    ulNumVals++;
                }
            }
            ldifRecord.content[ulAttrAt]->mod_bvalues =
                KCCSIM_NEW_ARRAY (struct berval *, 1 + ulNumVals);

            if (pAttr->attrType == ATT_OBJECT_CLASS) {

                // Get the most specific object class.
                attRef.pEntry = pEntry;
                attRef.pAttr = pAttr;
                objClassToUse = KCCSimUpdateObjClassAttr (&attRef);
                ldifRecord.content[ulAttrAt]->mod_bvalues[0] =
                    KCCSIM_NEW (struct berval);
                KCCSimAllocConvertToLdapVal (
                    ATT_OBJECT_CLASS,
                    sizeof (ATTRTYP),
                    (PBYTE) &objClassToUse,
                    &(ldifRecord.content[ulAttrAt]->mod_bvalues[0]->bv_len),
                    &(ldifRecord.content[ulAttrAt]->mod_bvalues[0]->bv_val)
                    );

            } else {

                ulValAt = 0;
                for (pVal = pAttr->pValFirst;
                     pVal != NULL;
                     pVal = pVal->next) {

                    Assert (ulValAt < ulNumVals);
                    ldifRecord.content[ulAttrAt]->mod_bvalues[ulValAt] =
                        KCCSIM_NEW (struct berval);
                    KCCSimAllocConvertToLdapVal (
                        pAttr->attrType,
                        pVal->ulLen,
                        pVal->pVal,
                        &(ldifRecord.content[ulAttrAt]->mod_bvalues[ulValAt]->bv_len),
                        &(ldifRecord.content[ulAttrAt]->mod_bvalues[ulValAt]->bv_val)
                        );
                    ulValAt++;

                }
                Assert (ulValAt == ulNumVals);
        
            }

            ldifRecord.content[ulAttrAt]->mod_bvalues[ulNumVals] = NULL;
            ulAttrAt++;

        }
        Assert (ulAttrAt == ulNumAttrs);
    
        ldifRecord.content[ulNumAttrs] = NULL;

        KCCSimStubExport (fpOut, &ldifRecord);
        KCCSimFreeLdapMods (ldifRecord.content);

    }

    // Recursively export this entry's children.
    for (pChildAt = pEntry->children;
         pChildAt != NULL;
         pChildAt = pChildAt->next) {

        KCCSimRecursiveExport (fpOut, bExportConfigOnly, pChildAt);

    }
}

VOID
KCCSimExportWholeDirectory (
    IN  LPCWSTR                     pwszFn,
    IN  BOOL                        bExportConfigOnly
    )
/*++

Routine Description:

    Exports the entire directory.

Arguments:

    pwszFn              - Filename of the output file.
    bExportConfigOnly   - TRUE if we should only export configuration
                          data so that the result can be loaded onto
                          a real server later.

Return Value:

    None.

--*/
{
    FILE *                          fpOut;
    PSIM_ENTRY                      pStartEntry;

    fpOut = _wfopen (pwszFn, L"wt");
    if (fpOut == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_WIN32,
            GetLastError ()
            );
    }

    __try {
        pStartEntry = KCCSimDsnameToEntry (NULL, KCCSIM_NO_OPTIONS);
        KCCSimRecursiveExport (fpOut, bExportConfigOnly, pStartEntry);
    } __finally {
        fclose (fpOut);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\eval.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    eval.c

ABSTRACT:

    Contains routines for evaluating comparisons
    between attribute values.  Used primarily for
    evaluating filters in searches.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <filtypes.h>
#include "util.h"
#include "dir.h"

/***

    A brief note.

    We cannot simply use the comparison routines in dbsyntax.c.
    The dblayer reformats data before placing it in the database.
    In the simulated directory, we store all of our data in the
    form recognized by the mdlayer (i.e. as a SYNTAX_*.)  Therefore
    the comparison methods differ.  Since there are tons of syntax
    types, only the ones needed by the KCC are emulated here.  If a
    search is called on any others, an exception will be raised.

***/

BOOL
KCCSimIsNullTermA (
    IN  LPCSTR                      psz,
    IN  ULONG                       ulCnt
    )
/*++

Routine Description:

    Checks whether a buffer is a null-terminated string, scanning
    ahead a fixed number of characters.  This function is useful
    for determining whether the contents of a fixed-length buffer
    represent a null-termined string.  Note that we cannot use
    strlen or _strncnt, because if the buffer is not a
    null-terminated string we risk running outside of it.

Arguments:

    psz                 - The string to check.
    ulCnt               - The length of the buffer, in CHARs.

Return Value:

    TRUE if psz is a null-terminated string.

--*/
{
    ULONG                           ul;

    for (ul = 0; ul < ulCnt; ul++) {
        if (psz[ul] == '\0') {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
KCCSimIsNullTermW (
    IN  LPCWSTR                     pwsz,
    IN  ULONG                       ulCnt
    )
/*++

Routine Description:

    Unicode version of KCCSimIsNullTermA.

Arguments:

    pwsz                - The string to check.
    ulCnt               - The length of the buffer, in WCHARs.

Return Value:

    TRUE if pwsz is a null-terminated string.

--*/
{
    ULONG                           ul;

    for (ul = 0; ul < ulCnt; ul++) {
        if (pwsz[ul] == L'\0') {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
KCCSimEvalFromCmp (
    IN  UCHAR                       ucOp,
    IN  INT                         iCmp
    )
/*++

Routine Description:

    This function converts an compare-result integer
    (i.e. returned by wcscmp, memcmp, etc) and determines
    whether it represents a TRUE or FALSE evaluation of
    an expression.

Arguments:

    ucOp                - The compare operation being performed.
    iCmp                - The compare-result integer.

Return Value:

    TRUE if the expression evaluates true.

--*/
{
    switch (ucOp) {

        case FI_CHOICE_PRESENT:
            return TRUE;
            break;

        case FI_CHOICE_EQUALITY:
            return (iCmp == 0);
            break;
        
        case FI_CHOICE_NOT_EQUAL:
            return (iCmp != 0);

        case FI_CHOICE_LESS:
            return (iCmp < 0);
            break;

        case FI_CHOICE_LESS_OR_EQ:
            return (iCmp <= 0);
            break;

        case FI_CHOICE_GREATER_OR_EQ:
            return (iCmp >= 0);
            break;

        case FI_CHOICE_GREATER:
            return (iCmp > 0);
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_INVALID_COMPARE_OPERATION
                );
            return FALSE;
            break;
    }
}

BOOL
KCCSimEvalDistname (
    IN  UCHAR                       ucOp,
    IN  ULONG                       ulLen1,
    IN  const SYNTAX_DISTNAME *     pVal1,
    IN  ULONG                       ulLen2,
    IN  const SYNTAX_DISTNAME *     pVal2
    )
/*++

Routine Description:

    Compares two DISTNAMEs.

Arguments:

    ucOp                - The operation to be performed.
    ulLen1              - Length of the first buffer.
    pVal1               - The first buffer.
    ulLen2              - Length of the second buffer.
    pVal2               - The second buffer.

Return Value:

    TRUE if the DISTNAMEs match.

--*/
{
    if (ulLen1 < sizeof (SYNTAX_DISTNAME) ||
        ulLen1 < pVal1->structLen ||
        ulLen2 < sizeof (SYNTAX_DISTNAME) ||
        ulLen2 < pVal2->structLen) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_INVALID_COMPARE_FORMAT
            );
    }

    switch (ucOp) {

        case FI_CHOICE_PRESENT:
            return TRUE;
            break;

        case FI_CHOICE_EQUALITY:
            return NameMatched (pVal1, pVal2);
            break;

        case FI_CHOICE_NOT_EQUAL:
            return !NameMatched (pVal1, pVal2);
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_INVALID_COMPARE_OPERATION
                );
            return FALSE;
            break;
    }
    
}

BOOL
KCCSimEvalObjectID (
    IN  UCHAR                       ucOp,
    IN  ULONG                       ulLen1,
    IN  const SYNTAX_OBJECT_ID *    pVal1,
    IN  ULONG                       ulLen2,
    IN  const SYNTAX_OBJECT_ID *    pVal2
    )
/*++

Routine Description:

    Compares two OBJECT_IDs.

Arguments:

    ucOp                - The operation to be performed.
    ulLen1              - Length of the first buffer.
    pVal1               - The first buffer.
    ulLen2              - Length of the second buffer.
    pVal2               - The second buffer.

Return Value:

    TRUE if the object IDs match.

--*/
{
    if (ulLen1 != sizeof (SYNTAX_OBJECT_ID) ||
        ulLen2 != sizeof (SYNTAX_OBJECT_ID)) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_INVALID_COMPARE_FORMAT
            );
    }

    return KCCSimEvalFromCmp (ucOp, *pVal2 - *pVal1);
}

BOOL
KCCSimEvalNocaseString (
    IN  UCHAR                       ucOp,
    IN  ULONG                       ulLen1,
    IN  const SYNTAX_NOCASE_STRING *pVal1,
    IN  ULONG                       ulLen2,
    IN  const SYNTAX_NOCASE_STRING *pVal2
    )
/*++

Routine Description:

    Compares two NOCASE_STRINGs.

Arguments:

    ucOp                - The operation to be performed.
    ulLen1              - Length of the first buffer.
    pVal1               - The first buffer.
    ulLen2              - Length of the second buffer.
    pVal2               - The second buffer.

Return Value:

    TRUE if the strings match (not case-sensitive.)

--*/
{
    if (!KCCSimIsNullTermA (pVal1, ulLen1) ||
        !KCCSimIsNullTermA (pVal2, ulLen2)) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_INVALID_COMPARE_FORMAT
            );
    }

    if (ucOp == FI_CHOICE_SUBSTRING) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_UNSUPPORTED_FILITEM_CHOICE
            );
        return FALSE;
    } else {

        return KCCSimEvalFromCmp (ucOp, _stricmp (pVal2, pVal1));

    }
}

BOOL
KCCSimEvalOctetString (
    IN  UCHAR                       ucOp,
    IN  ULONG                       ulLen1,
    IN  const SYNTAX_OCTET_STRING * pVal1,
    IN  ULONG                       ulLen2,
    IN  const SYNTAX_OCTET_STRING * pVal2
    )
/*++

Routine Description:

    Compares two OCTET_STRINGs.

Arguments:

    ucOp                - The operation to be performed.
    ulLen1              - Length of the first buffer.
    pVal1               - The first buffer.
    ulLen2              - Length of the second buffer.
    pVal2               - The second buffer.

Return Value:

    TRUE if the strings match.

--*/
{
    int iCmp;

    if (ucOp == FI_CHOICE_SUBSTRING) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_UNSUPPORTED_FILITEM_CHOICE
            );
        return FALSE;
    } else {

        iCmp = memcmp (pVal2, pVal1, min (ulLen1, ulLen2));
        if (iCmp == 0) {
            iCmp = ulLen2 - ulLen1;
        }

        return KCCSimEvalFromCmp (ucOp, iCmp);

    }
}

BOOL
KCCSimEvalUnicode (
    IN  UCHAR                       ucOp,
    IN  ULONG                       ulLen1,
    IN  const SYNTAX_UNICODE *      pVal1,
    IN  ULONG                       ulLen2,
    IN  const SYNTAX_UNICODE *      pVal2
    )
/*++

Routine Description:

    Compares two UNICODEs.

Arguments:

    ucOp                - The operation to be performed.
    ulLen1              - Length of the first buffer.
    pVal1               - The first buffer.
    ulLen2              - Length of the second buffer.
    pVal2               - The second buffer.

Return Value:

    TRUE if the unicode strings match.

--*/
{
    if (!KCCSimIsNullTermW (pVal1, ulLen1) ||
        !KCCSimIsNullTermW (pVal2, ulLen2)) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_INVALID_COMPARE_FORMAT
            );
    }

    if (ucOp == FI_CHOICE_SUBSTRING) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_UNSUPPORTED_FILITEM_CHOICE
            );
        return FALSE;
    } else {
        return KCCSimEvalFromCmp (ucOp, _wcsicmp (pVal2, pVal1));
    }
}

BOOL
KCCSimCompare (
    IN  ATTRTYP                     attrType,
    IN  UCHAR                       ucOper,
    IN  ULONG                       ulLen1,
    IN  const BYTE *                pVal1,
    IN  ULONG                       ulLen2,
    IN  const BYTE *                pVal2
    )
/*++

Routine Description:

    Compares two attribute values.

Arguments:

    attrType            - The type of the attribute whose values are
                          being compared.
    ucOp                - The operation to be performed.
    ulLen1              - Length of the first buffer.
    pVal1               - The first buffer.
    ulLen2              - Length of the second buffer.
    pVal2               - The second buffer.

Return Value:

    TRUE if the attribute values match.

--*/
{
    ULONG                           ulSyntax;
    BOOL                            bResult;

    ulSyntax = KCCSimAttrSyntaxType (attrType);

    if (ucOper == FI_CHOICE_PRESENT) {
        return TRUE;
    }

    switch (ulSyntax) {

        case SYNTAX_DISTNAME_TYPE:
            return KCCSimEvalDistname (
                ucOper,
                ulLen1,
                (SYNTAX_DISTNAME *) pVal1,
                ulLen2,
                (SYNTAX_DISTNAME *) pVal2
                );
            break;

        case SYNTAX_OBJECT_ID_TYPE:
            return KCCSimEvalObjectID (
                ucOper,
                ulLen1,
                (SYNTAX_OBJECT_ID *) pVal1,
                ulLen2,
                (SYNTAX_OBJECT_ID *) pVal2
                );
            break;

        case SYNTAX_NOCASE_STRING_TYPE:
            return KCCSimEvalNocaseString (
                ucOper,
                ulLen1,
                (SYNTAX_NOCASE_STRING *) pVal1,
                ulLen2,
                (SYNTAX_NOCASE_STRING *) pVal2
                );
            break;

        case SYNTAX_OCTET_STRING_TYPE:
            return KCCSimEvalOctetString (
                ucOper,
                ulLen1,
                (SYNTAX_OCTET_STRING *) pVal1,
                ulLen2,
                (SYNTAX_OCTET_STRING *) pVal2
                );
            break;

        case SYNTAX_UNICODE_TYPE:
            return KCCSimEvalUnicode (
                ucOper,
                ulLen1,
                (SYNTAX_UNICODE *) pVal1,
                ulLen2,
                (SYNTAX_UNICODE *) pVal2
                );
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_SYNTAX_TYPE,
                KCCSimAttrTypeToString (attrType)
                );
            return FALSE;
            break;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\kccsim.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccsim.c

ABSTRACT:

    The body of KCCSim.  This file contains wmain and
    some initialization routines.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <drs.h>
#include <dsutil.h>
#include <attids.h>
#include <filtypes.h>
#include <ntdskcc.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "simtime.h"
#include "ldif.h"
#include "user.h"
#include "state.h"

// Function prototypes - ISM simulation library

VOID SimI_ISMInitialize (VOID);
VOID SimI_ISMTerminate (VOID);

// Function prototypes - LDAP LDIF utilities

#if DBG

VOID InitMem (VOID);
VOID DumpMemoryTracker( VOID );

#endif  // DBG


VOID
KCCSimExpandRDN (
    IO  LPWSTR                      pwszBuf
    )
{
    PSIM_ENTRY                      pEntryServer, pEntryDsa;

    FILTER                          filter;
    ENTINFSEL                       entinfsel;
    SEARCHARG                       searchArg;
    SEARCHRES *                     pSearchRes = NULL;

    if (pwszBuf == NULL || pwszBuf[0] == L'\0') {
        return;
    }

    // If it contains an '=' sign, assume it's a DN, not an RDN
    if (wcschr (pwszBuf, L'=') != NULL) {
        return;
    }

    // The Dir API returns results in thread-alloc'd memory.
    // Initialize the thread state

    KCCSimThreadCreate();

    searchArg.pObject = NULL;
    searchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    searchArg.bOneNC = FALSE;
    searchArg.pFilter = &filter;
    searchArg.searchAliases = FALSE;
    searchArg.pSelection = &entinfsel;
    searchArg.pSelectionRange = NULL;
    InitCommarg (&searchArg.CommArg);
    filter.pNextFilter = NULL;
    filter.choice = FILTER_CHOICE_ITEM;
    filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    filter.FilterTypes.Item.FilTypes.ava.type = ATT_RDN;
    filter.FilterTypes.Item.FilTypes.ava.Value.valLen = KCCSIM_WCSMEMSIZE (pwszBuf);
    filter.FilterTypes.Item.FilTypes.ava.Value.pVal = (PBYTE) pwszBuf;
    filter.FilterTypes.Item.FilTypes.pbSkip = NULL;
    filter.FilterTypes.Item.expectedSize = 0;
    entinfsel.attSel = EN_ATTSET_LIST;
    entinfsel.AttrTypBlock.attrCount = 0;
    entinfsel.AttrTypBlock.pAttr = NULL;
    entinfsel.infoTypes = EN_INFOTYPES_TYPES_ONLY;

    SimDirSearch (&searchArg, &pSearchRes);

    if (pSearchRes->count == 0) {
        return;
        // No entries found.
    }

    pEntryServer = KCCSimDsnameToEntry (
        pSearchRes->FirstEntInf.Entinf.pName, KCCSIM_NO_OPTIONS);
    if (pEntryServer == NULL) {
        return;
    }

    pEntryDsa = KCCSimFindFirstChild (
        pEntryServer, CLASS_NTDS_DSA, NULL);
    if (pEntryDsa == NULL) {
        return;
    }

    // pwszBuf size is hardcoded at 1024. Good enough for
    // this simulator for now.
    if (pEntryDsa->pdn->NameLen >= 1024) {
        Assert(pEntryDsa->pdn->NameLen < 1024);
        return;
    }

    // We've finally found it.
    wcsncpy (
        pwszBuf,
        pEntryDsa->pdn->StringName,
        pEntryDsa->pdn->NameLen
        );
    // ensure string is terminated
    pwszBuf[pEntryDsa->pdn->NameLen] = '\0';

    KCCSimThreadDestroy();
}

VOID
KCCSimSyntaxError (
    IN  BOOL                        bIsScript,
    IN  LPCWSTR                     pwszBuf,
    IN  ULONG                       ulLineAt
    )
/*++

Routine Description:

    Notifies the user of a syntax error.

Arguments:

    bIsScript           - TRUE if the command was found in a script;
                          FALSE if it was entered on the command line.
    pwszBuf             - The erroneous command.
    ulLineAt            - The line in the script where this error occurred.

Return Value:

    None.

--*/
{
    WCHAR                           wszLineBuf[6];

    if (pwszBuf == NULL) {
        return;
    }

    if (bIsScript) {

        swprintf (wszLineBuf, L"%.5u", ulLineAt);
        KCCSimPrintMessage (
            KCCSIM_MSG_SYNTAX_ERROR_LINE,
            pwszBuf,
            wszLineBuf
            );

    } else {

        KCCSimPrintMessage (
            KCCSIM_MSG_SYNTAX_ERROR,
            pwszBuf
            );

    }
}

#define DO_SYNTAX_ERROR \
        KCCSimSyntaxError (fpScript != stdin, wszCommand, ulLineAt)

VOID
KCCSimRunKccAll (
    VOID
    )
/*++

Routine Description:

    Runs the KCC iteratively as each server in the enterprise.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG                           ulNumServers, ul;
    PSIM_ENTRY *                    apEntryNTDSSettings = NULL;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];

    __try {

        KCCSimAllocGetAllServers (&ulNumServers, &apEntryNTDSSettings);

        for (ul = 0; ul < ulNumServers; ul++) {
            KCCSimBuildAnchor (apEntryNTDSSettings[ul]->pdn->StringName);
            KCCSimPrintMessage (
                KCCSIM_MSG_RUNNING_KCC,
                KCCSimQuickRDNBackOf
                    (apEntryNTDSSettings[ul]->pdn, 1, wszRDN)
                );
            KCCSimRunKcc ();
            KCCSimPrintMessage (
                KCCSIM_MSG_DID_RUN_KCC,
                wszRDN
                );
        }

    } __finally {

        KCCSimFree (apEntryNTDSSettings);

    }
}

VOID
KCCSimRun (
    FILE *                          fpScript
    )
/*++

Routine Description:

    Runs KCCSim.

Arguments:

    fpScript            - The stream where we get command input.  This may
                          be stdin.

Return Value:

    None.

--*/
{
    WCHAR                           wszCommand[1024],
                                    wszArg0[1024],
                                    wszArg1[1024],
                                    wszArg2[1024],
                                    wszArg3[1024],
                                    wszArg4[1024],
                                    wszArg5[1024];
    BOOL                            bQuit, bUpdated;
    ULONG                           ulLineAt;
    PDSNAME                         pdn1 = NULL,
                                    pdn2 = NULL,
                                    pdn3 = NULL;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];

    DWORD                           dwErrorType, dwErrorCode;

    CHAR                            szTimeBuf[1+SZDSTIME_LEN];
    WCHAR                           wszLtowBuf1[1+KCCSIM_MAX_LTOA_CHARS],
                                    wszLtowBuf2[1+KCCSIM_MAX_LTOA_CHARS];
    ULONG                           ul1, ul2;

    bQuit = FALSE;
    bUpdated = FALSE;
    ulLineAt = 0;

    // By default, always display level 0 debug messages and level 1 events
    // to the console
    KCCSimSetDebugLog (L"stdout", 0, 1);

    while (!bQuit) {

        __try {

            if (fpScript == stdin) {
                printf (
                    "\n\nSimulated Time: %s\n",
                    DSTimeToDisplayString (SimGetSecondsSince1601 (), szTimeBuf)
                    );
                printf (
                    "   Actual Time: %s\n",
                    DSTimeToDisplayString (KCCSimGetRealTime (), szTimeBuf)
                    );
                wprintf (L"\n> ");
            }

            if (fgetws (wszCommand, 1023, fpScript) == NULL) {
                // Must be an end-of-file.  Switch to user mode.
                fpScript = stdin;
                continue;
            }
            ulLineAt++;
            // Kill the trailing '\n'
            wszCommand[wcslen (wszCommand) - 1] = L'\0';

            if (wszCommand[0] == L'\0') {
                continue;
            }

            if (fpScript == stdin) {
                wprintf (L"\n");
            }

            if (!KCCSimParseCommand (wszCommand, 0, wszArg0) ||
                !KCCSimParseCommand (wszCommand, 1, wszArg1) ||
                !KCCSimParseCommand (wszCommand, 2, wszArg2) ||
                !KCCSimParseCommand (wszCommand, 3, wszArg3) ||
                !KCCSimParseCommand (wszCommand, 4, wszArg4) ||
                !KCCSimParseCommand (wszCommand, 5, wszArg5)) {
                DO_SYNTAX_ERROR;
                continue;
            }

            switch (towlower (wszArg0[0])) {

                case ';':
                    break;

                // Compare the simulated directory to one represented by an
                // ldif file
                case L'c':
                    if (wszArg1[0] == L'\0') {
                        DO_SYNTAX_ERROR;
                        break;
                    }
                    KCCSimCompareDirectory (wszArg1);
                    break;

                // Display information about the simulated environment
                case L'd':
                    if (!bUpdated) {
                        KCCSimUpdateWholeDirectory ();
                        bUpdated = TRUE;
                        KCCSimPrintMessage (KCCSIM_MSG_DID_INITIALIZE_DIRECTORY);
                    }
                    switch (towlower (wszArg0[1])) {
                        case L'c':  // Configuration information
                            KCCSimDisplayConfigInfo ();
                            break;
                        case L'g':  // Graph Information
                            KCCSimDisplayGraphInfo ();
                            break;
                        case L'd':  // Directory dump
                            KCCSimDumpDirectory (wszArg1);
                            break;
                        case L's':  // Server info
                            if (wszArg1[0] == L'\0') {
                                DO_SYNTAX_ERROR;
                                break;
                            }
                            KCCSimExpandRDN (wszArg1);
                            KCCSimBuildAnchor (wszArg1);
                            KCCSimDisplayServer ();
                            break;
                        default:
                            DO_SYNTAX_ERROR;
                            break;
                    }
                    break;

                // Load part of the directory from an ldif or ini file
                case L'l':
                    if (wszArg1[0] == L'\0') {
                        DO_SYNTAX_ERROR;
                        break;
                    }
                    switch (towlower (wszArg0[1])) {
                        case L'i':  // Load an ini file
                            bUpdated = FALSE;
                            __try {
                                BuildCfg (wszArg1);
                            } __finally {
                                // This is to avoid loading PART of an INI
                                // file, which could cause problems.  If an
                                // exception occurs we reinitialize everything
                                if (AbnormalTermination ()) {
                                    KCCSimInitializeDir ();
                                }
                            }
                            KCCSimPrintMessage (
                                KCCSIM_MSG_DID_LOAD_INPUT_FILE,
                                wszArg1
                                );
                            break;
                        case L'l':  // Load an ldif file
                            bUpdated = FALSE;
                            KCCSimLoadLdif (wszArg1);
                            KCCSimPrintMessage (
                                KCCSIM_MSG_DID_LOAD_INPUT_FILE,
                                wszArg1
                                );
                            break;
                        default:
                            DO_SYNTAX_ERROR;
                            break;
                    }
                    break;

                // Open a debug log
                case L'o':
                    ul1 = wcstoul (wszArg2, NULL, 0);    // Will default to 0
                    ul2 = wcstoul (wszArg3, NULL, 0);    // Will default to 0
                    KCCSimSetDebugLog (wszArg1, ul1, ul2);
                    KCCSimPrintMessage (
                        KCCSIM_MSG_DID_OPEN_DEBUG_LOG,
                        wszArg1,
                        _ultow (ul1, wszLtowBuf1, 10),
                        _ultow (ul2, wszLtowBuf2, 10)
                        );
                    break;

                // Quit
                case L'q':
#if DBG
                    KCCSimPrintStatistics();
#endif
                    bQuit = TRUE;
                    break;

                // Run the KCC
                case L'r':
                    if (!bUpdated) {
                        KCCSimUpdateWholeDirectory ();
                        bUpdated = TRUE;
                        KCCSimPrintMessage (KCCSIM_MSG_DID_INITIALIZE_DIRECTORY);
                    }
                    if (towlower (wszArg0[1]) == L'r') {    // Run all
                        KCCSimRunKccAll ();
                        break;
                    }
                    if (wszArg1[0] == L'\0') {
                        DO_SYNTAX_ERROR;
                        break;
                    }
                    KCCSimExpandRDN (wszArg1);
                    KCCSimBuildAnchor (wszArg1);
                    KCCSimPrintMessage (
                        KCCSIM_MSG_RUNNING_KCC,
                        KCCSimQuickRDNBackOf (KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN), 1, wszRDN)
                        );
                    KCCSimRunKcc ();
                    KCCSimPrintMessage (
                        KCCSIM_MSG_DID_RUN_KCC,
                        wszRDN
                        );
                    break;

                // Set a server state parameter
                case L's':
                    if (!bUpdated) {
                        KCCSimUpdateWholeDirectory ();
                        bUpdated = TRUE;
                        KCCSimPrintMessage (KCCSIM_MSG_DID_INITIALIZE_DIRECTORY);
                    }
                    switch (towlower (wszArg0[1])) {
                        case 'b':
                            if (wszArg1[0] == L'\0' || wszArg2[0] == L'\0') {
                                DO_SYNTAX_ERROR;
                                break;
                            }
                            KCCSimExpandRDN (wszArg1);
                            pdn1 = KCCSimAllocDsname (wszArg1);
                            ul1 = wcstoul (wszArg2, NULL, 10);
                            if (KCCSimSetBindError (pdn1, ul1)) {
                                KCCSimPrintMessage (
                                    KCCSIM_MSG_DID_SET_BIND_ERROR,
                                    wszArg1,
                                    _ultow (ul1, wszLtowBuf1, 10)
                                    );
                            } else {
                                KCCSimPrintMessage (
                                    KCCSIM_MSG_SERVER_DOES_NOT_EXIST,
                                    wszArg1
                                    );
                            }
                            KCCSimFree (pdn1);
                            pdn1 = NULL;
                            break;
                        case 's':
                            if (wszArg1[0] == L'\0' || wszArg2[0] == L'\0' ||
                                wszArg3[0] == L'\0' || wszArg4[0] == L'\0') {
                                DO_SYNTAX_ERROR;
                                break;
                            }
                            KCCSimExpandRDN (wszArg1);
                            KCCSimExpandRDN (wszArg2);
                            pdn1 = KCCSimAllocDsname (wszArg1);
                            pdn2 = KCCSimAllocDsname (wszArg2);
                            pdn3 = KCCSimAllocDsname (wszArg3);
                            ul1 = wcstoul (wszArg4, NULL, 10);
                            if (wszArg5[0] == L'\0') {
                                ul2 = 1;        // Default
                            } else {
                                ul2 = wcstoul (wszArg5, NULL, 10);
                            }
                            if (KCCSimReportSync (pdn1, pdn3, pdn2, ul1, ul2)) {
                                KCCSimPrintMessage (
                                    KCCSIM_MSG_DID_REPORT_SYNC,
                                    _ultow (ul2, wszLtowBuf2, 10),
                                    _ultow (ul1, wszLtowBuf1, 10),
                                    wszArg1,
                                    wszArg2,
                                    wszArg3
                                    );
                            } else {
                                KCCSimPrintMessage (
                                    KCCSIM_MSG_COULD_NOT_REPORT_SYNC,
                                    wszArg1,
                                    wszArg2,
                                    wszArg3
                                    );
                            }
                            KCCSimFree (pdn1);
                            pdn1 = NULL;
                            KCCSimFree (pdn2);
                            pdn2 = NULL;
                            KCCSimFree (pdn3);
                            pdn3 = NULL;
                            break;
                        default:
                            DO_SYNTAX_ERROR;
                            break;
                    }
                    break;

                // Add seconds to the simulated time
                case L't':
                    if (wszArg1[0] == L'\0') {
                        DO_SYNTAX_ERROR;
                        break;
                    }
                    if (!bUpdated) {
                        KCCSimUpdateWholeDirectory ();
                        bUpdated = TRUE;
                        KCCSimPrintMessage (KCCSIM_MSG_DID_INITIALIZE_DIRECTORY);
                    }
                    ul1 = wcstoul (wszArg1, NULL, 10);
                    KCCSimAddSeconds (ul1);
                    KCCSimPrintMessage (
                        KCCSIM_MSG_DID_ADD_SECONDS,
                        _ultow (ul1, wszLtowBuf1, 10)
                        );
                    break;

                // Write the simulated directory to an ldif file
                case L'w':
                    if (wszArg1[0] == L'\0') {
                        DO_SYNTAX_ERROR;
                        break;
                    }
                    switch (wszArg0[1]) {
                        case 'a':   // Append changes
                            if (KCCSimExportChanges (wszArg1, FALSE)) {
                                KCCSimPrintMessage (
                                    KCCSIM_MSG_DID_APPEND_CHANGES,
                                    wszArg1
                                    );
                            } else {
                                KCCSimPrintMessage (
                                    KCCSIM_MSG_NO_CHANGES_TO_EXPORT
                                    );
                            }
                            break;
                        case 'c':   // Write changes
                            if (KCCSimExportChanges (wszArg1, TRUE)) {
                                KCCSimPrintMessage (
                                    KCCSIM_MSG_DID_EXPORT_CHANGES,
                                    wszArg1
                                    );
                            } else {
                                KCCSimPrintMessage (
                                    KCCSIM_MSG_NO_CHANGES_TO_EXPORT
                                    );
                            }
                            break;
                        case 'w':   // Write whole directory
                            KCCSimExportWholeDirectory (wszArg1, FALSE);
                            KCCSimPrintMessage (
                                KCCSIM_MSG_DID_EXPORT_WHOLE_DIRECTORY,
                                wszArg1
                                );
                            break;
                        case 'x':
                            KCCSimExportWholeDirectory (wszArg1, TRUE);
                            KCCSimPrintMessage (
                                KCCSIM_MSG_DID_EXPORT_IMPORTABLE_DIRECTORY,
                                wszArg1
                                );
                            break;
                        default:
                            DO_SYNTAX_ERROR;
                            break;
                    }
                    break;

                // Help
                case L'h':
                case L'?':
                    KCCSimPrintMessage (KCCSIM_MSG_COMMAND_HELP);
                    break;

                default:
                    DO_SYNTAX_ERROR;
                    break;

            }

        } __except (KCCSimHandleException (
                        GetExceptionInformation (),
                        &dwErrorType,
                        &dwErrorCode)) {

            switch (dwErrorType) {

                case KCCSIM_ETYPE_WIN32:
                    KCCSimPrintMessage (KCCSIM_MSG_ANNOUNCE_WIN32_ERROR);
                    break;

                case KCCSIM_ETYPE_INTERNAL:
                    KCCSimPrintMessage (KCCSIM_MSG_ANNOUNCE_INTERNAL_ERROR);
                    break;

                default:
                    Assert (!L"This type of error should never happen!");
                    break;

            }

            KCCSimPrintExceptionMessage ();

            if (dwErrorType != KCCSIM_ETYPE_INTERNAL) {
                bQuit = TRUE;
            }

        }   // __try/__except

    }       // while (!bQuit)

}

ULONG
__cdecl
wmain (
    INT                             argc,
    LPWSTR *                        argv
    )
/*++

Routine Description:

    Main entrypoint for KCCSim.

Arguments:

    argc                - Number of command line arguments.
    argv                - Command line arguments.

Return Value:

    Win32 error code.

--*/
{
    FILE *                          fpScript;
    INT                             iArgAt;
    BOOL                            bQuit, bQuiet;

    __try {

        // Basic initialization.
        KCCSimInitializeTime ();    // Initialize the simulated time
        KCCSimInitializeSchema ();  // Initialize the schema table
        KCCSimInitializeDir ();     // Initialize the directory

        SimI_ISMInitialize ();      // Initialize the simulated ism functions
        KccInitialize ();           // Initialize the KCC
#if DBG
        InitMem ();                 // Needed by ldifldap
#endif

        fpScript = stdin;
        bQuit = FALSE;
        bQuiet = FALSE;

        for (iArgAt = 1; iArgAt < argc; iArgAt++) {

            if (argv[iArgAt][0] == L'/' || argv[iArgAt][0] == L'-') {
                switch (towlower (argv[iArgAt][1])) {

                    case L'h':
                    case L'?':
                        KCCSimPrintMessage (KCCSIM_MSG_HELP);
                        _getch ();
                        KCCSimPrintMessage (KCCSIM_MSG_COMMAND_HELP);
                        bQuit = TRUE;
                        break;

                    case L'q':
                        bQuiet = TRUE;
                        break;

                    default:
                        break;

                }
            } else if (fpScript == stdin) {

                fpScript = _wfopen (argv[iArgAt], L"rt");
                if (fpScript == NULL) {
                    KCCSimPrintMessage (
                        KCCSIM_MSG_ANNOUNCE_CANT_OPEN_SCRIPT,
                        argv[iArgAt]
                        );
                    wprintf (KCCSimMsgToString (
                        KCCSIM_ETYPE_WIN32,
                        GetLastError ()
                        ));
                    bQuit = TRUE;
                }

            }

        }

    } __except (KCCSimHandleException (
                        GetExceptionInformation (),
                        NULL,
                        NULL)) {

        KCCSimPrintMessage (KCCSIM_MSG_ANNOUNCE_ERROR_INITIALIZING);
        KCCSimPrintExceptionMessage ();
        bQuit = TRUE;

    }

    if (!bQuit) {
        KCCSimQuiet (bQuiet);
        KCCSimRun (fpScript);
    }

    // Terminate the simulated ism functions.
    SimI_ISMTerminate ();

#if DBG
    DumpMemoryTracker(); // Show unused ldif memory
#endif

    // Close any open log file.
    KCCSimSetDebugLog (NULL, 0, 0);

    // Close the script file.
    if (fpScript != stdin) {
        fclose (fpScript);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\kccsim.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccsim.h

ABSTRACT:

    Main header file for KCCSim.  This replaces all "real" functions
    that KCCSim simulated with their simulated counterparts.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#ifndef _KCCSIM_H_
#define _KCCSIM_H_

// We need these includes to prototype the simulated functions.
#include <lsarpc.h>
#include <ismapi.h>

//
// This header file is full of expressions that are always false. These
// expressions manifest themselves in macros that take unsigned values
// and make tests, for example, of greater than or equal to zero.
//
// Turn off these warnings until the authors can fix this code.
//

#pragma warning(disable:4296)

//
// Memory Allocation Functions
#define THAlloc                             KCCSimThreadAlloc
#define THReAlloc                           KCCSimThreadReAlloc
#define THFree                              KCCSimThreadFree
#undef  THAllocEx
#define THAllocEx(pTHS,ulSize)              KCCSimThreadAlloc(ulSize)
#define THCreate( type )                    KCCSimThreadCreate();
#define THDestroy()                         KCCSimThreadDestroy();

// Simulated LSA Functions
#define LsaIQueryInformationPolicyTrusted   SimLsaIQueryInformationPolicyTrusted
#define LsaIFree_LSAPR_POLICY_INFORMATION   SimLsaIFree_LSAPR_POLICY_INFORMATION

// Simulated ISM Functions
#define I_ISMGetTransportServers            KCCSimI_ISMGetTransportServers
#define I_ISMGetConnectionSchedule          KCCSimI_ISMGetConnectionSchedule
#define I_ISMGetConnectivity                KCCSimI_ISMGetConnectivity
#define I_ISMFree                           KCCSimI_ISMFree

// Simulated DS Client Functions
#define DsReplicaGetInfoW                   SimDsReplicaGetInfoW
#define DsReplicaFreeInfo                   SimDsReplicaFreeInfo
#define DsBindW                             SimDsBindW
#define DsUnBindW                           SimDsUnBindW

// Simulated Directory Service Functions
#define GetSecondsSince1601                 SimGetSecondsSince1601
#define GuidBasedDNSNameFromDSName          SimGuidBasedDNSNameFromDSName
#define DsGetDefaultObjCategory             SimDsGetDefaultObjCategory
#define GetConfigurationName                SimGetConfigurationName
#define DirRead                             SimDirRead
#define DirSearch                           SimDirSearch
#define DirAddEntry                         SimDirAddEntry
#define DirRemoveEntry                      SimDirRemoveEntry
#define DirModifyEntry                      SimDirModifyEntry
#define MtxAddrFromTransportAddr            SimMtxAddrFromTransportAddr
#define TransportAddrFromMtxAddr            SimTransportAddrFromMtxAddr
#define DirReplicaAdd                       SimDirReplicaAdd
#define DirReplicaDelete                    SimDirReplicaDelete
#define DirReplicaGetDemoteTarget           SimDirReplicaGetDemoteTarget
#define DirReplicaDemote                    SimDirReplicaDemote
#define DirReplicaModify                    SimDirReplicaModify
#define DirReplicaReferenceUpdate           SimDirReplicaReferenceUpdate
#define DSNAMEToMappedStrExternal(x)        SimDSNAMEToMappedStrExternal(x,FALSE)

// Debug Overrides
#undef  DPRINT
#define DPRINT(n,s)                 KCCSimDbgLog (n, s)
#undef  DPRINT1
#define DPRINT1(n,s,x)              KCCSimDbgLog (n, s, x)
#undef  DPRINT2
#define DPRINT2(n,s,x,y)            KCCSimDbgLog (n, s, x, y)
#undef  DPRINT3
#define DPRINT3(n,s,x,y,z)          KCCSimDbgLog (n, s, x, y, z)
#undef  DPRINT4
#define DPRINT4(n,s,x,y,z,w)        KCCSimDbgLog (n, s, x, y, z, w)

// Log Event Overrides
// Note that this catches all events logged with LogEvent and LogEvent8. It does
// not catch LogEvent8WithData. This is rarely used by the KCC at present.
#undef LogEvent8
#define LogEvent8(cat, sev, msg, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) \
    KCCSimEventLog( cat, sev, msg, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL ); \
    LogEvent8WithData(cat, sev, msg, arg1, arg2, arg3, arg4, arg5, \
                      arg6, arg7, arg8, 0, NULL)



// Utilities

LPVOID
KCCSimAlloc (
    IN  ULONG                       ulSize
    );

LPVOID
KCCSimReAlloc (
    IN  LPVOID                      pOld,
    IN  ULONG                       ulSize
    );

VOID
KCCSimFree (
    IN  LPVOID                      p
    );

VOID
KCCSimDbgLog (
    IN  ULONG                       ulLevel,
    IN  LPCSTR                      pszFormat,
    ...
    );

VOID
KCCSimEventLog (
    IN  ULONG                       ulCategory,
    IN  ULONG                       ulSeverity,
    IN  DWORD                       dwMessageId,
    ...
    );

LPVOID
KCCSimThreadAlloc (
    IN  ULONG                       ulSize
    );

LPVOID
KCCSimThreadReAlloc (
    IN  LPVOID                      pOld,
    IN  ULONG                       ulSize
    );

VOID
KCCSimThreadFree (
    IN  LPVOID                      p
    );

DWORD
KCCSimThreadCreate (
    void
    );

VOID
KCCSimThreadDestroy (
    void
    );

// Function prototypes - LSA

NTSTATUS NTAPI
SimLsaIQueryInformationPolicyTrusted (
    IN  POLICY_INFORMATION_CLASS    InformationClass,
    OUT PLSAPR_POLICY_INFORMATION   *Buffer
    );

VOID NTAPI
SimLsaIFree_LSAPR_POLICY_INFORMATION (
    IN  POLICY_INFORMATION_CLASS    InformationClass,
    IN  PLSAPR_POLICY_INFORMATION   PolicyInformation
    );

// Function prototypes - KCCSIM wrappers of simulated ISM functions

DWORD
KCCSimI_ISMGetTransportServers (
    IN  HANDLE                      hIsm,
    IN  LPCWSTR                     pszSiteDN,
    OUT ISM_SERVER_LIST **          ppServerList
    );

DWORD
KCCSimI_ISMGetConnectionSchedule (
    IN  HANDLE                      hIsm,
    IN  LPCWSTR                     pszSite1DN,
    IN  LPCWSTR                     pszSite2DN,
    OUT ISM_SCHEDULE **             ppSchedule
    );

DWORD
KCCSimI_ISMGetConnectivity (
    IN  LPCWSTR                     pszTransportDN,
    OUT ISM_CONNECTIVITY **         ppConnectivity
    );

DWORD
KCCSimI_ISMFree (
    IN  VOID *                      pv
    );

// Function Prototypes - NTDSAPI

DWORD
WINAPI
SimDsReplicaGetInfoW (
    HANDLE                          hDs,
    DS_REPL_INFO_TYPE               InfoType,
    LPCWSTR                         pszObject,
    UUID *                          puuidForSourceDsaObjGuid,
    VOID **                         ppInfo
    );

void
WINAPI
SimDsReplicaFreeInfo (
    DS_REPL_INFO_TYPE               InfoType,
    VOID *                          pInfo
    );

DWORD
WINAPI
SimDsBindW (
    LPCWSTR                         DomainControllerName,
    LPCWSTR                         DnsDomainName,
    HANDLE *                        phDS
    );

DWORD
WINAPI
SimDsUnBindW (
    HANDLE *                        phDS
    );

// Function Prototypes - NTDSA

DSTIME
SimGetSecondsSince1601 (
    VOID
    );

LPWSTR
SimGuidBasedDNSNameFromDSName (
    PDSNAME                         pdnServer
    );

PDSNAME
SimDsGetDefaultObjCategory (
    ATTRTYP                         attrTyp
    );

NTSTATUS
SimGetConfigurationName (
    DWORD                           which,
    DWORD *                         pcbName,
    DSNAME *                        pName
    );

ULONG
SimDirRead (
    READARG FAR *                   pReadArg,
    READRES **                      ppReadRes
    );

ULONG
SimDirSearch (
    SEARCHARG *                     pSearchArg,
    SEARCHRES **                    ppSearchRes
    );

ULONG
SimDirAddEntry (
    ADDARG *                        pAddArg,
    ADDRES **                       ppAddRes
    );

ULONG
SimDirRemoveEntry (
    REMOVEARG *                     pRemoveArg,
    REMOVERES **                    ppRemoveRes
    );

ULONG
SimDirModifyEntry (
    MODIFYARG *                     pModifyArg,
    MODIFYRES **                    ppModifyRes
    );

MTX_ADDR *
SimMtxAddrFromTransportAddr (
    IN  LPWSTR                      psz
    );

LPWSTR
SimTransportAddrFromMtxAddr (
    MTX_ADDR *                      pMtxAddr
    );

ULONG
SimDirReplicaAdd (
    IN  PDSNAME                     pdnNC,
    IN  PDSNAME                     pdnSourceDsa,
    IN  PDSNAME                     pdnTransport,
    IN  LPWSTR                      pwszSourceDsaAddress,
    IN  LPWSTR                      pwszSourceDsaDnsDomainName,
    IN  REPLTIMES *                 preptimesSync,
    IN  ULONG                       ulOptions
    );

ULONG
SimDirReplicaDelete (
    IN  PDSNAME                     pdnNC,
    IN  LPWSTR                      pwszSourceDRA,
    IN  ULONG                       ulOptions
    );

struct _DRS_DEMOTE_TARGET_SEARCH_INFO;
ULONG
SimDirReplicaGetDemoteTarget(
    IN      DSNAME *                                pNC,
    IN OUT  struct _DRS_DEMOTE_TARGET_SEARCH_INFO * pDSTInfo,
    OUT     LPWSTR *                                ppszDemoteTargetDNSName,
    OUT     DSNAME **                               ppDemoteTargetDSADN
    );

ULONG
SimDirReplicaDemote(
    IN  DSNAME *                    pNC,
    IN  LPWSTR                      pszOtherDSADNSName,
    IN  DSNAME *                    pOtherDSADN,
    IN  ULONG                       ulOptions
    );

ULONG
SimDirReplicaModify (
    IN  PDSNAME                     pNC,
    IN  UUID *                      puuidSourceDRA,
    IN  UUID *                      puuidTransportObj,
    IN  LPWSTR                      pszSourceDRA,
    IN  REPLTIMES *                 prtSchedule,
    IN  ULONG                       ulReplicaFlags,
    IN  ULONG                       ulModifyFields,
    IN  ULONG                       ulOptions
    );

ULONG
SimDirReplicaReferenceUpdate(
    DSNAME *    pNC,
    LPWSTR      pszRepsToDRA,
    UUID *      puuidRepsToDRA,
    ULONG       ulOptions
    );

LPSTR
SimDSNAMEToMappedStrExternal(
    IN DSNAME *pName,
    IN OPTIONAL BOOLEAN fUseNormalAllocator
    );

VOID
SimDirFreeSearchRes(
    IN SEARCHRES *pSearchRes
    );

VOID
SimDirFreeReadRes(
    IN READRES *pReadRes
    );

#endif // _KCCSIM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\ldif.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ldif.h

ABSTRACT:

    Header file for ldif.c.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

VOID
KCCSimLogDirectoryAdd (
    IN  const DSNAME *              pdn,
    IN  ATTRBLOCK *                 pAddBlock
    );

VOID
KCCSimLogDirectoryRemove (
    IN  const DSNAME *              pdn
    );

VOID
KCCSimLogDirectoryModify (
    IN  const DSNAME *              pdn,
    IN  ULONG                       ulCount,
    IN  ATTRMODLIST *               pModifyList
    );

VOID
KCCSimLogSingleAttValChange (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  const BYTE *                pValData,
    IN  USHORT                      choice
    );

VOID
KCCSimLoadLdif (
    IN  LPCWSTR                     pwszFn
    );

BOOL
KCCSimExportChanges (
    IN  LPCWSTR                     pwszFn,
    IN  BOOL                        bOverwrite
    );

VOID
KCCSimExportWholeDirectory (
    IN  LPCWSTR                     pwszFn,
    IN  BOOL                        bExportConfigOnly
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\runkcc.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    runkcc.cxx

ABSTRACT:

    C++ file to drive the KCC.  The exposed (extern "C") function
    is prototyped in user.h.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#pragma hdrstop

extern "C" {
#include <drs.h>
#include <ntdskcc.h>
#include "user.h"
#include "simtime.h"
}
#include <kcc.hxx>
#include <kcctask.hxx>
#include <kccconn.hxx>
#include <kcctopl.hxx>

class KCC_TASK_URT_WRAPPER : public KCC_TASK_UPDATE_REPL_TOPOLOGY
{
public:
    VOID
    CallTaskExecute (PDWORD pDw);
};

VOID
KCC_TASK_URT_WRAPPER::CallTaskExecute (
    IN  PDWORD                      pDw
    )
{
    Execute (pDw);
}

extern "C"
VOID
KCCSimRunKcc (
    VOID
    )
{
    KCC_TASK_URT_WRAPPER            kccWrap;
    DWORD                           dw;

    KCCSimStartTicking ();
    kccWrap.CallTaskExecute (&dw);
    KCCSimStopTicking ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\schmap.c ===
/*++

Copyright (c) 2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    schmap.c

ABSTRACT:

    This file was automatically generated by schtable.exe.

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <attids.h>
#include "schmap.h"

// Define symbols missing from attids.h
#define ATT_ENTRY_TTL 0xffffffff
#define CLASS_DYNAMIC_OBJECT 0xffffffff

const struct _SCHTABLE_MAPPING          schTable[] = {

    { L"accountExpires"                            , ATT_ACCOUNT_EXPIRES                          , SYNTAX_I8_TYPE                    , L"Account-Expires"                           , 0                                             },
    { L"accountNameHistory"                        , ATT_ACCOUNT_NAME_HISTORY                     , SYNTAX_UNICODE_TYPE               , L"Account-Name-History"                      , 0                                             },
    { L"aCSAggregateTokenRatePerUser"              , ATT_ACS_AGGREGATE_TOKEN_RATE_PER_USER        , SYNTAX_I8_TYPE                    , L"ACS-Aggregate-Token-Rate-Per-User"         , 0                                             },
    { L"aCSAllocableRSVPBandwidth"                 , ATT_ACS_ALLOCABLE_RSVP_BANDWIDTH             , SYNTAX_I8_TYPE                    , L"ACS-Allocable-RSVP-Bandwidth"              , 0                                             },
    { L"aCSCacheTimeout"                           , ATT_ACS_CACHE_TIMEOUT                        , SYNTAX_INTEGER_TYPE               , L"ACS-Cache-Timeout"                         , 0                                             },
    { L"aCSDirection"                              , ATT_ACS_DIRECTION                            , SYNTAX_INTEGER_TYPE               , L"ACS-Direction"                             , 0                                             },
    { L"aCSDSBMDeadTime"                           , ATT_ACS_DSBM_DEADTIME                        , SYNTAX_INTEGER_TYPE               , L"ACS-DSBM-DeadTime"                         , 0                                             },
    { L"aCSDSBMPriority"                           , ATT_ACS_DSBM_PRIORITY                        , SYNTAX_INTEGER_TYPE               , L"ACS-DSBM-Priority"                         , 0                                             },
    { L"aCSDSBMRefresh"                            , ATT_ACS_DSBM_REFRESH                         , SYNTAX_INTEGER_TYPE               , L"ACS-DSBM-Refresh"                          , 0                                             },
    { L"aCSEnableACSService"                       , ATT_ACS_ENABLE_ACS_SERVICE                   , SYNTAX_BOOLEAN_TYPE               , L"ACS-Enable-ACS-Service"                    , 0                                             },
    { L"aCSEnableRSVPAccounting"                   , ATT_ACS_ENABLE_RSVP_ACCOUNTING               , SYNTAX_BOOLEAN_TYPE               , L"ACS-Enable-RSVP-Accounting"                , 0                                             },
    { L"aCSEnableRSVPMessageLogging"               , ATT_ACS_ENABLE_RSVP_MESSAGE_LOGGING          , SYNTAX_BOOLEAN_TYPE               , L"ACS-Enable-RSVP-Message-Logging"           , 0                                             },
    { L"aCSEventLogLevel"                          , ATT_ACS_EVENT_LOG_LEVEL                      , SYNTAX_INTEGER_TYPE               , L"ACS-Event-Log-Level"                       , 0                                             },
    { L"aCSIdentityName"                           , ATT_ACS_IDENTITY_NAME                        , SYNTAX_UNICODE_TYPE               , L"ACS-Identity-Name"                         , 0                                             },
    { L"aCSMaxAggregatePeakRatePerUser"            , ATT_ACS_MAX_AGGREGATE_PEAK_RATE_PER_USER     , SYNTAX_I8_TYPE                    , L"ACS-Max-Aggregate-Peak-Rate-Per-User"      , 0                                             },
    { L"aCSMaxDurationPerFlow"                     , ATT_ACS_MAX_DURATION_PER_FLOW                , SYNTAX_INTEGER_TYPE               , L"ACS-Max-Duration-Per-Flow"                 , 0                                             },
    { L"aCSMaxNoOfAccountFiles"                    , ATT_ACS_MAX_NO_OF_ACCOUNT_FILES              , SYNTAX_INTEGER_TYPE               , L"ACS-Max-No-Of-Account-Files"               , 0                                             },
    { L"aCSMaxNoOfLogFiles"                        , ATT_ACS_MAX_NO_OF_LOG_FILES                  , SYNTAX_INTEGER_TYPE               , L"ACS-Max-No-Of-Log-Files"                   , 0                                             },
    { L"aCSMaxPeakBandwidth"                       , ATT_ACS_MAX_PEAK_BANDWIDTH                   , SYNTAX_I8_TYPE                    , L"ACS-Max-Peak-Bandwidth"                    , 0                                             },
    { L"aCSMaxPeakBandwidthPerFlow"                , ATT_ACS_MAX_PEAK_BANDWIDTH_PER_FLOW          , SYNTAX_I8_TYPE                    , L"ACS-Max-Peak-Bandwidth-Per-Flow"           , 0                                             },
    { L"aCSMaxSizeOfRSVPAccountFile"               , ATT_ACS_MAX_SIZE_OF_RSVP_ACCOUNT_FILE        , SYNTAX_INTEGER_TYPE               , L"ACS-Max-Size-Of-RSVP-Account-File"         , 0                                             },
    { L"aCSMaxSizeOfRSVPLogFile"                   , ATT_ACS_MAX_SIZE_OF_RSVP_LOG_FILE            , SYNTAX_INTEGER_TYPE               , L"ACS-Max-Size-Of-RSVP-Log-File"             , 0                                             },
    { L"aCSMaxTokenBucketPerFlow"                  , ATT_ACS_MAX_TOKEN_BUCKET_PER_FLOW            , SYNTAX_I8_TYPE                    , L"ACS-Max-Token-Bucket-Per-Flow"             , 0                                             },
    { L"aCSMaxTokenRatePerFlow"                    , ATT_ACS_MAX_TOKEN_RATE_PER_FLOW              , SYNTAX_I8_TYPE                    , L"ACS-Max-Token-Rate-Per-Flow"               , 0                                             },
    { L"aCSMaximumSDUSize"                         , ATT_ACS_MAXIMUM_SDU_SIZE                     , SYNTAX_I8_TYPE                    , L"ACS-Maximum-SDU-Size"                      , 0                                             },
    { L"aCSMinimumDelayVariation"                  , ATT_ACS_MINIMUM_DELAY_VARIATION              , SYNTAX_I8_TYPE                    , L"ACS-Minimum-Delay-Variation"               , 0                                             },
    { L"aCSMinimumLatency"                         , ATT_ACS_MINIMUM_LATENCY                      , SYNTAX_I8_TYPE                    , L"ACS-Minimum-Latency"                       , 0                                             },
    { L"aCSMinimumPolicedSize"                     , ATT_ACS_MINIMUM_POLICED_SIZE                 , SYNTAX_I8_TYPE                    , L"ACS-Minimum-Policed-Size"                  , 0                                             },
    { L"aCSNonReservedMaxSDUSize"                  , ATT_ACS_NON_RESERVED_MAX_SDU_SIZE            , SYNTAX_I8_TYPE                    , L"ACS-Non-Reserved-Max-SDU-Size"             , 0                                             },
    { L"aCSNonReservedMinPolicedSize"              , ATT_ACS_NON_RESERVED_MIN_POLICED_SIZE        , SYNTAX_I8_TYPE                    , L"ACS-Non-Reserved-Min-Policed-Size"         , 0                                             },
    { L"aCSNonReservedPeakRate"                    , ATT_ACS_NON_RESERVED_PEAK_RATE               , SYNTAX_I8_TYPE                    , L"ACS-Non-Reserved-Peak-Rate"                , 0                                             },
    { L"aCSNonReservedTokenSize"                   , ATT_ACS_NON_RESERVED_TOKEN_SIZE              , SYNTAX_I8_TYPE                    , L"ACS-Non-Reserved-Token-Size"               , 0                                             },
    { L"aCSNonReservedTxLimit"                     , ATT_ACS_NON_RESERVED_TX_LIMIT                , SYNTAX_I8_TYPE                    , L"ACS-Non-Reserved-Tx-Limit"                 , 0                                             },
    { L"aCSNonReservedTxSize"                      , ATT_ACS_NON_RESERVED_TX_SIZE                 , SYNTAX_I8_TYPE                    , L"ACS-Non-Reserved-Tx-Size"                  , 0                                             },
    { L"aCSPermissionBits"                         , ATT_ACS_PERMISSION_BITS                      , SYNTAX_I8_TYPE                    , L"ACS-Permission-Bits"                       , 0                                             },
    { L"aCSPolicyName"                             , ATT_ACS_POLICY_NAME                          , SYNTAX_UNICODE_TYPE               , L"ACS-Policy-Name"                           , 0                                             },
    { L"aCSPriority"                               , ATT_ACS_PRIORITY                             , SYNTAX_INTEGER_TYPE               , L"ACS-Priority"                              , 0                                             },
    { L"aCSRSVPAccountFilesLocation"               , ATT_ACS_RSVP_ACCOUNT_FILES_LOCATION          , SYNTAX_UNICODE_TYPE               , L"ACS-RSVP-Account-Files-Location"           , 0                                             },
    { L"aCSRSVPLogFilesLocation"                   , ATT_ACS_RSVP_LOG_FILES_LOCATION              , SYNTAX_UNICODE_TYPE               , L"ACS-RSVP-Log-Files-Location"               , 0                                             },
    { L"aCSServiceType"                            , ATT_ACS_SERVICE_TYPE                         , SYNTAX_INTEGER_TYPE               , L"ACS-Service-Type"                          , 0                                             },
    { L"aCSTimeOfDay"                              , ATT_ACS_TIME_OF_DAY                          , SYNTAX_UNICODE_TYPE               , L"ACS-Time-Of-Day"                           , 0                                             },
    { L"aCSTotalNoOfFlows"                         , ATT_ACS_TOTAL_NO_OF_FLOWS                    , SYNTAX_INTEGER_TYPE               , L"ACS-Total-No-Of-Flows"                     , 0                                             },
    { L"aCSServerList"                             , ATT_ACS_SERVER_LIST                          , SYNTAX_UNICODE_TYPE               , L"ACS-Server-List"                           , 0                                             },
    { L"notes"                                     , ATT_ADDITIONAL_INFORMATION                   , SYNTAX_UNICODE_TYPE               , L"Additional-Information"                    , 0                                             },
    { L"additionalTrustedServiceNames"             , ATT_ADDITIONAL_TRUSTED_SERVICE_NAMES         , SYNTAX_UNICODE_TYPE               , L"Additional-Trusted-Service-Names"          , 0                                             },
    { L"streetAddress"                             , ATT_ADDRESS                                  , SYNTAX_UNICODE_TYPE               , L"Address"                                   , 0                                             },
    { L"addressBookRoots"                          , ATT_ADDRESS_BOOK_ROOTS                       , SYNTAX_DISTNAME_TYPE              , L"Address-Book-Roots"                        , 0                                             },
    { L"addressEntryDisplayTable"                  , ATT_ADDRESS_ENTRY_DISPLAY_TABLE              , SYNTAX_OCTET_STRING_TYPE          , L"Address-Entry-Display-Table"               , 0                                             },
    { L"addressEntryDisplayTableMSDOS"             , ATT_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS        , SYNTAX_OCTET_STRING_TYPE          , L"Address-Entry-Display-Table-MSDOS"         , 0                                             },
    { L"homePostalAddress"                         , ATT_ADDRESS_HOME                             , SYNTAX_UNICODE_TYPE               , L"Address-Home"                              , 0                                             },
    { L"addressSyntax"                             , ATT_ADDRESS_SYNTAX                           , SYNTAX_OCTET_STRING_TYPE          , L"Address-Syntax"                            , 0                                             },
    { L"addressType"                               , ATT_ADDRESS_TYPE                             , SYNTAX_NOCASE_STRING_TYPE         , L"Address-Type"                              , 0                                             },
    { L"adminContextMenu"                          , ATT_ADMIN_CONTEXT_MENU                       , SYNTAX_UNICODE_TYPE               , L"Admin-Context-Menu"                        , 0                                             },
    { L"adminCount"                                , ATT_ADMIN_COUNT                              , SYNTAX_INTEGER_TYPE               , L"Admin-Count"                               , 0                                             },
    { L"adminDescription"                          , ATT_ADMIN_DESCRIPTION                        , SYNTAX_UNICODE_TYPE               , L"Admin-Description"                         , 0                                             },
    { L"adminDisplayName"                          , ATT_ADMIN_DISPLAY_NAME                       , SYNTAX_UNICODE_TYPE               , L"Admin-Display-Name"                        , 0                                             },
    { L"adminMultiselectPropertyPages"             , ATT_ADMIN_MULTISELECT_PROPERTY_PAGES         , SYNTAX_UNICODE_TYPE               , L"Admin-Multiselect-Property-Pages"          , 0                                             },
    { L"adminPropertyPages"                        , ATT_ADMIN_PROPERTY_PAGES                     , SYNTAX_UNICODE_TYPE               , L"Admin-Property-Pages"                      , 0                                             },
    { L"allowedAttributes"                         , ATT_ALLOWED_ATTRIBUTES                       , SYNTAX_OBJECT_ID_TYPE             , L"Allowed-Attributes"                        , 0                                             },
    { L"allowedAttributesEffective"                , ATT_ALLOWED_ATTRIBUTES_EFFECTIVE             , SYNTAX_OBJECT_ID_TYPE             , L"Allowed-Attributes-Effective"              , 0                                             },
    { L"allowedChildClasses"                       , ATT_ALLOWED_CHILD_CLASSES                    , SYNTAX_OBJECT_ID_TYPE             , L"Allowed-Child-Classes"                     , 0                                             },
    { L"allowedChildClassesEffective"              , ATT_ALLOWED_CHILD_CLASSES_EFFECTIVE          , SYNTAX_OBJECT_ID_TYPE             , L"Allowed-Child-Classes-Effective"           , 0                                             },
    { L"altSecurityIdentities"                     , ATT_ALT_SECURITY_IDENTITIES                  , SYNTAX_UNICODE_TYPE               , L"Alt-Security-Identities"                   , 0                                             },
    { L"aNR"                                       , ATT_ANR                                      , SYNTAX_UNICODE_TYPE               , L"ANR"                                       , 0                                             },
    { L"appSchemaVersion"                          , ATT_APP_SCHEMA_VERSION                       , SYNTAX_INTEGER_TYPE               , L"App-Schema-Version"                        , 0                                             },
    { L"applicationName"                           , ATT_APPLICATION_NAME                         , SYNTAX_UNICODE_TYPE               , L"Application-Name"                          , 0                                             },
    { L"appliesTo"                                 , ATT_APPLIES_TO                               , SYNTAX_UNICODE_TYPE               , L"Applies-To"                                , 0                                             },
    { L"assetNumber"                               , ATT_ASSET_NUMBER                             , SYNTAX_UNICODE_TYPE               , L"Asset-Number"                              , 0                                             },
    { L"assistant"                                 , ATT_ASSISTANT                                , SYNTAX_DISTNAME_TYPE              , L"Assistant"                                 , 0                                             },
    { L"assocNTAccount"                            , ATT_ASSOC_NT_ACCOUNT                         , SYNTAX_OCTET_STRING_TYPE          , L"Assoc-NT-Account"                          , 0                                             },
    { L"attributeDisplayNames"                     , ATT_ATTRIBUTE_DISPLAY_NAMES                  , SYNTAX_UNICODE_TYPE               , L"Attribute-Display-Names"                   , 0                                             },
    { L"attributeID"                               , ATT_ATTRIBUTE_ID                             , SYNTAX_OBJECT_ID_TYPE             , L"Attribute-ID"                              , 0                                             },
    { L"attributeSecurityGUID"                     , ATT_ATTRIBUTE_SECURITY_GUID                  , SYNTAX_OCTET_STRING_TYPE          , L"Attribute-Security-GUID"                   , 0                                             },
    { L"attributeSyntax"                           , ATT_ATTRIBUTE_SYNTAX                         , SYNTAX_OBJECT_ID_TYPE             , L"Attribute-Syntax"                          , 0                                             },
    { L"attributeTypes"                            , ATT_ATTRIBUTE_TYPES                          , SYNTAX_UNICODE_TYPE               , L"Attribute-Types"                           , 0                                             },
    { L"auditingPolicy"                            , ATT_AUDITING_POLICY                          , SYNTAX_OCTET_STRING_TYPE          , L"Auditing-Policy"                           , 0                                             },
    { L"authenticationOptions"                     , ATT_AUTHENTICATION_OPTIONS                   , SYNTAX_INTEGER_TYPE               , L"Authentication-Options"                    , 0                                             },
    { L"authorityRevocationList"                   , ATT_AUTHORITY_REVOCATION_LIST                , SYNTAX_OCTET_STRING_TYPE          , L"Authority-Revocation-List"                 , 0                                             },
    { L"auxiliaryClass"                            , ATT_AUXILIARY_CLASS                          , SYNTAX_OBJECT_ID_TYPE             , L"Auxiliary-Class"                           , 0                                             },
    { L"badPasswordTime"                           , ATT_BAD_PASSWORD_TIME                        , SYNTAX_I8_TYPE                    , L"Bad-Password-Time"                         , 0                                             },
    { L"badPwdCount"                               , ATT_BAD_PWD_COUNT                            , SYNTAX_INTEGER_TYPE               , L"Bad-Pwd-Count"                             , 0                                             },
    { L"birthLocation"                             , ATT_BIRTH_LOCATION                           , SYNTAX_OCTET_STRING_TYPE          , L"Birth-Location"                            , 0                                             },
    { L"bridgeheadServerListBL"                    , ATT_BRIDGEHEAD_SERVER_LIST_BL                , SYNTAX_DISTNAME_TYPE              , L"Bridgehead-Server-List-BL"                 , 0                                             },
    { L"bridgeheadTransportList"                   , ATT_BRIDGEHEAD_TRANSPORT_LIST                , SYNTAX_DISTNAME_TYPE              , L"Bridgehead-Transport-List"                 , 0                                             },
    { L"builtinCreationTime"                       , ATT_BUILTIN_CREATION_TIME                    , SYNTAX_I8_TYPE                    , L"Builtin-Creation-Time"                     , 0                                             },
    { L"builtinModifiedCount"                      , ATT_BUILTIN_MODIFIED_COUNT                   , SYNTAX_I8_TYPE                    , L"Builtin-Modified-Count"                    , 0                                             },
    { L"businessCategory"                          , ATT_BUSINESS_CATEGORY                        , SYNTAX_UNICODE_TYPE               , L"Business-Category"                         , 0                                             },
    { L"bytesPerMinute"                            , ATT_BYTES_PER_MINUTE                         , SYNTAX_INTEGER_TYPE               , L"Bytes-Per-Minute"                          , 0                                             },
    { L"cACertificate"                             , ATT_CA_CERTIFICATE                           , SYNTAX_OCTET_STRING_TYPE          , L"CA-Certificate"                            , 0                                             },
    { L"cACertificateDN"                           , ATT_CA_CERTIFICATE_DN                        , SYNTAX_UNICODE_TYPE               , L"CA-Certificate-DN"                         , 0                                             },
    { L"cAConnect"                                 , ATT_CA_CONNECT                               , SYNTAX_UNICODE_TYPE               , L"CA-Connect"                                , 0                                             },
    { L"cAUsages"                                  , ATT_CA_USAGES                                , SYNTAX_UNICODE_TYPE               , L"CA-Usages"                                 , 0                                             },
    { L"cAWEBURL"                                  , ATT_CA_WEB_URL                               , SYNTAX_UNICODE_TYPE               , L"CA-WEB-URL"                                , 0                                             },
    { L"canUpgradeScript"                          , ATT_CAN_UPGRADE_SCRIPT                       , SYNTAX_UNICODE_TYPE               , L"Can-Upgrade-Script"                        , 0                                             },
    { L"canonicalName"                             , ATT_CANONICAL_NAME                           , SYNTAX_UNICODE_TYPE               , L"Canonical-Name"                            , 0                                             },
    { L"catalogs"                                  , ATT_CATALOGS                                 , SYNTAX_UNICODE_TYPE               , L"Catalogs"                                  , 0                                             },
    { L"categories"                                , ATT_CATEGORIES                               , SYNTAX_UNICODE_TYPE               , L"Categories"                                , 0                                             },
    { L"categoryId"                                , ATT_CATEGORY_ID                              , SYNTAX_OCTET_STRING_TYPE          , L"Category-Id"                               , 0                                             },
    { L"certificateAuthorityObject"                , ATT_CERTIFICATE_AUTHORITY_OBJECT             , SYNTAX_DISTNAME_TYPE              , L"Certificate-Authority-Object"              , 0                                             },
    { L"certificateRevocationList"                 , ATT_CERTIFICATE_REVOCATION_LIST              , SYNTAX_OCTET_STRING_TYPE          , L"Certificate-Revocation-List"               , 0                                             },
    { L"certificateTemplates"                      , ATT_CERTIFICATE_TEMPLATES                    , SYNTAX_UNICODE_TYPE               , L"Certificate-Templates"                     , 0                                             },
    { L"classDisplayName"                          , ATT_CLASS_DISPLAY_NAME                       , SYNTAX_UNICODE_TYPE               , L"Class-Display-Name"                        , 0                                             },
    { L"codePage"                                  , ATT_CODE_PAGE                                , SYNTAX_INTEGER_TYPE               , L"Code-Page"                                 , 0                                             },
    { L"cOMClassID"                                , ATT_COM_CLASSID                              , SYNTAX_UNICODE_TYPE               , L"COM-ClassID"                               , 0                                             },
    { L"cOMCLSID"                                  , ATT_COM_CLSID                                , SYNTAX_UNICODE_TYPE               , L"COM-CLSID"                                 , 0                                             },
    { L"cOMInterfaceID"                            , ATT_COM_INTERFACEID                          , SYNTAX_UNICODE_TYPE               , L"COM-InterfaceID"                           , 0                                             },
    { L"cOMOtherProgId"                            , ATT_COM_OTHER_PROG_ID                        , SYNTAX_UNICODE_TYPE               , L"COM-Other-Prog-Id"                         , 0                                             },
    { L"cOMProgID"                                 , ATT_COM_PROGID                               , SYNTAX_UNICODE_TYPE               , L"COM-ProgID"                                , 0                                             },
    { L"cOMTreatAsClassId"                         , ATT_COM_TREAT_AS_CLASS_ID                    , SYNTAX_UNICODE_TYPE               , L"COM-Treat-As-Class-Id"                     , 0                                             },
    { L"cOMTypelibId"                              , ATT_COM_TYPELIB_ID                           , SYNTAX_UNICODE_TYPE               , L"COM-Typelib-Id"                            , 0                                             },
    { L"cOMUniqueLIBID"                            , ATT_COM_UNIQUE_LIBID                         , SYNTAX_UNICODE_TYPE               , L"COM-Unique-LIBID"                          , 0                                             },
    { L"info"                                      , ATT_COMMENT                                  , SYNTAX_UNICODE_TYPE               , L"Comment"                                   , 0                                             },
    { L"cn"                                        , ATT_COMMON_NAME                              , SYNTAX_UNICODE_TYPE               , L"Common-Name"                               , 0                                             },
    { L"company"                                   , ATT_COMPANY                                  , SYNTAX_UNICODE_TYPE               , L"Company"                                   , 0                                             },
    { L"contentIndexingAllowed"                    , ATT_CONTENT_INDEXING_ALLOWED                 , SYNTAX_BOOLEAN_TYPE               , L"Content-Indexing-Allowed"                  , 0                                             },
    { L"contextMenu"                               , ATT_CONTEXT_MENU                             , SYNTAX_UNICODE_TYPE               , L"Context-Menu"                              , 0                                             },
    { L"controlAccessRights"                       , ATT_CONTROL_ACCESS_RIGHTS                    , SYNTAX_OCTET_STRING_TYPE          , L"Control-Access-Rights"                     , 0                                             },
    { L"cost"                                      , ATT_COST                                     , SYNTAX_INTEGER_TYPE               , L"Cost"                                      , 0                                             },
    { L"countryCode"                               , ATT_COUNTRY_CODE                             , SYNTAX_INTEGER_TYPE               , L"Country-Code"                              , 0                                             },
    { L"c"                                         , ATT_COUNTRY_NAME                             , SYNTAX_UNICODE_TYPE               , L"Country-Name"                              , 0                                             },
    { L"createDialog"                              , ATT_CREATE_DIALOG                            , SYNTAX_UNICODE_TYPE               , L"Create-Dialog"                             , 0                                             },
    { L"createTimeStamp"                           , ATT_CREATE_TIME_STAMP                        , SYNTAX_TIME_TYPE                  , L"Create-Time-Stamp"                         , 0                                             },
    { L"createWizardExt"                           , ATT_CREATE_WIZARD_EXT                        , SYNTAX_UNICODE_TYPE               , L"Create-Wizard-Ext"                         , 0                                             },
    { L"creationTime"                              , ATT_CREATION_TIME                            , SYNTAX_I8_TYPE                    , L"Creation-Time"                             , 0                                             },
    { L"creationWizard"                            , ATT_CREATION_WIZARD                          , SYNTAX_UNICODE_TYPE               , L"Creation-Wizard"                           , 0                                             },
    { L"creator"                                   , ATT_CREATOR                                  , SYNTAX_UNICODE_TYPE               , L"Creator"                                   , 0                                             },
    { L"cRLObject"                                 , ATT_CRL_OBJECT                               , SYNTAX_DISTNAME_TYPE              , L"CRL-Object"                                , 0                                             },
    { L"cRLPartitionedRevocationList"              , ATT_CRL_PARTITIONED_REVOCATION_LIST          , SYNTAX_OCTET_STRING_TYPE          , L"CRL-Partitioned-Revocation-List"           , 0                                             },
    { L"crossCertificatePair"                      , ATT_CROSS_CERTIFICATE_PAIR                   , SYNTAX_OCTET_STRING_TYPE          , L"Cross-Certificate-Pair"                    , 0                                             },
    { L"currMachineId"                             , ATT_CURR_MACHINE_ID                          , SYNTAX_OCTET_STRING_TYPE          , L"Curr-Machine-Id"                           , 0                                             },
    { L"currentLocation"                           , ATT_CURRENT_LOCATION                         , SYNTAX_OCTET_STRING_TYPE          , L"Current-Location"                          , 0                                             },
    { L"currentParentCA"                           , ATT_CURRENT_PARENT_CA                        , SYNTAX_DISTNAME_TYPE              , L"Current-Parent-CA"                         , 0                                             },
    { L"currentValue"                              , ATT_CURRENT_VALUE                            , SYNTAX_OCTET_STRING_TYPE          , L"Current-Value"                             , 0                                             },
    { L"dBCSPwd"                                   , ATT_DBCS_PWD                                 , SYNTAX_OCTET_STRING_TYPE          , L"DBCS-Pwd"                                  , 0                                             },
    { L"defaultClassStore"                         , ATT_DEFAULT_CLASS_STORE                      , SYNTAX_DISTNAME_TYPE              , L"Default-Class-Store"                       , 0                                             },
    { L"defaultGroup"                              , ATT_DEFAULT_GROUP                            , SYNTAX_DISTNAME_TYPE              , L"Default-Group"                             , 0                                             },
    { L"defaultHidingValue"                        , ATT_DEFAULT_HIDING_VALUE                     , SYNTAX_BOOLEAN_TYPE               , L"Default-Hiding-Value"                      , 0                                             },
    { L"defaultLocalPolicyObject"                  , ATT_DEFAULT_LOCAL_POLICY_OBJECT              , SYNTAX_DISTNAME_TYPE              , L"Default-Local-Policy-Object"               , 0                                             },
    { L"defaultObjectCategory"                     , ATT_DEFAULT_OBJECT_CATEGORY                  , SYNTAX_DISTNAME_TYPE              , L"Default-Object-Category"                   , 0                                             },
    { L"defaultPriority"                           , ATT_DEFAULT_PRIORITY                         , SYNTAX_INTEGER_TYPE               , L"Default-Priority"                          , 0                                             },
    { L"defaultSecurityDescriptor"                 , ATT_DEFAULT_SECURITY_DESCRIPTOR              , SYNTAX_UNICODE_TYPE               , L"Default-Security-Descriptor"               , 0                                             },
    { L"deltaRevocationList"                       , ATT_DELTA_REVOCATION_LIST                    , SYNTAX_OCTET_STRING_TYPE          , L"Delta-Revocation-List"                     , 0                                             },
    { L"department"                                , ATT_DEPARTMENT                               , SYNTAX_UNICODE_TYPE               , L"Department"                                , 0                                             },
    { L"description"                               , ATT_DESCRIPTION                              , SYNTAX_UNICODE_TYPE               , L"Description"                               , 0                                             },
    { L"desktopProfile"                            , ATT_DESKTOP_PROFILE                          , SYNTAX_UNICODE_TYPE               , L"Desktop-Profile"                           , 0                                             },
    { L"destinationIndicator"                      , ATT_DESTINATION_INDICATOR                    , SYNTAX_PRINT_CASE_STRING_TYPE     , L"Destination-Indicator"                     , 0                                             },
    { L"dhcpClasses"                               , ATT_DHCP_CLASSES                             , SYNTAX_OCTET_STRING_TYPE          , L"dhcp-Classes"                              , 0                                             },
    { L"dhcpFlags"                                 , ATT_DHCP_FLAGS                               , SYNTAX_I8_TYPE                    , L"dhcp-Flags"                                , 0                                             },
    { L"dhcpIdentification"                        , ATT_DHCP_IDENTIFICATION                      , SYNTAX_UNICODE_TYPE               , L"dhcp-Identification"                       , 0                                             },
    { L"dhcpMask"                                  , ATT_DHCP_MASK                                , SYNTAX_PRINT_CASE_STRING_TYPE     , L"dhcp-Mask"                                 , 0                                             },
    { L"dhcpMaxKey"                                , ATT_DHCP_MAXKEY                              , SYNTAX_I8_TYPE                    , L"dhcp-MaxKey"                               , 0                                             },
    { L"dhcpObjDescription"                        , ATT_DHCP_OBJ_DESCRIPTION                     , SYNTAX_UNICODE_TYPE               , L"dhcp-Obj-Description"                      , 0                                             },
    { L"dhcpObjName"                               , ATT_DHCP_OBJ_NAME                            , SYNTAX_UNICODE_TYPE               , L"dhcp-Obj-Name"                             , 0                                             },
    { L"dhcpOptions"                               , ATT_DHCP_OPTIONS                             , SYNTAX_OCTET_STRING_TYPE          , L"dhcp-Options"                              , 0                                             },
    { L"dhcpProperties"                            , ATT_DHCP_PROPERTIES                          , SYNTAX_OCTET_STRING_TYPE          , L"dhcp-Properties"                           , 0                                             },
    { L"dhcpRanges"                                , ATT_DHCP_RANGES                              , SYNTAX_PRINT_CASE_STRING_TYPE     , L"dhcp-Ranges"                               , 0                                             },
    { L"dhcpReservations"                          , ATT_DHCP_RESERVATIONS                        , SYNTAX_PRINT_CASE_STRING_TYPE     , L"dhcp-Reservations"                         , 0                                             },
    { L"dhcpServers"                               , ATT_DHCP_SERVERS                             , SYNTAX_PRINT_CASE_STRING_TYPE     , L"dhcp-Servers"                              , 0                                             },
    { L"dhcpSites"                                 , ATT_DHCP_SITES                               , SYNTAX_PRINT_CASE_STRING_TYPE     , L"dhcp-Sites"                                , 0                                             },
    { L"dhcpState"                                 , ATT_DHCP_STATE                               , SYNTAX_PRINT_CASE_STRING_TYPE     , L"dhcp-State"                                , 0                                             },
    { L"dhcpSubnets"                               , ATT_DHCP_SUBNETS                             , SYNTAX_PRINT_CASE_STRING_TYPE     , L"dhcp-Subnets"                              , 0                                             },
    { L"dhcpType"                                  , ATT_DHCP_TYPE                                , SYNTAX_INTEGER_TYPE               , L"dhcp-Type"                                 , 0                                             },
    { L"dhcpUniqueKey"                             , ATT_DHCP_UNIQUE_KEY                          , SYNTAX_I8_TYPE                    , L"dhcp-Unique-Key"                           , 0                                             },
    { L"dhcpUpdateTime"                            , ATT_DHCP_UPDATE_TIME                         , SYNTAX_I8_TYPE                    , L"dhcp-Update-Time"                          , 0                                             },
    { L"displayName"                               , ATT_DISPLAY_NAME                             , SYNTAX_UNICODE_TYPE               , L"Display-Name"                              , 0                                             },
    { L"displayNamePrintable"                      , ATT_DISPLAY_NAME_PRINTABLE                   , SYNTAX_PRINT_CASE_STRING_TYPE     , L"Display-Name-Printable"                    , 0                                             },
    { L"dITContentRules"                           , ATT_DIT_CONTENT_RULES                        , SYNTAX_UNICODE_TYPE               , L"DIT-Content-Rules"                         , 0                                             },
    { L"division"                                  , ATT_DIVISION                                 , SYNTAX_UNICODE_TYPE               , L"Division"                                  , 0                                             },
    { L"dMDLocation"                               , ATT_DMD_LOCATION                             , SYNTAX_DISTNAME_TYPE              , L"DMD-Location"                              , 0                                             },
    { L"dmdName"                                   , ATT_DMD_NAME                                 , SYNTAX_UNICODE_TYPE               , L"DMD-Name"                                  , 0                                             },
    { L"dNReferenceUpdate"                         , ATT_DN_REFERENCE_UPDATE                      , SYNTAX_DISTNAME_TYPE              , L"DN-Reference-Update"                       , 0                                             },
    { L"dnsAllowDynamic"                           , ATT_DNS_ALLOW_DYNAMIC                        , SYNTAX_BOOLEAN_TYPE               , L"Dns-Allow-Dynamic"                         , 0                                             },
    { L"dnsAllowXFR"                               , ATT_DNS_ALLOW_XFR                            , SYNTAX_BOOLEAN_TYPE               , L"Dns-Allow-XFR"                             , 0                                             },
    { L"dNSHostName"                               , ATT_DNS_HOST_NAME                            , SYNTAX_UNICODE_TYPE               , L"DNS-Host-Name"                             , 0                                             },
    { L"dnsNotifySecondaries"                      , ATT_DNS_NOTIFY_SECONDARIES                   , SYNTAX_INTEGER_TYPE               , L"Dns-Notify-Secondaries"                    , 0                                             },
    { L"dNSProperty"                               , ATT_DNS_PROPERTY                             , SYNTAX_OCTET_STRING_TYPE          , L"DNS-Property"                              , 0                                             },
    { L"dnsRecord"                                 , ATT_DNS_RECORD                               , SYNTAX_OCTET_STRING_TYPE          , L"Dns-Record"                                , 0                                             },
    { L"dnsRoot"                                   , ATT_DNS_ROOT                                 , SYNTAX_UNICODE_TYPE               , L"Dns-Root"                                  , 0                                             },
    { L"dnsSecureSecondaries"                      , ATT_DNS_SECURE_SECONDARIES                   , SYNTAX_INTEGER_TYPE               , L"Dns-Secure-Secondaries"                    , 0                                             },
    { L"dNSTombstoned"                             , ATT_DNS_TOMBSTONED                           , SYNTAX_BOOLEAN_TYPE               , L"DNS-Tombstoned"                            , 0                                             },
    { L"domainCAs"                                 , ATT_DOMAIN_CERTIFICATE_AUTHORITIES           , SYNTAX_DISTNAME_TYPE              , L"Domain-Certificate-Authorities"            , 0                                             },
    { L"dc"                                        , ATT_DOMAIN_COMPONENT                         , SYNTAX_UNICODE_TYPE               , L"Domain-Component"                          , 0                                             },
    { L"domainCrossRef"                            , ATT_DOMAIN_CROSS_REF                         , SYNTAX_DISTNAME_TYPE              , L"Domain-Cross-Ref"                          , 0                                             },
    { L"domainID"                                  , ATT_DOMAIN_ID                                , SYNTAX_DISTNAME_TYPE              , L"Domain-ID"                                 , 0                                             },
    { L"domainIdentifier"                          , ATT_DOMAIN_IDENTIFIER                        , SYNTAX_INTEGER_TYPE               , L"Domain-Identifier"                         , 0                                             },
    { L"domainPolicyObject"                        , ATT_DOMAIN_POLICY_OBJECT                     , SYNTAX_DISTNAME_TYPE              , L"Domain-Policy-Object"                      , 0                                             },
    { L"domainPolicyReference"                     , ATT_DOMAIN_POLICY_REFERENCE                  , SYNTAX_DISTNAME_TYPE              , L"Domain-Policy-Reference"                   , 0                                             },
    { L"domainReplica"                             , ATT_DOMAIN_REPLICA                           , SYNTAX_UNICODE_TYPE               , L"Domain-Replica"                            , 0                                             },
    { L"domainWidePolicy"                          , ATT_DOMAIN_WIDE_POLICY                       , SYNTAX_OCTET_STRING_TYPE          , L"Domain-Wide-Policy"                        , 0                                             },
    { L"driverName"                                , ATT_DRIVER_NAME                              , SYNTAX_UNICODE_TYPE               , L"Driver-Name"                               , 0                                             },
    { L"driverVersion"                             , ATT_DRIVER_VERSION                           , SYNTAX_INTEGER_TYPE               , L"Driver-Version"                            , 0                                             },
    { L"dSCorePropagationData"                     , ATT_DS_CORE_PROPAGATION_DATA                 , SYNTAX_TIME_TYPE                  , L"DS-Core-Propagation-Data"                  , 0                                             },
    { L"dSHeuristics"                              , ATT_DS_HEURISTICS                            , SYNTAX_UNICODE_TYPE               , L"DS-Heuristics"                             , 0                                             },
    { L"dSUIAdminMaximum"                          , ATT_DS_UI_ADMIN_MAXIMUM                      , SYNTAX_INTEGER_TYPE               , L"DS-UI-Admin-Maximum"                       , 0                                             },
    { L"dSUIAdminNotification"                     , ATT_DS_UI_ADMIN_NOTIFICATION                 , SYNTAX_UNICODE_TYPE               , L"DS-UI-Admin-Notification"                  , 0                                             },
    { L"dSUIShellMaximum"                          , ATT_DS_UI_SHELL_MAXIMUM                      , SYNTAX_INTEGER_TYPE               , L"DS-UI-Shell-Maximum"                       , 0                                             },
    { L"dSASignature"                              , ATT_DSA_SIGNATURE                            , SYNTAX_OCTET_STRING_TYPE          , L"DSA-Signature"                             , 0                                             },
    { L"dynamicLDAPServer"                         , ATT_DYNAMIC_LDAP_SERVER                      , SYNTAX_DISTNAME_TYPE              , L"Dynamic-LDAP-Server"                       , 0                                             },
    { L"mail"                                      , ATT_E_MAIL_ADDRESSES                         , SYNTAX_UNICODE_TYPE               , L"E-mail-Addresses"                          , 0                                             },
    { L"eFSPolicy"                                 , ATT_EFSPOLICY                                , SYNTAX_OCTET_STRING_TYPE          , L"EFSPolicy"                                 , 0                                             },
    { L"employeeID"                                , ATT_EMPLOYEE_ID                              , SYNTAX_UNICODE_TYPE               , L"Employee-ID"                               , 0                                             },
    { L"employeeNumber"                            , ATT_EMPLOYEE_NUMBER                          , SYNTAX_UNICODE_TYPE               , L"Employee-Number"                           , 0                                             },
    { L"employeeType"                              , ATT_EMPLOYEE_TYPE                            , SYNTAX_UNICODE_TYPE               , L"Employee-Type"                             , 0                                             },
    { L"Enabled"                                   , ATT_ENABLED                                  , SYNTAX_BOOLEAN_TYPE               , L"Enabled"                                   , 0                                             },
    { L"enabledConnection"                         , ATT_ENABLED_CONNECTION                       , SYNTAX_BOOLEAN_TYPE               , L"Enabled-Connection"                        , 0                                             },
    { L"enrollmentProviders"                       , ATT_ENROLLMENT_PROVIDERS                     , SYNTAX_UNICODE_TYPE               , L"Enrollment-Providers"                      , 0                                             },
    { L"entryTTL"                                  , ATT_ENTRY_TTL                                , SYNTAX_INTEGER_TYPE               , L"Entry-TTL"                                 , 0                                             },
    { L"extendedAttributeInfo"                     , ATT_EXTENDED_ATTRIBUTE_INFO                  , SYNTAX_UNICODE_TYPE               , L"Extended-Attribute-Info"                   , 0                                             },
    { L"extendedCharsAllowed"                      , ATT_EXTENDED_CHARS_ALLOWED                   , SYNTAX_BOOLEAN_TYPE               , L"Extended-Chars-Allowed"                    , 0                                             },
    { L"extendedClassInfo"                         , ATT_EXTENDED_CLASS_INFO                      , SYNTAX_UNICODE_TYPE               , L"Extended-Class-Info"                       , 0                                             },
    { L"extensionName"                             , ATT_EXTENSION_NAME                           , SYNTAX_UNICODE_TYPE               , L"Extension-Name"                            , 0                                             },
    { L"extraColumns"                              , ATT_EXTRA_COLUMNS                            , SYNTAX_UNICODE_TYPE               , L"Extra-Columns"                             , 0                                             },
    { L"facsimileTelephoneNumber"                  , ATT_FACSIMILE_TELEPHONE_NUMBER               , SYNTAX_UNICODE_TYPE               , L"Facsimile-Telephone-Number"                , 0                                             },
    { L"fileExtPriority"                           , ATT_FILE_EXT_PRIORITY                        , SYNTAX_UNICODE_TYPE               , L"File-Ext-Priority"                         , 0                                             },
    { L"flags"                                     , ATT_FLAGS                                    , SYNTAX_INTEGER_TYPE               , L"Flags"                                     , 0                                             },
    { L"flatName"                                  , ATT_FLAT_NAME                                , SYNTAX_UNICODE_TYPE               , L"Flat-Name"                                 , 0                                             },
    { L"forceLogoff"                               , ATT_FORCE_LOGOFF                             , SYNTAX_I8_TYPE                    , L"Force-Logoff"                              , 0                                             },
    { L"foreignIdentifier"                         , ATT_FOREIGN_IDENTIFIER                       , SYNTAX_OCTET_STRING_TYPE          , L"Foreign-Identifier"                        , 0                                             },
    { L"friendlyNames"                             , ATT_FRIENDLY_NAMES                           , SYNTAX_UNICODE_TYPE               , L"Friendly-Names"                            , 0                                             },
    { L"fromEntry"                                 , ATT_FROM_ENTRY                               , SYNTAX_BOOLEAN_TYPE               , L"From-Entry"                                , 0                                             },
    { L"fromServer"                                , ATT_FROM_SERVER                              , SYNTAX_DISTNAME_TYPE              , L"From-Server"                               , 0                                             },
    { L"frsComputerReference"                      , ATT_FRS_COMPUTER_REFERENCE                   , SYNTAX_DISTNAME_TYPE              , L"Frs-Computer-Reference"                    , 0                                             },
    { L"frsComputerReferenceBL"                    , ATT_FRS_COMPUTER_REFERENCE_BL                , SYNTAX_DISTNAME_TYPE              , L"Frs-Computer-Reference-BL"                 , 0                                             },
    { L"fRSControlDataCreation"                    , ATT_FRS_CONTROL_DATA_CREATION                , SYNTAX_UNICODE_TYPE               , L"FRS-Control-Data-Creation"                 , 0                                             },
    { L"fRSControlInboundBacklog"                  , ATT_FRS_CONTROL_INBOUND_BACKLOG              , SYNTAX_UNICODE_TYPE               , L"FRS-Control-Inbound-Backlog"               , 0                                             },
    { L"fRSControlOutboundBacklog"                 , ATT_FRS_CONTROL_OUTBOUND_BACKLOG             , SYNTAX_UNICODE_TYPE               , L"FRS-Control-Outbound-Backlog"              , 0                                             },
    { L"fRSDirectoryFilter"                        , ATT_FRS_DIRECTORY_FILTER                     , SYNTAX_UNICODE_TYPE               , L"FRS-Directory-Filter"                      , 0                                             },
    { L"fRSDSPoll"                                 , ATT_FRS_DS_POLL                              , SYNTAX_INTEGER_TYPE               , L"FRS-DS-Poll"                               , 0                                             },
    { L"fRSExtensions"                             , ATT_FRS_EXTENSIONS                           , SYNTAX_OCTET_STRING_TYPE          , L"FRS-Extensions"                            , 0                                             },
    { L"fRSFaultCondition"                         , ATT_FRS_FAULT_CONDITION                      , SYNTAX_UNICODE_TYPE               , L"FRS-Fault-Condition"                       , 0                                             },
    { L"fRSFileFilter"                             , ATT_FRS_FILE_FILTER                          , SYNTAX_UNICODE_TYPE               , L"FRS-File-Filter"                           , 0                                             },
    { L"fRSFlags"                                  , ATT_FRS_FLAGS                                , SYNTAX_INTEGER_TYPE               , L"FRS-Flags"                                 , 0                                             },
    { L"fRSLevelLimit"                             , ATT_FRS_LEVEL_LIMIT                          , SYNTAX_INTEGER_TYPE               , L"FRS-Level-Limit"                           , 0                                             },
    { L"fRSMemberReference"                        , ATT_FRS_MEMBER_REFERENCE                     , SYNTAX_DISTNAME_TYPE              , L"FRS-Member-Reference"                      , 0                                             },
    { L"fRSMemberReferenceBL"                      , ATT_FRS_MEMBER_REFERENCE_BL                  , SYNTAX_DISTNAME_TYPE              , L"FRS-Member-Reference-BL"                   , 0                                             },
    { L"fRSPartnerAuthLevel"                       , ATT_FRS_PARTNER_AUTH_LEVEL                   , SYNTAX_INTEGER_TYPE               , L"FRS-Partner-Auth-Level"                    , 0                                             },
    { L"fRSPrimaryMember"                          , ATT_FRS_PRIMARY_MEMBER                       , SYNTAX_DISTNAME_TYPE              , L"FRS-Primary-Member"                        , 0                                             },
    { L"fRSReplicaSetGUID"                         , ATT_FRS_REPLICA_SET_GUID                     , SYNTAX_OCTET_STRING_TYPE          , L"FRS-Replica-Set-GUID"                      , 0                                             },
    { L"fRSReplicaSetType"                         , ATT_FRS_REPLICA_SET_TYPE                     , SYNTAX_INTEGER_TYPE               , L"FRS-Replica-Set-Type"                      , 0                                             },
    { L"fRSRootPath"                               , ATT_FRS_ROOT_PATH                            , SYNTAX_UNICODE_TYPE               , L"FRS-Root-Path"                             , 0                                             },
    { L"fRSRootSecurity"                           , ATT_FRS_ROOT_SECURITY                        , SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE, L"FRS-Root-Security"                         , 0                                             },
    { L"fRSServiceCommand"                         , ATT_FRS_SERVICE_COMMAND                      , SYNTAX_UNICODE_TYPE               , L"FRS-Service-Command"                       , 0                                             },
    { L"fRSServiceCommandStatus"                   , ATT_FRS_SERVICE_COMMAND_STATUS               , SYNTAX_UNICODE_TYPE               , L"FRS-Service-Command-Status"                , 0                                             },
    { L"fRSStagingPath"                            , ATT_FRS_STAGING_PATH                         , SYNTAX_UNICODE_TYPE               , L"FRS-Staging-Path"                          , 0                                             },
    { L"fRSTimeLastCommand"                        , ATT_FRS_TIME_LAST_COMMAND                    , SYNTAX_TIME_TYPE                  , L"FRS-Time-Last-Command"                     , 0                                             },
    { L"fRSTimeLastConfigChange"                   , ATT_FRS_TIME_LAST_CONFIG_CHANGE              , SYNTAX_TIME_TYPE                  , L"FRS-Time-Last-Config-Change"               , 0                                             },
    { L"fRSUpdateTimeout"                          , ATT_FRS_UPDATE_TIMEOUT                       , SYNTAX_INTEGER_TYPE               , L"FRS-Update-Timeout"                        , 0                                             },
    { L"fRSVersion"                                , ATT_FRS_VERSION                              , SYNTAX_UNICODE_TYPE               , L"FRS-Version"                               , 0                                             },
    { L"fRSVersionGUID"                            , ATT_FRS_VERSION_GUID                         , SYNTAX_OCTET_STRING_TYPE          , L"FRS-Version-GUID"                          , 0                                             },
    { L"fRSWorkingPath"                            , ATT_FRS_WORKING_PATH                         , SYNTAX_UNICODE_TYPE               , L"FRS-Working-Path"                          , 0                                             },
    { L"fSMORoleOwner"                             , ATT_FSMO_ROLE_OWNER                          , SYNTAX_DISTNAME_TYPE              , L"FSMO-Role-Owner"                           , 0                                             },
    { L"garbageCollPeriod"                         , ATT_GARBAGE_COLL_PERIOD                      , SYNTAX_INTEGER_TYPE               , L"Garbage-Coll-Period"                       , 0                                             },
    { L"generatedConnection"                       , ATT_GENERATED_CONNECTION                     , SYNTAX_BOOLEAN_TYPE               , L"Generated-Connection"                      , 0                                             },
    { L"generationQualifier"                       , ATT_GENERATION_QUALIFIER                     , SYNTAX_UNICODE_TYPE               , L"Generation-Qualifier"                      , 0                                             },
    { L"givenName"                                 , ATT_GIVEN_NAME                               , SYNTAX_UNICODE_TYPE               , L"Given-Name"                                , 0                                             },
    { L"globalAddressList"                         , ATT_GLOBAL_ADDRESS_LIST                      , SYNTAX_DISTNAME_TYPE              , L"Global-Address-List"                       , 0                                             },
    { L"governsID"                                 , ATT_GOVERNS_ID                               , SYNTAX_OBJECT_ID_TYPE             , L"Governs-ID"                                , 0                                             },
    { L"gPLink"                                    , ATT_GP_LINK                                  , SYNTAX_UNICODE_TYPE               , L"GP-Link"                                   , 0                                             },
    { L"gPOptions"                                 , ATT_GP_OPTIONS                               , SYNTAX_INTEGER_TYPE               , L"GP-Options"                                , 0                                             },
    { L"gPCFileSysPath"                            , ATT_GPC_FILE_SYS_PATH                        , SYNTAX_UNICODE_TYPE               , L"GPC-File-Sys-Path"                         , 0                                             },
    { L"gPCFunctionalityVersion"                   , ATT_GPC_FUNCTIONALITY_VERSION                , SYNTAX_INTEGER_TYPE               , L"GPC-Functionality-Version"                 , 0                                             },
    { L"gPCMachineExtensionNames"                  , ATT_GPC_MACHINE_EXTENSION_NAMES              , SYNTAX_UNICODE_TYPE               , L"GPC-Machine-Extension-Names"               , 0                                             },
    { L"gPCUserExtensionNames"                     , ATT_GPC_USER_EXTENSION_NAMES                 , SYNTAX_UNICODE_TYPE               , L"GPC-User-Extension-Names"                  , 0                                             },
    { L"gPCWQLFilter"                              , ATT_GPC_WQL_FILTER                           , SYNTAX_UNICODE_TYPE               , L"GPC-WQL-Filter"                            , 0                                             },
    { L"groupAttributes"                           , ATT_GROUP_ATTRIBUTES                         , SYNTAX_INTEGER_TYPE               , L"Group-Attributes"                          , 0                                             },
    { L"groupMembershipSAM"                        , ATT_GROUP_MEMBERSHIP_SAM                     , SYNTAX_OCTET_STRING_TYPE          , L"Group-Membership-SAM"                      , 0                                             },
    { L"groupPriority"                             , ATT_GROUP_PRIORITY                           , SYNTAX_UNICODE_TYPE               , L"Group-Priority"                            , 0                                             },
    { L"groupType"                                 , ATT_GROUP_TYPE                               , SYNTAX_INTEGER_TYPE               , L"Group-Type"                                , 0                                             },
    { L"groupstoIgnore"                            , ATT_GROUPS_TO_IGNORE                         , SYNTAX_UNICODE_TYPE               , L"Groups-to-Ignore"                          , 0                                             },
    { L"hasMasterNCs"                              , ATT_HAS_MASTER_NCS                           , SYNTAX_DISTNAME_TYPE              , L"Has-Master-NCs"                            , 0                                             },
    { L"hasPartialReplicaNCs"                      , ATT_HAS_PARTIAL_REPLICA_NCS                  , SYNTAX_DISTNAME_TYPE              , L"Has-Partial-Replica-NCs"                   , 0                                             },
    { L"helpData16"                                , ATT_HELP_DATA16                              , SYNTAX_OCTET_STRING_TYPE          , L"Help-Data16"                               , 0                                             },
    { L"helpData32"                                , ATT_HELP_DATA32                              , SYNTAX_OCTET_STRING_TYPE          , L"Help-Data32"                               , 0                                             },
    { L"helpFileName"                              , ATT_HELP_FILE_NAME                           , SYNTAX_UNICODE_TYPE               , L"Help-File-Name"                            , 0                                             },
    { L"homeDirectory"                             , ATT_HOME_DIRECTORY                           , SYNTAX_UNICODE_TYPE               , L"Home-Directory"                            , 0                                             },
    { L"homeDrive"                                 , ATT_HOME_DRIVE                               , SYNTAX_UNICODE_TYPE               , L"Home-Drive"                                , 0                                             },
    { L"iconPath"                                  , ATT_ICON_PATH                                , SYNTAX_UNICODE_TYPE               , L"Icon-Path"                                 , 0                                             },
    { L"implementedCategories"                     , ATT_IMPLEMENTED_CATEGORIES                   , SYNTAX_OCTET_STRING_TYPE          , L"Implemented-Categories"                    , 0                                             },
    { L"indexedScopes"                             , ATT_INDEXEDSCOPES                            , SYNTAX_UNICODE_TYPE               , L"IndexedScopes"                             , 0                                             },
    { L"initialAuthIncoming"                       , ATT_INITIAL_AUTH_INCOMING                    , SYNTAX_UNICODE_TYPE               , L"Initial-Auth-Incoming"                     , 0                                             },
    { L"initialAuthOutgoing"                       , ATT_INITIAL_AUTH_OUTGOING                    , SYNTAX_UNICODE_TYPE               , L"Initial-Auth-Outgoing"                     , 0                                             },
    { L"initials"                                  , ATT_INITIALS                                 , SYNTAX_UNICODE_TYPE               , L"Initials"                                  , 0                                             },
    { L"installUiLevel"                            , ATT_INSTALL_UI_LEVEL                         , SYNTAX_INTEGER_TYPE               , L"Install-Ui-Level"                          , 0                                             },
    { L"instanceType"                              , ATT_INSTANCE_TYPE                            , SYNTAX_INTEGER_TYPE               , L"Instance-Type"                             , 0                                             },
    { L"interSiteTopologyFailover"                 , ATT_INTER_SITE_TOPOLOGY_FAILOVER             , SYNTAX_INTEGER_TYPE               , L"Inter-Site-Topology-Failover"              , 0                                             },
    { L"interSiteTopologyGenerator"                , ATT_INTER_SITE_TOPOLOGY_GENERATOR            , SYNTAX_DISTNAME_TYPE              , L"Inter-Site-Topology-Generator"             , 0                                             },
    { L"interSiteTopologyRenew"                    , ATT_INTER_SITE_TOPOLOGY_RENEW                , SYNTAX_INTEGER_TYPE               , L"Inter-Site-Topology-Renew"                 , 0                                             },
    { L"internationalISDNNumber"                   , ATT_INTERNATIONAL_ISDN_NUMBER                , SYNTAX_NUMERIC_STRING_TYPE        , L"International-ISDN-Number"                 , 0                                             },
    { L"invocationId"                              , ATT_INVOCATION_ID                            , SYNTAX_OCTET_STRING_TYPE          , L"Invocation-Id"                             , 0                                             },
    { L"ipsecData"                                 , ATT_IPSEC_DATA                               , SYNTAX_OCTET_STRING_TYPE          , L"Ipsec-Data"                                , 0                                             },
    { L"ipsecDataType"                             , ATT_IPSEC_DATA_TYPE                          , SYNTAX_INTEGER_TYPE               , L"Ipsec-Data-Type"                           , 0                                             },
    { L"ipsecFilterReference"                      , ATT_IPSEC_FILTER_REFERENCE                   , SYNTAX_DISTNAME_TYPE              , L"Ipsec-Filter-Reference"                    , 0                                             },
    { L"ipsecID"                                   , ATT_IPSEC_ID                                 , SYNTAX_UNICODE_TYPE               , L"Ipsec-ID"                                  , 0                                             },
    { L"ipsecISAKMPReference"                      , ATT_IPSEC_ISAKMP_REFERENCE                   , SYNTAX_DISTNAME_TYPE              , L"Ipsec-ISAKMP-Reference"                    , 0                                             },
    { L"ipsecName"                                 , ATT_IPSEC_NAME                               , SYNTAX_UNICODE_TYPE               , L"Ipsec-Name"                                , 0                                             },
    { L"iPSECNegotiationPolicyAction"              , ATT_IPSEC_NEGOTIATION_POLICY_ACTION          , SYNTAX_UNICODE_TYPE               , L"IPSEC-Negotiation-Policy-Action"           , 0                                             },
    { L"ipsecNegotiationPolicyReference"           , ATT_IPSEC_NEGOTIATION_POLICY_REFERENCE       , SYNTAX_DISTNAME_TYPE              , L"Ipsec-Negotiation-Policy-Reference"        , 0                                             },
    { L"iPSECNegotiationPolicyType"                , ATT_IPSEC_NEGOTIATION_POLICY_TYPE            , SYNTAX_UNICODE_TYPE               , L"IPSEC-Negotiation-Policy-Type"             , 0                                             },
    { L"ipsecNFAReference"                         , ATT_IPSEC_NFA_REFERENCE                      , SYNTAX_DISTNAME_TYPE              , L"Ipsec-NFA-Reference"                       , 0                                             },
    { L"ipsecOwnersReference"                      , ATT_IPSEC_OWNERS_REFERENCE                   , SYNTAX_DISTNAME_TYPE              , L"Ipsec-Owners-Reference"                    , 0                                             },
    { L"ipsecPolicyReference"                      , ATT_IPSEC_POLICY_REFERENCE                   , SYNTAX_DISTNAME_TYPE              , L"Ipsec-Policy-Reference"                    , 0                                             },
    { L"isCriticalSystemObject"                    , ATT_IS_CRITICAL_SYSTEM_OBJECT                , SYNTAX_BOOLEAN_TYPE               , L"Is-Critical-System-Object"                 , 0                                             },
    { L"isDefunct"                                 , ATT_IS_DEFUNCT                               , SYNTAX_BOOLEAN_TYPE               , L"Is-Defunct"                                , 0                                             },
    { L"isDeleted"                                 , ATT_IS_DELETED                               , SYNTAX_BOOLEAN_TYPE               , L"Is-Deleted"                                , 0                                             },
    { L"isEphemeral"                               , ATT_IS_EPHEMERAL                             , SYNTAX_BOOLEAN_TYPE               , L"Is-Ephemeral"                              , 0                                             },
    { L"memberOf"                                  , ATT_IS_MEMBER_OF_DL                          , SYNTAX_DISTNAME_TYPE              , L"Is-Member-Of-DL"                           , 0                                             },
    { L"isMemberOfPartialAttributeSet"             , ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET       , SYNTAX_BOOLEAN_TYPE               , L"Is-Member-Of-Partial-Attribute-Set"        , 0                                             },
    { L"isPrivilegeHolder"                         , ATT_IS_PRIVILEGE_HOLDER                      , SYNTAX_DISTNAME_TYPE              , L"Is-Privilege-Holder"                       , 0                                             },
    { L"isSingleValued"                            , ATT_IS_SINGLE_VALUED                         , SYNTAX_BOOLEAN_TYPE               , L"Is-Single-Valued"                          , 0                                             },
    { L"keywords"                                  , ATT_KEYWORDS                                 , SYNTAX_UNICODE_TYPE               , L"Keywords"                                  , 0                                             },
    { L"knowledgeInformation"                      , ATT_KNOWLEDGE_INFORMATION                    , SYNTAX_NOCASE_STRING_TYPE         , L"Knowledge-Information"                     , 0                                             },
    { L"lastBackupRestorationTime"                 , ATT_LAST_BACKUP_RESTORATION_TIME             , SYNTAX_I8_TYPE                    , L"Last-Backup-Restoration-Time"              , 0                                             },
    { L"lastContentIndexed"                        , ATT_LAST_CONTENT_INDEXED                     , SYNTAX_I8_TYPE                    , L"Last-Content-Indexed"                      , 0                                             },
    { L"lastKnownParent"                           , ATT_LAST_KNOWN_PARENT                        , SYNTAX_DISTNAME_TYPE              , L"Last-Known-Parent"                         , 0                                             },
    { L"lastLogoff"                                , ATT_LAST_LOGOFF                              , SYNTAX_I8_TYPE                    , L"Last-Logoff"                               , 0                                             },
    { L"lastLogon"                                 , ATT_LAST_LOGON                               , SYNTAX_I8_TYPE                    , L"Last-Logon"                                , 0                                             },
    { L"lastLogonTimestamp"                        , ATT_LAST_LOGON_TIMESTAMP                     , SYNTAX_I8_TYPE                    , L"Last-Logon-Timestamp"                      , 0                                             },
    { L"lastSetTime"                               , ATT_LAST_SET_TIME                            , SYNTAX_I8_TYPE                    , L"Last-Set-Time"                             , 0                                             },
    { L"lastUpdateSequence"                        , ATT_LAST_UPDATE_SEQUENCE                     , SYNTAX_UNICODE_TYPE               , L"Last-Update-Sequence"                      , 0                                             },
    { L"lDAPAdminLimits"                           , ATT_LDAP_ADMIN_LIMITS                        , SYNTAX_UNICODE_TYPE               , L"LDAP-Admin-Limits"                         , 0                                             },
    { L"lDAPDisplayName"                           , ATT_LDAP_DISPLAY_NAME                        , SYNTAX_UNICODE_TYPE               , L"LDAP-Display-Name"                         , 0                                             },
    { L"lDAPIPDenyList"                            , ATT_LDAP_IPDENY_LIST                         , SYNTAX_OCTET_STRING_TYPE          , L"LDAP-IPDeny-List"                          , 0                                             },
    { L"legacyExchangeDN"                          , ATT_LEGACY_EXCHANGE_DN                       , SYNTAX_NOCASE_STRING_TYPE         , L"Legacy-Exchange-DN"                        , 0                                             },
    { L"linkID"                                    , ATT_LINK_ID                                  , SYNTAX_INTEGER_TYPE               , L"Link-ID"                                   , 0                                             },
    { L"linkTrackSecret"                           , ATT_LINK_TRACK_SECRET                        , SYNTAX_OCTET_STRING_TYPE          , L"Link-Track-Secret"                         , 0                                             },
    { L"lmPwdHistory"                              , ATT_LM_PWD_HISTORY                           , SYNTAX_OCTET_STRING_TYPE          , L"Lm-Pwd-History"                            , 0                                             },
    { L"localPolicyFlags"                          , ATT_LOCAL_POLICY_FLAGS                       , SYNTAX_INTEGER_TYPE               , L"Local-Policy-Flags"                        , 0                                             },
    { L"localPolicyReference"                      , ATT_LOCAL_POLICY_REFERENCE                   , SYNTAX_DISTNAME_TYPE              , L"Local-Policy-Reference"                    , 0                                             },
    { L"localeID"                                  , ATT_LOCALE_ID                                , SYNTAX_INTEGER_TYPE               , L"Locale-ID"                                 , 0                                             },
    { L"l"                                         , ATT_LOCALITY_NAME                            , SYNTAX_UNICODE_TYPE               , L"Locality-Name"                             , 0                                             },
    { L"localizedDescription"                      , ATT_LOCALIZED_DESCRIPTION                    , SYNTAX_UNICODE_TYPE               , L"Localized-Description"                     , 0                                             },
    { L"localizationDisplayId"                     , ATT_LOCALIZATION_DISPLAY_ID                  , SYNTAX_INTEGER_TYPE               , L"Localization-Display-Id"                   , 0                                             },
    { L"location"                                  , ATT_LOCATION                                 , SYNTAX_UNICODE_TYPE               , L"Location"                                  , 0                                             },
    { L"lockOutObservationWindow"                  , ATT_LOCK_OUT_OBSERVATION_WINDOW              , SYNTAX_I8_TYPE                    , L"Lock-Out-Observation-Window"               , 0                                             },
    { L"lockoutDuration"                           , ATT_LOCKOUT_DURATION                         , SYNTAX_I8_TYPE                    , L"Lockout-Duration"                          , 0                                             },
    { L"lockoutThreshold"                          , ATT_LOCKOUT_THRESHOLD                        , SYNTAX_INTEGER_TYPE               , L"Lockout-Threshold"                         , 0                                             },
    { L"lockoutTime"                               , ATT_LOCKOUT_TIME                             , SYNTAX_I8_TYPE                    , L"Lockout-Time"                              , 0                                             },
    { L"thumbnailLogo"                             , ATT_LOGO                                     , SYNTAX_OCTET_STRING_TYPE          , L"Logo"                                      , 0                                             },
    { L"logonCount"                                , ATT_LOGON_COUNT                              , SYNTAX_INTEGER_TYPE               , L"Logon-Count"                               , 0                                             },
    { L"logonHours"                                , ATT_LOGON_HOURS                              , SYNTAX_OCTET_STRING_TYPE          , L"Logon-Hours"                               , 0                                             },
    { L"logonWorkstation"                          , ATT_LOGON_WORKSTATION                        , SYNTAX_OCTET_STRING_TYPE          , L"Logon-Workstation"                         , 0                                             },
    { L"lSACreationTime"                           , ATT_LSA_CREATION_TIME                        , SYNTAX_I8_TYPE                    , L"LSA-Creation-Time"                         , 0                                             },
    { L"lSAModifiedCount"                          , ATT_LSA_MODIFIED_COUNT                       , SYNTAX_I8_TYPE                    , L"LSA-Modified-Count"                        , 0                                             },
    { L"machineArchitecture"                       , ATT_MACHINE_ARCHITECTURE                     , SYNTAX_INTEGER_TYPE               , L"Machine-Architecture"                      , 0                                             },
    { L"machinePasswordChangeInterval"             , ATT_MACHINE_PASSWORD_CHANGE_INTERVAL         , SYNTAX_I8_TYPE                    , L"Machine-Password-Change-Interval"          , 0                                             },
    { L"machineRole"                               , ATT_MACHINE_ROLE                             , SYNTAX_INTEGER_TYPE               , L"Machine-Role"                              , 0                                             },
    { L"machineWidePolicy"                         , ATT_MACHINE_WIDE_POLICY                      , SYNTAX_OCTET_STRING_TYPE          , L"Machine-Wide-Policy"                       , 0                                             },
    { L"managedBy"                                 , ATT_MANAGED_BY                               , SYNTAX_DISTNAME_TYPE              , L"Managed-By"                                , 0                                             },
    { L"managedObjects"                            , ATT_MANAGED_OBJECTS                          , SYNTAX_DISTNAME_TYPE              , L"Managed-Objects"                           , 0                                             },
    { L"manager"                                   , ATT_MANAGER                                  , SYNTAX_DISTNAME_TYPE              , L"Manager"                                   , 0                                             },
    { L"mAPIID"                                    , ATT_MAPI_ID                                  , SYNTAX_INTEGER_TYPE               , L"MAPI-ID"                                   , 0                                             },
    { L"marshalledInterface"                       , ATT_MARSHALLED_INTERFACE                     , SYNTAX_OCTET_STRING_TYPE          , L"Marshalled-Interface"                      , 0                                             },
    { L"masteredBy"                                , ATT_MASTERED_BY                              , SYNTAX_DISTNAME_TYPE              , L"Mastered-By"                               , 0                                             },
    { L"maxPwdAge"                                 , ATT_MAX_PWD_AGE                              , SYNTAX_I8_TYPE                    , L"Max-Pwd-Age"                               , 0                                             },
    { L"maxRenewAge"                               , ATT_MAX_RENEW_AGE                            , SYNTAX_I8_TYPE                    , L"Max-Renew-Age"                             , 0                                             },
    { L"maxStorage"                                , ATT_MAX_STORAGE                              , SYNTAX_I8_TYPE                    , L"Max-Storage"                               , 0                                             },
    { L"maxTicketAge"                              , ATT_MAX_TICKET_AGE                           , SYNTAX_I8_TYPE                    , L"Max-Ticket-Age"                            , 0                                             },
    { L"mayContain"                                , ATT_MAY_CONTAIN                              , SYNTAX_OBJECT_ID_TYPE             , L"May-Contain"                               , 0                                             },
    { L"meetingAdvertiseScope"                     , ATT_MEETINGADVERTISESCOPE                    , SYNTAX_UNICODE_TYPE               , L"meetingAdvertiseScope"                     , 0                                             },
    { L"meetingApplication"                        , ATT_MEETINGAPPLICATION                       , SYNTAX_UNICODE_TYPE               , L"meetingApplication"                        , 0                                             },
    { L"meetingBandwidth"                          , ATT_MEETINGBANDWIDTH                         , SYNTAX_INTEGER_TYPE               , L"meetingBandwidth"                          , 0                                             },
    { L"meetingBlob"                               , ATT_MEETINGBLOB                              , SYNTAX_OCTET_STRING_TYPE          , L"meetingBlob"                               , 0                                             },
    { L"meetingContactInfo"                        , ATT_MEETINGCONTACTINFO                       , SYNTAX_UNICODE_TYPE               , L"meetingContactInfo"                        , 0                                             },
    { L"meetingDescription"                        , ATT_MEETINGDESCRIPTION                       , SYNTAX_UNICODE_TYPE               , L"meetingDescription"                        , 0                                             },
    { L"meetingEndTime"                            , ATT_MEETINGENDTIME                           , SYNTAX_TIME_TYPE                  , L"meetingEndTime"                            , 0                                             },
    { L"meetingID"                                 , ATT_MEETINGID                                , SYNTAX_UNICODE_TYPE               , L"meetingID"                                 , 0                                             },
    { L"meetingIP"                                 , ATT_MEETINGIP                                , SYNTAX_UNICODE_TYPE               , L"meetingIP"                                 , 0                                             },
    { L"meetingIsEncrypted"                        , ATT_MEETINGISENCRYPTED                       , SYNTAX_UNICODE_TYPE               , L"meetingIsEncrypted"                        , 0                                             },
    { L"meetingKeyword"                            , ATT_MEETINGKEYWORD                           , SYNTAX_UNICODE_TYPE               , L"meetingKeyword"                            , 0                                             },
    { L"meetingLanguage"                           , ATT_MEETINGLANGUAGE                          , SYNTAX_UNICODE_TYPE               , L"meetingLanguage"                           , 0                                             },
    { L"meetingLocation"                           , ATT_MEETINGLOCATION                          , SYNTAX_UNICODE_TYPE               , L"meetingLocation"                           , 0                                             },
    { L"meetingMaxParticipants"                    , ATT_MEETINGMAXPARTICIPANTS                   , SYNTAX_INTEGER_TYPE               , L"meetingMaxParticipants"                    , 0                                             },
    { L"meetingName"                               , ATT_MEETINGNAME                              , SYNTAX_UNICODE_TYPE               , L"meetingName"                               , 0                                             },
    { L"meetingOriginator"                         , ATT_MEETINGORIGINATOR                        , SYNTAX_UNICODE_TYPE               , L"meetingOriginator"                         , 0                                             },
    { L"meetingOwner"                              , ATT_MEETINGOWNER                             , SYNTAX_UNICODE_TYPE               , L"meetingOwner"                              , 0                                             },
    { L"meetingProtocol"                           , ATT_MEETINGPROTOCOL                          , SYNTAX_UNICODE_TYPE               , L"meetingProtocol"                           , 0                                             },
    { L"meetingRating"                             , ATT_MEETINGRATING                            , SYNTAX_UNICODE_TYPE               , L"meetingRating"                             , 0                                             },
    { L"meetingRecurrence"                         , ATT_MEETINGRECURRENCE                        , SYNTAX_UNICODE_TYPE               , L"meetingRecurrence"                         , 0                                             },
    { L"meetingScope"                              , ATT_MEETINGSCOPE                             , SYNTAX_UNICODE_TYPE               , L"meetingScope"                              , 0                                             },
    { L"meetingStartTime"                          , ATT_MEETINGSTARTTIME                         , SYNTAX_TIME_TYPE                  , L"meetingStartTime"                          , 0                                             },
    { L"meetingType"                               , ATT_MEETINGTYPE                              , SYNTAX_UNICODE_TYPE               , L"meetingType"                               , 0                                             },
    { L"meetingURL"                                , ATT_MEETINGURL                               , SYNTAX_UNICODE_TYPE               , L"meetingURL"                                , 0                                             },
    { L"member"                                    , ATT_MEMBER                                   , SYNTAX_DISTNAME_TYPE              , L"Member"                                    , 0                                             },
    { L"mhsORAddress"                              , ATT_MHS_OR_ADDRESS                           , SYNTAX_UNICODE_TYPE               , L"MHS-OR-Address"                            , 0                                             },
    { L"minPwdAge"                                 , ATT_MIN_PWD_AGE                              , SYNTAX_I8_TYPE                    , L"Min-Pwd-Age"                               , 0                                             },
    { L"minPwdLength"                              , ATT_MIN_PWD_LENGTH                           , SYNTAX_INTEGER_TYPE               , L"Min-Pwd-Length"                            , 0                                             },
    { L"minTicketAge"                              , ATT_MIN_TICKET_AGE                           , SYNTAX_I8_TYPE                    , L"Min-Ticket-Age"                            , 0                                             },
    { L"modifiedCount"                             , ATT_MODIFIED_COUNT                           , SYNTAX_I8_TYPE                    , L"Modified-Count"                            , 0                                             },
    { L"modifiedCountAtLastProm"                   , ATT_MODIFIED_COUNT_AT_LAST_PROM              , SYNTAX_I8_TYPE                    , L"Modified-Count-At-Last-Prom"               , 0                                             },
    { L"modifyTimeStamp"                           , ATT_MODIFY_TIME_STAMP                        , SYNTAX_TIME_TYPE                  , L"Modify-Time-Stamp"                         , 0                                             },
    { L"moniker"                                   , ATT_MONIKER                                  , SYNTAX_OCTET_STRING_TYPE          , L"Moniker"                                   , 0                                             },
    { L"monikerDisplayName"                        , ATT_MONIKER_DISPLAY_NAME                     , SYNTAX_UNICODE_TYPE               , L"Moniker-Display-Name"                      , 0                                             },
    { L"moveTreeState"                             , ATT_MOVE_TREE_STATE                          , SYNTAX_OCTET_STRING_TYPE          , L"Move-Tree-State"                           , 0                                             },
    { L"msCOM-DefaultPartitionLink"                , ATT_MS_COM_DEFAULTPARTITIONLINK              , SYNTAX_DISTNAME_TYPE              , L"ms-COM-DefaultPartitionLink"               , 0                                             },
    { L"msCOM-ObjectId"                            , ATT_MS_COM_OBJECTID                          , SYNTAX_OCTET_STRING_TYPE          , L"ms-COM-ObjectId"                           , 0                                             },
    { L"msCOM-PartitionLink"                       , ATT_MS_COM_PARTITIONLINK                     , SYNTAX_DISTNAME_TYPE              , L"ms-COM-PartitionLink"                      , 0                                             },
    { L"msCOM-PartitionSetLink"                    , ATT_MS_COM_PARTITIONSETLINK                  , SYNTAX_DISTNAME_TYPE              , L"ms-COM-PartitionSetLink"                   , 0                                             },
    { L"msCOM-UserLink"                            , ATT_MS_COM_USERLINK                          , SYNTAX_DISTNAME_TYPE              , L"ms-COM-UserLink"                           , 0                                             },
    { L"msCOM-UserPartitionSetLink"                , ATT_MS_COM_USERPARTITIONSETLINK              , SYNTAX_DISTNAME_TYPE              , L"ms-COM-UserPartitionSetLink"               , 0                                             },
    { L"msDS-AllowedDNSSuffixes"                   , ATT_MS_DS_ALLOWED_DNS_SUFFIXES               , SYNTAX_UNICODE_TYPE               , L"ms-DS-Allowed-DNS-Suffixes"                , 0                                             },
    { L"msDS-Auxiliary-Classes"                    , ATT_MS_DS_AUXILIARY_CLASSES                  , SYNTAX_OBJECT_ID_TYPE             , L"ms-DS-Auxiliary-Classes"                   , 0                                             },
    { L"msDS-Approx-Immed-Subordinates"            , ATT_MS_DS_APPROX_IMMED_SUBORDINATES          , SYNTAX_INTEGER_TYPE               , L"ms-DS-Approx-Immed-Subordinates"           , 0                                             },
    { L"msDS-Behavior-Version"                     , ATT_MS_DS_BEHAVIOR_VERSION                   , SYNTAX_INTEGER_TYPE               , L"ms-DS-Behavior-Version"                    , 0                                             },
    { L"msDS-Cached-Membership"                    , ATT_MS_DS_CACHED_MEMBERSHIP                  , SYNTAX_OCTET_STRING_TYPE          , L"ms-DS-Cached-Membership"                   , 0                                             },
    { L"msDS-Cached-Membership-Time-Stamp"         , ATT_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP       , SYNTAX_I8_TYPE                    , L"ms-DS-Cached-Membership-Time-Stamp"        , 0                                             },
    { L"mS-DS-ConsistencyGuid"                     , ATT_MS_DS_CONSISTENCY_GUID                   , SYNTAX_OCTET_STRING_TYPE          , L"MS-DS-Consistency-Guid"                    , 0                                             },
    { L"mS-DS-ConsistencyChildCount"               , ATT_MS_DS_CONSISTENCY_CHILD_COUNT            , SYNTAX_INTEGER_TYPE               , L"MS-DS-Consistency-Child-Count"             , 0                                             },
    { L"mS-DS-CreatorSID"                          , ATT_MS_DS_CREATOR_SID                        , SYNTAX_SID_TYPE                   , L"MS-DS-Creator-SID"                         , 0                                             },
    { L"msDS-Entry-Time-To-Die"                    , ATT_MS_DS_ENTRY_TIME_TO_DIE                  , SYNTAX_TIME_TYPE                  , L"ms-DS-Entry-Time-To-Die"                   , 0                                             },
    { L"msDS-FilterContainers"                     , ATT_MS_DS_FILTER_CONTAINERS                  , SYNTAX_UNICODE_TYPE               , L"ms-DS-Filter-Containers"                   , 0                                             },
    { L"msDS-HasInstantiatedNCs"                   , ATT_MS_DS_HAS_INSTANTIATED_NCS               , SYNTAX_DISTNAME_BINARY_TYPE       , L"ms-DS-Has-Instantiated-NCs"                , 0                                             },
    { L"msDS-TrustForestTrustInfo"                 , ATT_MS_DS_TRUST_FOREST_TRUST_INFO            , SYNTAX_OCTET_STRING_TYPE          , L"ms-DS-Trust-Forest-Trust-Info"             , 0                                             },
    { L"ms-DS-MachineAccountQuota"                 , ATT_MS_DS_MACHINE_ACCOUNT_QUOTA              , SYNTAX_INTEGER_TYPE               , L"MS-DS-Machine-Account-Quota"               , 0                                             },
    { L"msDS-Other-Settings"                       , ATT_MS_DS_OTHER_SETTINGS                     , SYNTAX_UNICODE_TYPE               , L"ms-DS-Other-Settings"                      , 0                                             },
    { L"msDS-NCReplCursors"                        , ATT_MS_DS_NC_REPL_CURSORS                    , SYNTAX_UNICODE_TYPE               , L"ms-DS-NC-Repl-Cursors"                     , 0                                             },
    { L"msDS-NCReplInboundNeighbors"               , ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS          , SYNTAX_UNICODE_TYPE               , L"ms-DS-NC-Repl-Inbound-Neighbors"           , 0                                             },
    { L"msDS-NCReplOutboundNeighbors"              , ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS         , SYNTAX_UNICODE_TYPE               , L"ms-DS-NC-Repl-Outbound-Neighbors"          , 0                                             },
    { L"msDS-NC-Replica-Locations"                 , ATT_MS_DS_NC_REPLICA_LOCATIONS               , SYNTAX_DISTNAME_TYPE              , L"ms-DS-NC-Replica-Locations"                , 0                                             },
    { L"msDS-Non-Security-Group-Extra-Classes"     , ATT_MS_DS_NON_SECURITY_GROUP_EXTRA_CLASSES   , SYNTAX_UNICODE_TYPE               , L"ms-DS-Non-Security-Group-Extra-Classes"    , 0                                             },
    { L"msDS-Preferred-GC-Site"                    , ATT_MS_DS_PREFERRED_GC_SITE                  , SYNTAX_DISTNAME_TYPE              , L"ms-DS-Preferred-GC-Site"                   , 0                                             },
    { L"msDS-ReplAttributeMetaData"                , ATT_MS_DS_REPL_ATTRIBUTE_META_DATA           , SYNTAX_UNICODE_TYPE               , L"ms-DS-Repl-Attribute-Meta-Data"            , 0                                             },
    { L"msDS-ReplValueMetaData"                    , ATT_MS_DS_REPL_VALUE_META_DATA               , SYNTAX_UNICODE_TYPE               , L"ms-DS-Repl-Value-Meta-Data"                , 0                                             },
    { L"mS-DS-ReplicatesNCReason"                  , ATT_MS_DS_REPLICATES_NC_REASON               , SYNTAX_DISTNAME_BINARY_TYPE       , L"MS-DS-Replicates-NC-Reason"                , 0                                             },
    { L"msDS-Replication-Notify-First-DSA-Delay"   , ATT_MS_DS_REPLICATION_NOTIFY_FIRST_DSA_DELAY , SYNTAX_INTEGER_TYPE               , L"ms-DS-Replication-Notify-First-DSA-Delay"  , 0                                             },
    { L"msDS-Replication-Notify-Subsequent-DSA-Delay", ATT_MS_DS_REPLICATION_NOTIFY_SUBSEQUENT_DSA_DELAY, SYNTAX_INTEGER_TYPE               , L"ms-DS-Replication-Notify-Subsequent-DSA-Delay", 0                                             },
    { L"msDs-Schema-Extensions"                    , ATT_MS_DS_SCHEMA_EXTENSIONS                  , SYNTAX_OCTET_STRING_TYPE          , L"ms-ds-Schema-Extensions"                   , 0                                             },
    { L"msDS-SDReferenceDomain"                    , ATT_MS_DS_SD_REFERENCE_DOMAIN                , SYNTAX_DISTNAME_TYPE              , L"ms-DS-SD-Reference-Domain"                 , 0                                             },
    { L"msDS-Security-Group-Extra-Classes"         , ATT_MS_DS_SECURITY_GROUP_EXTRA_CLASSES       , SYNTAX_UNICODE_TYPE               , L"ms-DS-Security-Group-Extra-Classes"        , 0                                             },
    { L"msDS-Settings"                             , ATT_MS_DS_SETTINGS                           , SYNTAX_UNICODE_TYPE               , L"ms-DS-Settings"                            , 0                                             },
    { L"msDS-Site-Affinity"                        , ATT_MS_DS_SITE_AFFINITY                      , SYNTAX_OCTET_STRING_TYPE          , L"ms-DS-Site-Affinity"                       , 0                                             },
    { L"msDS-User-Account-Control-Computed"        , ATT_MS_DS_USER_ACCOUNT_CONTROL_COMPUTED      , SYNTAX_INTEGER_TYPE               , L"ms-DS-User-Account-Control-Computed"       , 0                                             },
    { L"ownerBL"                                   , ATT_MS_EXCH_OWNER_BL                         , SYNTAX_DISTNAME_TYPE              , L"ms-Exch-Owner-BL"                          , 0                                             },
    { L"msFRS-Hub-Member"                          , ATT_MS_FRS_HUB_MEMBER                        , SYNTAX_DISTNAME_TYPE              , L"ms-FRS-Hub-Member"                         , 0                                             },
    { L"msFRS-Topology-Pref"                       , ATT_MS_FRS_TOPOLOGY_PREF                     , SYNTAX_UNICODE_TYPE               , L"ms-FRS-Topology-Pref"                      , 0                                             },
    { L"msPKI-Cert-Template-OID"                   , ATT_MS_PKI_CERT_TEMPLATE_OID                 , SYNTAX_UNICODE_TYPE               , L"ms-PKI-Cert-Template-OID"                  , 0                                             },
    { L"msPKI-Certificate-Application-Policy"      , ATT_MS_PKI_CERTIFICATE_APPLICATION_POLICY    , SYNTAX_UNICODE_TYPE               , L"ms-PKI-Certificate-Application-Policy"     , 0                                             },
    { L"msPKI-Certificate-Name-Flag"               , ATT_MS_PKI_CERTIFICATE_NAME_FLAG             , SYNTAX_INTEGER_TYPE               , L"ms-PKI-Certificate-Name-Flag"              , 0                                             },
    { L"msPKI-Certificate-Policy"                  , ATT_MS_PKI_CERTIFICATE_POLICY                , SYNTAX_UNICODE_TYPE               , L"ms-PKI-Certificate-Policy"                 , 0                                             },
    { L"msPKI-Enrollment-Flag"                     , ATT_MS_PKI_ENROLLMENT_FLAG                   , SYNTAX_INTEGER_TYPE               , L"ms-PKI-Enrollment-Flag"                    , 0                                             },
    { L"msPKI-Minimal-Key-Size"                    , ATT_MS_PKI_MINIMAL_KEY_SIZE                  , SYNTAX_INTEGER_TYPE               , L"ms-PKI-Minimal-Key-Size"                   , 0                                             },
    { L"msPKI-OID-Attribute"                       , ATT_MS_PKI_OID_ATTRIBUTE                     , SYNTAX_INTEGER_TYPE               , L"ms-PKI-OID-Attribute"                      , 0                                             },
    { L"msPKI-OID-CPS"                             , ATT_MS_PKI_OID_CPS                           , SYNTAX_UNICODE_TYPE               , L"ms-PKI-OID-CPS"                            , 0                                             },
    { L"msPKI-OID-User-Notice"                     , ATT_MS_PKI_OID_USER_NOTICE                   , SYNTAX_UNICODE_TYPE               , L"ms-PKI-OID-User-Notice"                    , 0                                             },
    { L"msPKI-Private-Key-Flag"                    , ATT_MS_PKI_PRIVATE_KEY_FLAG                  , SYNTAX_INTEGER_TYPE               , L"ms-PKI-Private-Key-Flag"                   , 0                                             },
    { L"msPKI-Supersede-Templates"                 , ATT_MS_PKI_SUPERSEDE_TEMPLATES               , SYNTAX_UNICODE_TYPE               , L"ms-PKI-Supersede-Templates"                , 0                                             },
    { L"msPKI-Template-Minor-Revision"             , ATT_MS_PKI_TEMPLATE_MINOR_REVISION           , SYNTAX_INTEGER_TYPE               , L"ms-PKI-Template-Minor-Revision"            , 0                                             },
    { L"msPKI-Template-Schema-Version"             , ATT_MS_PKI_TEMPLATE_SCHEMA_VERSION           , SYNTAX_INTEGER_TYPE               , L"ms-PKI-Template-Schema-Version"            , 0                                             },
    { L"msPKI-RA-Application-Policies"             , ATT_MS_PKI_RA_APPLICATION_POLICIES           , SYNTAX_UNICODE_TYPE               , L"ms-PKI-RA-Application-Policies"            , 0                                             },
    { L"msPKI-RA-Policies"                         , ATT_MS_PKI_RA_POLICIES                       , SYNTAX_UNICODE_TYPE               , L"ms-PKI-RA-Policies"                        , 0                                             },
    { L"msPKI-RA-Signature"                        , ATT_MS_PKI_RA_SIGNATURE                      , SYNTAX_INTEGER_TYPE               , L"ms-PKI-RA-Signature"                       , 0                                             },
    { L"msRRASAttribute"                           , ATT_MS_RRAS_ATTRIBUTE                        , SYNTAX_UNICODE_TYPE               , L"ms-RRAS-Attribute"                         , 0                                             },
    { L"msRRASVendorAttributeEntry"                , ATT_MS_RRAS_VENDOR_ATTRIBUTE_ENTRY           , SYNTAX_UNICODE_TYPE               , L"ms-RRAS-Vendor-Attribute-Entry"            , 0                                             },
    { L"mS-SQL-Name"                               , ATT_MS_SQL_NAME                              , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Name"                               , 0                                             },
    { L"mS-SQL-RegisteredOwner"                    , ATT_MS_SQL_REGISTEREDOWNER                   , SYNTAX_UNICODE_TYPE               , L"MS-SQL-RegisteredOwner"                    , 0                                             },
    { L"mS-SQL-Contact"                            , ATT_MS_SQL_CONTACT                           , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Contact"                            , 0                                             },
    { L"mS-SQL-Location"                           , ATT_MS_SQL_LOCATION                          , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Location"                           , 0                                             },
    { L"mS-SQL-Memory"                             , ATT_MS_SQL_MEMORY                            , SYNTAX_I8_TYPE                    , L"MS-SQL-Memory"                             , 0                                             },
    { L"mS-SQL-Build"                              , ATT_MS_SQL_BUILD                             , SYNTAX_INTEGER_TYPE               , L"MS-SQL-Build"                              , 0                                             },
    { L"mS-SQL-ServiceAccount"                     , ATT_MS_SQL_SERVICEACCOUNT                    , SYNTAX_UNICODE_TYPE               , L"MS-SQL-ServiceAccount"                     , 0                                             },
    { L"mS-SQL-CharacterSet"                       , ATT_MS_SQL_CHARACTERSET                      , SYNTAX_INTEGER_TYPE               , L"MS-SQL-CharacterSet"                       , 0                                             },
    { L"mS-SQL-SortOrder"                          , ATT_MS_SQL_SORTORDER                         , SYNTAX_UNICODE_TYPE               , L"MS-SQL-SortOrder"                          , 0                                             },
    { L"mS-SQL-UnicodeSortOrder"                   , ATT_MS_SQL_UNICODESORTORDER                  , SYNTAX_INTEGER_TYPE               , L"MS-SQL-UnicodeSortOrder"                   , 0                                             },
    { L"mS-SQL-Clustered"                          , ATT_MS_SQL_CLUSTERED                         , SYNTAX_BOOLEAN_TYPE               , L"MS-SQL-Clustered"                          , 0                                             },
    { L"mS-SQL-NamedPipe"                          , ATT_MS_SQL_NAMEDPIPE                         , SYNTAX_UNICODE_TYPE               , L"MS-SQL-NamedPipe"                          , 0                                             },
    { L"mS-SQL-MultiProtocol"                      , ATT_MS_SQL_MULTIPROTOCOL                     , SYNTAX_UNICODE_TYPE               , L"MS-SQL-MultiProtocol"                      , 0                                             },
    { L"mS-SQL-SPX"                                , ATT_MS_SQL_SPX                               , SYNTAX_UNICODE_TYPE               , L"MS-SQL-SPX"                                , 0                                             },
    { L"mS-SQL-TCPIP"                              , ATT_MS_SQL_TCPIP                             , SYNTAX_UNICODE_TYPE               , L"MS-SQL-TCPIP"                              , 0                                             },
    { L"mS-SQL-AppleTalk"                          , ATT_MS_SQL_APPLETALK                         , SYNTAX_UNICODE_TYPE               , L"MS-SQL-AppleTalk"                          , 0                                             },
    { L"mS-SQL-Vines"                              , ATT_MS_SQL_VINES                             , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Vines"                              , 0                                             },
    { L"mS-SQL-Status"                             , ATT_MS_SQL_STATUS                            , SYNTAX_I8_TYPE                    , L"MS-SQL-Status"                             , 0                                             },
    { L"mS-SQL-LastUpdatedDate"                    , ATT_MS_SQL_LASTUPDATEDDATE                   , SYNTAX_UNICODE_TYPE               , L"MS-SQL-LastUpdatedDate"                    , 0                                             },
    { L"mS-SQL-InformationURL"                     , ATT_MS_SQL_INFORMATIONURL                    , SYNTAX_UNICODE_TYPE               , L"MS-SQL-InformationURL"                     , 0                                             },
    { L"mS-SQL-ConnectionURL"                      , ATT_MS_SQL_CONNECTIONURL                     , SYNTAX_UNICODE_TYPE               , L"MS-SQL-ConnectionURL"                      , 0                                             },
    { L"mS-SQL-PublicationURL"                     , ATT_MS_SQL_PUBLICATIONURL                    , SYNTAX_UNICODE_TYPE               , L"MS-SQL-PublicationURL"                     , 0                                             },
    { L"mS-SQL-GPSLatitude"                        , ATT_MS_SQL_GPSLATITUDE                       , SYNTAX_UNICODE_TYPE               , L"MS-SQL-GPSLatitude"                        , 0                                             },
    { L"mS-SQL-GPSLongitude"                       , ATT_MS_SQL_GPSLONGITUDE                      , SYNTAX_UNICODE_TYPE               , L"MS-SQL-GPSLongitude"                       , 0                                             },
    { L"mS-SQL-GPSHeight"                          , ATT_MS_SQL_GPSHEIGHT                         , SYNTAX_UNICODE_TYPE               , L"MS-SQL-GPSHeight"                          , 0                                             },
    { L"mS-SQL-Version"                            , ATT_MS_SQL_VERSION                           , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Version"                            , 0                                             },
    { L"mS-SQL-Language"                           , ATT_MS_SQL_LANGUAGE                          , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Language"                           , 0                                             },
    { L"mS-SQL-Description"                        , ATT_MS_SQL_DESCRIPTION                       , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Description"                        , 0                                             },
    { L"mS-SQL-Type"                               , ATT_MS_SQL_TYPE                              , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Type"                               , 0                                             },
    { L"mS-SQL-InformationDirectory"               , ATT_MS_SQL_INFORMATIONDIRECTORY              , SYNTAX_BOOLEAN_TYPE               , L"MS-SQL-InformationDirectory"               , 0                                             },
    { L"mS-SQL-Database"                           , ATT_MS_SQL_DATABASE                          , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Database"                           , 0                                             },
    { L"mS-SQL-AllowAnonymousSubscription"         , ATT_MS_SQL_ALLOWANONYMOUSSUBSCRIPTION        , SYNTAX_BOOLEAN_TYPE               , L"MS-SQL-AllowAnonymousSubscription"         , 0                                             },
    { L"mS-SQL-Alias"                              , ATT_MS_SQL_ALIAS                             , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Alias"                              , 0                                             },
    { L"mS-SQL-Size"                               , ATT_MS_SQL_SIZE                              , SYNTAX_I8_TYPE                    , L"MS-SQL-Size"                               , 0                                             },
    { L"mS-SQL-CreationDate"                       , ATT_MS_SQL_CREATIONDATE                      , SYNTAX_UNICODE_TYPE               , L"MS-SQL-CreationDate"                       , 0                                             },
    { L"mS-SQL-LastBackupDate"                     , ATT_MS_SQL_LASTBACKUPDATE                    , SYNTAX_UNICODE_TYPE               , L"MS-SQL-LastBackupDate"                     , 0                                             },
    { L"mS-SQL-LastDiagnosticDate"                 , ATT_MS_SQL_LASTDIAGNOSTICDATE                , SYNTAX_UNICODE_TYPE               , L"MS-SQL-LastDiagnosticDate"                 , 0                                             },
    { L"mS-SQL-Applications"                       , ATT_MS_SQL_APPLICATIONS                      , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Applications"                       , 0                                             },
    { L"mS-SQL-Keywords"                           , ATT_MS_SQL_KEYWORDS                          , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Keywords"                           , 0                                             },
    { L"mS-SQL-Publisher"                          , ATT_MS_SQL_PUBLISHER                         , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Publisher"                          , 0                                             },
    { L"mS-SQL-AllowKnownPullSubscription"         , ATT_MS_SQL_ALLOWKNOWNPULLSUBSCRIPTION        , SYNTAX_BOOLEAN_TYPE               , L"MS-SQL-AllowKnownPullSubscription"         , 0                                             },
    { L"mS-SQL-AllowImmediateUpdatingSubscription" , ATT_MS_SQL_ALLOWIMMEDIATEUPDATINGSUBSCRIPTION, SYNTAX_BOOLEAN_TYPE               , L"MS-SQL-AllowImmediateUpdatingSubscription" , 0                                             },
    { L"mS-SQL-AllowQueuedUpdatingSubscription"    , ATT_MS_SQL_ALLOWQUEUEDUPDATINGSUBSCRIPTION   , SYNTAX_BOOLEAN_TYPE               , L"MS-SQL-AllowQueuedUpdatingSubscription"    , 0                                             },
    { L"mS-SQL-AllowSnapshotFilesFTPDownloading"   , ATT_MS_SQL_ALLOWSNAPSHOTFILESFTPDOWNLOADING  , SYNTAX_BOOLEAN_TYPE               , L"MS-SQL-AllowSnapshotFilesFTPDownloading"   , 0                                             },
    { L"mS-SQL-ThirdParty"                         , ATT_MS_SQL_THIRDPARTY                        , SYNTAX_BOOLEAN_TYPE               , L"MS-SQL-ThirdParty"                         , 0                                             },
    { L"msTAPI-ConferenceBlob"                     , ATT_MS_TAPI_CONFERENCE_BLOB                  , SYNTAX_OCTET_STRING_TYPE          , L"ms-TAPI-Conference-Blob"                   , 0                                             },
    { L"msTAPI-IpAddress"                          , ATT_MS_TAPI_IP_ADDRESS                       , SYNTAX_UNICODE_TYPE               , L"ms-TAPI-Ip-Address"                        , 0                                             },
    { L"msTAPI-ProtocolId"                         , ATT_MS_TAPI_PROTOCOL_ID                      , SYNTAX_UNICODE_TYPE               , L"ms-TAPI-Protocol-Id"                       , 0                                             },
    { L"msTAPI-uid"                                , ATT_MS_TAPI_UNIQUE_IDENTIFIER                , SYNTAX_UNICODE_TYPE               , L"ms-TAPI-Unique-Identifier"                 , 0                                             },
    { L"msWMI-Author"                              , ATT_MS_WMI_AUTHOR                            , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Author"                             , 0                                             },
    { L"msWMI-ChangeDate"                          , ATT_MS_WMI_CHANGEDATE                        , SYNTAX_UNICODE_TYPE               , L"ms-WMI-ChangeDate"                         , 0                                             },
    { L"msWMI-Class"                               , ATT_MS_WMI_CLASS                             , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Class"                              , 0                                             },
    { L"msWMI-ClassDefinition"                     , ATT_MS_WMI_CLASSDEFINITION                   , SYNTAX_UNICODE_TYPE               , L"ms-WMI-ClassDefinition"                    , 0                                             },
    { L"msWMI-CreationDate"                        , ATT_MS_WMI_CREATIONDATE                      , SYNTAX_UNICODE_TYPE               , L"ms-WMI-CreationDate"                       , 0                                             },
    { L"msWMI-Genus"                               , ATT_MS_WMI_GENUS                             , SYNTAX_INTEGER_TYPE               , L"ms-WMI-Genus"                              , 0                                             },
    { L"msWMI-ID"                                  , ATT_MS_WMI_ID                                , SYNTAX_UNICODE_TYPE               , L"ms-WMI-ID"                                 , 0                                             },
    { L"msWMI-IntDefault"                          , ATT_MS_WMI_INTDEFAULT                        , SYNTAX_INTEGER_TYPE               , L"ms-WMI-intDefault"                         , 0                                             },
    { L"msWMI-intFlags1"                           , ATT_MS_WMI_INTFLAGS1                         , SYNTAX_INTEGER_TYPE               , L"ms-WMI-intFlags1"                          , 0                                             },
    { L"msWMI-intFlags2"                           , ATT_MS_WMI_INTFLAGS2                         , SYNTAX_INTEGER_TYPE               , L"ms-WMI-intFlags2"                          , 0                                             },
    { L"msWMI-intFlags3"                           , ATT_MS_WMI_INTFLAGS3                         , SYNTAX_INTEGER_TYPE               , L"ms-WMI-intFlags3"                          , 0                                             },
    { L"msWMI-intFlags4"                           , ATT_MS_WMI_INTFLAGS4                         , SYNTAX_INTEGER_TYPE               , L"ms-WMI-intFlags4"                          , 0                                             },
    { L"msWMI-IntMax"                              , ATT_MS_WMI_INTMAX                            , SYNTAX_INTEGER_TYPE               , L"ms-WMI-intMax"                             , 0                                             },
    { L"msWMI-IntMin"                              , ATT_MS_WMI_INTMIN                            , SYNTAX_INTEGER_TYPE               , L"ms-WMI-intMin"                             , 0                                             },
    { L"msWMI-IntValidValues"                      , ATT_MS_WMI_INTVALIDVALUES                    , SYNTAX_INTEGER_TYPE               , L"ms-WMI-intValidValues"                     , 0                                             },
    { L"msWMI-Int8Default"                         , ATT_MS_WMI_INT8DEFAULT                       , SYNTAX_I8_TYPE                    , L"ms-WMI-int8Default"                        , 0                                             },
    { L"msWMI-Int8Max"                             , ATT_MS_WMI_INT8MAX                           , SYNTAX_I8_TYPE                    , L"ms-WMI-int8Max"                            , 0                                             },
    { L"msWMI-Int8Min"                             , ATT_MS_WMI_INT8MIN                           , SYNTAX_I8_TYPE                    , L"ms-WMI-int8Min"                            , 0                                             },
    { L"msWMI-Int8ValidValues"                     , ATT_MS_WMI_INT8VALIDVALUES                   , SYNTAX_I8_TYPE                    , L"ms-WMI-int8ValidValues"                    , 0                                             },
    { L"msWMI-Mof"                                 , ATT_MS_WMI_MOF                               , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Mof"                                , 0                                             },
    { L"msWMI-Name"                                , ATT_MS_WMI_NAME                              , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Name"                               , 0                                             },
    { L"msWMI-NormalizedClass"                     , ATT_MS_WMI_NORMALIZEDCLASS                   , SYNTAX_UNICODE_TYPE               , L"ms-WMI-NormalizedClass"                    , 0                                             },
    { L"msWMI-Parm1"                               , ATT_MS_WMI_PARM1                             , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Parm1"                              , 0                                             },
    { L"msWMI-Parm2"                               , ATT_MS_WMI_PARM2                             , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Parm2"                              , 0                                             },
    { L"msWMI-Parm3"                               , ATT_MS_WMI_PARM3                             , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Parm3"                              , 0                                             },
    { L"msWMI-Parm4"                               , ATT_MS_WMI_PARM4                             , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Parm4"                              , 0                                             },
    { L"msWMI-PropertyName"                        , ATT_MS_WMI_PROPERTYNAME                      , SYNTAX_UNICODE_TYPE               , L"ms-WMI-PropertyName"                       , 0                                             },
    { L"msWMI-Query"                               , ATT_MS_WMI_QUERY                             , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Query"                              , 0                                             },
    { L"msWMI-QueryLanguage"                       , ATT_MS_WMI_QUERYLANGUAGE                     , SYNTAX_UNICODE_TYPE               , L"ms-WMI-QueryLanguage"                      , 0                                             },
    { L"msWMI-ScopeGuid"                           , ATT_MS_WMI_SCOPEGUID                         , SYNTAX_UNICODE_TYPE               , L"ms-WMI-ScopeGuid"                          , 0                                             },
    { L"msWMI-SourceOrganization"                  , ATT_MS_WMI_SOURCEORGANIZATION                , SYNTAX_UNICODE_TYPE               , L"ms-WMI-SourceOrganization"                 , 0                                             },
    { L"msWMI-StringDefault"                       , ATT_MS_WMI_STRINGDEFAULT                     , SYNTAX_UNICODE_TYPE               , L"ms-WMI-stringDefault"                      , 0                                             },
    { L"msWMI-StringValidValues"                   , ATT_MS_WMI_STRINGVALIDVALUES                 , SYNTAX_UNICODE_TYPE               , L"ms-WMI-stringValidValues"                  , 0                                             },
    { L"msWMI-TargetClass"                         , ATT_MS_WMI_TARGETCLASS                       , SYNTAX_UNICODE_TYPE               , L"ms-WMI-TargetClass"                        , 0                                             },
    { L"msWMI-TargetNameSpace"                     , ATT_MS_WMI_TARGETNAMESPACE                   , SYNTAX_UNICODE_TYPE               , L"ms-WMI-TargetNameSpace"                    , 0                                             },
    { L"msWMI-TargetObject"                        , ATT_MS_WMI_TARGETOBJECT                      , SYNTAX_OCTET_STRING_TYPE          , L"ms-WMI-TargetObject"                       , 0                                             },
    { L"msWMI-TargetPath"                          , ATT_MS_WMI_TARGETPATH                        , SYNTAX_UNICODE_TYPE               , L"ms-WMI-TargetPath"                         , 0                                             },
    { L"msWMI-TargetType"                          , ATT_MS_WMI_TARGETTYPE                        , SYNTAX_UNICODE_TYPE               , L"ms-WMI-TargetType"                         , 0                                             },
    { L"mscopeId"                                  , ATT_MSCOPE_ID                                , SYNTAX_PRINT_CASE_STRING_TYPE     , L"Mscope-Id"                                 , 0                                             },
    { L"msiFileList"                               , ATT_MSI_FILE_LIST                            , SYNTAX_UNICODE_TYPE               , L"Msi-File-List"                             , 0                                             },
    { L"msiScript"                                 , ATT_MSI_SCRIPT                               , SYNTAX_OCTET_STRING_TYPE          , L"Msi-Script"                                , 0                                             },
    { L"msiScriptName"                             , ATT_MSI_SCRIPT_NAME                          , SYNTAX_UNICODE_TYPE               , L"Msi-Script-Name"                           , 0                                             },
    { L"msiScriptPath"                             , ATT_MSI_SCRIPT_PATH                          , SYNTAX_UNICODE_TYPE               , L"Msi-Script-Path"                           , 0                                             },
    { L"msiScriptSize"                             , ATT_MSI_SCRIPT_SIZE                          , SYNTAX_INTEGER_TYPE               , L"Msi-Script-Size"                           , 0                                             },
    { L"mSMQAuthenticate"                          , ATT_MSMQ_AUTHENTICATE                        , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Authenticate"                         , 0                                             },
    { L"mSMQBasePriority"                          , ATT_MSMQ_BASE_PRIORITY                       , SYNTAX_INTEGER_TYPE               , L"MSMQ-Base-Priority"                        , 0                                             },
    { L"mSMQComputerType"                          , ATT_MSMQ_COMPUTER_TYPE                       , SYNTAX_NOCASE_STRING_TYPE         , L"MSMQ-Computer-Type"                        , 0                                             },
    { L"mSMQComputerTypeEx"                        , ATT_MSMQ_COMPUTER_TYPE_EX                    , SYNTAX_UNICODE_TYPE               , L"MSMQ-Computer-Type-Ex"                     , 0                                             },
    { L"mSMQCost"                                  , ATT_MSMQ_COST                                , SYNTAX_INTEGER_TYPE               , L"MSMQ-Cost"                                 , 0                                             },
    { L"mSMQCSPName"                               , ATT_MSMQ_CSP_NAME                            , SYNTAX_NOCASE_STRING_TYPE         , L"MSMQ-CSP-Name"                             , 0                                             },
    { L"mSMQDependentClientService"                , ATT_MSMQ_DEPENDENT_CLIENT_SERVICE            , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Dependent-Client-Service"             , 0                                             },
    { L"mSMQDependentClientServices"               , ATT_MSMQ_DEPENDENT_CLIENT_SERVICES           , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Dependent-Client-Services"            , 0                                             },
    { L"mSMQDigests"                               , ATT_MSMQ_DIGESTS                             , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Digests"                              , 0                                             },
    { L"mSMQDigestsMig"                            , ATT_MSMQ_DIGESTS_MIG                         , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Digests-Mig"                          , 0                                             },
    { L"mSMQDsService"                             , ATT_MSMQ_DS_SERVICE                          , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Ds-Service"                           , 0                                             },
    { L"mSMQDsServices"                            , ATT_MSMQ_DS_SERVICES                         , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Ds-Services"                          , 0                                             },
    { L"mSMQEncryptKey"                            , ATT_MSMQ_ENCRYPT_KEY                         , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Encrypt-Key"                          , 0                                             },
    { L"mSMQForeign"                               , ATT_MSMQ_FOREIGN                             , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Foreign"                              , 0                                             },
    { L"mSMQInRoutingServers"                      , ATT_MSMQ_IN_ROUTING_SERVERS                  , SYNTAX_DISTNAME_TYPE              , L"MSMQ-In-Routing-Servers"                   , 0                                             },
    { L"mSMQInterval1"                             , ATT_MSMQ_INTERVAL1                           , SYNTAX_INTEGER_TYPE               , L"MSMQ-Interval1"                            , 0                                             },
    { L"mSMQInterval2"                             , ATT_MSMQ_INTERVAL2                           , SYNTAX_INTEGER_TYPE               , L"MSMQ-Interval2"                            , 0                                             },
    { L"mSMQJournal"                               , ATT_MSMQ_JOURNAL                             , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Journal"                              , 0                                             },
    { L"mSMQJournalQuota"                          , ATT_MSMQ_JOURNAL_QUOTA                       , SYNTAX_INTEGER_TYPE               , L"MSMQ-Journal-Quota"                        , 0                                             },
    { L"mSMQLabel"                                 , ATT_MSMQ_LABEL                               , SYNTAX_NOCASE_STRING_TYPE         , L"MSMQ-Label"                                , 0                                             },
    { L"mSMQLabelEx"                               , ATT_MSMQ_LABEL_EX                            , SYNTAX_UNICODE_TYPE               , L"MSMQ-Label-Ex"                             , 0                                             },
    { L"mSMQLongLived"                             , ATT_MSMQ_LONG_LIVED                          , SYNTAX_INTEGER_TYPE               , L"MSMQ-Long-Lived"                           , 0                                             },
    { L"mSMQMigrated"                              , ATT_MSMQ_MIGRATED                            , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Migrated"                             , 0                                             },
    { L"mSMQNameStyle"                             , ATT_MSMQ_NAME_STYLE                          , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Name-Style"                           , 0                                             },
    { L"mSMQNt4Flags"                              , ATT_MSMQ_NT4_FLAGS                           , SYNTAX_INTEGER_TYPE               , L"MSMQ-Nt4-Flags"                            , 0                                             },
    { L"mSMQNt4Stub"                               , ATT_MSMQ_NT4_STUB                            , SYNTAX_INTEGER_TYPE               , L"MSMQ-Nt4-Stub"                             , 0                                             },
    { L"mSMQOSType"                                , ATT_MSMQ_OS_TYPE                             , SYNTAX_INTEGER_TYPE               , L"MSMQ-OS-Type"                              , 0                                             },
    { L"mSMQOutRoutingServers"                     , ATT_MSMQ_OUT_ROUTING_SERVERS                 , SYNTAX_DISTNAME_TYPE              , L"MSMQ-Out-Routing-Servers"                  , 0                                             },
    { L"mSMQOwnerID"                               , ATT_MSMQ_OWNER_ID                            , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Owner-ID"                             , 0                                             },
    { L"mSMQPrevSiteGates"                         , ATT_MSMQ_PREV_SITE_GATES                     , SYNTAX_DISTNAME_TYPE              , L"MSMQ-Prev-Site-Gates"                      , 0                                             },
    { L"mSMQPrivacyLevel"                          , ATT_MSMQ_PRIVACY_LEVEL                       , SYNTAX_INTEGER_TYPE               , L"MSMQ-Privacy-Level"                        , 0                                             },
    { L"mSMQQMID"                                  , ATT_MSMQ_QM_ID                               , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-QM-ID"                                , 0                                             },
    { L"mSMQQueueJournalQuota"                     , ATT_MSMQ_QUEUE_JOURNAL_QUOTA                 , SYNTAX_INTEGER_TYPE               , L"MSMQ-Queue-Journal-Quota"                  , 0                                             },
    { L"mSMQQueueNameExt"                          , ATT_MSMQ_QUEUE_NAME_EXT                      , SYNTAX_UNICODE_TYPE               , L"MSMQ-Queue-Name-Ext"                       , 0                                             },
    { L"mSMQQueueQuota"                            , ATT_MSMQ_QUEUE_QUOTA                         , SYNTAX_INTEGER_TYPE               , L"MSMQ-Queue-Quota"                          , 0                                             },
    { L"mSMQQueueType"                             , ATT_MSMQ_QUEUE_TYPE                          , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Queue-Type"                           , 0                                             },
    { L"mSMQQuota"                                 , ATT_MSMQ_QUOTA                               , SYNTAX_INTEGER_TYPE               , L"MSMQ-Quota"                                , 0                                             },
    { L"msMQ-Recipient-FormatName"                 , ATT_MSMQ_RECIPIENT_FORMATNAME                , SYNTAX_UNICODE_TYPE               , L"MSMQ-Recipient-FormatName"                 , 0                                             },
    { L"mSMQRoutingService"                        , ATT_MSMQ_ROUTING_SERVICE                     , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Routing-Service"                      , 0                                             },
    { L"mSMQRoutingServices"                       , ATT_MSMQ_ROUTING_SERVICES                    , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Routing-Services"                     , 0                                             },
    { L"mSMQServiceType"                           , ATT_MSMQ_SERVICE_TYPE                        , SYNTAX_INTEGER_TYPE               , L"MSMQ-Service-Type"                         , 0                                             },
    { L"mSMQServices"                              , ATT_MSMQ_SERVICES                            , SYNTAX_INTEGER_TYPE               , L"MSMQ-Services"                             , 0                                             },
    { L"mSMQSignCertificates"                      , ATT_MSMQ_SIGN_CERTIFICATES                   , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Sign-Certificates"                    , 0                                             },
    { L"mSMQSignCertificatesMig"                   , ATT_MSMQ_SIGN_CERTIFICATES_MIG               , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Sign-Certificates-Mig"                , 0                                             },
    { L"mSMQSignKey"                               , ATT_MSMQ_SIGN_KEY                            , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Sign-Key"                             , 0                                             },
    { L"mSMQSite1"                                 , ATT_MSMQ_SITE_1                              , SYNTAX_DISTNAME_TYPE              , L"MSMQ-Site-1"                               , 0                                             },
    { L"mSMQSite2"                                 , ATT_MSMQ_SITE_2                              , SYNTAX_DISTNAME_TYPE              , L"MSMQ-Site-2"                               , 0                                             },
    { L"mSMQSiteForeign"                           , ATT_MSMQ_SITE_FOREIGN                        , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Site-Foreign"                         , 0                                             },
    { L"mSMQSiteGates"                             , ATT_MSMQ_SITE_GATES                          , SYNTAX_DISTNAME_TYPE              , L"MSMQ-Site-Gates"                           , 0                                             },
    { L"mSMQSiteGatesMig"                          , ATT_MSMQ_SITE_GATES_MIG                      , SYNTAX_DISTNAME_TYPE              , L"MSMQ-Site-Gates-Mig"                       , 0                                             },
    { L"mSMQSiteID"                                , ATT_MSMQ_SITE_ID                             , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Site-ID"                              , 0                                             },
    { L"mSMQSiteName"                              , ATT_MSMQ_SITE_NAME                           , SYNTAX_NOCASE_STRING_TYPE         , L"MSMQ-Site-Name"                            , 0                                             },
    { L"mSMQSiteNameEx"                            , ATT_MSMQ_SITE_NAME_EX                        , SYNTAX_UNICODE_TYPE               , L"MSMQ-Site-Name-Ex"                         , 0                                             },
    { L"mSMQSites"                                 , ATT_MSMQ_SITES                               , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Sites"                                , 0                                             },
    { L"mSMQTransactional"                         , ATT_MSMQ_TRANSACTIONAL                       , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Transactional"                        , 0                                             },
    { L"mSMQUserSid"                               , ATT_MSMQ_USER_SID                            , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-User-Sid"                             , 0                                             },
    { L"mSMQVersion"                               , ATT_MSMQ_VERSION                             , SYNTAX_INTEGER_TYPE               , L"MSMQ-Version"                              , 0                                             },
    { L"msNPAllowDialin"                           , ATT_MSNPALLOWDIALIN                          , SYNTAX_BOOLEAN_TYPE               , L"msNPAllowDialin"                           , 0                                             },
    { L"msNPCalledStationID"                       , ATT_MSNPCALLEDSTATIONID                      , SYNTAX_PRINT_CASE_STRING_TYPE     , L"msNPCalledStationID"                       , 0                                             },
    { L"msNPCallingStationID"                      , ATT_MSNPCALLINGSTATIONID                     , SYNTAX_PRINT_CASE_STRING_TYPE     , L"msNPCallingStationID"                      , 0                                             },
    { L"msNPSavedCallingStationID"                 , ATT_MSNPSAVEDCALLINGSTATIONID                , SYNTAX_PRINT_CASE_STRING_TYPE     , L"msNPSavedCallingStationID"                 , 0                                             },
    { L"msRADIUSCallbackNumber"                    , ATT_MSRADIUSCALLBACKNUMBER                   , SYNTAX_PRINT_CASE_STRING_TYPE     , L"msRADIUSCallbackNumber"                    , 0                                             },
    { L"msRADIUSFramedIPAddress"                   , ATT_MSRADIUSFRAMEDIPADDRESS                  , SYNTAX_INTEGER_TYPE               , L"msRADIUSFramedIPAddress"                   , 0                                             },
    { L"msRADIUSFramedRoute"                       , ATT_MSRADIUSFRAMEDROUTE                      , SYNTAX_PRINT_CASE_STRING_TYPE     , L"msRADIUSFramedRoute"                       , 0                                             },
    { L"msRADIUSServiceType"                       , ATT_MSRADIUSSERVICETYPE                      , SYNTAX_INTEGER_TYPE               , L"msRADIUSServiceType"                       , 0                                             },
    { L"msRASSavedCallbackNumber"                  , ATT_MSRASSAVEDCALLBACKNUMBER                 , SYNTAX_PRINT_CASE_STRING_TYPE     , L"msRASSavedCallbackNumber"                  , 0                                             },
    { L"msRASSavedFramedIPAddress"                 , ATT_MSRASSAVEDFRAMEDIPADDRESS                , SYNTAX_INTEGER_TYPE               , L"msRASSavedFramedIPAddress"                 , 0                                             },
    { L"msRASSavedFramedRoute"                     , ATT_MSRASSAVEDFRAMEDROUTE                    , SYNTAX_PRINT_CASE_STRING_TYPE     , L"msRASSavedFramedRoute"                     , 0                                             },
    { L"mustContain"                               , ATT_MUST_CONTAIN                             , SYNTAX_OBJECT_ID_TYPE             , L"Must-Contain"                              , 0                                             },
    { L"nameServiceFlags"                          , ATT_NAME_SERVICE_FLAGS                       , SYNTAX_INTEGER_TYPE               , L"Name-Service-Flags"                        , 0                                             },
    { L"nCName"                                    , ATT_NC_NAME                                  , SYNTAX_DISTNAME_TYPE              , L"NC-Name"                                   , 0                                             },
    { L"nETBIOSName"                               , ATT_NETBIOS_NAME                             , SYNTAX_UNICODE_TYPE               , L"NETBIOS-Name"                              , 0                                             },
    { L"netbootAllowNewClients"                    , ATT_NETBOOT_ALLOW_NEW_CLIENTS                , SYNTAX_BOOLEAN_TYPE               , L"netboot-Allow-New-Clients"                 , 0                                             },
    { L"netbootAnswerOnlyValidClients"             , ATT_NETBOOT_ANSWER_ONLY_VALID_CLIENTS        , SYNTAX_BOOLEAN_TYPE               , L"netboot-Answer-Only-Valid-Clients"         , 0                                             },
    { L"netbootAnswerRequests"                     , ATT_NETBOOT_ANSWER_REQUESTS                  , SYNTAX_BOOLEAN_TYPE               , L"netboot-Answer-Requests"                   , 0                                             },
    { L"netbootCurrentClientCount"                 , ATT_NETBOOT_CURRENT_CLIENT_COUNT             , SYNTAX_INTEGER_TYPE               , L"netboot-Current-Client-Count"              , 0                                             },
    { L"netbootGUID"                               , ATT_NETBOOT_GUID                             , SYNTAX_OCTET_STRING_TYPE          , L"Netboot-GUID"                              , 0                                             },
    { L"netbootInitialization"                     , ATT_NETBOOT_INITIALIZATION                   , SYNTAX_UNICODE_TYPE               , L"Netboot-Initialization"                    , 0                                             },
    { L"netbootIntelliMirrorOSes"                  , ATT_NETBOOT_INTELLIMIRROR_OSES               , SYNTAX_UNICODE_TYPE               , L"netboot-IntelliMirror-OSes"                , 0                                             },
    { L"netbootLimitClients"                       , ATT_NETBOOT_LIMIT_CLIENTS                    , SYNTAX_BOOLEAN_TYPE               , L"netboot-Limit-Clients"                     , 0                                             },
    { L"netbootLocallyInstalledOSes"               , ATT_NETBOOT_LOCALLY_INSTALLED_OSES           , SYNTAX_UNICODE_TYPE               , L"netboot-Locally-Installed-OSes"            , 0                                             },
    { L"netbootMachineFilePath"                    , ATT_NETBOOT_MACHINE_FILE_PATH                , SYNTAX_UNICODE_TYPE               , L"Netboot-Machine-File-Path"                 , 0                                             },
    { L"netbootMaxClients"                         , ATT_NETBOOT_MAX_CLIENTS                      , SYNTAX_INTEGER_TYPE               , L"netboot-Max-Clients"                       , 0                                             },
    { L"netbootMirrorDataFile"                     , ATT_NETBOOT_MIRROR_DATA_FILE                 , SYNTAX_UNICODE_TYPE               , L"Netboot-Mirror-Data-File"                  , 0                                             },
    { L"netbootNewMachineNamingPolicy"             , ATT_NETBOOT_NEW_MACHINE_NAMING_POLICY        , SYNTAX_UNICODE_TYPE               , L"netboot-New-Machine-Naming-Policy"         , 0                                             },
    { L"netbootNewMachineOU"                       , ATT_NETBOOT_NEW_MACHINE_OU                   , SYNTAX_DISTNAME_TYPE              , L"netboot-New-Machine-OU"                    , 0                                             },
    { L"netbootSCPBL"                              , ATT_NETBOOT_SCP_BL                           , SYNTAX_DISTNAME_TYPE              , L"netboot-SCP-BL"                            , 0                                             },
    { L"netbootServer"                             , ATT_NETBOOT_SERVER                           , SYNTAX_DISTNAME_TYPE              , L"netboot-Server"                            , 0                                             },
    { L"netbootSIFFile"                            , ATT_NETBOOT_SIF_FILE                         , SYNTAX_UNICODE_TYPE               , L"Netboot-SIF-File"                          , 0                                             },
    { L"netbootTools"                              , ATT_NETBOOT_TOOLS                            , SYNTAX_UNICODE_TYPE               , L"netboot-Tools"                             , 0                                             },
    { L"networkAddress"                            , ATT_NETWORK_ADDRESS                          , SYNTAX_NOCASE_STRING_TYPE         , L"Network-Address"                           , 0                                             },
    { L"nextLevelStore"                            , ATT_NEXT_LEVEL_STORE                         , SYNTAX_DISTNAME_TYPE              , L"Next-Level-Store"                          , 0                                             },
    { L"nextRid"                                   , ATT_NEXT_RID                                 , SYNTAX_INTEGER_TYPE               , L"Next-Rid"                                  , 0                                             },
    { L"nonSecurityMember"                         , ATT_NON_SECURITY_MEMBER                      , SYNTAX_DISTNAME_TYPE              , L"Non-Security-Member"                       , 0                                             },
    { L"nonSecurityMemberBL"                       , ATT_NON_SECURITY_MEMBER_BL                   , SYNTAX_DISTNAME_TYPE              , L"Non-Security-Member-BL"                    , 0                                             },
    { L"notificationList"                          , ATT_NOTIFICATION_LIST                        , SYNTAX_DISTNAME_TYPE              , L"Notification-List"                         , 0                                             },
    { L"nTGroupMembers"                            , ATT_NT_GROUP_MEMBERS                         , SYNTAX_OCTET_STRING_TYPE          , L"NT-Group-Members"                          , 0                                             },
    { L"nTMixedDomain"                             , ATT_NT_MIXED_DOMAIN                          , SYNTAX_INTEGER_TYPE               , L"NT-Mixed-Domain"                           , 0                                             },
    { L"ntPwdHistory"                              , ATT_NT_PWD_HISTORY                           , SYNTAX_OCTET_STRING_TYPE          , L"Nt-Pwd-History"                            , 0                                             },
    { L"nTSecurityDescriptor"                      , ATT_NT_SECURITY_DESCRIPTOR                   , SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE, L"NT-Security-Descriptor"                    , 0                                             },
    { L"distinguishedName"                         , ATT_OBJ_DIST_NAME                            , SYNTAX_DISTNAME_TYPE              , L"Obj-Dist-Name"                             , 0                                             },
    { L"objectCategory"                            , ATT_OBJECT_CATEGORY                          , SYNTAX_DISTNAME_TYPE              , L"Object-Category"                           , 0                                             },
    { L"objectClass"                               , ATT_OBJECT_CLASS                             , SYNTAX_OBJECT_ID_TYPE             , L"Object-Class"                              , 0                                             },
    { L"objectClassCategory"                       , ATT_OBJECT_CLASS_CATEGORY                    , SYNTAX_INTEGER_TYPE               , L"Object-Class-Category"                     , 0                                             },
    { L"objectClasses"                             , ATT_OBJECT_CLASSES                           , SYNTAX_UNICODE_TYPE               , L"Object-Classes"                            , 0                                             },
    { L"objectCount"                               , ATT_OBJECT_COUNT                             , SYNTAX_INTEGER_TYPE               , L"Object-Count"                              , 0                                             },
    { L"objectGUID"                                , ATT_OBJECT_GUID                              , SYNTAX_OCTET_STRING_TYPE          , L"Object-Guid"                               , 0                                             },
    { L"objectSid"                                 , ATT_OBJECT_SID                               , SYNTAX_SID_TYPE                   , L"Object-Sid"                                , 0                                             },
    { L"objectVersion"                             , ATT_OBJECT_VERSION                           , SYNTAX_INTEGER_TYPE               , L"Object-Version"                            , 0                                             },
    { L"oEMInformation"                            , ATT_OEM_INFORMATION                          , SYNTAX_UNICODE_TYPE               , L"OEM-Information"                           , 0                                             },
    { L"oMObjectClass"                             , ATT_OM_OBJECT_CLASS                          , SYNTAX_OCTET_STRING_TYPE          , L"OM-Object-Class"                           , 0                                             },
    { L"oMSyntax"                                  , ATT_OM_SYNTAX                                , SYNTAX_INTEGER_TYPE               , L"OM-Syntax"                                 , 0                                             },
    { L"oMTGuid"                                   , ATT_OMT_GUID                                 , SYNTAX_OCTET_STRING_TYPE          , L"OMT-Guid"                                  , 0                                             },
    { L"oMTIndxGuid"                               , ATT_OMT_INDX_GUID                            , SYNTAX_OCTET_STRING_TYPE          , L"OMT-Indx-Guid"                             , 0                                             },
    { L"operatingSystem"                           , ATT_OPERATING_SYSTEM                         , SYNTAX_UNICODE_TYPE               , L"Operating-System"                          , 0                                             },
    { L"operatingSystemHotfix"                     , ATT_OPERATING_SYSTEM_HOTFIX                  , SYNTAX_UNICODE_TYPE               , L"Operating-System-Hotfix"                   , 0                                             },
    { L"operatingSystemServicePack"                , ATT_OPERATING_SYSTEM_SERVICE_PACK            , SYNTAX_UNICODE_TYPE               , L"Operating-System-Service-Pack"             , 0                                             },
    { L"operatingSystemVersion"                    , ATT_OPERATING_SYSTEM_VERSION                 , SYNTAX_UNICODE_TYPE               , L"Operating-System-Version"                  , 0                                             },
    { L"operatorCount"                             , ATT_OPERATOR_COUNT                           , SYNTAX_INTEGER_TYPE               , L"Operator-Count"                            , 0                                             },
    { L"optionDescription"                         , ATT_OPTION_DESCRIPTION                       , SYNTAX_UNICODE_TYPE               , L"Option-Description"                        , 0                                             },
    { L"options"                                   , ATT_OPTIONS                                  , SYNTAX_INTEGER_TYPE               , L"Options"                                   , 0                                             },
    { L"optionsLocation"                           , ATT_OPTIONS_LOCATION                         , SYNTAX_PRINT_CASE_STRING_TYPE     , L"Options-Location"                          , 0                                             },
    { L"o"                                         , ATT_ORGANIZATION_NAME                        , SYNTAX_UNICODE_TYPE               , L"Organization-Name"                         , 0                                             },
    { L"ou"                                        , ATT_ORGANIZATIONAL_UNIT_NAME                 , SYNTAX_UNICODE_TYPE               , L"Organizational-Unit-Name"                  , 0                                             },
    { L"originalDisplayTable"                      , ATT_ORIGINAL_DISPLAY_TABLE                   , SYNTAX_OCTET_STRING_TYPE          , L"Original-Display-Table"                    , 0                                             },
    { L"originalDisplayTableMSDOS"                 , ATT_ORIGINAL_DISPLAY_TABLE_MSDOS             , SYNTAX_OCTET_STRING_TYPE          , L"Original-Display-Table-MSDOS"              , 0                                             },
    { L"otherLoginWorkstations"                    , ATT_OTHER_LOGIN_WORKSTATIONS                 , SYNTAX_UNICODE_TYPE               , L"Other-Login-Workstations"                  , 0                                             },
    { L"otherMailbox"                              , ATT_OTHER_MAILBOX                            , SYNTAX_UNICODE_TYPE               , L"Other-Mailbox"                             , 0                                             },
    { L"middleName"                                , ATT_OTHER_NAME                               , SYNTAX_UNICODE_TYPE               , L"Other-Name"                                , 0                                             },
    { L"otherWellKnownObjects"                     , ATT_OTHER_WELL_KNOWN_OBJECTS                 , SYNTAX_DISTNAME_BINARY_TYPE       , L"Other-Well-Known-Objects"                  , 0                                             },
    { L"owner"                                     , ATT_OWNER                                    , SYNTAX_DISTNAME_TYPE              , L"Owner"                                     , 0                                             },
    { L"packageFlags"                              , ATT_PACKAGE_FLAGS                            , SYNTAX_INTEGER_TYPE               , L"Package-Flags"                             , 0                                             },
    { L"packageName"                               , ATT_PACKAGE_NAME                             , SYNTAX_UNICODE_TYPE               , L"Package-Name"                              , 0                                             },
    { L"packageType"                               , ATT_PACKAGE_TYPE                             , SYNTAX_INTEGER_TYPE               , L"Package-Type"                              , 0                                             },
    { L"parentCA"                                  , ATT_PARENT_CA                                , SYNTAX_DISTNAME_TYPE              , L"Parent-CA"                                 , 0                                             },
    { L"parentCACertificateChain"                  , ATT_PARENT_CA_CERTIFICATE_CHAIN              , SYNTAX_OCTET_STRING_TYPE          , L"Parent-CA-Certificate-Chain"               , 0                                             },
    { L"parentGUID"                                , ATT_PARENT_GUID                              , SYNTAX_OCTET_STRING_TYPE          , L"Parent-GUID"                               , 0                                             },
    { L"partialAttributeDeletionList"              , ATT_PARTIAL_ATTRIBUTE_DELETION_LIST          , SYNTAX_OCTET_STRING_TYPE          , L"Partial-Attribute-Deletion-List"           , 0                                             },
    { L"partialAttributeSet"                       , ATT_PARTIAL_ATTRIBUTE_SET                    , SYNTAX_OCTET_STRING_TYPE          , L"Partial-Attribute-Set"                     , 0                                             },
    { L"pekKeyChangeInterval"                      , ATT_PEK_KEY_CHANGE_INTERVAL                  , SYNTAX_I8_TYPE                    , L"Pek-Key-Change-Interval"                   , 0                                             },
    { L"pekList"                                   , ATT_PEK_LIST                                 , SYNTAX_OCTET_STRING_TYPE          , L"Pek-List"                                  , 0                                             },
    { L"pendingCACertificates"                     , ATT_PENDING_CA_CERTIFICATES                  , SYNTAX_OCTET_STRING_TYPE          , L"Pending-CA-Certificates"                   , 0                                             },
    { L"pendingParentCA"                           , ATT_PENDING_PARENT_CA                        , SYNTAX_DISTNAME_TYPE              , L"Pending-Parent-CA"                         , 0                                             },
    { L"perMsgDialogDisplayTable"                  , ATT_PER_MSG_DIALOG_DISPLAY_TABLE             , SYNTAX_OCTET_STRING_TYPE          , L"Per-Msg-Dialog-Display-Table"              , 0                                             },
    { L"perRecipDialogDisplayTable"                , ATT_PER_RECIP_DIALOG_DISPLAY_TABLE           , SYNTAX_OCTET_STRING_TYPE          , L"Per-Recip-Dialog-Display-Table"            , 0                                             },
    { L"personalTitle"                             , ATT_PERSONAL_TITLE                           , SYNTAX_UNICODE_TYPE               , L"Personal-Title"                            , 0                                             },
    { L"otherFacsimileTelephoneNumber"             , ATT_PHONE_FAX_OTHER                          , SYNTAX_UNICODE_TYPE               , L"Phone-Fax-Other"                           , 0                                             },
    { L"otherHomePhone"                            , ATT_PHONE_HOME_OTHER                         , SYNTAX_UNICODE_TYPE               , L"Phone-Home-Other"                          , 0                                             },
    { L"homePhone"                                 , ATT_PHONE_HOME_PRIMARY                       , SYNTAX_UNICODE_TYPE               , L"Phone-Home-Primary"                        , 0                                             },
    { L"otherIpPhone"                              , ATT_PHONE_IP_OTHER                           , SYNTAX_UNICODE_TYPE               , L"Phone-Ip-Other"                            , 0                                             },
    { L"ipPhone"                                   , ATT_PHONE_IP_PRIMARY                         , SYNTAX_UNICODE_TYPE               , L"Phone-Ip-Primary"                          , 0                                             },
    { L"primaryInternationalISDNNumber"            , ATT_PHONE_ISDN_PRIMARY                       , SYNTAX_UNICODE_TYPE               , L"Phone-ISDN-Primary"                        , 0                                             },
    { L"otherMobile"                               , ATT_PHONE_MOBILE_OTHER                       , SYNTAX_UNICODE_TYPE               , L"Phone-Mobile-Other"                        , 0                                             },
    { L"mobile"                                    , ATT_PHONE_MOBILE_PRIMARY                     , SYNTAX_UNICODE_TYPE               , L"Phone-Mobile-Primary"                      , 0                                             },
    { L"otherTelephone"                            , ATT_PHONE_OFFICE_OTHER                       , SYNTAX_UNICODE_TYPE               , L"Phone-Office-Other"                        , 0                                             },
    { L"otherPager"                                , ATT_PHONE_PAGER_OTHER                        , SYNTAX_UNICODE_TYPE               , L"Phone-Pager-Other"                         , 0                                             },
    { L"pager"                                     , ATT_PHONE_PAGER_PRIMARY                      , SYNTAX_UNICODE_TYPE               , L"Phone-Pager-Primary"                       , 0                                             },
    { L"physicalDeliveryOfficeName"                , ATT_PHYSICAL_DELIVERY_OFFICE_NAME            , SYNTAX_UNICODE_TYPE               , L"Physical-Delivery-Office-Name"             , 0                                             },
    { L"physicalLocationObject"                    , ATT_PHYSICAL_LOCATION_OBJECT                 , SYNTAX_DISTNAME_TYPE              , L"Physical-Location-Object"                  , 0                                             },
    { L"thumbnailPhoto"                            , ATT_PICTURE                                  , SYNTAX_OCTET_STRING_TYPE          , L"Picture"                                   , 0                                             },
    { L"pKICriticalExtensions"                     , ATT_PKI_CRITICAL_EXTENSIONS                  , SYNTAX_UNICODE_TYPE               , L"PKI-Critical-Extensions"                   , 0                                             },
    { L"pKIDefaultCSPs"                            , ATT_PKI_DEFAULT_CSPS                         , SYNTAX_UNICODE_TYPE               , L"PKI-Default-CSPs"                          , 0                                             },
    { L"pKIDefaultKeySpec"                         , ATT_PKI_DEFAULT_KEY_SPEC                     , SYNTAX_INTEGER_TYPE               , L"PKI-Default-Key-Spec"                      , 0                                             },
    { L"pKIEnrollmentAccess"                       , ATT_PKI_ENROLLMENT_ACCESS                    , SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE, L"PKI-Enrollment-Access"                     , 0                                             },
    { L"pKIExpirationPeriod"                       , ATT_PKI_EXPIRATION_PERIOD                    , SYNTAX_OCTET_STRING_TYPE          , L"PKI-Expiration-Period"                     , 0                                             },
    { L"pKIExtendedKeyUsage"                       , ATT_PKI_EXTENDED_KEY_USAGE                   , SYNTAX_UNICODE_TYPE               , L"PKI-Extended-Key-Usage"                    , 0                                             },
    { L"pKIKeyUsage"                               , ATT_PKI_KEY_USAGE                            , SYNTAX_OCTET_STRING_TYPE          , L"PKI-Key-Usage"                             , 0                                             },
    { L"pKIMaxIssuingDepth"                        , ATT_PKI_MAX_ISSUING_DEPTH                    , SYNTAX_INTEGER_TYPE               , L"PKI-Max-Issuing-Depth"                     , 0                                             },
    { L"pKIOverlapPeriod"                          , ATT_PKI_OVERLAP_PERIOD                       , SYNTAX_OCTET_STRING_TYPE          , L"PKI-Overlap-Period"                        , 0                                             },
    { L"pKT"                                       , ATT_PKT                                      , SYNTAX_OCTET_STRING_TYPE          , L"PKT"                                       , 0                                             },
    { L"pKTGuid"                                   , ATT_PKT_GUID                                 , SYNTAX_OCTET_STRING_TYPE          , L"PKT-Guid"                                  , 0                                             },
    { L"policyReplicationFlags"                    , ATT_POLICY_REPLICATION_FLAGS                 , SYNTAX_INTEGER_TYPE               , L"Policy-Replication-Flags"                  , 0                                             },
    { L"portName"                                  , ATT_PORT_NAME                                , SYNTAX_UNICODE_TYPE               , L"Port-Name"                                 , 0                                             },
    { L"possSuperiors"                             , ATT_POSS_SUPERIORS                           , SYNTAX_OBJECT_ID_TYPE             , L"Poss-Superiors"                            , 0                                             },
    { L"possibleInferiors"                         , ATT_POSSIBLE_INFERIORS                       , SYNTAX_OBJECT_ID_TYPE             , L"Possible-Inferiors"                        , 0                                             },
    { L"postOfficeBox"                             , ATT_POST_OFFICE_BOX                          , SYNTAX_UNICODE_TYPE               , L"Post-Office-Box"                           , 0                                             },
    { L"postalAddress"                             , ATT_POSTAL_ADDRESS                           , SYNTAX_UNICODE_TYPE               , L"Postal-Address"                            , 0                                             },
    { L"postalCode"                                , ATT_POSTAL_CODE                              , SYNTAX_UNICODE_TYPE               , L"Postal-Code"                               , 0                                             },
    { L"preferredDeliveryMethod"                   , ATT_PREFERRED_DELIVERY_METHOD                , SYNTAX_INTEGER_TYPE               , L"Preferred-Delivery-Method"                 , 0                                             },
    { L"preferredOU"                               , ATT_PREFERRED_OU                             , SYNTAX_DISTNAME_TYPE              , L"Preferred-OU"                              , 0                                             },
    { L"prefixMap"                                 , ATT_PREFIX_MAP                               , SYNTAX_OCTET_STRING_TYPE          , L"Prefix-Map"                                , 0                                             },
    { L"presentationAddress"                       , ATT_PRESENTATION_ADDRESS                     , SYNTAX_ADDRESS_TYPE               , L"Presentation-Address"                      , 0                                             },
    { L"previousCACertificates"                    , ATT_PREVIOUS_CA_CERTIFICATES                 , SYNTAX_OCTET_STRING_TYPE          , L"Previous-CA-Certificates"                  , 0                                             },
    { L"previousParentCA"                          , ATT_PREVIOUS_PARENT_CA                       , SYNTAX_DISTNAME_TYPE              , L"Previous-Parent-CA"                        , 0                                             },
    { L"primaryGroupID"                            , ATT_PRIMARY_GROUP_ID                         , SYNTAX_INTEGER_TYPE               , L"Primary-Group-ID"                          , 0                                             },
    { L"primaryGroupToken"                         , ATT_PRIMARY_GROUP_TOKEN                      , SYNTAX_INTEGER_TYPE               , L"Primary-Group-Token"                       , 0                                             },
    { L"printAttributes"                           , ATT_PRINT_ATTRIBUTES                         , SYNTAX_INTEGER_TYPE               , L"Print-Attributes"                          , 0                                             },
    { L"printBinNames"                             , ATT_PRINT_BIN_NAMES                          , SYNTAX_UNICODE_TYPE               , L"Print-Bin-Names"                           , 0                                             },
    { L"printCollate"                              , ATT_PRINT_COLLATE                            , SYNTAX_BOOLEAN_TYPE               , L"Print-Collate"                             , 0                                             },
    { L"printColor"                                , ATT_PRINT_COLOR                              , SYNTAX_BOOLEAN_TYPE               , L"Print-Color"                               , 0                                             },
    { L"printDuplexSupported"                      , ATT_PRINT_DUPLEX_SUPPORTED                   , SYNTAX_BOOLEAN_TYPE               , L"Print-Duplex-Supported"                    , 0                                             },
    { L"printEndTime"                              , ATT_PRINT_END_TIME                           , SYNTAX_INTEGER_TYPE               , L"Print-End-Time"                            , 0                                             },
    { L"printFormName"                             , ATT_PRINT_FORM_NAME                          , SYNTAX_UNICODE_TYPE               , L"Print-Form-Name"                           , 0                                             },
    { L"printKeepPrintedJobs"                      , ATT_PRINT_KEEP_PRINTED_JOBS                  , SYNTAX_BOOLEAN_TYPE               , L"Print-Keep-Printed-Jobs"                   , 0                                             },
    { L"printLanguage"                             , ATT_PRINT_LANGUAGE                           , SYNTAX_UNICODE_TYPE               , L"Print-Language"                            , 0                                             },
    { L"printMACAddress"                           , ATT_PRINT_MAC_ADDRESS                        , SYNTAX_UNICODE_TYPE               , L"Print-MAC-Address"                         , 0                                             },
    { L"printMaxCopies"                            , ATT_PRINT_MAX_COPIES                         , SYNTAX_INTEGER_TYPE               , L"Print-Max-Copies"                          , 0                                             },
    { L"printMaxResolutionSupported"               , ATT_PRINT_MAX_RESOLUTION_SUPPORTED           , SYNTAX_INTEGER_TYPE               , L"Print-Max-Resolution-Supported"            , 0                                             },
    { L"printMaxXExtent"                           , ATT_PRINT_MAX_X_EXTENT                       , SYNTAX_INTEGER_TYPE               , L"Print-Max-X-Extent"                        , 0                                             },
    { L"printMaxYExtent"                           , ATT_PRINT_MAX_Y_EXTENT                       , SYNTAX_INTEGER_TYPE               , L"Print-Max-Y-Extent"                        , 0                                             },
    { L"printMediaReady"                           , ATT_PRINT_MEDIA_READY                        , SYNTAX_UNICODE_TYPE               , L"Print-Media-Ready"                         , 0                                             },
    { L"printMediaSupported"                       , ATT_PRINT_MEDIA_SUPPORTED                    , SYNTAX_UNICODE_TYPE               , L"Print-Media-Supported"                     , 0                                             },
    { L"printMemory"                               , ATT_PRINT_MEMORY                             , SYNTAX_INTEGER_TYPE               , L"Print-Memory"                              , 0                                             },
    { L"printMinXExtent"                           , ATT_PRINT_MIN_X_EXTENT                       , SYNTAX_INTEGER_TYPE               , L"Print-Min-X-Extent"                        , 0                                             },
    { L"printMinYExtent"                           , ATT_PRINT_MIN_Y_EXTENT                       , SYNTAX_INTEGER_TYPE               , L"Print-Min-Y-Extent"                        , 0                                             },
    { L"printNetworkAddress"                       , ATT_PRINT_NETWORK_ADDRESS                    , SYNTAX_UNICODE_TYPE               , L"Print-Network-Address"                     , 0                                             },
    { L"printNotify"                               , ATT_PRINT_NOTIFY                             , SYNTAX_UNICODE_TYPE               , L"Print-Notify"                              , 0                                             },
    { L"printNumberUp"                             , ATT_PRINT_NUMBER_UP                          , SYNTAX_INTEGER_TYPE               , L"Print-Number-Up"                           , 0                                             },
    { L"printOrientationsSupported"                , ATT_PRINT_ORIENTATIONS_SUPPORTED             , SYNTAX_UNICODE_TYPE               , L"Print-Orientations-Supported"              , 0                                             },
    { L"printOwner"                                , ATT_PRINT_OWNER                              , SYNTAX_UNICODE_TYPE               , L"Print-Owner"                               , 0                                             },
    { L"printPagesPerMinute"                       , ATT_PRINT_PAGES_PER_MINUTE                   , SYNTAX_INTEGER_TYPE               , L"Print-Pages-Per-Minute"                    , 0                                             },
    { L"printRate"                                 , ATT_PRINT_RATE                               , SYNTAX_INTEGER_TYPE               , L"Print-Rate"                                , 0                                             },
    { L"printRateUnit"                             , ATT_PRINT_RATE_UNIT                          , SYNTAX_UNICODE_TYPE               , L"Print-Rate-Unit"                           , 0                                             },
    { L"printSeparatorFile"                        , ATT_PRINT_SEPARATOR_FILE                     , SYNTAX_UNICODE_TYPE               , L"Print-Separator-File"                      , 0                                             },
    { L"printShareName"                            , ATT_PRINT_SHARE_NAME                         , SYNTAX_UNICODE_TYPE               , L"Print-Share-Name"                          , 0                                             },
    { L"printSpooling"                             , ATT_PRINT_SPOOLING                           , SYNTAX_UNICODE_TYPE               , L"Print-Spooling"                            , 0                                             },
    { L"printStaplingSupported"                    , ATT_PRINT_STAPLING_SUPPORTED                 , SYNTAX_BOOLEAN_TYPE               , L"Print-Stapling-Supported"                  , 0                                             },
    { L"printStartTime"                            , ATT_PRINT_START_TIME                         , SYNTAX_INTEGER_TYPE               , L"Print-Start-Time"                          , 0                                             },
    { L"printStatus"                               , ATT_PRINT_STATUS                             , SYNTAX_UNICODE_TYPE               , L"Print-Status"                              , 0                                             },
    { L"printerName"                               , ATT_PRINTER_NAME                             , SYNTAX_UNICODE_TYPE               , L"Printer-Name"                              , 0                                             },
    { L"priorSetTime"                              , ATT_PRIOR_SET_TIME                           , SYNTAX_I8_TYPE                    , L"Prior-Set-Time"                            , 0                                             },
    { L"priorValue"                                , ATT_PRIOR_VALUE                              , SYNTAX_OCTET_STRING_TYPE          , L"Prior-Value"                               , 0                                             },
    { L"priority"                                  , ATT_PRIORITY                                 , SYNTAX_INTEGER_TYPE               , L"Priority"                                  , 0                                             },
    { L"privateKey"                                , ATT_PRIVATE_KEY                              , SYNTAX_OCTET_STRING_TYPE          , L"Private-Key"                               , 0                                             },
    { L"privilegeAttributes"                       , ATT_PRIVILEGE_ATTRIBUTES                     , SYNTAX_INTEGER_TYPE               , L"Privilege-Attributes"                      , 0                                             },
    { L"privilegeDisplayName"                      , ATT_PRIVILEGE_DISPLAY_NAME                   , SYNTAX_UNICODE_TYPE               , L"Privilege-Display-Name"                    , 0                                             },
    { L"privilegeHolder"                           , ATT_PRIVILEGE_HOLDER                         , SYNTAX_DISTNAME_TYPE              , L"Privilege-Holder"                          , 0                                             },
    { L"privilegeValue"                            , ATT_PRIVILEGE_VALUE                          , SYNTAX_I8_TYPE                    , L"Privilege-Value"                           , 0                                             },
    { L"productCode"                               , ATT_PRODUCT_CODE                             , SYNTAX_OCTET_STRING_TYPE          , L"Product-Code"                              , 0                                             },
    { L"profilePath"                               , ATT_PROFILE_PATH                             , SYNTAX_UNICODE_TYPE               , L"Profile-Path"                              , 0                                             },
    { L"proxiedObjectName"                         , ATT_PROXIED_OBJECT_NAME                      , SYNTAX_DISTNAME_BINARY_TYPE       , L"Proxied-Object-Name"                       , 0                                             },
    { L"proxyAddresses"                            , ATT_PROXY_ADDRESSES                          , SYNTAX_UNICODE_TYPE               , L"Proxy-Addresses"                           , 0                                             },
    { L"proxyGenerationEnabled"                    , ATT_PROXY_GENERATION_ENABLED                 , SYNTAX_BOOLEAN_TYPE               , L"Proxy-Generation-Enabled"                  , 0                                             },
    { L"proxyLifetime"                             , ATT_PROXY_LIFETIME                           , SYNTAX_I8_TYPE                    , L"Proxy-Lifetime"                            , 0                                             },
    { L"publicKeyPolicy"                           , ATT_PUBLIC_KEY_POLICY                        , SYNTAX_OCTET_STRING_TYPE          , L"Public-Key-Policy"                         , 0                                             },
    { L"purportedSearch"                           , ATT_PURPORTED_SEARCH                         , SYNTAX_UNICODE_TYPE               , L"Purported-Search"                          , 0                                             },
    { L"pwdHistoryLength"                          , ATT_PWD_HISTORY_LENGTH                       , SYNTAX_INTEGER_TYPE               , L"Pwd-History-Length"                        , 0                                             },
    { L"pwdLastSet"                                , ATT_PWD_LAST_SET                             , SYNTAX_I8_TYPE                    , L"Pwd-Last-Set"                              , 0                                             },
    { L"pwdProperties"                             , ATT_PWD_PROPERTIES                           , SYNTAX_INTEGER_TYPE               , L"Pwd-Properties"                            , 0                                             },
    { L"qualityOfService"                          , ATT_QUALITY_OF_SERVICE                       , SYNTAX_INTEGER_TYPE               , L"Quality-Of-Service"                        , 0                                             },
    { L"queryFilter"                               , ATT_QUERY_FILTER                             , SYNTAX_UNICODE_TYPE               , L"Query-Filter"                              , 0                                             },
    { L"queryPolicyBL"                             , ATT_QUERY_POLICY_BL                          , SYNTAX_DISTNAME_TYPE              , L"Query-Policy-BL"                           , 0                                             },
    { L"queryPolicyObject"                         , ATT_QUERY_POLICY_OBJECT                      , SYNTAX_DISTNAME_TYPE              , L"Query-Policy-Object"                       , 0                                             },
    { L"queryPoint"                                , ATT_QUERYPOINT                               , SYNTAX_UNICODE_TYPE               , L"QueryPoint"                                , 0                                             },
    { L"rangeLower"                                , ATT_RANGE_LOWER                              , SYNTAX_INTEGER_TYPE               , L"Range-Lower"                               , 0                                             },
    { L"rangeUpper"                                , ATT_RANGE_UPPER                              , SYNTAX_INTEGER_TYPE               , L"Range-Upper"                               , 0                                             },
    { L"name"                                      , ATT_RDN                                      , SYNTAX_UNICODE_TYPE               , L"RDN"                                       , 0                                             },
    { L"rDNAttID"                                  , ATT_RDN_ATT_ID                               , SYNTAX_OBJECT_ID_TYPE             , L"RDN-Att-ID"                                , 0                                             },
    { L"registeredAddress"                         , ATT_REGISTERED_ADDRESS                       , SYNTAX_OCTET_STRING_TYPE          , L"Registered-Address"                        , 0                                             },
    { L"remoteServerName"                          , ATT_REMOTE_SERVER_NAME                       , SYNTAX_UNICODE_TYPE               , L"Remote-Server-Name"                        , 0                                             },
    { L"remoteSource"                              , ATT_REMOTE_SOURCE                            , SYNTAX_UNICODE_TYPE               , L"Remote-Source"                             , 0                                             },
    { L"remoteSourceType"                          , ATT_REMOTE_SOURCE_TYPE                       , SYNTAX_INTEGER_TYPE               , L"Remote-Source-Type"                        , 0                                             },
    { L"remoteStorageGUID"                         , ATT_REMOTE_STORAGE_GUID                      , SYNTAX_UNICODE_TYPE               , L"Remote-Storage-GUID"                       , 0                                             },
    { L"replPropertyMetaData"                      , ATT_REPL_PROPERTY_META_DATA                  , SYNTAX_OCTET_STRING_TYPE          , L"Repl-Property-Meta-Data"                   , 0                                             },
    { L"replTopologyStayOfExecution"               , ATT_REPL_TOPOLOGY_STAY_OF_EXECUTION          , SYNTAX_INTEGER_TYPE               , L"Repl-Topology-Stay-Of-Execution"           , 0                                             },
    { L"replUpToDateVector"                        , ATT_REPL_UPTODATE_VECTOR                     , SYNTAX_OCTET_STRING_TYPE          , L"Repl-UpToDate-Vector"                      , 0                                             },
    { L"replicaSource"                             , ATT_REPLICA_SOURCE                           , SYNTAX_UNICODE_TYPE               , L"Replica-Source"                            , 0                                             },
    { L"directReports"                             , ATT_REPORTS                                  , SYNTAX_DISTNAME_TYPE              , L"Reports"                                   , 0                                             },
    { L"replInterval"                              , ATT_REPL_INTERVAL                            , SYNTAX_INTEGER_TYPE               , L"Repl-Interval"                             , 0                                             },
    { L"repsFrom"                                  , ATT_REPS_FROM                                , SYNTAX_OCTET_STRING_TYPE          , L"Reps-From"                                 , 0                                             },
    { L"repsTo"                                    , ATT_REPS_TO                                  , SYNTAX_OCTET_STRING_TYPE          , L"Reps-To"                                   , 0                                             },
    { L"requiredCategories"                        , ATT_REQUIRED_CATEGORIES                      , SYNTAX_OCTET_STRING_TYPE          , L"Required-Categories"                       , 0                                             },
    { L"retiredReplDSASignatures"                  , ATT_RETIRED_REPL_DSA_SIGNATURES              , SYNTAX_OCTET_STRING_TYPE          , L"Retired-Repl-DSA-Signatures"               , 0                                             },
    { L"tokenGroups"                               , ATT_TOKEN_GROUPS                             , SYNTAX_SID_TYPE                   , L"Token-Groups"                              , 0                                             },
    { L"tokenGroupsGlobalAndUniversal"             , ATT_TOKEN_GROUPS_GLOBAL_AND_UNIVERSAL        , SYNTAX_SID_TYPE                   , L"Token-Groups-Global-And-Universal"         , 0                                             },
    { L"tokenGroupsNoGCAcceptable"                 , ATT_TOKEN_GROUPS_NO_GC_ACCEPTABLE            , SYNTAX_SID_TYPE                   , L"Token-Groups-No-GC-Acceptable"             , 0                                             },
    { L"revision"                                  , ATT_REVISION                                 , SYNTAX_INTEGER_TYPE               , L"Revision"                                  , 0                                             },
    { L"rid"                                       , ATT_RID                                      , SYNTAX_INTEGER_TYPE               , L"Rid"                                       , 0                                             },
    { L"rIDAllocationPool"                         , ATT_RID_ALLOCATION_POOL                      , SYNTAX_I8_TYPE                    , L"RID-Allocation-Pool"                       , 0                                             },
    { L"rIDAvailablePool"                          , ATT_RID_AVAILABLE_POOL                       , SYNTAX_I8_TYPE                    , L"RID-Available-Pool"                        , 0                                             },
    { L"rIDManagerReference"                       , ATT_RID_MANAGER_REFERENCE                    , SYNTAX_DISTNAME_TYPE              , L"RID-Manager-Reference"                     , 0                                             },
    { L"rIDNextRID"                                , ATT_RID_NEXT_RID                             , SYNTAX_INTEGER_TYPE               , L"RID-Next-RID"                              , 0                                             },
    { L"rIDPreviousAllocationPool"                 , ATT_RID_PREVIOUS_ALLOCATION_POOL             , SYNTAX_I8_TYPE                    , L"RID-Previous-Allocation-Pool"              , 0                                             },
    { L"rIDSetReferences"                          , ATT_RID_SET_REFERENCES                       , SYNTAX_DISTNAME_TYPE              , L"RID-Set-References"                        , 0                                             },
    { L"rIDUsedPool"                               , ATT_RID_USED_POOL                            , SYNTAX_I8_TYPE                    , L"RID-Used-Pool"                             , 0                                             },
    { L"rightsGuid"                                , ATT_RIGHTS_GUID                              , SYNTAX_UNICODE_TYPE               , L"Rights-Guid"                               , 0                                             },
    { L"roleOccupant"                              , ATT_ROLE_OCCUPANT                            , SYNTAX_DISTNAME_TYPE              , L"Role-Occupant"                             , 0                                             },
    { L"rootTrust"                                 , ATT_ROOT_TRUST                               , SYNTAX_DISTNAME_TYPE              , L"Root-Trust"                                , 0                                             },
    { L"rpcNsAnnotation"                           , ATT_RPC_NS_ANNOTATION                        , SYNTAX_UNICODE_TYPE               , L"rpc-Ns-Annotation"                         , 0                                             },
    { L"rpcNsBindings"                             , ATT_RPC_NS_BINDINGS                          , SYNTAX_UNICODE_TYPE               , L"rpc-Ns-Bindings"                           , 0                                             },
    { L"rpcNsCodeset"                              , ATT_RPC_NS_CODESET                           , SYNTAX_UNICODE_TYPE               , L"rpc-Ns-Codeset"                            , 0                                             },
    { L"rpcNsEntryFlags"                           , ATT_RPC_NS_ENTRY_FLAGS                       , SYNTAX_INTEGER_TYPE               , L"rpc-Ns-Entry-Flags"                        , 0                                             },
    { L"rpcNsGroup"                                , ATT_RPC_NS_GROUP                             , SYNTAX_UNICODE_TYPE               , L"rpc-Ns-Group"                              , 0                                             },
    { L"rpcNsInterfaceID"                          , ATT_RPC_NS_INTERFACE_ID                      , SYNTAX_UNICODE_TYPE               , L"rpc-Ns-Interface-ID"                       , 0                                             },
    { L"rpcNsObjectID"                             , ATT_RPC_NS_OBJECT_ID                         , SYNTAX_UNICODE_TYPE               , L"rpc-Ns-Object-ID"                          , 0                                             },
    { L"rpcNsPriority"                             , ATT_RPC_NS_PRIORITY                          , SYNTAX_INTEGER_TYPE               , L"rpc-Ns-Priority"                           , 0                                             },
    { L"rpcNsProfileEntry"                         , ATT_RPC_NS_PROFILE_ENTRY                     , SYNTAX_UNICODE_TYPE               , L"rpc-Ns-Profile-Entry"                      , 0                                             },
    { L"rpcNsTransferSyntax"                       , ATT_RPC_NS_TRANSFER_SYNTAX                   , SYNTAX_UNICODE_TYPE               , L"rpc-Ns-Transfer-Syntax"                    , 0                                             },
    { L"sAMAccountName"                            , ATT_SAM_ACCOUNT_NAME                         , SYNTAX_UNICODE_TYPE               , L"SAM-Account-Name"                          , 0                                             },
    { L"sAMAccountType"                            , ATT_SAM_ACCOUNT_TYPE                         , SYNTAX_INTEGER_TYPE               , L"SAM-Account-Type"                          , 0                                             },
    { L"schedule"                                  , ATT_SCHEDULE                                 , SYNTAX_OCTET_STRING_TYPE          , L"Schedule"                                  , 0                                             },
    { L"schemaFlagsEx"                             , ATT_SCHEMA_FLAGS_EX                          , SYNTAX_INTEGER_TYPE               , L"Schema-Flags-Ex"                           , 0                                             },
    { L"schemaIDGUID"                              , ATT_SCHEMA_ID_GUID                           , SYNTAX_OCTET_STRING_TYPE          , L"Schema-ID-GUID"                            , 0                                             },
    { L"schemaInfo"                                , ATT_SCHEMA_INFO                              , SYNTAX_OCTET_STRING_TYPE          , L"Schema-Info"                               , 0                                             },
    { L"schemaUpdate"                              , ATT_SCHEMA_UPDATE                            , SYNTAX_TIME_TYPE                  , L"Schema-Update"                             , 0                                             },
    { L"schemaVersion"                             , ATT_SCHEMA_VERSION                           , SYNTAX_INTEGER_TYPE               , L"Schema-Version"                            , 0                                             },
    { L"scopeFlags"                                , ATT_SCOPE_FLAGS                              , SYNTAX_INTEGER_TYPE               , L"Scope-Flags"                               , 0                                             },
    { L"scriptPath"                                , ATT_SCRIPT_PATH                              , SYNTAX_UNICODE_TYPE               , L"Script-Path"                               , 0                                             },
    { L"sDRightsEffective"                         , ATT_SD_RIGHTS_EFFECTIVE                      , SYNTAX_INTEGER_TYPE               , L"SD-Rights-Effective"                       , 0                                             },
    { L"searchFlags"                               , ATT_SEARCH_FLAGS                             , SYNTAX_INTEGER_TYPE               , L"Search-Flags"                              , 0                                             },
    { L"searchGuide"                               , ATT_SEARCH_GUIDE                             , SYNTAX_OCTET_STRING_TYPE          , L"Search-Guide"                              , 0                                             },
    { L"securityIdentifier"                        , ATT_SECURITY_IDENTIFIER                      , SYNTAX_SID_TYPE                   , L"Security-Identifier"                       , 0                                             },
    { L"seeAlso"                                   , ATT_SEE_ALSO                                 , SYNTAX_DISTNAME_TYPE              , L"See-Also"                                  , 0                                             },
    { L"seqNotification"                           , ATT_SEQ_NOTIFICATION                         , SYNTAX_INTEGER_TYPE               , L"Seq-Notification"                          , 0                                             },
    { L"serialNumber"                              , ATT_SERIAL_NUMBER                            , SYNTAX_PRINT_CASE_STRING_TYPE     , L"Serial-Number"                             , 0                                             },
    { L"serverName"                                , ATT_SERVER_NAME                              , SYNTAX_UNICODE_TYPE               , L"Server-Name"                               , 0                                             },
    { L"serverReference"                           , ATT_SERVER_REFERENCE                         , SYNTAX_DISTNAME_TYPE              , L"Server-Reference"                          , 0                                             },
    { L"serverReferenceBL"                         , ATT_SERVER_REFERENCE_BL                      , SYNTAX_DISTNAME_TYPE              , L"Server-Reference-BL"                       , 0                                             },
    { L"serverRole"                                , ATT_SERVER_ROLE                              , SYNTAX_INTEGER_TYPE               , L"Server-Role"                               , 0                                             },
    { L"serverState"                               , ATT_SERVER_STATE                             , SYNTAX_INTEGER_TYPE               , L"Server-State"                              , 0                                             },
    { L"serviceBindingInformation"                 , ATT_SERVICE_BINDING_INFORMATION              , SYNTAX_UNICODE_TYPE               , L"Service-Binding-Information"               , 0                                             },
    { L"serviceClassID"                            , ATT_SERVICE_CLASS_ID                         , SYNTAX_OCTET_STRING_TYPE          , L"Service-Class-ID"                          , 0                                             },
    { L"serviceClassInfo"                          , ATT_SERVICE_CLASS_INFO                       , SYNTAX_OCTET_STRING_TYPE          , L"Service-Class-Info"                        , 0                                             },
    { L"serviceClassName"                          , ATT_SERVICE_CLASS_NAME                       , SYNTAX_UNICODE_TYPE               , L"Service-Class-Name"                        , 0                                             },
    { L"serviceDNSName"                            , ATT_SERVICE_DNS_NAME                         , SYNTAX_UNICODE_TYPE               , L"Service-DNS-Name"                          , 0                                             },
    { L"serviceDNSNameType"                        , ATT_SERVICE_DNS_NAME_TYPE                    , SYNTAX_UNICODE_TYPE               , L"Service-DNS-Name-Type"                     , 0                                             },
    { L"serviceInstanceVersion"                    , ATT_SERVICE_INSTANCE_VERSION                 , SYNTAX_OCTET_STRING_TYPE          , L"Service-Instance-Version"                  , 0                                             },
    { L"servicePrincipalName"                      , ATT_SERVICE_PRINCIPAL_NAME                   , SYNTAX_UNICODE_TYPE               , L"Service-Principal-Name"                    , 0                                             },
    { L"setupCommand"                              , ATT_SETUP_COMMAND                            , SYNTAX_UNICODE_TYPE               , L"Setup-Command"                             , 0                                             },
    { L"shellContextMenu"                          , ATT_SHELL_CONTEXT_MENU                       , SYNTAX_UNICODE_TYPE               , L"Shell-Context-Menu"                        , 0                                             },
    { L"shellPropertyPages"                        , ATT_SHELL_PROPERTY_PAGES                     , SYNTAX_UNICODE_TYPE               , L"Shell-Property-Pages"                      , 0                                             },
    { L"shortServerName"                           , ATT_SHORT_SERVER_NAME                        , SYNTAX_UNICODE_TYPE               , L"Short-Server-Name"                         , 0                                             },
    { L"showInAddressBook"                         , ATT_SHOW_IN_ADDRESS_BOOK                     , SYNTAX_DISTNAME_TYPE              , L"Show-In-Address-Book"                      , 0                                             },
    { L"showInAdvancedViewOnly"                    , ATT_SHOW_IN_ADVANCED_VIEW_ONLY               , SYNTAX_BOOLEAN_TYPE               , L"Show-In-Advanced-View-Only"                , 0                                             },
    { L"sIDHistory"                                , ATT_SID_HISTORY                              , SYNTAX_SID_TYPE                   , L"SID-History"                               , 0                                             },
    { L"signatureAlgorithms"                       , ATT_SIGNATURE_ALGORITHMS                     , SYNTAX_UNICODE_TYPE               , L"Signature-Algorithms"                      , 0                                             },
    { L"siteGUID"                                  , ATT_SITE_GUID                                , SYNTAX_OCTET_STRING_TYPE          , L"Site-GUID"                                 , 0                                             },
    { L"siteLinkList"                              , ATT_SITE_LINK_LIST                           , SYNTAX_DISTNAME_TYPE              , L"Site-Link-List"                            , 0                                             },
    { L"siteList"                                  , ATT_SITE_LIST                                , SYNTAX_DISTNAME_TYPE              , L"Site-List"                                 , 0                                             },
    { L"siteObject"                                , ATT_SITE_OBJECT                              , SYNTAX_DISTNAME_TYPE              , L"Site-Object"                               , 0                                             },
    { L"siteObjectBL"                              , ATT_SITE_OBJECT_BL                           , SYNTAX_DISTNAME_TYPE              , L"Site-Object-BL"                            , 0                                             },
    { L"siteServer"                                , ATT_SITE_SERVER                              , SYNTAX_DISTNAME_TYPE              , L"Site-Server"                               , 0                                             },
    { L"mailAddress"                               , ATT_SMTP_MAIL_ADDRESS                        , SYNTAX_UNICODE_TYPE               , L"SMTP-Mail-Address"                         , 0                                             },
    { L"sPNMappings"                               , ATT_SPN_MAPPINGS                             , SYNTAX_UNICODE_TYPE               , L"SPN-Mappings"                              , 0                                             },
    { L"st"                                        , ATT_STATE_OR_PROVINCE_NAME                   , SYNTAX_UNICODE_TYPE               , L"State-Or-Province-Name"                    , 0                                             },
    { L"street"                                    , ATT_STREET_ADDRESS                           , SYNTAX_UNICODE_TYPE               , L"Street-Address"                            , 0                                             },
    { L"structuralObjectClass"                     , ATT_STRUCTURAL_OBJECT_CLASS                  , SYNTAX_OBJECT_ID_TYPE             , L"Structural-Object-Class"                   , 0                                             },
    { L"subClassOf"                                , ATT_SUB_CLASS_OF                             , SYNTAX_OBJECT_ID_TYPE             , L"Sub-Class-Of"                              , 0                                             },
    { L"subRefs"                                   , ATT_SUB_REFS                                 , SYNTAX_DISTNAME_TYPE              , L"Sub-Refs"                                  , 0                                             },
    { L"subSchemaSubEntry"                         , ATT_SUBSCHEMASUBENTRY                        , SYNTAX_DISTNAME_TYPE              , L"SubSchemaSubEntry"                         , 0                                             },
    { L"superScopeDescription"                     , ATT_SUPER_SCOPE_DESCRIPTION                  , SYNTAX_UNICODE_TYPE               , L"Super-Scope-Description"                   , 0                                             },
    { L"superScopes"                               , ATT_SUPER_SCOPES                             , SYNTAX_PRINT_CASE_STRING_TYPE     , L"Super-Scopes"                              , 0                                             },
    { L"superiorDNSRoot"                           , ATT_SUPERIOR_DNS_ROOT                        , SYNTAX_UNICODE_TYPE               , L"Superior-DNS-Root"                         , 0                                             },
    { L"supplementalCredentials"                   , ATT_SUPPLEMENTAL_CREDENTIALS                 , SYNTAX_OCTET_STRING_TYPE          , L"Supplemental-Credentials"                  , 0                                             },
    { L"supportedApplicationContext"               , ATT_SUPPORTED_APPLICATION_CONTEXT            , SYNTAX_OCTET_STRING_TYPE          , L"Supported-Application-Context"             , 0                                             },
    { L"sn"                                        , ATT_SURNAME                                  , SYNTAX_UNICODE_TYPE               , L"Surname"                                   , 0                                             },
    { L"syncAttributes"                            , ATT_SYNC_ATTRIBUTES                          , SYNTAX_INTEGER_TYPE               , L"Sync-Attributes"                           , 0                                             },
    { L"syncMembership"                            , ATT_SYNC_MEMBERSHIP                          , SYNTAX_DISTNAME_TYPE              , L"Sync-Membership"                           , 0                                             },
    { L"syncWithObject"                            , ATT_SYNC_WITH_OBJECT                         , SYNTAX_DISTNAME_TYPE              , L"Sync-With-Object"                          , 0                                             },
    { L"syncWithSID"                               , ATT_SYNC_WITH_SID                            , SYNTAX_SID_TYPE                   , L"Sync-With-SID"                             , 0                                             },
    { L"systemAuxiliaryClass"                      , ATT_SYSTEM_AUXILIARY_CLASS                   , SYNTAX_OBJECT_ID_TYPE             , L"System-Auxiliary-Class"                    , 0                                             },
    { L"systemFlags"                               , ATT_SYSTEM_FLAGS                             , SYNTAX_INTEGER_TYPE               , L"System-Flags"                              , 0                                             },
    { L"systemMayContain"                          , ATT_SYSTEM_MAY_CONTAIN                       , SYNTAX_OBJECT_ID_TYPE             , L"System-May-Contain"                        , 0                                             },
    { L"systemMustContain"                         , ATT_SYSTEM_MUST_CONTAIN                      , SYNTAX_OBJECT_ID_TYPE             , L"System-Must-Contain"                       , 0                                             },
    { L"systemOnly"                                , ATT_SYSTEM_ONLY                              , SYNTAX_BOOLEAN_TYPE               , L"System-Only"                               , 0                                             },
    { L"systemPossSuperiors"                       , ATT_SYSTEM_POSS_SUPERIORS                    , SYNTAX_OBJECT_ID_TYPE             , L"System-Poss-Superiors"                     , 0                                             },
    { L"telephoneNumber"                           , ATT_TELEPHONE_NUMBER                         , SYNTAX_UNICODE_TYPE               , L"Telephone-Number"                          , 0                                             },
    { L"teletexTerminalIdentifier"                 , ATT_TELETEX_TERMINAL_IDENTIFIER              , SYNTAX_OCTET_STRING_TYPE          , L"Teletex-Terminal-Identifier"               , 0                                             },
    { L"telexNumber"                               , ATT_TELEX_NUMBER                             , SYNTAX_OCTET_STRING_TYPE          , L"Telex-Number"                              , 0                                             },
    { L"primaryTelexNumber"                        , ATT_TELEX_PRIMARY                            , SYNTAX_UNICODE_TYPE               , L"Telex-Primary"                             , 0                                             },
    { L"templateRoots"                             , ATT_TEMPLATE_ROOTS                           , SYNTAX_DISTNAME_TYPE              , L"Template-Roots"                            , 0                                             },
    { L"terminalServer"                            , ATT_TERMINAL_SERVER                          , SYNTAX_OCTET_STRING_TYPE          , L"Terminal-Server"                           , 0                                             },
    { L"co"                                        , ATT_TEXT_COUNTRY                             , SYNTAX_UNICODE_TYPE               , L"Text-Country"                              , 0                                             },
    { L"textEncodedORAddress"                      , ATT_TEXT_ENCODED_OR_ADDRESS                  , SYNTAX_UNICODE_TYPE               , L"Text-Encoded-OR-Address"                   , 0                                             },
    { L"timeRefresh"                               , ATT_TIME_REFRESH                             , SYNTAX_I8_TYPE                    , L"Time-Refresh"                              , 0                                             },
    { L"timeVolChange"                             , ATT_TIME_VOL_CHANGE                          , SYNTAX_I8_TYPE                    , L"Time-Vol-Change"                           , 0                                             },
    { L"title"                                     , ATT_TITLE                                    , SYNTAX_UNICODE_TYPE               , L"Title"                                     , 0                                             },
    { L"tombstoneLifetime"                         , ATT_TOMBSTONE_LIFETIME                       , SYNTAX_INTEGER_TYPE               , L"Tombstone-Lifetime"                        , 0                                             },
    { L"transportAddressAttribute"                 , ATT_TRANSPORT_ADDRESS_ATTRIBUTE              , SYNTAX_OBJECT_ID_TYPE             , L"Transport-Address-Attribute"               , 0                                             },
    { L"transportDLLName"                          , ATT_TRANSPORT_DLL_NAME                       , SYNTAX_UNICODE_TYPE               , L"Transport-DLL-Name"                        , 0                                             },
    { L"transportType"                             , ATT_TRANSPORT_TYPE                           , SYNTAX_DISTNAME_TYPE              , L"Transport-Type"                            , 0                                             },
    { L"treatAsLeaf"                               , ATT_TREAT_AS_LEAF                            , SYNTAX_BOOLEAN_TYPE               , L"Treat-As-Leaf"                             , 0                                             },
    { L"treeName"                                  , ATT_TREE_NAME                                , SYNTAX_UNICODE_TYPE               , L"Tree-Name"                                 , 0                                             },
    { L"trustAttributes"                           , ATT_TRUST_ATTRIBUTES                         , SYNTAX_INTEGER_TYPE               , L"Trust-Attributes"                          , 0                                             },
    { L"trustAuthIncoming"                         , ATT_TRUST_AUTH_INCOMING                      , SYNTAX_OCTET_STRING_TYPE          , L"Trust-Auth-Incoming"                       , 0                                             },
    { L"trustAuthOutgoing"                         , ATT_TRUST_AUTH_OUTGOING                      , SYNTAX_OCTET_STRING_TYPE          , L"Trust-Auth-Outgoing"                       , 0                                             },
    { L"trustDirection"                            , ATT_TRUST_DIRECTION                          , SYNTAX_INTEGER_TYPE               , L"Trust-Direction"                           , 0                                             },
    { L"trustParent"                               , ATT_TRUST_PARENT                             , SYNTAX_DISTNAME_TYPE              , L"Trust-Parent"                              , 0                                             },
    { L"trustPartner"                              , ATT_TRUST_PARTNER                            , SYNTAX_UNICODE_TYPE               , L"Trust-Partner"                             , 0                                             },
    { L"trustPosixOffset"                          , ATT_TRUST_POSIX_OFFSET                       , SYNTAX_INTEGER_TYPE               , L"Trust-Posix-Offset"                        , 0                                             },
    { L"trustType"                                 , ATT_TRUST_TYPE                               , SYNTAX_INTEGER_TYPE               , L"Trust-Type"                                , 0                                             },
    { L"uASCompat"                                 , ATT_UAS_COMPAT                               , SYNTAX_INTEGER_TYPE               , L"UAS-Compat"                                , 0                                             },
    { L"uNCName"                                   , ATT_UNC_NAME                                 , SYNTAX_UNICODE_TYPE               , L"UNC-Name"                                  , 0                                             },
    { L"unicodePwd"                                , ATT_UNICODE_PWD                              , SYNTAX_OCTET_STRING_TYPE          , L"Unicode-Pwd"                               , 0                                             },
    { L"upgradeProductCode"                        , ATT_UPGRADE_PRODUCT_CODE                     , SYNTAX_OCTET_STRING_TYPE          , L"Upgrade-Product-Code"                      , 0                                             },
    { L"uPNSuffixes"                               , ATT_UPN_SUFFIXES                             , SYNTAX_UNICODE_TYPE               , L"UPN-Suffixes"                              , 0                                             },
    { L"userAccountControl"                        , ATT_USER_ACCOUNT_CONTROL                     , SYNTAX_INTEGER_TYPE               , L"User-Account-Control"                      , 0                                             },
    { L"userCert"                                  , ATT_USER_CERT                                , SYNTAX_OCTET_STRING_TYPE          , L"User-Cert"                                 , 0                                             },
    { L"comment"                                   , ATT_USER_COMMENT                             , SYNTAX_UNICODE_TYPE               , L"User-Comment"                              , 0                                             },
    { L"userParameters"                            , ATT_USER_PARAMETERS                          , SYNTAX_UNICODE_TYPE               , L"User-Parameters"                           , 0                                             },
    { L"userPassword"                              , ATT_USER_PASSWORD                            , SYNTAX_OCTET_STRING_TYPE          , L"User-Password"                             , 0                                             },
    { L"userPrincipalName"                         , ATT_USER_PRINCIPAL_NAME                      , SYNTAX_UNICODE_TYPE               , L"User-Principal-Name"                       , 0                                             },
    { L"userSharedFolder"                          , ATT_USER_SHARED_FOLDER                       , SYNTAX_UNICODE_TYPE               , L"User-Shared-Folder"                        , 0                                             },
    { L"userSharedFolderOther"                     , ATT_USER_SHARED_FOLDER_OTHER                 , SYNTAX_UNICODE_TYPE               , L"User-Shared-Folder-Other"                  , 0                                             },
    { L"userSMIMECertificate"                      , ATT_USER_SMIME_CERTIFICATE                   , SYNTAX_OCTET_STRING_TYPE          , L"User-SMIME-Certificate"                    , 0                                             },
    { L"userWorkstations"                          , ATT_USER_WORKSTATIONS                        , SYNTAX_UNICODE_TYPE               , L"User-Workstations"                         , 0                                             },
    { L"uSNChanged"                                , ATT_USN_CHANGED                              , SYNTAX_I8_TYPE                    , L"USN-Changed"                               , 0                                             },
    { L"uSNCreated"                                , ATT_USN_CREATED                              , SYNTAX_I8_TYPE                    , L"USN-Created"                               , 0                                             },
    { L"uSNDSALastObjRemoved"                      , ATT_USN_DSA_LAST_OBJ_REMOVED                 , SYNTAX_I8_TYPE                    , L"USN-DSA-Last-Obj-Removed"                  , 0                                             },
    { L"USNIntersite"                              , ATT_USN_INTERSITE                            , SYNTAX_INTEGER_TYPE               , L"USN-Intersite"                             , 0                                             },
    { L"uSNLastObjRem"                             , ATT_USN_LAST_OBJ_REM                         , SYNTAX_I8_TYPE                    , L"USN-Last-Obj-Rem"                          , 0                                             },
    { L"uSNSource"                                 , ATT_USN_SOURCE                               , SYNTAX_I8_TYPE                    , L"USN-Source"                                , 0                                             },
    { L"validAccesses"                             , ATT_VALID_ACCESSES                           , SYNTAX_INTEGER_TYPE               , L"Valid-Accesses"                            , 0                                             },
    { L"vendor"                                    , ATT_VENDOR                                   , SYNTAX_UNICODE_TYPE               , L"Vendor"                                    , 0                                             },
    { L"versionNumber"                             , ATT_VERSION_NUMBER                           , SYNTAX_INTEGER_TYPE               , L"Version-Number"                            , 0                                             },
    { L"versionNumberHi"                           , ATT_VERSION_NUMBER_HI                        , SYNTAX_INTEGER_TYPE               , L"Version-Number-Hi"                         , 0                                             },
    { L"versionNumberLo"                           , ATT_VERSION_NUMBER_LO                        , SYNTAX_INTEGER_TYPE               , L"Version-Number-Lo"                         , 0                                             },
    { L"volTableGUID"                              , ATT_VOL_TABLE_GUID                           , SYNTAX_OCTET_STRING_TYPE          , L"Vol-Table-GUID"                            , 0                                             },
    { L"volTableIdxGUID"                           , ATT_VOL_TABLE_IDX_GUID                       , SYNTAX_OCTET_STRING_TYPE          , L"Vol-Table-Idx-GUID"                        , 0                                             },
    { L"volumeCount"                               , ATT_VOLUME_COUNT                             , SYNTAX_INTEGER_TYPE               , L"Volume-Count"                              , 0                                             },
    { L"wbemPath"                                  , ATT_WBEM_PATH                                , SYNTAX_UNICODE_TYPE               , L"Wbem-Path"                                 , 0                                             },
    { L"wellKnownObjects"                          , ATT_WELL_KNOWN_OBJECTS                       , SYNTAX_DISTNAME_BINARY_TYPE       , L"Well-Known-Objects"                        , 0                                             },
    { L"whenChanged"                               , ATT_WHEN_CHANGED                             , SYNTAX_TIME_TYPE                  , L"When-Changed"                              , 0                                             },
    { L"whenCreated"                               , ATT_WHEN_CREATED                             , SYNTAX_TIME_TYPE                  , L"When-Created"                              , 0                                             },
    { L"winsockAddresses"                          , ATT_WINSOCK_ADDRESSES                        , SYNTAX_OCTET_STRING_TYPE          , L"Winsock-Addresses"                         , 0                                             },
    { L"wWWHomePage"                               , ATT_WWW_HOME_PAGE                            , SYNTAX_UNICODE_TYPE               , L"WWW-Home-Page"                             , 0                                             },
    { L"url"                                       , ATT_WWW_PAGE_OTHER                           , SYNTAX_UNICODE_TYPE               , L"WWW-Page-Other"                            , 0                                             },
    { L"x121Address"                               , ATT_X121_ADDRESS                             , SYNTAX_NUMERIC_STRING_TYPE        , L"X121-Address"                              , 0                                             },
    { L"userCertificate"                           , ATT_X509_CERT                                , SYNTAX_OCTET_STRING_TYPE          , L"X509-Cert"                                 , 0                                             },
    { L"aCSPolicy"                                 , CLASS_ACS_POLICY                             , 0                                 , L"ACS-Policy"                                , CLASS_TOP                                     },
    { L"aCSResourceLimits"                         , CLASS_ACS_RESOURCE_LIMITS                    , 0                                 , L"ACS-Resource-Limits"                       , CLASS_TOP                                     },
    { L"aCSSubnet"                                 , CLASS_ACS_SUBNET                             , 0                                 , L"ACS-Subnet"                                , CLASS_TOP                                     },
    { L"addressBookContainer"                      , CLASS_ADDRESS_BOOK_CONTAINER                 , 0                                 , L"Address-Book-Container"                    , CLASS_TOP                                     },
    { L"addressTemplate"                           , CLASS_ADDRESS_TEMPLATE                       , 0                                 , L"Address-Template"                          , CLASS_DISPLAY_TEMPLATE                        },
    { L"applicationEntity"                         , CLASS_APPLICATION_ENTITY                     , 0                                 , L"Application-Entity"                        , CLASS_TOP                                     },
    { L"applicationProcess"                        , CLASS_APPLICATION_PROCESS                    , 0                                 , L"Application-Process"                       , CLASS_TOP                                     },
    { L"applicationSettings"                       , CLASS_APPLICATION_SETTINGS                   , 0                                 , L"Application-Settings"                      , CLASS_TOP                                     },
    { L"applicationSiteSettings"                   , CLASS_APPLICATION_SITE_SETTINGS              , 0                                 , L"Application-Site-Settings"                 , CLASS_TOP                                     },
    { L"applicationVersion"                        , CLASS_APPLICATION_VERSION                    , 0                                 , L"Application-Version"                       , CLASS_APPLICATION_SETTINGS                    },
    { L"attributeSchema"                           , CLASS_ATTRIBUTE_SCHEMA                       , 0                                 , L"Attribute-Schema"                          , CLASS_TOP                                     },
    { L"builtinDomain"                             , CLASS_BUILTIN_DOMAIN                         , 0                                 , L"Builtin-Domain"                            , CLASS_TOP                                     },
    { L"categoryRegistration"                      , CLASS_CATEGORY_REGISTRATION                  , 0                                 , L"Category-Registration"                     , CLASS_LEAF                                    },
    { L"certificationAuthority"                    , CLASS_CERTIFICATION_AUTHORITY                , 0                                 , L"Certification-Authority"                   , CLASS_TOP                                     },
    { L"classRegistration"                         , CLASS_CLASS_REGISTRATION                     , 0                                 , L"Class-Registration"                        , CLASS_LEAF                                    },
    { L"classSchema"                               , CLASS_CLASS_SCHEMA                           , 0                                 , L"Class-Schema"                              , CLASS_TOP                                     },
    { L"classStore"                                , CLASS_CLASS_STORE                            , 0                                 , L"Class-Store"                               , CLASS_TOP                                     },
    { L"comConnectionPoint"                        , CLASS_COM_CONNECTION_POINT                   , 0                                 , L"Com-Connection-Point"                      , CLASS_CONNECTION_POINT                        },
    { L"computer"                                  , CLASS_COMPUTER                               , 0                                 , L"Computer"                                  , CLASS_USER                                    },
    { L"configuration"                             , CLASS_CONFIGURATION                          , 0                                 , L"Configuration"                             , CLASS_TOP                                     },
    { L"connectionPoint"                           , CLASS_CONNECTION_POINT                       , 0                                 , L"Connection-Point"                          , CLASS_LEAF                                    },
    { L"contact"                                   , CLASS_CONTACT                                , 0                                 , L"Contact"                                   , CLASS_ORGANIZATIONAL_PERSON                   },
    { L"container"                                 , CLASS_CONTAINER                              , 0                                 , L"Container"                                 , CLASS_TOP                                     },
    { L"controlAccessRight"                        , CLASS_CONTROL_ACCESS_RIGHT                   , 0                                 , L"Control-Access-Right"                      , CLASS_TOP                                     },
    { L"country"                                   , CLASS_COUNTRY                                , 0                                 , L"Country"                                   , CLASS_TOP                                     },
    { L"cRLDistributionPoint"                      , CLASS_CRL_DISTRIBUTION_POINT                 , 0                                 , L"CRL-Distribution-Point"                    , CLASS_TOP                                     },
    { L"crossRef"                                  , CLASS_CROSS_REF                              , 0                                 , L"Cross-Ref"                                 , CLASS_TOP                                     },
    { L"crossRefContainer"                         , CLASS_CROSS_REF_CONTAINER                    , 0                                 , L"Cross-Ref-Container"                       , CLASS_TOP                                     },
    { L"device"                                    , CLASS_DEVICE                                 , 0                                 , L"Device"                                    , CLASS_TOP                                     },
    { L"dfsConfiguration"                          , CLASS_DFS_CONFIGURATION                      , 0                                 , L"Dfs-Configuration"                         , CLASS_TOP                                     },
    { L"dHCPClass"                                 , CLASS_DHCP_CLASS                             , 0                                 , L"DHCP-Class"                                , CLASS_TOP                                     },
    { L"displaySpecifier"                          , CLASS_DISPLAY_SPECIFIER                      , 0                                 , L"Display-Specifier"                         , CLASS_TOP                                     },
    { L"displayTemplate"                           , CLASS_DISPLAY_TEMPLATE                       , 0                                 , L"Display-Template"                          , CLASS_TOP                                     },
    { L"dMD"                                       , CLASS_DMD                                    , 0                                 , L"DMD"                                       , CLASS_TOP                                     },
    { L"dnsNode"                                   , CLASS_DNS_NODE                               , 0                                 , L"Dns-Node"                                  , CLASS_TOP                                     },
    { L"dnsZone"                                   , CLASS_DNS_ZONE                               , 0                                 , L"Dns-Zone"                                  , CLASS_TOP                                     },
    { L"domain"                                    , CLASS_DOMAIN                                 , 0                                 , L"Domain"                                    , CLASS_TOP                                     },
    { L"domainDNS"                                 , CLASS_DOMAIN_DNS                             , 0                                 , L"Domain-DNS"                                , CLASS_DOMAIN                                  },
    { L"domainPolicy"                              , CLASS_DOMAIN_POLICY                          , 0                                 , L"Domain-Policy"                             , CLASS_LEAF                                    },
    { L"dSUISettings"                              , CLASS_DS_UI_SETTINGS                         , 0                                 , L"DS-UI-Settings"                            , CLASS_TOP                                     },
    { L"dSA"                                       , CLASS_DSA                                    , 0                                 , L"DSA"                                       , CLASS_APPLICATION_ENTITY                      },
    { L"dynamicObject"                             , CLASS_DYNAMIC_OBJECT                         , 0                                 , L"Dynamic-Object"                            , CLASS_TOP                                     },
    { L"fileLinkTracking"                          , CLASS_FILE_LINK_TRACKING                     , 0                                 , L"File-Link-Tracking"                        , CLASS_TOP                                     },
    { L"fileLinkTrackingEntry"                     , CLASS_FILE_LINK_TRACKING_ENTRY               , 0                                 , L"File-Link-Tracking-Entry"                  , CLASS_TOP                                     },
    { L"foreignSecurityPrincipal"                  , CLASS_FOREIGN_SECURITY_PRINCIPAL             , 0                                 , L"Foreign-Security-Principal"                , CLASS_TOP                                     },
    { L"fTDfs"                                     , CLASS_FT_DFS                                 , 0                                 , L"FT-Dfs"                                    , CLASS_TOP                                     },
    { L"group"                                     , CLASS_GROUP                                  , 0                                 , L"Group"                                     , CLASS_TOP                                     },
    { L"groupOfNames"                              , CLASS_GROUP_OF_NAMES                         , 0                                 , L"Group-Of-Names"                            , CLASS_TOP                                     },
    { L"groupPolicyContainer"                      , CLASS_GROUP_POLICY_CONTAINER                 , 0                                 , L"Group-Policy-Container"                    , CLASS_CONTAINER                               },
    { L"indexServerCatalog"                        , CLASS_INDEX_SERVER_CATALOG                   , 0                                 , L"Index-Server-Catalog"                      , CLASS_CONNECTION_POINT                        },
    { L"infrastructureUpdate"                      , CLASS_INFRASTRUCTURE_UPDATE                  , 0                                 , L"Infrastructure-Update"                     , CLASS_TOP                                     },
    { L"intellimirrorGroup"                        , CLASS_INTELLIMIRROR_GROUP                    , 0                                 , L"Intellimirror-Group"                       , CLASS_TOP                                     },
    { L"intellimirrorSCP"                          , CLASS_INTELLIMIRROR_SCP                      , 0                                 , L"Intellimirror-SCP"                         , CLASS_SERVICE_ADMINISTRATION_POINT            },
    { L"interSiteTransport"                        , CLASS_INTER_SITE_TRANSPORT                   , 0                                 , L"Inter-Site-Transport"                      , CLASS_TOP                                     },
    { L"interSiteTransportContainer"               , CLASS_INTER_SITE_TRANSPORT_CONTAINER         , 0                                 , L"Inter-Site-Transport-Container"            , CLASS_TOP                                     },
    { L"ipsecBase"                                 , CLASS_IPSEC_BASE                             , 0                                 , L"Ipsec-Base"                                , CLASS_TOP                                     },
    { L"ipsecFilter"                               , CLASS_IPSEC_FILTER                           , 0                                 , L"Ipsec-Filter"                              , CLASS_IPSEC_BASE                              },
    { L"ipsecISAKMPPolicy"                         , CLASS_IPSEC_ISAKMP_POLICY                    , 0                                 , L"Ipsec-ISAKMP-Policy"                       , CLASS_IPSEC_BASE                              },
    { L"ipsecNegotiationPolicy"                    , CLASS_IPSEC_NEGOTIATION_POLICY               , 0                                 , L"Ipsec-Negotiation-Policy"                  , CLASS_IPSEC_BASE                              },
    { L"ipsecNFA"                                  , CLASS_IPSEC_NFA                              , 0                                 , L"Ipsec-NFA"                                 , CLASS_IPSEC_BASE                              },
    { L"ipsecPolicy"                               , CLASS_IPSEC_POLICY                           , 0                                 , L"Ipsec-Policy"                              , CLASS_IPSEC_BASE                              },
    { L"leaf"                                      , CLASS_LEAF                                   , 0                                 , L"Leaf"                                      , CLASS_TOP                                     },
    { L"licensingSiteSettings"                     , CLASS_LICENSING_SITE_SETTINGS                , 0                                 , L"Licensing-Site-Settings"                   , CLASS_APPLICATION_SITE_SETTINGS               },
    { L"linkTrackObjectMoveTable"                  , CLASS_LINK_TRACK_OBJECT_MOVE_TABLE           , 0                                 , L"Link-Track-Object-Move-Table"              , CLASS_FILE_LINK_TRACKING                      },
    { L"linkTrackOMTEntry"                         , CLASS_LINK_TRACK_OMT_ENTRY                   , 0                                 , L"Link-Track-OMT-Entry"                      , CLASS_LEAF                                    },
    { L"linkTrackVolEntry"                         , CLASS_LINK_TRACK_VOL_ENTRY                   , 0                                 , L"Link-Track-Vol-Entry"                      , CLASS_LEAF                                    },
    { L"linkTrackVolumeTable"                      , CLASS_LINK_TRACK_VOLUME_TABLE                , 0                                 , L"Link-Track-Volume-Table"                   , CLASS_FILE_LINK_TRACKING                      },
    { L"locality"                                  , CLASS_LOCALITY                               , 0                                 , L"Locality"                                  , CLASS_TOP                                     },
    { L"lostAndFound"                              , CLASS_LOST_AND_FOUND                         , 0                                 , L"Lost-And-Found"                            , CLASS_TOP                                     },
    { L"mailRecipient"                             , CLASS_MAIL_RECIPIENT                         , 0                                 , L"Mail-Recipient"                            , CLASS_TOP                                     },
    { L"meeting"                                   , CLASS_MEETING                                , 0                                 , L"Meeting"                                   , CLASS_TOP                                     },
    { L"msCOM-Partition"                           , CLASS_MS_COM_PARTITION                       , 0                                 , L"ms-COM-Partition"                          , CLASS_TOP                                     },
    { L"msCOM-PartitionSet"                        , CLASS_MS_COM_PARTITIONSET                    , 0                                 , L"ms-COM-PartitionSet"                       , CLASS_TOP                                     },
    { L"msDS-App-Configuration"                    , CLASS_MS_DS_APP_CONFIGURATION                , 0                                 , L"ms-DS-App-Configuration"                   , CLASS_APPLICATION_SETTINGS                    },
    { L"msExchConfigurationContainer"              , CLASS_MS_EXCH_CONFIGURATION_CONTAINER        , 0                                 , L"ms-Exch-Configuration-Container"           , CLASS_CONTAINER                               },
    { L"msPKI-Enterprise-Oid"                      , CLASS_MS_PKI_ENTERPRISE_OID                  , 0                                 , L"ms-PKI-Enterprise-Oid"                     , CLASS_TOP                                     },
    { L"msPKI-Key-Recovery-Agent"                  , CLASS_MS_PKI_KEY_RECOVERY_AGENT              , 0                                 , L"ms-PKI-Key-Recovery-Agent"                 , CLASS_USER                                    },
    { L"mS-SQL-SQLServer"                          , CLASS_MS_SQL_SQLSERVER                       , 0                                 , L"MS-SQL-SQLServer"                          , CLASS_SERVICE_CONNECTION_POINT                },
    { L"mS-SQL-OLAPServer"                         , CLASS_MS_SQL_OLAPSERVER                      , 0                                 , L"MS-SQL-OLAPServer"                         , CLASS_SERVICE_CONNECTION_POINT                },
    { L"mS-SQL-SQLRepository"                      , CLASS_MS_SQL_SQLREPOSITORY                   , 0                                 , L"MS-SQL-SQLRepository"                      , CLASS_TOP                                     },
    { L"mS-SQL-SQLPublication"                     , CLASS_MS_SQL_SQLPUBLICATION                  , 0                                 , L"MS-SQL-SQLPublication"                     , CLASS_TOP                                     },
    { L"mS-SQL-SQLDatabase"                        , CLASS_MS_SQL_SQLDATABASE                     , 0                                 , L"MS-SQL-SQLDatabase"                        , CLASS_TOP                                     },
    { L"mS-SQL-OLAPDatabase"                       , CLASS_MS_SQL_OLAPDATABASE                    , 0                                 , L"MS-SQL-OLAPDatabase"                       , CLASS_TOP                                     },
    { L"mS-SQL-OLAPCube"                           , CLASS_MS_SQL_OLAPCUBE                        , 0                                 , L"MS-SQL-OLAPCube"                           , CLASS_TOP                                     },
    { L"msTAPI-RtConference"                       , CLASS_MS_TAPI_RT_CONFERENCE                  , 0                                 , L"ms-TAPI-Rt-Conference"                     , CLASS_TOP                                     },
    { L"msTAPI-RtPerson"                           , CLASS_MS_TAPI_RT_PERSON                      , 0                                 , L"ms-TAPI-Rt-Person"                         , CLASS_TOP                                     },
    { L"msWMI-IntRangeParam"                       , CLASS_MS_WMI_INTRANGEPARAM                   , 0                                 , L"ms-WMI-IntRangeParam"                      , CLASS_MS_WMI_RANGEPARAM                       },
    { L"msWMI-IntSetParam"                         , CLASS_MS_WMI_INTSETPARAM                     , 0                                 , L"ms-WMI-IntSetParam"                        , CLASS_MS_WMI_RANGEPARAM                       },
    { L"msWMI-MergeablePolicyTemplate"             , CLASS_MS_WMI_MERGEABLEPOLICYTEMPLATE         , 0                                 , L"ms-WMI-MergeablePolicyTemplate"            , CLASS_MS_WMI_POLICYTEMPLATE                   },
    { L"msWMI-ObjectEncoding"                      , CLASS_MS_WMI_OBJECTENCODING                  , 0                                 , L"ms-WMI-ObjectEncoding"                     , CLASS_TOP                                     },
    { L"msWMI-PolicyTemplate"                      , CLASS_MS_WMI_POLICYTEMPLATE                  , 0                                 , L"ms-WMI-PolicyTemplate"                     , CLASS_TOP                                     },
    { L"msWMI-PolicyType"                          , CLASS_MS_WMI_POLICYTYPE                      , 0                                 , L"ms-WMI-PolicyType"                         , CLASS_TOP                                     },
    { L"msWMI-RangeParam"                          , CLASS_MS_WMI_RANGEPARAM                      , 0                                 , L"ms-WMI-RangeParam"                         , CLASS_TOP                                     },
    { L"msWMI-RealRangeParam"                      , CLASS_MS_WMI_REALRANGEPARAM                  , 0                                 , L"ms-WMI-RealRangeParam"                     , CLASS_MS_WMI_RANGEPARAM                       },
    { L"msWMI-Rule"                                , CLASS_MS_WMI_RULE                            , 0                                 , L"ms-WMI-Rule"                               , CLASS_TOP                                     },
    { L"msWMI-ShadowObject"                        , CLASS_MS_WMI_SHADOWOBJECT                    , 0                                 , L"ms-WMI-ShadowObject"                       , CLASS_TOP                                     },
    { L"msWMI-SimplePolicyTemplate"                , CLASS_MS_WMI_SIMPLEPOLICYTEMPLATE            , 0                                 , L"ms-WMI-SimplePolicyTemplate"               , CLASS_MS_WMI_POLICYTEMPLATE                   },
    { L"msWMI-Som"                                 , CLASS_MS_WMI_SOM                             , 0                                 , L"ms-WMI-Som"                                , CLASS_TOP                                     },
    { L"msWMI-StringSetParam"                      , CLASS_MS_WMI_STRINGSETPARAM                  , 0                                 , L"ms-WMI-StringSetParam"                     , CLASS_MS_WMI_RANGEPARAM                       },
    { L"msWMI-UintRangeParam"                      , CLASS_MS_WMI_UINTRANGEPARAM                  , 0                                 , L"ms-WMI-UintRangeParam"                     , CLASS_MS_WMI_RANGEPARAM                       },
    { L"msWMI-UintSetParam"                        , CLASS_MS_WMI_UINTSETPARAM                    , 0                                 , L"ms-WMI-UintSetParam"                       , CLASS_MS_WMI_RANGEPARAM                       },
    { L"msWMI-UnknownRangeParam"                   , CLASS_MS_WMI_UNKNOWNRANGEPARAM               , 0                                 , L"ms-WMI-UnknownRangeParam"                  , CLASS_MS_WMI_RANGEPARAM                       },
    { L"msWMI-WMIGPO"                              , CLASS_MS_WMI_WMIGPO                          , 0                                 , L"ms-WMI-WMIGPO"                             , CLASS_TOP                                     },
    { L"mSMQConfiguration"                         , CLASS_MSMQ_CONFIGURATION                     , 0                                 , L"MSMQ-Configuration"                        , CLASS_TOP                                     },
    { L"msMQ-Custom-Recipient"                     , CLASS_MSMQ_CUSTOM_RECIPIENT                  , 0                                 , L"MSMQ-Custom-Recipient"                     , CLASS_TOP                                     },
    { L"mSMQEnterpriseSettings"                    , CLASS_MSMQ_ENTERPRISE_SETTINGS               , 0                                 , L"MSMQ-Enterprise-Settings"                  , CLASS_TOP                                     },
    { L"msMQ-Group"                                , CLASS_MSMQ_GROUP                             , 0                                 , L"MSMQ-Group"                                , CLASS_TOP                                     },
    { L"mSMQMigratedUser"                          , CLASS_MSMQ_MIGRATED_USER                     , 0                                 , L"MSMQ-Migrated-User"                        , CLASS_TOP                                     },
    { L"mSMQQueue"                                 , CLASS_MSMQ_QUEUE                             , 0                                 , L"MSMQ-Queue"                                , CLASS_TOP                                     },
    { L"mSMQSettings"                              , CLASS_MSMQ_SETTINGS                          , 0                                 , L"MSMQ-Settings"                             , CLASS_TOP                                     },
    { L"mSMQSiteLink"                              , CLASS_MSMQ_SITE_LINK                         , 0                                 , L"MSMQ-Site-Link"                            , CLASS_TOP                                     },
    { L"nTDSConnection"                            , CLASS_NTDS_CONNECTION                        , 0                                 , L"NTDS-Connection"                           , CLASS_LEAF                                    },
    { L"nTDSDSA"                                   , CLASS_NTDS_DSA                               , 0                                 , L"NTDS-DSA"                                  , CLASS_APPLICATION_SETTINGS                    },
    { L"nTDSService"                               , CLASS_NTDS_SERVICE                           , 0                                 , L"NTDS-Service"                              , CLASS_TOP                                     },
    { L"nTDSSiteSettings"                          , CLASS_NTDS_SITE_SETTINGS                     , 0                                 , L"NTDS-Site-Settings"                        , CLASS_APPLICATION_SITE_SETTINGS               },
    { L"nTFRSMember"                               , CLASS_NTFRS_MEMBER                           , 0                                 , L"NTFRS-Member"                              , CLASS_TOP                                     },
    { L"nTFRSReplicaSet"                           , CLASS_NTFRS_REPLICA_SET                      , 0                                 , L"NTFRS-Replica-Set"                         , CLASS_TOP                                     },
    { L"nTFRSSettings"                             , CLASS_NTFRS_SETTINGS                         , 0                                 , L"NTFRS-Settings"                            , CLASS_APPLICATION_SETTINGS                    },
    { L"nTFRSSubscriber"                           , CLASS_NTFRS_SUBSCRIBER                       , 0                                 , L"NTFRS-Subscriber"                          , CLASS_TOP                                     },
    { L"nTFRSSubscriptions"                        , CLASS_NTFRS_SUBSCRIPTIONS                    , 0                                 , L"NTFRS-Subscriptions"                       , CLASS_TOP                                     },
    { L"organization"                              , CLASS_ORGANIZATION                           , 0                                 , L"Organization"                              , CLASS_TOP                                     },
    { L"organizationalPerson"                      , CLASS_ORGANIZATIONAL_PERSON                  , 0                                 , L"Organizational-Person"                     , CLASS_PERSON                                  },
    { L"organizationalRole"                        , CLASS_ORGANIZATIONAL_ROLE                    , 0                                 , L"Organizational-Role"                       , CLASS_TOP                                     },
    { L"organizationalUnit"                        , CLASS_ORGANIZATIONAL_UNIT                    , 0                                 , L"Organizational-Unit"                       , CLASS_TOP                                     },
    { L"packageRegistration"                       , CLASS_PACKAGE_REGISTRATION                   , 0                                 , L"Package-Registration"                      , CLASS_TOP                                     },
    { L"person"                                    , CLASS_PERSON                                 , 0                                 , L"Person"                                    , CLASS_TOP                                     },
    { L"physicalLocation"                          , CLASS_PHYSICAL_LOCATION                      , 0                                 , L"Physical-Location"                         , CLASS_LOCALITY                                },
    { L"pKICertificateTemplate"                    , CLASS_PKI_CERTIFICATE_TEMPLATE               , 0                                 , L"PKI-Certificate-Template"                  , CLASS_TOP                                     },
    { L"pKIEnrollmentService"                      , CLASS_PKI_ENROLLMENT_SERVICE                 , 0                                 , L"PKI-Enrollment-Service"                    , CLASS_TOP                                     },
    { L"printQueue"                                , CLASS_PRINT_QUEUE                            , 0                                 , L"Print-Queue"                               , CLASS_CONNECTION_POINT                        },
    { L"queryPolicy"                               , CLASS_QUERY_POLICY                           , 0                                 , L"Query-Policy"                              , CLASS_TOP                                     },
    { L"remoteMailRecipient"                       , CLASS_REMOTE_MAIL_RECIPIENT                  , 0                                 , L"Remote-Mail-Recipient"                     , CLASS_TOP                                     },
    { L"remoteStorageServicePoint"                 , CLASS_REMOTE_STORAGE_SERVICE_POINT           , 0                                 , L"Remote-Storage-Service-Point"              , CLASS_SERVICE_ADMINISTRATION_POINT            },
    { L"residentialPerson"                         , CLASS_RESIDENTIAL_PERSON                     , 0                                 , L"Residential-Person"                        , CLASS_PERSON                                  },
    { L"rIDManager"                                , CLASS_RID_MANAGER                            , 0                                 , L"RID-Manager"                               , CLASS_TOP                                     },
    { L"rIDSet"                                    , CLASS_RID_SET                                , 0                                 , L"RID-Set"                                   , CLASS_TOP                                     },
    { L"rpcContainer"                              , CLASS_RPC_CONTAINER                          , 0                                 , L"Rpc-Container"                             , CLASS_CONTAINER                               },
    { L"rpcEntry"                                  , CLASS_RPC_ENTRY                              , 0                                 , L"rpc-Entry"                                 , CLASS_CONNECTION_POINT                        },
    { L"rpcGroup"                                  , CLASS_RPC_GROUP                              , 0                                 , L"rpc-Group"                                 , CLASS_RPC_ENTRY                               },
    { L"rpcProfile"                                , CLASS_RPC_PROFILE                            , 0                                 , L"rpc-Profile"                               , CLASS_RPC_ENTRY                               },
    { L"rpcProfileElement"                         , CLASS_RPC_PROFILE_ELEMENT                    , 0                                 , L"rpc-Profile-Element"                       , CLASS_RPC_ENTRY                               },
    { L"rpcServer"                                 , CLASS_RPC_SERVER                             , 0                                 , L"rpc-Server"                                , CLASS_RPC_ENTRY                               },
    { L"rpcServerElement"                          , CLASS_RPC_SERVER_ELEMENT                     , 0                                 , L"rpc-Server-Element"                        , CLASS_RPC_ENTRY                               },
    { L"rRASAdministrationConnectionPoint"         , CLASS_RRAS_ADMINISTRATION_CONNECTION_POINT   , 0                                 , L"RRAS-Administration-Connection-Point"      , CLASS_SERVICE_ADMINISTRATION_POINT            },
    { L"rRASAdministrationDictionary"              , CLASS_RRAS_ADMINISTRATION_DICTIONARY         , 0                                 , L"RRAS-Administration-Dictionary"            , CLASS_TOP                                     },
    { L"samDomain"                                 , CLASS_SAM_DOMAIN                             , 0                                 , L"Sam-Domain"                                , CLASS_TOP                                     },
    { L"samDomainBase"                             , CLASS_SAM_DOMAIN_BASE                        , 0                                 , L"Sam-Domain-Base"                           , CLASS_TOP                                     },
    { L"samServer"                                 , CLASS_SAM_SERVER                             , 0                                 , L"Sam-Server"                                , CLASS_SECURITY_OBJECT                         },
    { L"secret"                                    , CLASS_SECRET                                 , 0                                 , L"Secret"                                    , CLASS_LEAF                                    },
    { L"securityObject"                            , CLASS_SECURITY_OBJECT                        , 0                                 , L"Security-Object"                           , CLASS_TOP                                     },
    { L"securityPrincipal"                         , CLASS_SECURITY_PRINCIPAL                     , 0                                 , L"Security-Principal"                        , CLASS_TOP                                     },
    { L"server"                                    , CLASS_SERVER                                 , 0                                 , L"Server"                                    , CLASS_TOP                                     },
    { L"serversContainer"                          , CLASS_SERVERS_CONTAINER                      , 0                                 , L"Servers-Container"                         , CLASS_TOP                                     },
    { L"serviceAdministrationPoint"                , CLASS_SERVICE_ADMINISTRATION_POINT           , 0                                 , L"Service-Administration-Point"              , CLASS_SERVICE_CONNECTION_POINT                },
    { L"serviceClass"                              , CLASS_SERVICE_CLASS                          , 0                                 , L"Service-Class"                             , CLASS_LEAF                                    },
    { L"serviceConnectionPoint"                    , CLASS_SERVICE_CONNECTION_POINT               , 0                                 , L"Service-Connection-Point"                  , CLASS_CONNECTION_POINT                        },
    { L"serviceInstance"                           , CLASS_SERVICE_INSTANCE                       , 0                                 , L"Service-Instance"                          , CLASS_CONNECTION_POINT                        },
    { L"site"                                      , CLASS_SITE                                   , 0                                 , L"Site"                                      , CLASS_TOP                                     },
    { L"siteLink"                                  , CLASS_SITE_LINK                              , 0                                 , L"Site-Link"                                 , CLASS_TOP                                     },
    { L"siteLinkBridge"                            , CLASS_SITE_LINK_BRIDGE                       , 0                                 , L"Site-Link-Bridge"                          , CLASS_TOP                                     },
    { L"sitesContainer"                            , CLASS_SITES_CONTAINER                        , 0                                 , L"Sites-Container"                           , CLASS_TOP                                     },
    { L"storage"                                   , CLASS_STORAGE                                , 0                                 , L"Storage"                                   , CLASS_CONNECTION_POINT                        },
    { L"subnet"                                    , CLASS_SUBNET                                 , 0                                 , L"Subnet"                                    , CLASS_TOP                                     },
    { L"subnetContainer"                           , CLASS_SUBNET_CONTAINER                       , 0                                 , L"Subnet-Container"                          , CLASS_TOP                                     },
    { L"subSchema"                                 , CLASS_SUBSCHEMA                              , 0                                 , L"SubSchema"                                 , CLASS_TOP                                     },
    { L"top"                                       , CLASS_TOP                                    , 0                                 , L"Top"                                       , CLASS_TOP                                     },
    { L"trustedDomain"                             , CLASS_TRUSTED_DOMAIN                         , 0                                 , L"Trusted-Domain"                            , CLASS_LEAF                                    },
    { L"typeLibrary"                               , CLASS_TYPE_LIBRARY                           , 0                                 , L"Type-Library"                              , CLASS_TOP                                     },
    { L"user"                                      , CLASS_USER                                   , 0                                 , L"User"                                      , CLASS_ORGANIZATIONAL_PERSON                   },
    { L"volume"                                    , CLASS_VOLUME                                 , 0                                 , L"Volume"                                    , CLASS_CONNECTION_POINT                        } 

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\simmd.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simmd.h

ABSTRACT:

    Header file for the simmd*.c simulated APIs.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#ifndef _SIMMD_H_
#define _SIMMD_H_

// From simmderr.c

// For now, dsid = 0
#define KCCSimSetUpdError(pCR,problem,e) \
        KCCSimDoSetUpdError(pCR,problem,e,0,0)
#define KCCSimSetUpdErrorEx(pCR,problem,e,d) \
        KCCSimDoSetUpdError(pCR,problem,e,d,0)

#define KCCSimSetAttError(pCR,pDN,aTyp,problem,pAV,e) \
        KCCSimDoSetAttError(pCR,pDN,aTyp,problem,pAV,e,0,0)
#define KCCSimSetAttErrorEx(pCR,pDN,aTyp,problem,pAV,e,ed) \
        KCCSimDoSetAttError(pCR,pDN,aTyp,problem,pAV,e,ed,0)

#define KCCSimSetNamError(pCR,problem,pDN,e) \
        KCCSimDoSetNamError(pCR,problem,pDN,e,0,0)
#define KCCSimSetNamErrorEx(pCR,problem,pDN,e,ed) \
        KCCSimDoSetNamError(pCR,problem,pDN,e,ed,0)

int
KCCSimDoSetUpdError (
    COMMRES *                       pCommRes,
    USHORT                          problem,
    DWORD                           extendedErr,
    DWORD                           extendedData,
    DWORD                           dsid
    );

int
KCCSimDoSetAttError (
    COMMRES *                       pCommRes,
    PDSNAME                         pDN,
    ATTRTYP                         aTyp,
    USHORT                          problem,
    ATTRVAL *                       pAttVal,
    DWORD                           extendedErr,
    DWORD                           extendedData,
    DWORD                           dsid
    );

int
KCCSimDoSetNamError (
    COMMRES *                       pCommRes,
    USHORT                          problem,
    PDSNAME                         pDN,
    DWORD                           extendedErr,
    DWORD                           extendedData,
    DWORD                           dsid
    );

// From simmdnam.c

PSIM_ENTRY
KCCSimResolveName (
    PDSNAME                         pObject,
    COMMRES *                       pCommRes
    );

#endif // _SIMMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\schmap.h ===
/*++

Copyright (c) 2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    schmap.h

ABSTRACT:

    This file was automatically generated by schtable.exe.

--*/

#ifndef _KCCSIM_SCHMAP_H_
#define _KCCSIM_SCHMAP_H_

#define SCHTABLE_MAX_LDAPNAME_LEN       44
#define SCHTABLE_MAX_SCHEMANAME_LEN     45
#define SCHTABLE_NUM_ROWS               1134

struct _SCHTABLE_MAPPING {
    const WCHAR                         wszLdapDisplayName[1+SCHTABLE_MAX_LDAPNAME_LEN];
    const ATTRTYP                       attrType;
    const ULONG                         ulSyntax;
    const WCHAR                         wszSchemaRDN[1+SCHTABLE_MAX_SCHEMANAME_LEN];
    const ATTRTYP                       superClass;
};

extern const struct _SCHTABLE_MAPPING   schTable[];

#endif // _KCCSIM_SCHMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\simmderr.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simmderr.c

ABSTRACT:

    Simulates the error reporting routines
    for the Dir* APIs.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"

/***

    This is kind of an ugly file.  In order to avoid duplicating absurd
    amounts of code, we simply include mderror.c directly.  We stub out
    some #defines to prevent mderror.c from behaving in undesired ways,
    and then enclose its component functions in neat little wrappers.
    Function comments are omitted as each of the functions in this file
    is self-explanatory.

***/

// For simulating the error routines
#include <mdglobal.h>
#include <direrr.h>
#define __SCACHE_H__
#define _dbglobal_h_
#define _mdglobal_h_
#define _MDLOCAL_
#define _DSATOOLS_
// Need to undo override in kccsim.h since mderror.c includes dsevent.h
#undef LogEvent8

THSTATE *                           pFakeTHS;
#define pTHStls                     pFakeTHS
#define gfDsaWritable               FALSE
#define SetDsaWritability(x,y)

#include "../../ntdsa/src/mderror.c"

int
KCCSimDoSetUpdError (
    COMMRES *                       pCommRes,
    USHORT                          problem,
    DWORD                           dwExtendedErr,
    DWORD                           dwExtendedData,
    DWORD                           dsid
    )
{
    int                             iRet;

    pFakeTHS = KCCSIM_NEW (THSTATE);
    pFakeTHS->fDRA = FALSE;

    iRet = DoSetUpdError (
        problem,
        dwExtendedErr,
        dwExtendedData,
        dsid
        );

    pCommRes->errCode = pFakeTHS->errCode;
    pCommRes->pErrInfo = pFakeTHS->pErrInfo;

    KCCSimFree (pFakeTHS);

    return iRet;
}

int
KCCSimDoSetAttError (
    COMMRES *                       pCommRes,
    PDSNAME                         pDN,
    ATTRTYP                         aTyp,
    USHORT                          problem,
    ATTRVAL *                       pAttVal,
    DWORD                           extendedErr,
    DWORD                           extendedData,
    DWORD                           dsid
    )
{
    int                             iRet;

    pFakeTHS = KCCSIM_NEW (THSTATE);
    pFakeTHS->fDRA = FALSE;
    
    iRet = DoSetAttError (
        pDN,
        aTyp,
        problem,
        pAttVal,
        extendedErr,
        extendedData,
        dsid
        );

    pCommRes->errCode = pFakeTHS->errCode;
    pCommRes->pErrInfo = pFakeTHS->pErrInfo;

    KCCSimFree (pFakeTHS);

    return iRet;
}

int
KCCSimDoSetNamError (
    COMMRES *                       pCommRes,
    USHORT                          problem,
    PDSNAME                         pDN,
    DWORD                           dwExtendedErr,
    DWORD                           dwExtendedData,
    DWORD                           dsid
    )
{
    int                             iRet;

    pFakeTHS = KCCSIM_NEW (THSTATE);
    pFakeTHS->fDRA = FALSE;

    iRet = DoSetNamError (
        problem,
        pDN,
        dwExtendedErr,
        dwExtendedData,
        dsid
        );

    pCommRes->errCode = pFakeTHS->errCode;
    pCommRes->pErrInfo = pFakeTHS->pErrInfo;

    KCCSimFree (pFakeTHS);

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\simism.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simism.c

ABSTRACT:

    Simulates the ISM APIs.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <ismapi.h>
#include <attids.h>
#include <debug.h>
#include "../../ism/include/common.h"
#include "kccsim.h"
#include "util.h"
#include "dir.h"

/***

    The following functions are callbacks for the ISM simulator library.

***/

DWORD
DirReadTransport (
    IN  PVOID                       pConnectionHandle,
    IO  PTRANSPORT_INSTANCE         pTransport
    )
/*++

Routine Description:

    Retrieves information about a transport.

Arguments:

    pConnectionHandle   - Not used.
    pTransport          - The transport to fill with data.  It is expected that
                          pTransport->Name is valid initially.

Return Value:

    Win32 error code.

--*/
{
    PSIM_ENTRY                      pEntry;
    SIM_ATTREF                      attRef;
    PDSNAME                         pdn;

    pdn = KCCSimAllocDsname (pTransport->Name);
    pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
    KCCSimFree (pdn);
    if (pEntry != NULL) {

        if (KCCSimGetAttribute (pEntry, ATT_REPL_INTERVAL, &attRef)) {
            pTransport->ReplInterval = 
                *((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal);
        }
        if (KCCSimGetAttribute (pEntry, ATT_OPTIONS, &attRef)) {
            pTransport->Options =
                *((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal);
        }

    }

    return ERROR_SUCCESS;
}

VOID
DirFreeSiteList (
    IN  DWORD                       dwNumberSites,
    IN  LPWSTR *                    ppwszSiteList
    )
/*++

Routine Description:

    Frees an array of strings.

Arguments:

    dwNumberSites       - The number of strings in the array.
    ppwszSiteList       - The array to free.

Return Value:

    None.

--*/
{
    ULONG                           ulSiteAt;

    if (ppwszSiteList == NULL) {
        return;
    }

    for (ulSiteAt = 0; ulSiteAt < dwNumberSites; ulSiteAt++) {
        KCCSimFree (ppwszSiteList[ulSiteAt]);
    }
    KCCSimFree (ppwszSiteList);
}

VOID
DirCopySiteList (
    IN  DWORD                       dwNumberSites,
    IN  LPWSTR *                    ppwszSiteList,
    OUT LPWSTR **                   pppwszCopy
    )
/*++

Routine Description:

    Makes a copy of an array of strings.

Arguments:

    dwNumberSites       - Number of strings in the array.
    ppwszSiteList       - The array to copy.
    pppwszCopy          - Pointer to the copy.

Return Value:

    None.

--*/
{
    LPWSTR *                        ppwszCopy;
    ULONG                           ulSiteAt;

    ppwszCopy = KCCSIM_NEW_ARRAY (LPWSTR, dwNumberSites);

    // Fill the copy with NULLs in case we run out of memory
    for (ulSiteAt = 0; ulSiteAt < dwNumberSites; ulSiteAt++) {
        ppwszCopy[ulSiteAt] = NULL;
    }

    // Copy the strings
    for (ulSiteAt = 0; ulSiteAt < dwNumberSites; ulSiteAt++) {
        if (ppwszSiteList[ulSiteAt] != NULL) {
            ppwszCopy[ulSiteAt] = KCCSIM_WCSDUP (ppwszSiteList[ulSiteAt]);
        }
    }

    *pppwszCopy = ppwszCopy;
}

DWORD
DirGetSiteList (
    IN  PVOID                       pConnectionHandle,
    OUT LPDWORD                     pdwNumberSites,
    OUT LPWSTR **                   pppwszSiteList
    )
/*++

Routine Description:

    Retrieves a list of all sites in the enterprise.

Arguments:

    pConnectionHandle   - Not used.
    pdwNumberSites      - The number of sites in the enterprise.
    pppwszSiteList      - Array of site DNs.

Return Value:

    Win32 error code.

--*/
{
    PSIM_ENTRY                      pEntryConfig, pEntrySitesContainer,
                                    pEntrySite;

    DWORD                           dwNumberSites = 0;
    LPWSTR *                        ppwszSiteList = NULL;
    ULONG                           ulSiteAt;

    *pdwNumberSites = 0;
    *pppwszSiteList = NULL;         // Default

    __try {

        // First locate the sites container.
        pEntryConfig = KCCSimDsnameToEntry (
            KCCSimAnchorDn (KCCSIM_ANCHOR_CONFIG_DN), KCCSIM_NO_OPTIONS);
        pEntrySitesContainer = KCCSimFindFirstChild (
            pEntryConfig, CLASS_SITES_CONTAINER, NULL);
        if (pEntrySitesContainer == NULL) {
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_SITES_CONTAINER_MISSING
            );
        }

        // Now determine the number of sites.
        dwNumberSites = 0;
        for (pEntrySite = KCCSimFindFirstChild (
                pEntrySitesContainer, CLASS_SITE, NULL);
             pEntrySite != NULL;
             pEntrySite = KCCSimFindNextChild (
                pEntrySite, CLASS_SITE, NULL)) {
            dwNumberSites++;
        }

        // Now fill in the list with NULLs in case we run out of memory.
        ppwszSiteList = KCCSIM_NEW_ARRAY (LPWSTR, dwNumberSites);
        for (ulSiteAt = 0; ulSiteAt < dwNumberSites; ulSiteAt++) {
            ppwszSiteList[ulSiteAt] = NULL;
        }

        ulSiteAt = 0;
        for (pEntrySite = KCCSimFindFirstChild (
                pEntrySitesContainer, CLASS_SITE, NULL);
             pEntrySite != NULL;
             pEntrySite = KCCSimFindNextChild (
                pEntrySite, CLASS_SITE, NULL)) {

            Assert (ulSiteAt < dwNumberSites);
            ppwszSiteList[ulSiteAt] = KCCSIM_WCSDUP (pEntrySite->pdn->StringName);
            ulSiteAt++;

        }
        Assert (ulSiteAt == dwNumberSites);

        // We're done!
        *pdwNumberSites = dwNumberSites;
        *pppwszSiteList = ppwszSiteList;

    // If an exception occurs and the site list has been allocated, be sure to free it.
    // If the site list has not yet been allocated, ppwszSiteList will still have its
    // initial value of NULL.
    } __finally {
    
        if (AbnormalTermination() && (ppwszSiteList!=NULL)) {
            DirFreeSiteList (dwNumberSites, ppwszSiteList);
        }

    }

    return ERROR_SUCCESS;
}

DWORD
DirGetSiteBridgeheadList(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPCWSTR SiteDN,
    LPDWORD pNumberServers,
    LPWSTR **ppServerList
    )
/*++

Routine Description:

     ISM dir-layer callback to get bridgehead list

Arguments:

     pTransport - ISM transport object
     ConnectionHandle - connection state context, unused
     SiteDN - DN of site for which bridgheads are requested
     pNumberServers - address to which the number found is written
     ppServerList - address to which is written the array of servers

Return Value:

    Win32 error code.

--*/
{
    LPWSTR *                        pServerList = NULL;
    ULONG                           cb;

    PSIM_ENTRY                      pEntryTransport, pEntrySite;
    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pValAt;

    const DSNAME *                  pdnSite = NULL;
    PDSNAME                         pdn = NULL;
    ULONG                           ulNumBridgeheads, ul;

    if (NULL == ppServerList) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppServerList = NULL;

    __try {

        pdn = KCCSimAllocDsname (pTransport->Name);
        pEntryTransport = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
        KCCSimFree (pdn);
        pdn = NULL;
        pdn = KCCSimAllocDsname (SiteDN);
        pEntrySite = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
        KCCSimFree (pdn);
        pdn = NULL;

        if (pEntryTransport == NULL || pEntrySite == NULL) {
            return ERROR_NOT_FOUND;
        }

        if (!KCCSimGetAttribute (
                pEntryTransport,
                ATT_BRIDGEHEAD_SERVER_LIST_BL,
                &attRef
                )) {
            // No bridgehead list attribute.  Just return NULL.
            *pNumberServers = 0;
            *ppServerList = NULL;
            return NO_ERROR;
        }

        // First determine how many servers are bridgeheads in this site.
        ulNumBridgeheads = 0;
        for (pValAt = attRef.pAttr->pValFirst;
             pValAt != NULL;
             pValAt = pValAt->next) {
            DSNAME *pdnServer = (SYNTAX_DISTNAME *) pValAt->pVal;
            if (KCCSimNthAncestor (pEntrySite->pdn, pdnServer) != -1) {
                ulNumBridgeheads++;
            }
        }

        // Allocate space
        cb = sizeof (LPWSTR) * ulNumBridgeheads;
        pServerList = KCCSimAlloc (cb);

        // Fill in the bridgeheads.
        ul = 0;
        for (pValAt = attRef.pAttr->pValFirst;
             pValAt != NULL;
             pValAt = pValAt->next) {
            DSNAME *pdnServer = (SYNTAX_DISTNAME *) pValAt->pVal;
            if (KCCSimNthAncestor (pEntrySite->pdn, pdnServer) != -1) {
                Assert (ul < ulNumBridgeheads);
                pServerList[ul] = KCCSIM_WCSDUP( pdnServer->StringName );
                ul++;
            }
        }
        Assert (ul == ulNumBridgeheads);

        *pNumberServers = ul;
        *ppServerList = pServerList;

    } __finally {

        if (pdn) {
            KCCSimFree (pdn);
        }
        if (AbnormalTermination ()) {
            KCCSimFree (pServerList);
        }

    }

    return NO_ERROR;
}

VOID
DirTerminateIteration (
    OUT PVOID *                     ppIterateContextHandle
    )
/*++

Routine Description:

    Terminates an iterator.  An iterator is just a PSIM_ENTRY or
    a PSIM_VALUE, so we do not need to free anything.

Arguments:

    ppIterateContextHandle - Handle of the iterator to terminate.

Return Value:

    None.

--*/
{
    *ppIterateContextHandle = NULL;
}

DWORD
DirIterateSiteLinks (
    IN  PTRANSPORT_INSTANCE         pTransport,
    IN  PVOID                       pConnectionHandle,
    IO  PVOID *                     ppIterateContextHandle,
    IO  LPWSTR                      pwszSiteLinkName
    )
/*++

Routine Description:

    Iterates over all site links in a transport.

Arguments:

    pTransport          - The transport to search.
    pConnectionHandle   - Not used.
    ppIterateContextHandle - Handle of the iterator. If *ppIterateContextHandle
                          is NULL, creates a new iterator.
    pwszSiteLinkName    - Preallocated string buffer of length
                          MAX_REG_COMPONENT that will hold the site link DN.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntryTransport, pEntrySiteLink;
    PDSNAME                         pdnTransport = NULL;

    __try {

        pEntrySiteLink = *((PSIM_ENTRY *) ppIterateContextHandle);

        if (pEntrySiteLink == NULL) {
            // This is the first call to IterateSiteLinks ().
            pdnTransport = KCCSimAllocDsname (pTransport->Name);
            pEntryTransport = KCCSimDsnameToEntry (pdnTransport, KCCSIM_NO_OPTIONS);
            pEntrySiteLink = KCCSimFindFirstChild (
                pEntryTransport, CLASS_SITE_LINK, NULL);
        } else {
            pEntrySiteLink = KCCSimFindNextChild (
                pEntrySiteLink, CLASS_SITE_LINK, NULL);
        }

        *ppIterateContextHandle = (PVOID) pEntrySiteLink;

        if (pEntrySiteLink == NULL) {
            pwszSiteLinkName = L'\0';
        } else {
            wcsncpy (
                pwszSiteLinkName,
                pEntrySiteLink->pdn->StringName,
                MAX_REG_COMPONENT
                );
        }

    } __finally {

        KCCSimFree (pdnTransport);

    }

    if (*ppIterateContextHandle == NULL) {
        return ERROR_NO_MORE_ITEMS;
    } else {
        return ERROR_SUCCESS;
    }
}

VOID
DirFreeMultiszString (
    IN  LPWSTR                      pwszMultiszString
    )
/*++

Routine Description:

    Frees a multi-sz string.

Arguments:

    pwszMultiszString   - The string to free.

Return Value:

    None.

--*/
{
    KCCSimFree (pwszMultiszString);
}

VOID
DirFreeSchedule (
    IN  PBYTE                       pSchedule
    )
/*++

Routine Description:

    Frees a schedule.

Arguments:

    pSchedule           - The schedule to free.

Return Value:

    None.

--*/
{
    KCCSimFree (pSchedule);
}

DWORD
DirReadSiteLink (
    IN  PTRANSPORT_INSTANCE         pTransport,
    IN  PVOID                       pConnectionHandle,
    IN  LPWSTR                      pwszSiteLinkName,
    OUT LPWSTR *                    ppwszSiteList,
    IO  PISM_LINK                   pLinkValue,
    OUT PBYTE *                     ppSchedule OPTIONAL
    )
/*++

Routine Description:

    Reads information out of a site link.

Arguments:

    pTransport          - The transport type of this site-link.
    pConnectionHandle   - Not used.
    pwszSiteLinkName    - The DN of this site link.
    ppwszSiteList       - A list of sites that belong to this site link,
                          stored as a multi-sz string.
    pLinkValue          - Pointer to an ISM_LINK that will hold
                          supplementary information about this site link.
    ppSchedule          - The schedule of this site link.

Return Value:

    Win32 error code.

--*/
{
    PSIM_ENTRY                      pEntrySiteLink;
    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pValAt;
    PDSNAME                         pdnSiteLink = NULL;
    PDSNAME                         pdnSiteVal;

    ULONG                           cbSiteList, ulPos;
    LPWSTR                          pwszSiteList = NULL;
    PBYTE                           pSchedule = NULL;

    // Set the defaults.
    if (ppwszSiteList != NULL) {
        *ppwszSiteList = NULL;
    }
    if (ppSchedule != NULL) {
        *ppSchedule = NULL;
    }

    __try {

        pdnSiteLink = KCCSimAllocDsname (pwszSiteLinkName);
        pEntrySiteLink = KCCSimDsnameToEntry (pdnSiteLink, KCCSIM_NO_OPTIONS);

        Assert (pEntrySiteLink != NULL);

        // Site list attribute
        if (KCCSimGetAttribute (pEntrySiteLink, ATT_SITE_LIST, &attRef)) {

            cbSiteList = 0;
            for (pValAt = attRef.pAttr->pValFirst;
                 pValAt != NULL;
                 pValAt = pValAt->next) {

                pdnSiteVal = (SYNTAX_DISTNAME *) pValAt->pVal;
                cbSiteList += (wcslen (pdnSiteVal->StringName) + 1);

            }
            cbSiteList++;   // For the multisz trailing \0

            pwszSiteList = KCCSimAlloc (sizeof (WCHAR) * cbSiteList);

            ulPos = 0;
            for (pValAt = attRef.pAttr->pValFirst;
                 pValAt != NULL;
                 pValAt = pValAt->next) {

                pdnSiteVal = (SYNTAX_DISTNAME *) pValAt->pVal;
                wcscpy (&pwszSiteList[ulPos], pdnSiteVal->StringName);
                ulPos += (wcslen (pdnSiteVal->StringName) + 1);

            }
            pwszSiteList[ulPos++] = L'\0';  // Multisz trailing \0
            Assert (cbSiteList == ulPos);

        }

        // Cost attribute
        if (KCCSimGetAttribute (pEntrySiteLink, ATT_COST, &attRef)) {
            pLinkValue->ulCost =
                *((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal);
        }

        // Replication Interval attribute
        if (KCCSimGetAttribute (pEntrySiteLink, ATT_REPL_INTERVAL, &attRef)) {
            pLinkValue->ulReplicationInterval =
                *((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal);
        }

        // Options attribute
        if (KCCSimGetAttribute (pEntrySiteLink, ATT_OPTIONS, &attRef)) {
            pLinkValue->ulOptions =
                *((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal);
        }

        // Schedule attribute
        if (KCCSimGetAttribute (pEntrySiteLink, ATT_SCHEDULE, &attRef)) {
            pSchedule = KCCSimAlloc (attRef.pAttr->pValFirst->ulLen);
            memcpy (
                pSchedule,
                attRef.pAttr->pValFirst->pVal,
                attRef.pAttr->pValFirst->ulLen
                );
        }

        if (ppwszSiteList != NULL) {
            *ppwszSiteList = pwszSiteList;
        }
        if (ppSchedule != NULL) {
            *ppSchedule = pSchedule;
        }

    } __finally {

        KCCSimFree (pdnSiteLink);
        if (AbnormalTermination ()) {
            DirFreeMultiszString (pwszSiteList);
            DirFreeSchedule (pSchedule);
        }

    }

    return ERROR_SUCCESS;
}

DWORD
DirIterateSiteLinkBridges (
    IN  PTRANSPORT_INSTANCE         pTransport,
    IN  PVOID                       pConnectionHandle,
    IO  PVOID *                     ppIterateContextHandle,
    IO  LPWSTR                      pwszSiteLinkBridgeName
    )
/*++

Routine Description:

    Iterates over the bridgeheads for a given transport.

Arguments:

    pTransport          - The transport to search.
    pConnectionHandle   - Not used.
    ppIterateContextHandle - Handle of the iterator. If *ppIterateContextHandle
                          is NULL, creates a new iterator.
    pwszSiteLinkBridgeName - Preallocated string buffer of length
                          MAX_REG_COMPONENT that will hold the name of the
                          bridghead server.

Return Value:

    

--*/
{
    PSIM_ENTRY                      pEntryTransport;
    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pValBridgehead;
    PDSNAME                         pdnTransport = NULL;

    __try {

        pValBridgehead = *((PSIM_VALUE *) ppIterateContextHandle);

        if (pValBridgehead == NULL) {
            // This is the first call
            pdnTransport = KCCSimAllocDsname (pTransport->Name);
            pEntryTransport = KCCSimDsnameToEntry (pdnTransport, KCCSIM_NO_OPTIONS);
            if (KCCSimGetAttribute (pEntryTransport,
                    ATT_BRIDGEHEAD_SERVER_LIST_BL, &attRef)) {
                pValBridgehead = attRef.pAttr->pValFirst;
            }
        } else {
            // Not the first call
            pValBridgehead = pValBridgehead->next;
        }

        *ppIterateContextHandle = (PVOID) pValBridgehead;

        if (pValBridgehead == NULL) {
            pwszSiteLinkBridgeName[0] = L'\0';
        } else {
            wcsncpy (
                pwszSiteLinkBridgeName,
                (LPWSTR) pValBridgehead->pVal,
                MAX_REG_COMPONENT
                );
        }

    } __finally {

        KCCSimFree (pdnTransport);

    }

    if (*ppIterateContextHandle == NULL) {
        return ERROR_NO_MORE_ITEMS;
    } else {
        return ERROR_SUCCESS;
    }
}

DWORD
DirReadSiteLinkBridge (
    IN  PTRANSPORT_INSTANCE         pTransport,
    IN  PVOID                       pConnectionHandle,
    IN  LPWSTR                      pwszSiteLinkBridgeName,
    IO  LPWSTR *                    ppwszSiteLinkList
    )
//
// Not implemented
//
{
    return ERROR_INVALID_PARAMETER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\simlsa.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simlsa.c

ABSTRACT:

    Simulates the LSA functions.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"

VOID
KCCSimAllocLsaUnicodeString (
    IN  LPCWSTR                     pwszString,
    IO  PLSAPR_UNICODE_STRING       pLsaUnicodeString
    )
/*++

Routine Description:

    Converter for LSAPR_UINCODE_STRINGs.

Arguments:

    pwszString          - String to convert.
    pLsaUnicodeString   - Pointer to an LSAPR_UNICODE_STRING that will hold
                          the result.

Return Value:

    None.

--*/
{
    pLsaUnicodeString->Buffer = KCCSIM_WCSDUP (pwszString);
    pLsaUnicodeString->Length = (USHORT)wcslen (pLsaUnicodeString->Buffer);
}

VOID
KCCSimQueryDnsDomainInformation (
    IO  PLSAPR_POLICY_DNS_DOMAIN_INFO pDnsDomainInfo
    )
/*++

Routine Description:

    Helper function for SimLsaIQueryInformationPolicyTrusted that
    fills an LSAPR_POLICY_DNS_DOMAIN_INFO structure with data.

Arguments:

    pDnsDomainInfo      - Pointer to a DNS domain info structure that will
                          hold the result.

Return Value:

    None.

--*/
{
    KCCSimAllocLsaUnicodeString (
        KCCSimAnchorString (KCCSIM_ANCHOR_DOMAIN_NAME),
        &pDnsDomainInfo->Name
        );
    KCCSimAllocLsaUnicodeString (
        KCCSimAnchorString (KCCSIM_ANCHOR_DOMAIN_DNS_NAME),
        &pDnsDomainInfo->DnsDomainName
        );
    KCCSimAllocLsaUnicodeString (
        KCCSimAnchorString (KCCSIM_ANCHOR_ROOT_DOMAIN_DNS_NAME),
        &pDnsDomainInfo->DnsForestName
        );
    memcpy (
        &pDnsDomainInfo->DomainGuid,
        &(KCCSimAnchorDn (KCCSIM_ANCHOR_DOMAIN_DN))->Guid,
        sizeof (GUID)
        );
    pDnsDomainInfo->Sid = NULL;
}

NTSTATUS NTAPI
SimLsaIQueryInformationPolicyTrusted (
    IN  POLICY_INFORMATION_CLASS    InformationClass,
    OUT PLSAPR_POLICY_INFORMATION * Buffer
    )
/*++

Routine Description:

    Simulates the LsaIQueryInformationPolicyTrusted API.

Arguments:

    InformationClass    - The information class to query.
    Buffer              - A pointer to the result.

Return Value:

    STATUS_*.

--*/
{
    PLSAPR_POLICY_INFORMATION       pPolicyInfo;
    NTSTATUS                        ntStatus;

    pPolicyInfo = KCCSIM_NEW (LSAPR_POLICY_INFORMATION);

    switch (InformationClass) {

        case PolicyDnsDomainInformation:
            KCCSimQueryDnsDomainInformation (
                &pPolicyInfo->PolicyDnsDomainInfo
                );
            break;

        case PolicyAuditLogInformation:
        case PolicyAuditEventsInformation:
        case PolicyPrimaryDomainInformation:
        case PolicyPdAccountInformation:
        case PolicyAccountDomainInformation:
        case PolicyLsaServerRoleInformation:
        case PolicyReplicaSourceInformation:
        case PolicyDefaultQuotaInformation:
        case PolicyModificationInformation:
        case PolicyAuditFullSetInformation:
        case PolicyAuditFullQueryInformation:
        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_POLICY_INFORMATION_CLASS
                );
            break;

    }

    *Buffer = pPolicyInfo;

    return STATUS_SUCCESS;

}

VOID NTAPI
SimLsaIFree_LSAPR_POLICY_INFORMATION (
    IN  POLICY_INFORMATION_CLASS    InformationClass,
    IN  PLSAPR_POLICY_INFORMATION   PolicyInformation
    )
/*++

Routine Description:

    Simulates the LsaIFree_LSAPR_POLICY_INFORMATION API.

Arguments:

    InformationClass    - The information class of PolicyInformation.
    PolicyInformation   - The structure to free.

Return Value:

    None.

--*/
{
    PLSAPR_POLICY_DNS_DOMAIN_INFO   pDnsDomainInfo;

    if (PolicyInformation != NULL) {

        switch (InformationClass) {

            case PolicyDnsDomainInformation:
                pDnsDomainInfo = &PolicyInformation->PolicyDnsDomainInfo;
                if (pDnsDomainInfo->Name.Buffer != NULL) {
                    KCCSimFree (pDnsDomainInfo->Name.Buffer);
                }
                if (pDnsDomainInfo->DnsDomainName.Buffer != NULL) {
                    KCCSimFree (pDnsDomainInfo->DnsDomainName.Buffer);
                }
                if (pDnsDomainInfo->DnsForestName.Buffer != NULL) {
                    KCCSimFree (pDnsDomainInfo->DnsForestName.Buffer);
                }
                if (pDnsDomainInfo->Sid != NULL) {
                    KCCSimFree (pDnsDomainInfo->Sid);
                }
                break;

            case PolicyAuditLogInformation:
            case PolicyAuditEventsInformation:
            case PolicyPrimaryDomainInformation:
            case PolicyPdAccountInformation:
            case PolicyAccountDomainInformation:
            case PolicyLsaServerRoleInformation:
            case PolicyReplicaSourceInformation:
            case PolicyDefaultQuotaInformation:
            case PolicyModificationInformation:
            case PolicyAuditFullSetInformation:
            case PolicyAuditFullQueryInformation:
            default:
                KCCSimException (
                    KCCSIM_ETYPE_INTERNAL,
                    KCCSIM_ERROR_UNSUPPORTED_POLICY_INFORMATION_CLASS
                    );
                break;

        }

        KCCSimFree (PolicyInformation);

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\simdsapi.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simdsapi.c

ABSTRACT:

    Simulates the Ds* APIs.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <drs.h>
#include <ntdskcc.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "state.h"

BOOL fNullUuid (const GUID *);

DWORD
WINAPI
SimDsReplicaGetInfoW (
    IN  HANDLE                      hDs,
    IN  DS_REPL_INFO_TYPE           InfoType,
    IN  LPCWSTR                     pszObject,
    IN  UUID *                      puuidForSourceDsaObjGuid,
    OUT VOID **                     ppInfo
    )
/*++

Routine Description:

    Simulates the DsReplicaGetInfoW API.

Arguments:

    hDs                 - A "handle" returned by SimDsBindW (which is
                          really just a PDSNAME).
    InfoType            - The information type to return.
    pszObject           - Currently unused.
    puuidForSourceDsaObjGuid - Currently unused.
    ppInfo              - Pointer to the result.

Return Value:

    None.

--*/
{
    DWORD                           status = NO_ERROR;

    *ppInfo = NULL;

    if (NULL == hDs ||
        NULL == ppInfo ||
        (((ULONG) InfoType >= DS_REPL_INFO_TYPE_MAX) &&
         ((ULONG) InfoType <= DS_REPL_INFO_TYPEP_MIN))) {
        return ERROR_INVALID_PARAMETER;
    }

    switch (InfoType) {

        case DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES:
        case DS_REPL_INFO_KCC_DSA_LINK_FAILURES:
            *ppInfo = KCCSimGetDsaFailures ((PDSNAME) hDs);
            if (NULL == *ppInfo) {
                Assert(!"KCCSimGetDsaFailures failed?");
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_DS_REPL_INFO_TYPE
                );
            break;

    }

    return status;
}

VOID
WINAPI
SimDsReplicaFreeInfo (
    IN  DS_REPL_INFO_TYPE           InfoType,
    IN  VOID *                      pInfo
    )
/*++

Routine Description:

    Simulates the DsReplicaFreeInfo API.

Arguments:

    InfoType            - The information type of pInfo.
    pInfo               - A buffer returned by SimDsReplicaGetInfoW.

Return Value:

    None.

--*/
{
    DS_REPL_KCC_DSA_FAILURESW *     pFailures;
    ULONG                           ul;

    switch (InfoType) {

        case DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES:
        case DS_REPL_INFO_KCC_DSA_LINK_FAILURES:
            // We only need to free pInfo
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_DS_REPL_INFO_TYPE
                );
            break;

    }

    KCCSimFree (pInfo);
    return;
}

DWORD
WINAPI
SimDsBindW (
    IN  LPCWSTR                     DomainControllerName,
    IN  LPCWSTR                     DnsDomainName,
    IO  HANDLE *                    phDS
    )
/*++

Routine Description:

    Simulates the DsBindW API.

Arguments:

    DomainControllerName - Guid-based dns name of the DC to which to bind.
    DnsDomainName       - Currently unused.
    phDS                - Pointer to a "handle" that will store the DSNAME
                          of the server we bind to.

Return Value:

    Win32 error code.

--*/
{
    PDSNAME                         pdnServer = NULL;
    LPWSTR                          pwsz = NULL;
    DWORD                           dwErr;

    Assert (DnsDomainName == NULL);         // Not supported

    // Create a blank PDSNAME to hold the GUID of this server.
    pdnServer = KCCSimAllocDsname (NULL);
    // Create the string-based UUID to pass to UuidFromStringW.
    pwsz = KCCSIM_WCSDUP (DomainControllerName);
    Assert (wcslen (pwsz) >= 36);
    pwsz[36] = L'\0';
    // Fill in the GUID structure in pdnServer.
    KCCSIM_CHKERR (UuidFromStringW (pwsz, &pdnServer->Guid));
    KCCSimFree (pwsz);
    // Check to see if we're simulating a bind error on this server.
    dwErr = KCCSimGetBindError (pdnServer);
    if (dwErr == NO_ERROR) {
        // Success; the handle points to the server's DSNAME.
        *phDS = (HANDLE) pdnServer;
    } else {
        *phDS = NULL;
        KCCSimFree (pdnServer);
    }

    return dwErr;
}

DWORD
WINAPI
SimDsUnBindW (
    IO  HANDLE *                    phDS
    )
/*++

Routine Description:

    Simulates the DsUnBindW API.

Arguments:

    phDS                - Pointer to a handle returned by SimDsBindW.

Return Value:

    Win32 error code.

--*/
{
    if (*phDS != NULL) {
        KCCSimFree (*phDS);
        *phDS = NULL;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\simmdnam.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simmdnam.c

ABSTRACT:

    Helper functions to do name resolution for the
    SimDir* APIs.  Also contains simulators for some
    of the name-processing APIs from ntdsa.dll.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <direrr.h>
#include <debug.h>
#include <winldap.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "simmd.h"

LPWSTR
SimGuidBasedDNSNameFromDSName (
    IN  PDSNAME                     pdnServer
    )
/*++

Routine Description:

    Simulates the GuidBasedDNSNameFromDSName API.

Arguments:

    pdnServer           - The DSName to convert.

Return Value:

    An allocated GUID-based DNS name.

--*/
{
    return KCCSimAllocGuidBasedDNSNameFromDSName (pdnServer);
}

PSIM_ENTRY
KCCSimResolveName (
    IN  PDSNAME                     pObject,
    IO  COMMRES *                   pCommRes
    )
/*++

Routine Description:

    Resolves a given DSNAME into a simulated directory entry.

Arguments:

    pObject             - The DN to resolve.
    pCommRes            - A COMMRES structure where any errors that occur
                          are to be recorded.

Return Value:

    The corresponding simulated directory entry, or NULL if none
    could be found.

--*/
{
    PSIM_ENTRY                      pEntry;

    pEntry = KCCSimDsnameToEntry (pObject, KCCSIM_NO_OPTIONS);
    if (pEntry == NULL) {                   // Entry doesn't exist
        KCCSimSetNamError (
            pCommRes,
            NA_PROBLEM_NO_OBJECT,
            NULL,
            DIRERR_OBJ_NOT_FOUND
            );
    }

    return pEntry;
}

PDSNAME
SimDsGetDefaultObjCategory (
    IN  ATTRTYP                     objClass
    )
/*++

Routine Description:

    Simulates the DsGetDefaultObjCategory API.

Arguments:

    objClass            - The object class.

Return Value:

    The corresponding default object category.

--*/
{
    return KCCSimAlwaysGetObjCategory (objClass);
}

NTSTATUS
SimGetConfigurationName (
    IN  DWORD                       which,
    IO  DWORD *                     pcbName,
    IO  DSNAME *                    pName
    )
/*++

Routine Description:

    Simulates the GetConfigurationName API.

Arguments:

    which               - A DSCONFIGNAME_* constant that specifies the
                          DN to retrieve.
    pcbName             - On input, contains the size of the pName buffer
                          in bytes.  If STATUS_BUFFER_TOO_SMALL is returned,
                          then on output, contains the required buffer size.
    pName               - A preallocated buffer that will hold the returned
                          configuration name.

Return Value:

    STATUS_*.

--*/
{
    const DSNAME *                  pdn;

    if (pcbName == NULL) {
        return (STATUS_INVALID_PARAMETER);
    }

    RtlZeroMemory (pName, *pcbName);

    switch (which) {
        case DSCONFIGNAME_DMD:
            pdn = KCCSimAnchorDn (KCCSIM_ANCHOR_DMD_DN);
            break;
        case DSCONFIGNAME_DSA:
            pdn = KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN);
            break;
        case DSCONFIGNAME_DOMAIN:
            pdn = KCCSimAnchorDn (KCCSIM_ANCHOR_DOMAIN_DN);
            break;
        case DSCONFIGNAME_CONFIGURATION:
            pdn = KCCSimAnchorDn (KCCSIM_ANCHOR_CONFIG_DN);
            break;
        case DSCONFIGNAME_ROOT_DOMAIN:
            pdn = KCCSimAnchorDn (KCCSIM_ANCHOR_ROOT_DOMAIN_DN);
            break;
        case DSCONFIGNAME_LDAP_DMD:
            pdn = KCCSimAnchorDn (KCCSIM_ANCHOR_LDAP_DMD_DN);
            break;
        case DSCONFIGNAME_PARTITIONS:
            pdn = KCCSimAnchorDn (KCCSIM_ANCHOR_PARTITIONS_DN);
            break;
        case DSCONFIGNAME_DS_SVC_CONFIG:
            pdn = KCCSimAnchorDn (KCCSIM_ANCHOR_DS_SVC_CONFIG_DN);
            break;
        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_CONFIG_NAME
                );
            pdn = NULL;
            break;
    }

    // Check if pName is large enough
    if (*pcbName < pdn->structLen) {
        *pcbName = pdn->structLen;
        return (STATUS_BUFFER_TOO_SMALL);
    }

    if (pName == NULL) {
        return (STATUS_INVALID_PARAMETER);
    }

    memcpy (pName, pdn, pdn->structLen);

    return (STATUS_SUCCESS);

}


LPSTR
SimDSNAMEToMappedStrExternal(
    IN DSNAME *pName,
    IN OPTIONAL BOOLEAN fUseNormalAllocator
    )

/*++

Routine Description:

    Return a ASCII string key that can be used for sorting dsnames

    We need to simulate this function instead of calling the corresponding
    function in ntdsa because that function allocates its own memory.

    The memory returned by this function must be off of the thread heap
    so that the caller can free it himself.

Arguments:

    pDn - 

Return Value:

    LPSTR - 

--*/

{
    LPWSTR *ppwzRDNs = NULL, *ppwzLoopRDNs, pwzRDN;
    LPSTR pszKey = NULL;
    LPWSTR pwzParts = NULL;
    ULONG mappedLen, inLen;

    Assert( pName );

    // Break up name into RDNs without types
    // This may not handle quoting quite as well as UnQuoteRDN, but it will
    // be close enough for the simulator's purposes
    ppwzRDNs = ldap_explode_dnW( pName->StringName, 1 );
    if (!ppwzRDNs) {
        return NULL;
    }

    // Space for concatenated name
    pwzParts = KCCSimAlloc( pName->NameLen * sizeof(WCHAR) );

    // Concatenate the RDNs to form a temporary name

    ppwzLoopRDNs = ppwzRDNs;
    for( pwzRDN = *ppwzLoopRDNs++; pwzRDN; pwzRDN = *ppwzLoopRDNs++ ) {
        wcscat( pwzParts, pwzRDN );
    }

    // Calculate length of mapped string
    inLen = wcslen( pwzParts );
    mappedLen = LCMapStringW(DS_DEFAULT_LOCALE,
                             (DS_DEFAULT_LOCALE_COMPARE_FLAGS | LCMAP_SORTKEY),
                             pwzParts,
                             inLen,
                             NULL,
                             0);
    if (mappedLen) {
        // Caller owned memory returned on thread heap!
        if( fUseNormalAllocator ) {
            pszKey = KCCSimAlloc( mappedLen );
        } else {
            pszKey = KCCSimThreadAlloc( mappedLen );
        }

        if (!LCMapStringW(DS_DEFAULT_LOCALE,
                         (DS_DEFAULT_LOCALE_COMPARE_FLAGS | LCMAP_SORTKEY),
                          pwzParts,
                          inLen,
                          (WCHAR *)pszKey,
                          mappedLen)) {

            DPRINT1 (0, "LCMapString failed with %x\n", GetLastError());
            KCCSimFree( pszKey );
            pszKey = NULL;
        }

    }
    else {
        DPRINT1 (0, "LCMapString failed with %x\n", GetLastError());
        Assert( FALSE );
    }

//cleanup:

    if (ppwzRDNs) {
        ldap_value_freeW( ppwzRDNs );
    }

    if (pwzParts) {
        KCCSimFree( pwzParts );
    }

    return pszKey;

} /* SimDSNAMEToMappedStrExternal */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\simtime.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simtime.c

ABSTRACT:

    Routines that govern the simulated time.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <debug.h>
#include "simtime.h"

struct _KCCSIM_TIME {
    DSTIME                          timeSim;
    BOOL                            bIsTicking;
    DSTIME                          timeStartedTicking;
};

struct _KCCSIM_TIME                 gSimTime;

VOID
KCCSimInitializeTime (
    VOID
    )
/*++

Routine Description:

    Initializes the simulated time to the real time.

Arguments:

    None.

Return Values:

    None.

--*/
{
    gSimTime.timeSim = KCCSimGetRealTime ();
    gSimTime.bIsTicking = FALSE;
    gSimTime.timeStartedTicking = 0;
}

VOID
KCCSimStartTicking (
    VOID
    )
/*++

Routine Description:

    Starts the simulated time.

Arguments:

    None.

Return Values:

    None.

--*/
{
    Assert (!gSimTime.bIsTicking);
    gSimTime.bIsTicking = TRUE;
    gSimTime.timeStartedTicking = KCCSimGetRealTime ();
}

VOID
KCCSimStopTicking (
    VOID
    )
/*++

Routine Description:

    Pauses the simulated time.

Arguments:

    None.

Return Values:

    None.

--*/
{
    Assert (gSimTime.bIsTicking);
    gSimTime.timeSim +=
      (KCCSimGetRealTime () - gSimTime.timeStartedTicking);
    gSimTime.bIsTicking = FALSE;
    gSimTime.timeStartedTicking = 0;
}

DSTIME
SimGetSecondsSince1601 (
    VOID
    )
/*++

Routine Description:

    Simulates GetSecondsSince1601 () by returning the simulated time.

Arguments:

    None.

Return Values:

    The simulated time.

--*/
{
    if (gSimTime.bIsTicking) {
        return (gSimTime.timeSim +
                KCCSimGetRealTime () - gSimTime.timeStartedTicking);
    } else {
        return gSimTime.timeSim;
    }
}

VOID
KCCSimAddSeconds (
    ULONG                           ulSeconds
    )
/*++

Routine Description:

    Increments the simulated time.

Arguments:

    ulSeconds           - Number of seconds to add.

Return Values:

    None.

--*/
{
    gSimTime.timeSim += ulSeconds;
}

/***

    KCCSimGetRealTime MUST be placed at the end of this file!  In order to
    get the real time, we call the real GetSecondsSince1601 (), so we must
    #undef the fake one.  This will affect (perhaps adversely) any functions
    that appear below KCCSimGetRealTime.

***/

// Prototype for the real GetSecondsSince1601, since it isn't exposed.
DSTIME GetSecondsSince1601 (
    VOID
    );

DSTIME
KCCSimGetRealTime (
    VOID
    )
/*++

Routine Description:

    Returns the real time.

Arguments:

    None.

Return Values:

    The real time.

--*/
{
#ifdef GetSecondsSince1601
#undef GetSecondsSince1601
#endif
    return GetSecondsSince1601 ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\simtime.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simtime.h

ABSTRACT:

    Header file for simtime.c.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

VOID
KCCSimInitializeTime (
    VOID
    );

VOID
KCCSimStartTicking (
    VOID
    );

VOID
KCCSimStopTicking (
    VOID
    );

VOID
KCCSimAddSeconds (
    ULONG                           ulSeconds
    );

DSTIME
KCCSimGetRealTime (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\simmdwt.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simmdwt.c

ABSTRACT:

    Simulates the write functions from the mdlayer
    (DirAddEntry, DirRemoveEntry, DirModifyEntry.)

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <direrr.h>
#include <attids.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "simmd.h"
#include "ldif.h"

VOID
KCCSimAddValBlockToAtt (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ATTRVALBLOCK *              pValsInf
    )
/*++

Routine Description:

    Adds an attribute value block to a simulated directory attribute.
    
    Note that this does not do any constraint checking, e.g. if you try
    to add several values to a single-valued attribute, it won't complain.

Arguments:

    pAttRef             - A reference to the desired attribute in the
                          simulated directory.
    pValsInf            - The values to add to the given attribute.

Return Value:

    None.

--*/
{
    ULONG                           ulValAt;
    PBYTE                           pValCopy;

    for (ulValAt = 0; ulValAt < pValsInf->valCount; ulValAt++) {

        pValCopy = KCCSimAlloc (pValsInf->pAVal[ulValAt].valLen);
        memcpy (
            pValCopy,
            pValsInf->pAVal[ulValAt].pVal,
            pValsInf->pAVal[ulValAt].valLen
            );

        KCCSimAddValueToAttribute (
            pAttRef,
            pValsInf->pAVal[ulValAt].valLen,
            pValCopy
            );

    }
}

ULONG
SimDirAddEntry (
    IN  ADDARG *                    pAddArg,
    OUT ADDRES **                   ppAddRes
    )
/*++

Routine Description:

    Simulates the DirAddEntry API.

Arguments:

    pAddArg             - Standard add arguments.
    ppAddRes            - Standard add results.

Return Value:

    DIRERR_*.

--*/
{
    PSIM_ENTRY                      pEntry;
    SIM_ATTREF                      attRef;
    ADDRES *                        pAddRes;
    ULONG                           ulAttrAt;

    Assert (pAddArg->pMetaDataVecRemote == NULL);

    g_Statistics.DirAddOps++;
    *ppAddRes = pAddRes = KCCSIM_NEW (ADDRES);
    pAddRes->CommRes.errCode = 0;

    // Check to see if this dsname already exists
    pEntry = KCCSimDsnameToEntry (pAddArg->pObject, KCCSIM_STRING_NAME_ONLY);

    if (pEntry == NULL) {       // It doesn't exist; we're clear to add
        
        pEntry = KCCSimDsnameToEntry (pAddArg->pObject, KCCSIM_WRITE);
        Assert (pEntry != NULL);

        for (ulAttrAt = 0; ulAttrAt < pAddArg->AttrBlock.attrCount; ulAttrAt++) {

            KCCSimNewAttribute (
                pEntry,
                pAddArg->AttrBlock.pAttr[ulAttrAt].attrTyp,
                &attRef
                );

            KCCSimAddValBlockToAtt (
                &attRef,
                &(pAddArg->AttrBlock.pAttr[ulAttrAt].AttrVal)
                );

        }

        // Add any missing vital attributes (such as GUID)
        KCCSimAddMissingAttributes (pEntry);

        // Fill the incoming DN with the GUID
        memcpy (&pAddArg->pObject->Guid, &pEntry->pdn->Guid, sizeof (GUID));

        // Log this change.
        KCCSimLogDirectoryAdd (
            pAddArg->pObject,
            &pAddArg->AttrBlock
            );

    } else {                    // The entry already exists!
        KCCSimSetUpdError (
            &pAddRes->CommRes,
            UP_PROBLEM_ENTRY_EXISTS,
            DIRERR_OBJ_STRING_NAME_EXISTS
            );
    }

    return pAddRes->CommRes.errCode;
}

ULONG
SimDirRemoveEntry (
    IN  REMOVEARG *                 pRemoveArg,
    OUT REMOVERES **                ppRemoveRes
    )
/*++

Routine Description:

    Simulates the DirRemoveEntry API.

Arguments:

    pRemoveArg          - Standard remove arguments.
    ppRemoveRes         - Standard remove results.

Return Value:

    DIRERR_*.

--*/
{
    PSIM_ENTRY                      pEntry;
    REMOVERES *                     pRemoveRes;

    Assert (pRemoveArg->pMetaDataVecRemote == NULL);

    g_Statistics.DirRemoveOps++;
    *ppRemoveRes = pRemoveRes = KCCSIM_NEW (REMOVERES);
    pRemoveRes->CommRes.errCode = 0;

    pEntry = KCCSimResolveName (pRemoveArg->pObject, &pRemoveRes->CommRes);

    if (pEntry != NULL) {
        
        if (pRemoveArg->fTreeDelete) {
            pRemoveArg->fTreeDelete = FALSE;    // This is what the real API does
            // We need to log this removal before we free the entry!
            KCCSimLogDirectoryRemove (pRemoveArg->pObject);
            KCCSimRemoveEntry (&pEntry);    // poof
        } else {

            // fTreeDelete not specified, so we must be careful
            if (pEntry->children != NULL) {     // Children exist
                KCCSimSetUpdError (
                    &pRemoveRes->CommRes,
                    UP_PROBLEM_CANT_ON_NON_LEAF,
                    DIRERR_CHILDREN_EXIST
                    );
            } else {                            // No children exist
                // We need to log this removal before we free the entry!
                KCCSimLogDirectoryRemove (pRemoveArg->pObject);
                KCCSimRemoveEntry (&pEntry);
            }

        }

    }

    return pRemoveRes->CommRes.errCode;
}

VOID
KCCSimModifyAtt (
    IN  PSIM_ENTRY                  pEntry,
    IN  USHORT                      usChoice,
    IN  ATTR *                      pAttrInf,
    IN  COMMARG *                   pCommArg,
    IN  COMMRES *                   pCommRes
    )
/*++

Routine Description:

    Helper function for SimDirModifyEntry.  Processes a single attribute.

Arguments:

    pEntry              - The entry whose attribute is being modified
    usChoice            - The type of modification being performed.
    pAttrInf            - Attribute info structure.
    pCommArg            - Standard common arguments.
    pCommRes            - Standard common results.

Return Value:

    None.

--*/
{
    SIM_ATTREF                      attRef;
    ULONG                           ulValAt;

    switch (usChoice) {

        case AT_CHOICE_ADD_ATT:
            // Check if this attribute exists.
            if (KCCSimGetAttribute (pEntry, pAttrInf->attrTyp, NULL)) {
                KCCSimSetAttError (
                    pCommRes,
                    pEntry->pdn,
                    pAttrInf->attrTyp,
                    PR_PROBLEM_ATT_OR_VALUE_EXISTS,
                    NULL,
                    DIRERR_ATT_ALREADY_EXISTS
                    );
            } else {
                KCCSimNewAttribute (pEntry, pAttrInf->attrTyp, &attRef);
                KCCSimAddValBlockToAtt (&attRef, &pAttrInf->AttrVal);
                KCCSimUpdatePropertyMetaData (
                    &attRef,
                    &(KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN))->Guid
                    );
            }
            break;
        
        case AT_CHOICE_REMOVE_ATT:
            // Get this attribute
            if (KCCSimGetAttribute (pEntry, pAttrInf->attrTyp, &attRef)) {
                KCCSimRemoveAttribute (&attRef);
            } else {                        // The attribute doesn't exist.
                // Does the caller even care?
                if (!pCommArg->Svccntl.fPermissiveModify) {
                    KCCSimSetAttError (
                        pCommRes,
                        pEntry->pdn,
                        pAttrInf->attrTyp,
                        PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                        NULL,
                        DIRERR_ATT_IS_NOT_ON_OBJ
                        );
                }
            }
            break;

        case AT_CHOICE_ADD_VALUES:
            if (KCCSimGetAttribute (pEntry, pAttrInf->attrTyp, &attRef)) {
                KCCSimAddValBlockToAtt (&attRef, &pAttrInf->AttrVal);
                KCCSimUpdatePropertyMetaData (
                    &attRef,
                    &(KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN))->Guid
                    );
            } else {
                KCCSimSetAttError (
                    pCommRes,
                    pEntry->pdn,
                    pAttrInf->attrTyp,
                    PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                    NULL,
                    DIRERR_ATT_IS_NOT_ON_OBJ
                    );
            }
            break;

        case AT_CHOICE_REMOVE_VALUES:
            if (KCCSimGetAttribute (pEntry, pAttrInf->attrTyp, &attRef)) {
                for (ulValAt = 0; ulValAt < pAttrInf->AttrVal.valCount; ulValAt++) {
                    if (KCCSimRemoveValueFromAttribute (
                            &attRef,
                            pAttrInf->AttrVal.pAVal[ulValAt].valLen,
                            pAttrInf->AttrVal.pAVal[ulValAt].pVal
                            )) {
                        KCCSimUpdatePropertyMetaData (
                            &attRef,
                            &(KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN))->Guid
                            );
                    } else if (!pCommArg->Svccntl.fPermissiveModify) {
                        // We failed to remove the value 'cause it wasn't there,
                        // and we're doing a non-permissive modify, so generate
                        // an error.
                        KCCSimSetAttError (
                            pCommRes,
                            pEntry->pdn,
                            pAttrInf->attrTyp,
                            PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                            &(pAttrInf->AttrVal.pAVal[ulValAt]),
                            DIRERR_CANT_REM_MISSING_ATT_VAL
                            );
                        break;
                    }
                }
            } else {                    // Attribute doesn't exist
                KCCSimSetAttError (
                    pCommRes,
                    pEntry->pdn,
                    pAttrInf->attrTyp,
                    PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                    NULL,
                    DIRERR_ATT_IS_NOT_ON_OBJ
                    );
            }
            break;

        case AT_CHOICE_REPLACE_ATT:
            // Remove the attribute if it exists.
            if (KCCSimGetAttribute (pEntry, pAttrInf->attrTyp, &attRef)) {
                KCCSimRemoveAttribute (&attRef);
            }
            KCCSimNewAttribute (pEntry, pAttrInf->attrTyp, &attRef);
            KCCSimAddValBlockToAtt (&attRef, &pAttrInf->AttrVal);
            KCCSimUpdatePropertyMetaData (
                &attRef,
                &(KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN))->Guid
                );
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_MODIFY_CHOICE
                );
            break;

    }

}

ULONG
SimDirModifyEntry (
    IN  MODIFYARG *                 pModifyArg,
    OUT MODIFYRES **                ppModifyRes
    )
/*++

Routine Description:

    Simulates the DirModifyEntry API.

Arguments:

    pModifyArg          - Standard modify arguments.
    ppModifyRes         - Standard modify results.

Return Value:

    DIRERR_*.

--*/
{
    MODIFYRES *                     pModifyRes;
    ATTRMODLIST *                   pModAt;
    PSIM_ENTRY                      pEntry;

    Assert (pModifyArg->pMetaDataVecRemote == NULL);

    g_Statistics.DirModifyOps++;
    *ppModifyRes = pModifyRes = KCCSIM_NEW (MODIFYRES);
    pModifyRes->CommRes.errCode = 0;

    pEntry = KCCSimResolveName (pModifyArg->pObject, &pModifyRes->CommRes);

    if (pEntry != NULL) {

        pModAt = &pModifyArg->FirstMod;
        while (pModAt != NULL) {

            KCCSimModifyAtt (
                pEntry,
                pModAt->choice,
                &pModAt->AttrInf,
                &pModifyArg->CommArg,
                &pModifyRes->CommRes
                );
            pModAt = pModAt->pNextMod;

        }

        KCCSimLogDirectoryModify (
            pModifyArg->pObject,
            pModifyArg->count,
            &pModifyArg->FirstMod
            );

    }
    
    return pModifyRes->CommRes.errCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\simmdrep.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simmdrep.c

ABSTRACT:

    Simulates the Replica functions from the mdlayer
    (DirReplica*).

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <attids.h>
#include <mdglobal.h>
#include <drserr.h>
#include <dsaapi.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "state.h"

BOOL MtxSame (UNALIGNED MTX_ADDR *pmtx1, UNALIGNED MTX_ADDR *pmtx2);

MTX_ADDR *
SimMtxAddrFromTransportAddr (
    IN  LPWSTR                      psz
    )
/*++

Routine Description:

    Simulates the MtxAddrFromTransportAddr API.
    
    Note that this is essentially identical to the corresponding function in
    drautil.c.

Arguments:

    psz                 - The string to convert.

Return Values:

    A pointer to the equivalent MTX_ADDR.

--*/
{
    DWORD       cch;
    MTX_ADDR *  pmtx;
    
    Assert(NULL != psz);
    
    cch = WideCharToMultiByte(CP_UTF8, 0L, psz, -1, NULL, 0, NULL, NULL);
    if (0 == cch) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            GetLastError()
            );
    }

    // Note that cch includes the null terminator, whereas MTX_TSIZE_FROM_LEN
    // expects a count that does *not* include the null terminator.
    
    pmtx = (MTX_ADDR *) KCCSimAlloc (MTX_TSIZE_FROM_LEN (cch-1));
    pmtx->mtx_namelen = cch;
    
    cch = WideCharToMultiByte(CP_UTF8, 0L, psz, -1, pmtx->mtx_name, cch, NULL,
                              NULL);
    if (0 == cch) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            GetLastError()
            );
    }
    
    Assert(cch == pmtx->mtx_namelen);
    Assert(L'\0' == pmtx->mtx_name[cch - 1]);
    
    return pmtx;
}

LPWSTR
SimTransportAddrFromMtxAddr (
    IN  MTX_ADDR *                  pMtxAddr
    )
/*++

Routine Description:

    Simulates the TransportAddrFromMtxAddr API.

Arguments:

    pMtxAddr            - The MTX_ADDR to convert.

Return Value:

    The equivalent transport address.

--*/
{
    return KCCSimAllocWideStr (CP_UTF8, pMtxAddr->mtx_name);
}

ULONG
SimDirReplicaAdd (
    IN  PDSNAME                     pdnNC,
    IN  PDSNAME                     pdnSourceDsa,
    IN  PDSNAME                     pdnTransport,
    IN  LPWSTR                      pwszSourceDsaAddress,
    IN  LPWSTR                      pwszSourceDsaDnsDomainName,
    IN  REPLTIMES *                 preptimesSync,
    IN  ULONG                       ulOptions
    )
/*++

Routine Description:

    Simulates the DirReplicaAdd API.

Arguments:

    pdnNC               - The NC to which we are adding this repsfrom.
    pdnSourceDsa        - The DN of the source server's NTDS Settings object.
    pdnTransport        - The transport DN.
    pwszSourceDsaAddress- The source DSA address.
    pwszSourceDsaDnsDomainName
                        - The DNS Domain Name of the source DSA.
    preptimesSync       - The replication schedule.
    ulOptions           - Option flags.

Return Value:

    DRAERR_*.

--*/
{
    REPLICA_LINK *                  pReplicaLinkOld = NULL;
    REPLICA_LINK *                  pReplicaLinkNew = NULL;
    ULONG                           cbReplicaLinkNew;

    USHORT                          usChangeType;
    MTX_ADDR *                      pMtxAddr = NULL;
    DSTIME                          timeNow;

    __try {

        if (NULL == pdnNC ||
            NULL == pwszSourceDsaAddress) {
            return DRAERR_InvalidParameter;
        }
        Assert (pdnSourceDsa != NULL);

        // Check that this NC exists.
        if (KCCSimDsnameToEntry (pdnNC, KCCSIM_NO_OPTIONS) == NULL) {
            return DRAERR_BadNC;
        }

        // If this replica link already exists, get rid of the old one.
        pReplicaLinkOld = KCCSimExtractReplicaLink (
            KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
            pdnNC,
            &pdnSourceDsa->Guid,
            NULL
            );

        timeNow = SimGetSecondsSince1601 ();
        pMtxAddr = SimMtxAddrFromTransportAddr (pwszSourceDsaAddress);

        // Allocate and set up a new replica link.
        cbReplicaLinkNew = sizeof (REPLICA_LINK) + MTX_TSIZE (pMtxAddr);
        pReplicaLinkNew = KCCSimAlloc (cbReplicaLinkNew);
        pReplicaLinkNew->dwVersion = VERSION_V1;
        pReplicaLinkNew->V1.cb = cbReplicaLinkNew;
        pReplicaLinkNew->V1.cConsecutiveFailures = 0;
        pReplicaLinkNew->V1.timeLastSuccess = timeNow;
        pReplicaLinkNew->V1.timeLastAttempt = timeNow;
        pReplicaLinkNew->V1.ulResultLastAttempt = ERROR_SUCCESS;
        pReplicaLinkNew->V1.cbOtherDraOffset =
          (DWORD) (pReplicaLinkNew->V1.rgb - (PBYTE) pReplicaLinkNew);
        pReplicaLinkNew->V1.cbOtherDra = MTX_TSIZE (pMtxAddr);
        pReplicaLinkNew->V1.ulReplicaFlags = ulOptions & RFR_FLAGS;
        if (preptimesSync == NULL) {
            RtlZeroMemory (&pReplicaLinkNew->V1.rtSchedule, sizeof (REPLTIMES));
        } else {
            memcpy (
                &pReplicaLinkNew->V1.rtSchedule,
                preptimesSync,
                sizeof (REPLTIMES)
                );
        }
        
        RtlZeroMemory (&pReplicaLinkNew->V1.usnvec, sizeof (USN_VECTOR));
        memcpy (
            &pReplicaLinkNew->V1.uuidDsaObj,
            &pdnSourceDsa->Guid,
            sizeof (UUID)
            );
        
        // Invocation ID is just the same as source DSA UUID.
        // We could get the real invocation ID of the server from the in-memory
        // directory, but this is not needed for the simulation.
        memcpy (
            &pReplicaLinkNew->V1.uuidInvocId,
            &pdnSourceDsa->Guid,
            sizeof (UUID)
            );
        if (pdnTransport == NULL) {
            RtlZeroMemory (&pReplicaLinkNew->V1.uuidTransportObj, sizeof (UUID));
        } else {
            memcpy (
                &pReplicaLinkNew->V1.uuidTransportObj,
                &pdnTransport->Guid,
                sizeof (UUID)
                );
        }
        memcpy (
            RL_POTHERDRA (pReplicaLinkNew),
            pMtxAddr,
            MTX_TSIZE (pMtxAddr)
            );

        // Insert the new replica link into the server state table.
        KCCSimInsertReplicaLink (
            KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
            pdnNC,
            pReplicaLinkNew
            );

    } __finally {

        KCCSimFree (pMtxAddr);
        KCCSimFree (pReplicaLinkOld);

    }

    return DRAERR_Success;
}

ULONG
SimDirReplicaDelete (
    IN  PDSNAME                     pdnNC,
    IN  LPWSTR                      pwszSourceDRA,
    IN  ULONG                       ulOptions
    )
/*++

Routine Description:

    Simulates the DirReplicaDelete API.
    
    Currently will not delete the entire NC tree if the last
    link for a partial replica is severed.  This is not needed for purposes
    of the simulation.

Arguments:

    pdnNC               - The NC from which we are deleting this repsfrom.
    pwszSourceDRA       - The source DRA whose repsfrom we want to delete.
    ulOptions           - Option flags.

Return Values:

    DRAERR_*.

--*/
{
    MTX_ADDR *                      pMtxAddr = NULL;
    REPLICA_LINK *                  pReplicaLink = NULL;

    __try {

        if (NULL == pdnNC) {
            return DRAERR_InvalidParameter;
        }

        // Check that this is a valid NC.
        if (KCCSimDsnameToEntry (pdnNC, KCCSIM_NO_OPTIONS) == NULL) {
            return DRAERR_BadNC;
        }

        pMtxAddr = SimMtxAddrFromTransportAddr (pwszSourceDRA);

        // Extract this repsfrom from the server state table.
        pReplicaLink = KCCSimExtractReplicaLink (
            KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
            pdnNC,
            NULL,
            pMtxAddr
            );

        if (pReplicaLink == NULL) {
            return DRAERR_NoReplica;
        }

        return DRAERR_Success;

    } __finally {

        KCCSimFree (pMtxAddr);
        KCCSimFree (pReplicaLink);

    }

    return DRAERR_Success;
}

ULONG
SimDirReplicaGetDemoteTarget(
    IN      DSNAME *                                pNC,
    IN OUT  struct _DRS_DEMOTE_TARGET_SEARCH_INFO * pDSTInfo,
    OUT     LPWSTR *                                ppszDemoteTargetDNSName,
    OUT     DSNAME **                               ppDemoteTargetDSADN
    )
/*++

Routine Description:

    Simulates the DirReplicaGetDemoteTarget API.

Arguments:

    As for DirReplicaGetDemoteTarget.

Return Values:

    0 on success, Win32 error on failure.
    
--*/
{
    return ERROR_NO_SUCH_DOMAIN;
}


ULONG
SimDirReplicaDemote(
    IN  DSNAME *    pNC,
    IN  LPWSTR      pszOtherDSADNSName,
    IN  DSNAME *    pOtherDSADN,
    IN  ULONG       ulOptions
    )
/*++

Routine Description:

    Simulates the DirReplicaDemote API.

Arguments:

    pNC (IN) - Name of the writeable NC to remove.

    pOtherDSADN (IN) - NTDS Settings (ntdsDsa) DN of the DSA to give FSMO
        roles/replicate to.

    ulOptions (IN) - Ignored - none yet defined.

Return Values:

    0 on success, Win32 error on failure.
    
--*/
{
    // Don't bother simulating FSMO role transfer -- just tear down the NC.
    return SimDirReplicaDelete(pNC,
                               NULL,
                               DRS_REF_OK | DRS_NO_SOURCE | DRS_ASYNC_REP);
}

ULONG
SimDirReplicaModify (
    IN  PDSNAME                     pNC,
    IN  UUID *                      puuidSourceDRA,
    IN  UUID *                      puuidTransportObj,
    IN  LPWSTR                      pszSourceDRA,
    IN  REPLTIMES *                 prtSchedule,
    IN  ULONG                       ulReplicaFlags,
    IN  ULONG                       ulModifyFields,
    IN  ULONG                       ulOptions
    )
/*++

Routine Description:

    Simulates the DirReplicaModify API.

Arguments:

    pNC                 - The NC whose repsfrom we are modifying.
    puuidSourceDRA      - The UUID of the source DRA.
    puuidTransportObj   - The UUID of the transport object.
    pszSourceDRA        - The string name of the source DRA DN.
    prtSchedule         - The replication schedule.
    ulReplicaFlags      - Replication flags.
    ulModifyFields      - The fields that we wish to modify.
    ulOptions           - Option flags.

Return Values:

    DRAERR_*.

--*/
{
    MTX_ADDR *                      pMtxAddr = NULL;
    REPLICA_LINK *                  pReplicaLinkOld = NULL;
    REPLICA_LINK *                  pReplicaLinkNew = NULL;
    ULONG                           cbReplicaLinkNew;

    __try {

        // This blob is lifted out of the real DirReplicaModify.
        if (    ( NULL == pNC )
             || ( ( NULL == puuidSourceDRA ) && ( NULL == pszSourceDRA ) )
             || ( ( NULL == pszSourceDRA   ) && ( DRS_UPDATE_ADDRESS  & ulModifyFields ) )
             || ( ( NULL == prtSchedule    ) && ( DRS_UPDATE_SCHEDULE & ulModifyFields ) )
             || ( 0 == ulModifyFields )
             || (    ulModifyFields
                  != (   ulModifyFields
                       & ( DRS_UPDATE_ADDRESS | DRS_UPDATE_SCHEDULE | DRS_UPDATE_FLAGS
                           | DRS_UPDATE_TRANSPORT
                         )
                     )
                )
           )
        {
            return DRAERR_InvalidParameter;
        }

        // Check that this is a valid NC.
        if (KCCSimDsnameToEntry (pNC, KCCSIM_NO_OPTIONS) == NULL) {
            return DRAERR_BadNC;
        }

        if (pszSourceDRA != NULL) {
            pMtxAddr = SimMtxAddrFromTransportAddr (pszSourceDRA);
        }

        // Extract the replica link from the server state table.  We'll
        // re-insert it after the modifications are done.
        pReplicaLinkOld = KCCSimExtractReplicaLink (
            KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
            pNC,
            puuidSourceDRA,
            pMtxAddr
            );

        if (pReplicaLinkOld == NULL) {
            return DRAERR_NoReplica;
        }
        
        // Set up the new replica link.  How we do this depends on
        // whether or not we are updating the address.

        if (ulModifyFields & DRS_UPDATE_ADDRESS) {

            // Updating the address, so we reallocate.
            cbReplicaLinkNew = sizeof (REPLICA_LINK) + MTX_TSIZE (pMtxAddr);
            pReplicaLinkNew = (REPLICA_LINK *) KCCSimAlloc (cbReplicaLinkNew);
            memcpy (
                pReplicaLinkNew,
                pReplicaLinkOld,
                min (cbReplicaLinkNew, pReplicaLinkOld->V1.cb)
                );
            pReplicaLinkNew->V1.cb = cbReplicaLinkNew;
            pReplicaLinkNew->V1.cbOtherDra = MTX_TSIZE (pMtxAddr);
            memcpy (RL_POTHERDRA (pReplicaLinkNew), pMtxAddr, MTX_TSIZE (pMtxAddr));
            // We leave pReplicaLinkOld non-NULL, so it will be freed in the
            // __finally block.

        } else {
            // No need to reallocate.
            pReplicaLinkNew = pReplicaLinkOld;
            pReplicaLinkOld = NULL;     // Make sure we don't free this later
        }

        // By now, the new replica link should be set up.
        Assert (pReplicaLinkNew != NULL);

        if (ulModifyFields & DRS_UPDATE_FLAGS) {
            pReplicaLinkNew->V1.ulReplicaFlags = ulReplicaFlags;
        }

        if (ulModifyFields & DRS_UPDATE_SCHEDULE) {
            memcpy (&pReplicaLinkNew->V1.rtSchedule, prtSchedule, sizeof (REPLTIMES));
        }

        if (ulModifyFields & DRS_UPDATE_TRANSPORT) {
            Assert (puuidTransportObj != NULL);
            memcpy (&pReplicaLinkNew->V1.uuidTransportObj, puuidTransportObj, sizeof (UUID));
        }

        // Finally, re-insert the modified replica link into the state table.
        KCCSimInsertReplicaLink (
            KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
            pNC,
            pReplicaLinkNew
            );

    } __finally {

        KCCSimFree (pReplicaLinkOld);
        KCCSimFree (pMtxAddr);

    }

    return DRAERR_Success;
}


ULONG
SimDirReplicaReferenceUpdate(
    DSNAME *    pNC,
    LPWSTR      pszRepsToDRA,
    UUID *      puuidRepsToDRA,
    ULONG       ulOptions
    )
{
    // ISSUE-nickhar-09/25/2000: We should simulate this function properly.
    return DRAERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\state.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    state.h

ABSTRACT:

    Header file for state.c.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

VOID
KCCSimFreeStates (
    VOID
    );

ULONG
KCCSimGetBindError (
    IN  const DSNAME *              pdnServer
    );

BOOL
KCCSimSetBindError (
    IN  const DSNAME *              pdnServer,
    IN  ULONG                       ulBindError
    );

#ifdef _mdglobal_h_

REPLICA_LINK *
KCCSimExtractReplicaLink (
    IN  const DSNAME *              pdnServer,
    IN  const DSNAME *              pdnNC,
    IN  const UUID *                puuidDsaObj,
    IN  MTX_ADDR *                  pMtxAddr
    );

VOID
KCCSimInsertReplicaLink (
    IN  const DSNAME *              pdnServer,
    IN  const DSNAME *              pdnNC,
    IN  REPLICA_LINK *              pReplicaLink
    );

#endif

PSIM_VALUE
KCCSimGetRepsFroms (
    IN  const DSNAME *              pdnServer,
    IN  const DSNAME *              pdnNC
    );

BOOL
KCCSimReportSync (
    IN  const DSNAME *              pdnServerTo,
    IN  const DSNAME *              pdnNC,
    IN  const DSNAME *              pdnServerFrom,
    IN  ULONG                       ulSyncError,
    IN  ULONG                       ulNumAttempts
    );

DS_REPL_KCC_DSA_FAILURESW *
KCCSimGetDsaFailures (
    IN  const DSNAME *              pdnServer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\user.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    user.c

ABSTRACT:

    Contains user interface routines for KCCSim.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

    04/12/2000      Nicholas Harvey (nickhar)
        Added functions to examine the current intra-site topologies and
        display graph-theoretic information.

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <drs.h>
#include <dsutil.h>
#include <mdglobal.h>
#include <attids.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "state.h"
#include "user.h"

VOID
KCCSimDumpDirectoryRecurse (
    IN  PSIM_ENTRY                  pEntry,
    IN  ULONG                       ulDepth
    )
/*++

Routine Description:

    Recursively retty-prints the DN of every entry
    in a sub-tree of the directory.

Arguments:

    pEntry              - The entry to start from.
    ulDepth             - Present depth of the sub-tree.  Used to determine
                          how far over each DN should be tabbed.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntryChildAt;
    PSIM_ATTRIBUTE                  pAttrAt;
    ULONG                           ulCount, ulNumAttrs;

    pAttrAt = pEntry->pAttrFirst;
    ulNumAttrs = 0;
    while (pAttrAt != NULL) {
        ulNumAttrs++;
        pAttrAt = pAttrAt->next;
    }
    for (ulCount = 0; ulCount < ulDepth; ulCount++)
        printf ("  ");
    wprintf (
        L"%-*.*s%3.3s [%2d]\n",
        71 - (2 * ulDepth),
        71 - (2 * ulDepth),
        pEntry->pdn->StringName,
        wcslen (pEntry->pdn->StringName) > 71 - (2 * ulDepth) ?
            L"..." :
            L"   ",
        ulNumAttrs
        );

    for (pEntryChildAt = pEntry->children;
         pEntryChildAt != NULL;
         pEntryChildAt = pEntryChildAt->next) {
        KCCSimDumpDirectoryRecurse (pEntryChildAt, 1L + ulDepth);
    }
}

VOID
KCCSimDumpDirectory (
    IN  LPCWSTR                     pwszStartDn
    )
/*++

Routine Description:

    Pretty-prints the DN of every entry in a sub-tree of the directory.

Arguments:

    pwszStartDn         - The DN to use as the root.

Return Value:

    None.

--*/
{
    PDSNAME                         pdn;
    PSIM_ENTRY                      pEntryStart;

    if (pwszStartDn == NULL || pwszStartDn[0] == L'\0') {
        pEntryStart = KCCSimDsnameToEntry (NULL, KCCSIM_NO_OPTIONS);
    } else {
        pdn = KCCSimAllocDsname (pwszStartDn);
        pEntryStart = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
        KCCSimFree (pdn);
    }

    if (pEntryStart != NULL) {
        KCCSimDumpDirectoryRecurse (pEntryStart, 0);
    }
}

LPWSTR
KCCSimNtdsDsaGuidToServerName (
    IN  GUID *                      pGuid,
    IO  LPWSTR                      pwszBuf
    )
/*++

Routine Description:

    Helper function that returns a server's RDN given the
    GUID of its NTDS Settings object.

Arguments:

    pGuid               - Pointer to the GUID of an NTDS Settings object.
    pwszBuf             - Preallocated buffer to hold the server RDN.

Return Value:

    Always returns pwszBuf.

--*/
{
    PSIM_ENTRY                      pEntry;
    PDSNAME                         pdn;

    pdn = KCCSimAllocDsname (NULL);
    memcpy (&pdn->Guid, pGuid, sizeof (GUID));
    pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
    KCCSimFree (pdn);

    if (pEntry == NULL) {
        return NULL;
    }

    pdn = KCCSimAlloc (pEntry->pdn->structLen);
    TrimDSNameBy (pEntry->pdn, 1, pdn);
    KCCSimQuickRDNOf (pdn, pwszBuf);
    KCCSimFree (pdn);
    return pwszBuf;
}

VOID
KCCSimDisplayLinksForNC (
    const DSNAME *                  pdnServer,
    const DSNAME *                  pdnNC,
    BOOL                            bIsMasterNC
    )
{
    PSIM_VALUE                      pValAt;

    REPLICA_LINK *                  prl;
    CHAR                            szLastSuccess[1+SZDSTIME_LEN];
    CHAR                            szLastAttempt[1+SZDSTIME_LEN];
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];
    LPWSTR                          pwszOtherDsaGuidS,
                                    pwszInvocIdS,
                                    pwszTransportGuidS;

    wprintf (
        L"\nREPLICA_LINKs for %s NC\n%s\n",
        bIsMasterNC ? L"master" : L"partial replica",
        pdnNC->StringName
        );

    for (pValAt = KCCSimGetRepsFroms (pdnServer, pdnNC);
         pValAt != NULL;
         pValAt = pValAt->next) {

        prl = (REPLICA_LINK *) pValAt->pVal;
        VALIDATE_REPLICA_LINK_VERSION (prl);
        Assert (prl->V1.cbOtherDraOffset == offsetof (REPLICA_LINK, V1.rgb));

        KCCSIM_CHKERR (UuidToStringW (
            &prl->V1.uuidDsaObj,
            &pwszOtherDsaGuidS));
        KCCSIM_CHKERR (UuidToStringW (
            &prl->V1.uuidInvocId,
            &pwszInvocIdS));
        KCCSIM_CHKERR (UuidToStringW (
            &prl->V1.uuidTransportObj,
            &pwszTransportGuidS));

        wprintf (
            L"\n"
            L"Consecutive Failures: %d\n"
            L"Last Success        : %S\n"
            L"Last Attempt        : %S\n"
            L"Last Result         : %d\n"
            L"Replica Flags       : 0x%x\n"
            L"Other DSA GUID      : %s [%s]\n"
            L"Other DSA Invocation: %s\n"
            L"Transport GUID      : %s\n"
            L"Other DSA Matrix Adr: %S\n",
            prl->V1.cConsecutiveFailures,
            DSTimeToDisplayString (prl->V1.timeLastSuccess, szLastSuccess),
            DSTimeToDisplayString (prl->V1.timeLastAttempt, szLastAttempt),
            prl->V1.ulResultLastAttempt,
            prl->V1.ulReplicaFlags,
            pwszOtherDsaGuidS,
            KCCSimNtdsDsaGuidToServerName (&prl->V1.uuidDsaObj, wszRDN),
            pwszInvocIdS,
            pwszTransportGuidS,
            ((MTX_ADDR *) prl->V1.rgb)->mtx_name
            );

        RpcStringFreeW (&pwszOtherDsaGuidS);
        RpcStringFreeW (&pwszInvocIdS);
        RpcStringFreeW (&pwszTransportGuidS);

    }

}

VOID
KCCSimDisplayServer (
    VOID
    )
{
    PSIM_ENTRY                      pEntryDsa;
    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pValAt;
    PDSNAME                         pdn;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];

    pEntryDsa = KCCSimDsnameToEntry (
        KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
        KCCSIM_NO_OPTIONS
        );

    KCCSimQuickRDNBackOf (
        pEntryDsa->pdn,
        1,
        wszRDN
        );

    wprintf (L"Configuration for %s:\n\n", wszRDN);

    KCCSimPrintMessage (
        KCCSIM_MSG_DISPLAY_ANCHOR,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_DMD_DN))->StringName,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN))->StringName,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_DOMAIN_DN))->StringName,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_CONFIG_DN))->StringName,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_ROOT_DOMAIN_DN))->StringName,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_LDAP_DMD_DN))->StringName,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_PARTITIONS_DN))->StringName,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_DS_SVC_CONFIG_DN))->StringName,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_SITE_DN))->StringName,
        KCCSimAnchorString (KCCSIM_ANCHOR_DOMAIN_NAME),
        KCCSimAnchorString (KCCSIM_ANCHOR_DOMAIN_DNS_NAME),
        KCCSimAnchorString (KCCSIM_ANCHOR_ROOT_DOMAIN_DNS_NAME)
        );

    wprintf (
        L"\nThis server returns %d on bind attempts.\n",
        KCCSimGetBindError (pEntryDsa->pdn)
        );

    if (!KCCSimGetAttribute (pEntryDsa, ATT_HAS_MASTER_NCS, &attRef)) {
        wprintf (L"Could not locate Master NCs!\n");
        return;
    }

    for (pValAt = attRef.pAttr->pValFirst;
         pValAt != NULL;
         pValAt = pValAt->next) {

        KCCSimDisplayLinksForNC (pEntryDsa->pdn, (PDSNAME) pValAt->pVal, TRUE);

    }

    if (KCCSimGetAttribute (pEntryDsa, ATT_HAS_PARTIAL_REPLICA_NCS, &attRef)) {
        for (pValAt = attRef.pAttr->pValFirst;
             pValAt != NULL;
             pValAt = pValAt->next) {

            KCCSimDisplayLinksForNC (pEntryDsa->pdn, (PDSNAME) pValAt->pVal, FALSE);

        }
    }

}

VOID
KCCSimDisplayTopologyInfo (
    IN  PSIM_ENTRY                  pEntrySites,
    IN  BOOL                        bInterSite
    )
/*++

Routine Description:

    Displays information about the enterprise topology.

Arguments:

    pEntrySites         - The Sites container.
    bInterSite          - If TRUE, displays the inter-site topology.
                          If FALSE, displays the intra-site topology
                          for each site in the enterprise.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntrySiteAt, pEntrySiteSettings,
                                    pEntryServers, pEntryServerAt,
                                    pEntryNtdsDsa, pEntryConnectionAt;
    SIM_ATTREF                      attRef;
    LPWSTR                          pwszUuid;
    WCHAR                           wszRDNBuf1[1+MAX_RDN_SIZE],
                                    wszRDNBuf2[1+MAX_RDN_SIZE],
                                    wszRDNBuf3[1+MAX_RDN_SIZE];
    ULONG                           ulOptions;
    BOOL                            bIsEnabled, bPrint;
    PDSNAME                         pdnTransportType = NULL,
                                    pdnFromServer = NULL;
    RPC_STATUS                      rpcStatus;
    PSIM_VALUE                      pValAt;

    if (bInterSite) {
        wprintf (L"Intersite Topology:\n");
    } else {
        wprintf (L"Intrasite Topology:\n");
    }

    for (pEntrySiteAt = KCCSimFindFirstChild (
            pEntrySites, CLASS_SITE, NULL);
         pEntrySiteAt != NULL;
         pEntrySiteAt = KCCSimFindNextChild (
            pEntrySiteAt, CLASS_SITE, NULL)) {

        pEntrySiteSettings = KCCSimFindFirstChild (
            pEntrySiteAt,
            CLASS_NTDS_SITE_SETTINGS,
            NULL
            );
        if (pEntrySiteSettings == NULL) {
            wprintf (
                L"Site [%s]: Could not locate NTDS Site Settings!\n",
                KCCSimQuickRDNOf (pEntrySiteAt->pdn, wszRDNBuf1)
                );
            continue;
        }

        KCCSimGetAttribute (pEntrySiteSettings, ATT_OPTIONS, &attRef);
        if (attRef.pAttr == NULL ||
            attRef.pAttr->pValFirst == NULL) {
            ulOptions = 0;
        } else {
            ulOptions = *((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal);
        }

        rpcStatus = UuidToStringW (&pEntrySiteAt->pdn->Guid, &pwszUuid);
        if( rpcStatus != RPC_S_OK ) {
            wprintf ( L"Site [%s]: Failed to convert Guid to string!\n",
                KCCSimQuickRDNOf (pEntrySiteAt->pdn, wszRDNBuf1)
                );
            continue;
        }

        if (!bInterSite) {
            wprintf (
                L"Site [%c%c%c%c%c] %s [%s]:\n",
                (ulOptions & NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED)     ?
                  KCCSIM_CID_NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED      : L' ',
                (ulOptions & NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED)      ?
                  KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED       : L' ',
                (ulOptions & NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED)     ?
                  KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED      : L' ',
                (ulOptions & NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED) ?
                  KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED  : L' ',
                (ulOptions & NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED) ?
                  KCCSIM_CID_NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED
                                                                             : L' ',
                pwszUuid,
                KCCSimQuickRDNOf (pEntrySiteAt->pdn, wszRDNBuf1)
                );
        }
        RpcStringFreeW (&pwszUuid);

        pEntryServers = KCCSimFindFirstChild (
            pEntrySiteAt,
            CLASS_SERVERS_CONTAINER,
            NULL
            );

        if (pEntryServers == NULL) {
            wprintf (L"  Could not locate servers container!\n");
            continue;
        }

        for (pEntryServerAt = KCCSimFindFirstChild (
                pEntryServers, CLASS_SERVER, NULL);
             pEntryServerAt != NULL;
             pEntryServerAt = KCCSimFindNextChild (
                pEntryServerAt, CLASS_SERVER, NULL)) {

            pEntryNtdsDsa = KCCSimFindFirstChild (
                pEntryServerAt,
                CLASS_NTDS_DSA,
                NULL
                );
            if (pEntryNtdsDsa == NULL) {
                wprintf (
                    L"  Server [%s]: Could not locate NTDS Settings!\n",
                    KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDNBuf1)
                    );
                continue;
            }

            KCCSimGetAttribute (pEntryNtdsDsa, ATT_OPTIONS, &attRef);
            if (attRef.pAttr == NULL ||
                attRef.pAttr->pValFirst == NULL) {
                ulOptions = 0;
            } else {
                ulOptions = *((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal);
            }

            rpcStatus = UuidToStringW (&pEntryNtdsDsa->pdn->Guid, &pwszUuid);
            if( rpcStatus != RPC_S_OK ) {
                wprintf ( L"  Server [%s]: Failed to convert Guid to string!\n",
                    KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDNBuf1)
                    );
                continue;
            }

            if (!bInterSite) {
                wprintf (
                    L"  Server [%c%c%c%c] %s [%s]:\n",
                    (ulOptions & NTDSDSA_OPT_IS_GC)                  ?
                      KCCSIM_CID_NTDSDSA_OPT_IS_GC                   : L' ',
                    (ulOptions & NTDSDSA_OPT_DISABLE_INBOUND_REPL)   ?
                      KCCSIM_CID_NTDSDSA_OPT_DISABLE_INBOUND_REPL    : L' ',
                    (ulOptions & NTDSDSA_OPT_DISABLE_OUTBOUND_REPL)  ?
                      KCCSIM_CID_NTDSDSA_OPT_DISABLE_OUTBOUND_REPL   : L' ',
                    (ulOptions & NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE) ?
                      KCCSIM_CID_NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE  : L' ',
                    pwszUuid,
                    KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDNBuf1)
                    );
            }
            RpcStringFreeW (&pwszUuid);

            for (pEntryConnectionAt = KCCSimFindFirstChild (
                    pEntryNtdsDsa, CLASS_NTDS_CONNECTION, NULL);
                 pEntryConnectionAt != NULL;
                 pEntryConnectionAt = KCCSimFindNextChild (
                    pEntryConnectionAt, CLASS_NTDS_CONNECTION, NULL)) {

                KCCSimGetAttribute (pEntryConnectionAt, ATT_ENABLED_CONNECTION, &attRef);
                if (attRef.pAttr == NULL || attRef.pAttr->pValFirst == NULL) {
                    wprintf (
                        L"    Connection %s lacks an enabled attribute!\n",
                        KCCSimQuickRDNOf (pEntryConnectionAt->pdn, wszRDNBuf1)
                        );
                    continue;
                }
                if (*((SYNTAX_BOOLEAN *) attRef.pAttr->pValFirst->pVal)) {
                     bIsEnabled = TRUE;
                } else {
                    bIsEnabled = FALSE;
                }

                KCCSimGetAttribute (pEntryConnectionAt, ATT_FROM_SERVER, &attRef);
                if (attRef.pAttr == NULL || attRef.pAttr->pValFirst == NULL) {
                    wprintf (
                        L"    Connection %s lacks a fromServer attribute!\n",
                        KCCSimQuickRDNOf (pEntryConnectionAt->pdn, wszRDNBuf1)
                        );
                    continue;
                }
                pdnFromServer = (SYNTAX_DISTNAME *) attRef.pAttr->pValFirst->pVal;

                KCCSimGetAttribute (pEntryConnectionAt, ATT_OPTIONS, &attRef);
                if (attRef.pAttr == NULL ||
                    attRef.pAttr->pValFirst == NULL) {
                    ulOptions = 0;
                } else {
                    ulOptions = *((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal);
                }

                KCCSimGetAttribute (pEntryConnectionAt, ATT_TRANSPORT_TYPE, &attRef);
                if (attRef.pAttr == NULL ||
                    attRef.pAttr->pValFirst == NULL) {
                    pdnTransportType = NULL;
                } else {
                    pdnTransportType = (SYNTAX_DISTNAME *) attRef.pAttr->pValFirst->pVal;
                }

                bPrint = FALSE;
                if (bInterSite && (pdnTransportType != NULL)) {
                    wprintf (
                        L"[%s] Connection [%c%c%c%c] [%-4s] to %s from %s\n",
                        bIsEnabled ? L"Enabled " : L"Disabled",
                        (ulOptions & NTDSCONN_OPT_IS_GENERATED)            ?
                          KCCSIM_CID_NTDSCONN_OPT_IS_GENERATED             : L' ',
                        (ulOptions & NTDSCONN_OPT_TWOWAY_SYNC)             ?
                          KCCSIM_CID_NTDSCONN_OPT_TWOWAY_SYNC              : L' ',
                        (ulOptions & NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT) ?
                          KCCSIM_CID_NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT  : L' ',
                        (ulOptions & NTDSCONN_OPT_USE_NOTIFY)              ?
                          KCCSIM_CID_NTDSCONN_OPT_USE_NOTIFY               : L' ',
                        KCCSimQuickRDNOf (pdnTransportType, wszRDNBuf1),
                        KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDNBuf2),
                        KCCSimQuickRDNBackOf (pdnFromServer, 1, wszRDNBuf3)
                        );
                    bPrint = TRUE;
                } else if (!bInterSite && (pdnTransportType == NULL)) {
                    wprintf (
                        L"    [%s] Connection [%c%c%c%c] from %s\n",
                        bIsEnabled ? L"Enabled " : L"Disabled",
                        (ulOptions & NTDSCONN_OPT_IS_GENERATED)            ?
                          KCCSIM_CID_NTDSCONN_OPT_IS_GENERATED             : L' ',
                        (ulOptions & NTDSCONN_OPT_TWOWAY_SYNC)             ?
                          KCCSIM_CID_NTDSCONN_OPT_TWOWAY_SYNC              : L' ',
                        (ulOptions & NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT) ?
                          KCCSIM_CID_NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT  : L' ',
                        (ulOptions & NTDSCONN_OPT_USE_NOTIFY)              ?
                          KCCSIM_CID_NTDSCONN_OPT_USE_NOTIFY               : L' ',
                        KCCSimQuickRDNBackOf (pdnFromServer, 1, wszRDNBuf1)
                        );
                    bPrint = TRUE;
                }

                if (bPrint) {
                    // Print the list of NC's to replicate over this connection (if available)
                    KCCSimGetAttribute (pEntryConnectionAt, ATT_MS_DS_REPLICATES_NC_REASON, &attRef);
                    if (attRef.pAttr != NULL) {
                        wprintf( L"    [" );
                        for (pValAt = attRef.pAttr->pValFirst;
                             pValAt != NULL;
                             pValAt = pValAt->next) {
                            // pVal is a distname-binary
                            SYNTAX_DISTNAME_BINARY *pReason = (SYNTAX_DISTNAME_BINARY *) pValAt->pVal;
                            DSNAME *pdnNC = NAMEPTR( pReason );
                            wprintf( L"%s ", KCCSimQuickRDNOf (pdnNC, wszRDNBuf1) );
                        }
                        wprintf( L"]\n" );
                    }

                    // Print this connection's schedule (if it exists)
                    KCCSimGetAttribute (pEntryConnectionAt, ATT_SCHEDULE, &attRef);
                    if (attRef.pAttr != NULL) {
                        PSCHEDULE pSchedule;
                        DWORD i, lastByte, cbSchedule, cbSchedData;
                        char* pData;

                        cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
                        cbSchedData = SCHEDULE_DATA_ENTRIES;

                        wprintf( L"    [ " );
                        if( attRef.pAttr->pValFirst->ulLen != cbSchedule ) {

                            wprintf( L" Invalid Schedule " );

                        } else {

                            pSchedule = (PSCHEDULE) attRef.pAttr->pValFirst->pVal;
                            pData = ((char*) pSchedule) + sizeof(SCHEDULE);
                            
                            // Find the last non-zero byte in the string
                            lastByte = SCHEDULE_DATA_ENTRIES-1;
                            while( pData[lastByte]==0 ) {
                                lastByte--;
                            }
                            
                            // Print the schedule data in hex, ignoring trailing zeros,
                            // and inserting spaces between every dword
                            for( i=0; i<=lastByte; i++ ) {
                                wprintf( L"%02x", pData[i] );
                                if(i%4==3) wprintf( L" ");
                            }

                            if( lastByte==0 ) {
                                wprintf( L"empty schedule" );
                            }
                        }                        
                        wprintf( L" ]\n" );
                    }                }

            } // for each connection

        }  // for each server/dsa

    } // for each site

    wprintf (L"\n");
}

VOID
KCCSimDisplayConfigInfo (
    VOID
    )
/*++

Routine Description:

    Displays the configuration information.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntryRoot, pEntryConfig, pEntrySites,
                                    pEntryTransports, pEntryTransportAt,
                                    pEntrySiteLinkAt, pEntryBridgeAt;
    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pValAt;

    WCHAR                           wszRDNBuf1[1+MAX_RDN_SIZE],
                                    wszRDNBuf2[1+MAX_RDN_SIZE];
    ULONG                           ulOptions;

    pEntryRoot = KCCSimDsnameToEntry (NULL, KCCSIM_NO_OPTIONS);
    if (pEntryRoot == NULL) {
        wprintf (L"The directory is empty!\n");
        return;
    }

    pEntryConfig = KCCSimFindFirstChild (pEntryRoot, CLASS_CONFIGURATION, NULL);
    if (pEntryConfig == NULL) {
        wprintf (L"Could not locate config container!\n");
        return;
    }

    wprintf (L"Displaying configuration information.\n\n");

    pEntrySites = KCCSimFindFirstChild (
        pEntryConfig,
        CLASS_SITES_CONTAINER,
        NULL
        );
    if (pEntrySites == NULL) {
        wprintf (L"Could not locate sites container!\n");
        return;
    }

    KCCSimDisplayTopologyInfo (pEntrySites, FALSE);
    KCCSimDisplayTopologyInfo (pEntrySites, TRUE);

    pEntryTransports = KCCSimFindFirstChild (
        pEntrySites,
        CLASS_INTER_SITE_TRANSPORT_CONTAINER,
        NULL
        );
    if (pEntryTransports == NULL) {
        wprintf (L"Could not locate inter-site transports container!\n");
        return;
    }

    for (pEntryTransportAt = KCCSimFindFirstChild
            (pEntryTransports, CLASS_INTER_SITE_TRANSPORT, NULL);
         pEntryTransportAt != NULL;
         pEntryTransportAt = KCCSimFindNextChild
            (pEntryTransportAt, CLASS_INTER_SITE_TRANSPORT, NULL)) {

        KCCSimQuickRDNOf (pEntryTransportAt->pdn, wszRDNBuf1);

        for (pEntryBridgeAt = KCCSimFindFirstChild
                (pEntryTransportAt, CLASS_SITE_LINK_BRIDGE, NULL);
             pEntryBridgeAt != NULL;
             pEntryBridgeAt = KCCSimFindNextChild
                (pEntryBridgeAt, CLASS_SITE_LINK_BRIDGE, NULL)) {

            wprintf (
                L"[%s] Bridge %s:\n",
                wszRDNBuf1,
                KCCSimQuickRDNOf (pEntryBridgeAt->pdn, wszRDNBuf2)
                );

            wprintf (L"  Site-Links  :");
            if (KCCSimGetAttribute (pEntryBridgeAt, ATT_SITE_LINK_LIST, &attRef)) {
                for (pValAt = attRef.pAttr->pValFirst;
                     pValAt != NULL;
                     pValAt = pValAt->next) {
                    wprintf (L" [%s]", KCCSimQuickRDNOf
                             ((SYNTAX_DISTNAME *) pValAt->pVal, wszRDNBuf2));
                }
            }
            wprintf (L"\n");
        }

        for (pEntrySiteLinkAt = KCCSimFindFirstChild
                (pEntryTransportAt, CLASS_SITE_LINK, NULL);
             pEntrySiteLinkAt != NULL;
             pEntrySiteLinkAt = KCCSimFindNextChild
                (pEntrySiteLinkAt, CLASS_SITE_LINK, NULL)) {

            wprintf (
                L"[%s] Site-link %s:\n",
                wszRDNBuf1,
                KCCSimQuickRDNOf (pEntrySiteLinkAt->pdn, wszRDNBuf2)
                );

            wprintf (L"  Sites        :");
            if (KCCSimGetAttribute (pEntrySiteLinkAt, ATT_SITE_LIST, &attRef)) {
                for (pValAt = attRef.pAttr->pValFirst;
                     pValAt != NULL;
                     pValAt = pValAt->next) {
                    wprintf (L" [%s]", KCCSimQuickRDNOf
                             ((SYNTAX_DISTNAME *) pValAt->pVal, wszRDNBuf2));
                }
            }
            wprintf (L"\n");

            if (KCCSimGetAttribute (pEntrySiteLinkAt, ATT_COST, &attRef)) {
                wprintf (L"  Cost         : %lu\n", *((SYNTAX_INTEGER *)
                         attRef.pAttr->pValFirst->pVal));
            }
            if (KCCSimGetAttribute (pEntrySiteLinkAt, ATT_REPL_INTERVAL, &attRef)) {
                wprintf (L"  Repl Interval: %lu\n", *((SYNTAX_INTEGER *)
                         attRef.pAttr->pValFirst->pVal));
            }

        }

    }
}


/*++

Structure Name:
    
    SimpleDict

Description:

    Simple fixed-size dictionary for mapping a set of Unicode strings to
    integers in [0,n]. Uses a simple sorted array.

Usage:
    Create using DictNew(), giving the maximum number of entries.
    Add entries using the DictAdd() function.
    After adding all entries, use DictSort() to sort the entries.
    The entries can then be efficiently looked up using DictLookup().
    When finished with the dictionary, use DictFree() to free its memory.

--*/
typedef struct {
    WCHAR**     data;
    int         maxSize, curSize;
    char        sorted;         
} SimpleDict;


VOID
DictNew (
    SimpleDict                      *d,
    int                             size
    )
/*++

Routine Description:

    DictNew - Create a new SimpleDict

Arguments:

    d                   - Pointer to a SimpleDict structure
    size                - Maximum number of elements the dict can contain

Return Value:

    None, but returns an initialized dictionary in d
    
--*/
{
    int i;
    Assert( size>0 );
    d->maxSize = d->curSize = 0;
    d->data = (WCHAR**) KCCSimAlloc( sizeof(WCHAR*)*size );
    d->maxSize = size;
}


VOID
DictFree (
    SimpleDict                       *d
    )
/*++

Routine Description:

    DictFree - Free the memory used by a SimpleDict

Arguments:

    d                   - Pointer to a valid SimpleDict structure

Return Value:

    None

--*/
{
    int i;
    for(i=0;i<d->curSize;i++) {
        if(d->data[i]) {
            KCCSimFree( d->data[i] );
            d->data[i] = NULL;
        }
    }
    KCCSimFree( d->data );
    d->data=NULL;
    d->maxSize = d->curSize = 0;
}


VOID
DictAdd (
    SimpleDict *d,
    WCHAR* wszStr
    )
/*++

Routine Description:

    DictAdd - Add a string to the dictionary
    The dictionary must not be full already.

Arguments:

    d                   - Pointer to a valid SimpleDict structure
    wszStr              - Pointer to a Unicode string

Return Value:

    None

--*/
{
    Assert( d->curSize<d->maxSize );
    d->data[d->curSize] = (WCHAR*) KCCSimAlloc( (wcslen(wszStr)+1)*sizeof(WCHAR) );
    wcscpy( d->data[d->curSize], wszStr );
    d->curSize++;
    d->sorted=0;
}


int __cdecl wszCompare( const WCHAR** arg1, const WCHAR** arg2 ) {
    return wcscmp( *arg1, *arg2 );
}


VOID
DictSort (
    SimpleDict *d
    )
/*++

Routine Description:

    DictSort - Sort the entries in a dictionary for efficient lookup.

Arguments:

    d                   - Pointer to a valid SimpleDict structure

Return Value:

    None
    
--*/
{
    Assert( d->data );
    qsort( d->data, d->curSize, sizeof(WCHAR*), wszCompare );
    d->sorted=1;
}


int
DictLookup (
    SimpleDict *d,
    WCHAR* wszStr
    )
/*++

Routine Description:

    DictLookup - Search the dictionary for a string matching wszStr,
    and map its name to an integer.

Arguments:

    d                   - Pointer to a valid SimpleDict structure
    wszStr              - The string we're looking for

Return Value:

    If the string was found, return its index in [0,n]. If it
    was not found, return -1.

--*/
{
    void* p;
    int x;
    Assert( d->data );
    if( !d->sorted ) DictSort(d);
    p = bsearch( &wszStr, d->data, d->curSize, sizeof(WCHAR*), wszCompare );
    if(p==NULL) { return -1; }
    x = (int) (((WCHAR**)p)-d->data);
    Assert(0==wcscmp(wszStr,d->data[x]));
    return x;
}


#define INTMIN(x,y) ((x)<(y)?(x):(y))
#define INF      (~((int)0))


VOID
KCCSimDisplaySiteGraphInfo (
    IN  PSIM_ENTRY                  pEntrySites
    )
/*++
Routine Description:

    Displays graph-theoretic information about a site.

Arguments:

    pEntrySites         - The Sites container.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntrySiteAt, pEntrySiteSettings,
                                    pEntryServers, pEntryServerAt,
                                    pEntryNtdsDsa, pEntryConnectionAt;
    SIM_ATTREF                      attRef;
    LPWSTR                          pwszUuid;
    WCHAR                           wszRDNBuf1[1+MAX_RDN_SIZE];
    BOOL                            bIsEnabled;
    PDSNAME                         pdnFromServer = NULL;

    SimpleDict                      dict;
    int                             i,j,k;
    int                             numServers, toServer, fromServer;
    unsigned int                    *mat=NULL,diam,avg;


    /* Loop over all sites */
    for (pEntrySiteAt = KCCSimFindFirstChild(pEntrySites, CLASS_SITE, NULL);
         pEntrySiteAt != NULL;
         pEntrySiteAt = KCCSimFindNextChild(pEntrySiteAt, CLASS_SITE, NULL)) {


        UuidToStringW (&pEntrySiteAt->pdn->Guid, &pwszUuid);
        KCCSimQuickRDNOf(pEntrySiteAt->pdn, wszRDNBuf1);
        wprintf( L"Site %s [%s]:\n",pwszUuid,wszRDNBuf1);
        RpcStringFreeW (&pwszUuid);

        pEntryServers = KCCSimFindFirstChild(pEntrySiteAt,CLASS_SERVERS_CONTAINER,NULL);
        if (pEntryServers == NULL) {
            wprintf (L"  Could not locate servers container!\n");
            continue;
        }


        /* Count the number of servers in the site */
        numServers=0;
        for (pEntryServerAt = KCCSimFindFirstChild (pEntryServers, CLASS_SERVER, NULL);
             pEntryServerAt != NULL;
             pEntryServerAt = KCCSimFindNextChild (pEntryServerAt, CLASS_SERVER, NULL))
        {
            numServers++;
        }

        wprintf(L"  Servers: %d\n", numServers);
        if( numServers==0 ) { continue; }
        DictNew(&dict, numServers);

        __try {

            /* Add the names of the servers to the dictionary */
            for (pEntryServerAt = KCCSimFindFirstChild (pEntryServers, CLASS_SERVER, NULL);
                 pEntryServerAt != NULL;
                 pEntryServerAt = KCCSimFindNextChild (pEntryServerAt, CLASS_SERVER, NULL))
            {
                KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDNBuf1);
                DictAdd(&dict, wszRDNBuf1);
            }
            DictSort(&dict);

            /* Allocate our adjacency matrix */
            mat = (int*) KCCSimAlloc( sizeof(int)*numServers*numServers );
            for(i=0;i<numServers;i++) {
                for(j=0;j<numServers;j++) {
                    mat[i*numServers+j] = (i==j)?0:INF;
                }
            }

            /* Loop over all servers in the site */
            for (pEntryServerAt = KCCSimFindFirstChild (pEntryServers, CLASS_SERVER, NULL);
                 pEntryServerAt != NULL;
                 pEntryServerAt = KCCSimFindNextChild (pEntryServerAt, CLASS_SERVER, NULL)) {

                pEntryNtdsDsa = KCCSimFindFirstChild(pEntryServerAt, CLASS_NTDS_DSA, NULL);
                if (pEntryNtdsDsa == NULL) {
                    wprintf( L"  Server [%s]: Could not locate NTDS Settings!\n",
                        KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDNBuf1));
                    continue;
                }

                KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDNBuf1);
                toServer = DictLookup(&dict, wszRDNBuf1);
                Assert(toServer>=0);

                /* Loop over all connections of this server */
                for (pEntryConnectionAt = KCCSimFindFirstChild (
                        pEntryNtdsDsa, CLASS_NTDS_CONNECTION, NULL);
                     pEntryConnectionAt != NULL;
                     pEntryConnectionAt = KCCSimFindNextChild (
                        pEntryConnectionAt, CLASS_NTDS_CONNECTION, NULL)) {

                    KCCSimGetAttribute (pEntryConnectionAt, ATT_ENABLED_CONNECTION, &attRef);
                    if (attRef.pAttr == NULL || attRef.pAttr->pValFirst == NULL) {
                        wprintf(L"    Connection %s lacks an enabled attribute!\n",
                            KCCSimQuickRDNOf (pEntryConnectionAt->pdn, wszRDNBuf1));
                        continue;
                    }
                    if (*((SYNTAX_BOOLEAN *) attRef.pAttr->pValFirst->pVal)) {
                         bIsEnabled = TRUE;
                    } else {
                        bIsEnabled = FALSE;
                    }

                    KCCSimGetAttribute (pEntryConnectionAt, ATT_FROM_SERVER, &attRef);
                    if (attRef.pAttr == NULL || attRef.pAttr->pValFirst == NULL) {
                        wprintf (L"    Connection %s lacks a fromServer attribute!\n",
                            KCCSimQuickRDNOf (pEntryConnectionAt->pdn, wszRDNBuf1));
                        continue;
                    }
                    pdnFromServer = (SYNTAX_DISTNAME *) attRef.pAttr->pValFirst->pVal;
                    KCCSimQuickRDNBackOf(pdnFromServer, 1, wszRDNBuf1);
                    fromServer = DictLookup( &dict, wszRDNBuf1 );

                    /* Ignore inter-site connections */
                    if( fromServer==-1 ) { continue; }

                    if( bIsEnabled ) {
                        Assert( 0<=fromServer ); Assert( fromServer<numServers );
                        Assert( 0<=toServer );   Assert( toServer<numServers );

                        /* Update our adjacency matrix accordingly */
                        mat[ toServer*numServers + fromServer ] = 1;
                    }

                }   /* End of connections */

            }   /* End of servers */

            /* Now that we have condensed the graph topology into an adjancency matrix,
             * we run Floyd-Warshall to determine all-pairs shortest path costs */
            for(k=0;k<numServers;k++) {
                for(i=0;i<numServers;i++) {
                    for(j=0;j<numServers;j++) {
                        if( mat[i*numServers+k]!=INF && mat[k*numServers+j]!=INF ) {
                            mat[i*numServers+j] =
                                INTMIN( mat[i*numServers+j],
                                        mat[i*numServers+k]+mat[k*numServers+j] ); 
                        }
                    }
                }
            }

            /* Now find the maximum length of a shortest path (ie, diameter) */
            diam = avg = 0;
            for(i=0;i<numServers;i++) {
                for(j=0;j<numServers;j++) {
                    if( mat[i*numServers+j]>diam ) diam=mat[i*numServers+j];
                    if(i!=j) avg+=mat[i*numServers+j];
                }
            }

            /* Print our results */
            if(diam==INF) {
                wprintf( L"    Intra-site topology diameter: Infinite (Graph disconnected)\n");
                wprintf( L"    Average shortest-path length: Infinite\n");
            } else {
                wprintf( L"    Intra-site topology diameter: %d\n", diam);
                wprintf( L"    Average shortest-path length: %f\n",
                    ((float)avg)/(float)(numServers*numServers-numServers));
            }

        } __finally {

            if(mat) KCCSimFree(mat);
            DictFree(&dict);

        }

    }   /* End of sites */

    wprintf (L"\n");
}


VOID
KCCSimDisplayGraphInfo (
    VOID
    )
/*++

Routine Description:

    Examines the configuration (ie. Connection objects in the current
    directory), and calculates some graph-theoretic statistics.
    Calls KCCSimDisplaySiteGraphInfo() to do most of the work.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntryRoot, pEntryConfig, pEntrySites;

    pEntryRoot = KCCSimDsnameToEntry (NULL, KCCSIM_NO_OPTIONS);
    if (pEntryRoot == NULL) {
        wprintf (L"The directory is empty!\n");
        return;
    }

    pEntryConfig = KCCSimFindFirstChild (pEntryRoot, CLASS_CONFIGURATION, NULL);
    if (pEntryConfig == NULL) {
        wprintf (L"Could not locate config container!\n");
        return;
    }

    wprintf (L"Displaying graph information.\n\n");

    pEntrySites = KCCSimFindFirstChild ( pEntryConfig, CLASS_SITES_CONTAINER, NULL );
    if (pEntrySites == NULL) {
        wprintf (L"Could not locate sites container!\n");
        return;
    }

    KCCSimDisplaySiteGraphInfo(pEntrySites);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\simmdrd.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simmdrd.c

ABSTRACT:

    Simulates the read functions from the mdlayer
    (DirRead, DirSearch.)

    Note that these routines return results in thread allocated memory (see ThCreate,
    ThAlloc, etc).  There must be thread state active in order for these routines
    to be able to allocate memory.

    The results of these routines should not be used for simulator long term memory of
    cached results. If the caller wants there results to outlast the current thread
    state, he must copy them.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <direrr.h>
#include <attids.h>
#include <filtypes.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "simmd.h"
#include "state.h"

#define NO_UPPER_LIMIT              0xffffffff

VOID
KCCSimGetValueLimits (
    IN  ATTRTYP                     attrType,
    IN  RANGEINFSEL *               pRangeSel,
    OUT PDWORD                      pStartIndex,
    OUT PDWORD                      pNumValues
    )
/*++

Routine Description:

    Given a range selection, returns the start index and
    number of values to return from an attribute.
    
    Note this is almost identical to the corresponding
    function in the dblayer.

Arguments:

    attrType            - The attribute type being read.
    pRangeSel           - The range selection.
    pStartIndex         - Pointer to a DWORD that will hold the start index.
    pNumValues          - Pointer to a DWORD that will hold the number of
                          values to retrieve.

Return Value:

    None.

--*/
{
    DWORD                           i;

    // Assume no limits.
    *pStartIndex = 0;
    *pNumValues = NO_UPPER_LIMIT;

    if(!pRangeSel) {
        // Yup, no limits.
        return;
    }

    // OK, assume only general limit, not specific match.
    *pNumValues = pRangeSel->valueLimit;

    // Look through the rangesel for a specific match
    for(i=0;i<pRangeSel->count;i++) {
        if(attrType == pRangeSel->pRanges[i].AttId) {
            if(pRangeSel->pRanges[i].upper == NO_UPPER_LIMIT) {
                *pStartIndex = pRangeSel->pRanges[i].lower;
                return;
            }
            else if(pRangeSel->pRanges[i].lower <=pRangeSel->pRanges[i].upper) {
                DWORD tempNumVals;
                *pStartIndex = pRangeSel->pRanges[i].lower;
                tempNumVals = (pRangeSel->pRanges[i].upper -
                               pRangeSel->pRanges[i].lower   )+ 1;

                if(*pNumValues != NO_UPPER_LIMIT) {
                    *pNumValues = min(*pNumValues, tempNumVals);
                }
                else {
                    *pNumValues = tempNumVals;
                }
            }
            else {
                *pNumValues = 0;
            }
            return;
        }
    }
}

VOID
KCCSimRegisterLimitReached (
    IO  RANGEINF *                  pRangeInf,
    IN  ATTRTYP                     attrType,
    IN  DWORD                       dwLower,
    IN  DWORD                       dwUpper
    )
/*++

Routine Description:

    When the number of attribute values read has reached the
    maximum allowed, this function makes a note of it in the
    rangeinf parameter.

Arguments:

    pRangeInf           - The rangeinf structure.
    attrType            - The attribute type.
    dwLower             - The lower limit.
    dwUpper             - The upper limit.

Return Value:

    None.

--*/
{
    if (pRangeInf->count == 0) {
        pRangeInf->pRanges = KCCSIM_THNEW (RANGEINFOITEM);
    } else {
        pRangeInf->pRanges =
          KCCSimThreadReAlloc (
              pRangeInf->pRanges,
              (pRangeInf->count + 1) * sizeof (RANGEINFOITEM));
    }

    pRangeInf->pRanges[pRangeInf->count].AttId = attrType;
    pRangeInf->pRanges[pRangeInf->count].lower = dwLower;
    pRangeInf->pRanges[pRangeInf->count].upper = dwUpper;

    pRangeInf->count++;
}

BOOL
KCCSimIsMatchingAttribute (
    IN  ENTINFSEL *                 pEntSel,
    IN  ATTRTYP                     attrType
    )
/*++

Routine Description:

    Checks whether the given attribute satisfies the entry
    selection parameters specified for a read.

Arguments:

    pEntSel             - Entry selection parameters.
    attrType            - The attribute type.

Return Value:

    TRUE if the attribute satisfies the given constraints.

--*/
{
    BOOL                            bResult;
    ULONG                           ulAttrAt;

    // If there are no restrictions, just return true
    if (pEntSel == NULL) {
        return TRUE;
    }

    switch (pEntSel->attSel) {

        case EN_ATTSET_ALL:
            bResult = TRUE;
            break;

        case EN_ATTSET_LIST:
            bResult = FALSE;
            // Check if it's in the list
            for (ulAttrAt = 0;
                 ulAttrAt < pEntSel->AttrTypBlock.attrCount;
                 ulAttrAt++) {
                if (attrType == pEntSel->AttrTypBlock.pAttr[ulAttrAt].attrTyp) {
                    bResult = TRUE;
                    break;
                }
            }
            break;

        case EN_ATTSET_ALL_WITH_LIST:
        case EN_ATTSET_LIST_DRA:
        case EN_ATTSET_ALL_DRA:
        case EN_ATTSET_LIST_DRA_EXT:
        case EN_ATTSET_ALL_DRA_EXT:
        case EN_ATTSET_LIST_DRA_PUBLIC:
        case EN_ATTSET_ALL_DRA_PUBLIC:
        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_ATTSET
                );
            bResult = FALSE;
            break;

    }

    return bResult;
}

VOID
KCCSimPackSingleAttribute (
    IN  ATTRTYP                     attrType,
    IN  PSIM_VALUE                  pValFirst,
    IN  UCHAR                       infoTypes,
    IN  RANGEINFSEL *               pRangeSel,
    IO  ATTR *                      pAttr,
    IO  RANGEINF *                  pRangeInf
    )
{
    PSIM_VALUE                      pValStart, pValAt;
    DWORD                           dwValAt, dwStartIndex, dwNumValues;

    pAttr->attrTyp = attrType;

    switch (infoTypes) {

        case EN_INFOTYPES_TYPES_ONLY:
            pAttr->AttrVal.valCount = 0;
            pAttr->AttrVal.pAVal = NULL;
            break;

        case EN_INFOTYPES_TYPES_VALS:
            KCCSimGetValueLimits (attrType,
                                  pRangeSel,
                                  &dwStartIndex,
                                  &dwNumValues);
            // Proceed to value dwStartIndex
            pValStart = pValFirst;
            dwValAt = 0;
            while (dwValAt < dwStartIndex && pValStart != NULL) {
                dwValAt++;
                pValStart = pValStart->next;
            }
            // Determine the actual number of values to return
            pValAt = pValStart;
            dwValAt = 0;
            while (dwValAt < dwNumValues && pValAt != NULL) {
                dwValAt++;
                pValAt = pValAt->next;
            }
            pAttr->AttrVal.valCount = dwValAt;
            pAttr->AttrVal.pAVal =
                (ATTRVAL *) KCCSimThreadAlloc (sizeof (ATTRVAL) * dwValAt);
            // Pack the values
            pValAt = pValStart;
            dwValAt = 0;
            while (dwValAt < dwNumValues && pValAt != NULL) {
                pAttr->AttrVal.pAVal[dwValAt].valLen
                  = pValAt->ulLen;
                pAttr->AttrVal.pAVal[dwValAt].pVal
                  = (PBYTE) KCCSimThreadAlloc (pValAt->ulLen);
                memcpy (pAttr->AttrVal.pAVal[dwValAt].pVal,
                        pValAt->pVal,
                        pValAt->ulLen);
                dwValAt++;
                pValAt = pValAt->next;
            }
            // Right now, the only time we can have a limited range is if
            // the user explicitly requested one.  This happens if either:
            // - There's a lower limit, or
            // - Not all values were returned, and the next one to be returned
            //   (= dwStartIndex + dwNumValues) is strictly less than valueLimit
            if (pRangeSel != NULL &&
                (dwStartIndex > 0 ||
                 (dwStartIndex + dwNumValues < pRangeSel->valueLimit &&
                  pValAt != NULL))) {
                KCCSimRegisterLimitReached (
                    pRangeInf,
                    attrType,
                    dwStartIndex,
                    dwStartIndex + dwNumValues - 1
                    );
            }
            break;

        case EN_INFOTYPES_TYPES_MAPI:
        case EN_INFOTYPES_SHORTNAMES:
        case EN_INFOTYPES_MAPINAMES:
        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_INFOTYPE
                );
            break;

    }
}


// When defined, the simulator will return simulated repsfroms to the KCC.
#define SIMULATED_REPSFROM


VOID
KCCSimPackAttributes (
    IN  PSIM_ENTRY                  pEntry,
    IN  ENTINFSEL *                 pEntSel,
    IN  RANGEINFSEL *               pRangeSel,
    IO  ENTINF *                    pEntInf,
    IO  RANGEINF *                  pRangeInf
    )
/*++

Routine Description:

    Given ENTINFSEL and RANGEINFSEL structures, this function
    generates the ENTINF and RANGEINF structures for a particular entry.

Arguments:

    pEntry              - The entry to process.
    pEntInfSel          - The entry selection constraints.
    pRangeInfSel        - The range selection constraints.
    pEntInf             - Pointer to an ENTINF structure that will hold
                          the returned data.
    pRangeInf           - Pointer to a RANGEINF structure that will hold
                          the returned range restrictions.

Return Value:

    None.

--*/
{
    UCHAR                           infoTypes;

    PSIM_ATTRIBUTE                  pAttrAt;
    ATTRBLOCK *                     pAttrBlock;
    DWORD                           dwAttrAt;

    if (pEntSel == NULL) {      // Use default for infoTypes
        infoTypes = EN_INFOTYPES_TYPES_VALS;
    } else {
        infoTypes = pEntSel->infoTypes;
    }

    // Fill in pEntInf / pRangeInf basics

    pEntInf->pName = KCCSimThreadAlloc (pEntry->pdn->structLen);
    memcpy (
        pEntInf->pName,
        pEntry->pdn,
        pEntry->pdn->structLen
        );
    pEntInf->ulFlags = 0;        // We don't fill this in yet, but unused by KCC.
    pRangeInf->count = 0;
    pRangeInf->pRanges = NULL;

    // Fill in the attribute block & range info
    pAttrBlock = &pEntInf->AttrBlock;

    // How many attributes are there that match attSel?
    pAttrAt = pEntry->pAttrFirst;
    dwAttrAt = 0;
    while (pAttrAt != NULL) {
        if (
#ifdef SIMULATED_REPSFROM
            pAttrAt->attrType != ATT_REPS_FROM &&   // repsFrom is handled separately
#endif // SIMULATED_REPSFROM
            KCCSimIsMatchingAttribute (pEntSel, pAttrAt->attrType)) {
            dwAttrAt++;
        }
        pAttrAt = pAttrAt->next;
    }

    // Did they request repsFrom?
#ifdef SIMULATED_REPSFROM
    if (KCCSimIsMatchingAttribute (pEntSel, ATT_REPS_FROM) &&
        KCCSimGetRepsFroms (
            KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
            pEntry->pdn
            ) != NULL) {
        dwAttrAt++;
    }
#endif // SIMULATED_REPSFROM

    pAttrBlock->attrCount = dwAttrAt;
    pAttrBlock->pAttr = (ATTR *) KCCSimThreadAlloc (sizeof (ATTR) * dwAttrAt);

    pAttrAt = pEntry->pAttrFirst;
    dwAttrAt = 0;
    while (pAttrAt != NULL) {
        if (
#ifdef SIMULATED_REPSFROM
            pAttrAt->attrType != ATT_REPS_FROM &&
#endif // SIMULATED_REPSFROM
            KCCSimIsMatchingAttribute (pEntSel, pAttrAt->attrType)) {

            KCCSimPackSingleAttribute (
                pAttrAt->attrType,
                pAttrAt->pValFirst,
                infoTypes,
                pRangeSel,
                &pAttrBlock->pAttr[dwAttrAt],
                pRangeInf
                );
            dwAttrAt++;

        }
        pAttrAt = pAttrAt->next;
    }

    // Add repsFrom
#ifdef SIMULATED_REPSFROM
    if (KCCSimIsMatchingAttribute (pEntSel, ATT_REPS_FROM) &&
        KCCSimGetRepsFroms (
            KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
            pEntry->pdn
            ) != NULL) {
        KCCSimPackSingleAttribute (
            ATT_REPS_FROM,
            KCCSimGetRepsFroms (
                KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
                pEntry->pdn),
            infoTypes,
            pRangeSel,
            &pAttrBlock->pAttr[dwAttrAt],
            pRangeInf
            );
    }
#endif // SIMULATED_REPSFROM
}

ULONG
SimDirRead (
    IN  READARG FAR *               pReadArg,
    OUT READRES **                  ppReadRes
    )
/*++

Routine Description:

    Simulates the DirRead API.

Arguments:

    pReadArg            - Standard DirRead arguments.
    ppReadRes           - Standard DirRead results.

Return Value:

    DIRERR_*.

--*/
{
    READRES *                       pReadRes;
    PSIM_ENTRY                      pEntry;
    ENTINF *                        pEntInf;
    RANGEINF *                      pRangeInf;

    ULONG                           ul;

    g_Statistics.DirReadOps++;
    *ppReadRes = pReadRes = KCCSIM_THNEW (READRES);
    pReadRes->CommRes.errCode = 0;

    pEntry = KCCSimResolveName (pReadArg->pObject, &pReadRes->CommRes);

    if (pEntry != NULL) {

        KCCSimPackAttributes (pEntry,
                              pReadArg->pSel,
                              pReadArg->pSelRange,
                              &pReadRes->entry,
                              &pReadRes->range);

        // If the user requested a list of attributes, and the list
        // is nonempty, and no attributes were found, it's an error
        if (pReadArg->pSel &&
            pReadArg->pSel->AttrTypBlock.attrCount > 0 &&
            pReadRes->entry.AttrBlock.attrCount == 0) {

            for (ul = 0; ul < pReadArg->pSel->AttrTypBlock.attrCount; ul++) {

                KCCSimSetAttError (
                    &pReadRes->CommRes,
                    pReadArg->pObject,
                    pReadArg->pSel->AttrTypBlock.pAttr[ul].attrTyp,
                    PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                    NULL,
                    DIRERR_NO_REQUESTED_ATTS_FOUND
                );

            }
        }

    }

    return pReadRes->CommRes.errCode;
}

BOOL
KCCSimEvalChoice (
    PSIM_ENTRY                      pEntry,
    UCHAR                           ucChoice,
    ATTRTYP                         attrType,
    ULONG                           ulFilterValLen,
    PUCHAR                          pFilterVal,
    PBOOL                           pbSkip
    )
/*++

Routine Description:

    Evaluates a filter on a given entry.

Arguments:

    pEntry              - The entry to evaluate.
    ucChoice            - The filter choice.
    attrType            - The attribute type.
    ulFilterValLen      - Length of the filter value.
    pFilterVal          - The filter value.
    pbSkip              - Skip parameter.

Return Value:

    TRUE if this entry matches the filter.

--*/
{
    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pVal;
    BOOL                            bEvalAny, bPassed;

    bEvalAny = FALSE;           // Have we checked any values?
    bPassed = FALSE;            // Have any values passed the test?

    // Find this attribute in the directory
    KCCSimGetAttribute (pEntry, attrType, &attRef);

    // We only try to evaluate this FILITEM if pbSkip is FALSE
    // or doesn't exist.

    if (attRef.pAttr != NULL &&
        (pbSkip == NULL || *pbSkip == FALSE)) {

        for (pVal = attRef.pAttr->pValFirst;
             pVal != NULL;
             pVal = pVal->next) {

            // Found a value.
            bEvalAny = TRUE;

            if (KCCSimCompare (
                    attrType,
                    ucChoice,
                    ulFilterValLen,
                    pFilterVal,
                    pVal->ulLen,
                    pVal->pVal)) {
                bPassed = TRUE;
                break;
            }

        } // for

    } // if

    // If we evaluated at least one value, then we return
    // bPassed.  If we evaluated no values, we return TRUE
    // if and only if the filitem choice is FI_CHOICE_NOT_EQUAL.
    if (bEvalAny) {
        return bPassed;
    } else {
        return (ucChoice == FI_CHOICE_NOT_EQUAL);
    }

}

BOOL
KCCSimEvalItem (
    PSIM_ENTRY                      pEntry,
    FILITEM *                       pFilItem
    )
/*++

Routine Description:

    Evaluates a single filter item on a given entry.

Arguments:

    pEntry              - The entry to evaluate.
    pFilItem            - The filter item.

Return Value:

    TRUE if the entry matches the filter item.

--*/
{
    BOOL bResult = FALSE;

    // Get the attribute type
    switch (pFilItem->choice) {
        
        case FI_CHOICE_FALSE:
            bResult = FALSE;
            break;

        case FI_CHOICE_TRUE:
            bResult = TRUE;
            break;

        case FI_CHOICE_PRESENT:
            bResult = KCCSimEvalChoice (
                pEntry,
                pFilItem->choice,
                pFilItem->FilTypes.present,
                0,
                NULL,
                pFilItem->FilTypes.pbSkip
                );
            break;

        case FI_CHOICE_SUBSTRING:
            bResult = KCCSimEvalChoice (
                pEntry,
                pFilItem->choice,
                pFilItem->FilTypes.pSubstring->type,
                0,          // N/A for substrings
                (PUCHAR) pFilItem->FilTypes.pSubstring,
                pFilItem->FilTypes.pbSkip
                );
            break;

        case FI_CHOICE_EQUALITY:
        case FI_CHOICE_NOT_EQUAL:
        case FI_CHOICE_GREATER_OR_EQ:
        case FI_CHOICE_GREATER:
        case FI_CHOICE_LESS_OR_EQ:
        case FI_CHOICE_LESS:
        case FI_CHOICE_BIT_AND:
        case FI_CHOICE_BIT_OR:
            bResult = KCCSimEvalChoice (
                pEntry,
                pFilItem->choice,
                pFilItem->FilTypes.ava.type,
                pFilItem->FilTypes.ava.Value.valLen,
                pFilItem->FilTypes.ava.Value.pVal,
                pFilItem->FilTypes.pbSkip
                );
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_FILITEM_CHOICE
                );
            break;

    }

    return bResult;
}

BOOL
KCCSimFilter (
    IN  PSIM_ENTRY                  pEntry,
    IN  PFILTER                     pFilter
    )
/*++

Routine Description:

    Evaluates a filter on a given entry.

Arguments:

    pEntry              - The entry to evaluate.
    pFilter             - The filter.

Return Value:

    TRUE if the entry matches the filter.

--*/
{
    PFILTER                         pFilterAt;
    BOOL                            bThisFilterValue;
    USHORT                          usCount;

    // What kind of filter is this?
    switch (pFilter->choice) {

        case FILTER_CHOICE_ITEM:
            // It's an item, so we can just evaluate the FILITEM.
            bThisFilterValue = KCCSimEvalItem (
                pEntry,
                &(pFilter->FilterTypes.Item)
                );
            break;

        case FILTER_CHOICE_AND:
            // It's an AND filterset.  So, check if any of its elements
            // are false.  Return TRUE only if all elements return TRUE.
            bThisFilterValue = TRUE;
            pFilterAt = pFilter->FilterTypes.And.pFirstFilter;
            usCount = pFilter->FilterTypes.And.count;
            while (pFilterAt != NULL && usCount > 0) {
                if (KCCSimFilter (pEntry, pFilterAt) == FALSE) {
                    bThisFilterValue = FALSE;
                    break;
                }
                pFilterAt = pFilterAt->pNextFilter;
                usCount--;
            }
            break;

        case FILTER_CHOICE_OR:
            // It's an OR filterset.  Same idea as with AND: we return
            // FALSE only if all elements return FALSE.
            bThisFilterValue = FALSE;
            pFilterAt = pFilter->FilterTypes.Or.pFirstFilter;
            usCount = pFilter->FilterTypes.Or.count;
            while (pFilterAt != NULL && usCount > 0) {
                if (KCCSimFilter (pEntry, pFilterAt) == TRUE) {
                    bThisFilterValue = TRUE;
                    break;
                }
                pFilterAt = pFilterAt->pNextFilter;
                usCount--;
            }
            break;

        case FILTER_CHOICE_NOT:
            // It's a NOT.  Return the converse of its element.
            bThisFilterValue =
                !KCCSimFilter (pEntry, pFilter->FilterTypes.pNot);
            break;

        default:
            // It's something we don't know about . . .
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_FILTER_CHOICE
                );
            bThisFilterValue = FALSE;
            break;

    }

    return bThisFilterValue;
}

VOID
KCCSimDoSearch (
    IN  PSIM_ENTRY                  pEntryAt,
    IN  UCHAR                       ucChoice,
    IN  PFILTER                     pFilter,
    IN  ENTINFSEL *                 pEntSel,
    IN  RANGEINFSEL *               pRangeSel,
    IO  PBOOL                       pbFirstFind,
    IO  SEARCHRES *                 pSearchRes
    )
/*++

Routine Description:

    Recursive search routine.  Generates search results for
    pEntryAt and all of its children, under the supplied choice,
    filter, entry selection and range selection constraints.

    Note: For performance reason, we prepend new matches to the beginning
    of the result list. Therefore, the ordering of the results is not what
    it used to be, but this shouldn't matter.

Arguments:

    pEntryAt            - The entry we're currently searching.
    ucChoice            - The type of search we are doing (base only,
                          immediate children, or whole subtree)
    pFilter             - The filter.
    pEntSel             - The entry selection constraints.
    pRangeSel           - The range selection constraints.
    pbFirstFind         - Initially set to TRUE.  After a match has
                          been found, this is set to FALSE.
    pSearchRes          - Preallocated search results structure.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pChildAt;
    ENTINFLIST *                    pEntInfList;
    RANGEINFLIST *                  pRangeInfList;
    ENTINF *                        pEntInf;
    RANGEINF *                      pRangeInf;

    if (KCCSimFilter (pEntryAt, pFilter)) {

        // This entry matches the filter, so we need to generate
        // search results.

        pSearchRes->count++;

        if (*pbFirstFind) {
            pEntInf = &(pSearchRes->FirstEntInf.Entinf);
            pRangeInf = &(pSearchRes->FirstRangeInf.RangeInf);
        } else {
            ENTINFLIST *pEntTail;
            RANGEINFLIST *pRangeTail;

            // Add a new entinf to the _head_ of the list
            pEntTail = pSearchRes->FirstEntInf.pNextEntInf;
            pEntInfList = KCCSIM_THNEW (ENTINFLIST);
            pSearchRes->FirstEntInf.pNextEntInf = pEntInfList;
            pEntInfList->pNextEntInf = pEntTail;
            pEntInf = &(pEntInfList->Entinf);

            // Add a new rangeinf to the _head_ of the list
            pRangeTail = pSearchRes->FirstRangeInf.pNext;
            pRangeInfList = KCCSIM_THNEW (RANGEINFLIST);
            pSearchRes->FirstRangeInf.pNext = pRangeInfList;
            pRangeInfList->pNext = pRangeTail;
            pRangeInf = &(pRangeInfList->RangeInf);
        }

        // Pack the attributes for this entry.
        KCCSimPackAttributes (
            pEntryAt,
            pEntSel,
            pRangeSel,
            pEntInf,
            pRangeInf
            );

        *pbFirstFind = FALSE;

    }

    switch (ucChoice) {

        case SE_CHOICE_BASE_ONLY:
            // We're done!
            break;

        case SE_CHOICE_IMMED_CHLDRN:
            // We need to do a recursive base-only search on each child.
            pChildAt = pEntryAt->children;
            while (pChildAt != NULL) {
                KCCSimDoSearch (
                    pChildAt,
                    SE_CHOICE_BASE_ONLY,
                    pFilter,
                    pEntSel,
                    pRangeSel,
                    pbFirstFind,
                    pSearchRes
                    );
                pChildAt = pChildAt->next;
            }
            break;

        case SE_CHOICE_WHOLE_SUBTREE:
            // We need to do a recursive whole-subtree search on each child.
            pChildAt = pEntryAt->children;
            while (pChildAt != NULL) {
                KCCSimDoSearch (
                    pChildAt,
                    SE_CHOICE_WHOLE_SUBTREE,
                    pFilter,
                    pEntSel,
                    pRangeSel,
                    pbFirstFind,
                    pSearchRes
                    );
                pChildAt = pChildAt->next;
            }
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_SE_CHOICE
                );
            break;

    }
}    

ULONG
SimDirSearch (
    IN  SEARCHARG *                 pSearchArg,
    OUT SEARCHRES **                ppSearchRes
    )
/*++

Routine Description:

    Simulates the DirSearch API.

Arguments:

    pSearchArg          - Standard search arguments.
    ppSearchRes         - Standard search results.

Return Value:

    DIRERR_*.

--*/
{
    SEARCHRES *                     pSearchRes;
    PSIM_ENTRY                      pBase;

    BOOL                            bFirstFind;

    g_Statistics.DirSearchOps++;
    *ppSearchRes = pSearchRes = KCCSIM_THNEW (SEARCHRES);
    pSearchRes->CommRes.errCode = 0;

    pBase = KCCSimResolveName (pSearchArg->pObject, &pSearchRes->CommRes);

    if (pBase != NULL) {

        pSearchRes->baseProvided = FALSE;           // Ignored
        pSearchRes->bSorted = FALSE;                // Ignored
        pSearchRes->pBase = NULL;                   // Ignored
        pSearchRes->count = 0;
        pSearchRes->FirstEntInf.pNextEntInf = NULL;
        pSearchRes->FirstRangeInf.pNext = NULL;
        pSearchRes->pPartialOutcomeQualifier = NULL;// Ignored
        pSearchRes->PagedResult.fPresent = FALSE;   // Ignored
        pSearchRes->PagedResult.pRestart = NULL;   // Ignored
        bFirstFind = TRUE;
        // Call the recursive search.
        KCCSimDoSearch (
            pBase,
            pSearchArg->choice,
            pSearchArg->pFilter,
            pSearchArg->pSelection,
            pSearchArg->pSelectionRange,
            &bFirstFind,
            pSearchRes
            );

    }

    return pSearchRes->CommRes.errCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\state.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    state.c

ABSTRACT:

    Manages the server state table.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <attids.h>
#include <dsutil.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "state.h"

BOOL fNullUuid (const GUID *);
BOOL MtxSame (UNALIGNED MTX_ADDR *pmtx1, UNALIGNED MTX_ADDR *pmtx2);

/***

    The KCC often wants to know information about the state of another server
    (usually the site bridgehead.)  It obtains information about other servers
    in two ways: through errors returned by DsBindW, and through data returned
    by DsGetReplicaInfoW.

    In addition, the KCC relies on the repsFrom attributes stored on the local
    DSA.  This is a non-replicated attribute that is (potentially) different
    for every server in the enterprise.  Since KCCSim maintains only a single
    instance of the directory, this raises the potential for conflict if the
    user wishes to run multiple iterations of the KCC from different servers.

    Both problems are resolved by maintaining a global server state table.
    The server state table contains one entry for each server in the
    enterprise.  Each table entry contains a set of repsFrom attributes (one
    for each NC held by the given server) and supplementary information.
    Therefore, calls to DsBindW and DsGetReplicaInfoW simply retrieve data
    out of the server state table; and the potential conflict is resolved
    because each iteration of the KCC only modifies the repsFrom attributes
    corresponding to the current local DSA.

***/

// This structure represents a single repsFrom attribute.
struct _KCCSIM_REPS_FROM_ATT {
    PDSNAME                         pdnNC;
    PSIM_VALUE                      pValFirst;
};

//
// This structure represents a server state.
// pEntryNTDSSettings   - The NTDS Settings object of this server.
// ulBindError          - The error code to return if DsBindW is called
//                        on this server.
// ulNumNCs             - Number of NCs held by this server.
// aRepsFrom            - Array of repsFrom attributes of size ulNumNCs.
//
struct _KCCSIM_SERVER_STATE {
    PSIM_ENTRY                      pEntryNTDSSettings;
    ULONG                           ulBindError;
    ULONG                           ulNumNCs;
    struct _KCCSIM_REPS_FROM_ATT *  aRepsFrom;
};

ULONG                               g_ulNumServers;
struct _KCCSIM_SERVER_STATE *       g_aState = NULL;

VOID
KCCSimFreeStates (
    VOID
    )
/*++

Routine Description:

    Frees the entire state table.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PSIM_VALUE                      pValAt, pValNext;
    ULONG                           ulServer, ulNC;

    if (g_aState == NULL) {
        return;
    }

    for (ulServer = 0; ulServer < g_ulNumServers; ulServer++) {
        for (ulNC = 0; ulNC < g_aState[ulServer].ulNumNCs; ulNC++) {
            KCCSimFree (g_aState[ulServer].aRepsFrom[ulNC].pdnNC);
            pValAt = g_aState[ulServer].aRepsFrom[ulNC].pValFirst;
            while (pValAt != NULL) {
                pValNext = pValAt->next;
                KCCSimFree (pValAt->pVal);
                KCCSimFree (pValAt);
                pValAt = pValNext;
            }
        }
        KCCSimFree (g_aState[ulServer].aRepsFrom);
    }
    KCCSimFree (g_aState);
    g_aState = NULL;
}

VOID
KCCSimInitializeStates (
    VOID
    )
/*++

Routine Description:

    Initializes the state table.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ATTRTYP                         ncClass[2] = {
                                        ATT_HAS_MASTER_NCS,
                                        ATT_HAS_PARTIAL_REPLICA_NCS };

    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pValAt;

    ULONG                           ulServer, ulNCType, ulNC;
    PSIM_ENTRY *                    apEntryNTDSSettings;
    struct _KCCSIM_SERVER_STATE     state;

    KCCSimAllocGetAllServers (&g_ulNumServers, &apEntryNTDSSettings);
    g_aState = KCCSIM_NEW_ARRAY (struct _KCCSIM_SERVER_STATE, g_ulNumServers);

    for (ulServer = 0; ulServer < g_ulNumServers; ulServer++) {

        g_aState[ulServer].pEntryNTDSSettings = apEntryNTDSSettings[ulServer];
        g_aState[ulServer].ulBindError = 0;

        // How many NCs are there?
        g_aState[ulServer].ulNumNCs = 0;
        for (ulNCType = 0; ulNCType < 2; ulNCType++) {
            if (KCCSimGetAttribute (
                    apEntryNTDSSettings[ulServer],
                    ncClass[ulNCType],
                    &attRef
                    )) {
                for (pValAt = attRef.pAttr->pValFirst;
                     pValAt != NULL;
                     pValAt = pValAt->next) {
                    g_aState[ulServer].ulNumNCs++;
                }
            }
        }

        g_aState[ulServer].aRepsFrom = KCCSIM_NEW_ARRAY
            (struct _KCCSIM_REPS_FROM_ATT, g_aState[ulServer].ulNumNCs);

        ulNC = 0;
        for (ulNCType = 0; ulNCType < 2; ulNCType++) {
            if (KCCSimGetAttribute (
                    apEntryNTDSSettings[ulServer],
                    ncClass[ulNCType],
                    &attRef
                    )) {
                for (pValAt = attRef.pAttr->pValFirst;
                     pValAt != NULL;
                     pValAt = pValAt->next) {

                    Assert (ulNC < g_aState[ulServer].ulNumNCs);
                    g_aState[ulServer].aRepsFrom[ulNC].pdnNC =
                        KCCSimAlloc (pValAt->ulLen);
                    memcpy (
                        g_aState[ulServer].aRepsFrom[ulNC].pdnNC,
                        pValAt->pVal,
                        pValAt->ulLen
                        );
                    g_aState[ulServer].aRepsFrom[ulNC].pValFirst = NULL;
                    ulNC++;

                }
            }
        }
        Assert (ulNC == g_aState[ulServer].ulNumNCs);

    }

    KCCSimFree (apEntryNTDSSettings);
}

struct _KCCSIM_SERVER_STATE *
KCCSimServerStateOf (
    IN  const DSNAME *              pdnServer
    )
/*++

Routine Description:

    Retrieves the server state entry corresponding to a particular server.

Arguments:

    pdnServer           - The server whose state we want to retrieve.

Return Value:

    The corresponding state table entry.

--*/
{
    struct _KCCSIM_SERVER_STATE *   pState;
    ULONG                           ul;

    if (g_aState == NULL) {
        KCCSimInitializeStates ();
    }

    pState = NULL;
    for (ul = 0; ul < g_ulNumServers; ul++) {
        if (NameMatched (pdnServer, g_aState[ul].pEntryNTDSSettings->pdn)) {
            pState = &g_aState[ul];
            break;
        }
    }

    return pState;
}

struct _KCCSIM_REPS_FROM_ATT *
KCCSimRepsFromAttOf (
    IN  const DSNAME *              pdnServer,
    IN  const DSNAME *              pdnNC
    )
/*++

Routine Description:

    Retrieves the repsfrom attribute corresponding to a particular
    server in a particular NC.

Arguments:

    pdnServer           - The server whose repsfrom attribute we want.
    pdnNC               - The naming context.

Return Value:

    The corresponding repsfrom attribute.

--*/
{
    struct _KCCSIM_SERVER_STATE *   pState;
    struct _KCCSIM_REPS_FROM_ATT *  pRepsFromAtt;
    ULONG                           ul;

    pState = KCCSimServerStateOf (pdnServer);
    if (pState == NULL) {
        return NULL;
    }

    pRepsFromAtt = NULL;
    for (ul = 0; ul < pState->ulNumNCs; ul++) {
        if (NameMatched (pdnNC, pState->aRepsFrom[ul].pdnNC)) {
            pRepsFromAtt = &pState->aRepsFrom[ul];
            break;
        }
    }

    return pRepsFromAtt;
}

ULONG
KCCSimGetBindError (
    IN  const DSNAME *              pdnServer
    )
/*++

Routine Description:

    Publicized function to get the bind error associated with a server.

Arguments:

    pdnServer           - The DN of the server.

Return Value:

    The associated bind error.

--*/
{
    struct _KCCSIM_SERVER_STATE *   pState;

    pState = KCCSimServerStateOf (pdnServer);

    if (pState == NULL) {
        return NO_ERROR;
    } else {
        return pState->ulBindError;
    }
}   

BOOL
KCCSimSetBindError (
    IN  const DSNAME *              pdnServer,
    IN  ULONG                       ulBindError
    )
/*++

Routine Description:

    Publicized function to set the bind error associated with a server.

Arguments:

    pdnServer           - The DN of the server.
    ulBindError         - The bind error.

Return Value:

    TRUE if the error code could be set.
    FALSE if the specified server does not exist.

--*/
{
    struct _KCCSIM_SERVER_STATE *   pState;

    pState = KCCSimServerStateOf (pdnServer);
    
    if (pState == NULL) {
        return FALSE;
    } else {
        pState->ulBindError = ulBindError;
        return TRUE;
    }
}

BOOL
KCCSimMatchReplicaLink (
    IN  const REPLICA_LINK *        pReplicaLink,
    IN  const UUID *                puuidDsaObj OPTIONAL,
    IN  MTX_ADDR *                  pMtxAddr OPTIONAL
    )
/*++

Routine Description:

    Determines whether a REPLICA_LINK corresponds to a given
    source DSA.  Matches by UUID if puuidDsaObj is present;
    otherwise searches by MTX_ADDR.  One of puuidDsaObj or
    pMtxAddr must be non-NULL.

Arguments:

    pReplicaLink        - The replica link to match.
    puuidDsaObj         - Source DSA UUID to match by.
    pMtxAddr            - Source DSA address to match by.

Return Value:

    TRUE if the REPLICA_LINK matches.

--*/
{
    Assert (pReplicaLink != NULL);
    Assert ((puuidDsaObj != NULL) || (pMtxAddr != NULL));
    VALIDATE_REPLICA_LINK_VERSION (pReplicaLink);

    if (puuidDsaObj == NULL) {
        // Search by MTX_ADDR
        if (MtxSame (pMtxAddr, RL_POTHERDRA (pReplicaLink))) {
            return TRUE;
        }
    } else {
        // Search by UUID
        if (memcmp (puuidDsaObj, &pReplicaLink->V1.uuidDsaObj, sizeof (UUID)) == 0) {
            return TRUE;
        }
    }

    return FALSE;
}

REPLICA_LINK *
KCCSimExtractReplicaLink (
    IN  const DSNAME *              pdnServer,
    IN  const DSNAME *              pdnNC,
    IN  const UUID *                puuidDsaObj OPTIONAL,
    IN  MTX_ADDR *                  pMtxAddr OPTIONAL
    )
/*++

Routine Description:

    Removes a REPLICA_LINK from the state table.  The REPLICA_LINK
    may be referenced either by source DSA UUID or matrix address;
    one of them must be non-NULL.

Arguments:

    pdnServer           - The server whose repsfrom attribute we are accessing.
    pdnNC               - The naming context.
    puuidDsaObj         - UUID of the source DSA.
    pMtxAddr            - MTX_ADDR of the source DSA.

Return Value:

    The REPLICA_LINK that was removed.  It is the caller's responsibility
    to free this structure by calling KCCSimFree.

--*/
{
    struct _KCCSIM_REPS_FROM_ATT *  pRepsFromAtt;
    PSIM_VALUE                      pValAt, pValTemp;
    REPLICA_LINK *                  pReplicaLink;

    Assert (pdnServer != NULL);
    Assert (pdnNC != NULL);
    Assert ((puuidDsaObj != NULL) || (pMtxAddr != NULL));

    pRepsFromAtt = KCCSimRepsFromAttOf (pdnServer, pdnNC);
    Assert (pRepsFromAtt != NULL);
    if (pRepsFromAtt->pValFirst == NULL) {
        return NULL;
    }

    pReplicaLink = NULL;        // Default to NULL return value

    // Does the list head match?
    if (KCCSimMatchReplicaLink (
            (REPLICA_LINK *) pRepsFromAtt->pValFirst->pVal,
            puuidDsaObj,
            pMtxAddr
            )) {
        pReplicaLink = (REPLICA_LINK *) pRepsFromAtt->pValFirst->pVal;
        pValTemp = pRepsFromAtt->pValFirst;
        pRepsFromAtt->pValFirst = pRepsFromAtt->pValFirst->next;
        KCCSimFree (pValTemp);
    } else {
        // Search for the parent of the matching entry
        for (pValAt = pRepsFromAtt->pValFirst;
             pValAt != NULL && pValAt->next != NULL;
             pValAt = pValAt->next) {

            if (KCCSimMatchReplicaLink (
                    (REPLICA_LINK *) pValAt->next->pVal,
                    puuidDsaObj,
                    pMtxAddr
                    )) {
                pReplicaLink = (REPLICA_LINK *) pValAt->next->pVal;
                pValTemp = pValAt->next;
                pValAt->next = pValAt->next->next;
                KCCSimFree (pValTemp);
                break;
            }

        }
    }

    return pReplicaLink;
}

VOID
KCCSimInsertReplicaLink (
    IN  const DSNAME *              pdnServer,
    IN  const DSNAME *              pdnNC,
    IN  REPLICA_LINK *              pReplicaLink
    )
/*++

Routine Description:

    Inserts a REPLICA_LINK into the state table.  No allocation is
    performed; the caller should NOT free pReplicaLink afterward!

Arguments:

    pdnServer           - The server whose repsfrom attribute we are accessing.
    pdnNC               - The naming context.
    pReplicaLink        - The replica link to insert.

Return Value:

    None.

--*/
{
    struct _KCCSIM_REPS_FROM_ATT *  pRepsFromAtt;
    REPLICA_LINK *                  pReplicaLinkOld;
    PSIM_VALUE                      pNewVal;

    Assert (pReplicaLink != NULL);
    VALIDATE_REPLICA_LINK_VERSION (pReplicaLink);

    pRepsFromAtt = KCCSimRepsFromAttOf (pdnServer, pdnNC);
    Assert (pRepsFromAtt != NULL);

#if DBG
    // Check to make sure we don't already have this REPLICA_LINK!
    pReplicaLinkOld = KCCSimExtractReplicaLink (
        pdnServer,
        pdnNC,
        &pReplicaLink->V1.uuidDsaObj,
        NULL
        );
    Assert (pReplicaLinkOld == NULL);
    pReplicaLinkOld = KCCSimExtractReplicaLink (
        pdnServer,
        pdnNC,
        NULL,
        RL_POTHERDRA (pReplicaLink)
        );
    Assert (pReplicaLinkOld == NULL);
#endif

    pNewVal = KCCSIM_NEW (SIM_VALUE);
    pNewVal->ulLen = pReplicaLink->V1.cb;
    pNewVal->pVal = (PBYTE) pReplicaLink;
    pNewVal->next = pRepsFromAtt->pValFirst;
    pRepsFromAtt->pValFirst = pNewVal;
}

PSIM_VALUE
KCCSimGetRepsFroms (
    IN  const DSNAME *              pdnServer,
    IN  const DSNAME *              pdnNC
    )
{
    struct _KCCSIM_REPS_FROM_ATT *  pRepsFromAtt;

    pRepsFromAtt = KCCSimRepsFromAttOf (pdnServer, pdnNC);
    if (pRepsFromAtt == NULL) {
        return NULL;
    } else {
        return pRepsFromAtt->pValFirst;
    }
}

BOOL
KCCSimReportSync (
    IN  const DSNAME *              pdnServerTo,
    IN  const DSNAME *              pdnNC,
    IN  const DSNAME *              pdnServerFrom,
    IN  ULONG                       ulSyncError,
    IN  ULONG                       ulNumAttempts
    )
{
    PSIM_ENTRY                      pEntryServerFrom;
    REPLICA_LINK *                  pReplicaLink = NULL;
    DSTIME                          timeNow;

    Assert (pdnServerTo != NULL);
    Assert (pdnNC != NULL);
    Assert (pdnServerFrom != NULL);

    __try {

        if (KCCSimRepsFromAttOf (pdnServerTo, pdnNC) == NULL) {
            return FALSE;
        }

        // Find the from server in the directory so we're sure to have its guid
        pEntryServerFrom = KCCSimDsnameToEntry (pdnServerFrom, KCCSIM_NO_OPTIONS);
        Assert (pEntryServerFrom != NULL);
        pReplicaLink = KCCSimExtractReplicaLink (
            pdnServerTo,
            pdnNC,
            &pEntryServerFrom->pdn->Guid,
            NULL
            );

        if (pReplicaLink == NULL) {
            return FALSE;
        }

        if (ulNumAttempts == 0) {
            return TRUE;
        }

        timeNow = SimGetSecondsSince1601 ();

        pReplicaLink->V1.ulResultLastAttempt = ulSyncError;
        pReplicaLink->V1.timeLastAttempt = timeNow;
        if (ulSyncError == 0) {
            pReplicaLink->V1.timeLastSuccess = timeNow;
            pReplicaLink->V1.cConsecutiveFailures = 0;
        } else {
            pReplicaLink->V1.cConsecutiveFailures += ulNumAttempts;
        }

    } __finally {

        if (pReplicaLink != NULL) {
            KCCSimInsertReplicaLink (
                pdnServerTo,
                pdnNC,
                pReplicaLink
                );
        }

    }

    return TRUE;
}

RTL_GENERIC_COMPARE_RESULTS
NTAPI
KCCSimCompareFailures (
    IN  PRTL_GENERIC_TABLE          pTable,
    IN  PVOID                       pFirstStruct,
    IN  PVOID                       pSecondStruct
    )
/*++

Routine Description:

    Compares two DS_REPL_KCC_DSA_FAILUREW structures by source DSA UUID.

Arguments:

    pTable              - Not used.
    pFirstStruct        - The first structure to compare.
    pSecondStruct       - The second structure to compare.

Return Value:

    One of GenericLessThan, GenericEqual, or GenericGreaterThan.

--*/
{
    DS_REPL_KCC_DSA_FAILUREW *      pFirstFailure;
    DS_REPL_KCC_DSA_FAILUREW *      pSecondFailure;
    INT                             iCmp;
    RTL_GENERIC_COMPARE_RESULTS     result;

    pFirstFailure = (DS_REPL_KCC_DSA_FAILUREW *) pFirstStruct;
    pSecondFailure = (DS_REPL_KCC_DSA_FAILUREW *) pSecondStruct;

    iCmp = memcmp (
        &pFirstFailure->uuidDsaObjGuid,
        &pSecondFailure->uuidDsaObjGuid,
        sizeof (GUID)
        );

    if (iCmp < 0) {
        result = GenericLessThan;
    } else if (iCmp > 0) {
        result = GenericGreaterThan;
    } else {
        Assert (iCmp == 0);
        result = GenericEqual;
    }

    return result;
}

VOID
KCCSimUpdateFailureTable (
    IN  PRTL_GENERIC_TABLE          pTable,
    IN  REPLICA_LINK *              pReplicaLink
    )
/*++

Routine Description:

    Processes a REPLICA_LINK and updates the failure table if necessary.

Arguments:

    pTable              - The failure table to update.
    pReplicaLink        - The replica link to process.

Return Value:

    None.

--*/
{
    DS_REPL_KCC_DSA_FAILUREW        failure;
    DS_REPL_KCC_DSA_FAILUREW *      pFailure;

    PSIM_ENTRY                      pEntry;
    PDSNAME                         pdn;
    DSTIME                          dsTime;

    // If this replica link isn't a failure, do nothing.
    if (pReplicaLink->V1.cConsecutiveFailures == 0) {
        return;
    }

    memcpy (&failure.uuidDsaObjGuid, &pReplicaLink->V1.uuidDsaObj, sizeof (GUID));
    pFailure = RtlLookupElementGenericTable (pTable, &failure);

    // If this uuid isn't in the table yet, add it.
    if (pFailure == NULL) {

        // We need to know the DN; so we look for it in the directory.
        pdn = KCCSimAllocDsname (NULL);
        memcpy (&pdn->Guid, &failure.uuidDsaObjGuid, sizeof (GUID));
        pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
        KCCSimFree (pdn);
        pdn = NULL;
        Assert (pEntry != NULL);

        failure.pszDsaDN = pEntry->pdn->StringName;
        DSTimeToFileTime (
            pReplicaLink->V1.timeLastSuccess,
            &failure.ftimeFirstFailure
            );
        failure.cNumFailures = pReplicaLink->V1.cConsecutiveFailures;
        failure.dwLastResult = 0;   // This is what the KCC does . . .
        RtlInsertElementGenericTable (
            pTable,
            (PVOID) &failure,
            sizeof (DS_REPL_KCC_DSA_FAILUREW),
            NULL
            );

    } else {

        // This uuid is in the table.  So update with worst-case info
        FileTimeToDSTime (pFailure->ftimeFirstFailure, &dsTime);
        if (dsTime < pReplicaLink->V1.timeLastSuccess) {
            DSTimeToFileTime (
                pReplicaLink->V1.timeLastSuccess,
                &pFailure->ftimeFirstFailure
                );
        }
        if (pFailure->cNumFailures < pReplicaLink->V1.cConsecutiveFailures) {
            pFailure->cNumFailures = pReplicaLink->V1.cConsecutiveFailures;
        }

    }
}

DS_REPL_KCC_DSA_FAILURESW *
KCCSimGetDsaFailures (
    IN  const DSNAME *              pdnServer
    )
/*++

Routine Description:

    Builds and returns the failures cache for a particular server.
    This is a bit tricky.  Each server will have several NCs, but
    we only want to return one failure entry per source DSA.  In
    addition, if there are several failures for a single source DSA
    (spread over several NCs), we want to merge them into a
    "worst-case" scenario (in the same way the real KCC builds its
    failure cache.)  We do this by building an RTL_GENERIC_TABLE
    that maps source DSA UUIDs to DS_REPLICA_KCC_DSA_FAILUREWs.  We
    then serialize this table into the return structure.

Arguments:

    pdnServer           - The server whose failures we want.

Return Value:

    The corresponding failures cache.

--*/
{
    DS_REPL_KCC_DSA_FAILURESW *     pDsaFailures = NULL;
    RTL_GENERIC_TABLE               tableFailures;
    ULONG                           cbDsaFailures;
    PVOID                           p;

    struct _KCCSIM_SERVER_STATE *   pState;
    REPLICA_LINK *                  pReplicaLink;
    PSIM_VALUE                      pValAt;
    ULONG                           ulNC, ulNumFailures, ul;

    __try {

        pState = KCCSimServerStateOf (pdnServer);
        if (pState == NULL) {
            return NULL;
        }

        RtlInitializeGenericTable (
            &tableFailures,
            KCCSimCompareFailures,
            KCCSimTableAlloc,
            KCCSimTableFree,
            NULL
            );

        for (ulNC = 0; ulNC < pState->ulNumNCs; ulNC++) {
            for (pValAt = pState->aRepsFrom[ulNC].pValFirst;
                 pValAt != NULL;
                 pValAt = pValAt->next) {

                pReplicaLink = (REPLICA_LINK *) pValAt->pVal;
                KCCSimUpdateFailureTable (
                    &tableFailures,
                    pReplicaLink
                    );

            }
        }

        ulNumFailures = RtlNumberGenericTableElements (&tableFailures);
        cbDsaFailures = offsetof (DS_REPL_KCC_DSA_FAILURESW, rgDsaFailure[0]) +
                        (sizeof (DS_REPL_KCC_DSA_FAILUREW) * ulNumFailures);
        pDsaFailures = KCCSimAlloc (cbDsaFailures);
        pDsaFailures->cNumEntries = ulNumFailures;
        pDsaFailures->dwReserved = 0;
        
        ul = 0;
        for (p = RtlEnumerateGenericTable (&tableFailures, TRUE);
             p != NULL;
             p = RtlEnumerateGenericTable (&tableFailures, FALSE)) {

            Assert (ul < ulNumFailures);
            memcpy (
                &pDsaFailures->rgDsaFailure[ul],
                p,
                sizeof (DS_REPL_KCC_DSA_FAILUREW)
                );
            ul++;

        }
        Assert (ul == ulNumFailures);

    } __finally {
    
        if (AbnormalTermination ()) {
            KCCSimFree (pDsaFailures);
        }
        
    }

    return pDsaFailures;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\user.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    user.h

ABSTRACT:

    Header file for user.c.  Also contains the main
    routines from buildcfg.c and runkcc.cxx.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

//
// The following are character IDs for the option flags.
// These are used by the routines in user.c to display the options associated
// with each object, and by buildcfg.c to specify object options.
//

#define KCCSIM_CID_NTDSDSA_OPT_IS_GC                                        L'G'
#define KCCSIM_CID_NTDSDSA_OPT_DISABLE_INBOUND_REPL                         L'I'
#define KCCSIM_CID_NTDSDSA_OPT_DISABLE_OUTBOUND_REPL                        L'O'
#define KCCSIM_CID_NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE                       L'X'
#define KCCSIM_CID_EXPLICIT_BRIDGEHEAD                                      L'B'
#define KCCSIM_CID_NTDSCONN_OPT_IS_GENERATED                                L'G'
#define KCCSIM_CID_NTDSCONN_OPT_TWOWAY_SYNC                                 L'2'
#define KCCSIM_CID_NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT                     L'O'
#define KCCSIM_CID_NTDSCONN_OPT_USE_NOTIFY                                  L'N'
#define KCCSIM_CID_NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED               L'A'
#define KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED                L'C'
#define KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED               L'M'
#define KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED           L'S'
#define KCCSIM_CID_NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED    L'I'
#define KCCSIM_CID_NTDSTRANSPORT_OPT_IGNORE_SCHEDULES                       L'S'
#define KCCSIM_CID_NTDSTRANSPORT_OPT_BRIDGES_REQUIRED                       L'B'
#define KCCSIM_CID_NTDSSITELINK_OPT_USE_NOTIFY                              L'N'
#define KCCSIM_CID_NTDSSITELINK_OPT_TWOWAY_SYNC                             L'2'

// From user.c

VOID
KCCSimDumpDirectory (
    LPCWSTR                     pwszStartDn
    );

VOID
KCCSimDisplayServer (
    VOID
    );

VOID
KCCSimDisplayConfigInfo (
    VOID
    );

VOID
KCCSimDisplayGraphInfo (
    VOID
    );

// From buildcfg.c

VOID
BuildCfg (
    LPCWSTR                     pwszFnIn
    );

// From runkcc.cxx

VOID
KCCSimRunKcc (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\util.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    util.c

ABSTRACT:

    Contains a bunch of quick, useful utilities.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <dsevent.h>
#include <debug.h>
#include <ismapi.h>
#include <taskq.h>
#include "util.h"
#include "schmap.h"

#define                             ERROR_BUF_LEN 4096

HINSTANCE                           hNtdsMsg = NULL;

WCHAR                               g_wszExceptionMsg[ERROR_BUF_LEN];
BOOL                                g_bQuiet = FALSE;
FILE *                              g_pFileLog = NULL;
ULONG                               g_ulDebugLevel = 0;
ULONG                               g_ulEventLevel = 0;
KCCSIM_STATISTICS                   g_Statistics;
HANDLE                              g_ThreadHeap = NULL;
BOOL                                gfIsTqRunning = TRUE;

// Function prototypes - ISM simulation library - private APIs

LPVOID
KCCSimAlloc (
    IN  ULONG                       ulSize
    );

VOID
KCCSimFree (
    IN  LPVOID                      p
    );

DWORD
SimI_ISMGetTransportServers (
    IN  HANDLE                      hIsm,
    IN  LPCWSTR                     pszSiteDN,
    OUT ISM_SERVER_LIST **          ppServerList
    );

DWORD
SimI_ISMGetConnectionSchedule (
    IN  HANDLE                      hIsm,
    IN  LPCWSTR                     pszSite1DN,
    IN  LPCWSTR                     pszSite2DN,
    OUT ISM_SCHEDULE **             ppSchedule
    );

DWORD
SimI_ISMGetConnectivity (
    IN  LPCWSTR                     pszTransportDN,
    OUT ISM_CONNECTIVITY **         ppConnectivity
    );

DWORD
SimI_ISMFree (
    IN  VOID *                      pv
    );

VOID
KCCSimQuiet (
    IN  BOOL                        bQuiet
    )
/*++

Routine Description:

    Turns quiet mode on and off.  In quiet mode, only error
    messages are printed.

Arguments:

    bQuiet              - TRUE to enable quiet mode,
                          FALSE to disable quiet mode.

Return Value:

    None.

--*/
{
    g_bQuiet = bQuiet;
}

DWORD
KCCSimHandleException (
    IN  const EXCEPTION_POINTERS *  pExceptPtrs,
    OUT PDWORD                      pdwErrType OPTIONAL,
    OUT PDWORD                      pdwErrCode OPTIONAL
    )
/*++

Routine Description:

    Extracts information from an EXCEPTION_POINTERS structure
    about an exception fired by KCCSim.  

Arguments:

    pExceptPtrs         - A valid EXCEPTION_POINTERS structure
    pdwErrType          - OPTIONAL.  Pointer to a DWORD to hold
                          the error type of the exception.
                          (e.g. KCCSIM_ETYPE_WIN32)
    pdwErrCode          - OPTIONAL.  Pointer to a DWORD to hold
                          the error code of the exception.
                          (e.g. ERROR_NOT_ENOUGH_MEMORY)

Return Value:

    If this was a KCCSIM_EXCEPTION, returns EXCEPTION_EXECUTE_HANDLER
    and fills pdwErrType and pdwErrCode, if present, with the
    appropriate values.  Otherwise, returns EXCEPTION_CONTINUE_SEARCH
    and fills pdwErrType and pdwErrCode, if present, with the value 0.

--*/
{
    Assert (pExceptPtrs != NULL);

    if (pExceptPtrs->ExceptionRecord->ExceptionCode == KCCSIM_EXCEPTION) {
        Assert (pExceptPtrs->ExceptionRecord->NumberParameters == 2);
        if (pdwErrType != NULL) {
            *pdwErrType = (DWORD) pExceptPtrs->ExceptionRecord->ExceptionInformation[0];
        }
        if (pdwErrCode != NULL) {
            *pdwErrCode = (DWORD) pExceptPtrs->ExceptionRecord->ExceptionInformation[1];
        }
        return EXCEPTION_EXECUTE_HANDLER;
    } else {
        if (pdwErrType != NULL) {
            *pdwErrType = 0;
        }
        if (pdwErrCode != NULL) {
            *pdwErrCode = 0;
        }
        return EXCEPTION_CONTINUE_SEARCH;
    }
}

LPCWSTR
KCCSimVaMsgToString (
    IN  DWORD                       dwErrorType,
    IN  DWORD                       dwMessageCode,
    IN  va_list *                   pArguments
    )
/*++

Routine Description:

    Retrieves the string associated with a given error type
    and message code.

Arguments:

    dwErrorType         - The error type.  (KCCSIM_ETYPE_*)
    dwMessageCode       - The message code.
                          (e.g. ERROR_NOT_ENOUGH_MEMORY or
                                KCCSIM_MSG_DID_RUN_KCC)
    pArguments          - Pointer to a list of arguments to substitute.

Return Value:

    The associated string.

--*/
{
    static WCHAR                    szError[ERROR_BUF_LEN];

    switch (dwErrorType) {

        case KCCSIM_ETYPE_WIN32:
            if (FormatMessageW (
                        FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        dwMessageCode,
                        GetSystemDefaultLangID (),
                        szError,
                        ERROR_BUF_LEN,
                        pArguments) != NO_ERROR) {
                Assert (wcslen (szError) >= 2);
                szError[wcslen (szError) - 2] = '\0';   // Remove \r\n
            } else {
                swprintf (szError, L"Win32 error %d occurred.", dwMessageCode);
            }
            break;

        case KCCSIM_ETYPE_INTERNAL:
            if (FormatMessageW (
                FORMAT_MESSAGE_FROM_HMODULE,
                NULL,
                dwMessageCode,
                GetSystemDefaultLangID (),
                szError,
                ERROR_BUF_LEN,
                pArguments) != NO_ERROR) {
                Assert (wcslen (szError) >= 2);
                szError[wcslen (szError) - 2] = '\0';   // Remove \r\n
            } else {
                swprintf (szError, L"KCCSim internal error %d occurred. (%d)",
                        dwMessageCode, GetLastError() );
            }
            break;

        default:
            swprintf (szError, L"Unrecognized error type.");
            break;

    }

    return szError;
}

LPCWSTR
KCCSimMsgToString (
    IN  DWORD                       dwErrType,
    IN  DWORD                       dwMessageCode,
    ...
    )
/*++

Routine Description:

    Public version of KCCSimVaMsgToString.

Arguments:

    dwErrType           - The error type.
    dwMessageCode       - The message code.
    ...                 - Optional arguments.

Return Value:

    The associated string.

--*/
{
    LPCWSTR                         pwsz;
    va_list                         arguments;

    va_start (arguments, dwMessageCode);
    pwsz = KCCSimVaMsgToString (dwErrType, dwMessageCode, &arguments);
    va_end (arguments);

    return pwsz;
}

VOID
KCCSimPrintMessage (
    IN  DWORD                       dwMessageCode,
    ...
    )
/*++

Routine Description:

    Prints a message with optional arguments.
    Has no effect in quiet mode.

Arguments:

    dwMessageCode       - The message code.
    ...                 - Optional arguments.

Return Value:

    None.

--*/
{
    LPCWSTR                         pwszStr;
    va_list                         arguments;

    va_start (arguments, dwMessageCode);
    pwszStr = KCCSimVaMsgToString (KCCSIM_ETYPE_INTERNAL, dwMessageCode, &arguments);
    va_end (arguments);
    if (!g_bQuiet) {
        wprintf (L"%s\n", pwszStr);
    }
    if (g_pFileLog!=NULL && g_pFileLog!=stdout) {
        fwprintf (g_pFileLog, L"\n%s\n", pwszStr);
    }
}

VOID
KCCSimException (
    IN  DWORD                       dwErrType,
    IN  DWORD                       dwErrCode,
    ...
    )
/*++

Routine Description:

    Raises an exception of class KCCSIM_EXCEPTION.  Also
    fills the global buffer g_wszExceptionMsg with the
    associated error message.

Arguments:

    dwErrType           - The error type.
    dwErrCode           - The error code.
    ...                 - Optional arguments to substitute within
                          the associated error message.

Return Value:

    None.

--*/
{
    // We use static data to avoid allocating any additional memory
    // at this point.
    static ULONG_PTR                ulpErr[2];
    static va_list                  arguments;

    va_start (arguments, dwErrCode);
    wcscpy (
        g_wszExceptionMsg,
        KCCSimVaMsgToString (dwErrType, dwErrCode, &arguments)
        );
    va_end (arguments);
    ulpErr[0] = dwErrType;
    ulpErr[1] = dwErrCode;

    RaiseException (
        KCCSIM_EXCEPTION,
        EXCEPTION_NONCONTINUABLE,
        2,
        ulpErr);
}

VOID
KCCSimPrintExceptionMessage (
    VOID
    )
/*++

Routine Description:

    Prints the message associated with the last call to
    KCCSimException.

Arguments:

    None.

Return Value:

    None.

--*/
{
    wprintf (L"%s\n", g_wszExceptionMsg);
}

VOID
KCCSimSetDebugLog (
    IN  LPCWSTR                     pwszFn OPTIONAL,
    IN  ULONG                       ulDebugLevel,
    IN  ULONG                       ulEventLevel
    )
/*++

Routine Description:

    Opens a debug log.

Arguments:

    pwszFn              - The filename to open.  If NULL, closes the
                          existing log and does not open a new one.

    ulDebugLevel        - Maximum debugging verbosity
    ulEventLevel        - Maximum event log verbosity

Return Value:

    None.

--*/
{
    // Close the existing log, if present
    if (g_pFileLog != NULL &&
        g_pFileLog != stdin &&
        g_pFileLog != stdout ) {
        KCCSIM_CHKERR (fclose (g_pFileLog));
    }

    if (pwszFn == NULL || pwszFn[0] == L'\0') {
        // If the message resource library is open, free it
        if (hNtdsMsg != NULL) {
            if (FreeLibrary (hNtdsMsg) == 0) {
                KCCSimException (
                    KCCSIM_ETYPE_WIN32,
                    GetLastError ()
                    );
            }
            hNtdsMsg = NULL;
        }
        return;
    }

    // Open the file log
    if( wcscmp(pwszFn, L"stdout")==0 ) {
        g_pFileLog = stdout;
    } else {
        g_pFileLog = _wfopen (pwszFn, L"wt");
    }
    if (g_pFileLog == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_WIN32,
            GetLastError ()
            );
    }

    // Set the debug level
    g_ulDebugLevel = ulDebugLevel;
    g_ulEventLevel = ulEventLevel;

    // Open the message resource library if it isn't open already
    if (hNtdsMsg == NULL) {
        hNtdsMsg = LoadLibraryExW (
            L"ntdsmsg",
            NULL,
            LOAD_LIBRARY_AS_DATAFILE
            );
        if (hNtdsMsg == NULL) {
            KCCSimException (
                KCCSIM_ETYPE_WIN32,
                GetLastError ()
                );
        }
    }
}

VOID
KCCSimDbgLog (
    IN  ULONG                       ulLevel,
    IN  LPCSTR                      pszFormat,
    ...
    )
/*++

Routine Description:

    Logs a debug message.  If no debug log is currently open, this
    function has no effect.

Arguments:

    ulLevel             - Debug level of the message.
    pszFormat           - printf-style format string.
    ...                 - Optional arguments.

Return Value:

    None.

--*/
{
    va_list                         arguments;
    static long                     lastTime=0;
    unsigned long                   curTime;
    time_t                          tempTime;

    if (g_pFileLog == NULL) {
        if (ulLevel == 0) {
            // Always count level zero debug messages
            g_Statistics.DebugMessagesEmitted++;
        }
        return;
    }

    va_start (arguments, pszFormat);
    if (ulLevel <= g_ulDebugLevel) {
        time( &tempTime );
        curTime = (long) tempTime;
        
        g_Statistics.DebugMessagesEmitted++;
        fprintf (g_pFileLog, "[%d] ", ulLevel);
        fprintf (g_pFileLog, "[%4d] ", lastTime ? curTime-lastTime : 0 );
        vfprintf (g_pFileLog, pszFormat, arguments);

        lastTime = curTime;
    }
    va_end (arguments);

}

VOID
KCCSimEventLog (
    IN  ULONG                       ulCategory,
    IN  ULONG                       ulSeverity,
    IN  DWORD                       dwMessageId,
    ...
    )
/*++

Routine Description:

    Logs an event.  If no debug log is currently open, this
    function has no effect.

Arguments:

    ulCategory          - The event category.
    ulSeverity          - The event severity.
    dwMessageId         - The event message ID from the ntdsmsg.dll resource.
    ...                 - Optional string-valued arguments.

Return Value:

    None.

--*/
{
    va_list                         arguments;
    LPWSTR                          pwszBuf;
    CHAR                            cid, fSimAlloc=FALSE;

    g_Statistics.LogEventsCalled++;
    if (ulSeverity > g_ulEventLevel) {
        return;
    }
    g_Statistics.LogEventsEmitted++;
    if (g_pFileLog == NULL) {
        return;
    }

    // If a file log is open, the message resource file
    // must be loaded.
    Assert (hNtdsMsg != NULL);

    va_start (arguments, dwMessageId);
    if (FormatMessageW (
            FORMAT_MESSAGE_FROM_HMODULE |
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_MAX_WIDTH_MASK,
            hNtdsMsg,
            dwMessageId,
            GetSystemDefaultLangID (),
            (LPWSTR) &pwszBuf,
            0,
            &arguments
            ) == 0) {
        pwszBuf = KCCSimAlloc(64 * sizeof(WCHAR));
        fSimAlloc = TRUE;
        swprintf( pwszBuf, L"LogEvent: message id 0x%x not found.", dwMessageId );
    }
    va_end (arguments);

    switch (ulSeverity) {
        case DS_EVENT_SEV_ALWAYS:     cid = 'A'; break;
        case DS_EVENT_SEV_MINIMAL:    cid = 'M'; break;
        case DS_EVENT_SEV_BASIC:      cid = 'B'; break;
        case DS_EVENT_SEV_EXTENSIVE:  cid = 'E'; break;
        case DS_EVENT_SEV_VERBOSE:    cid = 'V'; break;
        case DS_EVENT_SEV_INTERNAL:   cid = 'I'; break;
        case DS_EVENT_SEV_NO_LOGGING: cid = 'N'; break;
        default:                      cid = '?'; break;
    }

    fprintf (g_pFileLog, "[%c] %ls\n", cid, pwszBuf);
    if( fSimAlloc ) {
        KCCSimFree(pwszBuf);
    } else {
        LocalFree(pwszBuf);
    }
}

LPVOID
KCCSimAlloc (
    IN  ULONG                       ulSize
    )
/*++

Routine Description:

    Allocates memory. This memory is initialized to zero.

Arguments:

    ulSize              - Amount of memory to allocate.

Return Value:

    A pointer to the allocated memory buffer.  Note that KCCSimAlloc
    will never return NULL; if there is an error, it will raise an
    exception.

--*/
{
    LPVOID                          p;

    if ((p = LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT,ulSize)) == NULL) {
        printf( "Memory allocation failure - failed to allocate %d bytes.\n", ulSize );
        KCCSimException (KCCSIM_ETYPE_WIN32, GetLastError ());
    }

    g_Statistics.SimBytesTotalAllocated += ulSize;
    g_Statistics.SimBytesOutstanding += ulSize;
    if (g_Statistics.SimBytesOutstanding > g_Statistics.SimBytesMaxOutstanding) {
        g_Statistics.SimBytesMaxOutstanding = g_Statistics.SimBytesOutstanding;
    }

    return p;
}

LPVOID
KCCSimReAlloc (
    IN  LPVOID                      pOld,
    IN  ULONG                       ulSize
    )
/*++

Routine Description:

    Reallocates memory.

Arguments:

    pOld                - An existing block of memory.
    ulSize              - Size of the new block of memory.

Return Value:

    A pointer to the reallocated block of memory.

--*/
{
    LPVOID                          pNew;
    DWORD                           oldSize;

    Assert( pOld );

    oldSize = (DWORD) LocalSize( pOld );
    g_Statistics.SimBytesOutstanding -= oldSize;
    g_Statistics.SimBytesTotalAllocated -= oldSize;

    if ((pNew = LocalReAlloc (pOld, ulSize, LMEM_ZEROINIT)) == NULL) {
        printf( "Memory allocation failure - failed to reallocate %d bytes.\n", ulSize );
        KCCSimException (KCCSIM_ETYPE_WIN32, GetLastError ());
    }

    g_Statistics.SimBytesTotalAllocated += ulSize;
    g_Statistics.SimBytesOutstanding += ulSize;
    if (g_Statistics.SimBytesOutstanding > g_Statistics.SimBytesMaxOutstanding) {
        g_Statistics.SimBytesMaxOutstanding = g_Statistics.SimBytesOutstanding;
    }

    return pNew;
}

VOID
KCCSimFree (
    IN  LPVOID                      p
    )
/*++

Routine Description:

    Frees memory.  KCCSimFree (NULL) has no effect.

Arguments:

    p                   - The block of memory to free.

Return Value:

    None.

--*/
{
    DWORD oldSize;

    if (p != NULL) {
        oldSize = (DWORD) LocalSize( p );
        LocalFree( p );
        g_Statistics.SimBytesOutstanding -= oldSize;
    }
}


DWORD
KCCSimThreadCreate(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    void - 

Return Value:

    DWORD - 

--*/

{
#define INITIAL_HEAP_SIZE (16 * 1024 * 1024)
    if (g_ThreadHeap) {
        Assert( FALSE );
        KCCSimException (KCCSIM_ETYPE_WIN32, ERROR_INVALID_PARAMETER);
    }

    g_ThreadHeap = HeapCreate( 0, INITIAL_HEAP_SIZE, 0 );
    if (g_ThreadHeap) {
        return 0;
    } else {
        KCCSimException (KCCSIM_ETYPE_WIN32, GetLastError ());
        return 1;
    }
} /* KCCSimThreadCreate */


VOID
KCCSimThreadDestroy(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    void - 

Return Value:

    None

--*/

{
    if (!g_ThreadHeap) {
        Assert( FALSE );
        return;
    }
    if (!HeapDestroy( g_ThreadHeap )) {
        KCCSimException (KCCSIM_ETYPE_WIN32, GetLastError ());
    }
    g_ThreadHeap = NULL;
} /* KCCSimThreadDestroy */

LPVOID
KCCSimThreadAlloc (
    IN  ULONG                       ulSize
    )
/*++

Routine Description:

    Allocates memory.

Arguments:

    ulSize              - Amount of memory to allocate.

Return Value:

    A pointer to the allocated memory buffer.  Note that KCCSimAlloc
    will never return NULL; if there is an error, it will raise an
    exception.

--*/
{
    LPVOID                          p;

    Assert( g_ThreadHeap );

    if ((p = HeapAlloc( g_ThreadHeap, HEAP_ZERO_MEMORY, ulSize)) == NULL) {
        printf( "Memory allocation failure - failed to allocate %d bytes.\n", ulSize );
        KCCSimException (KCCSIM_ETYPE_WIN32, GetLastError ());
    }

    g_Statistics.ThreadBytesTotalAllocated += ulSize;
    g_Statistics.ThreadBytesOutstanding += ulSize;
    if (g_Statistics.ThreadBytesOutstanding > g_Statistics.ThreadBytesMaxOutstanding) {
        g_Statistics.ThreadBytesMaxOutstanding = g_Statistics.ThreadBytesOutstanding;
    }

    return p;
}

LPVOID
KCCSimThreadReAlloc (
    IN  LPVOID                      pOld,
    IN  ULONG                       ulSize
    )
/*++

Routine Description:

    Reallocates memory.

Arguments:

    pOld                - An existing block of memory.
    ulSize              - Size of the new block of memory.

Return Value:

    A pointer to the reallocated block of memory.

--*/
{
    LPVOID                          pNew;
    DWORD                           oldSize;

    Assert( g_ThreadHeap );
    Assert( pOld );

    oldSize = (DWORD) HeapSize( g_ThreadHeap, 0, pOld );
    Assert( oldSize != 0xffffffff );
    g_Statistics.ThreadBytesOutstanding -= oldSize;
    g_Statistics.ThreadBytesTotalAllocated -= oldSize;

    if ((pNew = HeapReAlloc( g_ThreadHeap, HEAP_ZERO_MEMORY, pOld, ulSize)) == NULL) {
        printf( "Memory allocation failure - failed to reallocate %d bytes.\n", ulSize );
        KCCSimException (KCCSIM_ETYPE_WIN32, GetLastError ());
    }

    g_Statistics.ThreadBytesTotalAllocated += ulSize;
    g_Statistics.ThreadBytesOutstanding += ulSize;
    if (g_Statistics.ThreadBytesOutstanding > g_Statistics.ThreadBytesMaxOutstanding) {
        g_Statistics.ThreadBytesMaxOutstanding = g_Statistics.ThreadBytesOutstanding;
    }

    return pNew;
}

VOID
KCCSimThreadFree (
    IN  LPVOID                      p
    )
/*++

Routine Description:

    Frees memory.  KCCSimFree (NULL) has no effect.

Arguments:

    p                   - The block of memory to free.

Return Value:

    None.

--*/
{
    DWORD ret, oldSize;

    Assert( g_ThreadHeap );

    if (p != NULL) {
        oldSize = (DWORD) HeapSize( g_ThreadHeap, 0, p );
        Assert( oldSize != 0xffffffff );

        if (!HeapFree( g_ThreadHeap, 0, p )) {
            KCCSimException (KCCSIM_ETYPE_WIN32, GetLastError ());
        }
        g_Statistics.ThreadBytesOutstanding -= oldSize;
    }
}

PVOID
KCCSimTableAlloc (
    IN  RTL_GENERIC_TABLE *         pTable,
    IN  CLONG                       ByteSize
    )
//
// This is just a wrapper for use by RTL_GENERIC_TABLEs.
//
{
    return KCCSimAlloc (ByteSize);
}

VOID
KCCSimTableFree (
    IN  RTL_GENERIC_TABLE *         pTable,
    IN  PVOID                       Buffer
    )
//
// This is just a wrapper for use by RTL_GENERIC_TABLEs.
//
{
    KCCSimFree (Buffer);
}

BOOL
KCCSimParseCommand (
    IN  LPCWSTR                     pwsz,
    IN  ULONG                       ulArg,
    IO  LPWSTR                      pwszBuf
    )
/*++

Routine Description:

    Retrieves a single argument from an arbitrary command of
    the form:
    arg0 arg1 "quoted arg2" arg3 ...

Arguments:

    pwsz                - The command line.
    ulArg               - The argument number to retrieve
                          (starting with 0)
    pwszBuf             - A preallocated buffer that will hold
                          the parsed argument.  To be safe, it
                          should be at least as long as
                          wcslen (pwsz).  If there are fewer than
                          ulArg+1 arguments, this will hold the
                          string L"\0".

Return Value:

    TRUE if the command line is properly formatted.
    FALSE if the command line contains an odd number of quotes.

--*/
{
    BOOL                            bIsInQuotes;
    ULONG                           ul;

    bIsInQuotes = FALSE;

    for (ul = 0; ul < ulArg; ul++) {

        // Skip past any white space
        while (*pwsz == L' ') {
            pwsz++;
        }

        // Skip past this command
        while (    (*pwsz != L'\0')
                && (*pwsz != L' ' || bIsInQuotes)) {
            if (*pwsz == L'\"') {
                bIsInQuotes = !bIsInQuotes;
            }
            pwsz++;
        }

    }

    if (!bIsInQuotes) {

        // Skip past any white space
        while (*pwsz == L' ') {
            pwsz++;
        }

        // Copy this command into the buffer
        while (    (*pwsz != L'\0')
                && (*pwsz != L' ' || bIsInQuotes)) {
            if (*pwsz == L'\"') {
                bIsInQuotes = !bIsInQuotes;
            } else {
                *pwszBuf = *pwsz;
                pwszBuf++;
            }
            pwsz++;
        }

    }

    *pwszBuf = L'\0';
    // Return true unless we stopped inside quotes
    return (!bIsInQuotes);
}

LPWSTR
KCCSimAllocWideStr (
    IN  UINT                        CodePage,
    IN  LPCSTR                      psz
    )
/*++

Routine Description:

    Converts a narrow string to a wide string.

Arguments:

    CodePage            - The code page to use.
    psz                 - The narrow string.

Return Value:

    The allocated wide string.  Never returns NULL.

--*/
{
    LPWSTR                          pwsz;
    ULONG                           cb;

    cb = MultiByteToWideChar (
        CodePage,
        0,
        psz,
        -1,
        NULL,
        0
        );
    if (0 == cb) {
        KCCSimException (
            KCCSIM_ETYPE_WIN32,
            GetLastError ()
            );
    }

    pwsz = KCCSimAlloc ((sizeof (WCHAR)) * (1 + cb));

    cb = MultiByteToWideChar (
        CodePage,
        0,
        psz,
        -1,
        pwsz,
        cb
        );
    if (0 == cb) {
        KCCSimException (
            KCCSIM_ETYPE_WIN32,
            GetLastError ()
            );
    }

    pwsz[cb] = 0;
    return pwsz;
}

LPSTR
KCCSimAllocNarrowStr (
    IN  UINT                        CodePage,
    IN  LPCWSTR                     pwsz
    )
/*++

Routine Description:

    Converts a wide string to a narrow string.

Arguments:

    CodePage            - The code page to use.
    pwsz                - The wide string.

Return Value:

    The allocated narrow string.  Never returns NULL.

--*/
{
    LPSTR                           psz;
    ULONG                           cb;

    cb = WideCharToMultiByte (
        CodePage,
        0,
        pwsz,
        -1,
        NULL,
        0,
        NULL,
        NULL
        );

    psz = KCCSimAlloc (cb);

    cb = WideCharToMultiByte (
        CodePage,
        0,
        pwsz,
        -1,
        psz,
        cb,
        NULL,
        NULL
        );
    if (0 == cb) {
        KCCSimException (
            KCCSIM_ETYPE_WIN32,
            GetLastError ()
            );
    }

    return psz;
}

PDSNAME
KCCSimAllocDsname (
    IN  LPCWSTR                     pwszDn OPTIONAL
    )
/*++

Routine Description:

    Creates a DSNAME structure with a given StringName.
    The GUID and SID are left blank.

Arguments:

    pwszDn              - The string name.  If NULL, creates a
                          DSNAME with a 0-length StringName.

Return Value:

    The allocated DSNAME.  Never returns NULL.

--*/
{
    PDSNAME                         pdn;
    ULONG                           ulNameLen;

    if (pwszDn == NULL) {
        ulNameLen = 0;
    } else {
        ulNameLen = wcslen (pwszDn);
    }

    pdn = (PDSNAME) KCCSimAlloc (DSNameSizeFromLen (ulNameLen));
    pdn->structLen = DSNameSizeFromLen (ulNameLen);
    pdn->SidLen = 0;
    pdn->NameLen = ulNameLen;

    if (pwszDn == NULL) {
        pdn->StringName[0] = '\0';
    } else {
        wcscpy (pdn->StringName, pwszDn);
    }

    return pdn;
}

PDSNAME
KCCSimAllocDsnameFromNarrow (
    IN  LPCSTR                      pszDn OPTIONAL
    )
/*++

Routine Description:

    Same as KCCSimAllocDsname, but accepts a narrow
    string as parameter.

Arguments:

    pszDn               - The string name.  If NULL, creates a
                          DSNAME with a 0-length StringName.

Return Value:

    The allocated DSNAME.  Never returns NULL.

--*/
{
    PDSNAME                   pdn;
    WCHAR                    *wszBuf;

    if (pszDn == NULL) {
        return KCCSimAllocDsname (NULL);
    } else {
        wszBuf = (WCHAR*) KCCSimAlloc((strlen(pszDn)+1)*sizeof(WCHAR));
        if (MultiByteToWideChar (
                CP_ACP,
                0,
                pszDn,
                1 + strlen (pszDn),
                wszBuf,
                1 + strlen (pszDn)
                ) == 0) {
            KCCSimException (
                KCCSIM_ETYPE_WIN32,
                GetLastError ()
                );
        }

        pdn = KCCSimAllocDsname (wszBuf);
        KCCSimFree( wszBuf );
        return pdn;
    }
}

LPWSTR
KCCSimQuickRDNOf (
    IN  const DSNAME *              pdn,
    IO  LPWSTR                      pwszBuf
    )
/*++

Routine Description:

    Retrieves the RDN of a DSNAME.

Arguments:

    pdn                 - The full DSNAME.
    pwszBuf             - A preallocated buffer of length MAX_RDN_SIZE
                          that will hold the corresponding RDN.

Return Value:

    Always returns pwszBuf.

--*/
{
    ULONG                           ulLen;
    ATTRTYP                         attrTyp;

    KCCSIM_CHKERR (GetRDNInfoExternal (
        pdn,
        pwszBuf,
        &ulLen,
        &attrTyp
        ));

    pwszBuf[ulLen] = '\0';
    return pwszBuf;
}

LPWSTR
KCCSimQuickRDNBackOf (
    IN  const DSNAME *              pdn,
    IN  ULONG                       ulBackBy,
    IO  LPWSTR                      pwszBuf
    )
/*++

Routine Description:

    Retrieves the RDN of an ancestor of a DSNAME.

Arguments:

    pdn                 - The full DSNAME.
    ulBackBy            - Number of RDNs to shave off before calling
                          KCCSimQuickRDNOf.
    pwszBuf             - A preallocated buffer of length MAX_RDN_SIZE
                          that will hold the corresponding RDN.

Return Value:

    Always returns pwszBuf.

--*/
{
    PDSNAME                         pdnTrimmed;

    if (ulBackBy == 0) {
        return KCCSimQuickRDNOf (pdn, pwszBuf);
    } else {
        pdnTrimmed = KCCSimAlloc (pdn->structLen);
        TrimDSNameBy ((PDSNAME) pdn, ulBackBy, pdnTrimmed);
        KCCSimQuickRDNOf (pdnTrimmed, pwszBuf);
        KCCSimFree (pdnTrimmed);
        return pwszBuf;
    }
}

PDSNAME
KCCSimAllocAppendRDN (
    IN  const DSNAME *              pdnOld,
    IN  LPCWSTR                     pwszNewRDN,
    IN  ATTRTYP                     attClass
    )
/*++

Routine Description:

    Appends an RDN onto an existing DSNAME.

Arguments:

    pdnOld              - The existing DSNAME.
    pwszNewRDN          - The RDN to append.
    attClass            - Attribute class of this RDN; typically
                          ATT_COMMON_NAME.

Return Value:

    A newly allocated DSNAME with the appended RDN.

--*/
{
    PDSNAME                         pdnNew;
    LPWSTR                          pwszNewRDNCopy;
    ULONG                           cbBytesNeeded, ulAppendResult;

    // We're given a LPCWSTR, but AppendRDN wants an LPWSTR.
    // So we make a copy.

    pwszNewRDNCopy = KCCSIM_WCSDUP (pwszNewRDN);

    cbBytesNeeded = AppendRDN (
        (PDSNAME) pdnOld,
        NULL,
        0,
        pwszNewRDNCopy,
        0,
        attClass
        );
    Assert (cbBytesNeeded > 0);

    pdnNew = KCCSimAlloc (cbBytesNeeded);
    ulAppendResult = AppendRDN (
        (PDSNAME) pdnOld,
        pdnNew,
        cbBytesNeeded,
        pwszNewRDNCopy,
        0,
        attClass
        );
    Assert (ulAppendResult == 0);       // Everything should be fine

    KCCSimFree (pwszNewRDNCopy);

    return pdnNew;
}

LPWSTR
KCCSimAllocDsnameToDNSName (
    IN  const DSNAME *              pdn
    )
/*++

Routine Description:

    Converts a DSNAME structure to the associated DSNAME, e.g.
    DC=ntdev,DC=microsoft,DC=com => ntdev.microsoft.com

Arguments:

    pdn                 - The DSNAME to convert.

Return Value:

    The allocated converted string. If the DSNAME is invalid,
    an exception is thrown.

--*/
{
    LPWSTR                          pwszDNSName;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];
    ULONG                           ulLen, ulNameParts, ulRDNAt;
    ULONG                           ulResult;
    
    Assert (pdn != NULL);
    Assert (pdn->NameLen > 0);

    ulResult = CountNameParts (pdn, &ulNameParts);
    if( 0!=ulResult ) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_INVALID_DSNAME,
            pdn->StringName
            );
    }

    // Determine how much space is needed.
    ulLen = 0;
    for (ulRDNAt = 0; ulRDNAt < ulNameParts; ulRDNAt++) {
        ulLen += wcslen (KCCSimQuickRDNBackOf (pdn, ulRDNAt, wszRDN)) + 1;
    }
    ulLen -= 1;

    pwszDNSName = KCCSimAlloc (sizeof (WCHAR) * (1 + ulLen));

    // Build the DNS Name
    pwszDNSName[0] = L'\0';
    for (ulRDNAt = 0; ulRDNAt < ulNameParts; ulRDNAt++) {
        wcscat (pwszDNSName, KCCSimQuickRDNBackOf (pdn, ulRDNAt, wszRDN));
        if (ulRDNAt != ulNameParts - 1) {
            wcscat (pwszDNSName, L".");
        }
    }

    return pwszDNSName;
}

VOID
KCCSimCopyGuidAndSid (
    IO  PDSNAME                     pdnDst,
    IN  const DSNAME *              pdnSrc
    )
/*++

Routine Description:

    Copies the GUID and SID from one DSNAME to another.
    Does not affect the StringNames of the DSNAMEs involved.

Arguments:

    pdnDst              - The destination DSNAME.
    pdnSrc              - The source DSNAME.

Return Value:

    None.

--*/
{
    if (pdnDst != NULL && pdnSrc != NULL) {

        memcpy (&pdnDst->Guid,
                &pdnSrc->Guid,
                sizeof (GUID));

        pdnDst->SidLen = pdnSrc->SidLen;

        memcpy (&pdnDst->Sid,
                &pdnSrc->Sid,
                sizeof (NT4SID));

    }
}

RTL_GENERIC_TABLE                   g_TableSchema;

struct _KCCSIM_SCHEMA_ENTRY {
    ATTRTYP                         attrType;
    const struct _SCHTABLE_MAPPING *pSchTableEntry;
    PDSNAME                         pdnObjCategory;
};

RTL_GENERIC_COMPARE_RESULTS
NTAPI
KCCSimSchemaTableCompare (
    IN  RTL_GENERIC_TABLE *         pTable,
    IN  PVOID                       pFirstStruct,
    IN  PVOID                       pSecondStruct
    )
/*++

Routine Description:

    Compares two _KCCSIM_SCHEMA_ENTRY structures by ATTRTYP.

Arguments:

    pTable              - Always &g_TableSchema.
    pFirstStruct        - The first ATTRTYP to compare.
    pSecondStruct       - The second ATTRTYP to compare.

Return Value:

    GenericLessThan, GenericGreaterThan or GenericEqual

--*/
{
    struct _KCCSIM_SCHEMA_ENTRY *   pFirstEntry;
    struct _KCCSIM_SCHEMA_ENTRY *   pSecondEntry;
    int                             iCmp;
    RTL_GENERIC_COMPARE_RESULTS     result;

    pFirstEntry = (struct _KCCSIM_SCHEMA_ENTRY *) pFirstStruct;
    pSecondEntry = (struct _KCCSIM_SCHEMA_ENTRY *) pSecondStruct;
    iCmp = pFirstEntry->attrType - pSecondEntry->attrType;

    if (iCmp < 0) {
        result = GenericLessThan;
    } else if (iCmp > 0) {
        result = GenericGreaterThan;
    } else {
        Assert (iCmp == 0);
        result = GenericEqual;
    }

    return result;
}

VOID
KCCSimInitializeSchema (
    VOID
    )
/*++

Routine Description:

    KCCSim maintains an RTL_GENERIC_TABLE that maps ATTRTYPs to
    schema information.  This table serves as a makeshift schema; it
    is necessary because we usually do not have a complete view of
    the schema available.  When we initially load an ldif file, for
    example, we need to know the ATTRTYP and attribute syntax of each
    attribute that is loaded.
    
    Upon initialization, this schema information
    is read out of the automatically generated table in schmap.c and
    stored in the RTL_GENERIC_TABLE for rapid lookup.
    Object categories are not stored in schmap.c (since they vary
    depending on the DN of the schema), and by default the
    pdnObjCategory field of g_TableSchema is NULL.  As object
    categories become known, they will be filled in as appropriate.    

Arguments:

    None.

Return Value:

    None.

--*/
{
    struct _KCCSIM_SCHEMA_ENTRY     insert;
    ULONG                           ul;

    RtlInitializeGenericTable (
        &g_TableSchema,
        KCCSimSchemaTableCompare,
        KCCSimTableAlloc,
        KCCSimTableFree,
        NULL
        );

    for (ul = 0; ul < SCHTABLE_NUM_ROWS; ul++) {
        insert.attrType = schTable[ul].attrType;
        insert.pSchTableEntry = &schTable[ul];
        insert.pdnObjCategory = NULL;
        RtlInsertElementGenericTable (
            &g_TableSchema,
            (PVOID) &insert,
            sizeof (struct _KCCSIM_SCHEMA_ENTRY),
            NULL
            );
    }
}

struct _KCCSIM_SCHEMA_ENTRY *
KCCSimSchemaTableLookup (
    IN  ATTRTYP                     attrType
    )
/*++

Routine Description:

    This retrieves the _KCCSIM_SCHEMA_ENTRY structure associated
    with a particular ATTRTYP.  The _KCCSIM_SCHEMA_ENTRY type is
    not publicized, but this function is called by the conversion
    functions below.

Arguments:

    attrType            - The attribute type to search for.

Return Value:

    The associated _KCCSIM_SCHEMA_ENTRY.

--*/
{
    struct _KCCSIM_SCHEMA_ENTRY     lookup;
    struct _KCCSIM_SCHEMA_ENTRY *   pFound;

    lookup.attrType = attrType;
    lookup.pSchTableEntry = NULL;
    lookup.pdnObjCategory = NULL;
    pFound = RtlLookupElementGenericTable (&g_TableSchema, &lookup);

    return pFound;
}

LPCWSTR
KCCSimAttrTypeToString (
    IN  ATTRTYP                     attrType
    )
//
// Converts an attribute type to an LDAP display name.
// (e.g. ATT_GOVERNS_ID => L"governsID")
//
{
    struct _KCCSIM_SCHEMA_ENTRY *   pSchemaEntry;

    pSchemaEntry = KCCSimSchemaTableLookup (attrType);

    if (pSchemaEntry == NULL) {
        return NULL;
    } else {
        Assert (pSchemaEntry->pSchTableEntry != NULL);
        return (pSchemaEntry->pSchTableEntry->wszLdapDisplayName);
    }
}

ATTRTYP
KCCSimStringToAttrType (
    IN  LPCWSTR                     pwszName
    )
//
// Converts an LDAP display name to an attribute type.
// (e.g. L"governsID" => ATT_GOVERNS_ID)
//
{
    ULONG                           ul;

    // The table is indexed by attrType, not name, so we have
    // to do this by brute force.

    for (ul = 0; ul < SCHTABLE_NUM_ROWS; ul++) {
        if (wcscmp (pwszName, schTable[ul].wszLdapDisplayName) == 0) {
            break;
        }
    }

    if (ul == SCHTABLE_NUM_ROWS) {
        return 0;
    } else {
        return schTable[ul].attrType;
    }
}

ATTRTYP
KCCSimNarrowStringToAttrType (
    IN  LPCSTR                      pszName
    )
//
// Converts a narrow-string LDAP display name to an attribute type.
// (e.g. "governsID" => ATT_GOVERNS_ID)
//
{
    static WCHAR                    wszBuf[1+SCHTABLE_MAX_LDAPNAME_LEN];

    if (MultiByteToWideChar (
            CP_ACP,
            0,
            pszName,
            1 + min (strlen (pszName), SCHTABLE_MAX_LDAPNAME_LEN),
            wszBuf,
            1 + SCHTABLE_MAX_LDAPNAME_LEN
            ) == 0) {
        KCCSimException (
            KCCSIM_ETYPE_WIN32,
            GetLastError ()
            );
    }

    return KCCSimStringToAttrType (wszBuf);
}

ULONG
KCCSimAttrSyntaxType (
    IN  ATTRTYP                     attrType
    )
//
// Returns an attribute's syntax type (SYNTAX_*_TYPE defined in ntdsa.h.)
// (e.g. ATT_GOVERNS_ID => SYNTAX_OBJECT_ID_TYPE)
//
{
    struct _KCCSIM_SCHEMA_ENTRY *   pSchemaEntry;

    pSchemaEntry = KCCSimSchemaTableLookup (attrType);

    if (pSchemaEntry == NULL) {
        return 0;
    } else {
        Assert (pSchemaEntry->pSchTableEntry != NULL);
        return (pSchemaEntry->pSchTableEntry->ulSyntax);
    }
}

LPCWSTR
KCCSimAttrSchemaRDN (
    IN  ATTRTYP                     attrType
    )
//
// Converts an attribute type to a schema RDN.
// (e.g. ATT_GOVERNS_ID => L"Governs-ID")
//
{
    struct _KCCSIM_SCHEMA_ENTRY *   pSchemaEntry;

    pSchemaEntry = KCCSimSchemaTableLookup (attrType);

    if (pSchemaEntry == NULL) {
        return NULL;
    } else {
        Assert (pSchemaEntry->pSchTableEntry != NULL);
        return (pSchemaEntry->pSchTableEntry->wszSchemaRDN);
    }
}

ATTRTYP
KCCSimAttrSuperClass (
    IN  ATTRTYP                     attrType
    )
//
// Converts a class type to the type of its super-class.
// (i.e. CLASS_NTDS_DSA => CLASS_APPLICATION_SETTINGS,
//       CLASS_APPLICATION_SETTINGS => CLASS_TOP,
//       CLASS_TOP => CLASS_TOP)
//
{
    struct _KCCSIM_SCHEMA_ENTRY *   pSchemaEntry;

    pSchemaEntry = KCCSimSchemaTableLookup (attrType);

    if (pSchemaEntry == NULL) {
        return 0;
    } else {
        Assert (pSchemaEntry->pSchTableEntry != NULL);
        return (pSchemaEntry->pSchTableEntry->superClass);
    }
}

PDSNAME
KCCSimAttrObjCategory (
    IN  ATTRTYP                     attrType
    )
//
// Converts an attribute type to an object category.
// If no object category is present for this attribute, returns NULL.
// A more general function, KCCSimAlwaysGetObjCategory, is prototyped
// in dir.h.
//
{
    struct _KCCSIM_SCHEMA_ENTRY *   pSchemaEntry;

    pSchemaEntry = KCCSimSchemaTableLookup (attrType);

    if (pSchemaEntry == NULL) {
        return NULL;
    } else {
        return (pSchemaEntry->pdnObjCategory);
    }
}

VOID
KCCSimSetObjCategory (
    IN  ATTRTYP                     attrType,
    IN  const DSNAME *              pdnObjCategory
    )
//
// Set this attribute's object category in the schema table.
//
{
    struct _KCCSIM_SCHEMA_ENTRY *   pSchemaEntry;

    pSchemaEntry = KCCSimSchemaTableLookup (attrType);

    if (pSchemaEntry != NULL) {

        pSchemaEntry->pdnObjCategory = KCCSimAlloc (pdnObjCategory->structLen);
        memcpy (
            pSchemaEntry->pdnObjCategory,
            pdnObjCategory,
            pdnObjCategory->structLen
            );

    }
}


VOID
KCCSimPrintStatistics(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    void - 

Return Value:

    None

--*/

{
    FILETIME ftCreationTime;
    FILETIME ftExitTime;
    FILETIME ftKernelTime = { 0 };
    FILETIME ftUserTime = { 0 };
    FILETIME ftIsmUserTime;
    SYSTEMTIME systemTime;

    if (!GetThreadTimes( GetCurrentThread(),
                         &ftCreationTime,
                         &ftExitTime,
                         &ftKernelTime,
                         &ftUserTime)) {
        printf( "GetThreadTimes call failed, error %d\n", GetLastError() );
    }

#define PRINT_DWORD( x ) printf( "%s = %d\n", #x, x );
#define PRINT_DWORD_MB( x ) printf( "%s = %d bytes (%.2f MB)\n", #x, x, x / (1024.0 * 1024.0) );
    printf( "Statistics:\n" );
    PRINT_DWORD( g_Statistics.DirAddOps );
    PRINT_DWORD( g_Statistics.DirModifyOps );
    PRINT_DWORD( g_Statistics.DirRemoveOps );
    PRINT_DWORD( g_Statistics.DirReadOps );
    PRINT_DWORD( g_Statistics.DirSearchOps );
    PRINT_DWORD( g_Statistics.DebugMessagesEmitted );
    PRINT_DWORD( g_Statistics.LogEventsCalled );
    PRINT_DWORD( g_Statistics.LogEventsEmitted );
    PRINT_DWORD_MB( g_Statistics.SimBytesTotalAllocated );
    PRINT_DWORD_MB( g_Statistics.SimBytesOutstanding );
    PRINT_DWORD_MB( g_Statistics.SimBytesMaxOutstanding );
    PRINT_DWORD_MB( g_Statistics.ThreadBytesTotalAllocated );
    PRINT_DWORD_MB( g_Statistics.ThreadBytesOutstanding );
    PRINT_DWORD_MB( g_Statistics.ThreadBytesMaxOutstanding );
    PRINT_DWORD( g_Statistics.IsmGetTransportServersCalls );
    PRINT_DWORD( g_Statistics.IsmGetConnScheduleCalls );
    PRINT_DWORD( g_Statistics.IsmGetConnectivityCalls );
    PRINT_DWORD( g_Statistics.IsmFreeCalls );

    ZeroMemory( &systemTime, sizeof( SYSTEMTIME ) );
    if (!FileTimeToSystemTime( &ftKernelTime, &systemTime )) {
        printf( "FileTimeToSystemTime failed, error %d\n", GetLastError() );
    }
    printf( "kernel cpu time = %d:%d:%d.%d\n",
            systemTime.wHour,
            systemTime.wMinute,
            systemTime.wSecond,
            systemTime.wMilliseconds );

    Assert( sizeof( ULONGLONG) == sizeof( FILETIME ) );
    memcpy( &ftIsmUserTime, &(g_Statistics.IsmUserTime), sizeof( FILETIME ) );
    ZeroMemory( &systemTime, sizeof( SYSTEMTIME ) );
    if (!FileTimeToSystemTime( &ftIsmUserTime, &systemTime )) {
        printf( "FileTimeToSystemTime failed, error %d\n", GetLastError() );
    }
    printf( "Ism user cpu time = %d:%d:%d.%d\n",
            systemTime.wHour,
            systemTime.wMinute,
            systemTime.wSecond,
            systemTime.wMilliseconds );

    ZeroMemory( &systemTime, sizeof( SYSTEMTIME ) );
    if (!FileTimeToSystemTime( &ftUserTime, &systemTime )) {
        printf( "FileTimeToSystemTime failed, error %d\n", GetLastError() );
    }
    printf( "user cpu time = %d:%d:%d.%d\n",
            systemTime.wHour,
            systemTime.wMinute,
            systemTime.wSecond,
            systemTime.wMilliseconds );

} /* KCCSimPrintStatistics */


DWORD
KCCSimI_ISMGetTransportServers (
    IN  HANDLE                      hIsm,
    IN  LPCWSTR                     pszSiteDN,
    OUT ISM_SERVER_LIST **          ppServerList
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;

    g_Statistics.IsmGetTransportServersCalls++;

    status = SimI_ISMGetTransportServers( hIsm, pszSiteDN, ppServerList );

    return status;
}


DWORD
KCCSimI_ISMGetConnectionSchedule (
    IN  HANDLE                      hIsm,
    IN  LPCWSTR                     pszSite1DN,
    IN  LPCWSTR                     pszSite2DN,
    OUT ISM_SCHEDULE **             ppSchedule
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;

    g_Statistics.IsmGetConnScheduleCalls++;

    status = SimI_ISMGetConnectionSchedule( hIsm, pszSite1DN, pszSite2DN, ppSchedule );

    return status;
}


DWORD
KCCSimI_ISMGetConnectivity (
    IN  LPCWSTR                     pszTransportDN,
    OUT ISM_CONNECTIVITY **         ppConnectivity
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;
    FILETIME ftCreationTimeBefore, ftCreationTimeAfter;
    FILETIME ftExitTimeBefore, ftExitTimeAfter;
    FILETIME ftKernelTimeBefore = { 0 }, ftKernelTimeAfter = { 0 };
    FILETIME ftUserTimeBefore = { 0 }, ftUserTimeAfter = { 0 };
    ULONGLONG llBefore, llAfter;

    if (!GetThreadTimes( GetCurrentThread(),
                         &ftCreationTimeBefore,
                         &ftExitTimeBefore,
                         &ftKernelTimeBefore,
                         &ftUserTimeBefore)) {
        printf( "GetThreadTimes call failed, error %d\n", GetLastError() );
    }

    g_Statistics.IsmGetConnectivityCalls++;

    status = SimI_ISMGetConnectivity( pszTransportDN, ppConnectivity );

    if (!GetThreadTimes( GetCurrentThread(),
                         &ftCreationTimeAfter,
                         &ftExitTimeAfter,
                         &ftKernelTimeAfter,
                         &ftUserTimeAfter)) {
        printf( "GetThreadTimes call failed, error %d\n", GetLastError() );
    }

    Assert( sizeof( ULONGLONG) == sizeof( FILETIME ) );
    memcpy( &llBefore, &ftUserTimeBefore, sizeof( ULONGLONG ) );
    memcpy( &llAfter, &ftUserTimeAfter, sizeof( ULONGLONG ) );
    g_Statistics.IsmUserTime += (llAfter - llBefore);

    return status;
}


DWORD
KCCSimI_ISMFree (
    IN  VOID *                      pv
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;

    g_Statistics.IsmFreeCalls++;

    status = SimI_ISMFree( pv );

    return status;
}


DSTIME
GetSecondsSince1601( void )
{
    SYSTEMTIME sysTime;
    FILETIME   fileTime;

    DSTIME  dsTime = 0, tempTime = 0;

    GetSystemTime( &sysTime );
    
    // Get FileTime
    SystemTimeToFileTime(&sysTime, &fileTime);
    dsTime = fileTime.dwLowDateTime;
    tempTime = fileTime.dwHighDateTime;
    dsTime |= (tempTime << 32);

    // Ok. now we have the no. of 100 ns intervals since 1601
    // in dsTime. Convert to seconds and return
    
    return(dsTime/(10*1000*1000L));
}

// Stub out unused taskq functions

BOOL
InitTaskScheduler(
    IN  DWORD           cSpares,
    IN  SPAREFN_INFO *  pSpares
    )
{
    return TRUE;
}

BOOL
ShutdownTaskSchedulerWait(
    DWORD   dwWaitTimeInMilliseconds    // maximum time to wait for current
    )                                   //   task (if any) to complete
{
    return TRUE;
}

BOOL
DoInsertInTaskQueue(
    PTASKQFN    pfnTaskQFn,     // task to execute
    void *      pvParam,        // user-defined parameter to that task
    DWORD       cSecsFromNow,   // secs from now to execute
    BOOL        fReschedule,
    PCHAR       pfnName
    )
{
    return TRUE;
}

void
ShutdownTaskSchedulerTrigger( void )
{
    NOTHING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\util.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dir.c

ABSTRACT:

    Contains assorted utilities.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#ifndef _KCCSIM_UTIL_H_
#define _KCCSIM_UTIL_H_

// Include the automatically generated error message file

#include "msg.h"

#define IO                          IN OUT
#define ARRAY_SIZE(x)               ((sizeof (x)) / (sizeof (x[0])))
#define KCCSIM_MAX_LTOA_CHARS       33
#define KCCSIM_MAX_LITOA_CHARS      64

#define KCCSIM_PARTITIONS_RDN       L"Partitions"
#define KCCSIM_SERVICES_CONTAINER   L"CN=Directory Service,CN=Windows NT,CN=Services,"
#define KCCSIM_AGGREGATE_RDN        L"Aggregate"

// Exception and error type codes

#define KCCSIM_EXCEPTION            0xE0020001
#define KCCSIM_ETYPE_WIN32          1
#define KCCSIM_ETYPE_INTERNAL       2

// Option flags

#define KCCSIM_NO_OPTIONS           0x00000000
#define KCCSIM_WRITE                0x00000001
#define KCCSIM_STRING_NAME_ONLY     0x00000002

// A few macros

#define KCCSIM_NEW(x) \
    (x *) KCCSimAlloc (sizeof (x))

#define KCCSIM_NEW_ARRAY(x,y) \
    (x *) KCCSimAlloc ((y) * sizeof (x))

#define KCCSIM_STRMEMSIZE(x) \
    (sizeof (CHAR) * (strlen (x) + 1))

#define KCCSIM_WCSMEMSIZE(x) \
    (sizeof (WCHAR) * (wcslen (x) + 1))

#define KCCSIM_STRDUP(src)              \
    strcpy ((LPSTR) KCCSimAlloc (KCCSIM_STRMEMSIZE (src)), src)

#define KCCSIM_WCSDUP(src)              \
    wcscpy ((LPWSTR) KCCSimAlloc (KCCSIM_WCSMEMSIZE (src)), src)

#define KCCSIM_CHKERR(x) {              \
    DWORD _dwWin32Err = (x);            \
    if (NO_ERROR != _dwWin32Err)        \
        KCCSimException (               \
            KCCSIM_ETYPE_WIN32,         \
            _dwWin32Err);               \
}

#define KCCSIM_THNEW(x) \
    (x *) KCCSimThreadAlloc (sizeof (x))

// Statistics

typedef struct _STATISTICS {
    DWORD DirAddOps;
    DWORD DirModifyOps;
    DWORD DirRemoveOps;
    DWORD DirReadOps;
    DWORD DirSearchOps;
    DWORD DebugMessagesEmitted;
    DWORD LogEventsCalled;
    DWORD LogEventsEmitted;
    DWORD SimBytesTotalAllocated;
    DWORD SimBytesOutstanding;
    DWORD SimBytesMaxOutstanding;
    DWORD ThreadBytesTotalAllocated;
    DWORD ThreadBytesOutstanding;
    DWORD ThreadBytesMaxOutstanding;
    ULONGLONG IsmUserTime;
    DWORD IsmGetTransportServersCalls;
    DWORD IsmGetConnScheduleCalls;
    DWORD IsmGetConnectivityCalls;
    DWORD IsmFreeCalls;
} KCCSIM_STATISTICS, *PKCCSIM_STATISTICS;

extern KCCSIM_STATISTICS g_Statistics;

// Function prototypes

VOID
KCCSimQuiet (
    IN  BOOL                        bQuiet
    );

DWORD
KCCSimHandleException (
    IN  const EXCEPTION_POINTERS *  pExceptionPtrs,
    OUT PDWORD                      pdwErrType OPTIONAL,
    OUT PDWORD                      pdwErrCode OPTIONAL
    );

LPCWSTR
KCCSimMsgToString (
    IN  DWORD                       dwErrType,
    IN  DWORD                       dwMessageCode,
    ...
    );

VOID
KCCSimPrintMessage (
    IN  DWORD                       dwMessageCode,
    ...
    );

VOID
KCCSimException (
    IN  DWORD                       dwErrType,
    IN  DWORD                       dwErrCode,
    ...
    );

VOID
KCCSimPrintExceptionMessage (
    VOID
    );

VOID
KCCSimSetDebugLog (
    IN  LPCWSTR                     pwszFn OPTIONAL,
    IN  ULONG                       ulDebugLevel,
    IN  ULONG                       ulLogLevel
    );

PVOID
KCCSimTableAlloc (
    IN  RTL_GENERIC_TABLE *         pTable,
    IN  CLONG                       ByteSize
    );

VOID
KCCSimTableFree (
    IN  RTL_GENERIC_TABLE *         pTable,
    IN  PVOID                       Buffer
    );

BOOL
KCCSimParseCommand (
    IN  LPCWSTR                     pwsz,
    IN  ULONG                       ulArg,
    IO  LPWSTR                      pwszBuf
    );

LPWSTR
KCCSimAllocWideStr (
    IN  UINT                        CodePage,
    IN  LPCSTR                      psz
    );

LPSTR
KCCSimAllocNarrowStr (
    IN  UINT                        CodePage,
    IN  LPCWSTR                     pwsz
    );

PDSNAME
KCCSimAllocDsname (
    IN  LPCWSTR                     pwszDn OPTIONAL
    );

PDSNAME
KCCSimAllocDsnameFromNarrow (
    IN  LPCSTR                      pszDn OPTIONAL
    );

LPWSTR
KCCSimQuickRDNOf (
    IN  const DSNAME *              pdn,
    IO  LPWSTR                      pwszBuf
    );

LPWSTR
KCCSimQuickRDNBackOf (
    IN  const DSNAME *              pdn,
    IN  ULONG                       ulBackBy,
    IO  LPWSTR                      pwszBuf
    );

PDSNAME
KCCSimAllocAppendRDN (
    IN  const DSNAME *              pdnOld,
    IN  LPCWSTR                     pwszNewRDN,
    IN  ATTRTYP                     attClass
    );

LPWSTR
KCCSimAllocDsnameToDNSName (
    IN  const DSNAME *              pdn
    );

VOID
KCCSimCopyGuidAndSid (
    IO  PDSNAME                     pdnDst,
    IN  const DSNAME *              pdnSrc
    );

VOID
KCCSimInitializeSchema (
    VOID
    );

LPCWSTR
KCCSimAttrTypeToString (
    IN  ATTRTYP                     attrType
    );

ATTRTYP
KCCSimStringToAttrType (
    IN  LPCWSTR                     pwszString
    );

ATTRTYP
KCCSimNarrowStringToAttrType (
    IN  LPCSTR                      pszString
    );

ULONG
KCCSimAttrSyntaxType (
    IN  ATTRTYP                     attrType
    );

LPCWSTR
KCCSimAttrSchemaRDN (
    IN  ATTRTYP                     attrType
    );

ATTRTYP
KCCSimAttrSuperClass (
    IN  ATTRTYP                     attrType
    );

PDSNAME
KCCSimAttrObjCategory (
    IN  ATTRTYP                     attrType
    );

VOID
KCCSimSetObjCategory (
    IN  ATTRTYP                     attrType,
    IN  const DSNAME *              pdnObjCategory
    );

VOID
KCCSimPrintStatistics(
    void
    );

#endif // _KCCSIM_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\schtable\schtable.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    schtable.c

ABSTRACT:

    Automatically generates the schema mapping source
    and header files that are used by KCCSim.  Reads
    its input from mkdit.ini in ds\setup.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include "schtable.h"

LPWSTR
SchTableAdvanceToNextString (
    IN  LPWSTR                      pwszCurString
    )
/*++

Routine Description:

    Finds the start of the next string in an INI profile section.

Arguments:

    IN  pwszCurString       - A pointer to the current string.

Return Value:

    If there are more strings in this profile section after
    pwszCurString, returns a pointer to the next one.  Otherwise
    returns NULL.

--*/
{
    while (*(pwszCurString++) != L'\0')
        ;

    if (*pwszCurString == L'\0') {
        return NULL;
    }

    else return pwszCurString;
}

ULONG
SchTableHexToInt (
    IN  WCHAR                       wc
    )
//
// Quick hack to convert a hex digit ('b') to an integer (11).
//
{
    switch (towlower (wc)) {
        case L'0': return 0;
        case L'1': return 1;
        case L'2': return 2;
        case L'3': return 3;
        case L'4': return 4;
        case L'5': return 5;
        case L'6': return 6;
        case L'7': return 7;
        case L'8': return 8;
        case L'9': return 9;
        case L'a': return 10;
        case L'b': return 11;
        case L'c': return 12;
        case L'd': return 13;
        case L'e': return 14;
        case L'f': return 15;
        default  : return 0;
    }
}

LPCWSTR
SchTableHexStringToSyntax (
    IN  LPCWSTR                     pwszHexString
    )
/*++

Routine Description:

    Converts a hex string such as those found in mkdit.ini
    to an attribute syntax type.

Arguments:

    IN  pwszHexString       - The hex-encoded string.

Return Value:

    The string representing the constant symbol for this
    attribute syntax type (e.g. "SYNTAX_DISTNAME").

--*/
{
    ULONG                               ulSyntax;

    // Make sure the string is properly formatted.
    if (pwszHexString == NULL       ||
        wcslen (pwszHexString) != 8 ||
        pwszHexString[0] != L'\\'   ||
        pwszHexString[1] != L'x') {
        return L"0";
    }

    // We just assume it's the last two digits of the string -
    // this will be true unless something in mkdit.ini changes
    ulSyntax = 16 * SchTableHexToInt (pwszHexString[6])
                  + SchTableHexToInt (pwszHexString[7]);

    // Return the name if we know it
    if (ulSyntax >= 0 && ulSyntax < SCHTABLE_MAX_SUPPORTED_SYNTAX) {
        return SCHTABLE_NTDSA_SYNTAX_NAME[ulSyntax];
    } else {
        return L"0";
    }
}

VOID
SchTableCreateGenericLdapName (
    IN  LPCWSTR                         pwszSchemaRDN,
    IO  LPWSTR                          pwszLdapDisplayName
    )
/*++

Routine Description:

    Converts a schema RDN ("Sub-Refs") to the corresponding
    generic LDAP display name ("subRefs").

Arguments:

    pwszSchemaRDN       - The schema RDN.
    pwszLdapDisplayName - Pointer to a preallocated buffer where
                          the LDAP display name is to be stored.
                          Since the generic LDAP display name is
                          never longer than the common name, this
                          can safely be of length
                          wcslen (pwszSchemaRDN).

Return Value:

    None.

--*/
{
    *pwszLdapDisplayName = towlower (*pwszSchemaRDN);
    pwszLdapDisplayName++;
    if (*pwszSchemaRDN == L'\0') {
        return;
    }

    do {

        pwszSchemaRDN++;
        if (*pwszSchemaRDN != L'-') {
            *pwszLdapDisplayName = *pwszSchemaRDN;
            pwszLdapDisplayName++;
        }

    } while (*pwszSchemaRDN != L'\0');

}

VOID
SchTableCreateAttributeConstant (
    IN  LPCWSTR                     pwszSchemaRDN,
    IO  LPWSTR                      pwszAttConstant,
    IN  BOOL                        bIsClass
    )
/*++

Routine Description:

    Converts a schema RDN ("Sub-Refs") to the corresponding
    attribute constant name ("ATT_SUB_REFS").

Arguments:

    pwszSchemaRDN       - The schema RDN.
    pwszAttConstant     - Pointer to a preallocated buffer where
                          the attribute constant name is to be stored.
                          Since the attribute constant name is
                          never longer than the common name, this
                          can safely be of length
                          wcslen (pwszSchemaRDN).
    bIsClass            - TRUE if this is a class, FALSE if it's an attribute.

Return Value:

    None.

--*/
{
    LPCWSTR                             pwszPrefix;

    pwszPrefix = (bIsClass ? L"CLASS_" : L"ATT_");

    swprintf (pwszAttConstant, pwszPrefix);
    pwszAttConstant += wcslen (pwszPrefix);

    while (*pwszSchemaRDN != L'\0') {

        if (*pwszSchemaRDN == L'-') {
            *pwszAttConstant = L'_';
        } else {
            *pwszAttConstant = towupper (*pwszSchemaRDN);
        }
        
        pwszSchemaRDN++;
        pwszAttConstant++;

    }

    *pwszAttConstant = L'\0';
}

BOOL
SchTableAddRow (
    IN  FILE *                      fpSource,
    IN  BOOL                        bIsLastRow,
    IN  LPCWSTR                     pwszSchemaRDN,
    OUT PULONG                      pulLdapNameLen,
    OUT PULONG                      pulSchemaRDNLen
    )
/*++

Routine Description:

    Adds a row to the schema mapping table.

Arguments:

    fpSource            - Pointer to the .c file.
    bIsLastRow          - TRUE if this is the last row to output.
    pwszSchemaRDN       - The name of the schema RDN.
    pulLdapNameLen      - The length of the LDAP display name.
    pulSchemaRDNLen     - The length of the schema RDN.

Return Value:

    TRUE if the row was successfully added.

--*/
{
    static WCHAR                        wszProfile[SCHTABLE_PROFILE_BUFFER_SIZE],
                                        wszQuotedLdapNameBuf[SCHTABLE_STRING_BUFFER_SIZE],
                                        wszQuotedSchemaRDNBuf[SCHTABLE_STRING_BUFFER_SIZE],
                                        wszAttConstantBuf[SCHTABLE_STRING_BUFFER_SIZE],
                                        wszBuf[SCHTABLE_STRING_BUFFER_SIZE],
                                        wszSubClassOfBuf[SCHTABLE_STRING_BUFFER_SIZE];

    LPWSTR                              pwszStringAt, pwszNextString, pwszToken,
                                        pwszLdapDisplayName, pwszSyntax, pwszSubClassOf;

    BOOL                                bIsClass;

    pwszLdapDisplayName = NULL;
    pwszSyntax = NULL;
    pwszSubClassOf = NULL;
    bIsClass = FALSE;

    if (GetPrivateProfileSectionW (
            pwszSchemaRDN,
            wszProfile,
            SCHTABLE_PROFILE_BUFFER_SIZE,
            SCHTABLE_MKDIT_INI_FILEPATH
            ) == SCHTABLE_PROFILE_BUFFER_SIZE - 2) {
        wprintf (L"SCHTABLE: Could not process attribute %s\n"
                 L"          because the default buffer is not large enough.\n",
                 pwszSchemaRDN);
        return FALSE;
    }

    pwszStringAt = wszProfile;
    while (pwszStringAt != NULL) {

        // Find the start of the next string, since we're
        // going to pick this one apart with wcstok
        pwszNextString = SchTableAdvanceToNextString (pwszStringAt);
        pwszToken = wcstok (pwszStringAt, L"=");

        // If this string has relevant information, remember where it is
        if (pwszToken != NULL) {
            if (_wcsicmp (pwszToken, SCHTABLE_MKDIT_KEY_LDAP_DISPLAY_NAME) == 0) {
                pwszLdapDisplayName = wcstok (NULL, L"=");
            } else if (_wcsicmp (pwszToken, SCHTABLE_MKDIT_KEY_ATTRIBUTE_SYNTAX) == 0) {
                pwszSyntax = wcstok (NULL, L"=");
            } else if (_wcsicmp (pwszToken, SCHTABLE_MKDIT_KEY_SUB_CLASS_OF) == 0) {
                bIsClass = TRUE;
                pwszSubClassOf = wcstok (NULL, L"=");
            }
        }

        pwszStringAt = pwszNextString;

    }

    // Create the attribute constant name
    SchTableCreateAttributeConstant (pwszSchemaRDN, wszAttConstantBuf, bIsClass);

    // Create the subclassof constant name
    if (pwszSubClassOf != NULL) {
        SchTableCreateAttributeConstant (pwszSubClassOf, wszSubClassOfBuf, TRUE);
    } else {
        swprintf (wszSubClassOfBuf, L"0");
    }

    // Quote the schema RDN name
    swprintf (wszQuotedSchemaRDNBuf, L"L\"%s\"", pwszSchemaRDN);
    *pulSchemaRDNLen = wcslen (pwszSchemaRDN);

    // If we didn't find an LDAP display name, substitute a generated generic one
    if (pwszLdapDisplayName == NULL) {
        SchTableCreateGenericLdapName (pwszSchemaRDN, wszBuf);
        pwszLdapDisplayName = wszBuf;
    }

    // Quote the LDAP display name
    swprintf (wszQuotedLdapNameBuf, L"L\"%s\"", pwszLdapDisplayName);
    *pulLdapNameLen = wcslen (pwszLdapDisplayName);

    fwprintf (
        fpSource,
        L"    { %-*s, %-*s, %-*s, %-*s, %-*s }%c\n",
        SCHTABLE_NAME_FIELD_WIDTH,
        wszQuotedLdapNameBuf,
        SCHTABLE_NAME_FIELD_WIDTH,
        wszAttConstantBuf,
        SCHTABLE_MAX_SYNTAX_NAME_LEN,
        SchTableHexStringToSyntax (pwszSyntax),
        SCHTABLE_NAME_FIELD_WIDTH,
        wszQuotedSchemaRDNBuf,
        SCHTABLE_NAME_FIELD_WIDTH,
        wszSubClassOfBuf,
        bIsLastRow ? L' ' : L','
        );

    return TRUE;
}

int
__cdecl
wmain (
    IN  int                         argc,
    IN  LPWSTR *                    argv
    )
/*++

Routine Description:

    wmain () for schtable.exe.

Arguments:

    argc                - Argument count.
    argv                - Argument values.

Return Value:

    Win32 exit code.

--*/
{
    FILE *                              fpHeader;
    FILE *                              fpSource;
    ULONG                               ulNumRows, ulLdapNameLen, ulSchemaRDNLen,
                                        ulMaxLdapNameLen, ulMaxSchemaRDNLen;

    WCHAR                               wszSchemaProfile[SCHTABLE_PROFILE_BUFFER_SIZE];
    LPWSTR                              pwszStringAt, pwszNextString, pwszToken;

    // Keep track of the longest name length.
    ulMaxLdapNameLen = 0;
    ulMaxSchemaRDNLen = 0;

    fpHeader = _wfopen (SCHTABLE_OUTPUT_HEADER_FILE, L"w");
    fpSource = _wfopen (SCHTABLE_OUTPUT_SOURCE_FILE, L"w");

    fwprintf (fpHeader, SCHTABLE_COMMENT, SCHTABLE_OUTPUT_HEADER_FILE);

    fwprintf (fpSource, SCHTABLE_COMMENT, SCHTABLE_OUTPUT_SOURCE_FILE);
    fwprintf (fpSource, SCHTABLE_INITIAL);

    ulNumRows = 0;
    if (GetPrivateProfileSectionW (
            SCHTABLE_MKDIT_PROFILE_SCHEMA,
            wszSchemaProfile,
            SCHTABLE_PROFILE_BUFFER_SIZE,
            SCHTABLE_MKDIT_INI_FILEPATH
            ) == SCHTABLE_PROFILE_BUFFER_SIZE - 2) {
        wprintf (L"SCHTABLE: Default buffer size is not large enough to hold\n"
                 L"          the entire schema table.\n");
    }

    pwszStringAt = wszSchemaProfile;
    while (pwszStringAt != NULL) {

        pwszNextString = SchTableAdvanceToNextString (pwszStringAt);
        pwszToken = wcstok (pwszStringAt, L"=");
        if (pwszToken != NULL &&
            _wcsicmp (pwszToken, SCHTABLE_MKDIT_KEY_CHILD) == 0) {

            // Found a child.
            pwszToken = wcstok (NULL, L"=");
            if (pwszToken != NULL &&
                // Ignore the aggregate attribute if we find it
                _wcsicmp (pwszToken, SCHTABLE_RDN_AGGREGATE) != 0) {
                if (SchTableAddRow (
                    fpSource,
                    pwszNextString == NULL,
                    pwszToken,
                    &ulLdapNameLen,
                    &ulSchemaRDNLen
                    )) {
                    // Successfully added a row
                    ulNumRows++;
                    if (ulLdapNameLen > ulMaxLdapNameLen) {
                        ulMaxLdapNameLen = ulLdapNameLen;
                    }
                    if (ulSchemaRDNLen > ulMaxSchemaRDNLen) {
                        ulMaxSchemaRDNLen = ulSchemaRDNLen;
                    }
                }
            }

        }

        pwszStringAt = pwszNextString;
    }

    fwprintf (
        fpSource,
        SCHTABLE_FINAL
        );

    fwprintf (
        fpHeader,
        SCHTABLE_HEADER,
        ulMaxLdapNameLen,
        ulMaxSchemaRDNLen,
        ulNumRows
        );

    fclose (fpSource);
    fclose (fpHeader);

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\kcc\sim\schtable\schtable.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    schtable.h

ABSTRACT:

    Header file for schtable.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#define IO                          IN OUT

// The pathname of mkdit.ini:
const LPWSTR SCHTABLE_MKDIT_INI_FILEPATH =
      L"..\\..\\..\\schema\\mkdit.ini";
// Names of the source and header files to output:
const LPWSTR SCHTABLE_OUTPUT_HEADER_FILE           = L"schmap.h";
const LPWSTR SCHTABLE_OUTPUT_SOURCE_FILE           = L"schmap.c";
// Some keys that are used to search through mkdit.ini:
const LPWSTR SCHTABLE_MKDIT_PROFILE_SCHEMA         = L"SCHEMA";
const LPWSTR SCHTABLE_MKDIT_KEY_CHILD              = L"CHILD";
const LPWSTR SCHTABLE_MKDIT_KEY_COMMON_NAME        = L"Common-Name";
const LPWSTR SCHTABLE_MKDIT_KEY_LDAP_DISPLAY_NAME  = L"LDAP-Display-Name";
const LPWSTR SCHTABLE_MKDIT_KEY_ATTRIBUTE_SYNTAX   = L"Attribute-Syntax";
const LPWSTR SCHTABLE_MKDIT_KEY_SUB_CLASS_OF       = L"Sub-Class-Of";
// We want to ignore the Aggregate attribute; here's its RDN:
const LPWSTR SCHTABLE_RDN_AGGREGATE                = L"Aggregate";

#define SCHTABLE_PROFILE_BUFFER_SIZE                32768
#define SCHTABLE_STRING_BUFFER_SIZE                 128

#define SCHTABLE_NAME_FIELD_WIDTH                   45

#define SCHTABLE_MAX_SUPPORTED_SYNTAX               18
#define SCHTABLE_MAX_SYNTAX_NAME_LEN                34

// These refer to the names of the SYNTAX_* constants from
// ntdsa.h.  Referring to the syntaxes by name rather than
// by number makes the resulting file more readable.
const WCHAR SCHTABLE_NTDSA_SYNTAX_NAME
            [SCHTABLE_MAX_SUPPORTED_SYNTAX]
            [1+SCHTABLE_MAX_SYNTAX_NAME_LEN] = {
      
      L"SYNTAX_UNDEFINED_TYPE",
      L"SYNTAX_DISTNAME_TYPE",
      L"SYNTAX_OBJECT_ID_TYPE",
      L"SYNTAX_CASE_STRING_TYPE",
      L"SYNTAX_NOCASE_STRING_TYPE",
      L"SYNTAX_PRINT_CASE_STRING_TYPE",
      L"SYNTAX_NUMERIC_STRING_TYPE",
      L"SYNTAX_DISTNAME_BINARY_TYPE",
      L"SYNTAX_BOOLEAN_TYPE",
      L"SYNTAX_INTEGER_TYPE",
      L"SYNTAX_OCTET_STRING_TYPE",
      L"SYNTAX_TIME_TYPE",
      L"SYNTAX_UNICODE_TYPE",
      L"SYNTAX_ADDRESS_TYPE",
      L"SYNTAX_DISTNAME_STRING_TYPE",
      L"SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE",
      L"SYNTAX_I8_TYPE",
      L"SYNTAX_SID_TYPE"

};

const LPWSTR SCHTABLE_COMMENT =

      L"/*++\n"
      L"\n"
      L"Copyright (c) 2000 Microsoft Corporation.\n"
      L"All rights reserved.\n"
      L"\n"
      L"MODULE NAME:\n"
      L"\n"
      L"    %s\n"
      L"\n"
      L"ABSTRACT:\n"
      L"\n"
      L"    This file was automatically generated by schtable.exe.\n"
      L"\n"
      L"--*/\n"
      L"\n";

const LPWSTR SCHTABLE_HEADER =

      L"#ifndef _KCCSIM_SCHMAP_H_\n"
      L"#define _KCCSIM_SCHMAP_H_\n"
      L"\n"
      L"#define SCHTABLE_MAX_LDAPNAME_LEN       %d\n"
      L"#define SCHTABLE_MAX_SCHEMANAME_LEN     %d\n"
      L"#define SCHTABLE_NUM_ROWS               %d\n"
      L"\n"
      L"struct _SCHTABLE_MAPPING {\n"
      L"    const WCHAR                         wszLdapDisplayName[1+SCHTABLE_MAX_LDAPNAME_LEN];\n"
      L"    const ATTRTYP                       attrType;\n"
      L"    const ULONG                         ulSyntax;\n"
      L"    const WCHAR                         wszSchemaRDN[1+SCHTABLE_MAX_SCHEMANAME_LEN];\n"
      L"    const ATTRTYP                       superClass;\n"
      L"};\n"
      L"\n"
      L"extern const struct _SCHTABLE_MAPPING   schTable[];\n"
      L"\n"
      L"#endif // _KCCSIM_SCHMAP_H_\n";

const LPWSTR SCHTABLE_INITIAL =

      L"#include <ntdspch.h>\n"
      L"#include <ntdsa.h>\n"
      L"#include <attids.h>\n"
      L"#include \"schmap.h\"\n"
      L"\n"
      L"// Define symbols missing from attids.h\n"
      L"#define ATT_ENTRY_TTL 0xffffffff\n"
      L"#define CLASS_DYNAMIC_OBJECT 0xffffffff\n"
      L"\n"
      L"const struct _SCHTABLE_MAPPING          schTable[] = {\n"
      L"\n";

const LPWSTR SCHTABLE_FINAL =

      L"\n"
      L"};\n";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\abandon.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    abandon.cxx handle abandon requests to an LDAP server

Abstract:

   This module implements the LDAP abandon APIs.

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG
SendLdapAbandon (
    PLDAP_CONN Connection,
    ULONG msgid
    );


ULONG __cdecl
ldap_abandon (
    LDAP *ExternalHandle,
    ULONG msgid
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);
    if (!connection && ExternalHandle)
    {
        return LDAP_PARAM_ERROR;
    }

    err = LdapAbandon( connection, msgid, TRUE );

    if (connection)
    {
        DereferenceLdapConnection( connection );
    }

    return err;
}

ULONG
LdapAbandon (
    PLDAP_CONN connection,
    ULONG msgid,
    BOOLEAN SendAbandon
    )
{
    PLDAP_REQUEST request = NULL;
    PLIST_ENTRY listEntry;
    ULONG err = LDAP_SUCCESS;
    USHORT connCount;
    PREFERRAL_TABLE_ENTRY referral;
    PLDAP_MESSAGEWAIT waitStructure = NULL;

    if (msgid == 0) {

        err = LDAP_PARAM_ERROR;
        SetConnectionError( connection, err, NULL );
        goto exit_abandon;
    }

    request = FindLdapRequest( (LONG) msgid );

    if (request == NULL) {

        err = LDAP_OTHER;                   // we've already freed it?
        SetConnectionError( connection, err, NULL );
        goto exit_abandon;
    }

    ACQUIRE_LOCK( &request->Lock );

    request->Abandoned = TRUE;
    ClearPendingListForRequest( request );

    RELEASE_LOCK( &request->Lock );
    
    if (SendAbandon) {

        //
        //  send an abandon request to each connection that we have referenced for
        //  this request
        //

        err = SendLdapAbandon( request->PrimaryConnection, msgid );

        referral = request->ReferralConnections;
        if (referral != NULL) {

            for (connCount = 0;
                 connCount < request->ReferralTableSize;
                 connCount++ ) {

                if (referral->ReferralServer != NULL) {

                    (VOID) SendLdapAbandon( referral->ReferralServer, msgid );
                }

                referral++;     // on to next entry
            }
        }
    } else {

        err = LDAP_SUCCESS;
    }


    CloseLdapRequest( request );
    DereferenceLdapRequest( request );

    //
    //  free any waiters that are waiting for this message
    //

    ACQUIRE_LOCK( &ConnectionListLock );

    listEntry = GlobalListWaiters.Flink;

    while (listEntry != &GlobalListWaiters) {

        waitStructure = CONTAINING_RECORD( listEntry,
                                           LDAP_MESSAGEWAIT,
                                           WaitListEntry );
        listEntry = listEntry->Flink;

        if (waitStructure->MessageNumber == msgid) {

            waitStructure->Satisfied = TRUE;
            SetEvent( waitStructure->Event );
        }
    }

    RELEASE_LOCK( &ConnectionListLock );

    LdapWakeupSelect();

exit_abandon:

    err = ((err == LDAP_SUCCESS) ? 0 : (ULONG) -1 );

    return err;
}

ULONG
SendLdapAbandon (
    PLDAP_CONN Connection,
    ULONG msgid
    )
{
    ULONG err = LDAP_SUCCESS;
    CLdapBer *lber = NULL;
    LONG abandonMessageId;
    ULONG hr = LDAP_PARAM_ERROR;

    if ((Connection != NULL) &&
        (Connection->TcpHandle != INVALID_SOCKET)) {

        hr = NOERROR;

        //
        //  Send the server an abandon message if we actually have a connection
        //  to the server.
        //
        //  the ldapv2 abandon message looks like this :
        //
        //  AbandonRequest ::= [APPLICATION 16] MessageID
        //

        lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

        GET_NEXT_MESSAGE_NUMBER( abandonMessageId );

        if (lber != NULL) {

            hr = lber->HrStartWriteSequence();

            if (hr != NOERROR) {
                 hr = LDAP_ENCODING_ERROR;
                 goto returnError;
            }

            hr = lber->HrAddValue( abandonMessageId );

            if (hr != NOERROR) {
                 hr = LDAP_ENCODING_ERROR;
                 goto returnError;
            }

            hr = lber->HrAddValue((LONG) msgid, LDAP_ABANDON_CMD );

            if (hr != NOERROR) {
                 hr = LDAP_ENCODING_ERROR;
                 goto returnError;
            }

            hr = lber->HrEndWriteSequence();

            if (hr != NOERROR) {
                 hr = LDAP_ENCODING_ERROR;
                 goto returnError;
            }

            //
            //  send the abandon request.
            //

            err = LdapSend( Connection, lber );

            if (err != LDAP_SUCCESS) {

                IF_DEBUG(NETWORK_ERRORS) {
                    LdapPrint2( "SendLdapAbandon connection 0x%x send with error of 0x%x.\n",
                                Connection, err );
                }
            }

            goto returnError;

        } else {

            IF_DEBUG(OUTMEMORY) {
                LdapPrint1( "SendLdapAbandonn connection 0x%x could not allocate unbind.\n",
                            Connection );
            }
            err = LDAP_NO_MEMORY;
        }
    }

returnError:

    SetConnectionError( Connection, hr, NULL );

    if (lber != NULL) {

       delete lber;
    }

    return (hr == NOERROR) ? err : hr;
}

// abandon.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\attrib.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    attrib.cxx parse out attributes from LDAP results

Abstract:

   This module implements the APIs to break apart LDAP results

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

PWCHAR
LdapFirstAttribute (
    PLDAP_CONN      connection,
    LDAPMessage     *Message,
    BerElement      **OpaqueResults,
    BOOLEAN         Unicode
    )
//
//  This routine gets the first attribute of the message.  It stores the attr
//  name in a "per connection" buffer but since we like to be multi-thread
//  safe, this is "per connection per thread" just for grins.
//
{
    CLdapBer *lber;
    ULONG hr;
    PLDAP_ATTR_NAME_THREAD_STORAGE threadAttr;
    DWORD currentThread;
    PWCHAR results = NULL;
    ULONG tLength;

    PLIST_ENTRY pThreadListEntry = NULL;
    PTHREAD_ENTRY pThreadEntry = NULL;
    BOOLEAN fRetriedFindThread = FALSE;

    *OpaqueResults = NULL;

    if ((Message == NULL) || (Message->lm_msgtype != LDAP_RES_SEARCH_ENTRY)) {

        SetConnectionError( connection, LDAP_DECODING_ERROR, NULL );
        return NULL;
    }

    currentThread = GetCurrentThreadId();

    //
    // Find the buffer to store the attribute name off of this connection
    // This requires first finding the THREAD_ENTRY for this thread,
    // then the attribute entry for this connection off of that thread entry.
    //
retryFindThread:

    ACQUIRE_LOCK( &PerThreadListLock );

    pThreadListEntry = GlobalPerThreadList.Flink;

    // find the THREAD_ENTRY for this thread
    while (pThreadListEntry != &GlobalPerThreadList) {

        pThreadEntry = CONTAINING_RECORD( pThreadListEntry, THREAD_ENTRY, ThreadEntry );
        pThreadListEntry = pThreadListEntry->Flink;

        if (pThreadEntry->dwThreadID == currentThread) {
            break;
        }

        pThreadEntry = NULL;
    }

    if (!pThreadEntry && !fRetriedFindThread) {
        // this thread must have been created before this DLL was loaded-
        // create a per-thread entry for it now
        RELEASE_LOCK( &PerThreadListLock );

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapFirstAttr could not find ThreadEntry for conn 0x%x, thread 0x%x.  Creating one.\n",
                            connection, currentThread );
        }

        if (!AddPerThreadEntry(currentThread)) {
            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapFirstAttr AddPerThreadEntry failed, conn 0x%x, thread 0x%x.\n",
                                connection, currentThread );
            }
            SetConnectionError( connection, LDAP_NO_MEMORY, NULL );
            return NULL;
        }

        fRetriedFindThread = TRUE;
        goto retryFindThread;
    }
    else if (!pThreadEntry) {
        // shouldn't happen --- somehow a thread entry wasn't created
        RELEASE_LOCK( &PerThreadListLock );
        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapFirstAttr no per-thread entry, conn 0x%x, thread 0x%x.\n",
                            connection, currentThread );
        }            
        ASSERT(pThreadEntry);
        SetConnectionError( connection, LDAP_LOCAL_ERROR, NULL );
        return NULL;
    }

    // find the attribute entry for this connection
    threadAttr = pThreadEntry->pCurrentAttrList;

    while (threadAttr != NULL) {

        if (threadAttr->PrimaryConn == connection) {
            ASSERT(threadAttr->Thread == currentThread);
            break;
        }

        threadAttr = threadAttr->pNext;
    }

    if (threadAttr == NULL) {

        threadAttr = (PLDAP_ATTR_NAME_THREAD_STORAGE) ldapMalloc(
                                sizeof( LDAP_ATTR_NAME_THREAD_STORAGE ),
                                LDAP_ATTR_THREAD_SIGNATURE );

        if (threadAttr == NULL) {

            IF_DEBUG(OUTMEMORY) {
                LdapPrint1( "ldapFirstAttr could not alloc curr attribute for thread for conn 0x%x.\n",
                                connection );
            }

            RELEASE_LOCK( &PerThreadListLock );
            SetConnectionError( connection, LDAP_NO_MEMORY, NULL );
            return NULL;
        }

        IF_DEBUG(TRACE1) {
            LdapPrint3( "ldapFirstAttr allocated attr at 0x%x for thread 0x%x, conn 0x%x.\n",
                            threadAttr, currentThread, connection );
        }

        threadAttr->Thread = currentThread;
        threadAttr->AttrTag.Tag = LDAP_DONT_FREE_SIGNATURE;
        threadAttr->AttrTagW.Tag = LDAP_DONT_FREE_SIGNATURE;
        threadAttr->pNext = pThreadEntry->pCurrentAttrList;
        threadAttr->PrimaryConn = connection;
        pThreadEntry->pCurrentAttrList = threadAttr;
    }
    
    RELEASE_LOCK( &PerThreadListLock );


    //
    //  We now at least have a place to put the results if all is successful
    //  ( in threadAttr->AttributeName )
    //

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    lber = (CLdapBer *) Message->lm_ber;

    if (lber == NULL) {

        goto protocolError;
    }

    hr = LdapGoToFirstAttribute( connection, lber );
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_first_attribute 1 conn 0x%x received protocol error 0x%x .\n",
                            connection, hr);
        }

protocolError:
        SetConnectionError( connection, LDAP_DECODING_ERROR, NULL );
        threadAttr = NULL;
        goto exitGetFirstAttr;
    }

    hr = lber->HrStartReadSequence();

    if (hr != NOERROR) {
        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_first_attribute 8 conn 0x%x received protocol error 0x%x .\n",
                            connection, hr);
        }
        goto exitGetFirstAttr;
    }

    //
    //  Next up is the first attribute type... let's store it off.
    //

    hr = lber->HrGetValue(  (WCHAR *) &(threadAttr->AttributeNameW[0]),
                            MAX_ATTRIBUTE_NAME_LENGTH - 1,
                            BER_OCTETSTRING );

    if (hr != NOERROR) {
        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_first_attribute 2 conn 0x%x received protocol error 0x%x .\n",
                            connection, hr);
        }
        goto protocolError;
    }

    //
    //  We save off both the unicode and single byte form of the attribute
    //  name and then return whichever one they want.
    //

    tLength = WideCharToMultiByte(  CP_ACP,
                                    0,
                                    &(threadAttr->AttributeNameW[0]),
                                    -1,
                                    (PCHAR) &(threadAttr->AttributeName[0]),
                                    MAX_ATTRIBUTE_NAME_LENGTH - 1,
                                    NULL,
                                    NULL );

    threadAttr->AttributeName[tLength-1] = '\0';

    if (Unicode) {

        results = &(threadAttr->AttributeNameW[0]);

    } else {

        results = (PWCHAR) &(threadAttr->AttributeName[0]);
    }

    //
    //  next up is the actual values for this attribute... we'll not quite skip
    //  past it since we may be able to read it straight off in ldap_get_values
    //

    *OpaqueResults = (BerElement *) lber;

exitGetFirstAttr:

    return results;
}

PWCHAR __cdecl
ldap_first_attributeW (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    BerElement      **OpaqueResults
    )
{
    PLDAP_CONN connection = NULL;
    PWCHAR results = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    results = LdapFirstAttribute( connection,
                                  Message,
                                  OpaqueResults,
                                  TRUE );

    DereferenceLdapConnection( connection );

    return results;
}

PCHAR __cdecl
ldap_first_attribute (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    BerElement      **OpaqueResults
    )
{
    PLDAP_CONN connection = NULL;
    PCHAR results = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    results = (PCHAR) LdapFirstAttribute( connection,
                                          Message,
                                          OpaqueResults,
                                          FALSE );

    DereferenceLdapConnection( connection );

    return results;
}

PCHAR __cdecl
ldap_first_attributeA (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    BerElement      **OpaqueResults
    )
{
    PLDAP_CONN connection = NULL;
    PCHAR results = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    results = (PCHAR) LdapFirstAttribute( connection,
                                          Message,
                                          OpaqueResults,
                                          FALSE );

    DereferenceLdapConnection( connection );

    return results;
}

PWCHAR
LdapNextAttribute (
    PLDAP_CONN      connection,
    LDAPMessage     *Message,
    BerElement      *OpaqueResults,
    BOOLEAN         Unicode
    )
//
//  This routine gets the next attribute of the message.  It's the follow-on
//  to ldap_first_attribute above.
//
{
    CLdapBer *lber;
    ULONG hr;
    PLDAP_ATTR_NAME_THREAD_STORAGE threadAttr;
    DWORD currentThread;
    ULONG tag;
    PWCHAR results = NULL;
    ULONG tLength;

    PLIST_ENTRY pThreadListEntry = NULL;
    PTHREAD_ENTRY pThreadEntry = NULL;
    BOOLEAN fRetriedFindThread = FALSE;

    if ((Message == NULL) || (Message->lm_msgtype != LDAP_RES_SEARCH_ENTRY)) {

        SetConnectionError( connection, LDAP_DECODING_ERROR, NULL );
        return NULL;
    }

    currentThread = GetCurrentThreadId();

    //
    // Find the buffer that stored the attribute name off of this connection
    // This requires first finding the THREAD_ENTRY for this thread,
    // then the attribute entry for this connection off of that thread entry.
    //
retryFindThread:

    ACQUIRE_LOCK( &PerThreadListLock );

    pThreadListEntry = GlobalPerThreadList.Flink;

    // find the THREAD_ENTRY for this thread
    while (pThreadListEntry != &GlobalPerThreadList) {

        pThreadEntry = CONTAINING_RECORD( pThreadListEntry, THREAD_ENTRY, ThreadEntry );
        pThreadListEntry = pThreadListEntry->Flink;

        if (pThreadEntry->dwThreadID == currentThread) {
            break;
        }

        pThreadEntry = NULL;
    }

    if (!pThreadEntry && !fRetriedFindThread) {
        // this thread must have been created before this DLL was loaded-
        // create a per-thread entry for it now
        RELEASE_LOCK( &PerThreadListLock );

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapNextAttr could not find ThreadEntry for conn 0x%x, thread 0x%x.  Creating one.\n",
                            connection, currentThread );
        }

        if (!AddPerThreadEntry(currentThread)) {
            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapNextAttr AddPerThreadEntry failed, conn 0x%x, thread 0x%x.\n",
                                connection, currentThread );
            }
            SetConnectionError( connection, LDAP_NO_MEMORY, NULL );
            goto exitGetNextAttr;
        }

        fRetriedFindThread = TRUE;
        goto retryFindThread;
    }
    else if (!pThreadEntry) {
        // shouldn't happen --- somehow a thread entry wasn't created
        RELEASE_LOCK( &PerThreadListLock );
        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapNextAttr no per-thread entry, conn 0x%x, thread 0x%x.\n",
                            connection, currentThread );
        }            
        ASSERT(pThreadEntry);
        SetConnectionError( connection, LDAP_LOCAL_ERROR, NULL );
        goto exitGetNextAttr;
    }    


    // find the attribute entry for this connection
    threadAttr = pThreadEntry->pCurrentAttrList;

    while (threadAttr != NULL) {

        if (threadAttr->PrimaryConn == connection) {
            ASSERT(threadAttr->Thread == currentThread);
            break;
        }

        threadAttr = threadAttr->pNext;
    }

    RELEASE_LOCK( &PerThreadListLock );
    
    if (threadAttr == NULL) {

        SetConnectionError( connection, LDAP_LOCAL_ERROR, NULL );
        goto exitGetNextAttr;
    }

    //
    //  We now at least have a place to put the results if all is successful
    //  ( in threadAttr->AttributeName )
    //

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    if (OpaqueResults == NULL) {

        threadAttr = NULL;
        SetConnectionError( connection, LDAP_LOCAL_ERROR, NULL );
        goto exitGetNextAttr;
    }

    lber = (CLdapBer *) OpaqueResults;

    //
    //  depending on what the last call was, we're either at the start of a
    //  sequence for the next attribute or the start of a set of attribute
    //  values for the current attribute.  We'll peak at the tag and if
    //  we're at a set, we'll skip the value.
    //

    hr = lber->HrPeekTag( &tag );

    if (hr == LDAP_NO_SUCH_ATTRIBUTE) {

        threadAttr = NULL;
        goto exitGetNextAttr;
    }

    if (tag == BER_SET) {

        hr = lber->HrSkipElement();     // skip the attribute value
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapNextAttr 1 conn 0x%x received protocol error 0x%x .\n",
                                connection, hr);
            }
            goto protocolError;
        }

        hr = lber->HrPeekTag( &tag );


        if (hr == LDAP_NO_SUCH_ATTRIBUTE) {

            threadAttr = NULL;
            goto exitGetNextAttr;
        }
        else if ( hr != NOERROR ) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapNextAttr 4 conn 0x%x received protocol error 0x%x .\n",
                                connection, hr);
            }
            goto protocolError;
        }
    }

    hr = lber->HrEndReadSequence();

    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapNextAttr 5 conn 0x%x received protocol error 0x%x .\n",
                            connection, hr);
        }
    }

    if (tag != BER_SEQUENCE) {

        //
        //  we're at the end of the attributes
        //

        threadAttr = NULL;
        goto exitGetNextAttr;
    }

    hr = lber->HrStartReadSequence(BER_SEQUENCE);
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapNextAttr 2 conn 0x%x received protocol error 0x%x .\n",
                            connection, hr);
        }

protocolError:
        SetConnectionError( connection, LDAP_DECODING_ERROR, NULL );
        threadAttr = NULL;
        goto exitGetNextAttr;
    }

    //
    //  Next up is the first attribute type... let's store it off.
    //

    hr = lber->HrGetValue(  (WCHAR *) &(threadAttr->AttributeNameW[0]),
                            MAX_ATTRIBUTE_NAME_LENGTH - 1,
                            BER_OCTETSTRING );

    if (hr != NOERROR) {
        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapNextAttr 3 conn 0x%x received protocol error 0x%x .\n",
                            connection, hr);
        }
        goto protocolError;
    }

    //
    //  We save off both the unicode and single byte form of the attribute
    //  name and then return whichever one they want.
    //

    tLength = WideCharToMultiByte(  CP_ACP,
                                    0,
                                    &(threadAttr->AttributeNameW[0]),
                                    -1,
                                    (PCHAR) &(threadAttr->AttributeName[0]),
                                    MAX_ATTRIBUTE_NAME_LENGTH - 1,
                                    NULL,
                                    NULL );

    threadAttr->AttributeName[tLength-1] = '\0';

    if (Unicode) {

        results = &(threadAttr->AttributeNameW[0]);

    } else {

        results = (PWCHAR) &(threadAttr->AttributeName[0]);
    }

    //
    //  next up is the actual values for this attribute... we'll leave the
    //  lber object in this state in case they come in for a read.  If they
    //  go to read the attribute that matches the threadAttr->AttributeName,
    //  we'll be right there.
    //

exitGetNextAttr:

    return results;
}

PWCHAR __cdecl
ldap_next_attributeW (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    BerElement      *OpaqueResults
    )
{
    PLDAP_CONN connection = NULL;
    PWCHAR results = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    results = LdapNextAttribute( connection,
                                 Message,
                                 OpaqueResults,
                                 TRUE );

    DereferenceLdapConnection( connection );

    return results;
}

PCHAR __cdecl
ldap_next_attribute (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    BerElement      *OpaqueResults
    )
{
    PLDAP_CONN connection = NULL;
    PCHAR results = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    results = (PCHAR) LdapNextAttribute( connection,
                                         Message,
                                         OpaqueResults,
                                         FALSE );

    DereferenceLdapConnection( connection );

    return results;
}

PCHAR __cdecl
ldap_next_attributeA (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    BerElement      *OpaqueResults
    )
{
    PLDAP_CONN connection = NULL;
    PCHAR results = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    results = (PCHAR) LdapNextAttribute( connection,
                                         Message,
                                         OpaqueResults,
                                         FALSE );

    DereferenceLdapConnection( connection );

    return results;
}


ULONG LdapGoToFirstAttribute (
    PLDAP_CONN Connection,
    CLdapBer *Lber
    )
//
//  This resets the parsing of the message and goes to the first attribute
//
{
    ULONG hr;
    ULONG tag = BER_INVALID_TAG;

    Lber->Reset(FALSE);

    hr = Lber->HrStartReadSequence(BER_SEQUENCE);
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapFirstAttr 1 conn 0x%x received protocol error 0x%x .\n",
                            Connection, hr);
        }
        return(LDAP_DECODING_ERROR);
    }

    hr = Lber->HrSkipElement();     // skip the message number
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapFirstAttr 2 conn 0x%x received protocol error 0x%x .\n",
                            Connection, hr);
        }
        return(LDAP_DECODING_ERROR);
    }

    hr = Lber->HrPeekTag( &tag );
    ASSERT( hr == NOERROR );

    //
    //  if this is a UDP connection, skip the DN if specified.
    //

    if ((Connection->UdpHandle != INVALID_SOCKET) &&
        (Connection->publicLdapStruct.ld_version == LDAP_VERSION2) &&
        (tag == BER_OCTETSTRING)) {

        hr = Lber->HrSkipElement();
        if ( hr != NOERROR ) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapFirstAttr 8 conn 0x%x received protocol error 0x%x .\n",
                                Connection, hr);
            }
            return(LDAP_DECODING_ERROR);
        }

        hr = Lber->HrPeekTag( &tag );
        ASSERT( hr == NOERROR );
    }

    if (tag == BER_SEQUENCE) {

        hr = Lber->HrStartReadSequence(tag);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapFirstAttr 3 conn 0x%x received protocol error 0x%x .\n",
                              Connection, hr);
            }
            return(LDAP_DECODING_ERROR);
        }

        hr = Lber->HrPeekTag( &tag );
        ASSERT( hr == NOERROR );
    }

    //
    //  start reading the actual result sequence
    //

    hr = Lber->HrStartReadSequence(LDAP_RES_SEARCH_ENTRY);

    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapFirstAttr 4 conn 0x%x received protocol error 0x%x .\n",
                            Connection, hr);
        }
        return(LDAP_DECODING_ERROR);
    }

    hr = Lber->HrPeekTag( &tag );
    ASSERT( hr == NOERROR );

    if (tag == BER_SEQUENCE) {

        hr = Lber->HrStartReadSequence(tag);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapFirstAttr 5 conn 0x%x received protocol error 0x%x .\n",
                                Connection, hr);
            }
            return(LDAP_DECODING_ERROR);
        }
    }

    hr = Lber->HrSkipElement();     // skip the distinguished name
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapFirstAttr 6 conn 0x%x received protocol error 0x%x .\n",
                            Connection, hr);
        }
        return(LDAP_DECODING_ERROR);
    }

    hr = Lber->HrStartReadSequence();

    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapFirstAttr 7 conn 0x%x received protocol error 0x%x .\n",
                            Connection, hr);
        }
        return(LDAP_DECODING_ERROR);
    }

    return LDAP_SUCCESS;
}

// attrib.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\autorec.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    receive.c    receive data from an LDAP server

Abstract:

   This module implements auto reconnect to an LDAP server

Author:

    Andy Herron    (andyhe)        07-Oct-1997
    Anoop Anantha  (AnoopA)        24-Jun-1998


Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

#define RECONNECT_INTERVAL 5000  // min autoreconnect interval (millisecs)

ULONG
LdapResendRequests (
    PLDAP_CONN Connection
    );

ULONG
FreeMessagesFromConnection (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection
    );

ULONG
LdapAutoReconnect (
    PLDAP_CONN Connection
    )
//
//  The connection has a reference we need to clear when we're done with it.
//  Also, the Connection->ReconnectLock should be held before coming in here
//  and Connection->HostConnectState must be set to HostConnectStateReconnecting.
//
{
    ULONG err = LDAP_SERVER_DOWN;
    PCHAR copyOfPrimaryCreds = NULL;
    ULONG bindMethod;
    BOOLEAN clearPending = FALSE;
    int sockerr = 0;

    ACQUIRE_LOCK( &Connection->StateLock );

    IF_DEBUG(RECONNECT) {
        LdapPrint2( "LdapAutoReconnect trying to reconnect conn 0x%x to %s.\n",
            Connection, Connection->publicLdapStruct.ld_host );
    }

    ASSERT( Connection->AutoReconnect == TRUE );
    
    if (Connection->Reconnecting == TRUE) {
    
        IF_DEBUG(RECONNECT) {
            LdapPrint1( "LdapAutoReconnect conn 0x%x already reconnecting.\n",
                        Connection);
        }
        
        Connection->HostConnectState = HostConnectStateError;
        
        RELEASE_LOCK( &Connection->StateLock );
        goto exitReconnect;
    }

    if (((Connection->HostConnectState != HostConnectStateError) &&
         (Connection->HostConnectState != HostConnectStateReconnecting )) ||
        (Connection->ConnObjectState != ConnObjectActive ) ||
        (Connection->BindInProgress == TRUE) ||
        (Connection->TcpHandle == INVALID_SOCKET)) {

        IF_DEBUG(RECONNECT) {
            LdapPrint1( "LdapAutoReconnect conn 0x%x not in correct state.\n",
                        Connection);
            if ((Connection->HostConnectState != HostConnectStateError) &&
                (Connection->HostConnectState != HostConnectStateReconnecting )) {

                LdapPrint1( "LdapAutoReconnect host state is %u.\n",
                                Connection->HostConnectState);
            }
            if (Connection->ConnObjectState != ConnObjectActive) {
                clearPending = TRUE;
                LdapPrint0( "LdapAutoReconnect connection state is closing.\n");
            }
            if (Connection->BindInProgress) {
                LdapPrint0( "LdapAutoReconnect connection has bind in progress.\n");
            }
            if (Connection->TcpHandle == INVALID_SOCKET) {
                LdapPrint0( "LdapAutoReconnect connection has invalid socket.\n");
            }
        }

        clearPending = TRUE;

        if (Connection->HostConnectState == HostConnectStateReconnecting) {

            Connection->HostConnectState = HostConnectStateError;
        }
        RELEASE_LOCK( &Connection->StateLock );
        goto exitReconnect;
    }

    //
    // Don't reconnect to the server like crazy if it keeps dropping us.
    // We might be on the server's IP deny list.
    //

    if ((Connection->LastReconnectAttempt != 0) &&
        (LdapGetTickCount() - Connection->LastReconnectAttempt < RECONNECT_INTERVAL)) {

        IF_DEBUG(RECONNECT) {
            LdapPrint1( "LdapAutoReconnect conn 0x%x reconnecting too frequently.\n",
                        Connection);
        }
        
        if (Connection->HostConnectState == HostConnectStateReconnecting) {

            Connection->HostConnectState = HostConnectStateError;
        }
        
        RELEASE_LOCK( &Connection->StateLock );
        goto exitReconnect;
    }
    
    //
    //  the only time we should get here is if we're in a reconnecting state
    //  not during a bind and not during a close.
    //

    ASSERT( Connection->HostConnectState == HostConnectStateReconnecting );

    Connection->ServerDown = FALSE;
    Connection->Reconnecting = TRUE;
    Connection->BindInProgress = FALSE;

    RELEASE_LOCK( &Connection->StateLock );

    //
    //  reset back to a basic state
    //

    BeginSocketProtection( Connection );

    sockerr = (*pclosesocket)(Connection->TcpHandle);
    ASSERT(sockerr == 0);
    
    Connection->TcpHandle = (*psocket)(PF_INET, SOCK_STREAM, 0);

    EndSocketProtection( Connection );

    if (Connection->TcpHandle == INVALID_SOCKET) {

        IF_DEBUG(RECONNECT) {
            LdapPrint1( "LdapAutoReconnect conn 0x%x could not reopen socket.\n",
                        Connection);
        }
        clearPending = TRUE;
        ACQUIRE_LOCK( &Connection->StateLock );
        Connection->HostConnectState = HostConnectStateError;
        Connection->Reconnecting = FALSE;
        Connection->ServerDown = TRUE;
        RELEASE_LOCK( &Connection->StateLock );
        goto exitReconnect;
    }

    if (Connection->PendingMessage != NULL) {

        CLdapBer *lber = (CLdapBer *) Connection->PendingMessage->lm_ber;

        if (lber != NULL) {

            delete lber;
        }
        ldapFree( Connection->PendingMessage, LDAP_MESG_SIGNATURE );
        Connection->PendingMessage = NULL;
    }

    if (Connection->SecureStream != NULL) {
        
        delete ((PSECURESTREAM) Connection->SecureStream) ;
        Connection->SecureStream = NULL;
    }
    Connection->CurrentSignStatus= FALSE;
    Connection->CurrentSealStatus= FALSE;

    Connection->LastReconnectAttempt = LdapGetTickCount();

    err = LdapConnect( Connection, NULL, TRUE );

    if (err != 0) {

        IF_DEBUG(RECONNECT) {
            LdapPrint1( "LdapAutoReconnect failed to connect, err 0x%x.\n", err);
        }

        ACQUIRE_LOCK( &Connection->StateLock );
        Connection->HostConnectState = HostConnectStateError;
        Connection->Reconnecting = FALSE;
        RELEASE_LOCK( &Connection->StateLock );

        SetEvent( Connection->ConnectEvent );
        err = LDAP_UNAVAILABLE;
        clearPending = TRUE;
        goto exitReconnect;
    }

    //
    //  send bind request
    //

    ACQUIRE_LOCK( &Connection->StateLock );
    bindMethod = Connection->BindMethod;
    RELEASE_LOCK( &Connection->StateLock );

    
    if (bindMethod != 0) {

        ACQUIRE_LOCK( &Connection->StateLock );
        
        PLDAPDN dnOnBind = Connection->DNOnBind;

        //
        // Unscramble the credentials
        //

        PWCHAR creds = Connection->CurrentCredentials;
        UNICODE_STRING OldScrambledCreds;

        ACQUIRE_LOCK( &Connection->ScramblingLock );

        if ( GlobalUseScrambling && Connection->Scrambled && Connection->CurrentCredentials) {

           DecodeUnicodeString(&Connection->ScrambledCredentials);
           Connection->Scrambled = FALSE;
        }

        OldScrambledCreds = Connection->ScrambledCredentials;

        RELEASE_LOCK( &Connection->ScramblingLock );


        Connection->CurrentCredentials = NULL;
        Connection->DNOnBind = NULL;

        RELEASE_LOCK( &Connection->StateLock );

        err = LdapBind( Connection,
                        dnOnBind,
                        bindMethod,
                        creds,
                        TRUE          // Synchronous
                        );

        IF_DEBUG(RECONNECT) {
            LdapPrint2( "LdapAutoReconnect: Bind to host %s returned 0x%x\n",
                    Connection->publicLdapStruct.ld_host, err );
        }

        //
        // If rebind fails for any reason other than auth failure,
        // restore the old credentials.
        //

        if (( err != LDAP_SUCCESS ) &&
            ( !LdapAuthError( err ) )) {

            ACQUIRE_LOCK( &Connection->StateLock );
            Connection->BindMethod = bindMethod;
            Connection->DNOnBind = dnOnBind;
            Connection->CurrentCredentials = creds;

            //
            // Rescramble the credentials
            //

            ACQUIRE_LOCK( &Connection->ScramblingLock );

            Connection->ScrambledCredentials = OldScrambledCreds;

            if ( GlobalUseScrambling && !Connection->Scrambled && Connection->CurrentCredentials) {

               EncodeUnicodeString(&Connection->ScrambledCredentials);
               Connection->Scrambled = TRUE;
            }

            RELEASE_LOCK( &Connection->ScramblingLock );
            RELEASE_LOCK( &Connection->StateLock );


        } else {

            //
            // We either succeeded or we got a real authentication error.
            // So, we free the credentials. If it succeeded, LdapBind() would
            // have made a copy. If failed, we don't want these credentials.
            //

            if (creds != NULL) {

                ULONG tag;

                if ( bindMethod == LDAP_AUTH_SIMPLE ) {

                    tag = LDAP_CREDENTIALS_SIGNATURE;

                } else {

                    tag = LDAP_SECURITY_SIGNATURE;
                }

                ldapFree( creds, tag );
            }

            ldapFree( dnOnBind, LDAP_USER_DN_SIGNATURE );
        }


        if ( err != LDAP_SUCCESS ) {

            //
            //  bummer... we couldn't reauthenticate as the user.  Oh well.
            //

            IF_DEBUG(RECONNECT) {
                LdapPrint2( "LdapAutoReconnect conn 0x%x could not bind, err = 0x%x\n",
                            Connection, err );
            }

            ACQUIRE_LOCK( &Connection->StateLock );
            Connection->HostConnectState = HostConnectStateError;
            Connection->Reconnecting = FALSE;
            Connection->ServerDown = TRUE;

            //
            // Make sure we don't try to reconnect again because we don't have
            // the original bind credentials anymore.
            //

            if (LdapAuthError(err)) {
                Connection->AutoReconnect = FALSE;
            }
            RELEASE_LOCK( &Connection->StateLock );

            SetEvent( Connection->ConnectEvent );
            clearPending = TRUE;
            goto exitReconnect;
        }
    }

    err = LdapResendRequests( Connection );

    ACQUIRE_LOCK( &Connection->StateLock );
    Connection->Reconnecting = FALSE;
    RELEASE_LOCK( &Connection->StateLock );
    SetEvent( Connection->ConnectEvent );

    if (err != LDAP_SUCCESS) {

        clearPending = TRUE;
    }

exitReconnect:

    if (clearPending) {

        LdapPrint2("Autoreconnect failure on connection 0x%x, err is 0x%x\n",Connection, err);
        ClearPendingListForConnection( Connection );
    }

    if (copyOfPrimaryCreds != NULL) {

        ldapFree( copyOfPrimaryCreds, LDAP_SECURITY_SIGNATURE );
    }

    return err;
}

ULONG
LdapResendRequests (
    PLDAP_CONN Connection
    )
{
    //
    //  go through each pending request and search for either primary
    //  requests or referral requests for this connection.
    //

    ULONG err = LDAP_SUCCESS;
    PLDAP_REQUEST request;
    PLIST_ENTRY listEntry;
    PMESSAGE_ID_LIST_ENTRY messageIdsToFree = NULL;
    PMESSAGE_ID_LIST_ENTRY currentNode = NULL;
    CLdapBer *lber;
    ULONG msgId;
    ULONG intermediateErr = LDAP_SUCCESS;

    ACQUIRE_LOCK( &RequestListLock );

    listEntry = GlobalListRequests.Flink;

    while (listEntry != &GlobalListRequests) {

        request = CONTAINING_RECORD( listEntry, LDAP_REQUEST, RequestListEntry );
        request = ReferenceLdapRequest(request);

        if (!request) {
            listEntry = listEntry->Flink;
            continue;
        }

        msgId = 0;
        err = LDAP_SUCCESS;

        ACQUIRE_LOCK( &request->Lock );

        if (Connection == request->PrimaryConnection) {

            if ((request->PagedSearchBlock)  ||
                (request->Abandoned) ||
                (request->ResponsesOutstanding == 0)) {

                //
                // Don't bother to resend this request. This is the original paged search request
                // which we retain as a handle for paging. It does not contain a BER buffer.
                //

                IF_DEBUG(SERVERDOWN) {
                    LdapPrint1("LdapResendRequest: Skipping over paged/abandoned/completed requests 0x%x\n", request);
                }
                RELEASE_LOCK( &request->Lock );
                listEntry = listEntry->Flink;
                DereferenceLdapRequest( request );
                continue;
            }


            //
            //  if we still have ber, we send it off.  If we don't, then we
            //  know that we've already given results to the client.  If it's
            //  not a search, we're done.  If it is a search, then we basically
            //  abandon the request since we've only given partial results.
            //

            msgId = request->MessageId;

            //
            //  grab the ber buffer, send it out if it's there and then put it
            //  back in a safe way.
            //

            lber = (CLdapBer *) InterlockedExchangePointer(  &request->BerMessageSent,
                                                             NULL );
            if ( lber != NULL ) {

                FreeMessagesFromConnection( request, Connection );

                RELEASE_LOCK( &request->Lock );
                RELEASE_LOCK( &RequestListLock );

                //
                // If we keep resending this request, and the server keeps dropping
                // us and forcing us to autoreconnect again, then stop sending this
                // request.  We exempt notification searches from this logic because
                // they can stay around for a long time and in doing so legitimately
                // rack up a large number of reconnects.
                //
                if ((request->NotificationSearch) ||
                    (request->ResentAttempts < GlobalRequestResendLimit)) {

                    request->ResentAttempts++;
                    err = LdapSend( Connection, lber );
                }
                else {
                
                    IF_DEBUG(SERVERDOWN) {
                        LdapPrint1("LdapResendRequest: Request 0x%x has too many resends\n", request);
                    }

                    // this will be picked up below and force a call to SimulateErrorMessage
                    err = LDAP_SERVER_DOWN;
                }
                
                lber = (CLdapBer *) InterlockedExchangePointer((PVOID *)&request->BerMessageSent,
                                                               (PVOID)lber );

                ACQUIRE_LOCK( &RequestListLock );
                ACQUIRE_LOCK( &request->Lock );

                if (lber != NULL) {

                    delete lber;
                }
                
            } else {

                //
                //  We've already received a response for this request.
                //

                err = LDAP_CONNECT_ERROR;

            }

        }

        //
        //  now we go through the referral table for this request...
        //

        PREFERRAL_TABLE_ENTRY refTable = request->ReferralConnections;

        if (refTable != NULL && err == LDAP_SUCCESS) {

            USHORT limit = request->ReferralTableSize;
            USHORT referralCount = 0;

            while (referralCount < limit && err == LDAP_SUCCESS) {

                if (refTable->ReferralServer == Connection) {

                    //
                    //  free all responses that we've received to date for this
                    //  request.
                    //

                    //
                    //  grab the ber buffer, send it out if it's there and then put it
                    //  back in a safe way.
                    //

                    lber = (CLdapBer *) InterlockedExchangePointer(  &refTable->BerMessageSent,
                                                                     NULL );
                    if (lber != NULL) {

                        if (msgId == 0) {       // only free messages once

                            FreeMessagesFromConnection( request, Connection );
                        }

                        RELEASE_LOCK( &request->Lock );
                        RELEASE_LOCK( &RequestListLock );

                        //
                        // If we keep resending this request, and the server keeps dropping
                        // us and forcing us to autoreconnect again, then stop sending this
                        // request.  If the parent of this referral was a notification search,
                        // we exempt it because notification searches can stay around for a long
                        // time.
                        //
                        if ((request->NotificationSearch) ||
                            (refTable->ResentAttempts < GlobalRequestResendLimit)) {

                            refTable->ResentAttempts++;
                            err = LdapSend( Connection, lber );
                        }
                        else {
                        
                            IF_DEBUG(SERVERDOWN) {
                                LdapPrint2("LdapResendRequest: Referral 0x%x for request 0x%x has too many resends\n",
                                            refTable,
                                            request);
                            }

                            err = LDAP_SERVER_DOWN;
                        }

                        ACQUIRE_LOCK( &RequestListLock );
                        ACQUIRE_LOCK( &request->Lock );

                        lber = (CLdapBer *) InterlockedExchangePointer(
                                            (PVOID *) &refTable->BerMessageSent,
                                            (PVOID) lber );

                        if (lber != NULL) {

                            delete lber;
                        }
                    } else {

                        //
                        //  We've already received a response for this request.
                        //

                        err = LDAP_CONNECT_ERROR;
                    }

                    msgId = request->MessageId;
                }
                referralCount++;
                refTable++;
            }
        }

        if (err != LDAP_SUCCESS) {

            ASSERT( msgId != 0 );

            //
            //  either we had problems resending the request or we've already
            //  received a response.  If we've already received a response,
            //  then we need to look at whether or not we've received all the
            //  responses (in which case we don't worry about it) or if we've
            //  only received partial, we close out the request with an error.
            //

            if ((request->Operation != LDAP_SEARCH_CMD) &&
                (err == LDAP_CONNECT_ERROR)) {

                //
                //  we've already received this response.  all is well for
                //  this request.
                //

                err = LDAP_SUCCESS;

            } else {

                //
                //  Either the send failed or it's a search and we've already
                //  given back part of the results.  Either way, we can't
                //  expect a response back, so we'll have to simulate one.
                //

                ULONG simErr = SimulateErrorMessage( Connection,
                                                     request,
                                                     LDAP_SERVER_DOWN
                                                     );
                IF_DEBUG(SERVERDOWN) {
                    LdapPrint2( "ldapResentRequests thread 0x%x simulated down message for connection 0x%x\n",
                                    GetCurrentThreadId(),
                                    Connection );
                }

                if (simErr != LDAP_SUCCESS) {

                    request->Abandoned = TRUE;
                }

                currentNode = (PMESSAGE_ID_LIST_ENTRY) ldapMalloc( sizeof( MESSAGE_ID_LIST_ENTRY ),
                                                               LDAP_MSGID_SIGNATURE );

                if (currentNode != NULL) {

                    currentNode->Next = messageIdsToFree;
                    currentNode->MessageId = msgId;
                    messageIdsToFree = currentNode;
                }

                ClearPendingListForRequest( request );
            }
        }

        //
        // Record the first error we stumble upon. Otherwise, it might get
        // lost as we cycle through the list of requests.
        //

        if (( err != LDAP_SUCCESS ) &&
            ( intermediateErr == LDAP_SUCCESS )) {

            intermediateErr = err;
        }

        RELEASE_LOCK( &request->Lock );

        listEntry = listEntry->Flink;
                
        DereferenceLdapRequest( request );

    }

    RELEASE_LOCK( &RequestListLock );

    //
    //  Now we go through and wake up any threads that are waiting for these
    //  requests.
    //

    if (messageIdsToFree != NULL) {

        ACQUIRE_LOCK( &ConnectionListLock );

        while (messageIdsToFree != NULL) {

            currentNode = messageIdsToFree;
            messageIdsToFree = messageIdsToFree->Next;

            CheckForWaiters( currentNode->MessageId, FALSE, Connection );
            ldapFree( currentNode, LDAP_MSGID_SIGNATURE );
        }

        RELEASE_LOCK( &ConnectionListLock );

        LdapWakeupSelect();
    }

    if (err == LDAP_SERVER_DOWN) {

        IF_DEBUG(SERVERDOWN) {
            LdapPrint2( "ldapResentRequests thread 0x%x has connection 0x%x as down.\n",
                            GetCurrentThreadId(),
                            Connection );
        }
    }

    return  (intermediateErr == LDAP_SUCCESS) ? err : intermediateErr;
}

ULONG
FreeMessagesFromConnection (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection
    )
{
    PLDAPMessage current = Request->MessageLinkedList;
    PLDAPMessage previous = NULL;
    PLDAPMessage next;

    while (current != NULL) {

        //
        //  flatten out the two lists (lm_next and lm_chain) into a single list
        //

        if (current->lm_next != NULL) {

            if (current->lm_chain != NULL) {

                //
                //  append the chain list onto the next list
                //

                next = current->lm_chain;

                while (next->lm_chain != NULL) {
                    next = next->lm_chain;
                }

                next->lm_chain = current->lm_next;

            } else {

                current->lm_chain = current->lm_next;
            }
            current->lm_next = NULL;
        }

        if (current->Connection == Connection->ExternalInfo) {

            //
            //  remove this entry from the list
            //

            next = current->lm_chain;

            if (previous == NULL) {

                Request->MessageLinkedList = next;

            } else {

                previous->lm_chain = next;
            }

            current->lm_chain = NULL;
            ldap_msgfree( current );
            current = next;

        } else {

            previous = current;
            current = current->lm_chain;
        }
    }

    return LDAP_SUCCESS;
}

// autorec.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\add.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    add.cxx handle add requests to an LDAP server

Abstract:

   This module implements the LDAP add APIs.

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG
EncodeAddList (
    CLdapBer *Lber,
    LDAPModW *AttributeList[],
    BOOLEAN Unicode
    );

ULONG
LdapAdd (
    PLDAP_CONN connection,
    PWCHAR DistinguishedName,
    LDAPModW *AttributeList[],
    BOOLEAN Unicode,
    BOOLEAN Synchronous,
    PLDAPControlW *ServerControls,
    PLDAPControlW *ClientControls,
    ULONG   *MessageNumber
    )
//
//  This allows a client to add an entry to the tree.  Note that if Unicode
//  is FALSE, then the AttributeList does not point to a list of Unicode
//  attributes, but rather a list of single byte attributes.
//
{
    PLDAP_REQUEST request = NULL;
    ULONG messageNumber;
    ULONG err;

    ASSERT(connection != NULL);

    if (MessageNumber == NULL) {

        return LDAP_PARAM_ERROR;
    }

    *MessageNumber = (ULONG) -1;

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {
       return err;
    }

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    request = LdapCreateRequest( connection, LDAP_ADD_CMD );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_add connection 0x%x couldn't allocate request.\n", connection);
        }
        err = LDAP_NO_MEMORY;
        SetConnectionError( connection, err, NULL );
        return err;
    }

    messageNumber = request->MessageId;

    request->Synchronous = Synchronous;

    request->add.Unicode = Unicode;

    err = LDAP_SUCCESS;

    if ((ServerControls != NULL) || (ClientControls != NULL)) {

        err = LdapCheckControls( request,
                                 ServerControls,
                                 ClientControls,
                                 Unicode,
                                 0 );

        if (err != LDAP_SUCCESS) {

            IF_DEBUG(CONTROLS) {
                LdapPrint2( "ldap_add connection 0x%x trouble with SControl, err 0x%x.\n",
                            connection, err );
            }
        }
    }

    if (err == LDAP_SUCCESS) {

        if (Synchronous || (request->ChaseReferrals == 0)) {

            request->AllocatedParms = FALSE;
            request->OriginalDN = DistinguishedName;
            request->add.AttributeList = AttributeList;

        } else {

            request->AllocatedParms = TRUE;

            if (DistinguishedName != NULL) {

                request->OriginalDN = ldap_dup_stringW( DistinguishedName, 0, LDAP_UNICODE_SIGNATURE );

                if (request->OriginalDN == NULL) {

                    err = LDAP_NO_MEMORY;
                }
            }
            if ( err == LDAP_SUCCESS ) {

                err = LdapDupLDAPModStructure(  AttributeList,
                                                Unicode,
                                                &request->add.AttributeList );
            }
        }
    }

    if (err == LDAP_SUCCESS) {

        START_LOGGING;
        DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=%d][OP=ldap_add][DN=%ws][ST=%I64d]",
               request->MessageId, DistinguishedName, request->RequestTime));
        LogAttributesAndControls(NULL, AttributeList, ServerControls, Unicode);
        DSLOG((DSLOG_FLAG_NOTIME,"[-]\n"));
        END_LOGGING;

        err = SendLdapAdd(  request,
                            connection,
                            request->OriginalDN,
                            request->add.AttributeList,
                            (CLdapBer **)&request->BerMessageSent,
                            request->add.Unicode,
                            0 );
    }

    if (err != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_add connection 0x%x errored with 0x%x.\n",
                        connection, err );
        }

        DSLOG((0,"[+][ID=%d][ET=%I64d][ER=%d][-]\n",request->MessageId,LdapGetTickCount(), err));

        messageNumber = (ULONG) -1;
        SetConnectionError( connection, err, NULL );

        CloseLdapRequest( request );
    }

    *MessageNumber = messageNumber;

    DereferenceLdapRequest( request );

    return err;
}


ULONG __cdecl
ldap_addW (
    LDAP *ExternalHandle,
    PWCHAR DistinguishedName,
    LDAPModW *AttributeList[]
    )
//
//  This is the client API to allow adding objects to the directory.
//
{
    ULONG err;
    ULONG msgId;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err =  LdapAdd( connection,
                    DistinguishedName,
                    AttributeList,
                    TRUE,
                    FALSE,
                    NULL,
                    NULL,
                    &msgId
                    );

    DereferenceLdapConnection( connection );

    return msgId;
}

ULONG __cdecl
ldap_add (
    LDAP *ExternalHandle,
    PCHAR DistinguishedName,
    LDAPModA *AttributeList[]
    )
//
//  This is the client API to allow adding objects to the directory.
//
{
    ULONG err;
    ULONG msgId = (ULONG) -1;

    err =  ldap_add_extA(   ExternalHandle,
                            DistinguishedName,
                            AttributeList,
                            NULL,
                            NULL,
                            &msgId
                            );
    return msgId;
}

ULONG __cdecl
ldap_add_sW (
    LDAP *ExternalHandle,
    PWCHAR DistinguishedName,
    LDAPModW *AttributeList[]
    )
{
    return ldap_add_ext_sW(  ExternalHandle,
                             DistinguishedName,
                             AttributeList,
                             NULL,
                             NULL
                             );
}

ULONG __cdecl
ldap_add_s (
    LDAP *ExternalHandle,
    PCHAR DistinguishedName,
    LDAPModA *AttributeList[]
    )
//
//  This is the client API to allow adding objects to the directory.
//
{
    return ldap_add_ext_sA( ExternalHandle,
                            DistinguishedName,
                            AttributeList,
                            NULL,
                            NULL
                            );
}

WINLDAPAPI ULONG LDAPAPI ldap_add_extW(
        LDAP *ExternalHandle,
        PWCHAR DistinguishedName,
        LDAPModW *AttributeList[],
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           *MessageNumber
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        return LDAP_PARAM_ERROR;
    }

    err =  LdapAdd( connection,
                    DistinguishedName,
                    AttributeList,
                    TRUE,
                    FALSE,
                    ServerControls,
                    ClientControls,
                    MessageNumber
                    );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_add_extA
(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        LDAPModA *AttributeList[],
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        ULONG           *MessageNumber
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (MessageNumber == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *MessageNumber = (ULONG) -1;

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        goto error;
    }

    err = LdapAdd( connection,
                   wName,
                   (LDAPModW **)AttributeList,
                   FALSE,
                   FALSE,
                   (PLDAPControlW *) ServerControls,
                   (PLDAPControlW *) ClientControls,
                   MessageNumber
                   );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_add_ext_sW(
        LDAP *ExternalHandle,
        PWCHAR DistinguishedName,
        LDAPModW *AttributeList[],
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls
        )
{
    ULONG msgId;
    ULONG err;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err =   LdapAdd( connection,
                     DistinguishedName,
                     AttributeList,
                     TRUE,
                     TRUE,
                     ServerControls,
                     ClientControls,
                     &msgId
                     );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                      );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     results,
                                     TRUE
                                     );
        }
    }

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_add_ext_sA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        LDAPModA *AttributeList[],
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    ULONG msgId;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    err = LdapAdd(   connection,
                     wName,
                     (LDAPModW **)AttributeList,
                     FALSE,
                     TRUE,
                     (PLDAPControlW *) ServerControls,
                     (PLDAPControlW *) ClientControls,
                     &msgId
                     );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                    );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     results,
                                     TRUE
                                     );
        }
    }

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    DereferenceLdapConnection( connection );

    return err;
}


ULONG
SendLdapAdd (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection,
    PWCHAR DistinguishedName,
    LDAPModW *AttributeList[],
    CLdapBer **Lber,
    BOOLEAN Unicode,
    LONG AltMsgId
    )
//
//  This allows a client to add an entry to the tree.  Note that if Unicode
//  is FALSE, then the AttributeList does not point to a list of Unicode
//  attributes, but rather a list of single byte attributes.
//
{
    ULONG hr;

    if ( (Connection->publicLdapStruct.ld_version == LDAP_VERSION2) &&
         ( LdapCheckForMandatoryControl( Request->ServerControls ) == TRUE )) {

        IF_DEBUG(CONTROLS) {
            LdapPrint1( "SendLdapAdd Connection 0x%x has mandatory controls.\n", Connection);
        }
        SetConnectionError( Connection, LDAP_UNAVAILABLE_CRIT_EXTENSION, NULL );
        return LDAP_UNAVAILABLE_CRIT_EXTENSION;
    }

    CLdapBer *lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {
        SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
        return LDAP_NO_MEMORY;
    }

    //
    //  The request looks like the following :
    //
    //     AddRequest ::=
    //         [APPLICATION 8] SEQUENCE {
    //              entry          LDAPDN,
    //              attrs          SEQUENCE OF SEQUENCE {
    //                                  type          AttributeType,
    //                                  values        SET OF AttributeValue
    //                             }
    //         }
    //

    hr = lber->HrStartWriteSequence();
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_add startWrite conn 0x%x encoding error of 0x%x.\n",
                        Connection, hr );
        }
        goto encodingError;

    } else {            // we can't forget EndWriteSequence

       if (AltMsgId != 0) {

          hr = lber->HrAddValue((LONG) AltMsgId );

       } else {

          hr = lber->HrAddValue((LONG) Request->MessageId );
       }

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_add MsgNo conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;
        }

        hr = lber->HrStartWriteSequence(LDAP_ADD_CMD);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_add cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;

        } else {        // we can't forget EndWriteSequence

            hr = lber->HrAddValue((const WCHAR *) DistinguishedName );
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_add DN conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto encodingError;
            }

            //
            //  add the attribute list and we're done.
            //

            hr = lber->HrStartWriteSequence();
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_add attrlist conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto encodingError;

            } else {        // we can't forget EndWriteSequence

                hr = EncodeAddList( lber, AttributeList, Unicode );

                if (hr != LDAP_SUCCESS) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "ldap_add attrlist conn 0x%x encoding error of 0x%x.\n",
                                    Connection, hr );
                    }
                    if (lber != NULL) {
                        delete lber;
                    }
                    return hr;
                }

                hr = lber->HrEndWriteSequence();
                ASSERT( hr == NOERROR );
            }

            hr = lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );
        }

        //
        //  put in the server controls here if required
        //

        if ( (Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
             ( Request->ServerControls != NULL )) {

            hr = InsertServerControls( Request, Connection, lber );

            if (hr != LDAP_SUCCESS) {

                if (lber != NULL) {
                    delete lber;
                }
                return hr;
            }
        }

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );
    }

    //
    //  send the search request.
    //

    ACQUIRE_LOCK( &Connection->ReconnectLock );

    AddToPendingList( Request, Connection );

    hr = LdapSend( Connection, lber );

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_add connection 0x%x send with error of 0x%x.\n",
                        Connection, hr );
        }
        
        DecrementPendingList( Request, Connection );

    } else {

        //
        //  Save off the lber value, free any lber message that is already
        //  present.
        //

        lber = (CLdapBer *) InterlockedExchangePointer(  (PVOID *) Lber,
                                                         (PVOID) lber );
    }

    RELEASE_LOCK( &Connection->ReconnectLock );

    if (lber != NULL) {

       delete lber;
    }

    return hr;

encodingError:

    if (lber != NULL) {
        delete lber;
    }

    return LDAP_ENCODING_ERROR;
}



ULONG
EncodeAddList (
    CLdapBer *Lber,
    LDAPModW *AttributeList[],
    BOOLEAN Unicode
    )
//
//  This routine is used by LdapAdd to copy a list of LDAPMOD records
//  to an outgoing message.  It is a different BER structure than LdapModify
//  uses.
//
//              attrs          SEQUENCE OF SEQUENCE {
//                                  type          AttributeType,
//                                  values        SET OF AttributeValue
//                             }
{
    ULONG count = 0;
    ULONG hr;

    if (AttributeList == NULL) {

        return LDAP_SUCCESS;
    }

    while (AttributeList[count] != NULL) {

        PLDAPModW attr = AttributeList[count];

        hr = Lber->HrStartWriteSequence();
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint1( "ldap_add attrlist 2 encoding error of 0x%x.\n", hr );
            }
            return LDAP_ENCODING_ERROR;
        }

        //
        //  We don't have to worry when adding the attribute
        //  types if we need to convert them to unicode to
        //  preserve any DBCS codes as they should be IA5
        //  attribute names only.
        //

        if (Unicode) {

            hr = Lber->HrAddValue((const WCHAR *) attr->mod_type );

        } else {

            hr = Lber->HrAddValue((const CHAR *) attr->mod_type );
        }
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint1( "ldap_add attrlist 3 encoding error of 0x%x.\n", hr );
            }
            return LDAP_ENCODING_ERROR;
        }

        hr = Lber->HrStartWriteSequence(BER_SET);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint1( "ldap_add attrlist 4 encoding error of 0x%x.\n", hr );
            }
            return LDAP_ENCODING_ERROR;
        }

        //
        //  the attribute value is either a string or a ptr to
        //  a berval structure.  Handle appropriately.
        //

        if (attr->mod_op & LDAP_MOD_BVALUES) {

            //
            //  array of berval structures, put each one into request
            //

            if (attr->mod_vals.modv_bvals != NULL) {

                ULONG valCount = 0;

                while (attr->mod_vals.modv_bvals[valCount]) {

                    PLDAP_BERVAL berValue = attr->mod_vals.modv_bvals[valCount++];

                    hr = Lber->HrAddBinaryValue((BYTE *) berValue->bv_val,
                                                        berValue->bv_len );
                    if (hr != NOERROR) {

                        IF_DEBUG(PARSE) {
                            LdapPrint1( "ldap_add attrlist 5 encoding error of 0x%x.\n", hr );
                        }
                        return LDAP_ENCODING_ERROR;
                    }
                }
            }

        } else {

            //
            //  array of strings, put each one into request
            //

            if (attr->mod_vals.modv_strvals != NULL) {

                ULONG valCount = 0;

                while (attr->mod_vals.modv_strvals[valCount]) {

                    if (Unicode) {

                        PWCHAR strValue = attr->mod_vals.modv_strvals[valCount++];

                        hr = Lber->HrAddValue((const WCHAR *) strValue );

                    } else {

                        PWCHAR wValue = NULL;
                        PCHAR strValue = ((PLDAPModA)attr)->mod_vals.modv_strvals[valCount++];

                        //
                        //  We need to convert from single byte
                        //  to unicode.  Otherwise we may be
                        //  putting DBCS codes into the UTF8
                        //  stream, which would not be good.
                        //

                        hr = ToUnicodeWithAlloc( strValue,
                                                 -1,
                                                 &wValue,
                                                 LDAP_UNICODE_SIGNATURE,
                                                 LANG_ACP );

                        if (hr == LDAP_SUCCESS) {

                            hr = Lber->HrAddValue((const WCHAR *) wValue );
                        }

                        ldapFree( wValue, LDAP_UNICODE_SIGNATURE );
                    }

                    if (hr != NOERROR) {

                        IF_DEBUG(PARSE) {
                            LdapPrint1( "ldap_add attrlist 6 encoding error of 0x%x.\n", hr );
                        }
                        return LDAP_ENCODING_ERROR;
                    }
                }
            }
        }

        hr = Lber->HrEndWriteSequence();     // BER_SET
        ASSERT( hr == NOERROR );

        hr = Lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );

        count++;
    }

    return LDAP_SUCCESS;
}


ULONG
LdapDupLDAPModStructure (
    LDAPModW *AttributeList[],
    BOOLEAN Unicode,
    LDAPModW **OutputList[]
)
//
//  This routine creates a duplicate of a list of attribute and value pairs
//  so that when we get a referral, we have the original fields to recreate
//  the BER encoded ASN1.
//
{
    ULONG hr = LDAP_SUCCESS;
    ULONG count = 0;
    PLDAPModW *newAttrList = NULL;

    *OutputList = NULL;

    if (AttributeList == NULL) {

        return hr;
    }

    while (AttributeList[count] != NULL) {

        count++;
    }

    count++;

    newAttrList = (PLDAPModW *) ldapMalloc( count * sizeof( PLDAPModW ),
                                            LDAP_ATTRIBUTE_MODIFY_SIGNATURE );

    if (newAttrList == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint0( "LdapDupLDAPModStructure 1 could not allocate memory.\n",  );
        }
        return LDAP_NO_MEMORY;
    }

    count = 0;

    while (AttributeList[count] != NULL) {

        PLDAPModW attr = AttributeList[count];
        PLDAPModW newAttr;

        newAttr = (PLDAPModW) ldapMalloc( sizeof( LDAPModW ), LDAP_ATTRIBUTE_MODIFY_SIGNATURE );

        if (newAttr == NULL) {

            IF_DEBUG(OUTMEMORY) {
                LdapPrint0( "LdapDupLDAPModStructure 2 could not allocate memory.\n",  );
            }
            hr = LDAP_NO_MEMORY;
            goto exitWithError;
        }

        newAttrList[count++] = newAttr;
        newAttr->mod_op = attr->mod_op;

        if (attr->mod_type != NULL) {

            if (Unicode) {

                newAttr->mod_type = ldap_dup_stringW( attr->mod_type,
                                                      0,
                                                      LDAP_UNICODE_SIGNATURE );

            } else {

                newAttr->mod_type = (PWCHAR) ldap_dup_string(
                                                      (PCHAR) attr->mod_type,
                                                      0,
                                                      LDAP_ANSI_SIGNATURE );
            }

            if (newAttr->mod_type == NULL) {

                IF_DEBUG(OUTMEMORY) {
                    LdapPrint0( "LdapDupLDAPModStructure 3 could not allocate memory.\n",  );
                }
                hr = LDAP_NO_MEMORY;
                goto exitWithError;
            }
        }

        //
        //  the attribute value is either a string or a ptr to
        //  a berval structure.  Handle appropriately.
        //

        if (attr->mod_op & LDAP_MOD_BVALUES) {

            //
            //  array of berval structures, allocate a copy of each one
            //

            if (attr->mod_vals.modv_bvals != NULL) {

                ULONG valCount = 0;

                while (attr->mod_vals.modv_bvals[valCount]) {

                    valCount++;
                }

                valCount++;

                newAttr->mod_vals.modv_bvals = (PLDAP_BERVAL *) ldapMalloc(
                             valCount * sizeof( PLDAP_BERVAL ),
                            LDAP_MOD_VALUE_SIGNATURE );

                if (newAttr->mod_vals.modv_bvals == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint0( "LdapDupLDAPModStructure 4 could not allocate memory.\n",  );
                    }
                    hr = LDAP_NO_MEMORY;
                    goto exitWithError;
                }

                PLDAP_BERVAL newBerVals = (PLDAP_BERVAL) ldapMalloc(
                                valCount * sizeof( LDAP_BERVAL ),
                                LDAP_MOD_VALUE_SIGNATURE );

                if (newBerVals == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint0( "LdapDupLDAPModStructure 5 could not allocate memory.\n",  );
                    }
                    hr = LDAP_NO_MEMORY;
                    goto exitWithError;
                }

                valCount = 0;

                while (attr->mod_vals.modv_bvals[valCount]) {

                    newAttr->mod_vals.modv_bvals[valCount] = newBerVals;

                    PLDAP_BERVAL berValue = attr->mod_vals.modv_bvals[valCount++];

                    newBerVals->bv_len = berValue->bv_len;

                    if ((berValue->bv_val != NULL) &&
                        (berValue->bv_len != 0)) {

                        newBerVals->bv_val = (PCHAR) ldapMalloc(
                                    berValue->bv_len,
                                    LDAP_MOD_VALUE_BERVAL_SIGNATURE );

                        if (newBerVals->bv_val == NULL) {

                            IF_DEBUG(OUTMEMORY) {
                                LdapPrint0( "LdapDupLDAPModStructure 6 could not allocate memory.\n",  );
                            }
                            hr = LDAP_NO_MEMORY;
                            goto exitWithError;
                        }

                        CopyMemory( newBerVals->bv_val,
                                    berValue->bv_val,
                                    berValue->bv_len );
                    }
                    newBerVals++;
                }
            }

        } else {

            //
            //  array of strings, allocate a copy of each one
            //

            if (attr->mod_vals.modv_strvals != NULL) {

                ULONG valCount = 0;

                while (attr->mod_vals.modv_strvals[valCount]) {

                    valCount++;
                }

                valCount++;

                newAttr->mod_vals.modv_strvals = (PWCHAR *) ldapMalloc(
                             valCount * sizeof( PWCHAR ),
                            LDAP_MOD_VALUE_SIGNATURE );

                if (newAttr->mod_vals.modv_strvals == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint0( "LdapDupLDAPModStructure 7 could not allocate memory.\n",  );
                    }
                    hr = LDAP_NO_MEMORY;
                    goto exitWithError;
                }

                valCount = 0;

                while (attr->mod_vals.modv_strvals[valCount]) {

                    if (Unicode) {

                        PWCHAR strValue = attr->mod_vals.modv_strvals[valCount];

                        newAttr->mod_vals.modv_strvals[ valCount ] =
                            ldap_dup_stringW(   strValue,
                                                0,
                                                LDAP_UNICODE_SIGNATURE );

                    } else {

                        PCHAR strValue = (PCHAR) attr->mod_vals.modv_strvals[valCount];

                        newAttr->mod_vals.modv_strvals[ valCount ] = (PWCHAR)
                            ldap_dup_string(    strValue,
                                                0,
                                                LDAP_ANSI_SIGNATURE );
                    }


                    if ( newAttr->mod_vals.modv_strvals[valCount++] == NULL ) {

                        IF_DEBUG(OUTMEMORY) {
                            LdapPrint0( "LdapDupLDAPModStructure 8 could not allocate memory.\n",  );
                        }
                        hr = LDAP_NO_MEMORY;
                        goto exitWithError;
                    }
                }
            }
        }
    }

exitWithError:

    if (hr != LDAP_SUCCESS) {

        LdapFreeLDAPModStructure( newAttrList, Unicode );

    } else {

        *OutputList = newAttrList;
    }

    return hr;
}

VOID
LdapFreeLDAPModStructure (
    PLDAPModW *AttributeList,
    BOOLEAN Unicode
    )
{
    ULONG count = 0;

    if (AttributeList == NULL) {

        return;
    }

    while (AttributeList[count] != NULL) {

        PLDAPModW attr = AttributeList[count++];

        if (attr->mod_type != NULL) {

            if (Unicode) {

                ldapFree( attr->mod_type, LDAP_UNICODE_SIGNATURE );

            } else {

                ldapFree( attr->mod_type, LDAP_ANSI_SIGNATURE );
            }
        }

        //
        //  the attribute value is either a string or a ptr to
        //  a berval structure.  Handle appropriately.
        //

        if (attr->mod_op & LDAP_MOD_BVALUES) {

            //
            //  array of berval structures, free a copy of each one
            //

            if (attr->mod_vals.modv_bvals != NULL) {

                ULONG valCount = 0;

                while (attr->mod_vals.modv_bvals[valCount]) {

                    PLDAP_BERVAL berValue = attr->mod_vals.modv_bvals[valCount++];

                    if (berValue->bv_val != NULL) {

                        ldapFree( berValue->bv_val,
                                    LDAP_MOD_VALUE_BERVAL_SIGNATURE );
                    }
                }

                if (attr->mod_vals.modv_bvals[0] != NULL) {

                    ldapFree( attr->mod_vals.modv_bvals[0], LDAP_MOD_VALUE_SIGNATURE );
                }

                ldapFree( attr->mod_vals.modv_bvals, LDAP_MOD_VALUE_SIGNATURE );
            }

        } else {

            //
            //  array of strings, allocate a copy of each one
            //

            if (attr->mod_vals.modv_strvals != NULL) {

                ULONG valCount = 0;

                while (attr->mod_vals.modv_strvals[valCount]) {

                    if (Unicode) {

                        PWCHAR strValue = attr->mod_vals.modv_strvals[valCount];

                        ldapFree( strValue, LDAP_UNICODE_SIGNATURE );

                    } else {

                        PCHAR strValue = (PCHAR) attr->mod_vals.modv_strvals[valCount];

                        ldapFree( strValue, LDAP_ANSI_SIGNATURE );
                    }
                    valCount++;
                }

                ldapFree( attr->mod_vals.modv_strvals, LDAP_MOD_VALUE_SIGNATURE );
            }
        }

        ldapFree( attr, LDAP_ATTRIBUTE_MODIFY_SIGNATURE );
    }

    ldapFree( AttributeList, LDAP_ATTRIBUTE_MODIFY_SIGNATURE );

    return;
}

// add.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\cache.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    cache.cxx  RootDSE cache maintencance for the LDAP api

Abstract:

   This module implements routines that maintain the RootDSE cache

Author:

    Anoop Anantha (anoopa)        06-Jan-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"


//
// The attribute cache itself is a two dimensional array of the form shown
// below. We have a hardcoded list of attributes we can cache. To add another
// cacheable item, simply add it to the list below. Keep in mind that the total
// size of the attribute+values must not exceed INITIAL_MAX_RECEIVE_BUFFER.
//

static PWCHAR CachedAttributeList[] = {
                                L"subschemaSubentry",
                                L"dsServiceName",
                                L"namingContexts",
                                L"defaultNamingContext",
                                L"schemaNamingContext",
                                L"configurationNamingContext",
                                L"rootDomainNamingContext",
                                L"supportedControl",
                                L"supportedLDAPVersion",
                                L"supportedLDAPPolicies",
                                L"supportedSASLMechanisms",
                                L"dnsHostName",
                                L"ldapServiceName",
                                L"serverName",
                                L"supportedCapabilities",
                                NULL
                        };

#define NUM_CACHED_ATTR  ((sizeof(CachedAttributeList)/sizeof(PWCHAR))-1)

//
// The CACHEHOLDER is considered as one CachePage. This is dynamically
// allocated on a per server basis. Since we can't have multidimensional
// arrays with different data types in each dimension, we have to play
// some tricks here by using the second row of the cache as PWCHAR*
// instead of PWCHAR. This is because an attribute can be multivalued.
//

typedef struct _CACHEHOLDER {

    LONG        RefCount;            // This CachePage is referenced, do not delete
    PWCHAR      ServerName;          // The name of the server
    USHORT      PortNumber;          // Target port number on the server
    ULONGLONG   CreateTime;          // Timestamp of cachepage creation
    ULONGLONG   LastAccessTime;
    PWCHAR      CacheTemplate[2][NUM_CACHED_ATTR];// points to an array of CachedAttributeList

} CACHEHOLDER, *PCACHEHOLDER;


#define CacheStateCacheHit                          0
#define CacheStateStaleCache                        1
#define CacheStateServerNotCached                   2
#define CacheStateNonCachableAttribute              3

//
// Maximum number of servers whose RootDSEs we are willing to cache
//

#define MAX_CACHE_SIZE          5
#define CACHE_TIMEOUT           900000   // 15 minutes in millisecs

//
// RootDSE cache holder. Currently, we have place for holding upto
// MAX_CACHE_SIZE servers.
//

PCACHEHOLDER CacheArray[MAX_CACHE_SIZE];


BOOLEAN
ValidateServerReturnedAttrList(
    PLDAP_CONN   Connection,
    PLDAPMessage message
    );


VOID
InitializeLdapCache (
   VOID
   )
{
    ACQUIRE_LOCK( &CacheLock );

    for (int i=0; i< MAX_CACHE_SIZE; i++) {

        CacheArray[i] = NULL;
    }

    RELEASE_LOCK( &CacheLock );

}


VOID
FreeCachePage(
   PCACHEHOLDER CachePage
   )
{
    //
    // The CacheLock must be held coming in here !
    //

    if ( CachePage == NULL) {

        return;
    }

    ldapFree( CachePage->ServerName, LDAP_HOST_NAME_SIGNATURE);

    for (int i=0; i<NUM_CACHED_ATTR; i++) {

        ldapFree( CachePage->CacheTemplate[0][i], LDAP_VALUE_SIGNATURE);
        PWCHAR *CurrentVal = (PWCHAR*) CachePage->CacheTemplate[1][i];

        if (CurrentVal != NULL) {

            for (int j=0; (CurrentVal[j]!= NULL) ; j++) {

                ldapFree( CurrentVal[j], LDAP_VALUE_SIGNATURE );
            }

            ldapFree( CurrentVal, LDAP_VALUE_LIST_SIGNATURE );
        }
    }

    ldapFree( CachePage, LDAP_VALUE_SIGNATURE );
}


VOID
FreeEntireLdapCache(
   VOID
   )
{
    //
    // The CacheLock must be held coming in here !
    //

    for (int i=0; i<MAX_CACHE_SIZE; i++) {

        if ( CacheArray[i] != NULL) {

            FreeCachePage( CacheArray[i] );
            CacheArray[i] = NULL;
        }
    }
}


ULONG
AllAttributesAreCacheable (
   PLDAP_CONN Connection,
   PWCHAR  AttributeList[],
   BOOLEAN Unicode
   )
{
    //
    // Scan through the list of attributes to determine if ALL of them are
    // cacheable. Even if one of them isn't cacheable, we return
    // CacheStateNonCachableAttribute. We then check to see if our local
    // cached copy is valid.
    //
    // Possible return values are:
    //          CacheStateNonCachableAttribute
    //          CacheStateCacheHit
    //          CacheStateStaleCache
    //          CacheStateServerNotCached
    //          other failure errors
    //

    PWCHAR* CurrentAttribute = AttributeList;
    PWCHAR* stdattr = CachedAttributeList;
    int i, err;

    if (!CurrentAttribute ) {

        return CacheStateNonCachableAttribute;
    }

    while (*CurrentAttribute != NULL) {

        //
        // As a temp measure, convert the attribute list to unicode before
        // the comparision. We will have to remove this conversion later due
        // to performance reasons.
        //

        PWCHAR wAttr = NULL;

        if (!Unicode) {

            err = ToUnicodeWithAlloc( (PCHAR) *CurrentAttribute,
                                      -1,
                                      &wAttr,
                                      LDAP_UNICODE_SIGNATURE,
                                      LANG_ACP
                                      );
        }

        while (*stdattr != NULL) {

            if (ldapWStringsIdentical((Unicode ? *CurrentAttribute : wAttr ),
                                      -1,
                                      *stdattr,
                                      -1 )) {
                //
                // Match found. Proceed to the next attribute on the list
                //

                IF_DEBUG(CACHE) {
                    LdapPrint1("Yes, %S is a cacheable attribute\n", (Unicode ? *CurrentAttribute : wAttr ));
                }
                stdattr = CachedAttributeList;
                CurrentAttribute++;
                break;
            }

            stdattr++;
        }

        ldapFree( wAttr, LDAP_UNICODE_SIGNATURE );

        if (*stdattr == NULL) {
            //
            // We have exhausted the list. We didn't find a match.
            //
            IF_DEBUG(CACHE) {
                LdapPrint0("Sorry, atleast one attribute is not cacheable\n");
            }
            return CacheStateNonCachableAttribute;
        }
    }

    ACQUIRE_LOCK( &CacheLock );

    for (i=0; i<MAX_CACHE_SIZE; i++) {


        if (CacheArray[i] != NULL) {

            IF_DEBUG(CACHE) {
                LdapPrint2("Comparing current server %S with cached server %S\n", Connection->DnsSuppliedName, CacheArray[i]->ServerName);
            }

            if (ldapWStringsIdentical( Connection->DnsSuppliedName,
                                       -1,
                                       CacheArray[i]->ServerName,
                                       -1
                                       ) &&
                (CacheArray[i]->PortNumber == Connection->PortNumber)) {

                if ((LdapGetTickCount() - CacheArray[i]->CreateTime) < CACHE_TIMEOUT) {

                    IF_DEBUG(CACHE) {
                        LdapPrint0("AllAttributesAreCacheable: Returning CACHE HIT..\n");
                    }

                    //
                    // Reference the cache page so that it is not replaced.
                    //

                    CacheArray[i]->RefCount++;

                    //
                    // Update the last accessed time.
                    //

                    CacheArray[i]->LastAccessTime = LdapGetTickCount();

                    RELEASE_LOCK( &CacheLock );
                    return CacheStateCacheHit;

                } else {

                    IF_DEBUG(CACHE) {
                        LdapPrint0("AllAttributesAreCacheable: Returning STALE CACHE..\n");
                    }
                    RELEASE_LOCK( &CacheLock );
                    return CacheStateStaleCache;
                }
            }
        }
    }

    RELEASE_LOCK( &CacheLock );

    IF_DEBUG(CACHE) {
        LdapPrint0("AllAttributesAreCacheable: Returning SERVER NOT CACHED!..\n");
    }

    return CacheStateServerNotCached;
}

ULONG
AccessLdapCache (
    IN PLDAP_REQUEST Request,
    IN PLDAP_CONN Connection,
    IN PWCHAR  DistinguishedName,
    IN ULONG   ScopeOfSearch,
    IN PWCHAR  SearchFilter,
    IN PWCHAR  AttributeList[],
    IN ULONG   AttributesOnly,
    IN BOOLEAN Unicode
    )
{
    //
    // We try to see if we already have an unexpired copy of the data in
    // our local cache. If so, we return it and update the access time, mark the
    // request as cached and return. Remember that we must also fill up the buffers
    // of the request with the fabricated LDAP message.
    //
    //
    // We should check to see if ALL of the requested attributes are among the cached
    // attributes. If even one of them is not present, we have to send out a search
    // with ALL attributes and refresh the cache in the process.
    //
    // Since this is a Quick 'n Dirty cache, we have a preconfigured set of attributes
    // which we will cache for each server.
    //
    // subschemaSubentry:
    // dsServiceName:
    // namingContexts:
    // defaultNamingContext:
    // schemaNamingContext:
    // configurationNamingContext:
    // rootDomainNamingContext:
    // supportedControl:
    // supportedLDAPVersion:
    // supportedLDAPPolicies:
    // supportedSASLMechanisms:
    // dnsHostName:
    // ldapServiceName:
    // serverName:
    // supportedCapabilities:
    //
    //
    // Since we will have marked the request as cacheable, when we retrieve the
    // message in our receive pump, we will have to copy the attributes we care
    // about. If the request is marked as a cache hit, we obviously don't copy
    // the attributes.
    //

    DBG_UNREFERENCED_PARAMETER( AttributesOnly );
    DBG_UNREFERENCED_PARAMETER( SearchFilter );
    DBG_UNREFERENCED_PARAMETER( ScopeOfSearch );
    DBG_UNREFERENCED_PARAMETER( DistinguishedName );

    ULONG err = 0;

    err = AllAttributesAreCacheable( Connection,
                                     AttributeList,
                                     Unicode );

    if (err == CacheStateCacheHit) {

        //
        // This was a perfect cache hit. We have to fabricate the appropriate
        // message and add it to the connection buffers.
        //

            Request->CopyResultToCache = FALSE;
            Request->ResultsAreCached = TRUE;

            err = FabricateLdapResult(
                            Request,
                            Connection,
                            Request->OriginalDN,
                            Request->search.AttributeList,
                            Request->search.Unicode
                            );

    } else {

        if ((err == CacheStateStaleCache) || (err == CacheStateServerNotCached)) {

            //
            // We will replace the attribute list with our own cacheable
            // attribute list so that we can cache most attributes.
            //

            PWCHAR *OrigAttrList = Request->search.AttributeList;
            BOOLEAN OrigUnicode = Request->search.Unicode;
            ULONG  OrigAttributesOnly = Request->search.AttributesOnly;

            Request->search.AttributeList = CachedAttributeList;
            Request->search.AttributesOnly = 0;
            Request->search.Unicode = TRUE;

            err = SendLdapSearch(Request,
                                 Connection,
                                 Request->OriginalDN,
                                 Request->search.ScopeOfSearch,
                                 Request->search.SearchFilter,
                                 Request->search.AttributeList,
                                 Request->search.AttributesOnly,
                                 Request->search.Unicode,
                                 (CLdapBer **)&Request->BerMessageSent,
                                 0 );

            //
            // Restore the saved parameters.
            //

            Request->search.AttributeList = OrigAttrList;
            Request->search.Unicode = OrigUnicode;
            Request->search.AttributesOnly = OrigAttributesOnly;

            Request->CopyResultToCache = TRUE;
            Request->ResultsAreCached = FALSE;

        } else if (err == CacheStateNonCachableAttribute) {

            //
            // Query consists of non-cacheable attribute(s). There is nothing we
            // can do except send the search across unaltered.
            //

            err = SendLdapSearch(Request,
                                 Connection,
                                 Request->OriginalDN,
                                 Request->search.ScopeOfSearch,
                                 Request->search.SearchFilter,
                                 Request->search.AttributeList,
                                 Request->search.AttributesOnly,
                                 Request->search.Unicode,
                                 (CLdapBer **)&Request->BerMessageSent,
                                 0 );
        }

    }

    return err;

}

ULONG
FabricateLdapResult (
    IN PLDAP_REQUEST request,
    IN PLDAP_CONN     Connection,
    IN PWCHAR     DistinguishedName,
    IN PWCHAR     AttributeList[],
    IN BOOLEAN    Unicode
    )
{
    //
    // Create a Ber-encoded message and insert it into the message stream.
    //

    ULONG err = LDAP_SUCCESS;
    CLdapBer *lber = NULL;
    ULONG hr = NO_ERROR;
    PLDAP_RECVBUFFER buffer = NULL;
    int CacheIndex = -1;

    lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "FabricateLdapResult: unable to alloc msg for 0x%x.\n",
                        Connection );
        }

        err = LDAP_NO_MEMORY;
        return err;
    }

    //
    // Depending on the list of requested attributes encode the response
    // message.
    //

    hr = lber->HrStartWriteSequence();      // Start of entire message
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "FabricateLdapResult: startWrite conn 0x%x encoding error of 0x%x.\n",
                        Connection, hr );
        }

        hr = LDAP_ENCODING_ERROR;
        goto returnError;

    } else {            // we can't forget EndWriteSequence

          hr = lber->HrAddValue((LONG) request->MessageId );

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: MsgNo conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;
        }

        hr = lber->HrStartWriteSequence(LDAP_RES_SEARCH_ENTRY);

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;

        }

        hr = lber->HrAddValue((const WCHAR *) DistinguishedName );
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: DN conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;
        }

        //
        // Now, start adding the PartialAttributelist (SEQUENCE OF SEQUENCE)
        //

        hr = lber->HrStartWriteSequence();

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: DN conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;
        }


        if (AttributeList != NULL) {

            ULONG count = 0;
            PWCHAR *CachedValues = NULL;

            while (AttributeList[count] != NULL) {


            if (!RetrieveFromCache( Connection, AttributeList[count], Unicode, &CacheIndex, &CachedValues)) {

                IF_DEBUG(PARSE) {
                    LdapPrint0( "FabricateLdapResult: RetrieveFromCache failed\n");
                }

                hr = LDAP_NO_MEMORY;
                goto returnError;

            } else if ( CachedValues == NULL ) {

                //
                // The server does not contain this attribute. Don't encode it.
                //

                count++;
                continue;
            }


            hr = lber->HrStartWriteSequence();  // This attribute type
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "FabricateLdapResult: DN conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                hr = LDAP_ENCODING_ERROR;
                goto returnError;
            }
                if (Unicode) {

                    hr = lber->HrAddValue((const WCHAR *) AttributeList[count]);

                } else {

                    hr = lber->HrAddValue((const CHAR *) AttributeList[count]);
                }

                if (hr != NOERROR) {
                    IF_DEBUG(PARSE) {
                        if (Unicode) {
                            IF_DEBUG(CACHE) {
                                LdapPrint3( "FabricateLdapResult: conn 0x%x encoding error of 0x%x, attr = %S.\n",
                                        Connection, hr, AttributeList[count] );
                            }
                        } else {
                            IF_DEBUG(CACHE) {
                                LdapPrint3( "FabricateLdapResult: conn 0x%x encoding error of 0x%x, attr = %s.\n",
                                        Connection, hr, AttributeList[count] );
                            }
                        }
                    }
                    hr = LDAP_ENCODING_ERROR;
                    goto returnError;
                }

                //
                // Here, we encode the value list returned from the cache. Remember
                // that a given attribute type (like supportedcontrols) might be
                // multi-valued.
                //

                hr = lber->HrStartWriteSequence(BER_SET);

                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                                    Connection, hr );
                    }
                    hr = LDAP_ENCODING_ERROR;
                    goto returnError;

                }

                ULONG newcount = 0;

                while (CachedValues[newcount] != NULL) {

                    hr = lber->HrAddValue((const WCHAR *) CachedValues[newcount]);

                    if (hr != NOERROR) {

                        IF_DEBUG(PARSE) {
                            LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                                        Connection, hr );
                        }
                        hr = LDAP_ENCODING_ERROR;
                        goto returnError;

                    }

                    //
                    // Free the value once we are done.
                    //

                    ldapFree( CachedValues[newcount], LDAP_VALUE_SIGNATURE );
                    newcount++;
                }

                //
                // End the set
                //

                hr = lber->HrEndWriteSequence();
                ASSERT( hr == NOERROR );

                //
                // End sequence for the PartialAttributeList (Current Attribute type)
                //

                hr = lber->HrEndWriteSequence();
                ASSERT( hr == NOERROR );

                ldapFree( CachedValues, LDAP_VALUE_LIST_SIGNATURE );
                count++;

            }

            //
            // Dereference the cache page after we are done. It is now
            // open for LRU replacement.
            //

            ASSERT( CacheIndex >= 0 );

            ACQUIRE_LOCK( &CacheLock );

            CacheArray[CacheIndex]->RefCount--;

            IF_DEBUG(CACHE) {
                LdapPrint2("FabricateLdapMessage: Refcount is %d, Cacheindex is %d\n",CacheArray[CacheIndex]->RefCount, CacheIndex );
            }

            ASSERT( CacheArray[CacheIndex]->RefCount >=0 );
            RELEASE_LOCK( &CacheLock );

        }

        //
        // End sequence for the PartialAttributeList
        //

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );


        //
        // End sequence for the SearchResultEntry (there is only one for RootDSE)
        //

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );

        //
        // End sequence for the first message
        //

        hr = lber->HrEndWriteSequence();               // Entire Response
        ASSERT( hr == NOERROR );

        //
        // Now, encode the SearchResultDone message.
        //

        hr = lber->HrStartWriteSequence();             // New message

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;

        }

        hr = lber->HrAddValue((LONG) request->MessageId );

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;

        }

        hr = lber->HrStartWriteSequence(LDAP_RES_SEARCH_RESULT);

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;

        }

        hr = lber->HrAddValue((LONG) LDAP_SUCCESS, BER_ENUMERATED );   // Result code

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;

        }

        hr = lber->HrAddValue((const WCHAR *) NULL);   // Ldap DN

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;

        }

        hr = lber->HrAddValue((const WCHAR *) NULL);   // Error Message

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;

        }

        hr = lber->HrEndWriteSequence();               // SearchResultDone
        ASSERT( hr == NOERROR );

        hr = lber->HrEndWriteSequence();               // New Message
        ASSERT( hr == NOERROR );


        //
        // Inject the newly created buffer into the receive stream.
        //

        buffer = LdapGetReceiveStructure(lber->CbData());

        if (buffer == NULL) {

            IF_DEBUG(OUTMEMORY) {
                LdapPrint0( "FabricateLdapResult: failed to get receive buffer\n");
            }

            goto returnError;
        }

        buffer->NumberOfBytesReceived = lber->CbData();
        buffer->Connection = Connection;

        //
        // Copy the value field over
        //

        CopyMemory( (PCHAR) &buffer->DataBuffer[0],
                     lber->PbData(),
                     lber->CbData()
                    );

        ACQUIRE_LOCK( &ConnectionListLock );

        InsertTailList( &Connection->CompletedReceiveList,
                        &buffer->ReceiveListEntry );

        RELEASE_LOCK( &ConnectionListLock );

        delete lber;
        lber = NULL;
    }


    return err;

returnError:

    SetConnectionError( Connection, hr, NULL );

    if (lber != NULL) {

       delete lber;
    }

    return hr;
}


BOOLEAN
RetrieveFromCache(
  IN PLDAP_CONN  Connection,
  IN PWCHAR AttributeName,
  IN BOOLEAN Unicode,
  IN OUT int *CacheIndex,
  IN OUT PWCHAR **ValueList
 )
{
    //
    // Takes in an Attribute name (like SupportedSaslMechanisms) and returns the
    // cached value. Since there could be multiple values for a given function,
    // a null-terminated list of attribute values is returned. It is the caller's
    // responsibility to free the string.
    //

    int CurrentCacheIndex = -1;
    int i, err;
    PWCHAR *pPtrArr = NULL;

    if (!ValueList) {
        return FALSE;
    }

    *ValueList = NULL;

    //
    // Discover the CachePage position if we don't know about it
    //

    ACQUIRE_LOCK( &CacheLock );

    if (*CacheIndex == -1) {

        for (i = 0; i<MAX_CACHE_SIZE; i++) {

            if ((CacheArray[i]) &&
                (ldapWStringsIdentical( Connection->DnsSuppliedName,
                                        -1,
                                        CacheArray[i]->ServerName,
                                        -1) ) &&
                (CacheArray[i]->PortNumber == Connection->PortNumber)) {

                *CacheIndex = i;
                break;
            }
        }
    }

    CurrentCacheIndex = *CacheIndex;

    if (CurrentCacheIndex == -1) {
        LdapPrint0("RetrieveFromCache: CachePage missing in late stage\n");
        ASSERT(CurrentCacheIndex != -1);
        SetConnectionError(Connection, LDAP_LOCAL_ERROR, NULL );
        RELEASE_LOCK( &CacheLock );
        return FALSE;
    }

    ASSERT( CacheArray[CurrentCacheIndex]->RefCount > 0 );

    //
    // Update the last accessed time.
    //

    CacheArray[CurrentCacheIndex]->LastAccessTime = LdapGetTickCount();

    //
    // Find out number of values present for the given AttributeType
    // We need this so that we can allocate the array needed to store it.
    //

    int AttrIndex = -1;

    //
    // Temporarily convert to UNICODE to perform the comparision
    //

    PWCHAR wAttrName = AttributeName;

    if (!Unicode) {

        err = ToUnicodeWithAlloc( (PCHAR) AttributeName,
                                  -1,
                                  &wAttrName,
                                  LDAP_UNICODE_SIGNATURE,
                                  LANG_ACP
                                  );

        if (err != LDAP_SUCCESS) {

            SetConnectionError( Connection, err, NULL );
            RELEASE_LOCK( &CacheLock );
            return FALSE;
        }
    }


    //
    // Discover the attribute index in the CachePage.
    //

    for (i=0; i<NUM_CACHED_ATTR; i++) {

        if (ldapWStringsIdentical(wAttrName,
                                   -1,
                                   CacheArray[CurrentCacheIndex]->CacheTemplate[0][i],
                                   -1 ) ) {

                    IF_DEBUG(PARSE) {
                        LdapPrint1("Found cache match for attribute %S\n",wAttrName );
                    }

                AttrIndex = i;
            }
    }

    if (!Unicode) {
        ldapFree( wAttrName, LDAP_UNICODE_SIGNATURE );
    }

    if (AttrIndex != -1) {

        PWCHAR* CurrentAttributeList = (PWCHAR*) CacheArray[CurrentCacheIndex]->CacheTemplate[1][AttrIndex];

        //
        // Count the number of values for the given attribute.
        //

        int NumValues;

        for (NumValues=0; CurrentAttributeList && (CurrentAttributeList[NumValues] != NULL); NumValues++) ;

        pPtrArr = (PWCHAR*) ldapMalloc(sizeof(PWCHAR)*(NumValues+1), LDAP_VALUE_LIST_SIGNATURE);

        if (pPtrArr == NULL) {

            SetConnectionError(Connection, LDAP_NO_MEMORY, NULL );
            RELEASE_LOCK( &CacheLock );
            return FALSE;
        }

        //
        // Now, copy the values to the array
        //

        PWCHAR* temp = (PWCHAR*) CacheArray[CurrentCacheIndex]->CacheTemplate[1][AttrIndex];

        for (i=0; i<NumValues; i++) {

            pPtrArr[i] = ldap_dup_stringW( temp[i],
                                           0,
                                           LDAP_VALUE_SIGNATURE);

            if (pPtrArr[i] == NULL) {
                RELEASE_LOCK( &CacheLock );
                return FALSE;
            }

        }

    }

    RELEASE_LOCK( &CacheLock );
    *ValueList = pPtrArr;
    return TRUE;

}

BOOLEAN
ValidateServerReturnedAttrList(
    PLDAP_CONN   Connection,
    PLDAPMessage message
    )
{
    //
    // Validate the server's returned response.  It must contain only those attributes
    // we asked for, and must not exceed the number of cachable attributes.
    //
    ULONG i;
    ULONG cAttr = 0;
    struct berelement *opaque = NULL;

    
    PWCHAR srvAttr = LdapFirstAttribute( Connection,
                                         message,
                                         (BerElement **) &opaque,
                                         TRUE );

    while (srvAttr != NULL) {

        cAttr++;

        // Is it on our list?
        for (i=0; i<NUM_CACHED_ATTR; i++) {

            if (ldapWStringsIdentical(srvAttr,
                                      -1,
                                      CachedAttributeList[i],
                                      -1)) {
                break;
            }

        }

        if (i == NUM_CACHED_ATTR) {

            // Server returned bogus attribute
            IF_DEBUG(CACHE){
                LdapPrint1("Server returned bad attr %S\n",srvAttr);
            }
            
            return FALSE;
        }

        srvAttr = LdapNextAttribute( Connection,
                                       message,
                                       opaque,
                                       TRUE );
    }

    if (cAttr > NUM_CACHED_ATTR) {

        // Server returned too many attributes
        IF_DEBUG(CACHE){
            LdapPrint1("Server returned too many (%d) attrs\n", cAttr);
        }
        
        return FALSE;
    }


    return TRUE;
}

BOOLEAN
CopyResultToCache(
  PLDAP_CONN   Connection,
  PLDAPMessage Result
 )
{
    //
    // Makes a copy of the incoming ldap message into the cache. Returns TRUE
    // if it could copy a cache page and FALSE if unsuccessful.
    //

    int i, err;

    IF_DEBUG(CACHE){
        LdapPrint1("Copying RootDSE of %S to cache...\n",Connection->DnsSuppliedName );
    }

    if (Result == NULL) {

        return FALSE;
    }

    //
    // Step through the first (and only) entry, If it is missing, there
    // is nothing to do.
    //

    PLDAPMessage message = ldap_first_record(Connection,
                                             Result,
                                             LDAP_RES_SEARCH_ENTRY );
    if (message == NULL) {

        return FALSE;
    }


    // Make sure the server gave us what we asked for
    if (!ValidateServerReturnedAttrList(Connection, message)) {
    
        return FALSE;
    }
    
    //
    // Figure out which CachePage we can use to store this data.
    //

    int CacheIndex = -1;
    int lruIndex = -1;
    ULONGLONG lru = 0;
    int firstAvailableSlot = -1;

    ACQUIRE_LOCK( &CacheLock );

    if (GlobalLdapShuttingDown == TRUE) {

        //
        // The client is terminating
        //

        RELEASE_LOCK( &CacheLock );
        return FALSE;
    }

    for (i = 0; i<MAX_CACHE_SIZE; i++) {

        if (CacheArray[i] == NULL) {

            if (firstAvailableSlot == -1) {
                firstAvailableSlot = i;
            }

        } else if (ldapWStringsIdentical( Connection->DnsSuppliedName,
                                          -1,
                                          CacheArray[i]->ServerName,
                                          -1) &&
                   (CacheArray[i]->PortNumber == Connection->PortNumber)) {

            CacheIndex = i;
            break;

        } else {

            //
            // Make a note of the Least Recently Used CachePage.
            // Might be useful later if we don't find any empty pages.
            // If a page is referenced, don't even think about replacing
            // it.
            //

            if ((lruIndex == -1) && (CacheArray[i]->RefCount == 0)) {

                lruIndex = i;
                lru = CacheArray[i]->LastAccessTime;

            } else if ((lruIndex != -1) &&
                       (lru > CacheArray[i]->LastAccessTime) &&
                       (CacheArray[i]->RefCount == 0))  {

                lruIndex = i;
                lru = CacheArray[i]->LastAccessTime;
            }
        }
    }


    if (CacheIndex == -1) {

        //
        // We didn't find a match.
        //

        if ((firstAvailableSlot == -1) && (lruIndex == -1)) {

            //
            // and there is no space to create a new page, Sorry!
            //

            IF_DEBUG(CACHE){
                LdapPrint0("No space to cache new server RootDSE, increase MAX_CACHE_SIZE\n");
            }
            RELEASE_LOCK( &CacheLock );
            return FALSE;

        } else if ((lruIndex != -1) && (firstAvailableSlot == -1)) {

            //
            // Luckily, we can delete an existing page.
            //

            IF_DEBUG(CACHE){
                LdapPrint1("Deleting existing page %d for lack of space\n",lruIndex);
            }
            FreeCachePage( CacheArray[lruIndex] );
            CacheArray[lruIndex] = NULL;
            CacheIndex = lruIndex;

        } else {

            //
            // We found an existing empty slot to create a new page.
            //

            IF_DEBUG(CACHE){
                LdapPrint1("Found empty slot %d, creating new cache page\n", firstAvailableSlot);
            }
            CacheIndex = firstAvailableSlot;
        }

        //
        // Create the new page
        //

        CacheArray[CacheIndex] = (PCACHEHOLDER) ldapMalloc(sizeof(CACHEHOLDER), LDAP_VALUE_SIGNATURE);

        if (CacheArray[CacheIndex] == NULL) {
            SetConnectionError(Connection, LDAP_NO_MEMORY, NULL);
            RELEASE_LOCK( &CacheLock );
            return FALSE;
        }

        CacheArray[CacheIndex]->ServerName = ldap_dup_stringW(Connection->DnsSuppliedName,
                                                              0,
                                                              LDAP_HOST_NAME_SIGNATURE
                                                              );
        if (CacheArray[CacheIndex]->ServerName == NULL) {

            ldapFree(CacheArray[CacheIndex], LDAP_VALUE_SIGNATURE);
            CacheArray[CacheIndex] = NULL;

            SetConnectionError(Connection, LDAP_NO_MEMORY, NULL);
            RELEASE_LOCK( &CacheLock );
            return FALSE;
        }

        CacheArray[CacheIndex]->PortNumber = Connection->PortNumber;

    }

    IF_DEBUG(CACHE) {
        LdapPrint2("CopyResultToCache: refcount is %d, CacheIndex is %d\n", CacheArray[CacheIndex]->RefCount, CacheIndex);
    }

    CacheArray[CacheIndex]->CreateTime = LdapGetTickCount();
    CacheArray[CacheIndex]->LastAccessTime = LdapGetTickCount();

    struct berelement *opaque = NULL;

    PWCHAR attribute = LdapFirstAttribute( Connection,
                                  message,
                                  (BerElement **) &opaque,
                                  TRUE );

    i = 0;

    while (attribute != NULL) {

        PWCHAR *values = NULL;
        ULONG count;
        PWCHAR *dest = NULL;
        PWCHAR currentVal = NULL;

        err = LdapGetValues(Connection,
                            message,
                            attribute,
                            FALSE,
                            TRUE,       // return in Unicode
                            (PVOID *) &values
                            );

        ULONG totalValues = ldap_count_valuesW( values );

        //
        // Free the existing attribute name and store the new one
        // inside.
        //

        if (CacheArray[CacheIndex]->CacheTemplate[0][i] != NULL) {

            ldapFree(CacheArray[CacheIndex]->CacheTemplate[0][i], LDAP_VALUE_SIGNATURE);
        }

        CacheArray[CacheIndex]->CacheTemplate[0][i] = ldap_dup_stringW(attribute,
                                                                       0,
                                                                       LDAP_VALUE_SIGNATURE);

        if (CacheArray[CacheIndex]->CacheTemplate[0][i] == NULL) {
            RELEASE_LOCK( &CacheLock );
            SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
            return FALSE;
        }


        if (CacheArray[CacheIndex]->CacheTemplate[1][i] != NULL) {

            //
            // Free the existing value list and values.
            //

            PWCHAR *CurrentVal = (PWCHAR*) CacheArray[CacheIndex]->CacheTemplate[1][i];

            for (int j=0; (CurrentVal[j]!= NULL) ; j++) {

                ldapFree( CurrentVal[j], LDAP_VALUE_SIGNATURE );
            }

            ldapFree( CurrentVal, LDAP_VALUE_LIST_SIGNATURE );
            CacheArray[CacheIndex]->CacheTemplate[1][i] = NULL;
        }

        dest = (PWCHAR*) ldapMalloc(sizeof(PWCHAR)*(totalValues+1), LDAP_VALUE_LIST_SIGNATURE);

        if (dest == NULL) {
            RELEASE_LOCK( &CacheLock );
            SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
            return FALSE;
        }

        //
        // Since we can't have multidimensional arrays with
        // different data types in each dimension, we have to play
        // some tricks here by using the second row of the cache as
        // PWCHAR* instead of PWCHAR. This is because an attribute
        // can be multivalued.
        //

        CacheArray[CacheIndex]->CacheTemplate[1][i] = (PWCHAR) dest;

        for (count = 0; count < totalValues; count++, currentVal++ ) {

            //
            // Copy the values
            //

            dest[count] = ldap_dup_stringW(values[count],
                                    0,
                                    LDAP_VALUE_SIGNATURE
                                    );
        }

        ldap_value_freeW( values );
        i++;
        attribute = LdapNextAttribute( Connection,
                                       message,
                                       opaque,
                                       TRUE );

    }  // while (attribute != NULL)

    //
    // Bump the refcount. We know that we will access this page immediately.
    //

    CacheArray[CacheIndex]->RefCount++;
    RELEASE_LOCK( &CacheLock );

    return TRUE;

}

// cache.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\bind.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bind.c    send a bind to an LDAP server

Abstract:

   This module implements the LDAP ldap_bind API.

Author:

    Andy Herron    (andyhe)        08-May-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"


BOOLEAN FailedntdsapiLoadLib = FALSE;

ULONG
LdapNonUnicodeBind (
    LDAP *ExternalHandle,
    PCHAR DistName,
    PCHAR Cred,
    ULONG Method,
    BOOLEAN Synchronous
    );

ULONG
LdapGetServiceNameForBind (
    PLDAP_CONN Connection,
    struct l_timeval  *Timeout,
    ULONG AuthMethod
    );

PWCHAR
LdapMakeServiceNameFromHostName (
    PWCHAR HostName
    );

//
//  This routine is one of the main entry points for clients calling into the
//  ldap API.
//

ULONG __cdecl
ldap_simple_bindW (
    LDAP *ExternalHandle,
    PWCHAR DistName,
    PWCHAR PassWord )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return (ULONG) -1;
    }

    err  =  LdapBind( connection,
                      DistName,
                      LDAP_AUTH_SIMPLE,
                      PassWord,
                      FALSE);

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_simple_bind_sW (
    LDAP *ExternalHandle,
    PWCHAR DistName,
    PWCHAR PassWord
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err  =  LdapBind( connection,
                      DistName,
                      LDAP_AUTH_SIMPLE,
                      PassWord,
                      TRUE);

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_bindW (
    LDAP *ExternalHandle,
    PWCHAR DistName,
    PWCHAR Cred,
    ULONG Method
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return (ULONG) -1;
    }

    err  =  LdapBind( connection,
                      DistName,
                      Method,
                      Cred,
                      FALSE);

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_bind_sW (
    LDAP *ExternalHandle,
    PWCHAR DistName,
    PWCHAR Cred,
    ULONG Method
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err  =  LdapBind( connection,
                      DistName,
                      Method,
                      Cred,
                      TRUE);

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_simple_bind (
    LDAP *ExternalHandle,
    PCHAR DistName,
    PCHAR PassWord )
{
    return LdapNonUnicodeBind( ExternalHandle, DistName, PassWord, LDAP_AUTH_SIMPLE, FALSE );
}

ULONG __cdecl
ldap_simple_bind_s (
    LDAP *ExternalHandle,
    PCHAR DistName,
    PCHAR PassWord
    )
{
    return LdapNonUnicodeBind( ExternalHandle, DistName, PassWord, LDAP_AUTH_SIMPLE, TRUE );
}

ULONG __cdecl
ldap_bind (
    LDAP *ExternalHandle,
    PCHAR DistName,
    PCHAR Cred,
    ULONG Method
    )
{
    return LdapNonUnicodeBind( ExternalHandle, DistName, Cred, Method, FALSE );
}

ULONG __cdecl
ldap_bind_s (
    LDAP *ExternalHandle,
    PCHAR DistName,
    PCHAR Cred,
    ULONG Method
    )
{
    return LdapNonUnicodeBind( ExternalHandle, DistName, Cred, Method, TRUE );
}

ULONG
LdapNonUnicodeBind (
    LDAP *ExternalHandle,
    PCHAR DistName,
    PCHAR Cred,
    ULONG Method,
    BOOLEAN Synchronous
    )
{
    ULONG err;
    PWCHAR wName = NULL;
    PWCHAR wPassword = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return (ULONG) ( Synchronous ? LDAP_PARAM_ERROR : -1 );
    }

    err = ToUnicodeWithAlloc( DistName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {
        goto error;
    }

    if (Method != LDAP_AUTH_SIMPLE) {

        wPassword = (PWCHAR) Cred;

    } else {

        err = ToUnicodeWithAlloc( Cred, -1, &wPassword, LDAP_UNICODE_SIGNATURE, LANG_ACP );
    }

    if (err != LDAP_SUCCESS) {
        goto error;
    }

    err = LdapBind( connection,
                    wName,
                    Method,
                    wPassword,
                    Synchronous);

error:
    if (wName)
    {
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );
    }

    if (Method == LDAP_AUTH_SIMPLE && wPassword) {

        ldapFree( wPassword, LDAP_UNICODE_SIGNATURE );
    }

    DereferenceLdapConnection( connection );

    return err;
}


ULONG
LdapBind (
    PLDAP_CONN connection,
    PWCHAR BindDistName,
    ULONG Method,
    PWCHAR BindCred,
    BOOLEAN Synchronous
    )
//
//  This routine sends a bind request to the server and optionally waits
//  for a reply.
//
//  If the call is Sychronous, it returns the LDAP error code.  Otherwise it
//  returns either -1 for failure or the LDAP message number if successful.
//
{

    ULONG err;
    PLDAP_REQUEST request = NULL;
    BOOLEAN haveLock = FALSE;
    BOOLEAN resetBindInProgress = FALSE;
    LONG messageNumber = 0;
    ULONG credentialLength = 0;
    ULONG oldVersion;
    struct l_timeval BindTimeout;
    ULONG initialBindError = LDAP_SUCCESS;
    BOOLEAN terminateConnection = FALSE;
    BOOLEAN fSentMessage = FALSE;
#if DBG
    ULONGLONG startTime = LdapGetTickCount();
#endif

    ASSERT(connection != NULL);

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {

        return (ULONG) ( Synchronous ? err : -1 );
    }

    if (!connection->WhistlerServer) {
        //
        // If this is a second bind on a connection which has signing/sealing
        // turned on, we must disallow it. This is by design because the server can't
        // handle multiple binds on a signed/sealed connection.
        //
        if (connection->CurrentSignStatus || connection->CurrentSealStatus) {

            LdapPrint0("Second Bind is illegal on a signed/sealed connection\n");
            return LDAP_UNWILLING_TO_PERFORM;

        }
    }



    oldVersion = connection->publicLdapStruct.ld_version;

    if (( Method == LDAP_AUTH_NEGOTIATE ) || ( Method == LDAP_AUTH_DIGEST )){

        //
        //  set the connection type to LDAP v3.
        //

        connection->publicLdapStruct.ld_version = LDAP_VERSION3;
    }

    CLdapBer lber( connection->publicLdapStruct.ld_version );

    //
    //  we initially set the error state to success so that the lowest layer
    //  can set it accurately.
    //

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    IF_DEBUG(CONNECTION) {
        LdapPrint2( "ldap_bind called for conn 0x%x, host is %s.\n",
                        connection, connection->publicLdapStruct.ld_host);
    }

    ACQUIRE_LOCK( &connection->StateLock );
    haveLock = TRUE;

    if (connection->ConnObjectState != ConnObjectActive) {

        IF_DEBUG(CONNECTION) {
            LdapPrint1( "ldap_bind connection 0x%x is closing.\n", connection);
        }
        err = LDAP_PARAM_ERROR;
        SetConnectionError( connection, err, NULL );
        goto exitBind;
    }

    //
    //  Free existing DN if we have one for the current connection
    //

    ldapFree( connection->DNOnBind, LDAP_USER_DN_SIGNATURE );
    connection->DNOnBind = NULL;

    //
    //  If someone sends a bind for a v2 CLDAP session, just remember the
    //  DN for the search request and we're done.
    //

    if ((connection->UdpHandle != INVALID_SOCKET) &&
        (connection->publicLdapStruct.ld_version == LDAP_VERSION2)) {

        IF_DEBUG(CONNECTION) {
            LdapPrint1( "ldap_bind connection 0x%x is connectionless.\n", connection);
        }

        if (BindDistName != NULL) {

            ULONG dnLength = strlenW( BindDistName );

            if (dnLength > 0) {

                connection->DNOnBind = (PLDAPDN) ldapMalloc(
                            (dnLength + 1) * sizeof(WCHAR), LDAP_USER_DN_SIGNATURE );

                if (connection->DNOnBind != NULL) {

                    CopyMemory( connection->DNOnBind,
                                BindDistName,
                                dnLength * sizeof(WCHAR) );
                }
            }
        }

        err = LDAP_SUCCESS;
        messageNumber = -1;     // if they do an async call, we need to return
                                // an invalid msg number so they don't try to
                                // wait on it.  They'd wait a LONG time.

        goto exitBind;
    }

    if (connection->TcpHandle == INVALID_SOCKET) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint1( "ldap_bind connection 0x%x is connectionless.\n", connection);
        }
        err = LDAP_PROTOCOL_ERROR;
        SetConnectionError( connection, err, NULL );
        goto exitBind;
    }

    if (connection->BindInProgress == TRUE) {

        IF_DEBUG(API_ERRORS) {
            LdapPrint1( "ldap_bind connection 0x%x has bind in progress.\n", connection);
        }
        err = LDAP_LOCAL_ERROR;
        SetConnectionError( connection, err, NULL );
        goto exitBind;
    }

    connection->BindInProgress = TRUE;
    resetBindInProgress = TRUE;

    FreeCurrentCredentials( connection );

    RELEASE_LOCK( &connection->StateLock );
    haveLock = FALSE;

    if (( Method != LDAP_AUTH_SIMPLE ) && 
        ( Method != LDAP_AUTH_EXTERNAL )) {

        if ( ! Synchronous ) {

            //
            // All of these methods must be called through
            // the synchronous handler routine.
            //

            err = LDAP_PARAM_ERROR;
            goto exitBind;
        }

        (VOID) LdapInitSecurity();

        err = LDAP_AUTH_METHOD_NOT_SUPPORTED;

        //
        // Get the specific auth details set up.
        //

        if ( Method == LDAP_AUTH_SICILY ) {

            err = LdapTryAllMsnAuthentication( connection, BindCred );

        } else if ( Method == LDAP_AUTH_NEGOTIATE ) {

            if (( SspiPackageNegotiate ) ||
                 (connection->PreferredSecurityPackage)) {

                //
                // Determine the service name to use for kerberos auth.
                // This has to be regenerated each time a bind is performed
                // including the autoreconnect scenario.
                //
                // AnoopA: 2/4/98
                // We need to put in a timeout because we were hanging
                // when the server failed to respond to our searches
                //

                   if (connection->publicLdapStruct.ld_timelimit != 0) {
                       BindTimeout.tv_sec = connection->publicLdapStruct.ld_timelimit;
                   }
                   else {
                       BindTimeout.tv_sec = 120;
                   }

                   BindTimeout.tv_usec = 0;

                   LdapDetermineServerVersion(connection, &BindTimeout, &(connection->WhistlerServer));

                   if (connection->ServiceNameForBind != NULL) {

                       ldapFree( connection->ServiceNameForBind, LDAP_SERVICE_NAME_SIGNATURE );
                       connection->ServiceNameForBind = NULL;
                   }
                
                   err = LdapGetServiceNameForBind( connection, &BindTimeout, Method );
                   IF_DEBUG(BIND) {
                       LdapPrint1("New servicename for bind is %S\n", connection->ServiceNameForBind);
                   }

                //
                // For LDAP_AUTH_NEGOTIATE, we expect the credentials
                // to be either NULL (to indicate the locally logged
                // on user), or to contain a SEC_WINNT_AUTH_IDENTITY
                // structure.
                //

                if ( (err != LDAP_OPERATIONS_ERROR) &&
                     (err != LDAP_SERVER_DOWN) &&
                     (err != LDAP_REFERRAL_V2) &&
                     (err != LDAP_TIMEOUT) ) {

                    PWCHAR serviceNameForBind;

                    if ((!connection->ForceHostBasedSPN) && (connection->ServiceNameForBind != NULL)) {

                        serviceNameForBind = connection->ServiceNameForBind;

                    } else {

                        serviceNameForBind = LdapMakeServiceNameFromHostName(connection->HostNameW);
                        if (!serviceNameForBind) {
                            IF_DEBUG(OUTMEMORY) {
                                LdapPrint1( "ldap_bind connection 0x%x couldn't allocate service name.\n", connection);
                            }

                            err = LDAP_NO_MEMORY;
                            SetConnectionError( connection, err, NULL );
                            goto exitBind;
                        }

                    }

                    //
                    // A third party server like Netscape might support
                    // DIGEST-MD5 but not support GSS-SPNEGO
                    //

                    if (SspiPackageDigest &&
                        !connection->PreferredSecurityPackage &&
                        !connection->SupportsGSS_SPNEGO &&
                        connection->SupportsDIGEST ) {

                        err = LdapSspiBind( connection,
                                            SspiPackageDigest,
                                            Method,
                                            connection->NegotiateFlags,
                                            NULL,
                                            serviceNameForBind,
                                            BindCred );

                    } else {

                        err = LdapSspiBind( connection,
                                            (connection->PreferredSecurityPackage)?
                                            connection->PreferredSecurityPackage:
                                            SspiPackageNegotiate,
                                            Method,
                                            connection->NegotiateFlags,
                                            BindDistName,
                                            serviceNameForBind,
                                            BindCred );
                    }

                    initialBindError = err;

                    if (serviceNameForBind != connection->ServiceNameForBind) {
                        // must have come from LdapMakeServiceNameFromHostName
                        // --> need to free it
                        ldapFree(serviceNameForBind, LDAP_SERVICE_NAME_SIGNATURE);
                    }
                }

                if (err == LDAP_PROTOCOL_ERROR) {

                    //
                    //  if the server doesn't support v3, we back off to
                    //  sicily authentication.
                    //
                    
                    connection->publicLdapStruct.ld_version = LDAP_VERSION2;
                    goto TrySicily;

                } else if (err == LDAP_AUTH_METHOD_NOT_SUPPORTED) {

                    //
                    //  if the server doesn't support v3, we back off to
                    //  sicily authentication.
                    //

                    connection->publicLdapStruct.ld_version = oldVersion;
                    goto TrySicily;

                } else if (err == LDAP_TIMEOUT ||
                           err == LDAP_SERVER_DOWN) {

                   //
                   // The server failed to respond to our search request
                   // Abort the bind
                   //

                   goto exitBind;

                }
            } else {

                //
                //  if the client doesn't support SNEGO, then we try sicily
                //

                connection->publicLdapStruct.ld_version = oldVersion;
TrySicily:
                err = LdapTryAllMsnAuthentication( connection, BindCred );
                
                if (err == LDAP_PROTOCOL_ERROR) {
                    
                    terminateConnection = TRUE;
                }

                if ((err != LDAP_SUCCESS) &&
                    (LdapAuthError(err) == FALSE)&&
                    (initialBindError != LDAP_SUCCESS)) {

                    //
                    // This is a third party server which does not understand
                    // the magic discovery packet we send for MsnAuthentication.
                    // We must return the true error, not errors which result from
                    // us sending this magic packet.
                    //

                    err = initialBindError;

                }
            }

        } else {

            ULONG flags = ( connection->NegotiateFlags == DEFAULT_NEGOTIATE_FLAGS ) ?
                            ( 0 ) : connection->NegotiateFlags;

            //
            // These are the same on the wire as when
            // LDAP_AUTH_SICILY is used, but they skip
            // the package enumeration and authenticate
            // directly as requested.
            //
            if (connection->publicLdapStruct.ld_timelimit != 0) {
                BindTimeout.tv_sec = connection->publicLdapStruct.ld_timelimit;
            }
            else {
                BindTimeout.tv_sec = 120;
            }

            BindTimeout.tv_usec = 0;
            LdapDetermineServerVersion(connection, &BindTimeout, &(connection->WhistlerServer));

            if ((Method == LDAP_AUTH_DPA) && (SspiPackageDpa != NULL)) {

                err = LdapSspiBind( connection,
                                    SspiPackageDpa,
                                    Method,
                                    flags,
                                    L"DPA",
                                    NULL,
                                    BindCred );

            } else if ((Method == LDAP_AUTH_MSN) && (SspiPackageSicily != NULL)) {

                err = LdapSspiBind( connection,
                                    SspiPackageSicily,
                                    Method,
                                    flags,
                                    L"MSN",
                                    NULL,
                                    BindCred );

            } else if ((Method == LDAP_AUTH_NTLM)  && (SspiPackageNtlm != NULL)) {

                err = LdapSspiBind( connection,
                                    SspiPackageNtlm,
                                    Method,
                                    flags,
                                    L"NTLM",
                                    NULL,
                                    BindCred );

            } else if ((Method == LDAP_AUTH_DIGEST)  && (SspiPackageDigest != NULL)) {

                //
                // Read the RootDSE and also determine the SPN to use.
                //
                
                ldapFree( connection->ServiceNameForBind, LDAP_SERVICE_NAME_SIGNATURE );
                connection->ServiceNameForBind = NULL;

                err = LdapGetServiceNameForBind( connection, &BindTimeout, Method );

                PWCHAR serviceNameForBind = NULL;
                
                if ((!connection->ForceHostBasedSPN) && (connection->ServiceNameForBind != NULL)) {

                    serviceNameForBind = connection->ServiceNameForBind;

                } else {

                    serviceNameForBind = LdapMakeServiceNameFromHostName(connection->HostNameW);
                    if (!serviceNameForBind) {
                        IF_DEBUG(OUTMEMORY) {
                            LdapPrint1( "ldap_bind connection 0x%x couldn't allocate service name.\n", connection);
                        }

                        err = LDAP_NO_MEMORY;
                        SetConnectionError( connection, err, NULL );
                        goto exitBind;
                    }

                }

                
                if (err == LDAP_SUCCESS) {

                    err = LdapSspiBind( connection,
                                        SspiPackageDigest,
                                        Method,
                                        flags,
                                        NULL,
                                        serviceNameForBind,
                                        BindCred );
                }

                if (serviceNameForBind != connection->ServiceNameForBind) {
                    // must have come from LdapMakeServiceNameFromHostName
                    // --> need to free it
                    ldapFree(serviceNameForBind, LDAP_SERVICE_NAME_SIGNATURE);
                }


            }

        }

    } else if ( Method == LDAP_AUTH_SIMPLE ) {

        //
        // Simple authentication.
        //

        request = LdapCreateRequest( connection, LDAP_BIND_CMD );

        if (request == NULL) {

            IF_DEBUG(OUTMEMORY) {
                LdapPrint1( "ldap_bind connection 0x%x couldn't allocate request.\n", connection);
            }

            err = LDAP_NO_MEMORY;
            SetConnectionError( connection, err, NULL );
            goto exitBind;
        }

        messageNumber = request->MessageId;
        request->ChaseReferrals = 0;

        //
        // Make sure this no other waiting thread steals a response meant
        // for us.
        //
    
        request->Synchronous = Synchronous;

        //
        //  format the bind request.
        //

        if ((connection->publicLdapStruct.ld_version == LDAP_VERSION2) ||
            (connection->publicLdapStruct.ld_version == LDAP_VERSION3)) {

            //
            //  the ldapv2 Bind message looks like this :
            //
            //  [APPLICATION 0] (IMPLICIT) SEQUENCE {
            //      version (INTEGER)
            //      szDN (LDAPDN)
            //      authentication CHOICE {
            //          simple  [0] OCTET STRING
            //          [... other choices ...]
            //          }
            //      }

            lber.HrStartWriteSequence();
            lber.HrAddValue( messageNumber );

            lber.HrStartWriteSequence(LDAP_BIND_CMD);
            lber.HrAddValue((LONG) connection->publicLdapStruct.ld_version);
            lber.HrAddValue((const WCHAR *) BindDistName );

            WCHAR   nullStr = L'\0';
            PWCHAR  credentials = BindCred;

            if (credentials != NULL) {

                credentialLength = (strlenW( credentials ) + 1) * sizeof(WCHAR);
                lber.HrAddValue((const WCHAR *) credentials, Method );

            } else {

                credentials = &nullStr;

                lber.HrAddBinaryValue( (BYTE *) credentials, 0, Method );
            }


            lber.HrEndWriteSequence();
            lber.HrEndWriteSequence();

        } else {

            IF_DEBUG(API_ERRORS) {
                LdapPrint2( "ldap_bind connection 0x%x asked for version 0x%x.\n",
                            connection, connection->publicLdapStruct.ld_version );
            }

            err = LDAP_PROTOCOL_ERROR;
            SetConnectionError( connection, err, NULL );
            goto exitBind;
        }

        //
        //  send the bind request.
        //

        ACQUIRE_LOCK( &connection->ReconnectLock );

        AddToPendingList( request, connection );

        err = LdapSend( connection, &lber );

        if (err != LDAP_SUCCESS) {

            IF_DEBUG(NETWORK_ERRORS) {
                LdapPrint2( "ldap_bind connection 0x%x send with error of 0x%x.\n",
                            connection, err );
            }

            DecrementPendingList( request, connection );
            RELEASE_LOCK( &connection->ReconnectLock );

        } else {
        
            fSentMessage = TRUE;
            
            RELEASE_LOCK( &connection->ReconnectLock );
            
            if (Synchronous) {

                PLDAPMessage message = NULL;

                ULONG timeout = LDAP_BIND_TIME_LIMIT_DEFAULT;


                if (connection->publicLdapStruct.ld_timelimit != 0) {
                    timeout = connection->publicLdapStruct.ld_timelimit * 1000;
                }

                err = LdapWaitForResponseFromServer( connection,
                                                     request,
                                                     timeout,
                                                     FALSE,     /// not search results
                                                     &message,
                                                     TRUE );    // Disable autoreconnect
                if (err == LDAP_SUCCESS) {

                    if (message != NULL) {

                        err = message->lm_returncode;

                    } else {

                        ASSERT( connection->ServerDown );  

                        err = LDAP_SERVER_DOWN;

                        IF_DEBUG(SERVERDOWN) {
                            LdapPrint2( "ldapBind thread 0x%x has connection 0x%x as down.\n",
                                            GetCurrentThreadId(),
                                            connection );
                        }
                    }

                    IF_DEBUG(TRACE1) {
                        LdapPrint2( "LdapBind conn 0x%x gets response of 0x%x from server.\n",
                                    connection, err );
                    }

                } else {

                    IF_DEBUG(TRACE2) {
                        LdapPrint2( "LdapBind conn 0x%x didn't get response from server, 0x%x.\n",
                                    connection, err );
                    }
                }


                if (message != NULL) {
                    ldap_msgfree( message );
                }
            }
        }
    } else {
        
        //
        // External authentication. From draft-ietf-ldapext-authmeth-04.txt,
        // the DN contains the Authorization Id of the following two forms:
        //
        // ; distinguished-name-based authz id.
        // dnAuthzId  = "dn:" dn
        // dn         = utf8string    ; with syntax defined in RFC 2253
        //
        // ; unspecified userid, UTF-8 encoded.
        // uAuthzId   = "u:" userid
        // userid     = utf8string    ; syntax unspecified
        //
        // One of the above authzIds will be part of the credentials field in
        // the SASL credentials field.
        //

        ASSERT(  Method == LDAP_AUTH_EXTERNAL );

        if ( BindCred || (! Synchronous)) {
            
            //
            // You can't specify credentials in an EXTERNAL SASL bind nor
            // can it be called asynchronously.
            //
            
            err = LDAP_PARAM_ERROR;
            goto exitBind;
        }

        err = LdapExchangeOpaqueToken(connection,
                                      LDAP_AUTH_SASL,         // auth mechanism
                                      L"EXTERNAL",            // oid
                                      BindDistName,           // authzId
                                      NULL,                   // Credentials
                                      0,                      // Credential length
                                      NULL,                   // return data
                                      NULL,                   // return data in berval form
                                      NULL,                   // server controls
                                      NULL,                   // client controls
                                      (PULONG) &messageNumber,// Message Number
                                      FALSE,                  // Send only
                                      TRUE,                   // Controls are unicode
                                      &fSentMessage           // did the message get sent?
                                      );


    }  // End of EXTERNAL auth.

    if (( Method == LDAP_AUTH_SIMPLE ) ||
        ( Method == LDAP_AUTH_EXTERNAL )) {

        // For non-SSPI bind methods, we want to clear the security context (if any)
        // of the connection, in case this was a re-bind following a previous 
        // SSPI bind.  We also need to clear any signing/sealing left over from
        // the previous bind.  We do this only if we got to the point of actually
        // sending the bind message to the server.

        if (fSentMessage) {
        
            CloseCredentials( connection );
            if ((connection->SecureStream) &&
                (connection->CurrentSignStatus || connection->CurrentSealStatus)) {

                PSECURESTREAM pTemp;
                pTemp = (PSECURESTREAM) connection->SecureStream;
                delete pTemp;
                
                connection->SecureStream = NULL;
                connection->CurrentSignStatus = FALSE;
                connection->CurrentSealStatus = FALSE;
            }
        }
    }

    if (err == LDAP_SUCCESS) {

        //
        //  save off the credentials we used to get to this server
        //

        ACQUIRE_LOCK( &connection->StateLock );

        ldapFree( connection->DNOnBind, LDAP_USER_DN_SIGNATURE );
        connection->DNOnBind = NULL;

        if (( Method == LDAP_AUTH_SIMPLE ) ||
            ( Method == LDAP_AUTH_EXTERNAL )) {

            if (credentialLength > 0) {

                // Note that we'll need up to (DES_BLOCKLEN-1) bytes of padding for RtlEncryptMemory
                connection->CurrentCredentials = (PWCHAR) ldapMalloc( credentialLength + 1 + (DES_BLOCKLEN-1),
                                                             LDAP_CREDENTIALS_SIGNATURE );


                if ( connection->CurrentCredentials != NULL ) {

                    CopyMemory( connection->CurrentCredentials,
                                BindCred,
                                credentialLength );

                    if (GlobalUseScrambling) {

                        ACQUIRE_LOCK( &connection->ScramblingLock );

                        pRtlInitUnicodeString( &connection->ScrambledCredentials, connection->CurrentCredentials);
                        RoundUnicodeStringMaxLength(&connection->ScrambledCredentials, DES_BLOCKLEN);

                        //
                        // Scramble plain-text credentials
                        //

                        EncodeUnicodeString(&connection->ScrambledCredentials);
                        connection->Scrambled = TRUE;

                        RELEASE_LOCK( &connection->ScramblingLock );
                    }

                }
            }
            connection->BindMethod = Method;
        }

        connection->BindPerformed = TRUE;

        if (BindDistName != NULL) {

            ULONG dnLength = strlenW( BindDistName ) * sizeof(WCHAR);

            if (dnLength > 0) {

                connection->DNOnBind = (PLDAPDN) ldapMalloc( dnLength + sizeof(WCHAR), LDAP_USER_DN_SIGNATURE );

                if (connection->DNOnBind != NULL) {

                    CopyMemory( connection->DNOnBind,
                                BindDistName,
                                dnLength );
                }
            }
        }

        RELEASE_LOCK( &connection->StateLock );
    }

exitBind:

    IF_DEBUG(BIND) {
        LdapPrint2( "ldap_bind returned err = 0x%x for connection 0x%x.\n",
                     err, connection );
    }

    if (resetBindInProgress == TRUE) {

        ldap_msgfree( connection->BindResponse );
        connection->BindResponse = NULL;

        connection->BindInProgress = FALSE;
    }

    //
    //  if the server returns a protocol error, RFC 2251 mandates
    //  the client MUST close the connection as the server will
    //  be unwilling to accept further operations. We mark
    //  the connection as down so that future requests trigger
    //  a disconnect/reconnect.
    //

    if ((err != LDAP_SUCCESS) &&
        (terminateConnection == TRUE)) {

        if (!haveLock) {
            ACQUIRE_LOCK( &connection->StateLock );
        }

        connection->HostConnectState = HostConnectStateError;

        if (!haveLock) {
            RELEASE_LOCK( &connection->StateLock );
        }
    }

    if (haveLock) {
        RELEASE_LOCK( &connection->StateLock );
    }

    if (! Synchronous) {

        if (err == LDAP_SUCCESS) {

            err = messageNumber;

        } else {

            err = (DWORD) -1;

            if (request != NULL) {

                CloseLdapRequest( request );
            }
        }

    } else {

        if (request != NULL) {

            CloseLdapRequest( request );
        }
    }

    if (request != NULL) {

        DereferenceLdapRequest( request );
    }

    START_LOGGING;
    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=ldap_bind]"));
    DSLOG((0,"[DN=%ws][PA=0x%x][ST=%I64d][ET=%I64d][ER=%d][-]\n",
           BindDistName, Method, startTime, LdapGetTickCount(), err));
    END_LOGGING;

    return err;
}

ULONG
FreeCurrentCredentials (
    PLDAP_CONN Connection
    )
{
    if (Connection->CurrentCredentials != NULL) {

        ULONG tag;

        if ( Connection->BindMethod == LDAP_AUTH_SIMPLE ) {

            tag = LDAP_CREDENTIALS_SIGNATURE;

        } else {

            tag = LDAP_SECURITY_SIGNATURE;
        }

        ldapFree( Connection->CurrentCredentials, tag );
        Connection->CurrentCredentials = NULL;
    }
    Connection->BindMethod = 0;

    if (GlobalUseScrambling) {
        pRtlInitUnicodeString( &Connection->ScrambledCredentials, NULL);
    }

    return LDAP_SUCCESS;
}

// important: must be lower-case, per RFC 2829, section 11
#define LDAP_SERVICE_PREFIX L"ldap"

PWCHAR
LdapMakeServiceNameFromHostName (
    PWCHAR HostName
    )
{
    PWCHAR pszServiceName = NULL;

    if (!LoadUser32Now()) {
        return NULL;
    }

    pszServiceName = (PWCHAR) ldapMalloc( (strlenW(LDAP_SERVICE_PREFIX) + strlenW(HostName) + 2)*sizeof(WCHAR), LDAP_SERVICE_NAME_SIGNATURE);
    if (!pszServiceName) {
        return NULL;
    };

    pfwsprintfW (pszServiceName, L"%s/%s", LDAP_SERVICE_PREFIX, HostName);

    return pszServiceName;
}


ULONG
LdapGetServiceNameForBind (
    PLDAP_CONN Connection,
    struct l_timeval  *Timeout,
    ULONG AuthMethod
    )
{

#define TEMPBUFFERSIZE  4096

   PWCHAR  pszSpn = NULL;
   DWORD   pcSpnLength = TEMPBUFFERSIZE;
   PLDAP   ldapConnection = Connection->ExternalInfo;
   ULONG   err;
   PLDAPMessage results = NULL;
   ULONG oldChaseReferrals = Connection->publicLdapStruct.ld_options;
   BOOLEAN foundGSSAPI = FALSE;
   BOOLEAN foundGSS_SPNEGO = FALSE;
   BOOLEAN foundDIGEST = FALSE;
   USHORT PortNumber = 0;
   PWCHAR servicename = NULL;
    
   PWCHAR attrList[4] = { L"supportedSASLMechanisms",
                          L"dnsHostName",
                          NULL };

   //
   // We try to generate a service principle name if we have a fully qualified
   // machine name.
   //

   if ((Connection->DnsSuppliedName != NULL) &&
       (NTDSLibraryHandle == NULL) &&
        (!FailedntdsapiLoadLib) ){

      //
      // Try to load ntdsapi.dll
      //

      ACQUIRE_LOCK( &LoadLibLock );

      NTDSLibraryHandle = LoadLibraryA( "NTDSAPI.DLL" );

      if (NTDSLibraryHandle != NULL) {

         pDsMakeSpnW = (FNDSMAKESPNW) GetProcAddress( NTDSLibraryHandle, "DsMakeSpnW" );

      if (pDsMakeSpnW == NULL) {

         //
         // No big deal. We won't die if we don't get that function
         // Just don't try to load the dll again.
         //

         FailedntdsapiLoadLib = TRUE;
         FreeLibrary( NTDSLibraryHandle );
         NTDSLibraryHandle = NULL;
      }

      } else {

         FailedntdsapiLoadLib = TRUE;
      }

      RELEASE_LOCK( &LoadLibLock );
   }


   if (pDsMakeSpnW) {

          //
          // We have to decide what we want to pass in as the service name. If we
          // connect using an IP address, we are out of luck and end up reading
          // the rootDSE attribute anyway.
          //
          // AnoopA (1/27/99): I have to read the RootDSE ALWAYS to figure out if the
          // server is pre-GSS-SPNEGO or not. But, we will try our best to get the
          // servicename through DsMakeSpn and not from the RootDSE.
          //
    

          //
          // If we had a domain name, we must redirect it to the appropriate KDC by 
          // supplying the @domain in the end. So, the new SPN will look like:
          //
          // LDAP/FQMN/FQDN@FQDN
          //
    
          pszSpn = (PWCHAR) ldapMalloc( TEMPBUFFERSIZE, LDAP_BUFFER_SIGNATURE );

          if (!pszSpn) {
              goto ReadRootDSE;
          }

          if (Connection->DomainName) {
    
              LONG DomainLength = strlenW(Connection->DomainName);
              
              if (DomainLength >= TEMPBUFFERSIZE/8) {
                  goto ReadRootDSE;
              }

              servicename = (PWCHAR)ldapMalloc( (DomainLength*2+2)* sizeof(WCHAR),
                                                 LDAP_BUFFER_SIGNATURE);
    
              if (!servicename) {
                  goto ReadRootDSE;
              }
    
              CopyMemory( servicename,
                          Connection->DomainName,
                          DomainLength * sizeof(WCHAR));
    
              *(servicename+DomainLength) = L'@';
    
              CopyMemory( servicename + DomainLength+1,
                          Connection->DomainName,
                          DomainLength * sizeof(WCHAR));
    
          } else {
              
              servicename = Connection->DnsSuppliedName;
          }
          
          if ( (!((Connection->PortNumber == LDAP_PORT) ||
                  (Connection->PortNumber == LDAP_GC_PORT) ||
                  (Connection->PortNumber == LDAP_SSL_PORT) ||
                  (Connection->PortNumber == LDAP_SSL_GC_PORT))) &&
                  (AuthMethod != LDAP_AUTH_DIGEST)) {
    
              //
              // This connection is on a non-standard port. Include it in the SPN, unless
              // we're building a Digest URI (Digest doesn't take the port number)
              //

              PortNumber = Connection->PortNumber;
          }
    
          IF_DEBUG(BIND) {
             LdapPrint1("Connection->hostname is %s\n", Connection->publicLdapStruct.ld_host);
             LdapPrint1("Connection->DnsSuppliedNAme is %S\n ", Connection->DnsSuppliedName);
             LdapPrint1("Connection->DomainName is %S\n ", Connection->DomainName);
         }

          //
          // Note: The service class name in the SPN must be lower-case ("ldap").
          // This is required by RFC 2829, section 11.  W2k DCs are not case-sensitive,
          // however, some third-party servers are.
          //
          err  = pDsMakeSpnW( LDAP_SERVICE_PREFIX,     // ServiceClass
                              servicename,            // ServiceName
                              Connection->DnsSuppliedName,  // Optional InstanceName
                              PortNumber,             // PortNumber, if nonstandard
                              NULL,                   // Optional referrer
                              &pcSpnLength,           // Length of buffer
                              pszSpn                  // Actual buffer
                              );
    
    
       if (err == ERROR_SUCCESS) {
    
          Connection->ServiceNameForBind = ldap_dup_stringW(
                                                           pszSpn,
                                                           0,
                                                           LDAP_SERVICE_NAME_SIGNATURE );
    
        IF_DEBUG(BIND) {
             LdapPrint2("LDAP: DsMakeSpn returned %S with error %d\n", Connection->ServiceNameForBind, err);
        }
        }
    
   }

ReadRootDSE:

    Connection->publicLdapStruct.ld_options &= ~LDAP_OPT_CHASE_REFERRALS;
    Connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_SUBORDINATE_REFERRALS;
    Connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_EXTERNAL_REFERRALS;

    //
    // Ensure that we don't try to sign/seal - remember that we haven't
    // bound yet.
    //

    err = ldap_search_ext_sW( ldapConnection,
                              NULL,
                              LDAP_SCOPE_BASE,
                              L"(objectclass=*)",
                              attrList,
                              0,            // attributes only
                              NULL,         // server controls
                              NULL,         // client controls
                              Timeout,
                              0,            // size limit
                              &results
                              );

    if (results != NULL) {

        PLDAPMessage message = ldap_first_record( Connection,
                                                  results,
                                                  LDAP_RES_SEARCH_ENTRY );

        if (message != NULL) {

            struct berelement *opaque = NULL;
            PWCHAR attribute = LdapFirstAttribute( Connection,
                                                   message,
                                                   (BerElement **) &opaque,
                                                   TRUE );

            while (attribute != NULL) {

                PWCHAR *values = NULL;
                ULONG count;

                if (LdapGetValues( Connection,
                                   message,
                                   attribute,
                                   FALSE,
                                   TRUE,
                                   (PVOID *) &values) != NOERROR)
                    values = NULL;

                ULONG totalValues = ldap_count_valuesW( values );

                if ( ldapWStringsIdentical(
                                     attribute,
                                     -1,
                                     L"supportedSASLMechanisms",
                                     -1 )) {


                    for (count = 0; count < totalValues; count++ ) {

                        if (ldapWStringsIdentical(
                                            values[count],
                                            -1,
                                            L"GSSAPI",
                                            -1 )) {
                            foundGSSAPI = TRUE;
                            IF_DEBUG(BIND) {
                                LdapPrint1( "ldapBind found GSSAPI auth type on conn 0x%x\n", Connection);
                            }
                        } else if (ldapWStringsIdentical(
                                            values[count],
                                            -1,
                                            L"GSS-SPNEGO",
                                            -1 )) {
                            foundGSS_SPNEGO = TRUE;
                            IF_DEBUG(BIND) {
                                LdapPrint1( "ldapBind found GSS-SPNEGO auth type on conn 0x%x\n", Connection);
                            }
                        } else if (ldapWStringsIdentical(
                                            values[count],
                                            -1,
                                            L"DIGEST-MD5",
                                            -1 )) {
                            foundDIGEST = TRUE;
                            IF_DEBUG(BIND) {
                                LdapPrint1( "ldapBind found DIGEST auth type on conn 0x%x\n", Connection);
                            }
                        }
                    }

                } else if ( ldapWStringsIdentical(
                                            attribute,
                                            -1,
                                            L"dnsHostName",
                                            -1 )) {
                   //
                   // We found the DNS name of the server we are connected to.
                   // Pick off the first one.
                   //

                   if ( totalValues && values[0] ) {

                      if (Connection->DnsSuppliedName != NULL) {

                         ldapFree(Connection->DnsSuppliedName, LDAP_HOST_NAME_SIGNATURE);
                      }

                      Connection->DnsSuppliedName = ldap_dup_stringW(
                                                                    values[0],
                                                                    0,
                                                                    LDAP_HOST_NAME_SIGNATURE);

                      IF_DEBUG(BIND) {
                         LdapPrint1("ldap bind: dnsHostName entry reads %s\n", Connection->DnsSuppliedName);
                      }

                   }
                   
                   //
                   // We can't query the RootDSE for the supportedLDAPVersion because
                   // the Exchange server exposes "supportedVersion" instead of "supportedLDAPVersion"
                   // Qeurying for "supportedVersion" will invalidate our cache.
                   //
                
                }

                ldap_value_freeW( values );

                attribute = LdapNextAttribute( Connection,
                                               message,
                                               opaque,
                                               TRUE );
            }
        }

        ldap_msgfree( results );
    }

    Connection->publicLdapStruct.ld_options = oldChaseReferrals;

    if (err == LDAP_SUCCESS) {

        //
        // This must be a v3 server we are talking to. It responded successfully
        // to our RootDSE search 
        //
        
        IF_DEBUG(BIND) {
            LdapPrint0("ldap bind: Server is v3\n");
        }
        Connection->HighestSupportedLdapVersion = LDAP_VERSION3;

        if  ((foundGSS_SPNEGO == FALSE) && (foundGSSAPI == FALSE)) {

            //
            // Non-AD server
            //

            IF_DEBUG(BIND) {
                LdapPrint0("ldap bind: Server does not support GSSAPI or GSS-SPNEGO\n");
            }

        } else if ((foundGSS_SPNEGO == FALSE) && (foundGSSAPI == TRUE)){

            //
            // AD Beta2 server
            //
            Connection->SupportsGSSAPI = TRUE;
            IF_DEBUG(BIND) {
                LdapPrint0("ldap bind: Server supports GSSAPI but not GSS-SPNEGO\n");
            }

        } else if ((foundGSS_SPNEGO == TRUE) && (foundGSSAPI == FALSE)) {

            //
            // Non-AD server but it supports the negotiate package.
            //

            Connection->SupportsGSS_SPNEGO = TRUE;
            IF_DEBUG(BIND) {
                LdapPrint0("ldap bind: Server supports GSS-SPNEGO but not GSSAPI\n");
            }

        } else if ((foundGSS_SPNEGO == TRUE) && (foundGSSAPI == TRUE)) {

            //
            // AD Beta3 server
            //

            Connection->SupportsGSS_SPNEGO = TRUE;
            Connection->SupportsGSSAPI = TRUE;
            IF_DEBUG(BIND) {
                LdapPrint0("ldap bind: Server supports both GSS-SPNEGO and GSSAPI\n");
            }
        }

        Connection->SupportsDIGEST = foundDIGEST;
    
    } else {

        //
        // This server probably requires a bind before doing a search.
        //
        IF_DEBUG(BIND) {
            LdapPrint0("ldap bind: Server is v2\n");
        }
        Connection->HighestSupportedLdapVersion = LDAP_VERSION2;
    }

   
   if (Connection->DomainName) {
       ldapFree(servicename, LDAP_BUFFER_SIGNATURE);
       servicename = NULL;
   }
    
   if (pszSpn) {
       ldapFree(pszSpn, LDAP_BUFFER_SIGNATURE);
       pszSpn = NULL;
   }
    
   return err;

}

BOOLEAN
LdapAuthError(
   ULONG err
   )
{
    //
    // Returns FALSE for non authentication errors like LDAP_BUSY etc.
    //

    if (( err == LDAP_INAPPROPRIATE_AUTH )  ||
        ( err == LDAP_INVALID_CREDENTIALS ) ||
        ( err == LDAP_INSUFFICIENT_RIGHTS ) ||
        ( err == LDAP_AUTH_METHOD_NOT_SUPPORTED ) ||
        ( err == LDAP_STRONG_AUTH_REQUIRED )  ||
        ( err == LDAP_AUTH_UNKNOWN )) {

        return TRUE;
    }

    return FALSE;
}

ULONG
LdapDetermineServerVersion (
    PLDAP_CONN Connection,
    struct l_timeval  *Timeout,
    BOOLEAN *pfIsServerWhistler     // OUT
    )
{
    PLDAP   ldapConnection = Connection->ExternalInfo;
    ULONG   err;
    PLDAPMessage results = NULL;
    ULONG oldChaseReferrals = Connection->publicLdapStruct.ld_options;

    PWCHAR attrList[2] = { L"supportedCapabilities",
                           NULL };

    Connection->publicLdapStruct.ld_options &= ~LDAP_OPT_CHASE_REFERRALS;
    Connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_SUBORDINATE_REFERRALS;
    Connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_EXTERNAL_REFERRALS;

    *pfIsServerWhistler = FALSE;

    err = ldap_search_ext_sW( ldapConnection,
                              NULL,
                              LDAP_SCOPE_BASE,
                              L"(objectclass=*)",
                              attrList,
                              0,            // attributes only
                              NULL,         // server controls
                              NULL,         // client controls
                              Timeout,
                              0,            // size limit
                              &results
                              );

    if (results != NULL) {

        PLDAPMessage message = ldap_first_record( Connection,
                                                  results,
                                                  LDAP_RES_SEARCH_ENTRY );

        if (message != NULL) {

            struct berelement *opaque = NULL;
            PWCHAR attribute = LdapFirstAttribute( Connection,
                                                   message,
                                                   (BerElement **) &opaque,
                                                   TRUE );

            while (attribute != NULL) {

                PWCHAR *values = NULL;
                ULONG count;

                if (LdapGetValues( Connection,
                                   message,
                                   attribute,
                                   FALSE,
                                   TRUE,
                                   (PVOID *) &values) != NOERROR)
                    values = NULL;

                ULONG totalValues = ldap_count_valuesW( values );

                if ( ldapWStringsIdentical(
                                     attribute,
                                     -1,
                                     L"supportedCapabilities",
                                     -1 )) {


                    for (count = 0; count < totalValues; count++ ) {

                        if (ldapWStringsIdentical(
                                            values[count],
                                            -1,
                                            L"1.2.840.113556.1.4.1791", // Whistler w/ rebind fixes OID
                                            -1 )) {
                            *pfIsServerWhistler = TRUE;
                            IF_DEBUG(BIND) {
                                LdapPrint1( "ldapBind found server is Whistler or better AD on conn 0x%x\n", Connection);
                            }
                        }
                    }

                }

                ldap_value_freeW( values );

                attribute = LdapNextAttribute( Connection,
                                               message,
                                               opaque,
                                               TRUE );
            }
        }

        ldap_msgfree( results );
    }

    Connection->publicLdapStruct.ld_options = oldChaseReferrals;

    return err;
}

// bind.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\compare.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    compare.cxx handle compare requests to an LDAP server

Abstract:

   This module implements the LDAP compare APIs.

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

//
//  This is the client API to allow comparing objects to the directory.
//
ULONG
LdapCompare (
    PLDAP_CONN connection,
    PWCHAR DistinguishedName,
    PWCHAR Attribute,
    PWCHAR Value,           // either value or Data is not null, not both
    struct berval   *Data,
    BOOLEAN Unicode,
    BOOLEAN Synchronous,
    PLDAPControlW   *ServerControls,
    PLDAPControlW   *ClientControls,
    ULONG           *MessageNumber
    )
{
    ULONG hr;
    PLDAP_REQUEST request = NULL;
    ULONG messageNumber;
    ULONG err;

    if (MessageNumber == NULL) {

        return LDAP_PARAM_ERROR;
    }

    *MessageNumber = (ULONG) -1;

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {
       return err;
    }

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    request = LdapCreateRequest( connection, LDAP_COMPARE_CMD );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_compare connection 0x%x couldn't allocate request.\n", connection);
        }
        hr = LDAP_NO_MEMORY;
        SetConnectionError( connection, hr, NULL );
        return hr;
    }

    messageNumber = request->MessageId;

    request->Synchronous = Synchronous;

    hr = LDAP_SUCCESS;

    if ((ServerControls != NULL) || (ClientControls != NULL)) {

        hr = LdapCheckControls( request,
                                ServerControls,
                                ClientControls,
                                Unicode,
                                0 );

        if (hr != LDAP_SUCCESS) {

            IF_DEBUG(CONTROLS) {
                LdapPrint2( "ldap_comp connection 0x%x trouble with SControl, err 0x%x.\n",
                            connection, hr );
            }
        }
    }

    if (hr == LDAP_SUCCESS) {

        if (Synchronous || (request->ChaseReferrals == 0)) {

            request->AllocatedParms = FALSE;
            request->OriginalDN = DistinguishedName;
            request->compare.Attribute = Attribute;
            request->compare.Value = Value;
            if (Data) {

                request->compare.Data.bv_val = Data->bv_val;
                request->compare.Data.bv_len = Data->bv_len;
            }

        } else {

            request->AllocatedParms = TRUE;

            if (DistinguishedName != NULL) {

                request->OriginalDN = ldap_dup_stringW( DistinguishedName, 0, LDAP_UNICODE_SIGNATURE );

                if (request->OriginalDN == NULL) {

                    hr = LDAP_NO_MEMORY;
                }
            }

            if ((hr == LDAP_SUCCESS) && ((Value != NULL) || (Data != NULL))) {

                request->compare.Attribute = ldap_dup_stringW( Attribute, 0, LDAP_UNICODE_SIGNATURE );

                if (request->compare.Attribute == NULL) {

                    hr = LDAP_NO_MEMORY;
                }
            }

            if ((hr == LDAP_SUCCESS) && (Value != NULL)) {

                request->compare.Value = ldap_dup_stringW( Value, 0, LDAP_UNICODE_SIGNATURE );

                if (request->compare.Value == NULL) {

                    hr = LDAP_NO_MEMORY;
                }
            }

            if ((hr == LDAP_SUCCESS) &&
                (Data != NULL) &&
                (Data->bv_val != NULL) &&
                (Data->bv_len > 0)) {

                request->compare.Data.bv_val = (PCHAR) ldapMalloc(
                                Data->bv_len,
                                LDAP_COMPARE_DATA_SIGNATURE );

                if (request->compare.Data.bv_val == NULL) {

                    hr = LDAP_NO_MEMORY;

                } else {

                    CopyMemory( request->compare.Data.bv_val,
                                Data->bv_val,
                                Data->bv_len );

                    request->compare.Data.bv_len = Data->bv_len;

                }
            }
        }
    }

    if (hr == LDAP_SUCCESS) {

        START_LOGGING;
        DSLOG((DSLOG_FLAG_TAG_CNPN,"[+]"));
        DSLOG((0,"[ID=%d][OP=ldap_compare][DN=%ws][ST=%I64d][ATTR=%ws][-]\n",
               request->MessageId, DistinguishedName, request->RequestTime,
               Attribute));
        END_LOGGING;

        hr = SendLdapCompare( request,
                              connection,
                              (CLdapBer **)&request->BerMessageSent,
                              request->OriginalDN,
                              0 );
    }

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_compare connection 0x%x errored with 0x%x.\n",
                        connection, hr );
        }

        DSLOG((0,"[+][ID=%d][ET=%I64d][ER=%d][-]\n",request->MessageId,LdapGetTickCount(), hr));
        messageNumber = (ULONG) -1;
        SetConnectionError( connection, hr, NULL );

        CloseLdapRequest( request );
    }

    *MessageNumber = messageNumber;

    DereferenceLdapRequest( request );
    return hr;
}

ULONG
SendLdapCompare (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection,
    CLdapBer **Lber,
    PWCHAR DistinguishedName,
    LONG AltMsgId
    )
{
    PWCHAR Attribute = Request->compare.Attribute;
    PWCHAR Value = Request->compare.Value;
    struct berval   *Data = &Request->compare.Data;
    ULONG hr;

    CLdapBer *lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {
        SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
        return LDAP_NO_MEMORY;
    }

    //
    //  The request looks like the following :
    //
    //     CompareRequest ::=
    //         [APPLICATION 14] SEQUENCE {
    //              entry          LDAPDN,
    //              ava            SEQUENCE {
    //                                  type          AttributeType,
    //                                  value         AttributeValue
    //                             }
    //         }
    //

    hr = lber->HrStartWriteSequence();
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_compare startWrite conn 0x%x encoding error of 0x%x.\n",
                        Connection, hr );
        }

        goto encodingError;

    } else {            // we can't forget EndWriteSequence

       if (AltMsgId != 0) {

          hr = lber->HrAddValue((LONG) AltMsgId );

       } else {

          hr = lber->HrAddValue((LONG) Request->MessageId );
       }

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_compare MsgNo conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;
        }

        hr = lber->HrStartWriteSequence(LDAP_COMPARE_CMD);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_compare cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;

        } else {        // we can't forget EndWriteSequence

            hr = lber->HrAddValue((const WCHAR *) DistinguishedName );
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_compare DN conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto encodingError;
            }

            //
            //  add the attribute list and we're done.
            //

            hr = lber->HrStartWriteSequence();
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_compare 1 conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto encodingError;

            } else {        // we can't forget EndWriteSequence

                hr = lber->HrAddValue((const WCHAR *) Attribute );
                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "ldap_compare 2 conn 0x%x encoding error of 0x%x.\n",
                                    Connection, hr );
                    }
                    goto encodingError;
                }

                if ((Data->bv_len > 0) && (Data->bv_val != NULL)) {

                    hr = lber->HrAddBinaryValue((BYTE *) Data->bv_val,
                                                        Data->bv_len );

                } else {

                    hr = lber->HrAddValue((const WCHAR *) Value );
                }

                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "ldap_compare 3 conn 0x%x encoding error of 0x%x.\n",
                                    Connection, hr );
                    }
                    goto encodingError;
                }

                hr = lber->HrEndWriteSequence();
                ASSERT( hr == NOERROR );
            }

            hr = lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );
        }

        //
        //  put in the server controls here if required
        //

        if ( (Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
             ( Request->ServerControls != NULL )) {

            hr = InsertServerControls( Request, Connection, lber );

            if (hr != LDAP_SUCCESS) {

                if (lber != NULL) {
                   delete lber;
                }
                return hr;
            }
        }

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );
    }

    //
    //  send the compare request.
    //
    
    ACQUIRE_LOCK( &Connection->ReconnectLock );

    AddToPendingList( Request, Connection );

    hr = LdapSend( Connection, lber );

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_compare connection 0x%x send with error of 0x%x.\n",
                        Connection, hr );
        }
        DecrementPendingList( Request, Connection );

    } else {

        //
        //  Save off the lber value, free any lber message that is already
        //  present.
        //

        lber = (CLdapBer *) InterlockedExchangePointer((PVOID *) Lber,
                                                       (PVOID) lber );
    }

    RELEASE_LOCK( &Connection->ReconnectLock );

    if (lber != NULL) {

       delete lber;
    }

    return hr;

encodingError:

    if (lber != NULL) {
        delete lber;
    }

    return LDAP_ENCODING_ERROR;
}

ULONG __cdecl
ldap_compareW (
    LDAP *ExternalHandle,
    PWCHAR DistinguishedName,
    PWCHAR Attribute,
    PWCHAR Value
    )
{
    PLDAP_CONN connection = NULL;
    ULONG err;
    ULONG msgId;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapCompare(connection,
                      DistinguishedName,
                      Attribute,
                      Value,
                      NULL,
                      TRUE,
                      FALSE,
                      NULL,
                      NULL,
                      &msgId
                      );

    DereferenceLdapConnection( connection );

    return msgId;
}

ULONG __cdecl
ldap_compare (
    LDAP *ExternalHandle,
    PCHAR DistinguishedName,
    PCHAR Attribute,
    PCHAR Value
    )
{
    ULONG err;
    ULONG msgId = (ULONG) -1;

    err = ldap_compare_extA(ExternalHandle,
                            DistinguishedName,
                            Attribute,
                            Value,
                            NULL,
                            NULL,
                            NULL,
                            &msgId
                            );
    return msgId;
}


ULONG __cdecl
ldap_compare_sW (
    LDAP *ExternalHandle,
    PWCHAR DistinguishedName,
    PWCHAR Attribute,
    PWCHAR Value
    )
{
    return ldap_compare_ext_sW(  ExternalHandle,
                                 DistinguishedName,
                                 Attribute,
                                 Value,
                                 NULL,
                                 NULL,
                                 NULL
                                 );
}

ULONG __cdecl
ldap_compare_s (
    LDAP *ExternalHandle,
    PCHAR DistinguishedName,
    PCHAR Attribute,
    PCHAR Value
    )
{
    return ldap_compare_ext_sA( ExternalHandle,
                                DistinguishedName,
                                Attribute,
                                Value,
                                NULL,
                                NULL,
                                NULL
                                );
}

ULONG __cdecl
ldap_compare_extW(
        LDAP *ExternalHandle,
        PWCHAR DistinguishedName,
        PWCHAR Attr,
        PWCHAR Value,           // either value or Data is not null, not both
        struct berval   *Data,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           *MessageNumber
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err =  LdapCompare( connection,
                        DistinguishedName,
                        Attr,
                        Value,
                        Data,
                        TRUE,
                        FALSE,
                        ServerControls,
                        ClientControls,
                        MessageNumber
                        );

    DereferenceLdapConnection( connection );

    return err;
}


ULONG __cdecl
ldap_compare_extA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        PCHAR Attr,
        PCHAR Value,           // either value or Data is not null, not both
        struct berval   *Data,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        ULONG           *MessageNumber
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    PLDAP_CONN connection = NULL;
    PWCHAR wAttr = NULL;
    PWCHAR wValue = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (MessageNumber == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *MessageNumber = (ULONG) -1;

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        goto error;
    }

    err = ToUnicodeWithAlloc( Attr, -1, &wAttr, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        goto error;
    }

    if ((Value != NULL) && (Data == NULL)) {

        err = ToUnicodeWithAlloc( Value, -1, &wValue, LDAP_UNICODE_SIGNATURE, LANG_ACP );

        if (err != LDAP_SUCCESS) {

            SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
            goto error;
        }
    }

    err = LdapCompare(   connection,
                         wName,
                         wAttr,
                         wValue,
                         Data,
                         FALSE,
                         FALSE,
                         (PLDAPControlW *) ServerControls,
                         (PLDAPControlW *) ClientControls,
                         MessageNumber
                         );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wValue)
        ldapFree( wValue, LDAP_UNICODE_SIGNATURE );

    if (wAttr)
        ldapFree( wAttr, LDAP_UNICODE_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}


ULONG __cdecl
ldap_compare_ext_sW(
        LDAP *ExternalHandle,
        PWCHAR DistinguishedName,
        PWCHAR Attr,
        PWCHAR Value,           // either value or Data is not null, not both
        struct berval   *Data,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls
        )
{
    ULONG msgId;
    ULONG err;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapCompare( connection,
                       DistinguishedName,
                       Attr,
                       Value,
                       Data,
                       TRUE,
                       TRUE,
                       ServerControls,
                       ClientControls,
                       &msgId
                       );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                      );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     results,
                                     TRUE
                                     );
        }
    }

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_compare_ext_sA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        PCHAR Attr,
        PCHAR Value,            // either value or Data is not null, not both
        struct berval   *Data,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    ULONG msgId;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;
    PWCHAR wAttr = NULL;
    PWCHAR wValue = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    err = ToUnicodeWithAlloc( Attr, -1, &wAttr, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    if ((Value != NULL) && (Data == NULL)) {

        err = ToUnicodeWithAlloc( Value, -1, &wValue, LDAP_UNICODE_SIGNATURE, LANG_ACP );

        if (err != LDAP_SUCCESS) {

            goto error;
        }
    }

    err = LdapCompare(   connection,
                         wName,
                         wAttr,
                         wValue,
                         Data,
                         FALSE,
                         TRUE,
                         (PLDAPControlW *) ServerControls,
                         (PLDAPControlW *) ClientControls,
                         &msgId
                         );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                    );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     results,
                                     TRUE
                                     );
        }
    }

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wAttr)
        ldapFree( wAttr, LDAP_UNICODE_SIGNATURE );

    if (wValue)
        ldapFree( wValue, LDAP_UNICODE_SIGNATURE );

    ASSERT(connection != NULL);
    DereferenceLdapConnection( connection );

    return err;
}

// compare.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\controls.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    controls.cxx  control block maintencance for the LDAP api

Abstract:

   This module implements routines that handle client and server controls

Author:

    Andy Herron (andyhe)        02-Apr-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

#define LDAP_CONTROL_NOTIFICATIONS_W    L"1.2.840.113556.1.4.528"

ULONG
LdapDupControls (
    PLDAP_REQUEST Request,
    PLDAPControlW **OutputControls,
    PLDAPControlW *InputControls,
    BOOLEAN Unicode,
    ULONG ExtraSlots
    );

ULONG
LdapCheckControls (
    PLDAP_REQUEST Request,
    PLDAPControlW *ServerControls,
    PLDAPControlW *ClientControls,
    BOOLEAN Unicode,
    ULONG   ExtraSlots
    )
{
    ULONG err = LDAP_SUCCESS;

    if (Request->AllocatedControls) {

        ldap_controls_freeW( Request->ServerControls );
        Request->ServerControls = NULL;

        ldap_controls_freeW( Request->ClientControls );
        Request->ClientControls = NULL;

        Request->AllocatedControls = FALSE;
    }

    if ((ServerControls == NULL) &&
        (ClientControls == NULL) &&
        (ExtraSlots == 0)) {

        return LDAP_SUCCESS;
    }

    PLDAPControlW currentControl;

    if (ClientControls != NULL) {

        //
        //  if any of them are mandatory and we don't support them, return error
        //

        PLDAPControlW *controls = ClientControls;

        while (*controls != NULL) {

            currentControl = *controls;

            //
            //  right now it's real easy, the only one we support is the
            //  one that sets referrals options per request
            //

            BOOLEAN setReferrals = FALSE;

            if (Unicode) {

                if (ldapWStringsIdentical( currentControl->ldctl_oid,
                                           -1,
                                           LDAP_CONTROL_REFERRALS_W,
                                           -1 ) == TRUE ) {
                    setReferrals = TRUE;
                }
            } else {

                if (CompareStringA( LDAP_DEFAULT_LOCALE,
                                    NORM_IGNORECASE,
                                    (PCHAR) currentControl->ldctl_oid,
                                    -1,
                                    LDAP_CONTROL_REFERRALS,
                                    -1 ) == 2) {

                    setReferrals = TRUE;
                }
            }

            if (setReferrals) {

                if ((currentControl->ldctl_value.bv_len != sizeof(ULONG)) ||
                    (currentControl->ldctl_value.bv_val == NULL)) {

                    setReferrals = FALSE;       // bad client control

                } else {

                    ULONG refFlags = *((ULONG *)(currentControl->ldctl_value.bv_val));

                    if (refFlags == PtrToUlong(LDAP_OPT_ON)) {

                        Request->ChaseReferrals = (LDAP_CHASE_SUBORDINATE_REFERRALS |
                                                   LDAP_CHASE_EXTERNAL_REFERRALS);

                    } else if (refFlags == PtrToUlong(LDAP_OPT_OFF)) {

                        Request->ChaseReferrals = 0;

                    } else if ((refFlags & (LDAP_CHASE_SUBORDINATE_REFERRALS |
                                            LDAP_CHASE_EXTERNAL_REFERRALS))
                                 != refFlags) {

                        setReferrals = FALSE;       // bad client control

                    } else {

                        Request->ChaseReferrals = LOBYTE( LOWORD( refFlags ) );
                    }
                    IF_DEBUG(REFERRALS) {
                        LdapPrint2( "LdapCheckControls set referrals to 0x%x for request 0x%x\n",
                                    Request->ChaseReferrals, Request );
                    }
                }
            }

            if ((currentControl->ldctl_iscritical) && (setReferrals == FALSE)) {

                IF_DEBUG(API_ERRORS) {
                    LdapPrint1( "LdapCheckControls does not support client control %S\n",
                                currentControl->ldctl_oid );
                }
                return LDAP_UNAVAILABLE_CRIT_EXTENSION;
            }
            controls++;
        }
    }

    
    //
    // Always allocate controls.
    //

    {
        Request->AllocatedControls = TRUE;

        //
        //  grab the controls and store them off on the request block
        //

        if ((ServerControls != NULL) || (ExtraSlots > 0)) {

            err = LdapDupControls( Request,
                                   &Request->ServerControls,
                                    ServerControls,
                                    Unicode,
                                    ExtraSlots );

            if (err != LDAP_SUCCESS) {

                IF_DEBUG(CONTROLS) {
                    LdapPrint1( "LdapCheckControls could not dup server control, err 0x%x\n",
                                err );
                }
                return err;
            }
        }

        if (ClientControls != NULL) {

            err = LdapDupControls( Request,
                                   &Request->ClientControls,
                                    ClientControls,
                                    Unicode,
                                    ExtraSlots );

            if (err != LDAP_SUCCESS) {

                IF_DEBUG(CONTROLS) {
                    LdapPrint1( "LdapCheckControls could not dup client control, err 0x%x\n",
                                err );
                }
                return err;
            }
        }
    }

    return err;
}

ULONG
LdapDupControls (
    PLDAP_REQUEST Request,
    PLDAPControlW **OutputControls,
    PLDAPControlW *InputControls,
    BOOLEAN Unicode,
    ULONG ExtraSlots
    )
//
//  If ExtraSlots is not zero, then instead of converting from ansi to unicode,
//  we just leave them in ansi.  This is used in paged results, since we don't
//  want to convert from ansi to unicode twice.
//
{
    ULONG err = LDAP_SUCCESS;
    ULONG numberEntries = 1;
    PLDAPControlW currentControl;
    PLDAPControlW *controls = InputControls;

    if (controls != NULL) {

        PLDAPControlW temp;

        while (*controls != NULL) {

            temp = *controls;

            //
            // If they pass us an empty control, bail.
            //

            if (temp->ldctl_oid == NULL) {
                break;
            }
            numberEntries++;
            controls++;
        }
    }

    numberEntries += ExtraSlots;

    if (numberEntries == 1) {

        *OutputControls = NULL;
        return LDAP_SUCCESS;
    }

    PLDAPControlW *newArray;
    PLDAPControlW newControl;

    newArray = (PLDAPControlW *) ldapMalloc(
                (numberEntries * sizeof(PLDAPControlW)) +
                ((numberEntries - 1) * sizeof(LDAPControlW)),
                LDAP_CONTROL_LIST_SIGNATURE );

    if (newArray == NULL) {

        return LDAP_NO_MEMORY;
    }

    controls = InputControls;

    newControl = (PLDAPControlW) &(newArray[numberEntries]);

    *OutputControls = newArray;

    //
    //  setup new array of pointers to controls.  set up the copies of the
    //  controls also.
    //

    while ((--numberEntries) > 0 && (err == LDAP_SUCCESS)) {

        if (controls != NULL) {

            currentControl = *controls;

        } else {

            currentControl = NULL;
        }

        *newArray = newControl;

        //
        //  take into account that we may have some empty entries at the
        //  end, though we still setup the pointers for them.  These are for
        //  for the server sort and paged results control.
        //

        if (currentControl != NULL) {

            newControl->ldctl_iscritical = currentControl->ldctl_iscritical;

            if (Unicode) {

                newControl->ldctl_oid = ldap_dup_stringW(
                                                currentControl->ldctl_oid,
                                                0,
                                                LDAP_VALUE_SIGNATURE );

                err = (newControl->ldctl_oid == NULL) ? LDAP_NO_MEMORY : LDAP_SUCCESS;

            } else if (ExtraSlots > 0) {

                newControl->ldctl_oid = (PWCHAR) ldap_dup_string(
                            (PCHAR) currentControl->ldctl_oid,
                            0,
                            LDAP_VALUE_SIGNATURE );

                err = (newControl->ldctl_oid == NULL) ? LDAP_NO_MEMORY : LDAP_SUCCESS;
                

            } else {

                err = ToUnicodeWithAlloc( (PCHAR) currentControl->ldctl_oid,
                                          -1,
                                          &newControl->ldctl_oid,
                                          LDAP_VALUE_SIGNATURE,
                                          LANG_ACP );
                

            }

            if (err != LDAP_SUCCESS) {

               break;
            }

            if (ldapWStringsIdentical( newControl->ldctl_oid,
                                       -1,
                                       LDAP_CONTROL_NOTIFICATIONS_W,
                                       -1) == TRUE) {
                
                IF_DEBUG(CONTROLS) {
                    LdapPrint0("Detected a notifications request\n");
                }
                Request->NotificationSearch = TRUE;
            }

            newControl->ldctl_value.bv_len = currentControl->ldctl_value.bv_len;

            if (newControl->ldctl_value.bv_len > 0) {

                newControl->ldctl_value.bv_val = (PCHAR) ldapMalloc(
                                        newControl->ldctl_value.bv_len,
                                        LDAP_CONTROL_SIGNATURE );

                if (newControl->ldctl_value.bv_val == NULL) {

                    err = LDAP_NO_MEMORY;
                    break;
                }

                CopyMemory( newControl->ldctl_value.bv_val,
                            currentControl->ldctl_value.bv_val,
                            newControl->ldctl_value.bv_len );
            }

            controls++;
        }

        newArray++;
        newControl++;
    }

    *newArray = NULL;

    if (err != LDAP_SUCCESS) {

        ldap_controls_freeW( *OutputControls );
        *OutputControls = NULL;
    }

    return err;
}

BOOLEAN
LdapCheckForMandatoryControl (
    PLDAPControlW *Controls
    )
{
    if (Controls == NULL) {

        return FALSE;
    }

    PLDAPControlW currentControl;

    //
    //  if any of them are mandatory and we don't support them, return error
    //

    while (*Controls != NULL) {

        currentControl = *Controls;

        if (currentControl->ldctl_iscritical) {

            return TRUE;
        }

        Controls++;
    }
    return FALSE;
}

ULONG
InsertServerControls (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection,
    CLdapBer *lber
    )
{
    ULONG hr;

    if ((Request->ServerControls == NULL) ||
        (*(Request->ServerControls) == NULL)) {

        return LDAP_SUCCESS;
    }

    PLDAPControlW currentControl;
    PLDAPControlW *controls = Request->ServerControls;

    hr = lber->HrStartWriteSequence( 0xA0 );    // constructed
                                                // context specific
                                                // tag is 0
    if (hr != NOERROR) {

        IF_DEBUG(CONTROLS) {
            LdapPrint2( "InsertServerControls conn 0x%x encoding error of 0x%x.\n",
                        Connection, hr );
        }
        return hr;

    } else {        // we can't forget EndWriteSequence

        while (*controls != NULL) {

            currentControl = *controls;

            hr = lber->HrStartWriteSequence();

            if (hr != NOERROR) {

                break;
            }

            hr = lber->HrAddValue((const WCHAR *) currentControl->ldctl_oid);

            if (hr != NOERROR) {

                IF_DEBUG(CONTROLS) {
                    LdapPrint3( "InsertServerControls conn 0x%x encoding error of 0x%x, oid = %S.\n",
                                Connection, hr, currentControl->ldctl_oid );
                }
                return hr;
            }

            hr = lber->HrAddValue((BOOLEAN) currentControl->ldctl_iscritical, BER_BOOLEAN );
            if (hr != NOERROR) {

                IF_DEBUG(CONTROLS) {
                    LdapPrint3( "InsertServerControls conn 0x%x encoding crit err 0x%x, oid = %S.\n",
                                Connection, hr, currentControl->ldctl_oid );
                }
                return hr;
            }

            hr = lber->HrAddBinaryValue((BYTE *) currentControl->ldctl_value.bv_val,
                                                 currentControl->ldctl_value.bv_len );
            if (hr != NOERROR) {

                IF_DEBUG(CONTROLS) {
                    LdapPrint3( "InsertServerControls conn 0x%x encoding value err 0x%x, oid = %S.\n",
                                Connection, hr, currentControl->ldctl_oid );
                }
                return hr;
            }

            hr = lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );

            controls++;
        }

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );
    }

    return hr;
}


ULONG
LdapRetrieveControlsFromMessage (
    PLDAPControlW **ControlArray,
    ULONG codePage,
    CLdapBer *Lber
    )
{
    //
    //  coming in here, we've just started reading the sequence of controls.
    //
    //  This gets a bit tricky.  Since we don't want to keep manipulating
    //  the array of controls, we'll first count the number of controls
    //  there are in the message, allocate the array, and then go back and
    //  read them in.
    //
    //      Controls ::= SEQUENCE OF Control
    //
    //      Control ::= SEQUENCE {
    //              controlType             LDAPOID,
    //              criticality             BOOLEAN DEFAULT FALSE,
    //              controlValue            OCTET STRING OPTIONAL }
    //

    ULONG numberEntries = 1;

    PLDAPControlW *controls = NULL;
    PLDAPControlW newControl;
    ULONG hr = NOERROR;

    *ControlArray = NULL;

    while (hr == NOERROR) {

        hr = Lber->HrStartReadSequence();

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint1( "LdapParseResult couldn't decode control, result 0x%x.\n", hr);
            }
            continue;
        }

        numberEntries++;

        hr = Lber->HrEndReadSequence();
        ASSERT( hr == NOERROR );
    }

    if (numberEntries > 1) {

        controls = (PLDAPControlW *) ldapMalloc(
                    (numberEntries * sizeof(PLDAPControlW)) +
                    ((numberEntries - 1) * sizeof(LDAPControlW)),
                    LDAP_CONTROL_LIST_SIGNATURE );

        if (controls == NULL) {

            hr = LDAP_NO_MEMORY;

        } else {

            ULONG tag = BER_INVALID_TAG;

            // reset the Lber back to the beginning of the controls

            Lber->Reset(FALSE);

            hr = Lber->HrStartReadSequence(BER_SEQUENCE);
            ASSERT( hr == NOERROR );

            hr = Lber->HrSkipElement();     // skip message id
            ASSERT( hr == NOERROR );

            hr = Lber->HrPeekTag( &tag );
            ASSERT( hr == NOERROR );

            if (tag == BER_OCTETSTRING) {  //  if this is a UDP connection, skip the DN if specified.

                hr = Lber->HrSkipElement();
                ASSERT( hr == NOERROR );

                hr = Lber->HrPeekTag( &tag );
                ASSERT( hr == NOERROR );
            }

            if (tag == BER_SEQUENCE) {

                hr = Lber->HrStartReadSequence(tag);
                ASSERT( hr == NOERROR );
            }

            hr = Lber->HrPeekTag( &tag );
            ASSERT( hr == NOERROR );

            hr = Lber->HrStartReadSequence(tag);      // meat of LdapResult
            ASSERT( hr == NOERROR );

            hr = Lber->HrEndReadSequence();
            ASSERT( hr == NOERROR );

            hr = Lber->HrPeekTag( &tag );
            ASSERT( hr == NOERROR );

            hr = Lber->HrStartReadSequence(tag);      // start of controls
            ASSERT( hr == NOERROR );

            newControl = (PLDAPControlW) &(controls[numberEntries]);

            //
            //  setup new array of pointers to controls.  set up the
            //  copies of the controls also.
            //

            *ControlArray = controls;

            if (hr == NOERROR) {

                while ((--numberEntries) > 0 && (hr == NOERROR)) {

                    //
                    //  for each control, save off the OID, criticality, and
                    //  control value into the array of control structures.
                    //

                    *controls = newControl;

                    //      Control ::= SEQUENCE {
                    //              controlType             LDAPOID,
                    //              criticality             BOOLEAN DEFAULT FALSE,
                    //              controlValue            OCTET STRING OPTIONAL }

                    hr = Lber->HrStartReadSequence();

                    if (hr != NOERROR) {

                        IF_DEBUG(PARSE) {
                            LdapPrint1( "LdapParseResult couldn't parse control, result 0x%x.\n", hr);
                        }
                        break;
                    }

                    if (codePage == LANG_UNICODE) {

                        hr = Lber->HrGetValueWithAlloc(&newControl->ldctl_oid);

                    } else {

                        hr = Lber->HrGetValueWithAlloc((PCHAR *) &newControl->ldctl_oid);
                    }

                    if (hr != NOERROR) {

                        IF_DEBUG(PARSE) {
                            LdapPrint1( "LdapParseResult couldn't parse control, result 0x%x.\n", hr);
                        }
                        break;
                    }

                    LONG criticality = 0;

                    hr = Lber->HrGetValue( &criticality, BER_BOOLEAN );

                    newControl->ldctl_iscritical = ((criticality == 0) ? FALSE : TRUE );

                    PBYTE pData = NULL;

                    hr = Lber->HrGetBinaryValuePointer(&pData, &newControl->ldctl_value.bv_len);

                    if (hr != NOERROR) {

                        IF_DEBUG(PARSE) {
                            LdapPrint1( "LdapParseResult couldn't parse control, result 0x%x.\n", hr);
                        }
                        break;
                    }

                    if (newControl->ldctl_value.bv_len > 0) {

                        newControl->ldctl_value.bv_val = (PCHAR) ldapMalloc(
                                                newControl->ldctl_value.bv_len,
                                                LDAP_CONTROL_SIGNATURE );

                        if (newControl->ldctl_value.bv_val == NULL) {

                            hr = LDAP_NO_MEMORY;
                            break;
                        }

                        CopyMemory( newControl->ldctl_value.bv_val,
                                    pData,
                                    newControl->ldctl_value.bv_len );
                    }

                    controls++;
                    newControl++;
                }

                *controls = NULL;
            }
        }
    }

    return hr;
}


WINLDAPAPI
ULONG LDAPAPI
ldap_free_controlsW (               // old one that can be removed eventually
    PLDAPControlW *Controls
    )
{
    return ldap_controls_freeW( Controls );
}

WINLDAPAPI
ULONG LDAPAPI
ldap_free_controlsA (               // old one that can be removed eventually
        LDAPControlA **Controls
        )
{
    return ldap_free_controlsW( (PLDAPControlW *) Controls );
}

WINLDAPAPI
ULONG LDAPAPI
ldap_controls_freeA (
        LDAPControlA **Controls
        )
{
    return ldap_free_controlsW( (PLDAPControlW *) Controls );
}

WINLDAPAPI
ULONG LDAPAPI
ldap_control_freeA (
        LDAPControlA *Control
        )
{
    return ldap_control_freeW( (PLDAPControlW) Control );
}

WINLDAPAPI
ULONG LDAPAPI
ldap_controls_freeW (
        LDAPControlW **Controls
        )
{
    if (Controls != NULL) {

        PLDAPControlW *controls = Controls;

        //
        //  free the controls
        //

        while (*controls != NULL) {

            ldapFree( (*controls)->ldctl_oid, LDAP_VALUE_SIGNATURE );
            ldapFree( (*controls)->ldctl_value.bv_val, LDAP_CONTROL_SIGNATURE );
            controls++;
        }

        ldapFree( Controls, LDAP_CONTROL_LIST_SIGNATURE );
    }
    return LDAP_SUCCESS;
}

WINLDAPAPI ULONG
LDAPAPI
ldap_control_freeW (
        LDAPControlW *Control
        )
{
    if (Control != NULL) {
        ldapFree( Control->ldctl_oid, LDAP_VALUE_SIGNATURE );
        ldapFree( Control->ldctl_value.bv_val, LDAP_CONTROL_SIGNATURE );
        ldapFree( Control, LDAP_CONTROL_SIGNATURE );
    }
    return LDAP_SUCCESS;
}

// controls.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\debug.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    debug.h   LDAP client 32 debugging/tracing

Abstract:

   This module implements debugging/tracing macros

Author:

    Andy Herron    (andyhe)        08-May-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#ifndef _LDAPDEBUG_
#define _LDAPDEBUG_

extern DBGPRINT GlobalLdapDbgPrint;

//
//  If SRVDBG is not defined and DBG is TRUE, define SRVDBG
//

#ifndef DBG
#define DBG 0
#endif

// Debugging macros
//

#if !DBG
#define LDAPDBG 0
#else
#define LDAPDBG 1
#endif

#undef IF_DEBUG
#undef LDAP_ASSERT
#undef ASSERT     

extern ULONG LdapDebug;

#if LDAPDBG

    #if (WINVER >= 0x0400)

    ULONG
    _cdecl
    DbgPrint(
        PCH Format,
        ...
        );

    #endif

    #define LDAP_ASSERT  DebugBreak();
    #define ASSERT( x )   if ( !(x) ) DebugBreak();

    #define DEBUG if (TRUE)
    #define IF_DEBUG(flag) if (LdapDebug & (DEBUG_ ## flag))

    #define LdapPrint0(fmt) if (GlobalLdapDbgPrint) {(*GlobalLdapDbgPrint)(("0x%x: "),(GetCurrentThreadId()));(*GlobalLdapDbgPrint)((fmt));}
    #define LdapPrint1(fmt,v0) if (GlobalLdapDbgPrint) {(*GlobalLdapDbgPrint)(("0x%x: "),(GetCurrentThreadId()));(*GlobalLdapDbgPrint)((fmt),(v0));}
    #define LdapPrint2(fmt,v0,v1) if (GlobalLdapDbgPrint) {(*GlobalLdapDbgPrint)(("0x%x: "),(GetCurrentThreadId()));(*GlobalLdapDbgPrint)((fmt),(v0),(v1));}
    #define LdapPrint3(fmt,v0,v1,v2) if (GlobalLdapDbgPrint) {(*GlobalLdapDbgPrint)(("0x%x: "),(GetCurrentThreadId()));(*GlobalLdapDbgPrint)((fmt),(v0),(v1),(v2));}
    #define LdapPrint4(fmt,v0,v1,v2,v3) if (GlobalLdapDbgPrint) {(*GlobalLdapDbgPrint)(("0x%x: "),(GetCurrentThreadId()));(*GlobalLdapDbgPrint)((fmt),(v0),(v1),(v2),(v3));}
    #define PRINT_LITERAL(literal) if (GlobalLdapDbgPrint) {(*GlobalLdapDbgPrint)(("0x%x: "),(GetCurrentThreadId()));(*GlobalLdapDbgPrint)( #literal" = %lx\n", (literal) );}

#else

    #define ASSERT( x )   ;
    #define DEBUG if (FALSE)
    #define IF_DEBUG(flag) if (FALSE)
    #define IF_NCP_DEBUG(flag) if (FALSE)

    #define LdapPrint0(fmt)
    #define LdapPrint1(fmt,v0)
    #define LdapPrint2(fmt,v0,v1)
    #define LdapPrint3(fmt,v0,v1,v2)
    #define LdapPrint4(fmt,v0,v1,v2,v3)

#endif

#define DEBUG_TRACE1              0x00000001
#define DEBUG_TRACE2              0x00000002
#define DEBUG_REFCNT              0x00000004
#define DEBUG_HEAP                0x00000008

#define DEBUG_CACHE               0x00000010
#define DEBUG_SSL                 0x00000020
#define DEBUG_SPEWSEARCH          0x00000040
#define DEBUG_SERVERDOWN          0x00000080

#define DEBUG_CONNECT             0x00000100
#define DEBUG_RECONNECT           0x00000200
#define DEBUG_RECEIVEDATA         0x00000400
#define DEBUG_PING                0x00000800

#define DEBUG_EOM                 0x00001000
#define DEBUG_BER                 0x00002000
#define DEBUG_OUTMEMORY           0x00004000
#define DEBUG_CONTROLS            0x00008000

#define DEBUG_HANDLES             0x00010000
#define DEBUG_CLDAP               0x00020000
#define DEBUG_FILTER              0x00040000
#define DEBUG_BIND                0x00080000

#define DEBUG_NETWORK_ERRORS      0x00100000
#define DEBUG_SCRATCH             0x00200000
#define DEBUG_PARSE               0x00400000
#define DEBUG_REFERRALS           0x00800000

#define DEBUG_SEARCH              0x01000000
#define DEBUG_REQUEST             0x02000000
#define DEBUG_CONNECTION          0x04000000
#define DEBUG_INIT_TERM           0x08000000

#define DEBUG_API_ERRORS          0x10000000
#define DEBUG_STOP_ON_ERRORS      0x20000000 /* If set, stop on internal errs */
#define DEBUG_ERRORS2             0x40000000
#define DEBUG_ERRORS              0x80000000

//
// Logging lock
//

#if DBG
#define START_LOGGING           ACQUIRE_LOCK(&LoadLibLock)
#define END_LOGGING             RELEASE_LOCK(&LoadLibLock)
#else
#define START_LOGGING           
#define END_LOGGING             
#endif

#endif // ndef _LDAPDEBUG_

// debug.h eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\default.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    default.cxx utility routine to get default ldap server

Abstract:

Author:

    Chuck Chan     (chuckc)        10-Sep-1996
    Andy Herron    (andyhe)
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

//
// Misc definitions & helper functions
//

DWORD ReadRegLdapDefault (
    LPWSTR *Address
    );

VOID LoadNetApi32Now(
    VOID
    );

typedef DWORD (*PF_DsGetDcName) (
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN GUID *SiteGuid OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
);

typedef DWORD (*PF_NetApiBufferFree) (
    IN LPVOID Buffer
);

typedef DWORD (*PF_DsGetDcOpen) (
    IN LPCSTR DnsName,              // UTF-8 Name
    IN ULONG Reserved,
    IN LPCWSTR SiteName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCSTR DnsTreeName OPTIONAL,
    IN ULONG Flags,
    OUT PHANDLE RetGetDcContext
    );

typedef DWORD (*PF_DsGetDcOpenW) (
    IN LPCWSTR DnsName,              // Unicode Name
    IN ULONG Reserved,
    IN LPCWSTR SiteName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR DnsTreeName OPTIONAL,  // Unicode Name
    IN ULONG Flags,
    OUT PHANDLE RetGetDcContext
    );

typedef DWORD (*PF_DsGetDcNext) (
    IN HANDLE GetDcContextHandle,
    OUT PULONG SockAddressCount OPTIONAL,
    OUT LPSOCKET_ADDRESS *SockAddresses OPTIONAL,
    OUT LPSTR *DnsHostName OPTIONAL
    );

typedef DWORD (*PF_DsGetDcNextW) (
    IN HANDLE GetDcContextHandle,
    OUT PULONG SockAddressCount OPTIONAL,
    OUT LPSOCKET_ADDRESS *SockAddresses OPTIONAL,
    OUT LPWSTR *DnsHostName OPTIONAL     // Unicode Name
    );

typedef DWORD (*PF_DsGetDcClose) (
    IN HANDLE GetDcContextHandle
    );

typedef DWORD (*PF_DsGetDcCloseW) (
    IN HANDLE GetDcContextHandle
    );

typedef LONG (APIENTRY * PF_RegOpenKeyExW) (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
);

typedef LONG (APIENTRY * PF_RegQueryValueExW) (
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
);

typedef LONG (APIENTRY * PF_RegCloseKey) (
    HKEY hKey
    );

typedef DWORD (*PF_DsGetSiteNameW)(
    IN  LPCWSTR ComputerName OPTIONAL,
    OUT LPWSTR *SiteName
);

typedef DWORD (*PF_DsRoleGetPrimaryDomainInformation) (
    IN LPCWSTR lpServer OPTIONAL,
    IN DSROLE_PRIMARY_DOMAIN_INFO_LEVEL InfoLevel,
    OUT PBYTE *Buffer
);

typedef VOID (*PF_DsRoleFreeMemory) (
    IN PVOID    Buffer
);


PF_DsGetDcName pfDsGetDcName = NULL;
PF_DsGetDcOpen pfDsGetDcOpen = NULL;
PF_DsGetDcNext pfDsGetDcNext = NULL;
PF_DsGetDcClose pfDsGetDcClose = NULL;
PF_DsGetDcOpenW pfDsGetDcOpenW = NULL;
PF_DsGetDcNextW pfDsGetDcNextW = NULL;
PF_DsGetDcCloseW pfDsGetDcCloseW = NULL;
PF_NetApiBufferFree pfNetApiBufferFree = NULL;
PF_RegOpenKeyExW pfRegOpenKeyExW = NULL;
PF_RegQueryValueExW pfRegQueryValueExW = NULL;
PF_RegCloseKey pfRegCloseKey = NULL;
PF_DsGetSiteNameW pfDsGetSiteName = NULL;
PF_DsRoleGetPrimaryDomainInformation pfDsRoleGetPrimaryDomainInformation = NULL;
PF_DsRoleFreeMemory pfDsRoleFreeMemory = NULL;

BOOLEAN FailedNetApi32LoadLib = FALSE;
BOOLEAN FailedAdvApi32LoadLib = FALSE;

BOOLEAN  UnicodeDsGetDCx = TRUE;


VOID LoadNetApi32Now(
    VOID
    )
{
    //
    // if the netapi32 DLL is not loaded, we make sure its loaded now.
    //

    if ((pfNetApiBufferFree != NULL) || (FailedNetApi32LoadLib == TRUE)) {

        return;
    }

    ACQUIRE_LOCK( &LoadLibLock );

    if ((NetApi32LibraryHandle == NULL) && ! FailedNetApi32LoadLib) {

        // load the library. if it fails, it would have done a SetLastError.

        if ( !GlobalWin9x ) {
            
            NetApi32LibraryHandle = LoadLibraryA("NETAPI32.DLL");
        
        } else {
            
            NetApi32LibraryHandle = LoadLibraryA("LOGONSRV.DLL");
        }


        if (NetApi32LibraryHandle != NULL) {

            pfDsGetDcName =  (PF_DsGetDcName) GetProcAddress(
                                                NetApi32LibraryHandle,
                                                "DsGetDcNameW");
            //
            // On NT 5.1 and above, we will find the unicode versions
            // of the DsGetDcOpen/Next/Close.
            //

            pfDsGetDcOpenW =  (PF_DsGetDcOpenW) GetProcAddress(
                                                 NetApi32LibraryHandle,
                                                 "DsGetDcOpenW");

            if (pfDsGetDcOpenW) {

                //
                // Whistler and above.
                //
                

                pfDsGetDcNextW =  (PF_DsGetDcNextW) GetProcAddress(
                                                    NetApi32LibraryHandle,
                                                    "DsGetDcNextW");
                pfDsGetDcCloseW =  (PF_DsGetDcCloseW) GetProcAddress(
                                                    NetApi32LibraryHandle,
                                                    "DsGetDcCloseW");
            } else {

                UnicodeDsGetDCx = FALSE;
                
                pfDsGetDcOpen =  (PF_DsGetDcOpen) GetProcAddress(
                                                    NetApi32LibraryHandle,
                                                    "DsGetDcOpen");
                pfDsGetDcNext =  (PF_DsGetDcNext) GetProcAddress(
                                                    NetApi32LibraryHandle,
                                                    "DsGetDcNext");
                pfDsGetDcClose =  (PF_DsGetDcClose) GetProcAddress(
                                                    NetApi32LibraryHandle,
                                                    "DsGetDcClose");
            }

            pfNetApiBufferFree = (PF_NetApiBufferFree) GetProcAddress(
                                                NetApi32LibraryHandle,
                                                "NetApiBufferFree");
            pfDsGetSiteName =  (PF_DsGetSiteNameW) GetProcAddress(
                                                NetApi32LibraryHandle,
                                                "DsGetSiteNameW");
            pfDsRoleGetPrimaryDomainInformation = (PF_DsRoleGetPrimaryDomainInformation) GetProcAddress(
                                                  NetApi32LibraryHandle,
                                                  "DsRoleGetPrimaryDomainInformation");
            pfDsRoleFreeMemory = (PF_DsRoleFreeMemory) GetProcAddress(
                                                  NetApi32LibraryHandle,
                                                  "DsRoleFreeMemory");
        } else {

            //
            //  only try to loadlib the file once
            //

            FailedNetApi32LoadLib = TRUE;
        }
    }

    RELEASE_LOCK( &LoadLibLock );
    return;
}

//
// Synopsis:   This routine is a wrapper around DsGetDcName(). However, it also
//             returns data from registry in case we cant find the DC.
//
// Parameters: Address - Used to return array of address strings. Typically
//             "122.356.006.676" or "phoenix".
//
//             Count - size of array on input, count of items on output.
//
//             Verify - if TRUE will as DsGetDcName to DS_FORCE_REDISCOVERY
//
// Returns:    NO_ERROR or Win32 error code.
//
// Notes:      The strings returned in the result array need to be freed
//
//
// Example usage:
//
//    if (err = GetDefaultLdapServer(NULL, Addresses, &Count, FALSE)) {
//
//         printf("GetDefaultLdapServer failed with: %d\n", err) ;
//    }
//
//    printf("LDAP servers are:\n") ;
//    for (i = 0; i < Count; i++) {
//
//        printf("%S\n", Addresses[i]) ;
//        (void) LocalFree(Addresses[i]) ;
//    }
//

DWORD
GetDefaultLdapServer(
    PWCHAR DomainName,
    LPWSTR Addresses[],
    LPWSTR DnsHostNames[],
    LPWSTR MemberDomains[],
    LPDWORD Count,
    ULONG DsFlags,
    BOOLEAN *SameSite,
    USHORT PortNumber
    )
{
    DWORD  err = 0;
    DWORD  index = 0 ;
    PDOMAIN_CONTROLLER_INFOW pDomainControllerInfo ;

    if (!Addresses || !Count || !DnsHostNames || !SameSite || !MemberDomains) {

        return ERROR_INVALID_PARAMETER ;
    }

    *SameSite = FALSE;

    if ((!GlobalWin9x) && (index < *Count) && (DomainName == NULL)) {

        err = ReadRegLdapDefault(Addresses + index) ;

        if (err == NO_ERROR) {
            index++ ;
        }
    }

    // if not already loaded, load dll now

    (void) LoadNetApi32Now() ;

    if ((pfDsGetDcName != NULL) && (index < *Count)) {

       DWORD Flags = 0;

       if (( PortNumber == LDAP_GC_PORT ) ||
            ( PortNumber == LDAP_SSL_GC_PORT )) {

          Flags = ( DS_GC_SERVER_REQUIRED |
                    DS_RETURN_DNS_NAME    |
                    DsFlags );
       
       } else {

          //
          // By default, look for DCs
          //

          Flags = ( DS_DIRECTORY_SERVICE_REQUIRED |
                    DS_RETURN_DNS_NAME            |
                    DsFlags );
       }

        err = (*pfDsGetDcName)(NULL,
                               DomainName,
                               NULL,
                               NULL,
                               Flags,
                               &pDomainControllerInfo
                               ) ;
        if (err == NO_ERROR) {

            ASSERT((pDomainControllerInfo->DomainControllerAddress[1] \
                   == TEXT('\\'))) ;

            Addresses[index] = ldap_dup_stringW( pDomainControllerInfo->
                                                DomainControllerAddress+2,
                                                0,
                                                LDAP_HOST_NAME_SIGNATURE );

            DnsHostNames[index] = ldap_dup_stringW( pDomainControllerInfo->
                                                    DomainControllerName+2,
                                                    0,
                                                    LDAP_HOST_NAME_SIGNATURE );

            MemberDomains[index] = ldap_dup_stringW( pDomainControllerInfo->
                                                    DomainName,
                                                    0,
                                                    LDAP_HOST_NAME_SIGNATURE );

            if ((pDomainControllerInfo->DcSiteName) && (pDomainControllerInfo->ClientSiteName)) {

                  if ( (lstrcmpW(pDomainControllerInfo->DcSiteName, pDomainControllerInfo->ClientSiteName) == 0)) {
      
                     *SameSite = TRUE;
                  } else {
      
                     *SameSite = FALSE;
                  }
            } else {

               *SameSite = FALSE;
            }

            //
            // If there are dots at the end of either the DC name or the domain
            // name, we will strip it off.
            //

            PWCHAR checkForEndDot =  NULL;

            if ( DnsHostNames[index] ) {
                  
                 checkForEndDot = DnsHostNames[index];

                  while (*checkForEndDot != L'\0') {
                     checkForEndDot++;
                  }
                  
                  if (*(checkForEndDot-1) == L'.') {
                     //
                     // Remove the '.' at the end.
                     //
                     *(checkForEndDot-1) = L'\0';
                  }
            }
            
            if ( MemberDomains[index] ) {
                
                checkForEndDot = MemberDomains[index];

                 while (*checkForEndDot != L'\0') {
                    checkForEndDot++;
                 }
                 
                 if (*(checkForEndDot-1) == L'.') {
                    //
                    // Remove the '.' at the end.
                    //
                    *(checkForEndDot-1) = L'\0';
                 }
            }


            if (pfNetApiBufferFree != NULL) {
                (*pfNetApiBufferFree)(pDomainControllerInfo);
            }
            index++ ;
        }
    }

    *Count = index ;
    return err;
}



DWORD LoadRegAPISet(void)
{
    DWORD error = ERROR_SUCCESS;

    // if not already loaded, load dll now
    ACQUIRE_LOCK( &LoadLibLock );

    if ((AdvApi32LibraryHandle == NULL) && ! FailedAdvApi32LoadLib ) {

        // load the library. if it fails, it would have done a SetLastError.

        AdvApi32LibraryHandle = LoadLibraryA("ADVAPI32.DLL");

        if (AdvApi32LibraryHandle == NULL) {

            //
            //  only try to loadlib the file once
            //

            FailedAdvApi32LoadLib = TRUE;
            pfRegOpenKeyExW = NULL;

            RELEASE_LOCK( &LoadLibLock );
            return GetLastError();
        }
    }

    if ((AdvApi32LibraryHandle != NULL) && (pfRegOpenKeyExW == NULL)) {

        pfRegOpenKeyExW =  (PF_RegOpenKeyExW) GetProcAddress(
                                                    AdvApi32LibraryHandle,
                                                    "RegOpenKeyExW");
        pfRegQueryValueExW = (PF_RegQueryValueExW) GetProcAddress(
                                                    AdvApi32LibraryHandle,
                                                    "RegQueryValueExW");
        pfRegCloseKey = (PF_RegCloseKey) GetProcAddress(
                                                    AdvApi32LibraryHandle,
                                                    "RegCloseKey");

        if ((pfRegQueryValueExW == NULL) ||
            (pfRegCloseKey == NULL)) {

            pfRegOpenKeyExW = NULL;
            error = ERROR_FILE_NOT_FOUND;
        }
    }

    RELEASE_LOCK( &LoadLibLock );

    return error;
}


#define LDAP_INTEGRITY_DEFAULT_KEY      L"System\\CurrentControlSet\\Services\\LDAP"
#define LDAP_INTEGRITY_DEFAULT_VALUE    L"LdapClientIntegrity"

DWORD ReadRegIntegrityDefault(DWORD *pdwIntegrity)
{
    DWORD  err;
    HKEY   hKey;
    DWORD  dwType;
    DWORD  dwIntegSetting;
    DWORD  cbIntegSetting = sizeof(dwIntegSetting);

    //
    // Open the registry Key
    //

    if (err = RegOpenKeyExW (  HKEY_LOCAL_MACHINE,
                               LDAP_INTEGRITY_DEFAULT_KEY,
                               0L,
                               KEY_READ,
                               &hKey)) {

        return err ;
    }

    err = RegQueryValueExW (hKey,
                            LDAP_INTEGRITY_DEFAULT_VALUE,
                            NULL,
                            &dwType,
                            (LPBYTE) &dwIntegSetting,
                            &cbIntegSetting) ;

    if (err == ERROR_SUCCESS) {

        if (dwType != REG_DWORD) {
            err = ERROR_CANTREAD;
        }
        else {
            *pdwIntegrity = dwIntegSetting;
        }
    }

    RegCloseKey(hKey) ;

    return err;
}



#define LDAP_DEFAULT_KEY      L"System\\CurrentControlSet\\Services\\TcpIp\\Parameters"
#define LDAP_DEFAULT_VALUE    L"LdapAddress"

//
// Read data from place in registry instead
//
DWORD ReadRegLdapDefault(LPWSTR *Address)
{
    DWORD  err;
    HKEY   hKey;
    WCHAR   IpAddress[64] ;
    DWORD  dwType, cb = sizeof(IpAddress);

    // if not already loaded, load dll now
    err = LoadRegAPISet();
    if (err != ERROR_SUCCESS) {
        return err;
    }


    if (pfRegOpenKeyExW == NULL) {

        err = ERROR_FILE_NOT_FOUND;

    } else {

        //
        // Open the registry Key
        //

        if (err = (*pfRegOpenKeyExW) (  HKEY_LOCAL_MACHINE,
                                        LDAP_DEFAULT_KEY,
                                        0L,
                                        KEY_READ,
                                        &hKey)) {

            return err ;
        }

        err = (*pfRegQueryValueExW) (hKey,
                                     LDAP_DEFAULT_VALUE,
                                     NULL,
                                     &dwType,
                                     (LPBYTE) IpAddress,
                                     &cb) ;

        if (err == NO_ERROR) {

            *Address = ldap_dup_stringW( IpAddress,
                                        0,
                                        LDAP_HOST_NAME_SIGNATURE );

            if (!(*Address)) {
                err = GetLastError() ;
            }
        }

        (*pfRegCloseKey)(hKey) ;
    }
    return err ;
}


DWORD
InitLdapServerFromDomain(
    LPCWSTR DomainName,
    ULONG Flags,
    OUT HANDLE *Handle,
    LPWSTR *Site
    )
{
    DWORD  status;
    DWORD flags = Flags;
    PCHAR DomainNameU = NULL;   // UTF-8 domain name

    flags &= DS_PDC_REQUIRED |
             DS_GC_SERVER_REQUIRED |
             DS_WRITABLE_REQUIRED |
             DS_ONLY_LDAP_NEEDED;

    // if not already loaded, load dll now

    (void) LoadNetApi32Now() ;

    if ( UnicodeDsGetDCx && 
         ((pfDsGetDcOpenW  == NULL) ||
          (pfDsGetDcNextW  == NULL) ||
          (pfDsGetDcCloseW == NULL))) {
        
        return ERROR_FILE_NOT_FOUND ;   // something wrong here.
    }

    if ((pfDsGetDcOpen  == NULL) ||
        (pfDsGetDcNext  == NULL) ||
        (pfDsGetDcClose == NULL)) {

        return ERROR_FILE_NOT_FOUND ;   // Win9x possibly
    }

    if (Site != NULL ) {

        *Site = NULL;

        if (pfDsGetSiteName != NULL &&
            pfNetApiBufferFree != NULL) {

            status = (*pfDsGetSiteName)( NULL, Site );
        }
    }

    if ( UnicodeDsGetDCx ) {

        status = (*pfDsGetDcOpenW)( DomainName,     // Unicode domain name
                                    0,
                                    Site != NULL ? *Site : NULL,
                                    NULL,
                                    NULL,
                                    flags,
                                    Handle
                                    );

    
    } else {

        //
        // Convert domain name to UTF-8 to work around the inconsistency
        // in the API.
        //
    
    
        status = FromUnicodeWithAlloc( (PWCHAR) DomainName,
                                       &DomainNameU,
                                       LDAP_HOST_NAME_SIGNATURE,
                                       LANG_UTF8
                                       );
    
        if ( status != LDAP_SUCCESS ) {
    
            return status;
        }
    
        status = (*pfDsGetDcOpen)(
                                  (LPCSTR) DomainNameU,     // UTF-8 domain name
                                  0,
                                  Site != NULL ? *Site : NULL,
                                  NULL,
                                  NULL,
                                  flags,
                                  Handle
                                  );
    
    }

    return status;
}

DWORD
NextLdapServerFromDomain(
    HANDLE Handle,
    LPSOCKET_ADDRESS *SockAddresses,
    PWCHAR *DnsHostNameW,
    PULONG SocketCount
    )
{
    DWORD  status = NO_ERROR;
    HANDLE handle = NULL;
    PCHAR  DnsHostNameU = NULL;

    if (SockAddresses != NULL) {
        *SockAddresses = NULL;
    }

    if (SocketCount != NULL) {
        *SocketCount = 0;
    }

    if (DnsHostNameW != NULL) {
       *DnsHostNameW = NULL;
    }

    if ( UnicodeDsGetDCx ) {
        
        status = (*pfDsGetDcNextW)(  Handle,
                                     SocketCount,
                                     SockAddresses,
                                     DnsHostNameW
                                     ) ;
    } else {

        status = (*pfDsGetDcNext)(  Handle,
                                    SocketCount,
                                    SockAddresses,
                                    &DnsHostNameU
                                    ) ;
        
        if (( DnsHostNameU != NULL ) &&
            ( status == LDAP_SUCCESS )) {
    
            status = ToUnicodeWithAlloc(DnsHostNameU,
                                        -1,
                                        DnsHostNameW,
                                        LDAP_HOST_NAME_SIGNATURE,
                                        LANG_UTF8);
        }
    }

    return status;
}


DWORD
CloseLdapServerFromDomain(
    HANDLE Handle,
    LPWSTR Site
    )
{

    if ( UnicodeDsGetDCx ) {
    
        (*pfDsGetDcCloseW)(Handle) ;

    } else {

        (*pfDsGetDcClose)(Handle) ;
    }

    if (Site != NULL) {
        (*pfNetApiBufferFree)(Site);
    }

    return NO_ERROR;
}


#define LDAP_REF_DBG_KEY      L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\LDAP"
#define LDAP_REF_DBG_VALUE    L"ReferralPopup"

VOID
DiscoverDebugRegKey(
    VOID
    )
{
    DWORD  err;
    HKEY   hKey;
    DWORD  popup = 0;
    DWORD  dwType, cb = sizeof(popup);


//    ACQUIRE_LOCK( &LoadLibLock );

    if ((AdvApi32LibraryHandle == NULL) && ! FailedAdvApi32LoadLib ) {

        // load the library. if it fails, it would have done a SetLastError.

        AdvApi32LibraryHandle = LoadLibraryA("ADVAPI32.DLL");

        if (AdvApi32LibraryHandle == NULL) {

            //
            //  only try to loadlib the file once
            //

            FailedAdvApi32LoadLib = TRUE;
            pfRegOpenKeyExW = NULL;
            
            DbgPrint("Bad library handle\n");

//          RELEASE_LOCK( &LoadLibLock );
            return;
        }
    }

    if ((AdvApi32LibraryHandle != NULL) && (pfRegOpenKeyExW == NULL)) {

        pfRegOpenKeyExW =  (PF_RegOpenKeyExW) GetProcAddress(
                                                    AdvApi32LibraryHandle,
                                                    "RegOpenKeyExW");
        pfRegQueryValueExW = (PF_RegQueryValueExW) GetProcAddress(
                                                    AdvApi32LibraryHandle,
                                                    "RegQueryValueExW");
        pfRegCloseKey = (PF_RegCloseKey) GetProcAddress(
                                                    AdvApi32LibraryHandle,
                                                    "RegCloseKey");

        if ((pfRegQueryValueExW == NULL) ||
            (pfRegCloseKey == NULL)) {

            pfRegOpenKeyExW = NULL;
        }
    }

//    RELEASE_LOCK( &LoadLibLock );

    if (pfRegOpenKeyExW == NULL) {

       DbgPrint("Bad func ptr\n");

        return;

    } else {

        //
        // Open the registry Key
        //

        if (err = (*pfRegOpenKeyExW) (  HKEY_LOCAL_MACHINE,
                                        LDAP_REF_DBG_KEY,
                                        0L,
                                        KEY_READ,
                                        &hKey)) {
           DbgPrint("cant open regkey\n");

            return;
        }

        err = (*pfRegQueryValueExW) (hKey,
                                     LDAP_REF_DBG_VALUE,
                                     NULL,
                                     &dwType,
                                     (LPBYTE) &popup,
                                     &cb) ;

        if (err == NO_ERROR) {

        
           DbgPrint("Found debug key\n");
           PopupRegKeyFound = popup ? TRUE: FALSE;
        } else {
           DbgPrint("Bad api return value\n");

        }

        (*pfRegCloseKey)(hKey) ;
    }
    return ;
}



ULONG
GetCurrentMachineParams(
    PWCHAR* Address,
    PWCHAR* DnsHostName
    )
{

    //
    // Try our best to figure out if the current machine is a DC. If
    // we succeed, we return the machine name so that future binds can
    // create an SPN out of it. Note that we do not try to retrieve the
    // domain name of the current machine. This is because we don't want
    // to fail over to other members of this domain at a later stage.
    //
    
    #define MAX_DNS_NAME_SIZE    200
    ULONG err = LDAP_OTHER;

    // if not already loaded, load dll now

    (void) LoadNetApi32Now() ;
    
    if (!pfDsRoleGetPrimaryDomainInformation  ||
        !pfDsRoleFreeMemory) {

        return ERROR_FILE_NOT_FOUND;        // NT4 and Win9x
    }

    if (!Address || !DnsHostName) {

        return LDAP_LOCAL_ERROR;
    }

    *Address = *DnsHostName = NULL;

    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBasic = NULL;

    err = pfDsRoleGetPrimaryDomainInformation( NULL,
                                              DsRolePrimaryDomainInfoBasic,
                                              (PBYTE *)&pBasic
                                              );

    if (err != LDAP_SUCCESS) {

        return err;
    }

    if ((pBasic->MachineRole == DsRole_RoleBackupDomainController) ||
        (pBasic->MachineRole == DsRole_RolePrimaryDomainController)) {

        //
        // Copy the localhost IP address 
        //

        *Address = ldap_dup_stringW( L"127.0.0.1", 0, LDAP_HOST_NAME_SIGNATURE );

        if (!*Address) {
            
            err = LDAP_NO_MEMORY;
            goto CleanupAndExit;
        }

        DWORD bufSize = 0; 
        
        //
        // discover the size of the hostname
        //

        GetComputerNameW( NULL, &bufSize );

        if (bufSize == 0) {
            
            err = LDAP_LOCAL_ERROR;
            goto CleanupAndExit;
        }
        
        ASSERT( bufSize < 1000 );        
        
        *DnsHostName = (PWCHAR) ldapMalloc( (bufSize+1)*sizeof(WCHAR),
                                             LDAP_HOST_NAME_SIGNATURE );
            
        if (!*DnsHostName) {
            
            err = LDAP_NO_MEMORY;
            goto CleanupAndExit;
        }
        
        //
        // Call again to retrieve the actual hostname.
        //

        if ( !GetComputerNameW( *DnsHostName, &bufSize ) ) {

            err = LDAP_LOCAL_ERROR;
            goto CleanupAndExit;
        }
    
    } else {

        //
        // This machine is not a DC.
        //

        err = LDAP_UNAVAILABLE;
    }

CleanupAndExit:

        if (pBasic) {
            pfDsRoleFreeMemory( pBasic );
        }
        
        if (err != LDAP_SUCCESS) {
            ldapFree(*DnsHostName, LDAP_HOST_NAME_SIGNATURE);
            ldapFree(*Address, LDAP_HOST_NAME_SIGNATURE);
            *Address = *DnsHostName = NULL;
        }
        
        return err;

}

// default.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\decode.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    decode.cxx   decode data from an LDAP server

Abstract:

   This module handles decoding incoming data from an LDAP server

Author:

    Andy Herron (andyhe)        01-Jun-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"


ULONG __cdecl
ldap_result2error (
    LDAP            *ExternalHandle,
    LDAPMessage     *res,
    ULONG           FreeIt
    )
//
//  This is one of the main entry points of the LDAP API... it returns the
//  error code that the server returned to a requesting client.  We've already
//  parsed out the return code so there's not much work.
//
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);
    if (!connection && ExternalHandle)
    {
        return LDAP_PARAM_ERROR;
    }

    //
    //  since we return -1 on calls such as ldap_search as a message id, we'll
    //  explicitely check for it here.
    //

    if ( res == (LDAPMessage *) -1 ) {

        res = NULL;
    }

    if (res != NULL) {

        LDAPMessage *checkResult = res;

        err = res->lm_returncode;

        while ((checkResult != NULL) &&
               ((checkResult->lm_msgtype == LDAP_RES_REFERRAL) ||
                (checkResult->lm_msgtype == LDAP_RES_SEARCH_ENTRY))) {

            checkResult = checkResult->lm_chain;
        }

        //
        //  return the result from a non-search entry record, rather than just
        //  the first entry in the list.  This is because the server's
        //  return code is stored in the last entry.
        //

        if (checkResult != NULL) {
            err = checkResult->lm_returncode;
        }

        SetConnectionError( connection, err, NULL );

        if ( FreeIt ) {

            ldap_msgfree( res );
        }

    } else {

        if (connection != NULL) {

            err = connection->publicLdapStruct.ld_errno;

        } else {

            err = LDAP_LOCAL_ERROR;
        }
    }

    if (connection)
    {
        DereferenceLdapConnection( connection );
    }

    return err;
}

ULONG
LdapInitialDecodeMessage (
    IN PLDAP_CONN Connection,
    IN PLDAPMessage LdapMsg
    )
//
//  This routine breaks out the return code, opcode, and message number from
//  the response returned by the server.
//
{
    ULONG tag = 0;
    CLdapBer *lber;
    LONG messageNumber;
    ULONG err = LDAP_OPERATIONS_ERROR;
    ULONG hr;
    BOOLEAN enclosingSequence = FALSE;

    lber = (CLdapBer *) (LdapMsg->lm_ber);

    if ( lber == NULL ) {

        return LDAP_LOCAL_ERROR;
    }

    hr = lber->HrStartReadSequence(BER_SEQUENCE);
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapMsgFromBuff 1 conn 0x%x received protocol error 0x%x .\n",
                            Connection, hr);
        }

protocolError:
        SetConnectionError( Connection, LDAP_PROTOCOL_ERROR, NULL );
        return(LDAP_PROTOCOL_ERROR);
    }

    hr = lber->HrGetValue( &messageNumber );
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapMsgFromBuff 2 conn 0x%x received protocol error 0x%x .\n",
                            Connection, hr);
        }

        goto protocolError;
    }

    LdapMsg->lm_msgid = GET_BASE_MESSAGE_NUMBER( messageNumber );
    LdapMsg->lm_referral = (USHORT) GET_REFERRAL_NUMBER( messageNumber );

    hr = lber->HrPeekTag( &tag );
    ASSERT( hr == NOERROR );

    //
    //  if this is a UDP connection, skip the DN if specified.
    //

    if ((Connection->UdpHandle != INVALID_SOCKET) &&
        (Connection->publicLdapStruct.ld_version == LDAP_VERSION2) &&
        (tag == BER_OCTETSTRING)) {

        hr = lber->HrSkipElement();
        if ( hr != NOERROR ) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapMsgFromBuff 11 conn 0x%x received protocol error 0x%x .\n",
                                Connection, hr);
            }
            goto protocolError;
        }

        hr = lber->HrPeekTag( &tag );
        ASSERT( hr == NOERROR );
    }

    if (tag == BER_SEQUENCE) {

        hr = lber->HrStartReadSequence(tag);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapMsgFromBuff 3 conn 0x%x received protocol error 0x%x .\n",
                                Connection, hr);
            }

            goto protocolError;
        }

        enclosingSequence = TRUE;

        hr = lber->HrPeekTag( &tag );
        ASSERT( hr == NOERROR );
    }

    //
    //  strip off the protocolOp specification
    //

    LdapMsg->lm_msgtype = tag;
    hr = lber->HrStartReadSequence(LdapMsg->lm_msgtype);

    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapMsgFromBuff 5 conn 0x%x received protocol error 0x%x .\n",
                            Connection, hr);
        }

        goto protocolError;
    }

    //
    //  based on the message type, process the rest of it.
    //

    switch (LdapMsg->lm_msgtype) {
    case LDAP_RES_BIND:
    case LDAP_RES_SEARCH_RESULT:
    case LDAP_RES_MODIFY:
    case LDAP_RES_ADD:
    case LDAP_RES_DELETE:
    case LDAP_RES_MODRDN:
    case LDAP_RES_COMPARE:
    case LDAP_RES_EXTENDED:

        hr = lber->HrPeekTag( &tag );
        ASSERT( hr == NOERROR );

        if (tag == BER_SEQUENCE) {

            hr = lber->HrStartReadSequence(tag);
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldapMsgFromBuff 6 conn 0x%x received protocol error 0x%x .\n",
                                    Connection, hr);
                }

                goto protocolError;
            }
        }

        hr = lber->HrGetEnumValue( (LONG *) &err );
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapMsgFromBuff 7 conn 0x%x received protocol error 0x%x .\n",
                                Connection, hr);
            }

            goto protocolError;
        }

        //
        //  there's nothing left to process in this packet.  No need to
        //  process the rest of it as it's just two (or three) EndReadSequences.
        //

        break;

    case LDAP_RES_SEARCH_ENTRY:

        //
        //   save off the offset of the distinguished name since we refer to
        //   it so often
        //

        hr = lber->HrPeekTag( &tag );
        ASSERT( hr == NOERROR );

        if (tag == BER_SEQUENCE) {

            hr = lber->HrStartReadSequence(tag);
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldapMsgFromBuff 8 conn 0x%x received protocol error 0x%x .\n",
                                    Connection, hr);
                }
                goto protocolError;
            }
        }

        hr = lber->HrSetDNLocation();

        if (hr != LDAP_SUCCESS) {

            return hr;
        }

        err = 0;

        //
        //  searchEntry response can fail if the DN is absent.
        //

        break;

    case LDAP_RES_REFERRAL:

        //
        //  for a referral, all is well if we simply receive it.
        //

        hr = lber->HrPeekTag( &tag );
        ASSERT( hr == NOERROR );

        if (tag == BER_SEQUENCE) {

            hr = lber->HrStartReadSequence(BER_SEQUENCE);
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldapMsgFromBuff 6 conn 0x%x received protocol error 0x%x .\n",
                                    Connection, hr);
                }

                goto protocolError;
            }
        }

        err = 0;
        break;

    default:

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldapMsgFromBuff 10 conn 0x%x received protocol error tag=0x%x .\n",
                            Connection, LdapMsg->lm_msgtype);
        }
        goto protocolError;
    }

    LdapMsg->lm_returncode = err;
    SetConnectionError( Connection, err, NULL );

    return LDAP_SUCCESS;
}

// decode.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\cstream.cxx ===
/***

File: cstream.cxx

Description:

    This is a simple class used to manage the crypto stream
    in streams based protocols (SSL, PCT, Kerberos with packet
    encryption).

Authors:

    Cory West <corywest@microsoft.com>
    Anoop Anantha <AnoopA@microsoft.com>
      - added client certificate authentication code.
      - added StartTLS/StopTLS support.

Copyright (C) 2000 Microsoft Corporation
All rights reserved.

***/

#include "precomp.h"
#pragma hdrstop
#include "cstream.hxx"

SECURITY_STATUS
SSPINegotiateLoop(
    PLDAP_CONN   Connection,
    CtxtHandle * hContext,
    PCredHandle  phCred,
    ULONG        UserMethod,
    PCHAR        UserName,
    BOOL         fDoInitialRead
);

VOID *CryptStream::operator new (
    size_t cSize
    )
{
    return ldapMalloc( (DWORD) cSize, LDAP_SSL_CLASS_SIGNATURE );
}

VOID CryptStream::operator delete (
    VOID *pInstance
    )
{
    ldapFree( pInstance, LDAP_SSL_CLASS_SIGNATURE );
    return;
}

CryptStream::CryptStream(
    PLDAP_CONN pLdapConn,
    PSecurityFunctionTableW encryptFunctionTable,
    BOOLEAN UseSSL
)
/*+++

The only constructor for this class.

---*/
{

    Connection = pLdapConn;

    pCryptoBuffers = NULL;
    dwMaxMessage = 0;

    pbOutboundCrypto = NULL;
    cbOutboundCryptoLen = 0;
    EncryptFunctionTable = encryptFunctionTable;

    hSslCredentials.dwLower = (ULONG) -1;
    hSslCredentials.dwUpper = (ULONG) -1;

    hSslContext.dwUpper = (ULONG) -1;
    hSslContext.dwUpper = (ULONG) -1;

    pbInboundCrypto = NULL;
    cbInboundCryptoLen = 0;
    cbInboundCryptoBytes = 0;

    cbCongestedClearText = 0;

    bCurrentMessageSizeValid = FALSE;

    cbMaxBufferUsed = 0;
    cUnsignsPerformed = 0;

    cbNegotiateBuffer = 0;
    pbNegotiateBuffer = 0;

    if (!UseSSL) {
       
       //
       // Setup the stream sizes here
       //

        int retval = EncryptFunctionTable->QueryContextAttributesW(
                      &Connection->SecurityContext,
                      SECPKG_ATTR_SIZES,
                      (PVOID) &ContextSizes );


        IF_DEBUG( SSL ) {
            
            LdapPrint1("QryContextAttributes returned 0x%x\n",retval);
            LdapPrint4("Negotiate attr sizes %d %d %d %d\n", 
                        ContextSizes.cbMaxToken,
                        ContextSizes.cbMaxSignature,
                        ContextSizes.cbBlockSize,
                        ContextSizes.cbSecurityTrailer );

            SecPkgContext_PackageInfo ContextPackageInfo;

            retval = EncryptFunctionTable->QueryContextAttributesW(
                      &Connection->SecurityContext,
                      SECPKG_ATTR_PACKAGE_INFO,
                      &ContextPackageInfo );

            LdapPrint3( "PackageInfo: %S %S %d\n",
                        ContextPackageInfo.PackageInfo->Name,
                        ContextPackageInfo.PackageInfo->Comment,
                        ContextPackageInfo.PackageInfo->wRPCID
                        );

            if ( retval == SEC_E_OK ) {
                EncryptFunctionTable->FreeContextBuffer( ContextPackageInfo.PackageInfo );
            }
        
        }

        retval = EncryptFunctionTable->QueryContextAttributesW(
                   &Connection->SecurityContext,
                   SECPKG_ATTR_STREAM_SIZES,
                   (PVOID) &SspiStreamSizes );

        if ((retval == SEC_E_OK) && (SspiStreamSizes.cbMaximumMessage != 0)) {
            dwMaxMessage = SspiStreamSizes.cbMaximumMessage;
        }
        else {
            // SSPI package imposes no size restriction
            dwMaxMessage = (DWORD) -1;
        }

        IF_DEBUG(SSL) {
            LdapPrint1("QryContextAttributes for SECPKG_ATTR_STREAM_SIZES returned 0x%x\n",retval);
            LdapPrint4("Stream sizes %d %d %d %d ", 
                        SspiStreamSizes.cbHeader,
                        SspiStreamSizes.cbTrailer,
                        SspiStreamSizes.cbMaximumMessage,
                        SspiStreamSizes.cBuffers);
            LdapPrint1("%d\n", SspiStreamSizes.cbBlockSize);
        }
        

    } else {  // using SSL.

        //
        // Fix up the correct function pointers to use for SSL encrypt/decrypt.
        //

        LdapSslEncrypt = (ENCRYPT_MESSAGE_FN) EncryptFunctionTable->Reserved3;
        LdapSslDecrypt = (DECRYPT_MESSAGE_FN) EncryptFunctionTable->Reserved4;

        ASSERT( LdapSslEncrypt );
        ASSERT( LdapSslDecrypt );

    }
    
    bUseSSL = UseSSL;

    return;
}

CryptStream::~CryptStream(
)
/*+++

The only destructor for this class.

---*/
{
    if ((hSslCredentials.dwLower != (ULONG) -1) ||
        (hSslCredentials.dwUpper != (ULONG) -1)) {

        EncryptFunctionTable->FreeCredentialHandle(
            &hSslCredentials );
    }

    if ((hSslContext.dwLower != (ULONG) -1) ||
        (hSslContext.dwUpper != (ULONG) -1)) {

        EncryptFunctionTable->DeleteSecurityContext(
            &hSslContext );
    }

    ldapFree( pbOutboundCrypto, LDAP_SECURITY_SIGNATURE );
    ldapFree( pbInboundCrypto, LDAP_SECURITY_SIGNATURE );
    ldapFree( pCryptoBuffers, LDAP_SECURITY_SIGNATURE );
    ldapFree( pbNegotiateBuffer, LDAP_SECURITY_SIGNATURE );

    return;
}

BOOLEAN
CryptStream::CheckInboundSpace(
    ULONG cbBytesNeeded
)
/*+++

Description:

    This internal routine checks to make sure that there
    are at least cbBytesNeeded available in the inbound
    crypto buffer.  The routine grows the buffer if
    necessary.

Parameters:

    cbBytesNeeded   - Minimum number of bytes to grow.

---*/
{

    PBYTE NewBuffer;
    ULONG NewBufferSize;

    if ( ( cbInboundCryptoLen - cbInboundCryptoBytes ) >= cbBytesNeeded ) {
        return TRUE;
    }

    //
    // Otherwise, resize.
    //

    NewBufferSize = cbInboundCryptoBytes + cbBytesNeeded + STREAM_GROW_SIZE;
    NewBuffer = (PBYTE) ldapMalloc( NewBufferSize, LDAP_SECURITY_SIGNATURE );

    if ( NewBuffer == NULL ) {
        return FALSE;
    }

    if (cbInboundCryptoBytes) {
        CopyMemory( NewBuffer, pbInboundCrypto, cbInboundCryptoBytes );
    }

    ldapFree( pbInboundCrypto, LDAP_SECURITY_SIGNATURE );

    pbInboundCrypto = NewBuffer;
    cbInboundCryptoLen = NewBufferSize;


    return TRUE;
}

ULONG CryptStream::DecryptLdapReceive(
    PLDAP_RECVBUFFER pCryptoReceive
)
/*+++

Description:

    This routine takes cipher text from the transport and
    processes it and passes it to the message pump.

Parameters:

    pCryptoReceive   - The next ldap receive.

Notes:

    This only gets called when the connection list lock
    is held so we don't have to worry about locking or
    ordering.

    If this ends up being slow, we could slow down all 
    client receives and may want to alter the way we 
    protect the message ordering here!

---*/
{

    ULONG LdapError = LDAP_SUCCESS;
    SECURITY_STATUS sErr;

    PBYTE pbCryptoHead, pbDecryptHead, pbClearTextHead;
    ULONG cbCryptoBytes, cbClearTextBytes;

    PLDAP_RECVBUFFER pDeleteReceive = NULL;

    if (!bUseSSL) {

      return (UnSignAndSealLdapStream( pCryptoReceive ));
    }

    
    //
    // If the crypt stream is in a congested state, try
    // to process the pending clear text before we do
    // more decrypto work.
    //
    // Congestion occurs when the inbound buffer has
    // cleartext at the head that we could not inject
    // into the message pump on a previous call.
    //

    if ( cbCongestedClearText ) {

        LdapError = InjectNewReceive( pbInboundCrypto,
                                      cbCongestedClearText );

        if ( LdapError != LDAP_SUCCESS ) {

            //
            // Still congested, don't process any crypto.
            //

            return LdapError;
        }

        //
        // Slide the crypto data if neccessary.
        //

        if ( cbInboundCryptoBytes ) {

            ldap_MoveMemory( (PCHAR) pbInboundCrypto,
                             (PCHAR) pbInboundCrypto + cbCongestedClearText,
                             cbInboundCryptoBytes );
        }

        cbCongestedClearText = 0;
    }

    //
    // Figure out what to decrypt.
    //
    // Here's how we use these buffers.  We decrypt in place in
    // either the crypt stream inbound buffer or in the receive
    // structure itself.  As we decrypt data, we slide the clear
    // text to the head of the buffer that we are decrypting.
    // When we can decrypt no more, we copy off the clear text
    // into the current receive structure or (if it's not big
    // enough) into a newly allocated receive structure.  We pass
    // this clear text receive out to the message pump.  If there's
    // left over crypto, we move it to the head of the inbound
    // crypto buffer for this stream.
    //

    if ( cbInboundCryptoBytes ) {

        //
        // If there's some residual crypto in the inbound
        // buffer, we have to append this data and decrypt
        // from the stream buffer.  Otherwise, we can
        // decrypt in place.
        //

        if ( !CheckInboundSpace( pCryptoReceive->NumberOfBytesReceived ) ) {
            return LDAP_NO_MEMORY;
        }

        pbCryptoHead = pbInboundCrypto + cbInboundCryptoBytes;

        ldap_MoveMemory( (PCHAR) pbCryptoHead,
                         (PCHAR)  &(pCryptoReceive->DataBuffer[0]),
                         pCryptoReceive->NumberOfBytesReceived );

        pbCryptoHead = pbInboundCrypto;
        cbCryptoBytes = cbInboundCryptoBytes + pCryptoReceive->NumberOfBytesReceived;
        pbDecryptHead = pbInboundCrypto;
        cbClearTextBytes = 0;

    } else {

        //
        // There's no pending crypto, so we can decrypt this
        // in place and save ourselves a copy.
        //

        pbCryptoHead = (PBYTE) &(pCryptoReceive->DataBuffer[0]);
        cbCryptoBytes = pCryptoReceive->NumberOfBytesReceived;
        pbDecryptHead = pbCryptoHead;
        cbClearTextBytes = 0;

    }

    //
    // Remember the start of the actual clear text!
    //

    pbClearTextHead = pbDecryptHead;

    //
    // Loop while there's data to decrypt.
    //

    while ( cbCryptoBytes ) {

        //
        // Setup the buffer chain.
        //

        pCryptoBuffers[0].pvBuffer =  pbCryptoHead;
        pCryptoBuffers[0].cbBuffer =  cbCryptoBytes;
        pCryptoBuffers[0].BufferType = SECBUFFER_DATA;

        for ( ULONG i = 1; i < SspiStreamSizes.cBuffers; i++ ) {
            pCryptoBuffers[i].pvBuffer = NULL;
            pCryptoBuffers[i].cbBuffer = 0;
            pCryptoBuffers[i].BufferType = SECBUFFER_EMPTY;
        }

        //
        // Actually decrypt the data!
        //

        sErr = LdapSslDecrypt(
                    &hSslContext,
                    &Decrypt,
                    0,
                    NULL );

        if ( sErr == ERROR_SUCCESS ) {

            //
            // We decrypted some data, update our pointers
            // and see if we need to continue.
            //

            pbCryptoHead = NULL;
            cbCryptoBytes = 0;

            for ( i = 1; i < SspiStreamSizes.cBuffers; i++ ) {

                if ( pCryptoBuffers[i].BufferType == SECBUFFER_DATA ) {

                    //
                    // Slide the data down if necessary.
                    //

                    if ( pbDecryptHead != pCryptoBuffers[i].pvBuffer ) {

                        ldap_MoveMemory( (PCHAR) pbDecryptHead,
                                         (PCHAR) pCryptoBuffers[i].pvBuffer,
                                         pCryptoBuffers[i].cbBuffer );
                    }

                    pbDecryptHead += pCryptoBuffers[i].cbBuffer;
                    cbClearTextBytes += pCryptoBuffers[i].cbBuffer;
                }

                if ( pCryptoBuffers[i].BufferType == SECBUFFER_EXTRA ) {

                    pbCryptoHead = (PBYTE) pCryptoBuffers[i].pvBuffer;
                    cbCryptoBytes = pCryptoBuffers[i].cbBuffer;
                }

            }

        } else if ( sErr == SEC_E_INCOMPLETE_MESSAGE ) {

            //
            // We've decrypted all we can.  Bail out.
            //

            break;

        } else if ( (sErr == SEC_I_RENEGOTIATE) ) {

            //
            // The server has just requested that the client initiate
            // another handshake sequence. At this point, the server will
            // typically send no more data until a ClientHello message
            // is received from the client. The client should send any
            // accumulated data (if it has any) and then start another
            // handshake sequence by calling InitializeSecurityContext.
            //

            //
            // You can not renegotiate an SSL connection while
            // a bind is in progress b/c the two procedures
            // use some common state variables...
            //

           if ( Connection->BindInProgress == TRUE) {

              return ERROR_LOGON_SESSION_COLLISION;
           }

            Connection->BindInProgress = TRUE;
            Connection->SslSetupInProgress = TRUE;

            sErr = SSPINegotiateLoop( FALSE );

            if ( sErr != SEC_E_OK ) {

               //
               // We failed to renegotiate for some reason. So, we have to
               // dump all crypto.
               //

               IF_DEBUG( SSL ) {
                   LdapPrint1( "wldap32: DecryptMessage couldn't decrypt.  sErr = 0x%x\n.", sErr );
               }

                cbInboundCryptoBytes = 0;
                RemoveEntryList( &pCryptoReceive->ReceiveListEntry );
                LdapFreeReceiveStructure( pCryptoReceive, TRUE );

                LdapError = LdapConvertSecurityError( Connection, sErr );
                return LdapError;
            }

            Connection->BindInProgress = FALSE;
            Connection->SslSetupInProgress = FALSE;

            //
            // When the last bit of handshake data is read from
            // the server, it often comes bundled with some encrypted
            // application data. This needs to be placed in the
            // pbCryptoHead buffer by the SSPINegotiateLoop function,
            // so that it can be decrypted in the next pass through the
            // loop.
            //

            continue;

        } else {

            //
            // We failed in some catastrophic way, so we
            // pretty much have to dump all crypto that
            // we have and try to recover on the next receive.
            // I'm betting this will never recover.
            //

            IF_DEBUG( SSL ) {
                LdapPrint1( "wldap32: DecryptMessage couldn't decrypt.  sErr = 0x%x\n.", sErr );
            }

            cbInboundCryptoBytes = 0;
            RemoveEntryList( &pCryptoReceive->ReceiveListEntry );
            LdapFreeReceiveStructure( pCryptoReceive, TRUE );

            LdapError = LdapConvertSecurityError( Connection, sErr );
            return LdapError;
        }

    }

    //
    // At this point, we have done all the decryption that
    // we can.  The following should be true:
    //
    //     pbClearTextHead   - The contiguous chunk of clear text.
    //     cbClearTextBytes  - The length of the clear text.
    //     cbCryptoBytes     - The left over crypto data.
    //     pbCryptoHead      - The left over crypto length.
    //
    // If we did the decryption in place in the receive
    // structure, we can just pass the data out in the receive
    // structure.  If we did the decryption in the crypt stream
    // buffer, but the clear text will fit in the current
    // receive structure, we can copy and pass the data out
    // in the receive.  Otherwise, we'll have to free the
    // current receive and allocate a larger one for the clear
    // text.
    //

    if ( ( cbInboundCryptoBytes ) &&
         ( cbClearTextBytes > pCryptoReceive->BufferSize ) ) {

        //
        // The resulting clear text won't fit in the current
        // receive buffer that we have, so we have to inject
        // an allocated buffer into the list.
        //

        LdapError = InjectNewReceive( pbClearTextHead,
                                      cbClearTextBytes );

        if ( LdapError != LDAP_SUCCESS ) {

            //
            // We couldn't inject so we have to leave the
            // stream in a congested state and try to
            // recover later.  Don't forget to slide to
            // leftover crypto down.
            //

            if ( cbCryptoBytes ) {

                ldap_MoveMemory( (PCHAR) pbInboundCrypto + cbClearTextBytes,
                                 (PCHAR) pbCryptoHead,
                                 cbCryptoBytes );

                cbInboundCryptoBytes = cbCryptoBytes;
                cbCryptoBytes = 0;
            }

            cbCongestedClearText = cbClearTextBytes;
        }

        //
        // Remove the receive from the list.  Since we know
        // we're working from the pending buffer in the crypt
        // stream, we can free this receive.
        //

        RemoveEntryList( &pCryptoReceive->ReceiveListEntry );
        LdapFreeReceiveStructure( pCryptoReceive, TRUE );

    } else if ( cbClearTextBytes ) {

        if ( cbInboundCryptoBytes == 0 ) {

            //
            // We used the actual receive buffer, so we can use
            // that same buffer to post the receive to the message
            // pump.
            //

            pCryptoReceive->NumberOfBytesReceived = cbClearTextBytes;

        } else if ( cbClearTextBytes <= pCryptoReceive->BufferSize ) {

            //
            // We did the decrypt in the stream, but the data
            // will fit in this receive, so use it.
            //

            CopyMemory( &(pCryptoReceive->DataBuffer[0]),
                        pbClearTextHead,
                        cbClearTextBytes );

            pCryptoReceive->NumberOfBytesReceived = cbClearTextBytes;

        }

        //
        // Move this receive to to completed list.
        //

        RemoveEntryList( &pCryptoReceive->ReceiveListEntry );
        InsertTailList( &Connection->CompletedReceiveList,
                        &pCryptoReceive->ReceiveListEntry );

    } else {

        //
        // There was no decrypted data, so we're done with
        // this receive.  We can't actually delete it until
        // we save off any pending crypto.
        //

        RemoveEntryList( &pCryptoReceive->ReceiveListEntry );
        pDeleteReceive = pCryptoReceive;

    }

    //
    // If there was any crypto data pending, put it in
    // the inbound buffer and we will do the right thing
    // on the next receive.
    //
    // We should try to protect this from failure
    // more since this will drop important crypto data.
    //

    if ( cbCryptoBytes ) {

        if ( pbInboundCrypto != pbCryptoHead ) {

            if ( !CheckInboundSpace( cbCryptoBytes ) ) {
                return LDAP_NO_MEMORY;
            }

            ldap_MoveMemory( (PCHAR) pbInboundCrypto,
                             (PCHAR) pbCryptoHead,
                             cbCryptoBytes );
        }

        cbInboundCryptoBytes = cbCryptoBytes;

    } else {

        cbInboundCryptoBytes = 0;
    }

    if ( pDeleteReceive ) {
        LdapFreeReceiveStructure( pDeleteReceive, TRUE );
    }

    return LdapError;
}

ULONG
CryptStream::InjectNewReceive(
    PBYTE pbClearText,
    ULONG cbClearText
)
/*+++

Description:

    This routine takes a block of clear text that is too
    big for the current receive buffer and injects into
    the message pump by allocating a properly sized
    receive buffer.

Arguments:

    pbClearText - The clear text buffer.
    cbClearText - The length of the clear text.

 ---*/
{

    PLDAP_RECVBUFFER pNewReceive;

    //
    // Allocate a new receive buffer.
    //

    pNewReceive = (PLDAP_RECVBUFFER) ldapMalloc( sizeof( LDAP_RECVBUFFER ) +
                                                 cbClearText,
                                                 LDAP_RECV_SIGNATURE );

    if ( pNewReceive == NULL ) {
        return LDAP_NO_MEMORY;
    }

    //
    //  Initialize non-zero fields.
    //

    pNewReceive->Connection = Connection;
    pNewReceive->BufferSize = cbClearText;
    pNewReceive->NumberOfBytesReceived = cbClearText;

    CopyMemory( &(pNewReceive->DataBuffer[0]),
                pbClearText,
                cbClearText );

    InsertTailList( &Connection->CompletedReceiveList,
                    &pNewReceive->ReceiveListEntry );

    return LDAP_SUCCESS;
}

ULONG
CryptStream::LdapSendSsl(
    PBYTE   pbClearText,
    ULONG   cbClearText
)
/*+++

Description:

    This routine takes the plain text request, encrypts it,
    and sends it off to the server.

Parameters:

    pbClearText   - The clear text request.
    cbClearText   - The length of the clear text.

Notes:

    This routine only gets called when the
    send lock for the host connection is held.
    The send lock protects the send data
    structures.

---*/
{

    ULONG           LdapError = LDAP_SUCCESS;
    SECURITY_STATUS sErr;
    SecBufferDesc   Encrypt;
    SecBuffer       CryptoBuffers[3];
    PBYTE           pbSendData, pbSendCrypto;
    ULONG           cbSendDataLeft, cbProcessedCrypto;
    ULONG           cbSpaceLeft, cbSpaceNeeded;
    ULONG           cbThisData;

    if (!bUseSSL) {

          return (SignAndSealLdapStream(pbClearText, cbClearText));
    }

    //
    // Set the initial pointers.
    //

    pbSendData = pbClearText;
    pbSendCrypto = pbOutboundCrypto;
    cbSendDataLeft = cbClearText;
    cbSpaceLeft = cbOutboundCryptoLen;
    cbProcessedCrypto = 0;

    //
    // Loop until we hit an error condition or run out of data to send.
    //

    for( ;; ) {

        //
        // How much will we process this time around?
        //

        if ( cbSendDataLeft > dwMaxMessage ) {
            cbThisData = dwMaxMessage;
        } else {
            cbThisData = cbSendDataLeft;
        }

        //
        // If there's not enough room to send another piece, or
        // if there's no more data to process, send what we have
        // processed so far and continue if necessary.
        //

        cbSpaceNeeded = SspiStreamSizes.cbHeader;
        cbSpaceNeeded += cbThisData;
        cbSpaceNeeded += SspiStreamSizes.cbTrailer;

        if ( ( cbSpaceNeeded > cbSpaceLeft ) ||
             ( cbSendDataLeft == 0 ) ) {

            //
            // Send what we have processed.
            //

            LdapError = LdapSendRaw( Connection,
                                     (PCHAR) pbOutboundCrypto,
                                     cbProcessedCrypto );

            if ( LdapError != LDAP_SUCCESS ) {
                break;
            }

            if ( cbSendDataLeft == 0 ) {

                //
                // There's no more data to process, so Exit.
                //

                break;

            } else {

                //
                // We've still got data, so reset the pointers.
                //

                pbSendCrypto = pbOutboundCrypto;
                cbSpaceLeft = cbOutboundCryptoLen;
                cbProcessedCrypto = 0;
            }

        }

        //
        // Prepare the encrypt buffer array.
        //

        CryptoBuffers[0].pvBuffer = pbSendCrypto;
        CryptoBuffers[0].cbBuffer = SspiStreamSizes.cbHeader;
        CryptoBuffers[0].BufferType = SECBUFFER_TOKEN;

        pbSendCrypto += SspiStreamSizes.cbHeader;
        cbSpaceLeft -= SspiStreamSizes.cbHeader;

        CryptoBuffers[1].pvBuffer = pbSendCrypto;
        CryptoBuffers[1].cbBuffer = cbThisData;
        CryptoBuffers[1].BufferType = SECBUFFER_DATA;

        ldap_MoveMemory( (PCHAR) pbSendCrypto, (PCHAR) pbSendData, cbThisData );

        cbSendDataLeft -= cbThisData;
        pbSendData += cbThisData;

        pbSendCrypto += cbThisData;
        cbSpaceLeft -= cbThisData;

        //
        // Not all packages require a trailer buffer.
        //

        if ( SspiStreamSizes.cbTrailer ) {

            CryptoBuffers[2].pvBuffer = pbSendCrypto;
            CryptoBuffers[2].cbBuffer = SspiStreamSizes.cbTrailer;
            CryptoBuffers[2].BufferType = SECBUFFER_TOKEN;

            pbSendCrypto += SspiStreamSizes.cbTrailer;
            cbSpaceLeft -= SspiStreamSizes.cbTrailer;

        } else {

            CryptoBuffers[2].pvBuffer = NULL;
            CryptoBuffers[2].cbBuffer = 0;
            CryptoBuffers[2].BufferType = SECBUFFER_EMPTY;

        }

        Encrypt.cBuffers = 3;
        Encrypt.pBuffers = CryptoBuffers;
        Encrypt.ulVersion = SECBUFFER_VERSION;

        //
        // Encrypt this portion of the message and continue.
        //

        sErr = LdapSslEncrypt(
               &hSslContext,
               0,
               &Encrypt,
               0 );

        LdapError = LdapConvertSecurityError( Connection, sErr );

        if ( LdapError != LDAP_SUCCESS ) {
            break;
        }
        
        cbProcessedCrypto = CryptoBuffers[0].cbBuffer +
                            CryptoBuffers[1].cbBuffer +
                            CryptoBuffers[2].cbBuffer;
    }

    //
    // We broke out of the loop, so either we
    // finished or there was an error.
    //

    return LdapError;
}

ULONG
CryptStream::NegotiateSecureConnection(
    PSecPkgInfoW Package
)
/*+++

Description:

    Negotiate an SSL session on the connection.
    We will always use the unified ssl/pct provider.

    This must not happen while a bind is in progress
    as we use some of the same state variable in
    each code path to track the SSPI status.

    This routine sets the following class private members:

        SspiPackage        - The package used on this connection.
        hSslCredentials    - The credentials handle for this connection.
        SslCredExpiry      - The expire time of these credentials.
        hSslContext        - The security context for this connection.
        SslContextExpiry   - The expire time of this context.
        SspiStreamSizes    - The stream sizes for this stream.

    This routine also allocates the pbOutboundCrypto buffer.

    This must return a Win32 error code.

1/21/1998 : Modified by AnoopA to incorporate client authentication.

---*/
{

    SECURITY_STATUS sErr;

    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];

    PBYTE           pbInboundToken = NULL;
    
    DWORD           ContextAttribs;
    PWCHAR          TargetName = NULL;
    DWORD           dwSspiFlags;
    ULONG           LdapError;

    SCHANNEL_CRED   schCred = {0};

    ASSERT( Connection != NULL );
    ASSERT( Package != NULL );
    ASSERT( EncryptFunctionTable != NULL );

    //
    // We will not pass any client creds initially (we don't have any!). If
    // the server demands creds, we will decide later.
    //

    schCred.dwVersion = SCHANNEL_CRED_VERSION;

    //
    // If a client cert routine is supplied, instruct schannel not to pick a
    // default client cert.
    //

    if (Connection->ClientCertRoutine) {
        schCred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;
    } else {
        schCred.dwFlags |= SCH_CRED_USE_DEFAULT_CREDS;
    }

    //
    // If the app wants to manually validate the server cert, prevent schannel
    // from doing so.
    //

    if (Connection->ServerCertRoutine) {
        schCred.dwFlags |= SCH_CRED_MANUAL_CRED_VALIDATION;
    } else {
        schCred.dwFlags |= SCH_CRED_AUTO_CRED_VALIDATION;
    }

    sErr = EncryptFunctionTable->AcquireCredentialsHandleW(
               NULL,                          // User name for the credentials.
               Package->Name,                 // Security package name.
               SECPKG_CRED_OUTBOUND,          // These are outbound only credentials.
               NULL,                          // The LUID - not applicable here!
               &schCred,                      // The package specific data with flags.
               NULL,                          // The specific get key function.
               NULL,                          // Argument to the get key function.
               &hSslCredentials,              // OUT: Pointer to the credential.
               &SslCredExpiry                 // OUT: Credential expiration time.
           );

    if ( sErr != SEC_E_OK ) {
        return sErr;
    }

    SspiPackage = Package;

    //
    // Set up the security flags and buffers.  The single
    // outbound buffer is for the outbound sspi token.  The
    // first inbound buffer is used to present the inbound
    // data to SSPI.  The second inbound buffer gets the
    // left over data when the inbound data contains more
    // than one token.
    //

    dwSspiFlags = ISC_REQ_SEQUENCE_DETECT |
                  ISC_REQ_REPLAY_DETECT   |
                  ISC_REQ_CONFIDENTIALITY |
                  ISC_REQ_MUTUAL_AUTH     |
                  ISC_RET_EXTENDED_ERROR  |
                  ISC_REQ_STREAM          |
                  ISC_REQ_ALLOCATE_MEMORY;

    //
    // Setup OutBuffer for InitializeSecurityContext call
    //

    OutBuffers[0].pvBuffer = NULL;
    OutBuffers[0].cbBuffer = 0;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;

    OutBuffer.cBuffers = 1;
    OutBuffer.pBuffers = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    //
    // Canonicalize the target name for the security provider
    // and reset the authentication leg counter.
    //

    if (Connection->DnsSuppliedName != NULL) {

        TargetName = Connection->DnsSuppliedName;

    } else {

        TargetName = Connection->HostNameW;
    }

    //
    // Start the negotiation. We will try to do it initially with the
    // default credentials.
    //

    sErr = EncryptFunctionTable->InitializeSecurityContextW(
               &hSslCredentials,
               NULL,
               TargetName,
               dwSspiFlags,
               0,
               SECURITY_NATIVE_DREP,
               NULL,
               0,
               &hSslContext,
               &OutBuffer,
               &ContextAttribs,
               &SslContextExpiry
           );

    if ( sErr != SEC_I_CONTINUE_NEEDED ) {
        goto ExitWithCleanup;
    }

    //
    // Send the HELLO token.
    //

    ASSERT( OutBuffers[0].cbBuffer != 0 );
    ASSERT( OutBuffers[0].pvBuffer != NULL );

    LdapError = LdapSendRaw( Connection,
                             (PCHAR) OutBuffers[0].pvBuffer,
                             OutBuffers[0].cbBuffer );

    EncryptFunctionTable->FreeContextBuffer( OutBuffers[0].pvBuffer );

    OutBuffers[0].cbBuffer = 0;
    OutBuffers[0].pvBuffer = NULL;

    if ( LdapError != LDAP_SUCCESS ) {

        sErr = ERROR_CONNECTION_INVALID;
        goto ExitWithCleanup;
    }

    //
    // Continue the SSL negotiate loop until it completes.
    //

    sErr = SSPINegotiateLoop( FALSE );

    if ( sErr != SEC_E_OK ) {
        goto ExitWithCleanup;
    }

    //
    // Set up the stream state for the crypto transport.
    //

    sErr = EncryptFunctionTable->QueryContextAttributesW(
               &hSslContext,
               SECPKG_ATTR_STREAM_SIZES,
               (PVOID) &SspiStreamSizes );

    if ( sErr != SEC_E_OK ) {
        goto ExitWithCleanup;
    }

    //
    // Allocate the buffer that we use to process outbound messages.
    //

    cbOutboundCryptoLen = SspiStreamSizes.cbHeader +
                          SspiStreamSizes.cbMaximumMessage +
                          SspiStreamSizes.cbTrailer;

    dwMaxMessage = SspiStreamSizes.cbMaximumMessage;

    pbOutboundCrypto = (PBYTE) ldapMalloc( cbOutboundCryptoLen,
                                           LDAP_SECURITY_SIGNATURE );

    if ( pbOutboundCrypto == NULL ) {
        sErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Allocate the buffer chain that we'll use to talk to SSPI.
    //

    pCryptoBuffers = (PSecBuffer) ldapMalloc(
                         ( sizeof( SecBuffer ) * SspiStreamSizes.cBuffers ),
                         LDAP_SECURITY_SIGNATURE );

    if ( pCryptoBuffers == NULL ) {
        sErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    Decrypt.cBuffers = SspiStreamSizes.cBuffers;
    Decrypt.pBuffers = pCryptoBuffers;
    Decrypt.ulVersion = SECBUFFER_VERSION;

ExitWithCleanup:

    if ( sErr != SEC_E_OK ) {

        //
        // If we failed, free the SSL credentials handle.
        //

        if ((hSslCredentials.dwLower != (ULONG) -1) ||
            (hSslCredentials.dwUpper != (ULONG) -1)) {

            EncryptFunctionTable->FreeCredentialHandle(
                &hSslCredentials );

            hSslCredentials.dwLower = (ULONG) -1;
            hSslCredentials.dwUpper = (ULONG) -1;
        }

        if ((hSslContext.dwLower != (ULONG) -1) ||
            (hSslContext.dwUpper != (ULONG) -1)) {

            EncryptFunctionTable->DeleteSecurityContext(
                &hSslContext );

            hSslContext.dwLower = (ULONG) -1;
            hSslContext.dwUpper = (ULONG) -1;
        }

        SspiPackage = NULL;
    }

    if ( pbInboundToken ) {
        ldapFree( pbInboundToken, LDAP_SECURITY_SIGNATURE );
    }

    return sErr;

}

SECURITY_STATUS
CryptStream::TearDownSecureConnection(
    VOID
)
/*+++

Description:

    Notify schannel and the server that we are about to close the connection.
    This involves building a SSL/TLS close notify message and sending that 
    message to the server.

    This must return a Win32 error code.

---*/
{
    SECURITY_STATUS sErr;

    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];

    SecBufferDesc   InBuffer;
    SecBuffer       InBuffers[4];
    
    DWORD           ContextAttribs;
    ULONG           LdapError;
    DWORD           dwType;
    DWORD           dwSSPIFlags;

    PBYTE           pbJunkBuffer = NULL;
    ULONG           cbReceived = 0;
    
    ASSERT( Connection != NULL );
    ASSERT( EncryptFunctionTable != NULL );

    //
    // Notify schannel that we are about to close the connection.
    //
    
    dwType = SCHANNEL_SHUTDOWN;
    
    OutBuffers[0].pvBuffer   = &dwType;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = sizeof(dwType);
    
    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    sErr = EncryptFunctionTable->ApplyControlToken( &hSslContext,
                                                    &OutBuffer );

    IF_DEBUG( SSL ) {
        LdapPrint1("TearDownSecureConnection:ApplyControlToken returned 0x%x\n",sErr);
    }
    
    if ( sErr != SEC_E_OK ) {
        goto ExitWithCleanup;
    }

    //
    // Build an SSL close notify message.
    //
    
    dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
                  ISC_REQ_REPLAY_DETECT     |
                  ISC_REQ_CONFIDENTIALITY   |
                  ISC_RET_EXTENDED_ERROR    |
                  ISC_REQ_ALLOCATE_MEMORY   |
                  ISC_REQ_STREAM;
    
    OutBuffers[0].pvBuffer   = NULL;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = 0;
    
    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    sErr = EncryptFunctionTable->InitializeSecurityContextW(
               &hSslCredentials,
               &hSslContext,
               NULL,
               dwSSPIFlags,
               0,
               SECURITY_NATIVE_DREP,
               NULL,
               0,
               &hSslContext,
               &OutBuffer,
               &ContextAttribs,
               &SslContextExpiry
           );

    if ( sErr != SEC_E_OK ) {
        goto ExitWithCleanup;
    }

    //
    // Send the CLOSE_NOTIFY alert to the server.
    //

    ASSERT( OutBuffers[0].cbBuffer != 0 );
    ASSERT( OutBuffers[0].pvBuffer != NULL );

    LdapError = LdapSendRaw( Connection,
                             (PCHAR) OutBuffers[0].pvBuffer,
                             OutBuffers[0].cbBuffer );

    EncryptFunctionTable->FreeContextBuffer( OutBuffers[0].pvBuffer );

    OutBuffers[0].cbBuffer = 0;
    OutBuffers[0].pvBuffer = NULL;

    if ( LdapError != LDAP_SUCCESS ) {

        sErr = ERROR_CONNECTION_INVALID;
        goto ExitWithCleanup;
    }

    pbJunkBuffer = (PBYTE) ldapMalloc( SspiMaxTokenSize, LDAP_SECURITY_SIGNATURE );

    if ( !pbJunkBuffer ) {

        sErr = ERROR_NOT_ENOUGH_MEMORY;
        goto ExitWithCleanup;
    }

TryReceiveAgain:

    LdapError = SslBlockingReceive( pbJunkBuffer,
                                    SspiMaxTokenSize, // size of data to receive
                                    &cbReceived
                                    );

    if (LdapError != LDAP_SUCCESS) {

        sErr = (LdapError==LDAP_TIMEOUT)? ERROR_TIMEOUT : ERROR_BAD_NET_RESP;
        goto ExitWithCleanup;
    }

    InBuffers[0].BufferType = SECBUFFER_DATA;
    InBuffers[0].cbBuffer = cbReceived;
    InBuffers[0].pvBuffer = pbJunkBuffer;

    //
    // For some wierd reason, we have to tack on 3 additional empty buffers
    // for this to work.
    //

    for ( ULONG i = 1; i < 4; i++ ) {
        InBuffers[i].pvBuffer = NULL;
        InBuffers[i].cbBuffer = 0;
        InBuffers[i].BufferType = SECBUFFER_EMPTY;
    }

    InBuffer.cBuffers  = SspiStreamSizes.cBuffers;
    InBuffer.pBuffers  = InBuffers;
    InBuffer.ulVersion = SECBUFFER_VERSION;

    sErr = LdapSslDecrypt(
                &hSslContext,
                &InBuffer,
                0,
                NULL );

    //
    // Since we have explicitly abandoned all outstanding requests prior to
    // sending the StopTLS alert, this message must be the server response
    // to the StopTLS request. Disregard all other messages the server might
    // send us.
    //

    if ( sErr != SEC_I_CONTEXT_EXPIRED ) {

        IF_DEBUG( SSL ) {
            LdapPrint1("TearDownSecureConnection: DecryptMessage returns 0x%x\n", sErr);
        }
//      ASSERT( FALSE );
        goto TryReceiveAgain;
    }

ExitWithCleanup:

    ldapFree( pbJunkBuffer, LDAP_SECURITY_SIGNATURE );

    IF_DEBUG( SSL ) {
         LdapPrint1("TearDownSecureConnection win32 error is 0x%x\n", sErr);
    }

    return sErr;

}



ULONG
CryptStream::SslBlockingReceive(
    PBYTE  pbReceive,
    ULONG  cbReceive,
    PULONG pcbReceived
)
/*+++

Description:

    This routine does a synchronous receive of SSL data
    during connection negotiation/teardown. Since the sockets
    are marked as non-blocking, this routine does a select
    on the socket and then receives data after the select
    fires.

Parameters:

    pbReceive - Buffer to receive into.
    cbReceive - Size of the receive buffer.

    This function returns an LDAP_ERROR.

---*/
{

    fd_set SockRead;
    struct timeval Timeout;
    int SockErr;

    //
    // Set the timeout and the socket array.
    //

    Timeout.tv_sec = LDAP_SSL_NEGOTIATE_TIME_DEFAULT;
    Timeout.tv_usec = 0;

    FD_ZERO( &SockRead );
    FD_SET( Connection->TcpHandle, &SockRead );

    SockErr = (*pselect)( 0,
                          &SockRead,
                          NULL,
                          NULL,
                          &Timeout );

    if ( ( SockErr == SOCKET_ERROR ) ||
         ( SockErr != 1 ) ) {

        //
        // The server didn't respond in the allotted time.
        // The setup will fail and this connection will
        // not get opened.
        //

        return LDAP_TIMEOUT;

    }

    //
    // Actually receive the data.
    //

    SockErr = (*precv)( Connection->TcpHandle,
                        (PCHAR) pbReceive,
                        cbReceive,
                        0 );

    if ( SockErr == SOCKET_ERROR ) {

        //
        // The setup will fail and this connection will
        // not get opened.
        //

        return LDAP_TIMEOUT;

    } else if ( SockErr == 0 ) {

        //
        // The server has closed the connection.
        //

        IF_DEBUG(SERVERDOWN) {
            LdapPrint2( "ldapSslBlockingRecv thread 0x%x has connection 0x%x as down.\n",
                            GetCurrentThreadId(),
                            Connection );
        }
        return LDAP_SERVER_DOWN;
    }

    //
    // We got some data... groovy.
    //

    *pcbReceived = SockErr;
    return LDAP_SUCCESS;
}

SECURITY_STATUS
CryptStream::SSPINegotiateLoop(
    BOOL         fDoInitialRead
)
 {

    SECURITY_STATUS      scRet;
    ULONG                LdapError;

    SecBufferDesc        InBuffer;
    SecBuffer            InBuffers[2];
    SecBufferDesc        OutBuffer;
    SecBuffer            OutBuffers[1];

    BOOL                 fDoRead;
    DWORD                dwSSPIFlags;
    DWORD                dwSSPIOutFlags;

    ULONG           cbInboundLen, cbProcessedBytes;
    PBYTE           pbReceiveStart;
    ULONG           cbReceived;

    BOOL          bInvokedCertCallback = FALSE;

    //
    // Set up the flags. In the first pass, we don't supply the
    // credentials.
    //


    fDoRead = fDoInitialRead;

    dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
                  ISC_REQ_REPLAY_DETECT     |
                  ISC_REQ_CONFIDENTIALITY   |
                  ISC_REQ_MUTUAL_AUTH       |
                  ISC_RET_EXTENDED_ERROR    |
                  ISC_REQ_STREAM            |
                  ISC_REQ_ALLOCATE_MEMORY;

    //
    //  Initialize buffer chains.
    //

    OutBuffer.cBuffers = 1;
    OutBuffer.pBuffers = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    InBuffer.cBuffers = 2;
    InBuffer.pBuffers = InBuffers;
    InBuffer.ulVersion = SECBUFFER_VERSION;

    //
    // Allocate a token buffer if we don't already have one.
    // SspiMaxTokenSize is the size of the largest possible
    // token according to the security provider.  This keeps
    // us from having to resize or copy.
    //

    if ( !pbNegotiateBuffer ) {

        pbNegotiateBuffer = (PBYTE) ldapMalloc( SspiMaxTokenSize,
                                                LDAP_SECURITY_SIGNATURE );

        if ( pbNegotiateBuffer == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    pbReceiveStart = pbNegotiateBuffer + cbNegotiateBuffer;
    cbInboundLen = SspiMaxTokenSize - cbNegotiateBuffer;

    //
    // InBuffers[0] describes the inbound
    // token data that is waiting to be processed.
    //

    InBuffers[0].pvBuffer = pbNegotiateBuffer;
    InBuffers[0].cbBuffer = cbNegotiateBuffer;
    InBuffers[0].BufferType = SECBUFFER_TOKEN;

    //
    // Start negotiating SSL.
    //

    scRet = SEC_I_CONTINUE_NEEDED;

     while( scRet == SEC_I_CONTINUE_NEEDED ||
            scRet == SEC_E_INCOMPLETE_MESSAGE ||
            scRet == SEC_I_INCOMPLETE_CREDENTIALS ) {

         //
         // If we have no data, or we need more data, do a receive.
         //
         // Note that we don't do a receive if we need to furnish credentials.
         //

         if( (( InBuffers[0].cbBuffer == 0 )&&(scRet != SEC_I_INCOMPLETE_CREDENTIALS)) ||
             ( scRet == SEC_E_INCOMPLETE_MESSAGE ) ) {

             if( fDoRead ) {

                 LdapError = SslBlockingReceive( pbReceiveStart,
                                                 cbInboundLen,
                                                 &cbReceived );

                if ( LdapError != LDAP_SUCCESS ) {
                    scRet = SEC_E_INTERNAL_ERROR;
                    break;
                }

                pbReceiveStart += cbReceived;
                cbNegotiateBuffer += cbReceived;
                InBuffers[0].cbBuffer += cbReceived;

            } else {

                fDoRead = TRUE;
            }
        }

        //
        // InBuffers[1] is for getting extra data that
        // SSPI/SCHANNEL doesn't proccess on this
        // run around the loop.
        //

        InBuffers[1].pvBuffer   = NULL;
        InBuffers[1].cbBuffer   = 0;
        InBuffers[1].BufferType = SECBUFFER_EMPTY;

        OutBuffers[0].pvBuffer   = 0;
        OutBuffers[0].BufferType = SECBUFFER_TOKEN;
        OutBuffers[0].cbBuffer   = 0;

        scRet = EncryptFunctionTable->InitializeSecurityContextW(
                    &hSslCredentials,
                    &hSslContext,
                    NULL,
                    dwSSPIFlags,
                    0,
                    SECURITY_NATIVE_DREP,
                    &InBuffer,
                    0,
                    NULL,
                    &OutBuffer,
                    &dwSSPIOutFlags,
                    &SslCredExpiry
                );

       if ( ( scRet == SEC_E_OK )              ||
            ( scRet == SEC_I_CONTINUE_NEEDED ) ||
            ( ( FAILED(scRet) ) && ( ( dwSSPIOutFlags & ISC_RET_EXTENDED_ERROR ) != 0 ) ) ) {

           if  ( ( OutBuffers[0].cbBuffer != 0 ) &&
                 ( OutBuffers[0].pvBuffer != NULL ) ) {

               LdapError = LdapSendRaw( Connection,
                                        (PCHAR) OutBuffers[0].pvBuffer,
                                        OutBuffers[0].cbBuffer );

               if ( LdapError != LDAP_SUCCESS ) {
                   scRet = SEC_E_INTERNAL_ERROR;
                   break;
               }

               EncryptFunctionTable->FreeContextBuffer( OutBuffers[0].pvBuffer );
               OutBuffers[0].pvBuffer = NULL;
               OutBuffers[0].cbBuffer = 0;
           }
       }

       if ( scRet == SEC_E_OK ) {

          //
          // A secure connection has been established.
          //

           if ( InBuffers[1].BufferType == SECBUFFER_EXTRA ) {

               cbProcessedBytes = InBuffers[0].cbBuffer - InBuffers[1].cbBuffer;

               ldap_MoveMemory( (PCHAR) InBuffers[0].pvBuffer,
                                (PCHAR) ( (PBYTE)InBuffers[0].pvBuffer + cbProcessedBytes ),
                                InBuffers[1].cbBuffer );

               InBuffers[0].cbBuffer = InBuffers[1].cbBuffer;
               cbNegotiateBuffer = InBuffers[1].cbBuffer;

           } else {

               InBuffers[0].cbBuffer = 0;
               cbNegotiateBuffer = 0;
           }

           //
           // Bail out to quit.  We leave the remaining token data
           // sitting in the buffer for the next negotiate.
           //

           //
           // This is a good time for the client to validate the server's
           // certificate
           //

           CERT_CONTEXT ServerCertContext;
           BOOL   retval;

           if ( Connection->ServerCertRoutine != NULL ) {

              scRet = EncryptFunctionTable->QueryContextAttributesW(
                                                                   &hSslContext,
                                                                   SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                                                   (PVOID) &ServerCertContext
                                                                   );
              if (scRet != SEC_E_OK) {

                 break;
              }

              //
              // We now have the certificate of the remote server. We callout to
              // the client to see if it likes it.
              //

              retval = Connection->ServerCertRoutine( Connection->ExternalInfo,
                                                      &ServerCertContext );

              if (retval == FALSE) {
                 //
                 // The user didn't like the server certificate for some reason.
                 // We will have to terminate the connection.
                 //
                 scRet = SEC_E_INTERNAL_ERROR;
                 break;
              }
           }
           break;

       } else if ( scRet == SEC_I_INCOMPLETE_CREDENTIALS ) {

          //
          // The server has demanded to see our client certificate. Check to
          // see if the user has registered a callout. If yes, call out else
          // try to complete the handshake without credentials.
          //

          if (( Connection->ClientCertRoutine != NULL) && ( bInvokedCertCallback == FALSE )) {
    
              //
              // Ask the security package for a list of Certificate Authorities
              // that the server trusts.
              //
    
              scRet = EncryptFunctionTable->QueryContextAttributesW(
                                                                   &hSslContext,
                                                                   SECPKG_ATTR_ISSUER_LIST_EX,
                                                                   (PVOID) &TrustedCAList );
    
              if ( scRet != SEC_E_OK ) {
                 break;
              }
    
              //
              // We succeeded in getting a list of the server-trusted CAs. We should
              // now callout to the user registered callback routine.
              //
    
              BOOL retval;
              PCCERT_CONTEXT  pCertificate = NULL;
    
              retval = Connection->ClientCertRoutine( Connection->ExternalInfo,
                                                      &TrustedCAList,
                                                      &pCertificate
                                                      );
              bInvokedCertCallback = TRUE;
    
              if (retval == FALSE) {
    
                 //
                 // We could not get a client certificate. Let's try to
                 // complete the handshake without using a client cert.
                 //
    
                 dwSSPIFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
                 scRet = SEC_I_INCOMPLETE_CREDENTIALS;
                 continue;
    
              }
    
              //
              // we now acquire a new set of credentials based on the client
              // certificate and call Initializesecuritycontext again.
              //
    
              SCHANNEL_CRED  UserSchCred = {0};

              UserSchCred.dwVersion = SCHANNEL_CRED_VERSION;
              UserSchCred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;
              UserSchCred.paCred = &pCertificate;
              UserSchCred.cCreds = 1;  // honor only the first cert in the chain.

              scRet = EncryptFunctionTable->AcquireCredentialsHandleW(
                         NULL,
                         SspiPackageSslPct->Name,
                         SECPKG_CRED_OUTBOUND,
                         NULL,
                         &UserSchCred,                  // IN: User supplied creds
                         NULL,
                         NULL,
                         &hSslCredentials,              // OUT: Pointer to the credential.
                         &SslCredExpiry                 // OUT: Credential expiration time.
                     );
    
              if ( scRet != SEC_E_OK ) {
                  return scRet;
              }
    
              //
              // We need to tell SSPI to use the supplied credentials
              //
    
              dwSSPIFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
              scRet = SEC_I_INCOMPLETE_CREDENTIALS;

    
          } else {

             //
             // We have no user-registered callback or the server didn't like
             // the credentials we supplied. So, our only resort is to continue
             // with no credentials.
             //

             dwSSPIFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
             continue;
          }

       } else if ( FAILED(scRet) && ( scRet != SEC_E_INCOMPLETE_MESSAGE ) ) {

           //
           // Free the security context handle and delete the local
           // data structures associated with the handle and try another
           // pkg if available.  I don't see that this is happening.
           //

           break;
       }

       if ( ( scRet != SEC_E_INCOMPLETE_MESSAGE ) &&
            ( scRet != SEC_I_INCOMPLETE_CREDENTIALS ) ) {

           if ( InBuffers[1].BufferType == SECBUFFER_EXTRA ) {

               cbProcessedBytes = InBuffers[0].cbBuffer - InBuffers[1].cbBuffer;
               ldap_MoveMemory( (PCHAR) InBuffers[0].pvBuffer,
                                (PCHAR) ( (PBYTE)InBuffers[0].pvBuffer + cbProcessedBytes ),
                                InBuffers[1].cbBuffer );

               InBuffers[0].cbBuffer = InBuffers[1].cbBuffer;
               cbNegotiateBuffer = InBuffers[1].cbBuffer;
               pbReceiveStart = pbNegotiateBuffer + cbNegotiateBuffer;

           } else {

               //
               // prepare for next receive
               //

               InBuffers[0].cbBuffer = 0;
               cbNegotiateBuffer = 0;
               pbReceiveStart = pbNegotiateBuffer;
           }
       }
   }

    return ( scRet );
}



SECURITY_STATUS
CryptStream::GetSSLAttributes(
    PSecPkgContext_ConnectionInfo pSecInfo
)
{
   //
   // Gets the SSL attributes of a connection, and fills up the supplied
   // SecPkgContext_ConnectionInfo structure.
   //
   SECURITY_STATUS      scRet;

   scRet = EncryptFunctionTable->QueryContextAttributesW(
                     &hSslContext,
                     SECPKG_ATTR_CONNECTION_INFO,
                     pSecInfo
                     );

   return scRet;

}


ULONG
CryptStream::SignAndSealLdapStream(
    PBYTE   pbClearText,
    ULONG   cbClearText
)
/*+++

Description:

    This routine takes the plain text request, signs it inplace,
    and sends it off to the server.

Parameters:

    pbClearText   - The clear text request.
    cbClearText   - The length of the clear text.

Notes:

    This routine only gets called when the
    send lock for the host connection is held.
    The send lock protects the send data
    structures.

---*/
{
   
   ULONG           LdapError;
   SECURITY_STATUS sErr;
   SecBufferDesc   Encrypt;
   SecBuffer       CryptoBuffers[3];
   PBYTE           pbSendData, pbSendCrypto;
   ULONG           cbProcessedCrypto = 0;
   BOOLEAN         SignOnly = FALSE; 

   ULONG           cbBytesLeft = cbClearText;
   ULONG           cbBytesToSend = 0;
   ULONG           cbOffset = 0;
   
   //
   // Set the initial pointers.
   //
   
   IF_DEBUG(SSL) {
       LdapPrint1("Signing/Sealing %d bytes of cleartext.\n",cbClearText );
   }

   pbSendData = pbClearText;
   pbSendCrypto = (PBYTE) ldapMalloc(
                     sizeof(EncryptHeader_v1) + 
                     ((dwMaxMessage == (DWORD)-1) ? cbClearText : dwMaxMessage) + 
                     ContextSizes.cbMaxSignature + ContextSizes.cbBlockSize +
                     ContextSizes.cbSecurityTrailer,
                     LDAP_SECURITY_SIGNATURE);
   
   if (pbSendCrypto == NULL) {
      return LDAP_NO_MEMORY;
   }


   PEncryptHeader_v1 pEncryptHeader = (PEncryptHeader_v1) pbSendCrypto;

   //
   // Advance pointer to the start of the message buffer.
   //

   pbSendCrypto += sizeof(EncryptHeader_v1);

   //
   // Sign or seal this message as appropriate
   //
   
   if ((Connection->CurrentSignStatus) && !(Connection->CurrentSealStatus)) {
       
       //
       // We need to sign only, not seal.
       //
       
       SignOnly = TRUE;
   }


   while (cbBytesLeft > 0) {


       if (dwMaxMessage == (DWORD)-1) {
            // package imposes no size restriction --> encrypt
            // all in one chunk
            cbBytesToSend = cbBytesLeft;    // == cbClearText
       }
       else {
           // we send the minimum of either the cleartext bytes
           // remaining or the maximum bytes we can send in one
           // chunk
           if (cbBytesLeft > dwMaxMessage) {
               cbBytesToSend = dwMaxMessage;
           }
           else {
               cbBytesToSend = cbBytesLeft;
           }
       }

       //
       // Encrypting also buys us signing if we had asked for integrity/replay/sequence
       // For sealing, we prepare the buffers in a different way
       //
       
       CryptoBuffers[0].pvBuffer = pbSendCrypto;
       CryptoBuffers[0].cbBuffer = ContextSizes.cbSecurityTrailer;
       CryptoBuffers[0].BufferType = SECBUFFER_TOKEN;
       
       CryptoBuffers[1].pvBuffer = pbSendCrypto+ContextSizes.cbSecurityTrailer;
       CryptoBuffers[1].cbBuffer = cbBytesToSend;
       CryptoBuffers[1].BufferType = SECBUFFER_DATA;
       CopyMemory( CryptoBuffers[1].pvBuffer, (const char*) pbClearText+cbOffset, cbBytesToSend);

       CryptoBuffers[2].pvBuffer = pbSendCrypto+ContextSizes.cbSecurityTrailer+cbBytesToSend;
       CryptoBuffers[2].cbBuffer = ContextSizes.cbMaxSignature + ContextSizes.cbBlockSize;
       CryptoBuffers[2].BufferType = SECBUFFER_PADDING;
   
       Encrypt.cBuffers = 3;
       Encrypt.pBuffers = CryptoBuffers;
       Encrypt.ulVersion = SECBUFFER_VERSION;

       sErr = EncryptFunctionTable->EncryptMessage(
                   &Connection->SecurityContext,
                   (SignOnly ? KERB_WRAP_NO_ENCRYPT : 0), 
                   &Encrypt,
                   0 );

       cbProcessedCrypto =  sizeof(EncryptHeader_v1) +
                            CryptoBuffers[0].cbBuffer +
                            CryptoBuffers[1].cbBuffer +
                            CryptoBuffers[2].cbBuffer;

       LdapError = LdapConvertSecurityError( Connection, sErr );
       
       IF_DEBUG(SSL) {
           LdapPrint1("EncryptMessage returned 0x%x\n", sErr);
       }

       if ( LdapError != LDAP_SUCCESS) {
          
          IF_DEBUG(SSL){
              LdapPrint2("EncryptMessage failed with 0x%x, sec context is 0x%x\n", sErr, &Connection->SecurityContext);
          }
          ldapFree(pEncryptHeader, LDAP_SECURITY_SIGNATURE);
          return LdapError;
       }

       //
       // After we successfully processed a message, we must slide the lower two
       // buffers up as specified by CryptoBuffers[0].cbBuffer
       //

       ASSERT(CryptoBuffers[0].cbBuffer <= ContextSizes.cbSecurityTrailer);
       ASSERT(CryptoBuffers[1].cbBuffer == cbBytesToSend);
       ASSERT(CryptoBuffers[2].cbBuffer <= (ContextSizes.cbBlockSize + ContextSizes.cbMaxSignature) );

       if (CryptoBuffers[0].cbBuffer < ContextSizes.cbSecurityTrailer) {
       
           IF_DEBUG(SSL){
               LdapPrint1("Shifting encryptbuffers by %d\n",CryptoBuffers[0].cbBuffer - ContextSizes.cbSecurityTrailer );
           }

           ldap_MoveMemory( (PCHAR) CryptoBuffers[0].pvBuffer+CryptoBuffers[0].cbBuffer,
                            (PCHAR) CryptoBuffers[1].pvBuffer,
                            CryptoBuffers[1].cbBuffer + CryptoBuffers[2].cbBuffer
                            );
       
       }

       //
       // We need to frame the crypto on the wire with 4 byte octets which contain
       // (in network byte order), the size of the ensuing crypto.
       //

       pEncryptHeader->EncryptMessageSize = (*phtonl) (cbProcessedCrypto - sizeof(EncryptHeader_v1));
       
       //
       // Ship this signed/sealed message to the server
       //

       LdapError = LdapSendRaw( Connection,
                               (PCHAR) pEncryptHeader,
                                cbProcessedCrypto );


       IF_DEBUG(SSL) {
           LdapPrint3("Sending %d signed/sealed bytes with retval 0x%x, %d bytes of cleartext to go\n", cbProcessedCrypto, LdapError, (cbBytesLeft-cbBytesToSend));
       }


       if (LdapError != LDAP_SUCCESS) {
            break;
       }

       //
       cbBytesLeft -= cbBytesToSend;
       cbOffset += cbBytesToSend;

   }

   ldapFree(pEncryptHeader, LDAP_SECURITY_SIGNATURE);

   return LdapError;
}


ULONG CryptStream::UnSignAndSealLdapStream(
    PLDAP_RECVBUFFER pCryptoReceive
)
/*+++

Description:

    This routine takes cipher text from the transport and
    processes it and passes it to the message pump.

Parameters:

    pCryptoReceive   - The next ldap receive.

Notes:

    This only gets called when the connection list lock
    is held so we don't have to worry about locking or
    ordering. We also do a lot of buffer copies. If this turns
    out to be slow, we should change the architecture.
*/
{

   SecBufferDesc   Decrypt;
   SecBuffer       CryptoBuffers[2];

   PBYTE pbCryptoHead;
   ULONG LdapError = LDAP_SUCCESS;
   SECURITY_STATUS sErr;

   ULONG cbCryptoBytes;

   pbCryptoHead = (PBYTE) &(pCryptoReceive->DataBuffer[0]);
   cbCryptoBytes = pCryptoReceive->NumberOfBytesReceived;
   BOOLEAN         UnSignOnly = FALSE; 
   
   if ( !cbCryptoBytes ) {

      RemoveEntryList( &pCryptoReceive->ReceiveListEntry );
      LdapFreeReceiveStructure( pCryptoReceive, TRUE );
      return LDAP_SUCCESS;
   }

   //
   // We have to ensure that we received the entire message before
   // trying to process it. So, we try to check the length only if it is
   // a brand new message. If not, we simply squirrel away the partial 
   // message.
   //

   PEncryptHeader_v1 pEncryptHeader = (PEncryptHeader_v1) pbCryptoHead;
   

   if ( !cbInboundCryptoBytes ) {

      //
      // we don't have any stored crypto, we assume this
      // to be a brand new message. Remember that the incoming header is
      // in network byte order.
      //
   
      //
      // Make sure we got enough bytes for the EncryptMessageSize
      //
      if (cbCryptoBytes >= sizeof (ULONG)) {
   

          ULONG IncomingMessageLength = sizeof(EncryptHeader_v1) +
                                (*pntohl) (pEncryptHeader->EncryptMessageSize);

          cbCurrentMessageSize = IncomingMessageLength;

          bCurrentMessageSizeValid = TRUE;
      }
   } 
   
      //
      // To make life easier, always store off the incoming message in our
      // private crypto buffers as it could contain partial messages
      //

   if ( pbInboundCrypto != pbCryptoHead ) {
      
      if ( !CheckInboundSpace( cbCryptoBytes ) ) {
     
          return LDAP_NO_MEMORY;
      }
      
      ldap_MoveMemory( (PCHAR) pbInboundCrypto + cbInboundCryptoBytes,
               (PCHAR) pbCryptoHead,
               cbCryptoBytes );
               
      cbInboundCryptoBytes += cbCryptoBytes;
      
      RemoveEntryList( &pCryptoReceive->ReceiveListEntry );
      LdapFreeReceiveStructure( pCryptoReceive, TRUE );
   }

   // If we didn't have enough bytes before to get the message size, try again
   // now that we've combined any bytes we got this time with the bytes we got the
   // last time
   if (!bCurrentMessageSizeValid) {

      if (cbInboundCryptoBytes >= sizeof (ULONG)) {

          PEncryptHeader_v1 pEncryptHeaderTemp = (PEncryptHeader_v1) pbInboundCrypto;

          ULONG IncomingMessageLength = sizeof(EncryptHeader_v1) +
          (*pntohl) (pEncryptHeaderTemp->EncryptMessageSize);

          cbCurrentMessageSize = IncomingMessageLength;

          bCurrentMessageSizeValid = TRUE;
      }
   }

   if ((!bCurrentMessageSizeValid) || ( cbCurrentMessageSize > cbInboundCryptoBytes)) {

      //
      // We don't have enough crypto to start processing, we hope to have
      // the rest the next time we come in here.
      //

      return LDAP_SUCCESS;
   }

   // keep track of how much buffer space we're using, for our
   // buffer trimming algorithm
   if (cbInboundCryptoBytes > cbMaxBufferUsed) {
       cbMaxBufferUsed = cbInboundCryptoBytes;
   }
   cUnsignsPerformed++;


   if ((Connection->CurrentSignStatus) && !(Connection->CurrentSealStatus)) {
       
       //
       // The data is only signed, not sealed.
       //

       UnSignOnly = TRUE;
   }
   
   //
   // Now, we have atleast one complete message in our buffers
   //
   // cbCurrentMessageSize : Number of bytes in the first message we want to decrypt.
   // pbInboundCrypto      : Start of the message buffer
   // cbInboundCryptoBytes : Total number of bytes in the buffer
   //
   // Note that we could have some extra crypto in the end. If so, we have to
   // slide it to the beginning and set the new message size. If not, we free
   // our entire buffer and we are done.
   //

   for ( ;; ) {

       //
       // Loop through our buffers trying to decrypt
       //
   
       if (!bCurrentMessageSizeValid || 
           !cbInboundCryptoBytes ||
          (cbCurrentMessageSize > cbInboundCryptoBytes) ) {
        
           return LdapError;
        }
   
       IF_DEBUG(SSL) {
           LdapPrint1("CurrentMessageSize is  %d bytes\n", cbCurrentMessageSize);
           LdapPrint1("Total size of inbound buffer is  %d bytes\n", cbInboundCryptoBytes);
         }

      //
      // Advance to the start of the encrypted message
      //
      
      pbCryptoHead = pbInboundCrypto;
      pEncryptHeader = (PEncryptHeader_v1) pbCryptoHead;

      //
      // Actually unsign/decrypt the data!
      //

      CryptoBuffers[0].pvBuffer =  pbCryptoHead + sizeof(EncryptHeader_v1);
      CryptoBuffers[0].cbBuffer =  (*pntohl) (pEncryptHeader->EncryptMessageSize);
      CryptoBuffers[0].BufferType = SECBUFFER_STREAM;
   
      CryptoBuffers[1].pvBuffer = NULL;
      CryptoBuffers[1].cbBuffer = 0;
      CryptoBuffers[1].BufferType = SECBUFFER_DATA;
   
      Decrypt.cBuffers = 2;
      Decrypt.pBuffers = CryptoBuffers;
      Decrypt.ulVersion = SECBUFFER_VERSION;

      sErr = EncryptFunctionTable->DecryptMessage(
              &Connection->SecurityContext,
              &Decrypt,
              0,
              NULL );
   
   
      if ( sErr != ERROR_SUCCESS ){
   
          //
          // We failed in some catastrophic way, so we
          // pretty much have to dump all crypto and close 
          // the connection.
          //
   
          IF_DEBUG(SSL) {
              LdapPrint1( "wldap32: DecryptMessage couldn't decrypt.  sErr = 0x%x\n.", sErr );
              ASSERT( sErr == ERROR_SUCCESS );
          }

          LdapError = LdapConvertSecurityError( Connection, sErr );

          goto Cleanup;
      }
      
   
     ASSERT ( sErr == ERROR_SUCCESS );
      
     //
     // Copy the clear text into a new receive buffer.
     //
   
     LdapError = InjectNewReceive( (PBYTE) CryptoBuffers[1].pvBuffer,
                                   CryptoBuffers[1].cbBuffer
                                   );
     
     if (LdapError != LDAP_SUCCESS) {
   
        goto Cleanup;
     }
   
     IF_DEBUG(SSL) {
         LdapPrint1("Actual number of decrypted bytes is %d\n", CryptoBuffers[0].cbBuffer);
     }

      //
      // If we have any extra bytes remaining in our buffers, slide it to the
      // top. If not, we can delete the entire buffer.
      //
      
     ASSERT (cbInboundCryptoBytes >= cbCurrentMessageSize);
   
     if (cbInboundCryptoBytes > cbCurrentMessageSize) {
   
         ldap_MoveMemory((PCHAR) pbInboundCrypto,
                 (PCHAR) pbInboundCrypto+cbCurrentMessageSize,
                 cbInboundCryptoBytes - cbCurrentMessageSize
                 );
         
         //
         // Adjust the number of remaining crypto available
         //

         cbInboundCryptoBytes -= cbCurrentMessageSize;
         
         pEncryptHeader = (PEncryptHeader_v1) pbInboundCrypto;
         
         if (cbInboundCryptoBytes >= sizeof (ULONG)) {

             ULONG NewIncomingMessageLength = sizeof(EncryptHeader_v1) +
                                        (*pntohl) (pEncryptHeader->EncryptMessageSize);
          
             cbCurrentMessageSize = NewIncomingMessageLength;
             bCurrentMessageSizeValid = TRUE;
         }
         else {
             bCurrentMessageSizeValid = FALSE;
         }

         
         
   
     } else {
        
        //
        // We have no extra crypto left to decode.
        //
   
        goto Cleanup;
     }
   
   }   // for (;;)

Cleanup:

    cbCurrentMessageSize = 0;
    bCurrentMessageSizeValid = FALSE;    
    cbInboundCryptoBytes = 0;

    if (cUnsignsPerformed > REEVAL_BUFFER_COUNT) {

        //
        // It's time to see if our buffer (pbInboundCrypto) may be
        // too large.  Every REEVAL_BUFFER_COUNT times through this code,
        // we check to see if the largest message in the last REEVAL_BUFFER_COUNT
        // number of operations used at least half of the buffer size.  If so,
        // fine --- we keep it.  If not, we free it and let it regrow on future
        // operations.  This avoids keeping a huge buffer around forever just because
        // one message happened to need it.
        // 
        if (cbMaxBufferUsed < (cbInboundCryptoLen/2)) {
            // buffer may be too large, get rid of it and start
            // from scratch on next operation
            ldapFree(pbInboundCrypto, LDAP_SECURITY_SIGNATURE);
            cbInboundCryptoLen = 0;
            pbInboundCrypto = NULL;
        }

        // reset for the next round
        cUnsignsPerformed = 0;
        cbMaxBufferUsed = 0;
    }
    
    return LdapError;
     
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\extend.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    extend.cxx handle extended requests to an LDAP server

Abstract:

   This module implements the LDAP delete APIs.

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

//
//  These APIs allow a client to send an extended request (free for all) to
//  an LDAPv3 (or above) server.  The functionality is fairly open... you can
//  send any request you'd like.  Note that since we don't know if you'll
//  be receiving a single or multiple results, you'll have to explicitly tell
//  us when you're done with the request by calling ldap_close_extended_op.
//

ULONG
LdapExtendedOp(
        PLDAP_CONN connection,
        PWCHAR Oid,
        struct berval   *Data,
        BOOLEAN Unicode,
        BOOLEAN Synchronous,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           *MessageNumber
    )
{
    ULONG hr;
    PLDAP_REQUEST request = NULL;
    ULONG messageNumber;
    ULONG err;

    if (MessageNumber == NULL) {

        return LDAP_PARAM_ERROR;
    }

    *MessageNumber = (ULONG) -1;

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {
       return err;
    }

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    request = LdapCreateRequest( connection, LDAP_EXTENDED_CMD );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_extended connection 0x%x couldn't allocate request.\n", connection);
        }
        hr = LDAP_NO_MEMORY;
        SetConnectionError( connection, hr, NULL );
        return hr;
    }

    messageNumber = request->MessageId;

    request->Synchronous = Synchronous;

    hr = LDAP_SUCCESS;

    if ((ServerControls != NULL) || (ClientControls != NULL)) {

        hr = LdapCheckControls( request,
                                ServerControls,
                                ClientControls,
                                Unicode,
                                0 );

        if (hr != LDAP_SUCCESS) {

            IF_DEBUG(CONTROLS) {
                LdapPrint2( "ldap_del connection 0x%x trouble with SControl, err 0x%x.\n",
                            connection, hr );
            }
        }
    }

    if (hr == LDAP_SUCCESS) {

        request->extended.Data.bv_len = Data ? Data->bv_len : 0;

        if (Synchronous || (request->ChaseReferrals == 0)) {

            request->AllocatedParms = FALSE;
            request->OriginalDN = Oid;
            request->extended.Data.bv_val = Data ? Data->bv_val : NULL;

        } else {

            request->AllocatedParms = TRUE;

            if (Oid != NULL) {

                request->OriginalDN = ldap_dup_stringW( Oid, 0, LDAP_UNICODE_SIGNATURE );

                if (request->OriginalDN == NULL) {

                    hr = LDAP_NO_MEMORY;
                }
            }

            if ((hr == LDAP_SUCCESS) &&
                (Data != NULL) &&
                (Data->bv_val != NULL) &&
                (Data->bv_len > 0)) {

                request->extended.Data.bv_val = (PCHAR) ldapMalloc(
                                Data->bv_len,
                                LDAP_EXTENDED_OP_SIGNATURE );

                if (request->extended.Data.bv_val == NULL) {

                    hr = LDAP_NO_MEMORY;

                } else {

                    CopyMemory( request->extended.Data.bv_val,
                                Data->bv_val,
                                Data->bv_len );

                }
            }
        }
    }

    if (hr == LDAP_SUCCESS) {

        hr = SendLdapExtendedOp( request,
                                 connection,
                                 request->OriginalDN,
                                 (CLdapBer **)&request->BerMessageSent,
                                 0 );
    }

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_add connection 0x%x errored with 0x%x.\n",
                        connection, hr );
        }

        messageNumber = (ULONG) -1;
        SetConnectionError( connection, hr, NULL );

        CloseLdapRequest( request );
    }

    *MessageNumber = messageNumber;

    DereferenceLdapRequest( request );
    return hr;
}

ULONG
SendLdapExtendedOp (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection,
    PWCHAR Oid,
    CLdapBer **Lber,
    LONG AltMsgId
    )
{
    ULONG hr;
    struct berval   *Data = &Request->extended.Data;

    CLdapBer *lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {
        SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
        return LDAP_NO_MEMORY;
    }

    //
    //  The request looks like the following :
    //
    //   ExtendedRequest ::= [APPLICATION 23] SEQUENCE {
    //          requestName      [0] LDAPOID,
    //          requestValue     [1] OCTET STRING OPTIONAL }
    //

    hr = lber->HrStartWriteSequence();
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_extendedop startWrite conn 0x%x encoding error of 0x%x.\n",
                        Connection, hr );
        }

        goto encodingError;

    } else {            // we can't forget EndWriteSequence

       if (AltMsgId != 0) {

          hr = lber->HrAddValue((LONG) AltMsgId );

       } else {

          hr = lber->HrAddValue((LONG) Request->MessageId );
       }

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_extendedop MsgNo conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;
        }

        hr = lber->HrStartWriteSequence(LDAP_EXTENDED_CMD);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_extendedop startWrite conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }

            goto encodingError;

        } else {            // we can't forget EndWriteSequence

            hr = lber->HrAddValue((const WCHAR *) Oid, BER_CLASS_CONTEXT_SPECIFIC | 0x00 );
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_extendedop OID conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto encodingError;
            }

            hr = lber->HrAddBinaryValue((BYTE *) Data->bv_val,
                                                ((Data->bv_val == NULL ) ?
                                                        0 : Data->bv_len ),
                                           (BER_CLASS_CONTEXT_SPECIFIC | 0x01));
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_extendedop conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto encodingError;
            }

            hr = lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );
        }

        //
        //  put in the server controls here if required
        //

        if ( (Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
             ( Request->ServerControls != NULL )) {

            hr = InsertServerControls( Request, Connection, lber );

            if (hr != LDAP_SUCCESS) {

                if (lber != NULL) {

                   delete lber;
                }
                return hr;
            }
        }

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );
    }

    //
    //  send the extended operations request.
    //

    ACQUIRE_LOCK( &Connection->ReconnectLock );

    AddToPendingList( Request, Connection );

    hr = LdapSend( Connection, lber );

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_extendedop connection 0x%x send with error of 0x%x.\n",
                        Connection, hr );
        }
        DecrementPendingList( Request, Connection );

    } else {

        //
        //  Save off the lber value, free any lber message that is already
        //  present.
        //

        lber = (CLdapBer *) InterlockedExchangePointer((PVOID *) Lber,
                                                       (PVOID) lber );
    }

    RELEASE_LOCK( &Connection->ReconnectLock );

    if (lber != NULL) {

       delete lber;
    }

    return hr;

encodingError:

    if (lber != NULL) {

       delete lber;
    }

    return LDAP_ENCODING_ERROR;
}

ULONG __cdecl
ldap_extended_operationW(
        LDAP *ExternalHandle,
        PWCHAR Oid,
        struct berval   *Data,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           *MessageNumber
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapExtendedOp(   connection,
                            Oid,
                            Data,
                            TRUE,
                            FALSE,
                            ServerControls,
                            ClientControls,
                            MessageNumber
                            );

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_extended_operationA (
        LDAP *ExternalHandle,
        PCHAR Oid,
        struct berval   *Data,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        ULONG           *MessageNumber
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (MessageNumber == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *MessageNumber = (ULONG) -1;

    err = ToUnicodeWithAlloc( Oid, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        goto error;
    }

    err = LdapExtendedOp(   connection,
                            wName,
                            Data,
                            FALSE,
                            FALSE,
                            (PLDAPControlW *) ServerControls,
                            (PLDAPControlW *) ClientControls,
                            MessageNumber
                            );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}

//
// This is a Synchronous version of ldap_extened_operation. It parses out
// the response data and OId if present and returns it to the user.
//
// It returns the server error code. However, it could also return client
// errors like LDAP_NO_MEMORY, LDAP_PARAM_ERROR etc.
//

ULONG __cdecl
ldap_extended_operation_sA (
        LDAP *ExternalHandle,
        PCHAR Oid,
        struct berval   *Data,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        PCHAR           *ReturnedOid,
        struct berval   **ReturnedData
        )
{
    ULONG err;
    PWCHAR wOid = NULL;
    PLDAP_CONN connection = NULL;
    ULONG  MessageNumber = (ULONG) -1;
    LDAPMessage   *Res = NULL;
    ULONG ServerError = LDAP_SUCCESS;


    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    err = ToUnicodeWithAlloc( Oid, -1, &wOid, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    err = LdapExtendedOp(   connection,
                            wOid,
                            Data,
                            FALSE,   // ANSI controls
                            FALSE,   // Asynchronous
                            (PLDAPControlW *) ServerControls,
                            (PLDAPControlW *) ClientControls,
                            &MessageNumber
                            );

    if (err != LDAP_SUCCESS) {
        
        goto error;
    }

    ASSERT( MessageNumber != (ULONG) -1 );

    err = ldap_result_with_error(  connection,
                                   MessageNumber,
                                   LDAP_MSG_ALL,
                                   NULL,
                                   &Res,
                                   NULL
                                   );

    if (err != LDAP_SUCCESS) {
        
        goto error;
    }

    //
    // Pluck out the server returned error.
    //

    if (Res != NULL) {

        ServerError = ldap_result2error( connection->ExternalInfo,
                                         Res,
                                         FALSE
                                         );
    }


    //
    // Even if the server failed us, parse the extended response for the OID
    // and return data if any.
    //

    err = LdapParseExtendedResult( connection,
                                   Res,
                                   (PWCHAR*) ReturnedOid,
                                   ReturnedData,
                                   TRUE,       // Free the message
                                   LANG_ACP
                                   );

    //
    // Give precedence to the server return code.
    //

    if (ServerError != LDAP_SUCCESS) {

        err = ServerError;
    }


error:
    if (wOid)
        ldapFree( wOid, LDAP_UNICODE_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    return err;

}

//
// This is a Synchronous version of ldap_extened_operation. It parses out
// the response data and OId if present and returns it to the user.
//
// It returns the server error code. However, it could also return client
// errors like LDAP_NO_MEMORY, LDAP_PARAM_ERROR etc.
//

ULONG __cdecl
ldap_extended_operation_sW (
        LDAP *ExternalHandle,
        PWCHAR Oid,
        struct berval   *Data,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        PWCHAR          *ReturnedOid,
        struct berval   **ReturnedData
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;
    ULONG  MessageNumber = (ULONG) -1;
    LDAPMessage   *Res = NULL;
    ULONG ServerError = LDAP_SUCCESS;


    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    err = LdapExtendedOp(   connection,
                            Oid,
                            Data,
                            TRUE,    // Unicode controls
                            FALSE,   // Asynchronous
                            (PLDAPControlW *) ServerControls,
                            (PLDAPControlW *) ClientControls,
                            &MessageNumber
                            );

    if (err != LDAP_SUCCESS) {
        
        goto error;
    }

    ASSERT( MessageNumber != (ULONG) -1 );

    err = ldap_result_with_error(  connection,
                                   MessageNumber,
                                   LDAP_MSG_ALL,
                                   NULL,
                                   &Res,
                                   NULL
                                   );

    if (err != LDAP_SUCCESS) {
        
        goto error;
    }

    //
    // Pluck out the server returned error.
    //

    if (Res != NULL) {

        ServerError = ldap_result2error( connection->ExternalInfo,
                                         Res,
                                         FALSE
                                         );
    }


    //
    // Even if the server failed us, parse the extended response for the OID
    // and return data if any.
    //

    err = LdapParseExtendedResult( connection,
                                   Res,
                                   (PWCHAR*) ReturnedOid,
                                   ReturnedData,
                                   TRUE,       // Free the message
                                   LANG_ACP
                                   );

    //
    // Give precedence to the server return code.
    //

    if (ServerError != LDAP_SUCCESS) {

        err = ServerError;
    }


error:
    if (connection)
        DereferenceLdapConnection( connection );

    return err;

}


ULONG __cdecl
ldap_close_extended_op(
        LDAP    *ExternalHandle,
        ULONG   MessageNumber
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapAbandon( connection, MessageNumber, FALSE );

    DereferenceLdapConnection( connection );

    return err;
}

// delete.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\delete.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    delete.cxx handle delete requests to an LDAP server

Abstract:

   This module implements the LDAP delete APIs.

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG
LdapDelete(
        PLDAP_CONN connection,
        PWCHAR DistinguishedName,
        BOOLEAN Unicode,
        BOOLEAN Synchronous,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           *MessageNumber
    )
{
    ULONG hr;
    PLDAP_REQUEST request = NULL;
    ULONG messageNumber;
    ULONG err;

    if (MessageNumber == NULL) {

        return LDAP_PARAM_ERROR;
    }

    *MessageNumber = (ULONG) -1;

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {
       return err;
    }

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    request = LdapCreateRequest( connection, LDAP_DELETE_CMD );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_delete connection 0x%x couldn't allocate request.\n", connection);
        }
        hr = LDAP_NO_MEMORY;
        SetConnectionError( connection, hr, NULL );
        return hr;
    }

    messageNumber = request->MessageId;

    request->Synchronous = Synchronous;

    hr = LDAP_SUCCESS;

    if ((ServerControls != NULL) || (ClientControls != NULL)) {

        hr = LdapCheckControls( request,
                                ServerControls,
                                ClientControls,
                                Unicode,
                                0 );

        if (hr != LDAP_SUCCESS) {

            IF_DEBUG(CONTROLS) {
                LdapPrint2( "ldap_del connection 0x%x trouble with SControl, err 0x%x.\n",
                            connection, hr );
            }
        }
    }

    if (hr == LDAP_SUCCESS) {

        if (Synchronous || (request->ChaseReferrals == 0)) {

            request->AllocatedParms = FALSE;
            request->OriginalDN = DistinguishedName;

        } else {

            request->AllocatedParms = TRUE;

            if (DistinguishedName != NULL) {

                request->OriginalDN = ldap_dup_stringW( DistinguishedName, 0, LDAP_UNICODE_SIGNATURE );

                if (request->OriginalDN == NULL) {

                    hr = LDAP_NO_MEMORY;
                }
            }
        }
    }

    if (hr == LDAP_SUCCESS) {

        START_LOGGING;
        DSLOG((DSLOG_FLAG_TAG_CNPN,"[+]"));
        DSLOG((0,"[ID=%d][OP=ldap_delete][DN=%ws][ST=%I64d][-]\n",
               request->MessageId, DistinguishedName,
               request->RequestTime));
        END_LOGGING;

        hr = SendLdapDelete( request,
                             connection,
                             request->OriginalDN,
                             (CLdapBer **)&request->BerMessageSent,
                             0 );
    }

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_add connection 0x%x errored with 0x%x.\n",
                        connection, hr );
        }

        DSLOG((0,"[+][ID=%d][ET=%I64d][ER=%d][-]\n",request->MessageId,LdapGetTickCount(), hr));
        messageNumber = (ULONG) -1;
        SetConnectionError( connection, hr, NULL );

        CloseLdapRequest( request );
    }

    *MessageNumber = messageNumber;

    DereferenceLdapRequest( request );

    return hr;
}

ULONG
SendLdapDelete (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection,
    PWCHAR DistinguishedName,
    CLdapBer **Lber,
    LONG AltMsgId
    )
{
    ULONG hr;

    CLdapBer *lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {
        SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
        return LDAP_NO_MEMORY;
    }

    //
    //  The request looks like the following :
    //
    //   DelRequest ::= [APPLICATION 10] LDAPDN
    //

    hr = lber->HrStartWriteSequence();
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_delete startWrite conn 0x%x encoding error of 0x%x.\n",
                        Connection, hr );
        }

        goto encodingError;

    } else {            // we can't forget EndWriteSequence

       if (AltMsgId != 0) {

          hr = lber->HrAddValue((LONG) AltMsgId );

       } else {

          hr = lber->HrAddValue((LONG) Request->MessageId );
       }

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_delete MsgNo conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;
        }

        hr = lber->HrAddValue((const WCHAR *) DistinguishedName, LDAP_DELETE_CMD );
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_delete DN conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;
        }

        //
        //  put in the server controls here if required
        //

        if ( (Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
             ( Request->ServerControls != NULL )) {

            hr = InsertServerControls( Request, Connection, lber );

            if (hr != LDAP_SUCCESS) {

                if (lber != NULL) {

                   delete lber;
                }
                return hr;
            }
        }

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );
    }

    //
    //  send the delete request.
    //

    ACQUIRE_LOCK( &Connection->ReconnectLock );

    AddToPendingList( Request, Connection );

    hr = LdapSend( Connection, lber );

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_delete connection 0x%x send with error of 0x%x.\n",
                        Connection, hr );
        }
        DecrementPendingList( Request, Connection );

    } else {

        //
        //  Save off the lber value, free any lber message that is already
        //  present.
        //

        lber = (CLdapBer *) InterlockedExchangePointer((PVOID *) Lber,
                                                       (PVOID) lber );
    }

    RELEASE_LOCK( &Connection->ReconnectLock );

    if (lber != NULL) {

       delete lber;
    }

    return hr;

encodingError:

    if (lber != NULL) {

       delete lber;
    }

    return LDAP_ENCODING_ERROR;
}

ULONG __cdecl
ldap_delete_extW(
        LDAP *ExternalHandle,
        PWCHAR dn,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           *MessageNumber
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err =  LdapDelete(  connection,
                        dn,
                        TRUE,
                        FALSE,
                        ServerControls,
                        ClientControls,
                        MessageNumber
                        );

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_deleteW (
    LDAP *ExternalHandle,
    PWCHAR DistinguishedName
    )
{
    ULONG err;
    ULONG msgId = (ULONG) -1;

    err = ldap_delete_extW( ExternalHandle,
                            DistinguishedName,
                            NULL,
                            NULL,
                            &msgId
                            );
    return msgId;
}

ULONG __cdecl
ldap_delete (
    LDAP *ExternalHandle,
    PCHAR DistinguishedName
    )
{
    ULONG err;
    ULONG msgId = (ULONG) -1;

    err = ldap_delete_extA( ExternalHandle,
                            DistinguishedName,
                            NULL,
                            NULL,
                            &msgId
                            );
    return msgId;
}


ULONG __cdecl
ldap_delete_sW (
    LDAP *ExternalHandle,
    PWCHAR DistinguishedName
    )
{
    return ldap_delete_ext_sW( ExternalHandle, DistinguishedName, NULL, NULL );
}

ULONG __cdecl
ldap_delete_s (
    LDAP *ExternalHandle,
    PCHAR DistinguishedName
    )
{
    return ldap_delete_ext_sA( ExternalHandle, DistinguishedName, NULL, NULL );
}


ULONG __cdecl
ldap_delete_extA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        ULONG           *MessageNumber
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (MessageNumber == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *MessageNumber = (ULONG) -1;

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        goto error;
    }

    err = LdapDelete(  connection,
                       wName,
                       FALSE,
                       FALSE,
                       (PLDAPControlW *) ServerControls,
                       (PLDAPControlW *) ClientControls,
                       MessageNumber
                       );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_delete_ext_sW(
        LDAP *ExternalHandle,
        PWCHAR dn,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls
        )
{
    ULONG err;
    ULONG msgId;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapDelete(connection,
                     dn,
                     TRUE,
                     TRUE,
                     ServerControls,
                     ClientControls,
                     &msgId
                     );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                    );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     results,
                                     TRUE
                                     );
        }
    }

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_delete_ext_sA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    ULONG msgId;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    err = LdapDelete(connection,
                     wName,
                     FALSE,
                     TRUE,
                     (PLDAPControlW *) ServerControls,
                     (PLDAPControlW *) ClientControls,
                     &msgId
                     );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                    );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     results,
                                     TRUE
                                     );
        }
    }

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    DereferenceLdapConnection( connection );

    return err;

}

// delete.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\getset.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    getset.cxx  modify or get values from an LDAP connection block

Abstract:

   This module implements the LDAP ldap_get_opt and ldap_set_opt APIs.

Author:

    Andy Herron    (andyhe)        08-May-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"


static PWCHAR SupportedExtensionList[] = {
                                L"VIRTUAL_LIST_VIEW",
                                NULL
                                };

#define NUM_SUPPORTED_EXTENSIONS  ((sizeof(SupportedExtensionList)/sizeof(PWCHAR))-1)



ULONG __cdecl ldap_get_optionW (
    LDAP *ExternalHandle,
    int option,
    void *outvalue )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    //
    // The connection itself might be in a closed state but we still need
    // to reference it. Hence, we call GetConnectionPointer2.
    //

    connection = GetConnectionPointer2(ExternalHandle);

    if (((connection == NULL) && (option != LDAP_OPT_API_INFO)) ||
         (outvalue == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    err = LdapGetConnectionOption( connection, option, outvalue, TRUE );

error:
    if (connection)
    {
        DereferenceLdapConnection( connection );
    }

    return err;
}

ULONG __cdecl ldap_get_option (
    LDAP *ExternalHandle,
    int option,
    void *outvalue )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    //
    // The connection itself might be in a closed state but we still need
    // to reference it. Hence, we call GetConnectionPointer2.
    //
    
    connection = GetConnectionPointer2(ExternalHandle);

    if (((connection == NULL) && (option != LDAP_OPT_API_INFO))||
         (outvalue == NULL)) {
        err = LDAP_PARAM_ERROR;
        goto error;
    }

    err = LdapGetConnectionOption( connection, option, outvalue, FALSE );

error:
    if (connection)
    {
        DereferenceLdapConnection( connection );
    }

    return err;
}


ULONG __cdecl ldap_set_optionW (
    LDAP *ExternalHandle,
    int option,
    const void *invalue )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL)
    {
        err = LDAP_PARAM_ERROR;
        goto error;
    }

    err = LdapSetConnectionOption( connection, option, invalue, TRUE );

error:
    if (connection)
    {
        DereferenceLdapConnection( connection );
    }

    return err;
}

ULONG __cdecl ldap_set_option (
    LDAP *ExternalHandle,
    int option,
    const void *invalue )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL)
    {
        err = LDAP_PARAM_ERROR;
        goto error;
    }

    err = LdapSetConnectionOption( connection, option, invalue, FALSE );

error:
    if (connection)
    {
        DereferenceLdapConnection( connection );
    }

    return err;
}

ULONG LdapGetConnectionOption (
    PLDAP_CONN connection,
    int option,
    void *outvalue,
    BOOLEAN Unicode
    )
{
    ULONG err = LDAP_SUCCESS;
    PLDAP_REFERRAL_CALLBACK refCallbacks;


    ASSERT(outvalue != NULL);

    switch (option) {

    case LDAP_OPT_DESC:     // socket descriptor

        *((SOCKET *) outvalue) = get_socket( connection );
        break;

    case LDAP_OPT_DEREF:

        *((ULONG *) outvalue) = connection->publicLdapStruct.ld_deref;
        break;

    case LDAP_OPT_SIZELIMIT:

        *((ULONG *) outvalue) = connection->publicLdapStruct.ld_sizelimit;
        break;

    case LDAP_OPT_TIMELIMIT:

        *((ULONG *) outvalue) = connection->publicLdapStruct.ld_timelimit;
        break;

    case LDAP_OPT_REFERRALS:

        if (connection->publicLdapStruct.ld_options & LDAP_OPT_CHASE_REFERRALS) {

            *((ULONG *) outvalue) = PtrToUlong(LDAP_OPT_ON);

        } else {

            *((ULONG *) outvalue) = ( connection->publicLdapStruct.ld_options &
         (LDAP_CHASE_SUBORDINATE_REFERRALS | LDAP_CHASE_EXTERNAL_REFERRALS));
        }
        break;

    case LDAP_OPT_SSL:

        *((ULONG *) outvalue) =
                PtrToUlong((connection->SecureStream) ? LDAP_OPT_ON : LDAP_OPT_OFF );
        break;

    case LDAP_OPT_VERSION:

        *((ULONG *) outvalue) = connection->publicLdapStruct.ld_version;
        break;

    case LDAP_OPT_REFERRAL_HOP_LIMIT:

        *((ULONG *) outvalue) = connection->publicLdapStruct.ld_refhoplimit;
        break;

    case LDAP_OPT_HOST_NAME:

        //
        // Existing code does NOT free the strings returned by this API. We
        // should (unfortunately) retain the same semantics.
        //

        if (Unicode) {

            if (connection->DnsSuppliedName != NULL) {

               *((PWCHAR *) outvalue) = connection->DnsSuppliedName;

            } else if (connection->ExplicitHostName != NULL) {

                *((PWCHAR *) outvalue) = connection->ExplicitHostName;

            } else {

                *((PWCHAR *) outvalue) = connection->HostNameW;
            }

        } else {

            PCHAR tempName = NULL;

            if (connection->OptHostNameA != NULL) {
                ldapFree(connection->OptHostNameA, LDAP_BUFFER_SIGNATURE);
                connection->OptHostNameA = NULL;
            }

            if (connection->DnsSuppliedName != NULL) {

               err = FromUnicodeWithAlloc( connection->DnsSuppliedName, &tempName, LDAP_BUFFER_SIGNATURE, LANG_ACP );

            } else if (connection->ExplicitHostName != NULL) {

               err = FromUnicodeWithAlloc( connection->ExplicitHostName, &tempName, LDAP_BUFFER_SIGNATURE, LANG_ACP );

            } else {

               err = FromUnicodeWithAlloc( connection->HostNameW, &tempName, LDAP_BUFFER_SIGNATURE, LANG_ACP );
            }

            *((PCHAR *) outvalue) = tempName;
            connection->OptHostNameA = tempName;
        }

        break;

    case LDAP_OPT_DNSDOMAIN_NAME:

        if (Unicode) {
            
            *((PWCHAR *) outvalue) = ldap_dup_stringW(connection->DomainName,
                                                      0,
                                                      LDAP_BUFFER_SIGNATURE
                                                      );

        } else {

            PCHAR tempName = NULL;

            err = FromUnicodeWithAlloc( connection->DomainName, &tempName, LDAP_BUFFER_SIGNATURE, LANG_ACP );

            *((PCHAR *) outvalue) = tempName;
        }

        break;

    case LDAP_OPT_ERROR_NUMBER:

        *((ULONG *) outvalue) = connection->publicLdapStruct.ld_errno;
        break;

    case LDAP_OPT_SSPI_FLAGS:

        *((ULONG *) outvalue) = connection->NegotiateFlags;
        break;

    case LDAP_OPT_PROMPT_CREDENTIALS:

        *((ULONG *) outvalue) = PtrToUlong( connection->PromptForCredentials ?
                                            LDAP_OPT_ON : LDAP_OPT_OFF );
        break;

    case LDAP_OPT_ERROR_STRING:

        if (Unicode) {

            *((PWCHAR *) outvalue) = (PWCHAR) ldap_err2stringW( connection->publicLdapStruct.ld_errno );

        } else {

            *((PCHAR *) outvalue) = (PCHAR) connection->publicLdapStruct.ld_error;
        }
        break;

    case LDAP_OPT_SERVER_ERROR:

       if (Unicode) {

          *((PWCHAR *) outvalue) = (PWCHAR) GetErrorMessage( connection, TRUE );

       } else {

          *((PCHAR *) outvalue) = (PCHAR) GetErrorMessage( connection, FALSE );

       }
       break;

    case LDAP_OPT_SERVER_EXT_ERROR: {

       PCHAR errorString;
       DWORD errRet = 0;
       DWORD i;

       err = LDAP_UNAVAILABLE;
       errorString = (PCHAR) GetErrorMessage( connection, FALSE );

       //
       // ok, we got something. Make sure it is at least 8 bytes long and the
       // first 8 bytes are hexadecimals.  If the first 8 bytes are not hexadecimal,
       // it is not formatted correctly. We cannot assume validity in this case.
       //

       if (errorString != NULL) {

           if ( strlen(errorString) >=  8 ) {

               for (i=0; i < 8; i++ ) {

                  errRet <<= 4;

                  if ( (errorString[i] >= '0') && (errorString[i] <= '9') ) {

                      errRet |= (errorString[i] - '0');
                  } else if ( (errorString[i] >= 'a') && (errorString[i] <= 'f') ) {

                      errRet |= (errorString[i] - 'a' + 10);
                  } else if ( (errorString[i] >= 'A') && (errorString[i] <= 'F') ) {

                      errRet |= (errorString[i] - 'A' + 10);
                  } else {
                      break;
                  }
               }

               if ( i == 8 ) {
                  err = LDAP_SUCCESS;
               } else {
                   errRet = 0;
               }
           }
           ldap_memfree(errorString);
       }

       *((ULONG *) outvalue) = errRet;
       break;
    }

    case LDAP_OPT_REFERRAL_CALLBACK:

        refCallbacks = (PLDAP_REFERRAL_CALLBACK) outvalue;

        if (refCallbacks->SizeOfCallbacks == sizeof(LDAP_REFERRAL_CALLBACK)) {

            refCallbacks->NotifyRoutine = connection->ReferralNotifyRoutine;
            refCallbacks->QueryForConnection = connection->ReferralQueryRoutine;
            refCallbacks->DereferenceRoutine = connection->DereferenceNotifyRoutine;

        } else {

            err = LDAP_PARAM_ERROR;
        }

        break;

    case LDAP_OPT_CLIENT_CERTIFICATE:

       *((QUERYCLIENTCERT **) outvalue) = connection->ClientCertRoutine;

       break;

    case LDAP_OPT_SERVER_CERTIFICATE:

       *((VERIFYSERVERCERT **) outvalue) = connection->ServerCertRoutine;

       break;


    case LDAP_OPT_GETDSNAME_FLAGS:

        *((ULONG *) outvalue) = connection->GetDCFlags;
        break;

    case LDAP_OPT_HOST_REACHABLE:

        err = PtrToUlong(LDAP_OPT_ON);

        if (connection->ServerDown == TRUE) {

            err = PtrToUlong(LDAP_OPT_OFF);

        } else {

            ULONGLONG tickCount = LdapGetTickCount();

            if (tickCount > connection->TimeOfLastReceive) {

                tickCount -= connection->TimeOfLastReceive;

                if (tickCount >= connection->KeepAliveSecondCount * 1000) {

                    //
                    //  if we would have to send a ping, then we return
                    //  ldap_opt_off, otherwise if the connection is up,
                    //  we return ok (LDAP_OPT_ON).
                    //

                    err = PtrToUlong(LDAP_OPT_OFF);
                }
            }
        }

        *((ULONG *) outvalue) = err;
        err = LDAP_SUCCESS;
        break;

    case LDAP_OPT_THREAD_FN_PTRS:
    case LDAP_OPT_REBIND_FN:
    case LDAP_OPT_REBIND_ARG:
    case LDAP_OPT_RESTART:
    case LDAP_OPT_IO_FN_PTRS:
    case LDAP_OPT_CACHE_FN_PTRS:
    case LDAP_OPT_CACHE_STRATEGY:
    case LDAP_OPT_CACHE_ENABLE:

        err = LDAP_LOCAL_ERROR;
        break;

    case LDAP_OPT_PING_KEEP_ALIVE:

        *((ULONG *) outvalue) = connection->KeepAliveSecondCount;
        break;

    case LDAP_OPT_PING_WAIT_TIME:

        *((ULONG *) outvalue) = connection->PingWaitTimeInMilliseconds;
        break;

    case LDAP_OPT_PING_LIMIT:

        *((ULONG *) outvalue) = connection->PingLimit;
        break;

    case LDAP_OPT_SSL_INFO:

       PSECURESTREAM pSecureStream;

       pSecureStream = (PSECURESTREAM) connection->SecureStream;

       if ((pSecureStream == NULL) ||
           ((connection->HostConnectState != HostConnectStateConnected))) {
           
           //
           // If SSL/TLS is not on, report it
           //
           
           err = LDAP_UNAVAILABLE;
           break;
       }

       err = pSecureStream->GetSSLAttributes( (PSecPkgContext_ConnectionInfo) outvalue );
       err = LdapConvertSecurityError( connection, err );
       *((ULONG *) outvalue) =  err;
       break;

    case LDAP_OPT_REF_DEREF_CONN_PER_MSG:

        *((ULONG *) outvalue) =
                PtrToUlong((connection->ReferenceConnectionsPerMessage) ? LDAP_OPT_ON : LDAP_OPT_OFF );
        break;

    case LDAP_OPT_SIGN:

       // We want to return TRUE if the user requested signing, but has not yet bound, to preserve semantics
       // (otherwise, you could call ldap_set_option to turn on signing, then immediately call ldap_get_option and
       // it would indicate signing was off, a strange situation).  We also want to return TRUE if signing is
       // on even though the user didn't ask for it (as a result of group policy).  This does create one issue, though:
       // if the connection is currently signed, and you use ldap_set_option to turn off signing, ldap_get_option
       // will still indicate signing is on until you re-bind because it indicates the current (not future) status.
       // Since the ability to turn off signing is a new feature, though, it shouldn't be too big of an issue.
       *((ULONG *) outvalue) =
               PtrToUlong(((connection->UserSignDataChoice)||(connection->CurrentSignStatus)) ? LDAP_OPT_ON : LDAP_OPT_OFF );
       break;

    case LDAP_OPT_ENCRYPT:
       // see comments about signing above
       *((ULONG *) outvalue) =
               PtrToUlong(((connection->UserSealDataChoice)||(connection->CurrentSealStatus)) ? LDAP_OPT_ON : LDAP_OPT_OFF );
       break;

    case LDAP_OPT_SASL_METHOD:

       if (Unicode) {

           *((PWCHAR *) outvalue) = ldap_dup_stringW(connection->SaslMethod,
                                                     0,
                                                     LDAP_BUFFER_SIGNATURE
                                                     );

       } else {

           PCHAR temp = NULL;

           err = FromUnicodeWithAlloc(connection->SaslMethod,
                                      &temp,
                                      LDAP_BUFFER_SIGNATURE,
                                      LANG_ACP
                                      );

           *((PCHAR *) outvalue) = temp;

       }

       break;

    case LDAP_OPT_AREC_EXCLUSIVE:
        
        *((ULONG *) outvalue) =
                PtrToUlong((connection->AREC_Exclusive) ? LDAP_OPT_ON : LDAP_OPT_OFF );
        break;

    case LDAP_OPT_AUTO_RECONNECT:
        
        *((ULONG *) outvalue) =
                PtrToUlong((connection->UserAutoRecChoice) ? LDAP_OPT_ON : LDAP_OPT_OFF );
        break;

    case LDAP_OPT_SECURITY_CONTEXT:
    
       if (!connection->BindPerformed) {

          err = LDAP_UNWILLING_TO_PERFORM;
          break;
       }
       ((PCtxtHandle) outvalue)->dwLower = connection->SecurityContext.dwLower;
       ((PCtxtHandle) outvalue)->dwUpper = connection->SecurityContext.dwUpper;
       break;

    case LDAP_OPT_API_INFO:
        
        LDAPAPIInfoW *pLdapApiInfo;
         
        pLdapApiInfo = (LDAPAPIInfoW *) outvalue;

        if ( pLdapApiInfo->ldapai_info_version != LDAP_API_INFO_VERSION ) {
            pLdapApiInfo->ldapai_info_version = LDAP_API_INFO_VERSION;
            err = LDAP_UNWILLING_TO_PERFORM;
            break;
        }

        pLdapApiInfo->ldapai_api_version = LDAP_API_VERSION;
        pLdapApiInfo->ldapai_protocol_version = LDAP_VERSION3;
        pLdapApiInfo->ldapai_vendor_version = LdapGetModuleBuildNum();
        
        if (Unicode) {
        
            pLdapApiInfo->ldapai_vendor_name = ldap_dup_stringW( LDAP_VENDOR_NAME_W,
                                                                 0,
                                                                 LDAP_VALUE_SIGNATURE ); 
        } else {

            pLdapApiInfo->ldapai_vendor_name = (PWCHAR) ldap_dup_string( LDAP_VENDOR_NAME,
                                                                         0,
                                                                         LDAP_VALUE_SIGNATURE ); 
        }

        PWCHAR *Array_To_Return;
        ULONG  numberofentries;
        ULONG  i;

        Array_To_Return = NULL;
        numberofentries = 0;

        for (i=0; i < NUM_SUPPORTED_EXTENSIONS; i++) {

            err = add_string_to_list( &Array_To_Return,
                                      &numberofentries,
                                      SupportedExtensionList[i],
                                      TRUE
                                      );

            if (err == 0) {
                Array_To_Return = NULL;
                err = LDAP_NO_MEMORY;
                break;
            }
        }

        pLdapApiInfo->ldapai_extensions = Array_To_Return;

        if (!Unicode) {

            //
            // Convert the list of unicode strings to ANSI... what a pain
            //
            
            PWCHAR *ExtNames = pLdapApiInfo->ldapai_extensions;
            PCHAR *ansiNames = (PCHAR *) ExtNames;
            PCHAR explodedName;
            
            if (ansiNames != NULL) {
        
                while (*ExtNames != NULL) {
                    
                    explodedName = NULL;
            
                    err = FromUnicodeWithAlloc( *ExtNames, &explodedName, LDAP_VALUE_SIGNATURE, LANG_ACP );
            
                    if (err != LDAP_SUCCESS) {
            
                        ldap_value_free( ansiNames );
                        err = LDAP_NO_MEMORY;
                        break;
                    }
            
                    ldapFree( *ExtNames, LDAP_VALUE_SIGNATURE );
                    *((PCHAR *) ExtNames) = explodedName;
                    ExtNames++;        // on to next entry in array
                }
            }

            pLdapApiInfo->ldapai_extensions = (PWCHAR*) ansiNames;
        }

        break;

    case LDAP_OPT_API_FEATURE_INFO:

        LDAPAPIFeatureInfoW *pLdapApiFeatureInfo;
         
        pLdapApiFeatureInfo = (LDAPAPIFeatureInfoW *) outvalue;

        if ( pLdapApiFeatureInfo->ldapaif_info_version != LDAP_FEATURE_INFO_VERSION ) {
            pLdapApiFeatureInfo->ldapaif_info_version = LDAP_FEATURE_INFO_VERSION;
            err = LDAP_UNWILLING_TO_PERFORM;
            break;
        }

        //
        // Match the name of the requested extension against our
        // SupportedExtensionList. For the time being, since we support just one
        // extension, we will fudge the value.
        //

        pLdapApiFeatureInfo->ldapaif_version = LDAP_API_FEATURE_VIRTUAL_LIST_VIEW;

        break;
    
    case LDAP_OPT_ROOTDSE_CACHE:
        *((ULONG *) outvalue) =
                PtrToUlong( DisableRootDSECache ? LDAP_OPT_OFF : LDAP_OPT_ON );
        break;

    case LDAP_OPT_TCP_KEEPALIVE:
        *((ULONG *) outvalue) =
                PtrToUlong( connection->UseTCPKeepAlives ? LDAP_OPT_ON : LDAP_OPT_OFF );
        break;

    default:

        err = LDAP_PARAM_ERROR;
    }

    return err;
}


ULONG LdapSetConnectionOption (
    PLDAP_CONN connection,
    int option,
    const void *invalue,
    BOOLEAN Unicode
    )
{
    ULONG err = LDAP_SUCCESS;
    ULONG value;
    PLDAP_REFERRAL_CALLBACK refCallbacks;

    ASSERT(connection != NULL);

    switch (option) {
    case LDAP_OPT_DEREF:

        value = RealValue(invalue);

        if ((value != LDAP_DEREF_NEVER) &&
            (value != LDAP_DEREF_SEARCHING) &&
            (value != LDAP_DEREF_FINDING) &&
            (value != LDAP_DEREF_ALWAYS)) {

            err = LDAP_PARAM_ERROR;

        } else {

            connection->publicLdapStruct.ld_deref = value;
        }
        break;

    case LDAP_OPT_SIZELIMIT:

        connection->publicLdapStruct.ld_sizelimit = *((ULONG *) invalue);
        break;

    case LDAP_OPT_TIMELIMIT:

        connection->publicLdapStruct.ld_timelimit = *((ULONG *) invalue);
        break;

    case LDAP_OPT_SSPI_FLAGS:

        connection->NegotiateFlags = *((ULONG *) invalue);

        if (connection->NegotiateFlags & (ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT)) {
            connection->UserSignDataChoice = TRUE;
        }
        else {
            connection->UserSignDataChoice = FALSE;
        }

        if (connection->NegotiateFlags & ISC_REQ_CONFIDENTIALITY) {
            connection->UserSealDataChoice = TRUE;
        }
        else {
            connection->UserSealDataChoice = FALSE;
        }  

        break;

    case LDAP_OPT_REFERRALS:

        value = RealValue(invalue);

        if (value == PtrToUlong(LDAP_OPT_ON)) {

            connection->publicLdapStruct.ld_options |= LDAP_OPT_CHASE_REFERRALS;
            connection->publicLdapStruct.ld_options |= LDAP_CHASE_SUBORDINATE_REFERRALS;
            connection->publicLdapStruct.ld_options |= LDAP_CHASE_EXTERNAL_REFERRALS;

        } else if (value == PtrToUlong(LDAP_OPT_OFF)) {

            connection->publicLdapStruct.ld_options &= ~LDAP_OPT_CHASE_REFERRALS;
            connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_SUBORDINATE_REFERRALS;
            connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_EXTERNAL_REFERRALS;

        } else if ((value & (LDAP_CHASE_SUBORDINATE_REFERRALS |
                             LDAP_CHASE_EXTERNAL_REFERRALS)) != value) {

            err = LDAP_PARAM_ERROR;

        } else {

            connection->publicLdapStruct.ld_options &= ~LDAP_OPT_CHASE_REFERRALS;
            connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_SUBORDINATE_REFERRALS;
            connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_EXTERNAL_REFERRALS;
            connection->publicLdapStruct.ld_options |= ( value & LDAP_CHASE_SUBORDINATE_REFERRALS );
            connection->publicLdapStruct.ld_options |= ( value & LDAP_CHASE_EXTERNAL_REFERRALS );
        }
        break;

    case LDAP_OPT_PROMPT_CREDENTIALS:

        value = RealValue(invalue);

        if (value == PtrToUlong(LDAP_OPT_ON)) {

            connection->PromptForCredentials = TRUE;

        } else if (value == PtrToUlong(LDAP_OPT_OFF)) {

            connection->PromptForCredentials = FALSE;

        } else {

            err = LDAP_PARAM_ERROR;
        }
        break;

    case LDAP_OPT_SSL:

        value = RealValue(invalue);

        if (value == PtrToUlong(LDAP_OPT_ON)) {

            if (connection->SslPort == FALSE) {

                if (connection->BindPerformed) {

                    err = LDAP_UNWILLING_TO_PERFORM;
                    break;
                }

                if ( connection->HostConnectState == HostConnectStateUnconnected ) {

                    err = SEC_E_OK;

                } else {

                    err = LdapSetupSslSession( connection );
                }

                if (err == SEC_E_OK) {

                    connection->SslPort = TRUE;

                } else {

                    err = LDAP_LOCAL_ERROR;
                    break;
                }

            } else {

                err = LDAP_SUCCESS;
            }

        } else if (value == PtrToUlong(LDAP_OPT_OFF)) {

            //
            //  we don't allow clients to disable ssl once the connection has
            //  been setup.
            //

            if ( connection->HostConnectState == HostConnectStateUnconnected ) {

                connection->SslPort = FALSE;

            } else if ((connection->SslPort == TRUE) ||
                       (connection->SslSetupInProgress == TRUE) ||
                       (connection->SecureStream != NULL)) {

                err = LDAP_UNWILLING_TO_PERFORM;
                break;
            }

            err = LDAP_SUCCESS;

        } else {

            err = LDAP_PARAM_ERROR;
        }
        break;

    case LDAP_OPT_VERSION:

        value = RealValue(invalue);

        if ((value != LDAP_VERSION2) &&
            (value != LDAP_VERSION3)) {

            err = LDAP_LOCAL_ERROR;

        } else {

            connection->publicLdapStruct.ld_version = value;
        }
        break;

    case LDAP_OPT_REFERRAL_HOP_LIMIT:

        value = *((ULONG *) invalue);

        connection->publicLdapStruct.ld_refhoplimit = value;
        break;

    case LDAP_OPT_ERROR_NUMBER:     // what the heck... let them change it.

        connection->publicLdapStruct.ld_errno = *((ULONG *) invalue);
        break;

    case LDAP_OPT_REFERRAL_CALLBACK:

        refCallbacks = (PLDAP_REFERRAL_CALLBACK) invalue;

        if (refCallbacks->SizeOfCallbacks == sizeof(LDAP_REFERRAL_CALLBACK)) {

            connection->ReferralNotifyRoutine = refCallbacks->NotifyRoutine;
            connection->ReferralQueryRoutine = refCallbacks->QueryForConnection;
            connection->DereferenceNotifyRoutine = refCallbacks->DereferenceRoutine;

        } else {

            err = LDAP_PARAM_ERROR;
        }
        break;

    case LDAP_OPT_CLIENT_CERTIFICATE:

       connection->ClientCertRoutine = (QUERYCLIENTCERT *)invalue;
       break;

    case LDAP_OPT_SERVER_CERTIFICATE:

       connection->ServerCertRoutine = (VERIFYSERVERCERT *)invalue;
       break;

    case LDAP_OPT_GETDSNAME_FLAGS:

        value = *((ULONG *) invalue);
        connection->GetDCFlags = value;
        break;

    case LDAP_OPT_HOST_NAME:

        if (connection->HostConnectState != HostConnectStateUnconnected) {

            err = LDAP_UNWILLING_TO_PERFORM;
            break;
        }

        PCHAR newHostName;

        newHostName = *((PCHAR *) invalue);

        if (newHostName == NULL) {
            break;
        }

        if (!Unicode) {

            err = ToUnicodeWithAlloc( newHostName, -1, &connection->ExplicitHostName, LDAP_HOST_NAME_SIGNATURE, LANG_ACP);

            break;

        } else {

            connection->ExplicitHostName = ldap_dup_stringW( (PWCHAR) newHostName,
                                                              0,
                                                              LDAP_HOST_NAME_SIGNATURE );

            if (connection->ExplicitHostName == NULL) {
                err = LDAP_NO_MEMORY;
            }
        }

        break;

    case LDAP_OPT_SIGN:

       value = RealValue(invalue);

       if (value == PtrToUlong(LDAP_OPT_ON)) {

          if (connection->SslPort) {

             err = LDAP_UNWILLING_TO_PERFORM;
             break;
          }

          connection->NegotiateFlags |= (ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
          connection->UserSignDataChoice = TRUE;
       }
       else if (value == PtrToUlong(LDAP_OPT_OFF)) {

          connection->NegotiateFlags &= ~(ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
          connection->UserSignDataChoice = FALSE;
       }
       else {
       
          err = LDAP_PARAM_ERROR;
       }
        
           
       break;

    case LDAP_OPT_ENCRYPT:

       value = RealValue(invalue);

       if (value == PtrToUlong(LDAP_OPT_ON)) {

           if (connection->SslPort) {

             err = LDAP_UNWILLING_TO_PERFORM;
             break;
           }

           connection->NegotiateFlags |= ISC_REQ_CONFIDENTIALITY;
           connection->UserSealDataChoice = TRUE;

       }
       else if (value == PtrToUlong(LDAP_OPT_OFF)) {

          connection->NegotiateFlags &= ~(ISC_REQ_CONFIDENTIALITY);
          connection->UserSealDataChoice = FALSE;
          
       }
       else {
       
          err = LDAP_PARAM_ERROR;
       }

       break;

    case LDAP_OPT_DNSDOMAIN_NAME:

        PWCHAR DomainName;

        if (connection->BindInProgress) {

            err = LDAP_UNWILLING_TO_PERFORM;
            break;
        }

        DomainName = *((PWCHAR *) invalue);

        if (connection->DomainName != NULL) {
            ldapFree( connection->DomainName, LDAP_HOST_NAME_SIGNATURE );
            connection->DomainName = NULL;
        }
        
        if (DomainName == NULL) {
            //
            // Nothing else to do
            //
            break;
        }

        //
        // Make a copy of the string
        //

        if (Unicode) {

            connection->DomainName = ldap_dup_stringW( DomainName, 0, LDAP_HOST_NAME_SIGNATURE );

            if (connection->DomainName == NULL) {
                err = LDAP_NO_MEMORY;
            }

        } else {

            err = ToUnicodeWithAlloc( (PCHAR) DomainName,
                                       -1,
                                       &connection->DomainName,
                                       LDAP_HOST_NAME_SIGNATURE,
                                       LANG_ACP );
        }

        break;
    
    
    case LDAP_OPT_DESC:     // socket descriptor
    case LDAP_OPT_ERROR_STRING:
    case LDAP_OPT_SECURITY_CONTEXT:

        err = LDAP_UNWILLING_TO_PERFORM;
        break;

    case LDAP_OPT_THREAD_FN_PTRS:
    case LDAP_OPT_REBIND_FN:
    case LDAP_OPT_REBIND_ARG:
    case LDAP_OPT_RESTART:
    case LDAP_OPT_IO_FN_PTRS:
    case LDAP_OPT_CACHE_FN_PTRS:
    case LDAP_OPT_CACHE_STRATEGY:
    case LDAP_OPT_CACHE_ENABLE:

        err = LDAP_LOCAL_ERROR;
        break;

    case LDAP_OPT_PING_KEEP_ALIVE:

        value = *((ULONG *) invalue);

        if ((value != 0) &&
            ((value < LDAP_PING_KEEP_ALIVE_MIN) ||
             (value > LDAP_PING_KEEP_ALIVE_MAX)))  {

            err = LDAP_PARAM_ERROR;

        } else {

            connection->KeepAliveSecondCount = value;
        }
        break;

    case LDAP_OPT_PING_WAIT_TIME:

        value = *((ULONG *) invalue);

        if ((value != 0) &&
            ((value < LDAP_PING_WAIT_TIME_MIN) ||
             (value > LDAP_PING_WAIT_TIME_MAX)))  {

            err = LDAP_PARAM_ERROR;

        } else {

            connection->PingWaitTimeInMilliseconds = value;
        }
        break;

    case LDAP_OPT_PING_LIMIT:

        value = *((ULONG *) invalue);

        if ((value != 0) &&
            ((value < LDAP_PING_LIMIT_MIN) ||
             (value > LDAP_PING_LIMIT_MAX)))  {

            err = LDAP_PARAM_ERROR;

        } else {

            connection->PingLimit = LOWORD(value);
        }
        break;

    case LDAP_OPT_REF_DEREF_CONN_PER_MSG:

        value = RealValue(invalue);

        if (value == PtrToUlong(LDAP_OPT_ON)) {

            connection->ReferenceConnectionsPerMessage = TRUE;

        } else if (value == PtrToUlong(LDAP_OPT_OFF)) {

            connection->ReferenceConnectionsPerMessage = FALSE;

        } else {

            err = LDAP_PARAM_ERROR;
        }
        break;

    case LDAP_OPT_SASL_METHOD:

        PWCHAR SaslMethod;

        if (connection->BindInProgress) {

            err = LDAP_UNWILLING_TO_PERFORM;
            break;
        }

        SaslMethod = *((PWCHAR *) invalue);

        if (SaslMethod == NULL) {
            err = LDAP_PARAM_ERROR;
            break;
        }

        //
        // Make a copy of the string
        //

        if (Unicode) {

            SaslMethod = ldap_dup_stringW(SaslMethod, 0, LDAP_SASL_SIGNATURE);

        } else {

            err = ToUnicodeWithAlloc( (PCHAR) SaslMethod, -1, &SaslMethod,LDAP_SASL_SIGNATURE, LANG_ACP );
        }

        if (pSaslGetProfilePackageW) {

            err = (*pSaslGetProfilePackageW)( SaslMethod,
                                             &connection->PreferredSecurityPackage
                                            );

            IF_DEBUG(BIND) {
                LdapPrint1("SaslGetProfilePackageA returned 0x%x\n", err);
            }

            err = LdapConvertSecurityError( connection, err );

            if (err == LDAP_SUCCESS) {

                ldapFree( connection->SaslMethod, LDAP_SASL_SIGNATURE );
                connection->SaslMethod = SaslMethod;
            } else {
                ldapFree( SaslMethod, LDAP_SASL_SIGNATURE );
            }

        } else {

            err = LDAP_LOCAL_ERROR;
        }

        break;

    case LDAP_OPT_AREC_EXCLUSIVE:
        
        value = RealValue(invalue);

        if (value == PtrToUlong(LDAP_OPT_ON)) {

            connection->AREC_Exclusive = TRUE;

        } else if (value == PtrToUlong(LDAP_OPT_OFF)) {

            connection->AREC_Exclusive = FALSE;

        } else {

            err = LDAP_PARAM_ERROR;
        }
        break;
    
    case LDAP_OPT_AUTO_RECONNECT:

        value = RealValue(invalue);

        if (value == PtrToUlong(LDAP_OPT_ON)) {

            connection->AutoReconnect = TRUE;
            connection->UserAutoRecChoice = TRUE;

        } else if (value == PtrToUlong(LDAP_OPT_OFF)) {

            connection->AutoReconnect = FALSE;
            connection->UserAutoRecChoice = FALSE;

        } else {

            err = LDAP_PARAM_ERROR;
        }
        break;

    case LDAP_OPT_ROOTDSE_CACHE:
        
        value = RealValue(invalue);

        if (value == PtrToUlong(LDAP_OPT_ON)) {

            DisableRootDSECache = FALSE;

        } else if (value == PtrToUlong(LDAP_OPT_OFF)) {

            DisableRootDSECache = TRUE;

        } else {

            err = LDAP_PARAM_ERROR;
        }
        
        break;


    case LDAP_OPT_TCP_KEEPALIVE:
    
        value = RealValue(invalue);

        if (value == PtrToUlong(LDAP_OPT_ON)) {

            connection->UseTCPKeepAlives = TRUE;

        } else if (value == PtrToUlong(LDAP_OPT_OFF)) {

            connection->UseTCPKeepAlives = FALSE;

        } else {

            err = LDAP_PARAM_ERROR;
        }
        
        break;
        
    default:

        err = LDAP_PARAM_ERROR;
    }

    return err;
}

// getset.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\globals.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    globals.h  global data for LDAP client DLL

Abstract:

   This module contains data declarations necessary for LDAP client DLL.

Author:

    Andy Herron    (andyhe)        08-May-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

extern LIST_ENTRY GlobalListActiveConnections;
extern LIST_ENTRY GlobalListWaiters;
extern LIST_ENTRY GlobalListRequests;
extern CRITICAL_SECTION RequestListLock;
extern CRITICAL_SECTION ConnectionListLock;
extern CRITICAL_SECTION LoadLibLock;
extern CRITICAL_SECTION CacheLock;
extern CRITICAL_SECTION SelectLock1;
extern CRITICAL_SECTION SelectLock2;
extern HANDLE     LdapHeap;
extern LONG      GlobalConnectionCount;
extern LONG      GlobalRequestCount;
extern LONG      GlobalWaiterCount;
extern LONG      GlobalMessageNumber;
extern BOOLEAN   MessageNumberHasWrapped;
extern BOOLEAN   GlobalWinsock11;
extern BOOLEAN   GlobalWinNT;
extern BOOLEAN GlobalLdapShuttingDown;
extern DWORD  GlobalReceiveHandlerThread;
extern DWORD  GlobalDrainWinsockThread;
extern HANDLE GlobalLdapShutdownEvent;
extern HINSTANCE GlobalLdapDllInstance;
extern BOOLEAN   GlobalWin9x;
extern HINSTANCE SecurityLibraryHandle;
extern HINSTANCE SslLibraryHandle;
extern HINSTANCE NetApi32LibraryHandle;
extern HINSTANCE AdvApi32LibraryHandle;
extern HINSTANCE NTDSLibraryHandle;
extern HINSTANCE USER32LibraryHandle;
extern LONG GlobalCountOfOpenRequests;
extern ULONG GlobalWaitSecondsForSelect;
extern ULONG GlobalLdapPingLimit;
extern ULONG GlobalPingWaitTime;
extern ULONG GlobalRequestResendLimit;
extern UCHAR GlobalSeed;
extern BOOLEAN PopupRegKeyFound;
extern BOOLEAN DisableRootDSECache;
extern BOOLEAN GlobalUseScrambling;
extern LIST_ENTRY GlobalPerThreadList;
extern CRITICAL_SECTION PerThreadListLock;
extern DWORD GlobalIntegrityDefault;

//
// The GlobalPerThreadList is protected by the PerThreadListLock.
// You hold this lock when navigating down the list (to find
// the THREAD_ENTRY for your thread) and when navigating
// across the per-thread entry to find the entry for your connection.
// Once you get the ERROR_ENTRY or LDAP_ATTR_NAME_THREAD_STORAGE for
// your connection, you don't need to hold it.  Since the entries
// are per-thread, per-connection, there are only 2 ways something
// could come along and alter your entry out from under you:
//   (1) Something else running on the same thread.  This can't happen
//       because 2 things can't run on the same thread at the same time.
//
//   (2) The connection ref count being decreased to 0 by another thread
//       and the connection being destroyed (DereferenceLdapConnection2).
//       But as long as you're in code that holds a ref on the connection,
//       this can't happen.
//
// So you need to hold the lock while navigating the lists, to protect
// against the _lists_ changing due to thread attach/detach or a connection
// being destoryed, but you don't have to protect against your _entry_
// changing.
//

#define LDAP_BIND_TIME_LIMIT_DEFAULT  (30*1000)
#define LDAP_SSL_NEGOTIATE_TIME_DEFAULT 30
#define LDAP_TIME_LIMIT_DEFAULT 0
#define CLDAP_DEFAULT_RETRY_COUNT 4
#define CLDAP_DEFAULT_TIMEOUT_COUNT 3
#define LDAP_REF_DEFAULT_HOP_LIMIT 32
#define LDAP_SERVER_PORT 389
#define LDAP_SERVER_PORT_SSL 636

#define GETHOSTBYNAME_RETRIES 3
#define GETHOSTBYADDR_RETRIES 3

#define INITIAL_MAX_RECEIVE_BUFFER 4096  // increased to handle bigger UDP packets
#define INITIAL_HEAP (16*1024)

#define LDAP_MAX_WAIT_TIME INFINITE
#define LDAP_ERROR_STR_LENGTH 100
#define LDAP_MAX_ERROR_STRINGS (LDAP_REFERRAL_LIMIT_EXCEEDED+1)

#define MAX_ATTRIBUTE_NAME_LENGTH 800

//
//  The following Authentication methods are defined for Microsoft Normandy
//  Compatibility.  Send a bind request with auth method of BIND_SSPI_NEGOTIATE
//  and null for user name and credentials and we'll negotiate common SSPI
//  providers with the server.
//

#define BIND_SSPI_PACKAGEREQ            0x89    // context specific + primitive
#define BIND_SSPI_NEGOTIATE             0x8a    // context specific + primitive
#define BIND_SSPI_RESPONSE              0x8b    // context specific + primitive

extern WCHAR LdapErrorStringsW[LDAP_MAX_ERROR_STRINGS][LDAP_ERROR_STR_LENGTH];
extern CHAR LdapErrorStrings[LDAP_MAX_ERROR_STRINGS][LDAP_ERROR_STR_LENGTH];

//
//  Security support
//

extern ULONG   NumberSecurityPackagesInstalled;
extern ULONG   NumberSslPackagesInstalled;
extern PSecurityFunctionTableW SspiFunctionTableW;
extern PSecurityFunctionTableW SslFunctionTableW;
extern PSecurityFunctionTableA SspiFunctionTableA;
extern PSecurityFunctionTableA SslFunctionTableA;
extern PSecPkgInfoW SslPackagesInstalled;
extern PSecPkgInfoW SecurityPackagesInstalled;
extern PSecPkgInfoW SspiPackageNegotiate;
extern PSecPkgInfoW SspiPackageKerberos;
extern PSecPkgInfoW SspiPackageSslPct;
extern PSecPkgInfoW SspiPackageSicily;
extern PSecPkgInfoW SspiPackageNtlm;
extern PSecPkgInfoW SspiPackageDpa;
extern PSecPkgInfoW SspiPackageDigest;
extern ULONG SspiMaxTokenSize;

//
//  This socket is used to wake up our thread in select to come and reread
//  the list of handles to wait on.
//

extern SOCKET LdapGlobalWakeupSelectHandle;
extern BOOLEAN InsideSelect;


extern DWORD GlobalTlsLastErrorIndex;

#define LANG_UNICODE    0
#define LANG_ACP        1
#define LANG_UTF8       2

//
//  Keep alive logic defaults/min/max
//
//  The current default/min/max for these values are as follows :
//
//  PING_KEEP_ALIVE :  120/5/maxInt  seconds (may also be zero)
//  PING_WAIT_TIME  :  2000/10/60000 milliseconds (may also be zero)
//  PING_LIMIT      :  4/0/maxInt

#define LDAP_PING_KEEP_ALIVE_DEF  120
#define LDAP_PING_KEEP_ALIVE_MIN  5
#define LDAP_PING_KEEP_ALIVE_MAX  ((ULONG) -1)

#define LDAP_PING_WAIT_TIME_DEF 2000
#define LDAP_PING_WAIT_TIME_MIN 10
#define LDAP_PING_WAIT_TIME_MAX 60000

#define LDAP_PING_LIMIT_DEF 4
#define LDAP_PING_LIMIT_MIN 1
#define LDAP_PING_LIMIT_MAX ((ULONG) -1)

#define LDAP_REQUEST_RESEND_LIMIT_DEF 20

// globals.h eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\ldapstr.h ===
#define WINLDAP_BASE_MSG                            1000

#define WINLDAP_RC_SUCCESS                          (WINLDAP_BASE_MSG+0x00)
#define WINLDAP_RC_OPERATIONS_ERROR                 (WINLDAP_BASE_MSG+0x01)
#define WINLDAP_RC_PROTOCOL_ERROR                   (WINLDAP_BASE_MSG+0x02)
#define WINLDAP_RC_TIMELIMIT_EXCEEDED               (WINLDAP_BASE_MSG+0x03)
#define WINLDAP_RC_SIZELIMIT_EXCEEDED               (WINLDAP_BASE_MSG+0x04)
#define WINLDAP_RC_COMPARE_FALSE                    (WINLDAP_BASE_MSG+0x05)
#define WINLDAP_RC_COMPARE_TRUE                     (WINLDAP_BASE_MSG+0x06)
#define WINLDAP_RC_AUTH_METHOD_NOT_SUPPORTED        (WINLDAP_BASE_MSG+0x07)
#define WINLDAP_RC_STRONG_AUTH_REQUIRED             (WINLDAP_BASE_MSG+0x08)
#define WINLDAP_RC_REFERRAL_V2                      (WINLDAP_BASE_MSG+0x09)
#define WINLDAP_RC_REFERRAL                         (WINLDAP_BASE_MSG+0x0a)
#define WINLDAP_RC_ADMIN_LIMIT_EXCEEDED             (WINLDAP_BASE_MSG+0x0b)
#define WINLDAP_RC_UNAVAILABLE_CRIT_EXTENSION       (WINLDAP_BASE_MSG+0x0c)
#define WINLDAP_RC_CONFIDENTIALITY_REQUIRED         (WINLDAP_BASE_MSG+0x0d)
#define WINLDAP_RC_NO_SUCH_ATTRIBUTE                (WINLDAP_BASE_MSG+0x10)
#define WINLDAP_RC_UNDEFINED_TYPE                   (WINLDAP_BASE_MSG+0x11)
#define WINLDAP_RC_INAPPROPRIATE_MATCHING           (WINLDAP_BASE_MSG+0x12)
#define WINLDAP_RC_CONSTRAINT_VIOLATION             (WINLDAP_BASE_MSG+0x13)
#define WINLDAP_RC_ATTRIBUTE_OR_VALUE_EXISTS        (WINLDAP_BASE_MSG+0x14)
#define WINLDAP_RC_INVALID_SYNTAX                   (WINLDAP_BASE_MSG+0x15)
#define WINLDAP_RC_NO_SUCH_OBJECT                   (WINLDAP_BASE_MSG+0x20)
#define WINLDAP_RC_ALIAS_PROBLEM                    (WINLDAP_BASE_MSG+0x21)
#define WINLDAP_RC_INVALID_DN_SYNTAX                (WINLDAP_BASE_MSG+0x22)
#define WINLDAP_RC_IS_LEAF                          (WINLDAP_BASE_MSG+0x23)
#define WINLDAP_RC_ALIAS_DEREF_PROBLEM              (WINLDAP_BASE_MSG+0x24)
#define WINLDAP_RC_INAPPROPRIATE_AUTH               (WINLDAP_BASE_MSG+0x30)
#define WINLDAP_RC_INVALID_CREDENTIALS              (WINLDAP_BASE_MSG+0x31)
#define WINLDAP_RC_INSUFFICIENT_RIGHTS              (WINLDAP_BASE_MSG+0x32)
#define WINLDAP_RC_BUSY                             (WINLDAP_BASE_MSG+0x33)
#define WINLDAP_RC_UNAVAILABLE                      (WINLDAP_BASE_MSG+0x34)
#define WINLDAP_RC_UNWILLING_TO_PERFORM             (WINLDAP_BASE_MSG+0x35)
#define WINLDAP_RC_LOOP_DETECT                      (WINLDAP_BASE_MSG+0x36)
#define WINLDAP_RC_SORT_CONTROL_MISSING             (WINLDAP_BASE_MSG+0x3C)
#define WINLDAP_RC_INDEX_RANGE_ERROR                (WINLDAP_BASE_MSG+0x3D)
#define WINLDAP_RC_NAMING_VIOLATION                 (WINLDAP_BASE_MSG+0x40)
#define WINLDAP_RC_OBJECT_CLASS_VIOLATION           (WINLDAP_BASE_MSG+0x41)
#define WINLDAP_RC_NOT_ALLOWED_ON_NONLEAF           (WINLDAP_BASE_MSG+0x42)
#define WINLDAP_RC_NOT_ALLOWED_ON_RDN               (WINLDAP_BASE_MSG+0x43)
#define WINLDAP_RC_ALREADY_EXISTS                   (WINLDAP_BASE_MSG+0x44)
#define WINLDAP_RC_NO_OBJECT_CLASS_MODS             (WINLDAP_BASE_MSG+0x45)
#define WINLDAP_RC_RESULTS_TOO_LARGE                (WINLDAP_BASE_MSG+0x46)
#define WINLDAP_RC_AFFECTS_MULTIPLE_DSAS            (WINLDAP_BASE_MSG+0x47)
#define WINLDAP_RC_OTHER                            (WINLDAP_BASE_MSG+0x50)
#define WINLDAP_RC_SERVER_DOWN                      (WINLDAP_BASE_MSG+0x51)
#define WINLDAP_RC_LOCAL_ERROR                      (WINLDAP_BASE_MSG+0x52)
#define WINLDAP_RC_ENCODING_ERROR                   (WINLDAP_BASE_MSG+0x53)
#define WINLDAP_RC_DECODING_ERROR                   (WINLDAP_BASE_MSG+0x54)
#define WINLDAP_RC_TIMEOUT                          (WINLDAP_BASE_MSG+0x55)
#define WINLDAP_RC_AUTH_UNKNOWN                     (WINLDAP_BASE_MSG+0x56)
#define WINLDAP_RC_FILTER_ERROR                     (WINLDAP_BASE_MSG+0x57)
#define WINLDAP_RC_USER_CANCELLED                   (WINLDAP_BASE_MSG+0x58)
#define WINLDAP_RC_PARAM_ERROR                      (WINLDAP_BASE_MSG+0x59)
#define WINLDAP_RC_NO_MEMORY                        (WINLDAP_BASE_MSG+0x5a)
#define WINLDAP_RC_CONNECT_ERROR                    (WINLDAP_BASE_MSG+0x5b)
#define WINLDAP_RC_NOT_SUPPORTED                    (WINLDAP_BASE_MSG+0x5c)
#define WINLDAP_RC_CONTROL_NOT_FOUND                (WINLDAP_BASE_MSG+0x5d)
#define WINLDAP_RC_NO_RESULTS_RETURNED              (WINLDAP_BASE_MSG+0x5e)
#define WINLDAP_RC_MORE_RESULTS_TO_RETURN           (WINLDAP_BASE_MSG+0x5f)
#define WINLDAP_RC_CLIENT_LOOP                      (WINLDAP_BASE_MSG+0x60)
#define WINLDAP_RC_REFERRAL_LIMIT_EXCEEDED          (WINLDAP_BASE_MSG+0x61)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\ldapber.cxx ===
/*--------------------------------------------------------------------------
    ldapber.cxx

        This module contains the implementation for the LDAP Basic Encoding
        Rules (BER) class.  It is intended to be built for both client and
        server.

    Copyright (C) 1993 Microsoft Corporation
    All rights reserved.

    Authors:
        robertc     Rob Carney

    History:
        04-17-96    robertc     Created.
  --------------------------------------------------------------------------*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

#define MIN_LDAP_MSG_SIZE 6


VOID *CLdapBer::operator new (
    size_t cSize
    )
{
    return ldapMalloc( (DWORD) cSize, LDAP_LDAP_CLASS_SIGNATURE );
}

VOID CLdapBer::operator delete (
    VOID *pInstance
    )
{
    ldapFree( pInstance, LDAP_LDAP_CLASS_SIGNATURE );
    return;
}

//
// CLdapBer Implementation
//
CLdapBer::CLdapBer (
    ULONG  LdapVersion
    )
{
    m_cbData    = 0;
    m_cbDataMax = 0;
    m_pbData    = NULL;
    m_iCurrPos  = 0;
    m_cbSeq     = 0;
    m_iSeqStart = 0;
    m_bytesReceived = 0;
    m_dnOffset  = 0;
    m_isCopy = FALSE;
    m_OverridingTag = 0;

    if (LdapVersion == LDAP_VERSION2) {

        m_CodePage = CP_ACP;

    } else {

        m_CodePage = CP_UTF8;
    }

    m_iCurrSeqStack = 0;
}


CLdapBer::~CLdapBer()
{
    Reset();

    if (m_pbData && ( ! m_isCopy)) {
        ldapFree(m_pbData, LDAP_LBER_SIGNATURE );
    }
    m_pbData = NULL;
    m_cbDataMax = 0;
}

ULONG
CLdapBer::CopyExistingBERStructure ( CLdapBer *lber )
//
//  This copies the main BER structure but doesn't copy the data since
//  we can share the buffer.
//
{
    m_cbData    = lber->m_cbData;
    m_cbDataMax = lber->m_cbDataMax;
    m_pbData    = lber->m_pbData;
    m_iCurrPos  = 0;
    m_cbSeq     = 0;
    m_iSeqStart = 0;
    m_bytesReceived = lber->m_bytesReceived;
    m_dnOffset  = lber->m_dnOffset;
    m_isCopy = TRUE;

    m_iCurrSeqStack = 0;

    return NOERROR;
}



/*!-------------------------------------------------------------------------
    CLdapBer::Reset
        Resets the class and frees any associated memory.
  ------------------------------------------------------------------------*/
void CLdapBer::Reset(BOOLEAN FullReset /* =FALSE */)
{
    if (FullReset == TRUE) {

        m_dnOffset  = 0;
        m_cbData    = 0;
        m_bytesReceived = 0;
    }
    m_iCurrPos  = 0;
    m_cbSeq     = 0;
    m_iSeqStart = 0;

    m_iCurrSeqStack = 0;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrLoadBer
        This routine loads the BER class from an input source data buffer
        that was received from the server.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrLoadBer(    const BYTE *pbSrc,
                                ULONG cbSrc,
                                ULONG *BytesTaken,
                                BOOLEAN HaveWholeMessage,
                                BOOLEAN IgnoreTag /*=FALSE*/
                                )
{
    ULONG hr;
    ULONG   bytesToTake = cbSrc;
    ULONG   messageLength;
    ULONG   bytesToAlloc;

    Reset(TRUE);

    //
    //  We may not need the entire buffer... check the first couple of
    //  bytes to get the total length of the message.
    //

    if (cbSrc < MIN_LDAP_MSG_SIZE && (HaveWholeMessage== FALSE)) {

        //
        //  this is just a partial message... copy the whole thing off but
        //  leave length indeterminate.
        //

        messageLength = 0;
        bytesToAlloc = MIN_LDAP_MSG_SIZE;

    } else {

        //
        //  we know that the message is formed as follows :
        //      BER_SEQUENCE    length 1  0x30
        //  followed by ASN.1 encoding of message length
        //

        if ((!IgnoreTag) && (*pbSrc != BER_SEQUENCE)) {

            return LDAP_DECODING_ERROR;
        }

        hr = Asn1GetPacketLength( (PUCHAR) pbSrc, &messageLength );
        if (hr != NOERROR) {
            return hr;
        }

        if (messageLength < bytesToTake) {

            bytesToTake = messageLength;
        }

        bytesToAlloc = 0;
    }

    m_cbData = m_cbSeq = messageLength;

    hr = HrEnsureBuffer( bytesToAlloc, TRUE); // length is picked up in m_cbData
    if (hr != 0) {
        return hr;
    }

    CopyMemory(m_pbData, pbSrc, bytesToTake);

    *BytesTaken = m_bytesReceived = bytesToTake;

    return NOERROR;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrLoadMoreBer
        This routine loads the BER class from an input source data buffer
        that was received from the server.  It loads subsequent packets
        into the buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrLoadMoreBer(const BYTE *pbSrc, ULONG cbSrc, ULONG *BytesTaken)
{
    ULONG hr;
    ULONG   bytesToTake;

    if (m_cbData == 0) {

        ULONG   messageLength;

        //
        //  we don't know the total message length yet.  So let's copy enough
        //  of the data to be able to get the packet length.
        //

        if ( m_bytesReceived < MIN_LDAP_MSG_SIZE ) {

            bytesToTake = MIN_LDAP_MSG_SIZE - m_bytesReceived;

            if (cbSrc < bytesToTake) {

                //
                //  we're receiving the data a few bytes at
                //  a time... oh well, we live with it.  Just copy the data
                //  into the buffer and we'll pick up the length next time.
                //

                CopyMemory(m_pbData+m_bytesReceived, pbSrc, cbSrc);

                m_bytesReceived += cbSrc;
                *BytesTaken = cbSrc;
                return NOERROR;
            }

            //
            //  without updating any counts, we copy over enough data to
            //  determine the length of the packet.  We update the received
            //  data count below when we copy it over again.
            //

            CopyMemory(m_pbData+m_bytesReceived, pbSrc, bytesToTake);
        }

        //
        //  we know that the message is formed as follows :
        //      BER_SEQUENCE    length 1  0x30
        //  followed by ASN.1 encoding of message length
        //

        if (*m_pbData != BER_SEQUENCE) {

            return LDAP_DECODING_ERROR;
        }

        hr = Asn1GetPacketLength( (PUCHAR) m_pbData, &messageLength );
        if (hr != NOERROR) {
            return hr;
        }

        m_cbData = m_cbSeq = messageLength;
    }

    bytesToTake = m_cbData - m_bytesReceived;

    //
    //  if we don't have enough for the remainder of the message, take all
    //  of what was passed in.
    //

    if (cbSrc < bytesToTake) {

        bytesToTake = cbSrc;
    }

    hr = HrEnsureBuffer( 0, TRUE);      // length is in m_cbData
    if (hr != 0) {
        return hr;
    }

    CopyMemory(m_pbData+m_bytesReceived, pbSrc, bytesToTake);

    m_bytesReceived += bytesToTake;
    *BytesTaken = bytesToTake;

    return NOERROR;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrStartReadSequence
        Start a sequence for reading.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrStartReadSequence(ULONG ulTag/*=BER_SEQUENCE*/, BOOLEAN IgnoreTag/*=FALSE*/) 
{
    ULONG   hr;
    ULONG   iPos, cbLength;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrStartReadSequence ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    if ( !IgnoreTag ) {
        
        if ((ULONG)m_pbData[m_iCurrPos] != ulTag)
            {
                IF_DEBUG(BER) {
                    LdapPrint2( "HrStartReadSequence expected tag of 0x%x, received 0x%x.\n",
                                ulTag, (ULONG)m_pbData[m_iCurrPos] );
                }
                
                return E_INVALIDARG;
            }
        
    }
    
    m_iCurrPos++;           // Skip over the tag.

    GetCbLength(&cbLength); // Get the # bytes in the length field.

    hr = HrPushSeqStack(m_iCurrPos, cbLength, m_iSeqStart, m_cbSeq);

    if (hr == NOERROR) {

        // Get the length of the sequence.
        hr = HrGetLength(&m_cbSeq);
        if (hr != 0) {

            HrPopSeqStack(&iPos, &cbLength, &m_iSeqStart, &m_cbSeq);

        } else {

            m_iSeqStart = m_iCurrPos;   // Set to the first position in the sequence.
        }
    }

    if (m_iCurrPos > m_cbData)
    {
//      ASSERT(m_iCurrPos <= m_cbData);
        hr = E_INVALIDARG;
    }

    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrEndReadSequence
        Ends a read sequence and restores the current sequence counters.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrEndReadSequence()
{
    ULONG       cbSeq;
    ULONG       iPos, cbLength;
    ULONG     hr;

    hr = HrPopSeqStack(&m_iCurrPos, &cbLength, &m_iSeqStart, &m_cbSeq);

    // Now position the current position to the end of the sequence.
    // m_iCurrPos is now pointing to the length field of the sequence.
    iPos = m_iCurrPos;

    if (hr == NOERROR) {

        hr = HrGetLength(&cbSeq);
        if (hr == NOERROR) {

            // Set the current position to the end of the sequence.
            m_iCurrPos = iPos + cbSeq + cbLength;
            if (m_iCurrPos > m_cbData)
                hr = E_INVALIDARG;
            }
        }

    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrStartWriteSequence
        Start a sequence for writing.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrStartWriteSequence(ULONG ulTag/*=BER_SEQUENCE*/)
{
    ULONG hr;
    ULONG   cbLength = 5;   // Defaults to 4 byte lengths

    if (m_OverridingTag) {

       ulTag = m_OverridingTag;
       m_OverridingTag = 0;
    }

    hr = HrEnsureBuffer(cbLength + 1);

    if (hr != 0) {
        return hr;
    }

    m_pbData[m_iCurrPos++] = (BYTE)ulTag;

    hr = HrPushSeqStack(m_iCurrPos, cbLength, m_iSeqStart, m_cbSeq);

    m_iCurrPos += cbLength; // Skip over length
    m_cbData = m_iCurrPos;  // update total length of data

    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrAddTag
        Add a tag... used for unbind
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrAddTag(ULONG ulTag)
{
    ULONG hr;

    hr = HrEnsureBuffer(2);

    if (hr != 0) {
        return hr;
    }

    m_pbData[m_iCurrPos++] = (BYTE)ulTag;
    m_pbData[m_iCurrPos++] = '\0';
    m_cbData = m_iCurrPos;

    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrEndWriteSequence
        Ends a write sequence, by putting the sequence length field in.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrEndWriteSequence()
{
    ULONG     hr;
    ULONG       cbSeq;
    ULONG       iPos, iPosSave, cbLength;

    if (m_OverridingTag) {
       
       //
       // We can't override the End sequence. This has to be an error
       //

       return E_INVALIDARG;
    }

    hr = HrPopSeqStack(&iPos, &cbLength, &m_iSeqStart, &m_cbSeq);

    if (hr == NOERROR) {

        // Get the length of the current sequence.
        cbSeq = m_iCurrPos - iPos - cbLength;

        // Save & set the current position.
        iPosSave = m_iCurrPos;
        m_iCurrPos = iPos;

        hr = HrSetLength(cbSeq, cbLength);
        m_iCurrPos = iPosSave;
    }

    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrPushSeqStack
        Pushes the current value on the sequence stack.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrPushSeqStack(ULONG iPos, ULONG cbLength, ULONG iParentSeqStart, ULONG cbParentSeq)
{

    ASSERT(m_iCurrSeqStack < MAX_BER_STACK);
    if (m_iCurrSeqStack >= MAX_BER_STACK)
        return E_OUTOFMEMORY;

    m_rgiSeqStack[m_iCurrSeqStack].iPos     = iPos;
    m_rgiSeqStack[m_iCurrSeqStack].cbLength = cbLength;
    m_rgiSeqStack[m_iCurrSeqStack].iParentSeqStart = iParentSeqStart;
    m_rgiSeqStack[m_iCurrSeqStack].cbParentSeq     = cbParentSeq;
    m_iCurrSeqStack++;

    return NOERROR;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrPopSeqStack
        Ends a read sequence.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrPopSeqStack(ULONG *piPos, ULONG *pcbLength, ULONG *piParentSeqStart, ULONG *pcbParentSeq)
{
    if (m_iCurrSeqStack == 0)
    {
        ASSERT(m_iCurrSeqStack != 0);
        return E_INVALIDARG;
    }

    --m_iCurrSeqStack;
    *piPos     = m_rgiSeqStack[m_iCurrSeqStack].iPos;
    *pcbLength = m_rgiSeqStack[m_iCurrSeqStack].cbLength;
    *piParentSeqStart = m_rgiSeqStack[m_iCurrSeqStack].iParentSeqStart;
    *pcbParentSeq     = m_rgiSeqStack[m_iCurrSeqStack].cbParentSeq;

    return NOERROR;
}



/*!-------------------------------------------------------------------------
    CLdapBer::HrSkipElement
        This routine skips over the current BER tag and value.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrSkipElement()
{
    //
    //  an element is made up of a tag, a length, and a value.  we'll
    //  skip the tag, find out what the length is, and then skip the value.
    //

    ULONG hr;
    ULONG   cb;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrSkipElement ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    m_iCurrPos++;       // skip tag

    hr = HrGetLength(&cb);

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData)) {

        m_iCurrPos += cb;
    }

    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrSkipTag
        Skips over the current tag.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrSkipTag()
{
    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrSkipTag ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    m_iCurrPos++;

    return NOERROR;
}



/*!-------------------------------------------------------------------------
    CLdapBer::HrPeekTag
        This routine gets the current tag, but doesn't increment the
        current position.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrPeekTag(ULONG *pulTag)
{
    ULONG   iPos;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrPeekTag ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    iPos = m_iCurrPos;

    *pulTag = (ULONG)m_pbData[iPos];

    return NOERROR;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrGetValue
        This routine gets an integer value from the current BER entry.  The
        default tag is an integer, but can Tagged with a different value
        via ulTag.
        Returns: NOERROR, E_INVALIDARG, E_OUTOFMEMORY
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrGetValue(LONG *pi, ULONG ulTag/*=BER_INTEGER*/, BOOLEAN IgnoreTag/*=FALSE*/) 
{
    ULONG hr;
    ULONG   cb;
    ULONG   ul;
    ULONG currentOffset = m_iCurrPos;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    ul = (ULONG)m_pbData[m_iCurrPos]; // TAG

    if (!IgnoreTag && (ul != ulTag)) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue expected tag of 0x%x, received 0x%x.\n",
                        ulTag, ul );
        }
        return E_INVALIDARG;
    }

    m_iCurrPos++;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        m_iCurrPos = currentOffset;
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb);

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData))
    {
        hr = GetInt(m_pbData + m_iCurrPos, cb, pi);
        m_iCurrPos += cb;
    }

    if (hr != NOERROR) {
        m_iCurrPos = currentOffset;
    }
    return hr;
}


ULONG CLdapBer::HrGetValueWithAlloc(PCHAR *szValue, BOOLEAN IgnoreTag/*=FALSE*/)
{
    ULONG hr;
    ULONG   cb;
    PCHAR   buffer;
    ULONG currentOffset = m_iCurrPos;

    *szValue = NULL;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValueWithAlloc ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    if ( !IgnoreTag ) {
        
        if (m_pbData[m_iCurrPos] != BER_OCTETSTRING) {
            
            IF_DEBUG(BER) {
                LdapPrint1( "HrGetValueWithAlloc got tag of 0x%x.\n",
                            m_pbData[m_iCurrPos] );
            }
            return LDAP_DECODING_ERROR;
        }
        
    }

    m_iCurrPos++;          // skip tag

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValueWithAlloc ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        m_iCurrPos = currentOffset;
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb);

    if ((hr == NOERROR) && (cb == 0) && (m_iCurrPos < m_cbData)) {
        // zero-length string
        *szValue = (PCHAR) ldapMalloc( 1, LDAP_VALUE_SIGNATURE );
        if (!(*szValue)) {
            return LDAP_NO_MEMORY;
        }

        (*szValue)[0] = '\0';
        return NOERROR;
    }

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData)) {

        //
        //  convert from UTF-8 to ANSI if required...  unfortunately there's
        //  no real quick way.
        //

        if (m_CodePage == CP_UTF8) {

            PWCHAR uniString = NULL;
            buffer = NULL;

            hr = ToUnicodeWithAlloc( (PCHAR) (m_pbData + m_iCurrPos),
                                     cb,
                                     &uniString,
                                     LDAP_UNICODE_SIGNATURE,
                                     LANG_UTF8 );

            if (hr == NOERROR) {

                hr = FromUnicodeWithAlloc(  uniString,
                                            &buffer,
                                            LDAP_VALUE_SIGNATURE,
                                            LANG_ACP
                                            );
            }
            ldapFree( uniString, LDAP_UNICODE_SIGNATURE );

            if (buffer == NULL) {

                hr = LDAP_NO_MEMORY;

            } else {

                *szValue = buffer;
                m_iCurrPos += cb;
            }
        } else {

            buffer = (PCHAR) ldapMalloc( cb + 1, LDAP_VALUE_SIGNATURE );

            if (buffer == NULL) {

                hr = LDAP_NO_MEMORY;

            } else {

                // Get the string.
                CopyMemory(buffer, m_pbData + m_iCurrPos, cb);
                *(buffer+cb) = '\0';
                *szValue = buffer;
                m_iCurrPos += cb;
            }
        }
    }

    if (hr != NOERROR) {
        m_iCurrPos = currentOffset;
    }
    return hr;
}

ULONG CLdapBer::HrGetValueWithAlloc(PWCHAR *szValue, BOOLEAN IgnoreTag/*=FALSE*/)
{
    ULONG hr;
    ULONG   cb;
    PWCHAR   buffer;
    ULONG currentOffset = m_iCurrPos;
    int err, required;

    *szValue = NULL;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValueWithAlloc ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    if ( !IgnoreTag ) {
        
        if (m_pbData[m_iCurrPos] != BER_OCTETSTRING) {
            
            IF_DEBUG(BER) {
                LdapPrint1( "HrGetValueWithAlloc got tag of 0x%x.\n",
                            m_pbData[m_iCurrPos] );
            }
            return LDAP_DECODING_ERROR;
        }

    }
        
    m_iCurrPos++;          // skip tag

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValueWithAlloc ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        m_iCurrPos = currentOffset;
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb);

    if ((hr == NOERROR) && (cb == 0) && (m_iCurrPos < m_cbData)) {
        // zero-length string
        *szValue = (PWCHAR) ldapMalloc( 1*sizeof(WCHAR), LDAP_VALUE_SIGNATURE );
        if (!(*szValue)) {
            return LDAP_NO_MEMORY;
        }

        (*szValue)[0] = L'\0';
        return NOERROR;
    }

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData)) {

        if (m_CodePage == CP_UTF8) {

            required = LdapUTF8ToUnicode( (const char *) (m_pbData + m_iCurrPos),
                                       cb,
                                       NULL,
                                       0 );

        } else {

            required = MultiByteToWideChar( m_CodePage,
                                            0,
                                            (const char *) (m_pbData + m_iCurrPos),
                                            cb,
                                            NULL,
                                            0 );
        }
        
        if ((required == 0) && (err = GetLastError())) {

            IF_DEBUG(BER) {
                LdapPrint1( "HrGetValueWithAlloc received error of 0x%x from MultiByteToWideChar.\n",
                                err );
            }

            switch (err) {
            case ERROR_INSUFFICIENT_BUFFER:
                hr = E_INVALIDARG;
                break;
            case ERROR_NO_UNICODE_TRANSLATION:
                hr = LDAP_DECODING_ERROR;
                break;
            