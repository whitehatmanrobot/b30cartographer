gn countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************GP class for the HAL******************************\
*                                                                           *
* Module: CHalExtendedProc.cpp                                                *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
extern "C"
{
#include <nvarm.h>
#include <AudioHw.h>
#include <nv_papu.h>
#include <nv32.h>
#include <aos.h>
};

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalExtendedProc.h"

CHalExtendedProc::CHalExtendedProc(CHalBase *pHal) : CObjBase(pHal)
{
    // keep the internal count ahead of the external count by this much
    m_CommandQ.Size = 4096;
}

RM_STATUS
CHalExtendedProc::Allocate(VOID *pParam)
{
	APU_EP_CREATE *pArg = (APU_EP_CREATE *)pParam;
	RM_STATUS rmStatus = RM_OK;
    
    do
    {
        rmStatus = GetCaps(pArg);
        if (rmStatus != RM_OK)
            break;

        rmStatus = AllocateMemory(pArg);
        if (rmStatus != RM_OK)
            break;

        InitializeHardware();

    } while (FALSE);

	return rmStatus;
}

RM_STATUS
CHalExtendedProc::Free(VOID *pParam)
{
    FreeMemory();
    return RM_OK;
}

RM_STATUS
CHalExtendedProc::GetCaps(APU_EP_CREATE *pArg)
{
    // have no idea what regs to check against

    return RM_OK;
}

RM_STATUS
CHalExtendedProc::AllocateMemory(APU_EP_CREATE *pArg)
{
    // what about notifier memory for both EP & GP ???
    // vik - todo
    m_SgeOut.Size = pArg->uSGEOutCount * NV_PSGE_SIZE;
    m_Scratch.Size = pArg->uScratch * NV_PSGE_SIZE;

	RM_STATUS rmStatus =  aosAllocateMem(m_SgeOut.Size,
						                ALIGN_16K,
						                &m_SgeOut.pLinAddr,
						                &m_SgeOut.pPhysAddr);

    if (rmStatus == RM_OK)
    {
        // allocate memory for the command Q
        rmStatus =  aosAllocateMem(m_CommandQ.Size,
						        ALIGN_16K,
						        &m_CommandQ.pLinAddr,
						        &m_CommandQ.pPhysAddr);
    }
    
    // allocate memory for 1PRD to point to the 4K command Q

    if (rmStatus == RM_OK)
    {
        // allocate memory scratch area
        rmStatus =  aosAllocateMem(m_Scratch.Size,
						        ALIGN_16K,
						        &m_Scratch.pLinAddr,
						        &m_Scratch.pPhysAddr);
    }

    return rmStatus;
}

VOID
CHalExtendedProc::FreeMemory()
{
	aosFreeMem(m_SgeOut.pLinAddr);
	aosFreeMem(m_CommandQ.pLinAddr);
	aosFreeMem(m_Scratch.pLinAddr);
}

VOID
CHalExtendedProc::InitializeHardware()
{
    // clear any pending interrupts! - todo cleanup
    RegWrite(NV_PAPU_EPISTS, (U032)0xFFFFFFFF);
    
    // output buffer PRDs
    RegWrite(NV_PAPU_EPFADDR, (U032)m_SgeOut.pPhysAddr);

    // scratch area for the eP
    RegWrite(NV_PAPU_EPSADDR, (U032)m_Scratch.pPhysAddr);

    // PRDs for the FIFO
    RegWrite(NV_PAPU_EPCADDR, (U032)m_CommandQ.pPhysAddr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\audio\CHalVoiceProc.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************VP class for the HAL******************************\
*                                                                           *
* Module: CHalVoiceProc.cpp                                                 *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <AudioHw.h>
#include <nvarm.h>
#include <nv32.h>
#include <nv_papu.h>
#include <aos.h>
};

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalVoiceProc.h"


RM_STATUS
CHalVoiceProc::Allocate(VOID *pParam)
{
	APU_AP_CREATE *pArg = (APU_AP_CREATE *)pParam;
	RM_STATUS rmStatus = RM_OK;
	
    do
    {
        rmStatus = GetCaps(pArg);
        if (rmStatus != RM_OK)
            break;

        rmStatus = AllocateMemory(pArg);
        if (rmStatus != RM_OK)
            break;

	    // this is for debug only!
        pArg->pVoiceList = (VOID_PTR)m_Voice.pLinAddr;

        InitializeHardware(pArg);

    } while (FALSE);

	return rmStatus;
}

RM_STATUS
CHalVoiceProc::Free(VOID *pParam)
{
	RM_STATUS rmStatus = RM_OK;
	
	FreeMemory();

	return rmStatus;
}

VOID
CHalVoiceProc::FreeMemory()
{
	aosFreeMem(m_Voice.pLinAddr);
	aosFreeMem(m_SgeIn.pLinAddr);
	aosFreeMem(m_SegIn.pLinAddr);
	aosFreeMem(m_HRTFTarg.pLinAddr);
	aosFreeMem(m_HRTFCurr.pLinAddr);
}

RM_STATUS
CHalVoiceProc::AllocateMemory(APU_AP_CREATE *pArg)
{
	RM_STATUS rmStatus;

    U032 uCnt;

	m_Voice.Size = pArg->uVoiceCount * NV_PAVS_SIZE;
    m_SgeIn.Size = pArg->uSGEInCount * NV_PSGE_SIZE;
    m_SegIn.Size = pArg->uSegInCount * 64 * NV_PSGE_SIZE;
    m_HRTFTarg.Size = pArg->uHRTFCount * NV_PAHRTFT_SIZE;
    m_HRTFCurr.Size = pArg->uVoice3dCount * NV_PAHRTFC_SIZE;
	
	rmStatus = aosAllocateMem(m_Voice.Size,
							ALIGN_16K,
							&m_Voice.pLinAddr,
							&m_Voice.pPhysAddr);
	if (rmStatus == RM_OK)
	{
        rmStatus = aosAllocateMem(m_SgeIn.Size,
								ALIGN_16K,
								&m_SgeIn.pLinAddr,
								&m_SgeIn.pPhysAddr);

	}
	

	if (rmStatus == RM_OK)
	{

		rmStatus = aosAllocateMem(m_SegIn.Size,
								ALIGN_16K,
								&m_SegIn.pLinAddr,
								&m_SegIn.pPhysAddr);

	}


	if (rmStatus == RM_OK)
	{

		rmStatus = aosAllocateMem(m_HRTFTarg.Size,
								ALIGN_16K,
								&m_HRTFTarg.pLinAddr,
								&m_HRTFTarg.pPhysAddr);

	}

	if (rmStatus == RM_OK)
	{
		rmStatus = aosAllocateMem(m_HRTFCurr.Size,
								ALIGN_16K,
								&m_HRTFCurr.pLinAddr,
								&m_HRTFCurr.pPhysAddr);

	}

    // initialize the voice structures
    if (rmStatus == RM_OK)
    {
        U032 uAddr;
        U016 uNxtVoice;

        for (uCnt = 0; uCnt < pArg->uVoiceCount; uCnt++) 
        {
            uAddr = U032(m_Voice.pLinAddr) + (uCnt * NV_PAVS_SIZE);

            aosZeroMemory((VOID *)uAddr, NV_PAVS_SIZE);

            uNxtVoice = (U016)REF_NUM(NV_PAVS_VOICE_TAR_PITCH_LINK_NEXT_VOICE_HANDLE, uCnt);

            MemWrite(uAddr + NV_PAVS_VOICE_TAR_PITCH_LINK, uNxtVoice);
        }
        
        aosZeroMemory(m_SgeIn.pLinAddr, m_SgeIn.Size);
        aosZeroMemory(m_SegIn.pLinAddr, m_SegIn.Size);
        
    }

	return rmStatus;
}


RM_STATUS
CHalVoiceProc::GetCaps(VOID *pParam)
{
	APU_AP_CREATE *pArg = (APU_AP_CREATE *)pParam;
	VOLU32 vTemp;

    if (pArg->uVoiceCount)
    {
	    vTemp = pArg->uVoiceCount - 1;
	    RegWrite(NV_PAPU_FEMAXV, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXV, &vTemp);
	    pArg->uVoiceCount = vTemp + 1;
    }

    if (pArg->uVoice3dCount)
    {
	    vTemp = pArg->uVoice3dCount - 1;
	    RegWrite(NV_PAPU_FEMAXTV, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXTV, &vTemp);
	    pArg->uVoice3dCount = vTemp + 1;
    }

	if (pArg->uHRTFCount)
    {
        vTemp = pArg->uHRTFCount - 1;
	    RegWrite(NV_PAPU_FEMAXHT, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXHT, &vTemp);
	    pArg->uHRTFCount = vTemp + 1;
    }


	if (pArg->uSegInCount)
    {
        vTemp = pArg->uSegInCount - 1;
	    RegWrite(NV_PAPU_FEMAXSESSL, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXSESSL, &vTemp);
	    pArg->uSegInCount = vTemp + 1;
    }

	if (pArg->uSGEInCount)
    {
        vTemp = pArg->uSGEInCount - 1;
	    RegWrite(NV_PAPU_FEMAXSESGE, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXSESGE, &vTemp);
	    pArg->uSGEInCount = vTemp + 1;
    }
    
    if (pArg->uSubmixCount)
    {
	    // submixes
        vTemp = pArg->uSubmixCount - 1;
	    RegWrite(NV_PAPU_FEMAXMB, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXMB, &vTemp);
	    pArg->uSubmixCount = vTemp + 1;
    }

	return RM_OK;
}


VOID
CHalVoiceProc::InitializeHardware(APU_AP_CREATE *pArg)
{
    // program the instance memory
    RegWrite(NV_PAPU_VPVADDR, (U032)m_Voice.pPhysAddr);
	RegWrite(NV_PAPU_VPHTADDR, (U032)m_HRTFTarg.pPhysAddr);
	RegWrite(NV_PAPU_VPHCADDR, (U032)m_HRTFCurr.pPhysAddr);
	RegWrite(NV_PAPU_VPSGEADDR, (U032)m_SgeIn.pPhysAddr);
	RegWrite(NV_PAPU_VPSSLADDR, (U032)m_SegIn.pPhysAddr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\audio\CHalMCP1.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Base class for the HAL******************************\
*                                                                           *
* Module: CHalBase.h                                                        *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CHALMCP1H_
#define _CHALMCP1H_

class CHalVoiceProc;
class CHalGlobalProc;
class CHalExtendedProc;
class CContextDma;
class CMCP1Method;
class CEPMethod;

#define MAX_CLIENTS		        8

class CHalMCP1 : public CHalBase
{
public:
	CHalMCP1(U008, HWINFO_COMMON_FIELDS *);
	~CHalMCP1();

public:
	RM_STATUS Allocate();
	RM_STATUS Free();

    RM_STATUS AddClient(VOID *pParam, U008 *pClientRef);
    RM_STATUS DeleteClient(U008 uClientRef);

    RM_STATUS AllocateContextDma(VOID *pParam);
    RM_STATUS FreeContextDma(VOID *pParam);

    RM_STATUS AllocateObject(U032 uObjectType, VOID *pParam);
    RM_STATUS FreeObject(U032 uObjectType, VOID *pParam);

	RM_STATUS InterruptService();
    
    enum E_STATE
    {
        ISO = 0,
        NON_ISO,
        // mode states
        FREE_RUN,
        // SE modes
        OFF,
        AC_SYNC,
        SW,
        // interrupts enables for SE
        INT_PANIC,
        INT_RETRIGGER,
        INT_WARN,
        // FE modes
        HALT,
        // FE controls
        LOCK,
        UNLOCK
    };

    enum INTERRUPT_STATE
    {
        ENABLE,
        DISABLE
    };

    VOID SetFrontEnd(E_STATE);
    VOID SetSetupEngine(E_STATE);
   	VOID SetInterrupts(INTERRUPT_STATE);


    CHalVoiceProc   *GetVoiceProc()     { return m_pVoiceProc; }
    CHalGlobalProc  *GetGlobalProc()    { return m_pGlobalProc; }
    CHalExtendedProc *GetExtendedProc() { return m_pExtendedProc; }

protected:
	// public objects
	CHalVoiceProc	    *m_pVoiceProc;
    CHalGlobalProc      *m_pGlobalProc;
    CHalExtendedProc    *m_pExtendedProc;

private:
	VOID OnIntrFETrap();
	BOOL GetUserMethodInfo(U032 *pMethod, U032 *pData);
	VOID WriteError(U032 uIsCurrentVoice, U008	uErrorCode);

    VOID SetSetupEngineGlobalCounts(U032 uExt, U032 uInt, U032 uDelta);
    VOID SetSetupEngineExtendedCounts(U032 uInt, U032 uDelta, U032 uStep);

    VOID CallbackClients(U032 uIntrMask);
    RM_STATUS StoreClientInfo(VOID *pFn, U032 uMask, U032 uContext);

	R_INTR	m_rInterruptMask;

    CContextDma *m_pCDma;
    CMCP1Method *m_pApMethod;
    CEPMethod   *m_pEpMethod;
    
    PNV1BA0NOTIFICATION *m_pNotify;

    MCP1_CLIENT_INFO m_ClientInfo[MAX_CLIENTS];

    MEM_DESC m_MagicWrite;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\audio\CHalMCP1.cpp ===
// cHalMCPI.cpp

extern "C"
{
#include <nv32.h>
#include <nvarm.h>
#include <AudioHw.h>
#include <nv_papu.h>
};

#include <aos.h>
// ahal should not need to be included...
// todo - have to work on the client info stuff
#include "AHal.h"

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalVoiceProc.h"
#include "CHalExtendedProc.h"
#include "CHalGlobalProc.h"
#include "CHalMCP1.h"
#include <CLinkList.h>
#include "CContextDma.h"
#include "CMCP1Method.h"
#include "CEPMethod.h"

// constructor
CHalMCP1::CHalMCP1(U008 uRevID, HWINFO_COMMON_FIELDS *pDev) : CHalBase(uRevID, pDev) 
{ 
    m_pVoiceProc = NULL;
    m_pCDma = NULL;
    m_pApMethod = NULL;
    m_pGlobalProc = NULL;
    m_pExtendedProc = NULL;
    m_pNotify = NULL;
    m_pEpMethod = NULL;
    m_MagicWrite.pLinAddr = NULL;

    // init the client callback info
    for (U032 uCnt = 0; uCnt < MAX_CLIENTS; uCnt++)
        m_ClientInfo[uCnt].pFn = NULL;
}

CHalMCP1::~CHalMCP1()
{
    if (m_pApMethod)
        delete m_pApMethod;
    
    if (m_pEpMethod)
        delete m_pEpMethod;

    if (m_pVoiceProc)   
        delete m_pVoiceProc;
    
    if (m_pGlobalProc)
        delete m_pGlobalProc;

    if (m_pExtendedProc)
        delete m_pExtendedProc;

    if (m_pCDma)
    {
        // clean the list - todo
    }

    m_pVoiceProc = NULL;
    m_pCDma = NULL;
    m_pApMethod = NULL;
    m_pGlobalProc = NULL;
    m_pExtendedProc = NULL;
    m_pEpMethod = NULL;
}

RM_STATUS 
CHalMCP1::InterruptService()
{
    RM_STATUS rmStatus = RM_OK;
    
    R_INTR rInterruptStatus;
    U032 uServiced = 1;
    
    INTR_MASK ClientMask;
    ClientMask.uValue = 0;
    
    // read from hardware what interrupt is pending
    RegRead(NV_PAPU_ISTS, &rInterruptStatus.uValue);
    
    // take action depending on what is triggered
    if (NV_PAPU_ISTS_GINTSTS_INTR == rInterruptStatus.General)
    {
        // prepare the magic write stuff
        aosZeroMemory(m_MagicWrite.pLinAddr, m_MagicWrite.Size);

        SetFrontEnd(E_STATE::LOCK);
        RegWrite(NV_PAPU_FEMEMADDR, (U032)m_MagicWrite.pPhysAddr);
        RegWrite(NV_PAPU_FEMEMDATA, (U032) 0x1);

        // find out if it's a valid interrupt
        // check for individial interrupt bits
        // can multiple bits be set?? vik
        
        if (NV_PAPU_ISTS_DWINTSTS_INTR == rInterruptStatus.DeltaWarning)
        {
            aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalMCP1::InterruptService - Delta Warning interrupt triggered!\n");
            rInterruptStatus.DeltaWarning = NV_PAPU_ISTS_DWINTSTS_CLR;
            ClientMask.apu.DeltaWarning = 1;
        }

        if (NV_PAPU_ISTS_RTWSTS_INTR == rInterruptStatus.RetriggerEvent)
        {
            aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalMCP1::InterruptService - Retriggerd Delta Warning interrupt (??)\n");
            // read only value.. need not be cleared
            // rInterruptStatus.RetriggerEvent = NV_PAPU_ISTS_RTWSTS_CLR; 
        }

        if (NV_PAPU_ISTS_DPINTSTS_INTR == rInterruptStatus.DeltaPanic)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::InterruptService - Delta Panic (internal and external GSCNT is same!\n");
            rInterruptStatus.DeltaPanic = NV_PAPU_ISTS_DPINTSTS_CLR;
            ClientMask.apu.DeltaPanic = 1;
        }

        if (NV_PAPU_ISTS_FETINTSTS_INTR == rInterruptStatus.FETrap)
        {
            rInterruptStatus.FETrap = NV_PAPU_ISTS_FETINTSTS_CLR;
        }

        if (NV_PAPU_ISTS_FENINTSTS_INTR == rInterruptStatus.FENotify)
        {
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::InterruptService - Notifier was written\n");
            rInterruptStatus.FENotify = NV_PAPU_ISTS_FENINTSTS_CLR;
            ClientMask.apu.FENotify = 1;
        }

        if (NV_PAPU_ISTS_FEVINTSTS_INTR == rInterruptStatus.FEVoice)
        {
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::InterruptService - End of voice received\n");
            rInterruptStatus.FEVoice = NV_PAPU_ISTS_FEVINTSTS_CLR;
            ClientMask.apu.FEVoice = 1;
        }

        if (NV_PAPU_ISTS_FEOINTSTS_INTR == rInterruptStatus.FEMethodOverFlow)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::InterruptService - User method fifo overflow.. some methods/data will be discarded\n");
            rInterruptStatus.FEMethodOverFlow = NV_PAPU_ISTS_FEOINTSTS_CLR;
            ClientMask.apu.FEMethodOverFlow = 1;
        }

        if (NV_PAPU_ISTS_GPMINTSTS_INTR == rInterruptStatus.GPMailbox)
        {
            rInterruptStatus.GPMailbox = NV_PAPU_ISTS_GPMINTSTS_CLR;
        }

        if (NV_PAPU_ISTS_GPNINTSTS_INTR == rInterruptStatus.GPNotify)
        {
            rInterruptStatus.GPNotify = NV_PAPU_ISTS_GPNINTSTS_CLR;
        }

        if (NV_PAPU_ISTS_EPMINTSTS_INTR == rInterruptStatus.EPMailbox)
        {
            rInterruptStatus.EPMailbox = NV_PAPU_ISTS_EPMINTSTS_CLR;
        }

        if (NV_PAPU_ISTS_EPNINTSTS_INTR == rInterruptStatus.EPNotify)
        {
            rInterruptStatus.EPNotify = NV_PAPU_ISTS_EPNINTSTS_CLR;
        }

        RegWrite(NV_PAPU_ISTS, rInterruptStatus.uValue);

        // complete the magic write...

        // unlock the FE
        SetFrontEnd(E_STATE::UNLOCK);

        // complete the magic writes (??)
        U032 uCnt = 0;
        while (! (*((U032 *)m_MagicWrite.pLinAddr)) )
        {
            if (uCnt++ > 100)
            {
                aosDbgPrintString(DEBUGLEVEL_ERRORS, "CHalMCP1::InterruptService - magic write not completing!!!\n");
                aosDbgBreakPoint();
                break;
            }
        }
    
        // it was our interrupt then complete the processing
        if (NV_PAPU_ISTS_GINTSTS_INTR == rInterruptStatus.General)
        {
            if (rInterruptStatus.FETrap == NV_PAPU_ISTS_FETINTSTS_CLR)
                OnIntrFETrap();

            // callback the clients
            CallbackClients(ClientMask.uValue);
        }

    }
    else
    {
        // not our interrupt
        rmStatus = RM_ERROR;
    }
    
    return rmStatus;
}

// returns non-zero if it's an EP SW method.. FALSE for AP
BOOL
CHalMCP1::GetUserMethodInfo(U032 *pMethod, U032 *pParam)
{
    // to do - change this when the .ref is updated
    RegRead(NV_PAPU_FEDECPARAM, pParam);
    RegRead(NV_PAPU_FEDECMETH, pMethod);

    BOOL bEPMethod = (*pMethod) & PIO_EP_OFFSET;

    // return 16 LSB after turning off bit 16
    *pMethod = ((*pMethod) & (~PIO_EP_OFFSET));
    *pMethod = LOW16(*pMethod);

    return bEPMethod;
}

VOID
CHalMCP1::OnIntrFETrap()
{
    R_FE_CONTROL rFeControl;
    RM_STATUS rmStatus = RM_ERROR;
    
    // first find out the reason for the trap
    U032 uParam;
    U032 uMethod;
    BOOL bEpMethod = GetUserMethodInfo(&uMethod, &uParam);
    
    RegRead(NV_PAPU_FECTL, &rFeControl.uValue);
    rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;
    RegWrite(NV_PAPU_FECTL, rFeControl.uValue);
    
    switch(rFeControl.TrapReason)
    {
    case NV_PAPU_FECTL_FETRAPREASON_METHOD_UNKNOWN:
        aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_METHOD_UNKNOWN\n");
    case NV_PAPU_FECTL_FETRAPREASON_NOT_IMPLEMENTED:
        aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_NOT_IMPLEMENTED\n");

        if (bEpMethod)
            rmStatus = m_pEpMethod->Execute(uMethod, uParam);
        else
            rmStatus = m_pApMethod->Execute(uMethod, uParam);

        break;
        
    case NV_PAPU_FECTL_FETRAPREASON_REQUESTED:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_REQUESTED\n");
        break;
        
    case NV_PAPU_FECTL_FETRAPREASON_BAD_ARGUMENT:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_BAD_ARGUMENT\n");
        break;

    case NV_PAPU_FECTL_FETRAPREASON_CURRENT_NOT_SET:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_CURRENT_NOT_SET\n");
        break;

    case NV_PAPU_FECTL_FETRAPREASON_ANTECEDENT_NOT_SET:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_ANTECEDENT_NOT_SET\n");
        break;

    case NV_PAPU_FECTL_FETRAPREASON_VOICE_ACTIVE:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_VOICE_ACTIVE\n");
        break;

    case NV_PAPU_FECTL_FETRAPREASON_NOT_DATA_TYPE_BUFFER:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_NOT_DATA_TYPE_BUFFER\n");
        break;
    }
    
    if (rmStatus != RM_OK)
        WriteError(FALSE, (U008)rFeControl.TrapReason);
        
    // turn the FE to free running
    SetFrontEnd(E_STATE::FREE_RUN);
}


VOID
CHalMCP1::WriteError(U032 uIsCurrentVoice, U008	uErrorCode)		
{
    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::WriteError - Writing to notification memory\n");

    if (m_pNotify)
    {
        U032 uIndex = 0;

        // TRUE - pick up from FECV, else write to [0]
        if (uIsCurrentVoice)
        {
            // get index
            RegRead(NV_PAPU_FECV, &uIndex);
            uIndex = (2*uIndex) + 2;
        }
        
        m_pNotify[uIndex]->GSCNT = 0xA1;             // just my signature
        m_pNotify[uIndex]->CurrentOffset = 0; 
        m_pNotify[uIndex]->Zero = 0;
        m_pNotify[uIndex]->Res0 = 0;
        m_pNotify[uIndex]->SamplesAvailable = 0;
        m_pNotify[uIndex]->EnvelopeActive = 0;
        m_pNotify[uIndex]->Status = uErrorCode;
    }
    else
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::WriteError - Notification memory not available\n");
    }

    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::WriteError - Done\n");
}

VOID 
CHalMCP1::CallbackClients(U032 uIntrMask)
{
    for (U032 uCnt = 0; uCnt < MAX_CLIENTS; uCnt++)
    {
        if ( (m_ClientInfo[uCnt].pFn) &&
            (m_ClientInfo[uCnt].Mask.uValue & uIntrMask) )
        {
            (*(m_ClientInfo[uCnt].pFn))((U032)m_ClientInfo[uCnt].pContext, uIntrMask, 0);
        }
    }
}

RM_STATUS
CHalMCP1::AddClient(VOID *pParam, U008 *pRef)
{
    PMCP1_CLIENT_INFO pClientInfo = (PMCP1_CLIENT_INFO)pParam;

    for (U032 uCnt = 0; uCnt < MAX_CLIENTS; uCnt++)
    {
        if (!m_ClientInfo[uCnt].pFn)
        {
            // store it here
            m_ClientInfo[uCnt].pFn = pClientInfo->pFn;
            m_ClientInfo[uCnt].Mask.uValue = pClientInfo->Mask.uValue;
            m_ClientInfo[uCnt].pContext = pClientInfo->pContext;
            *pRef = (U008)uCnt;

            return RM_OK;
        }
    }
    
    return RM_ERROR;
}

RM_STATUS
CHalMCP1::DeleteClient(U008 uRef)
{
    m_ClientInfo[uRef].pFn = NULL;
    return RM_OK;
}


RM_STATUS
CHalMCP1::Allocate()
{
    RM_STATUS rmStatus = RM_OK;
    
    // right now allocate just a page for magic write.. but later change it 
    // to allocate only 32 bits
    m_MagicWrite.Size = PAGE_SIZE;
    rmStatus = aosAllocateMem(m_MagicWrite.Size, 
                            ALIGN_4K, 
                            &(m_MagicWrite.pLinAddr),
                            &(m_MagicWrite.pPhysAddr));

    if (rmStatus == RM_OK)
    {
        // clear all the interrupts
        RegWrite(NV_PAPU_ISTS, (U032)0x00000FFF);

        m_rInterruptMask.uValue = 0;
        m_rInterruptMask.General = NV_PAPU_IEN_GINTEN_DISABLED;
        // m_rInterruptMask.DeltaWarning = NV_PAPU_IEN_DWINTEN_ENABLED;
        // m_rInterruptMask.DeltaPanic = NV_PAPU_IEN_DPINTEN_ENABLED;
        m_rInterruptMask.DeltaWarning = NV_PAPU_IEN_DWINTEN_DISABLED;
        m_rInterruptMask.DeltaPanic = NV_PAPU_IEN_DPINTEN_DISABLED;
        m_rInterruptMask.FETrap = NV_PAPU_IEN_FETINTEN_ENABLED;
        m_rInterruptMask.FENotify = NV_PAPU_IEN_FENINTEN_DISABLED;
        m_rInterruptMask.FEVoice = NV_PAPU_IEN_FEVINTEN_DISABLED;
        m_rInterruptMask.FEMethodOverFlow = NV_PAPU_IEN_FEOINTEN_ENABLED;
        m_rInterruptMask.GPMailbox = NV_PAPU_IEN_GPMINTEN_DISABLED;
        m_rInterruptMask.GPNotify = NV_PAPU_IEN_GPNINTEN_DISABLED;
        m_rInterruptMask.EPMailbox = NV_PAPU_IEN_EPMINTEN_DISABLED;
        m_rInterruptMask.EPNotify = NV_PAPU_IEN_EPNINTEN_DISABLED;

        R_FE_CONTROL rFeControl;
        rFeControl.uValue = 0;
	    rFeControl.TrapOnNotifier = NV_PAPU_FECTL_FENINT_ENABLED;
        rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;
        rFeControl.EnableLock = NV_PAPU_FECTL_FEMETH_PRIVLOCK_NOT_DISABLED;

        R_SE_CONTROL rSeControl;
        rSeControl.uValue = 0;
	    rSeControl.DeltaPanic = NV_PAPU_SECTL_DPINT_DISABLED;
	    rSeControl.Retriggered = NV_PAPU_SECTL_RTWARN_DISABLED;
	    rSeControl.DeltaWarn = NV_PAPU_SECTL_DWINT_DISABLED;
	    rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_OFF;

        RegWrite(NV_PAPU_IEN, m_rInterruptMask.uValue);
        RegWrite(NV_PAPU_FECTL, rFeControl.uValue);
        RegWrite(NV_PAPU_SECTL, rSeControl.uValue);
    
        // i want all legal traps to come to me...
        RegWrite(NV_PAPU_FETFORCE0, (U032)0);
        RegWrite(NV_PAPU_FETFORCE1, (U032)0);
        RegWrite(NV_PAPU_FETIGNORE0, (U032)0);
        RegWrite(NV_PAPU_FETIGNORE1, (U032)0);
    
        // stop the GP - todo

        // stop the EP - todo
    }

    return rmStatus;
}

RM_STATUS
CHalMCP1::Free()
{
    RM_STATUS rmStatus = RM_OK;
    
    // disable the interrupts
    SetInterrupts(INTERRUPT_STATE::DISABLE);

    // stop the FE
    SetFrontEnd(E_STATE::HALT);

    // free the memory
    if (m_MagicWrite.pLinAddr)
        aosFreeMem(m_MagicWrite.pLinAddr);

    return rmStatus;
}

RM_STATUS 
CHalMCP1::AllocateObject(U032 uObjectType, VOID *pParam)
{
	RM_STATUS	rmStatus = RM_ERROR;

    switch (uObjectType)
    {
    case AUDIO_OBJECT_AP:

        do
        {
	        APU_AP_CREATE *pArg = (APU_AP_CREATE *)pParam;

            if (m_pApMethod)
            {
                // not support for multiple object allocations...
                break;
            }

            // allocate the sw method class
            m_pApMethod = new CMCP1Method(this);
            m_pVoiceProc = new CHalVoiceProc(this);
            m_pGlobalProc = new CHalGlobalProc(this);

            if (m_pVoiceProc && m_pGlobalProc && m_pApMethod)
            {
                SetInterrupts(INTERRUPT_STATE::DISABLE);
                SetFrontEnd(E_STATE::LOCK);

                // now allocate the objects
                rmStatus = m_pVoiceProc->Allocate(pParam);
                if (rmStatus == RM_OK)
                    rmStatus = m_pGlobalProc->Allocate(pParam);
                
                if (pArg->flags.fields.ISO)
                {
                    SetFrontEnd(E_STATE::ISO);
                    SetSetupEngine(E_STATE::ISO);
                }
                else
                {
                    SetFrontEnd(E_STATE::NON_ISO);
                    SetSetupEngine(E_STATE::NON_ISO);
                }
                
                if (rmStatus == RM_OK)
                {
                    // find out mode for setup engine...
                    E_STATE eState;

                    switch(pArg->flags.fields.GSCNT)
                    {
                    case GSCNT_ACSYNC:
                        eState = AC_SYNC;
                        break;
                    case GSCNT_SW:
                        eState = SW;
                        break;
                    case GSCNT_FREE_RUNNING:
                    default:
                        eState = FREE_RUN;
                        break;
                    }

                    SetSetupEngine(eState);

                    if (eState != E_STATE::FREE_RUN)
                    {
                        SetSetupEngineGlobalCounts( pArg->uExternalGSCNT,
                                                    pArg->uInternalGSCNT,
                                                    pArg->uDeltaGSCNT);
                    }

                    SetFrontEnd(E_STATE::FREE_RUN);
                }
                
                SetFrontEnd(E_STATE::UNLOCK);
                SetInterrupts(INTERRUPT_STATE::ENABLE);

                pArg->pioBase = GetDevBase() + DEVICE_BASE(NV_PAPU_NV1BA0);
            }

        } while (FALSE);

        break;

    case AUDIO_OBJECT_EP:
        do
        {
            APU_EP_CREATE *pArg = (APU_EP_CREATE *) pParam;
            
            if (m_pEpMethod)
                break;

            m_pExtendedProc = new CHalExtendedProc(this);
            m_pEpMethod = new CEPMethod(this);

            if (m_pExtendedProc && m_pEpMethod)
                rmStatus = m_pExtendedProc->Allocate(pParam);

            if (rmStatus == RM_OK)
            {
                // set up the sample counts
                SetSetupEngineExtendedCounts(pArg->uInternalGSCNT,
                                            pArg->uDeltaGSCNT,
                                            pArg->uStepSize);

                pArg->pioBase = GetDevBase() + DEVICE_BASE(NV_PAPU_NV1BA0) + PIO_EP_OFFSET;
            }

        } while (FALSE);

        break;

    default:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::AllocateObject - Illegal object\n");
        rmStatus = RM_ERR_ILLEGAL_OBJECT;
        break;
    }
    
    if (rmStatus != RM_OK)
        FreeObject(uObjectType, NULL);

    return rmStatus;

}

RM_STATUS 
CHalMCP1::FreeObject(U032 uObjectType, VOID *pParam)
{
    RM_STATUS rmStatus = RM_OK;

    switch(uObjectType)
    {
    case AUDIO_OBJECT_AP:
        if (m_pApMethod)
        {
            delete m_pApMethod;
            m_pApMethod = NULL;
        }

        if (m_pGlobalProc)
        {
            m_pGlobalProc->Free();
            delete m_pGlobalProc;
            m_pGlobalProc = NULL;
        }

        if (m_pVoiceProc)
        {
            m_pVoiceProc->Free(pParam);
            delete m_pVoiceProc;
            m_pVoiceProc = NULL;
        }
        break;

    case AUDIO_OBJECT_EP:
        if (m_pEpMethod)
        {
            delete m_pEpMethod;
            m_pEpMethod = NULL;
        }

        if (m_pExtendedProc)
        {
            m_pExtendedProc->Free();
            delete m_pExtendedProc;
            m_pExtendedProc = NULL;
        }
        break;

    default:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::FreeObject - Illegal object\n");
        rmStatus = RM_ERR_ILLEGAL_OBJECT;
        break;
    }

    return rmStatus;
}


VOID 
CHalMCP1::SetInterrupts(INTERRUPT_STATE eIntrState)
{
    if (eIntrState == ENABLE)		// set the interrupts on
        m_rInterruptMask.General = NV_PAPU_IEN_GINTEN_ENABLED;
    else							// turn them off
        m_rInterruptMask.General = NV_PAPU_IEN_GINTEN_DISABLED;
    
    RegWrite(NV_PAPU_IEN, m_rInterruptMask.uValue);
}


VOID 
CHalMCP1::SetFrontEnd(E_STATE eFeState)
{
    R_FE_CONTROL rFeControl;
    
#if defined DEBUG
    U032 uCnt = 0;
#endif

    if (eFeState == LOCK)
    {
        do
        {
            RegRead(NV_PAPU_FECTL, &rFeControl.uValue);

#if defined DEBUG
            if (uCnt++ > 1000)      aosDbgBreakPoint();
#endif

        } while (rFeControl.Lock == NV_PAPU_FECTL_FEPRIVLOCK_LOCKED);

        rFeControl.Lock = NV_PAPU_FECTL_FEPRIVLOCK_LOCKED;
    }
    else
    {
        RegRead(NV_PAPU_FECTL, &rFeControl.uValue);

        // error check
        if (rFeControl.Lock == NV_PAPU_FECTL_FEPRIVLOCK_LOCKED)
        {
            aosDbgBreakPoint();
        }
        
        switch(eFeState)
        {
        case UNLOCK:
            rFeControl.Lock = NV_PAPU_FECTL_FEPRIVLOCK_UNLOCKED;
            break;
        case HALT:
            rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;
            break;
        case FREE_RUN:
            rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_FREE_RUNNING;
            break;
        case ISO:
	        rFeControl.WriteISO = NV_PAPU_FECTL_FEMWTYP_ISO;
	        rFeControl.ReadISO = NV_PAPU_FECTL_FEMRTYP_ISO;
	        rFeControl.NotifyISO = NV_PAPU_FECTL_FENTYP_ISO;
            rFeControl.PIOClass = NV_PAPU_FECTL_FEPIOCLASS_ISO;
            break;
        case NON_ISO:
	        rFeControl.WriteISO = NV_PAPU_FECTL_FEMWTYP_NON_ISO;
	        rFeControl.ReadISO = NV_PAPU_FECTL_FEMRTYP_NON_ISO;
	        rFeControl.NotifyISO = NV_PAPU_FECTL_FENTYP_NON_ISO;
            rFeControl.PIOClass = NV_PAPU_FECTL_FEPIOCLASS_NON_ISO;
            break;
        }
    }

    RegWrite(NV_PAPU_FECTL, rFeControl.uValue);
}


VOID
CHalMCP1::SetSetupEngine(E_STATE eState)
{
    R_SE_CONTROL rSeControl;

    RegRead(NV_PAPU_SECTL, &rSeControl.uValue);

    switch(eState)
    {
    case ISO:
	    rSeControl.SampleReadISO = NV_PAPU_SECTL_SESRTYP_ISO;
	    rSeControl.WriteISO = NV_PAPU_SECTL_SEPWTYP_ISO;
	    rSeControl.ReadISO = NV_PAPU_SECTL_SEPRTYP_ISO;
        break;
    case NON_ISO:
	    rSeControl.SampleReadISO = NV_PAPU_SECTL_SESRTYP_NON_ISO;
	    rSeControl.WriteISO = NV_PAPU_SECTL_SEPWTYP_NON_ISO;
	    rSeControl.ReadISO = NV_PAPU_SECTL_SEPRTYP_NON_ISO;
        break;
    case OFF:
        rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_OFF;
        break;
    case AC_SYNC:
        rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_AC_SYNC;
        break;
    case SW:
        rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_SW;
        break;
    case FREE_RUN:
        rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_FREE_RUNNING;
        break;
    case INT_PANIC:
        rSeControl.DeltaPanic = NV_PAPU_SECTL_DPINT_ENABLED;
        break;
    case INT_RETRIGGER:
        rSeControl.Retriggered = NV_PAPU_SECTL_RTWARN_ENABLED;
        break;
    case INT_WARN:
        rSeControl.DeltaWarn = NV_PAPU_SECTL_DWINT_ENABLED;
        break;
    default:
        return;
    }

    RegWrite(NV_PAPU_SECTL, rSeControl.uValue);

}

VOID
CHalMCP1::SetSetupEngineGlobalCounts(U032 uExt, U032 uInt, U032 uDelta)
{
    U032 uWarn = ((uInt - uExt) - uDelta)/3;
    U032 uRetrigger = 0;        // not using it right now
    U032 uPanic = 0;            // for now.. panic if uExt catches up with uInt

    RegWrite(NV_PAPU_XGSCNT, uExt);
    RegWrite(NV_PAPU_IGSCNT, uInt);
    RegWrite(NV_PAPU_DGSCNT, uDelta);
    RegWrite(NV_PAPU_WGSCNT, uWarn);
    RegWrite(NV_PAPU_RGSCNT, uRetrigger);
    RegWrite(NV_PAPU_PGSCNT, uPanic);
    
    // make sure the SECTL is triggering panic and warn interrupts
    // and retrigger is off
    SetSetupEngine(E_STATE::INT_PANIC);
    SetSetupEngine(E_STATE::INT_WARN);
}

VOID
CHalMCP1::SetSetupEngineExtendedCounts(U032 uInt, U032 uDelta, U032 uStep)
{
    RegWrite(NV_PAPU_EGSCNT, uInt);
    RegWrite(NV_PAPU_DEGSCNT, uDelta);
    RegWrite(NV_PAPU_ECNTSTP, uStep);
}

RM_STATUS 
CHalMCP1::AllocateContextDma(VOID *pParam)
{
    APU_AP_ALLOC_CONTEXT_DMA *pIn = (APU_AP_ALLOC_CONTEXT_DMA *)pParam;
    RM_STATUS rmStatus = RM_ERROR;

    CContextDma *pDma = new CContextDma;

    if (pDma)
    {
        rmStatus = pDma->Initialize((VOID *)pIn->uBaseAddress,
                                    pIn->uMaxOffset,
                                    pIn->uType);

        if (AUDIO_CONTEXT_DMA_FENOTIFIER == pIn->uType)
        {
            // store the notifier memory address...
            m_pNotify = (PNV1BA0NOTIFICATION *)pIn->uBaseAddress;
        }

        if (rmStatus == RM_OK)
            pDma->Add((CLinkList **)&m_pCDma);
        else
        {
            delete pDma;
            pDma = NULL;
        }
    }
    
    pIn->uHandle = (U032)pDma;

    return rmStatus;
}

RM_STATUS 
CHalMCP1::FreeContextDma(VOID *pParam)
{
    APU_AP_FREE_CONTEXT_DMA *pIn = (APU_AP_FREE_CONTEXT_DMA *) pParam;

#if defined DEBUG

    // search the list for the context DMA
    if (!m_pCDma || FALSE == m_pCDma->Exists((CLinkList *)pIn->uHandle))
    {
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalMCP1::FreeContextDma - handle not found\n");
        return RM_ERROR;
        
    }

#endif 

    // assume it's the correct handle and free it
    CContextDma *pElement = (CContextDma *)pIn->uHandle;
    
    if (!pElement)
        return RM_ERROR;

    if (pElement->GetType() == AUDIO_CONTEXT_DMA_FENOTIFIER)
        m_pNotify = NULL;
    
    pElement->Remove((CLinkList **)&m_pCDma);
    
    delete pElement;

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\class\nv\classdel.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CLASSDEL.C                                                        *
*     Deleted user objects are destroyed here if not in use or placed       *
* into a 'zombie' state waiting to go idle before all state is removed.     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>

//
// No zombie management yet
//
RM_STATUS classAddZombie
(
    POBJECT DeadObject
)
{
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\audio\CHalVoiceProc.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************VP class for the HAL******************************\
*                                                                           *
* Module: CHalVoiceProc.h                                                   *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CHALVOICEPROCH_
#define _CHALVOICEPROCH_

class CHalBase;
class CObjBase;

class CHalVoiceProc : public CObjBase
{
public:
    CHalVoiceProc(CHalBase *pHal) : CObjBase(pHal) { };
	~CHalVoiceProc() { };

public:

	// each derived object has to implement these functions
	RM_STATUS Allocate(VOID *pParam);
	RM_STATUS Free(VOID *pParam = NULL);
	RM_STATUS GetCaps(VOID *pParam);
    
    void *  GetSgeInLinAddr()   { return m_SgeIn.pLinAddr; }
    U032    GetSgeInSize()      { return m_SgeIn.Size; }

    void *  GetSegInLinAddr()   { return m_SegIn.pLinAddr; }
    U032    GetSegInSize()      { return m_SegIn.Size; }

private:
	VOID InitializeHardware(APU_AP_CREATE *);

    RM_STATUS AllocateMemory(APU_AP_CREATE *);
    VOID FreeMemory();

    MEM_DESC    m_Voice;
    MEM_DESC    m_SgeIn;
    MEM_DESC    m_SegIn;
    MEM_DESC    m_HRTFTarg;
    MEM_DESC    m_HRTFCurr;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\class\nv\classobj.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CLASSOBJ.C                                                        *
*     NV_CLASS objects are defined and managed in this module.              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <fifo.h>
#include <os.h>
#include <modular.h>


//
// Class object table.
//
extern CLASS classTable[];


//---------------------------------------------------------------------------
//
//  Class object method functions.
//
//---------------------------------------------------------------------------

RM_STATUS mthdCreateLegacy
(
	PHWINFO pDev,
    POBJECT ClassObject,
    PMETHOD Method,
    U032    Offset,
    U032    NewName
)
{
    RM_STATUS status;
    POBJECT   NewObject;

    if (NewName < RESERVED_NAMES)
        return (RM_ERR_CREATE_BAD_CLASS);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Creating Object ", NewName);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               Class  ", ClassObject->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               ChID   ", ClassObject->ChID);
    
    //
    // Class specific creation routine.
    //
    status = classCreate((VOID*)pDev, (PCLASSOBJECT)ClassObject, NewName, &NewObject, NULL);
    if (status == RM_OK)
    {
        //
        // Init global state.
        //
        DBG_VAL_PTR(NewObject);

        //
        // Stick new object into FIFO database.
        //
        if ((status = fifoAddObject(pDev, NewObject)) != RM_OK)
            classDestroy((VOID*)pDev, NewObject);
    }
    return (status);
}
RM_STATUS mthdCreate
(
	PHWINFO pDev,
    POBJECT ClassObject,
    PMETHOD Method,
    U032    Offset,
    U032    NewName,
    VOID*   pCreateParms
)
{
    RM_STATUS status;
    POBJECT   NewObject;

    if (NewName < RESERVED_NAMES)
        return (RM_ERR_CREATE_BAD_CLASS);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Creating Object ", NewName);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               Class  ", ClassObject->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               ChID   ", ClassObject->ChID);
    
    //
    // Class specific creation routine.
    //
    status = classCreate((VOID*)pDev, (PCLASSOBJECT)ClassObject, NewName, &NewObject, pCreateParms);
    if (status == RM_OK)
    {
        //
        // Init global state.
        //
        DBG_VAL_PTR(NewObject);

        //
        // Stick new object into FIFO database.
        //
        if ((status = fifoAddObject(pDev, NewObject)) != RM_OK)
            classDestroy((VOID*)pDev, NewObject);
    }
    return (status);
}
RM_STATUS mthdDestroy
(
	PHWINFO pDev,
    POBJECT ClassObject,
    PMETHOD Method,
    U032    Offset,
    U032    DelName
)
{
    RM_STATUS status;
    POBJECT   DelObject;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Destroying Object ", DelName);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                 Class  ", ClassObject->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                 ChID   ", ClassObject->ChID);
    //
    // Retrieve and delete object from FIFO database.
    //    
    status = fifoSearchObject(pDev, DelName, ClassObject->ChID, &DelObject);
    if (status == RM_OK)
    {
        //
        // Make sure to free up any events in this object
        //
        if (DelObject->NotifyEvent)
        {
            PEVENTNOTIFICATION thisEvent = DelObject->NotifyEvent;
            PEVENTNOTIFICATION nextEvent = DelObject->NotifyEvent->Next;
            
            //
            // Walk the event chain and delete
            //
            osFreeMem((VOID *)thisEvent);
            while (nextEvent)
            {
                thisEvent = nextEvent;
                nextEvent = thisEvent->Next;
                osFreeMem((VOID *)thisEvent);
            }
        }
        
        //
        // Class specific delete procedure.
        //
        status  = fifoDelObject(pDev, DelObject);
        status |= classDestroy((VOID*)pDev, DelObject);
    }
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\class\nv\nvde.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** NVDE ****************************************\
*                                                                           *
* Module: NVDE.C                                                            *
*     NVDE methods                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <modular.h>
#include <event.h>

RM_STATUS NvdeAlloc
(
    U032            Name,
    VOID*           pCreateParms
)
{
    PRMINFO pRmInfo = &NvRmInfo;
    RM_STATUS status;
    POBJECT pObject;
    PNVDEOBJECT pNvdeObject;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvdeAlloc\r\n");

    //
    // Make sure an NVDE object isn't already in use
    //
    if (pRmInfo->Debugger.object)
        return (NVDE_STATUS_ERROR_STATE_IN_USE);

    //
    // Allocate space for the object.
    //
    status = osAllocMem((VOID **)&pObject, sizeof(NVDEOBJECT));
    if (status)
        return (status);

    //
    // Set some default state.
    //
    pObject->Name = Name;
    pObject->ChID = 0;
    pObject->Class = NULL;
    pObject->ThisClass = NULL;
    pObject->Subchannel = NULL;
    pObject->Next = NULL;
    pObject->NotifyXlate = NULL;
    pObject->NotifyAction = 0;
    pObject->NotifyTrigger = 0;
    pObject->NotifyEvent = 0;

    //
    // Save off the event parameters.
    //
    pNvdeObject = (PNVDEOBJECT)pObject;
    pNvdeObject->EventHandle = ((NVDE_ALLOCATION_PARAMETERS*)pCreateParms)->EventHandle;
    pNvdeObject->EventClass = ((NVDE_ALLOCATION_PARAMETERS*)pCreateParms)->EventClass;
    pNvdeObject->EventBufferCount = 0;

    //
    // Queue up event...
    //
    status = eventSetObjectEventNotify(pObject, 0, 0, pNvdeObject->EventClass,  pNvdeObject->EventHandle);

    //
    // Set the pointer so we know a NVDE object is in use
    //
    if (status == RM_OK)
        pRmInfo->Debugger.object = (POBJECT) pObject;

    return status;
}


RM_STATUS NvdeFree
(
    U032 Client,
    U032 Object
)
{
    PRMINFO pRmInfo = &NvRmInfo;
    PNVDEOBJECT pNvdeObject = (PNVDEOBJECT)pRmInfo->Debugger.object;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvdeFree\r\n");

    if (pNvdeObject == NULL)
        return RM_OK;

    //
    // Assert that the handles match.
    //
    if (pNvdeObject->Common.Base.Name != Object)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad debugger object handle ", Object);
        return RM_ERROR;
    }

    //
    // Unplug event.  Handle is 0 for now since we only support
    // a single debugger event.
    //
    eventRemoveObjectEventNotify((POBJECT)pNvdeObject, 0);

    //
    // Clear out the NVDE object pointer so we know it's not in use
    //
    pRmInfo->Debugger.object = (POBJECT)NULL;

    return (osFreeMem(pNvdeObject));
}

V032 NvdeAppendEventForDebugger
(
    PNVDEOBJECT pDebugger,
    U032        code,
    U032        flags,
    U032        param1,
    U032        param2,
    U032        param3,
    U032        param4,
    U032        param5,
    U032        param6
)
{
    PNVDEEVENT event;

    if (pDebugger->EventBufferCount >= NVDE_MAX_EVENTS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Too many NVDE events to buffer.\n\r");
        return 0;
    }
    
    event           = pDebugger->EventBuffer + pDebugger->EventBufferCount;
    event->code     = code;
    event->flags    = flags;
    event->param[0] = param1;
    event->param[1] = param2;
    event->param[2] = param3;
    event->param[3] = param4;
    event->param[4] = param5;
    event->param[5] = param6;

    pDebugger->EventBufferCount++;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\audio\CObjBase.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Base class for the HAL******************************\
*                                                                           *
* Module: CObjBase.h                                                        *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _COBJBASEH_
#define _COBJBASEH_

class CHalBase;

class CObjBase
{
public:
	CObjBase(CHalBase *pHal)	{ m_pHal = pHal; }

public:
	// each derived object has to implement these functions
	virtual RM_STATUS Allocate(VOID *pParam) = 0;
	virtual RM_STATUS Free(VOID *pParam = NULL) = 0;

protected:
	
	virtual VOID RegWrite(U032 uOffset, U032 uValue) { m_pHal->RegWrite(uOffset, uValue); }
	virtual VOID RegWrite(U032 uOffset, U016 uValue) { m_pHal->RegWrite(uOffset, uValue); }
	virtual VOID RegWrite(U032 uOffset, U008 uValue) { m_pHal->RegWrite(uOffset, uValue); }

	virtual VOID RegRead(U032 uOffset, U032 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, U016 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, U008 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, volatile U032 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, volatile U016 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, volatile U008 *pValue) { m_pHal->RegRead(uOffset, pValue); }

    virtual void MemWrite(U032 uAddr, U008 uData)    { 	m_pHal->MemWrite(uAddr, uData);   }
    virtual void MemWrite(U032 uAddr, U016 uData)    { 	m_pHal->MemWrite(uAddr, uData);   }
    virtual void MemWrite(U032 uAddr, U032 uData)    { 	m_pHal->MemWrite(uAddr, uData);   }

    CHalBase *GetDevice()           { return m_pHal; }

private:
	CHalBase *m_pHal;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\audio\CMCP1Method.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CMCP1Method.cpp                                                     *
*     Object Classes are defined in this module.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <nv_uap.h>
#include <nv_papu.h>
#include <AudioHw.h>
#include <nv32.h>
};
#include <aos.h>
#include <ahal.h>

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalMCP1.h"
#include "CHalGlobalProc.h"
#include "CHalVoiceProc.h"
#include <CLinkList.h>
#include "CContextDma.h"
#include "CMCP1Method.h"

RM_STATUS
CMCP1Method::Execute(U032 uOffset, U032 uData)
{
    RM_STATUS rmStatus = RM_ERROR;  // not implemented

    do
    {
        if (CheckRange(uOffset, NV1BA0_PIO_SET_CONTEXT_DMA_NOTIFY))
        {
            rmStatus = SetContextDMANotify(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BA0_PIO_SET_CURRENT_SSL_CONTEXT_DMA))
        {
            rmStatus = SetCurrentSSLContextDMA(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BA0_PIO_SET_CURRENT_INBUF_SGE_CONTEXT_DMA))
        {
            rmStatus = SetCurrentInBufSGEContextDMA(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BA0_PIO_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA))
        {
            rmStatus = SetCurrentOutBufSGEContextDMA(uData);
            break;
        }
        
        if (CheckRange(uOffset, 0x4000))        // to be moved to the .ref file.. todo vik
        {
            rmStatus = SetGPState(uData);
            break;
        }

        if (CheckRange(uOffset, 0x4004))        // debug...
        {
            rmStatus = SetCurrentOutBufSGEOffset(uData);
            break;
        }
        
        if (CheckRange(uOffset, 0x4008))        // debug...
        {
            rmStatus = SetCurrentInBufSGEOffset(uData);
            break;
        }
        
        U032 uCnt = 0;

        for (uCnt = 0; uCnt < 4; uCnt++)
        {
            if (CheckRange(uOffset, (0x420C + (uCnt*8))) )
            {
                rmStatus = SetOutBufBA(uData, uCnt);
                break;
            }
        }
        
        if (uCnt != 4)
            break;

        for (uCnt = 0; uCnt < 4; uCnt++)
        {
            if (CheckRange(uOffset, (0x4210 + (uCnt*8))) )
            {
                rmStatus = SetOutBufLen(uData, uCnt);
                break;
            }
        }

        if (uCnt != 4)
            break;

        // find out if NV1BA0_PIO_SET_SSL_SEGMENT_OFFSET got triggered
        for (uCnt = 0; uCnt < 64; uCnt++)
        {
            if (CheckRange(uOffset, (0x400C + (uCnt*8))) )
            {
                rmStatus = SetSSLSegmentOffset(uData);
                break;
            }
        }
        
        if (uCnt != 64)
            break;

        for (uCnt = 0; uCnt < 64; uCnt++)
        {
            if (CheckRange(uOffset, (0x4010 + (uCnt*8))) )
            {
                rmStatus = SetSSLSegmentOffsetLength(uData, uCnt);
                break;
            }
        }

        if (uCnt != 64)
            break;
        
        
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CMCP1Method::Execute - SW method not yet implemented!\n");

#if defined WDM
        KdPrint(("Method offset = 0x%x Method Data = 0x%x\n", uOffset, uData));
#endif

    } while (FALSE);
    
    return rmStatus;
}

// software methods
RM_STATUS
CMCP1Method::SetContextDMANotify(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if ((U032)(pDma->GetAddress()) & 0xFF)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: SetContextDMANotify - Address not aligned on 256bytes boundary\n");
        return RM_ERROR;
    }

    m_pHal->RegWrite(NV_PAPU_FENADDR, (U032)pDma->GetAddress());
    return RM_OK;
}

RM_STATUS
CMCP1Method::SetCurrentSSLContextDMA(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if (((U032)(pDma->GetAddress()) & 0xFFF) ||
        (pDma->GetSize() & 0xFFF))
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: SetCurrentSSLContextDMA - Address not aligned on 4K boundary\n");
        return RM_ERROR;
    }

    m_pHal->RegWrite(NV_PAPU_FESESSLCTXPA, (U032)pDma->GetAddress());
    m_pHal->RegWrite(NV_PAPU_FESESSLMAXOFF, (U032)pDma->GetSize());

    return RM_OK;
}

RM_STATUS
CMCP1Method::SetCurrentInBufSGEContextDMA(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if (((U032)(pDma->GetAddress()) & 0xFFF) ||
        (pDma->GetSize() & 0xFFF))
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: SetCurrentInBufSGEContextDMA - Address not aligned on 4K boundary\n");
        return RM_ERROR;
    }

    m_pHal->RegWrite(NV_PAPU_FESESGECTXPA, (U032)pDma->GetAddress());
    m_pHal->RegWrite(NV_PAPU_FESESGEMAXOFF, (U032)pDma->GetSize());

    return RM_OK;
}

RM_STATUS
CMCP1Method::SetCurrentOutBufSGEContextDMA(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if (((U032)(pDma->GetAddress()) & 0xFFF) ||
        (pDma->GetSize() & 0xFFF))
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: SetCurrentOutBufSGEContextDMA - Address not aligned on 4K boundary\n");
        return RM_ERROR;
    }

    m_pHal->RegWrite(NV_PAPU_FEGPSGECTXPA, (U032)pDma->GetAddress());
    m_pHal->RegWrite(NV_PAPU_FEGPSGEMAXOFF, (U032)pDma->GetSize());

    return RM_OK;
}

RM_STATUS
CMCP1Method::SetGPState(U032 uData)
{
    R_GP_CONTROL rControl;
    rControl.uValue = 0;

    if (uData)
    {
        // take it out of reset...
        R_GP_RESET rReset;
        rReset.uValue = 0;
        rReset.Global = NV_PAPU_GPRST_GPRST_DISABLED;
        rReset.DSP = NV_PAPU_GPRST_GPDSPRST_ENABLED;
        rReset.NMI = NV_PAPU_GPRST_GPNMI_DISABLED;
        rReset.Abort = NV_PAPU_GPRST_GPABORT_DISABLED;

        m_pHal->RegWrite(NV_PAPU_GPRST, rReset.uValue);
        
        // write the command to make the GP work in pass thru
        DSP_CONTROL dspCtl;

        dspCtl.w0.uValue = 0;
        dspCtl.w0.field.EOL = 1;    // this is the last command

        dspCtl.w1.uValue = 0;
        dspCtl.w1.field.interleave = 1;
        dspCtl.w1.field.dspToSys = 1;
        dspCtl.w1.field.smDataFormat = 1;
        dspCtl.w1.field.increment = 32;

        dspCtl.w2.uValue = 0;
        dspCtl.w2.field.count0 = 1;   // 2 samples per block
        dspCtl.w2.field.count1 = 32;

        dspCtl.w3.uValue = 0;
        dspCtl.w3.field.dspStart = 0x1400;

        m_pHal->GetGlobalProc()->WriteCommand(&dspCtl);

        // auto start and auto idle
        R_GPDMA_CONFIG rConfig;
        rConfig.uValue = 0;
        rConfig.Start = NV_PAPU_GPDCFG_GPDASTRT_ENABLED;
        rConfig.Ready = NV_PAPU_GPDCFG_GPDARDY_ENABLED;
        m_pHal->RegWrite(NV_PAPU_GPDCFG, rConfig.uValue);
    
        // DMA start block pointer
        m_pHal->RegWrite(NV_PAPU_GPDSPT, (U032) 0);

        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CMCP1Method::SetGPState - the GP might just start...");
        // enable the GP
        rControl.Idle = NV_PAPU_GPIDRDY_GPSETIDLE_SET;
        rControl.IntrNotify = NV_PAPU_GPIDRDY_GPSETNINT_NOT_SET;
    }
    else
    {
        // stop the GP
        /*
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CMCP1Method::SetGPState - the GP might just stop...");
        rControl.EnableStop = NV_PAPU_GPIDRDY_GPSTOP_ENABLED;
        rControl.Stopped = NV_PAPU_GPIDRDY_GPSTOPPED_SET;
        */
    }

    m_pHal->RegWrite(NV_PAPU_GPIDRDY, rControl.uValue);

    aosDbgPrintString(DEBUGLEVEL_ERRORS, "done.  Congratulations!\n");
    return RM_OK;
}

// NV1BA0_PIO_SET_CURRENT_OUTBUF_SGE_OFFSET
RM_STATUS
CMCP1Method::SetCurrentOutBufSGEOffset(U032 uData)
{
    MCP1_PRD *pLin = (MCP1_PRD *)(m_pHal->GetGlobalProc()->GetSgeOutLinAddr());

    pLin->uAddr = uData;
    pLin->Control.uValue = 0;
    pLin->Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;      // owned by HW

    return RM_OK;
}

// NV1BA0_PIO_SET_CURRENT_INBUF_SGE_OFFSET
RM_STATUS
CMCP1Method::SetCurrentInBufSGEOffset(U032 uData)
{
    VOLU32 uTemp;

    // find out the max offset
    m_pHal->RegRead(NV_PAPU_FESESGEMAXOFF, &uTemp);
    if (uTemp < uData)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetCurrentInBufSGEOffset - max offset exceeded!\n");
        return RM_ERROR;
    }

    R_FE_CONTROL rFeCtl;

    m_pHal->RegRead(NV_PAPU_FECTL, &rFeCtl.uValue);
    if (rFeCtl.ValidSESGE == NV_PAPU_FECTL_FESESGECTXPA_VALID_NO)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetCurrentInBufSGEOffset - SGE context dma valid bit not set\n");
        return RM_ERROR;
    }

    // find the right PRD to write to
    MCP1_PRD *pPrd = (MCP1_PRD *)(m_pHal->GetVoiceProc()->GetSgeInLinAddr());
    U032 uNumOfPrds = (m_pHal->GetVoiceProc()->GetSgeInSize())/NV_PSGE_SIZE;

    // read the current index to write to...
    m_pHal->RegRead(NV_PAPU_FECSESGE, &uTemp);

    // a little error checking of my own..
    if (uNumOfPrds < uTemp)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetCurrentInBufSGEOffset - current index greater than total PRDs allocated\n");
        return RM_ERROR;
    }

    VOLU32 uBase;
    m_pHal->RegRead(NV_PAPU_FESESGECTXPA, &uBase);

    // make the PRD (not 0 based.. i think)
    pPrd[uTemp-1].uAddr = uBase + uData;
    pPrd[uTemp-1].Control.uValue = 0;
    pPrd[uTemp-1].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;

    return RM_OK;
}

// NV1BA0_PIO_SET_SSL_SEGMENT_OFFSET
RM_STATUS
CMCP1Method::SetSSLSegmentOffset(U032 uData)
{
    // error checking .. to hell with it! (for now)

    if (uData & 0xFFF)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetSSLSegmentOffset - alignment check fails!\n");
        return RM_ERROR;
    }
    
    // save it as pending
    uData = uData | NV_PAPU_FESESSLPENDOFF_VALID_YES;

    m_pHal->RegWrite(NV_PAPU_FESESSLPENDOFF, uData);

    return RM_OK;
}

// NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH
RM_STATUS
CMCP1Method::SetSSLSegmentOffsetLength(U032 uData, U032 uIndex)
{
    /*
    Check that the offset has already been saved by the previous method.
    Check that container_size != 2. 
    Check that (offset & container_size) == 0.
    Check that samples_per_block > stereo.
    
    Then, check the offset and length as follows:
    
           offset+(length*container_size*samples_per_block) <= maxoff
    */

    MCP1_PRD *pPrd = (MCP1_PRD *)(m_pHal->GetVoiceProc()->GetSegInLinAddr());
    
    // calculate the index of the SSL
    VOLU16 uCurrSSL = 0;
    m_pHal->RegRead(NV_PAPU_FECSESSL, &uCurrSSL);
    
    uIndex += (uCurrSSL * 64);
    
    // read the offset previosuly set
    VOLU32 uPendOffset = 0;
    m_pHal->RegRead(NV_PAPU_FESESSLPENDOFF, &uPendOffset);
    
    // just for fun confirm that it's valid
    if ((uPendOffset & 0x1) != NV_PAPU_FESESSLPENDOFF_VALID_YES)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetSSLSegmentOffsetLength - u can only set length after setting the offset!\n");
        return RM_ERROR;
    }
    
    VOLU32 uBase;
    m_pHal->RegRead(NV_PAPU_FESESSLCTXPA, &uBase);
    
    // these don't look like being '0' based
    pPrd[uIndex-1].uAddr = uBase + (uPendOffset & 0xFFFFF000);
    pPrd[uIndex-1].Control.uValue = uData;

    return RM_OK;
}

// NV1BA0_PIO_SET_OUTBUF_BA(i)
RM_STATUS
CMCP1Method::SetOutBufBA(U032 uData, U032 uIndex)
{
    U032 uOffBase;
    U032 uOffEnd;

    switch(uIndex)
    {
    case 0:
        uOffBase = NV_PAPU_GPOFBASE0;
        uOffEnd = NV_PAPU_GPOFEND0;
        break;
    case 1:
        uOffBase = NV_PAPU_GPOFBASE1;
        uOffEnd = NV_PAPU_GPOFEND1;
        break;
    case 2:
        uOffBase = NV_PAPU_GPOFBASE2;
        uOffEnd = NV_PAPU_GPOFEND2;
        break;
    case 3:
        uOffBase = NV_PAPU_GPOFBASE3;
        uOffEnd = NV_PAPU_GPOFEND3;
        break;
    }

    m_pHal->RegWrite(uOffBase, uData);
    m_pHal->RegWrite(uOffEnd, uData);

    return RM_OK;
}

// NV1BA0_PIO_SET_OUTBUF_LEN(i)
RM_STATUS
CMCP1Method::SetOutBufLen(U032 uData, U032 uIndex)
{
    U032 uOffBase;
    U032 uOffEnd;

    switch(uIndex)
    {
    case 0:
        uOffBase = NV_PAPU_GPOFBASE0;
        uOffEnd = NV_PAPU_GPOFEND0;
        break;
    case 1:
        uOffBase = NV_PAPU_GPOFBASE1;
        uOffEnd = NV_PAPU_GPOFEND1;
        break;
    case 2:
        uOffBase = NV_PAPU_GPOFBASE2;
        uOffEnd = NV_PAPU_GPOFEND2;
        break;
    case 3:
        uOffBase = NV_PAPU_GPOFBASE3;
        uOffEnd = NV_PAPU_GPOFEND3;
        break;
    }
    
    U032 uBaseAddr;
    m_pHal->RegRead(uOffBase, &uBaseAddr);

    m_pHal->RegWrite(uOffEnd, uBaseAddr + uData);
    
    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\btree\nv\btree.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Balanced Tree *******************************\
*                                                                           *
* Module: BTREE.C                                                           *
*   A generic library to balanced tree management is provided.              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nvrm.h>
#include <class.h>
#include <btree.h>
#include <os.h>
//
// Debugging support.
//
#ifdef DEBUG
//
// Validate node.
//
#define VALIDATE_NODE(pn)                   \
{                                           \
    if (btreeNodeValidate(pn) != RM_OK)     \
        return (RM_ERROR);                  \
}
#define VALIDATE_TREE(pt)                   \
{                                           \
    if (btreeTreeValidate(pt) != RM_OK)     \
        return (RM_ERROR);                  \
}
//
// Prototype validation routines.
//
RM_STATUS btreeNodeValidate(PNODE);
RM_STATUS btreeTreeValidate(PNODE);
RM_STATUS btreeDumpBranch(PNODE, U032);
RM_STATUS btreeDumpTree(PNODE);
//
// Validate a nodes branch and count values.
//
RM_STATUS btreeNodeValidate
(
    PNODE Node
)
{
    RM_STATUS status;
    
    status = RM_OK;
    if (Node == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR validating NULL NODE.\n\r");
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }
    if (((Node->LeftCount != 0) && (Node->LeftBranch == NULL))
    ||  ((Node->LeftCount == 0) && (Node->LeftBranch != NULL)))
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent left branch, Value = ", Node->Value);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                       Left count = ", Node->LeftCount);
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                      Left branch = ", Node->LeftBranch);
        DBG_BREAKPOINT();
        status = RM_ERROR;
    }
    if (((Node->RightCount != 0) && (Node->RightBranch == NULL))
    ||  ((Node->RightCount == 0) && (Node->RightBranch != NULL)))
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent right branch, Value = ", Node->Value);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                       Right count = ", Node->RightCount);
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                      Right branch = ", Node->RightBranch);
        DBG_BREAKPOINT();
        status = RM_ERROR;
    }
    return (status);
}
//
// Validate entire BTREE.
//
RM_STATUS btreeBranchValidate
(
    PNODE Node,
    U032 *NodeCount
)
{
    RM_STATUS status;
    U032 LeftCount;
    U032 RightCount;
    
    status = RM_OK;
    if (Node)
    {
        btreeNodeValidate(Node);
        if (Node->LeftBranch)
            status = btreeBranchValidate(Node->LeftBranch, &LeftCount);
        else
            LeftCount = 0;
        if (Node->RightBranch)
            status = btreeBranchValidate(Node->RightBranch, &RightCount);
        else
            RightCount = 0;
        if (Node->LeftCount != LeftCount)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent left count, Value = ", Node->Value);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                      Left count = ", Node->LeftCount);
            DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                     Left branch = ", Node->LeftBranch);
            DBG_BREAKPOINT();
            status = RM_ERROR;
        }
        if (Node->RightCount != RightCount)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent right count, Value = ", Node->Value);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                      Right count = ", Node->RightCount);
            DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                     Right branch = ", Node->RightBranch);
            DBG_BREAKPOINT();
            status = RM_ERROR;
        }
        *NodeCount = LeftCount + RightCount + 1;
    }
    return (status);
}
RM_STATUS btreeTreeValidate
(
    PNODE Trunk
)
{
    RM_STATUS status;
    U032      LeftCount;
    U032      RightCount;
    
    status = RM_OK;
    if (Trunk)
    {
        status = btreeNodeValidate(Trunk);
        if (Trunk->LeftBranch)
            status |= btreeBranchValidate(Trunk->LeftBranch, &LeftCount);
        else
            LeftCount = 0;
        if (Trunk->RightBranch)
            status |= btreeBranchValidate(Trunk->RightBranch, &RightCount);
        else
            RightCount = 0;
        if (Trunk->LeftCount != LeftCount)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent left count, Value = ", Trunk->Value);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                      Left count = ", Trunk->LeftCount);
            DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                     Left branch = ", Trunk->LeftBranch);
            DBG_BREAKPOINT();
            status = RM_ERROR;
        }
        if (Trunk->RightCount != RightCount)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent right count, Value = ", Trunk->Value);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                      Right count = ", Trunk->RightCount);
            DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                     Right branch = ", Trunk->RightBranch);
            DBG_BREAKPOINT();
            status = RM_ERROR;
        }
    }
    if (status)
        btreeDumpTree(Trunk);
    return (status);
}
//
// Dump current tree to debug port.
//
RM_STATUS btreeDumpBranch
(
    PNODE Node,
    U032  Level
)
{
    U032 i;

    if (Node)
    {
        VALIDATE_NODE(Node);
        btreeDumpBranch(Node->RightBranch, Level + 1);
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM_BTREE: ");
        for (i = 0; i < Level; i++)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, ".");
        }
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "Node         = ", Node);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "Value        = ", Node->Value);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "Left count   = ", Node->LeftCount);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "Right count  = ", Node->RightCount);
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "Left branch  = ", Node->LeftBranch);
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "Right branch = ", Node->RightBranch);
        btreeDumpBranch(Node->LeftBranch, Level + 1);
    }
    return (RM_OK);
}
RM_STATUS btreeDumpTree
(
    PNODE Trunk
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM_BTREE: ======================== Tree Dump ==========================\n\r");
    if (Trunk == NULL)
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM_BTREE: NULL\n\r");
    else
        btreeDumpBranch(Trunk, 0);
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM_BTREE: =============================================================\n\r");
    return (RM_OK);
}
#else
//
// Validate nothing.
//
#define VALIDATE_NODE(pn)
#define VALIDATE_TREE(pt)
#endif // DEBUG
//
// Insert new node into tree.
//
RM_STATUS btreeInsertBranch
(
    PNODE Node, 
    PNODE BranchNode
)
{
    RM_STATUS status;
    
    //
    // Check for duplicate names.
    //
    VALIDATE_NODE(BranchNode);
    if (Node->Value == BranchNode->Value)
        return (RM_ERR_INSERT_DUPLICATE_NAME);
    status = RM_OK;    
    if (Node->Value < BranchNode->Value)
    {
        //
        // Insert into right branch.
        //
        if (BranchNode->RightBranch)
        {
            status = btreeInsertBranch(Node, BranchNode->RightBranch);
        }
        else
        {
            BranchNode->RightBranch = Node;
            Node->RightCount        = 0;
            Node->LeftCount         = 0;
            Node->RightBranch       = NULL;
            Node->LeftBranch        = NULL;
        }
        if (status == RM_OK)    
            BranchNode->RightCount++;
    }
    else
    {
        //
        // Insert into left branch.
        //
        if (BranchNode->LeftBranch)
        {
            status = btreeInsertBranch(Node, BranchNode->LeftBranch);
        }
        else
        {
            BranchNode->LeftBranch = Node;
            Node->RightCount       = 0;
            Node->LeftCount        = 0;
            Node->RightBranch      = NULL;
            Node->LeftBranch       = NULL;
        }
        if (status == RM_OK)    
            BranchNode->LeftCount++;
    }
    return (status);
}
RM_STATUS btreeInsert
(
    PNODE  Node,
    PNODE *Trunk
)
{
    RM_STATUS status;

#ifdef DEBUG
    if (Node == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM_BTREE: Inserting NULL into BTREE!\n\r");
        DBG_BREAKPOINT();
    }
#endif // DEBUG    
    status = RM_OK;
    if (*Trunk == NULL)
    {
        *Trunk            = Node;
        Node->RightCount  = 0;
        Node->LeftCount   = 0;
        Node->RightBranch = NULL;
        Node->LeftBranch  = NULL;
    }
    else
    {
        status = btreeInsertBranch(Node, *Trunk);
    }
    VALIDATE_TREE(*Trunk);
    return (status);
}
//
// Remove node from tree.
//
RM_STATUS btreeDelete
(
    U032   Value,
    PNODE *Trunk
)
{
    PNODE Node;
    PNODE ParentNode;
    PNODE PrevNode;
    PNODE SearchNode;

    if (*Trunk == NULL)
        return (RM_ERROR);
    Node       = *Trunk;
    SearchNode = NULL;
    ParentNode = NULL;
    VALIDATE_TREE(*Trunk);
    //
    // Search tree for node being deleted.
    //
    while (Value != Node->Value)
    {
        ParentNode = Node;
        if (Value > Node->Value)
            Node = Node->LeftBranch;
        else
            Node = Node->RightBranch;
        if (Node == NULL)
            //
            // Not found.
            //
            return (RM_ERROR);
    }
    //
    // Check for branches of node to be deleted.
    //
    if (Node->RightCount + Node->LeftCount > 0)
    {
        PrevNode = NULL;
        //
        // Find best candidate to fill in place of deleted node.
        //
        if (Node->RightCount > Node->LeftCount)
        {
            //
            // Get next higher node.
            //
            SearchNode = Node->RightBranch;
            Node->RightCount--;
            while (SearchNode->LeftBranch)
            {
                SearchNode->LeftCount--;
                PrevNode   = SearchNode;
                SearchNode = SearchNode->LeftBranch;
            }
            if (PrevNode)
                PrevNode->LeftBranch = SearchNode->RightBranch;
            else
                Node->RightBranch = SearchNode->RightBranch;
        }
        else
        {
            //
            // Get next lower node.
            //
            SearchNode = Node->LeftBranch;
            Node->LeftCount--;
            while (SearchNode->RightBranch)
            {
                SearchNode->RightCount--;
                PrevNode   = SearchNode;
                SearchNode = SearchNode->RightBranch;
            }
            if (PrevNode)
                PrevNode->RightBranch  = SearchNode->LeftBranch;
            else
                Node->LeftBranch = SearchNode->LeftBranch;
        }
        //
        // Replace deleted node with best candidate.
        //
        SearchNode->LeftBranch  = Node->LeftBranch;
        SearchNode->LeftCount   = Node->LeftCount;
        SearchNode->RightBranch = Node->RightBranch;
        SearchNode->RightCount  = Node->RightCount;
    }
    //
    // Update parent branch pointers.
    //
    if (ParentNode)
    {
        if (ParentNode->LeftBranch == Node)
            ParentNode->LeftBranch  = SearchNode;
        else
            ParentNode->RightBranch = SearchNode;
    }
    else
    {
       *Trunk = SearchNode;
    }
    //
    // Update branch counts up to the deleted node.
    //    
    PrevNode = *Trunk;
    while (PrevNode && (PrevNode != SearchNode))
    {
        if (Value > PrevNode->Value)
        {
            PrevNode->LeftCount--;
            PrevNode = PrevNode->LeftBranch;
        }
        else
        {
            PrevNode->RightCount--;
            PrevNode = PrevNode->RightBranch;
        }
    }
    Node->RightCount  = 0;
    Node->LeftCount   = 0;
    Node->RightBranch = NULL;
    Node->LeftBranch  = NULL;
    VALIDATE_TREE(*Trunk);
    return (RM_OK);
}
//
// Search for node in tree.
//
RM_STATUS btreeSearch
(
    U032   Value,
    PNODE *Node,
    PNODE  Trunk
)
{
    VALIDATE_TREE(Trunk);
    *Node = Trunk;
    //
    // Search for Node Value.
    //
    while (*Node)
    {
        if (Value == (*Node)->Value)
            return (RM_OK);
        if (Value > (*Node)->Value)
            *Node = (*Node)->LeftBranch;
        else
            *Node = (*Node)->RightBranch;
    }
    return (RM_ERR_OBJECT_NOT_FOUND);
}
//
// Enumerate tree.
//
RM_STATUS btreeEnumStart
(
    U032   Value,
    PNODE *Node,
    PNODE  Trunk
)
{
    PNODE EnumNode;
    
    *Node    = Trunk;
    EnumNode = NULL;
    //
    // Search for Node Value.
    //
    while (*Node)
    {
        VALIDATE_NODE(*Node);
        if (Value == (*Node)->Value)
            return (RM_OK);
        if (Value > (*Node)->Value)
            *Node = (*Node)->LeftBranch;
        else
        {
            //
            // Save next nearest node.
            //
            EnumNode = *Node;
            *Node    = (*Node)->RightBranch;
        }
    }
    *Node = EnumNode;
    return (RM_OK);
}
RM_STATUS btreeEnumNext
(
    PNODE *Node,
    PNODE  Trunk
)
{
    PNODE EnumNode;
    U032  Value;
    
    VALIDATE_NODE(*Node);
    if ((*Node)->LeftBranch)
    {
        //
        // Start where we left off.
        //
        Value     = (*Node)->Value + 1;
        *Node    = (*Node)->LeftBranch;
        EnumNode = *Node;
        while (*Node)
        {
            VALIDATE_NODE(*Node);
            if (Value == (*Node)->Value)
                return (RM_OK);
            if (Value > (*Node)->Value)
                *Node = (*Node)->LeftBranch;
            else
            {
                //
                // Save next nearest node.
                //
                EnumNode = *Node;
                *Node    = (*Node)->RightBranch;
            }
        }
        *Node = EnumNode;
        return (RM_OK);
    }
    else
        return (btreeEnumStart((*Node)->Value + 1, Node, Trunk));
}
//
// Balance branch.
//
RM_STATUS btreeBalanceBranch
(
    PNODE *Node
)
{
    PNODE SearchNode;
    PNODE ParentNode;

    VALIDATE_NODE(*Node);
    while ((((*Node)->RightCount > (*Node)->LeftCount)
          ? ((*Node)->RightCount - (*Node)->LeftCount)
          : ((*Node)->LeftCount  - (*Node)->RightCount)) > 1)
    {
        ParentNode = NULL;
        if ((*Node)->RightCount > (*Node)->LeftCount)
        {
            SearchNode = (*Node)->RightBranch;
            while (SearchNode->LeftBranch)
            {
                ParentNode = SearchNode;
                SearchNode->LeftCount--;
                SearchNode = SearchNode->LeftBranch;
            }
            if (ParentNode)
            {
                ParentNode->LeftBranch  = SearchNode->RightBranch;
                SearchNode->RightBranch = (*Node)->RightBranch;
                SearchNode->RightCount  = (*Node)->RightCount - 1;
            }
            else
            {
                (*Node)->RightBranch = NULL;
                (*Node)->RightCount  = 0;
            }
            SearchNode->LeftBranch     = *Node;
            SearchNode->LeftCount      = (*Node)->LeftCount + 1;
            (*Node)->RightBranch = NULL;
            (*Node)->RightCount  = 0;
        }
        else
        {
            SearchNode = (*Node)->LeftBranch;
            while (SearchNode->RightBranch)
            {
                ParentNode = SearchNode;
                SearchNode->RightCount--;
                SearchNode = SearchNode->RightBranch;
            }
            if (ParentNode)
            {
                ParentNode->RightBranch = SearchNode->LeftBranch;
                SearchNode->LeftBranch  = (*Node)->LeftBranch;
                SearchNode->LeftCount   = (*Node)->LeftCount - 1;
            }
            else
            {
                (*Node)->LeftBranch = NULL;
                (*Node)->LeftCount  = 0;
            }
            SearchNode->RightBranch   = *Node;
            SearchNode->RightCount    = (*Node)->RightCount + 1;
            (*Node)->LeftBranch = NULL;
            (*Node)->LeftCount  = 0;
        }
        *Node = SearchNode;
    }
    if ((*Node)->RightBranch)
        btreeBalanceBranch(&((*Node)->RightBranch));
    if ((*Node)->LeftBranch)
        btreeBalanceBranch(&((*Node)->LeftBranch));
    return (RM_OK);
}
//
// Balance tree.
//
RM_STATUS btreeBalance
(
    PNODE *Trunk
)
{
    RM_STATUS status;
    
    status = RM_OK;
    if (*Trunk)
    {
        VALIDATE_TREE(*Trunk);
        status = btreeBalanceBranch(Trunk);
        VALIDATE_TREE(*Trunk);
    }
    return (status);    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\audio\CMCP1Method.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CMCP1Method.h                                                     *
*     Object Classes are defined in this module.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CMCP1METHODH_
#define _CMCP1METHODH_

#define METHOD_MIN_OFFSET(x)       (x)
#define METHOD_MAX_OFFSET(x)       ((x) + 0x4)

class CHalMCP1;

class CMCP1Method
{
public:
    CMCP1Method(CHalMCP1 *pHal) { m_pHal = pHal; };
    ~CMCP1Method() { };

public:
    RM_STATUS Execute(U032 uOffset, U032 uData);

private:
    CHalMCP1    *m_pHal;

    // utility
    BOOL CheckRange(U032 uOffset, U032 uMethodOffset)   
    { 
        return ((uOffset >= METHOD_MIN_OFFSET(uMethodOffset)) && 
                (uOffset < METHOD_MAX_OFFSET(uMethodOffset))?TRUE:FALSE);
    }

    // software methods
    RM_STATUS SetContextDMANotify(U032);
    RM_STATUS SetCurrentSSLContextDMA(U032);
    RM_STATUS SetCurrentInBufSGEContextDMA(U032);
    RM_STATUS SetCurrentOutBufSGEContextDMA(U032);

    // damn hacks!
    RM_STATUS SetGPState(U032);
    RM_STATUS SetCurrentOutBufSGEOffset(U032);
    RM_STATUS SetCurrentInBufSGEOffset(U032);
    RM_STATUS SetSSLSegmentOffset(U032);
    RM_STATUS SetSSLSegmentOffsetLength(U032, U032);
    RM_STATUS SetOutBufBA(U032, U032);
    RM_STATUS SetOutBufLen(U032, U032);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\class\nv\control.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CONTROL.C                                                         *
*     Control methods are implemented in this module.                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <gr.h>
#include <os.h>
#include <nv32.h>
#include "control.h"
#include "nvhw.h"

//
// FIFO database.
//

//---------------------------------------------------------------------------
//
//  Control methods.
//
//---------------------------------------------------------------------------


CTRLMETHOD NvControlMethods[] =
{
    {mthdSetObject,                 0x0000, 0x0003}
#ifdef OBSOLETE_FUNCTIONS
    {mthdSetStallNotifier,          0x0050, 0x0053},
    {mthdStallChannel,              0x0054, 0x0057}
#endif // OBSOLETE_FUNCTIONS
};

// Class representing information for channel control operations
CTRLCLASS NvControlClass =
{
    NvControlMethods,
    sizeof(NvControlMethods) / sizeof(CTRLMETHOD)
};


// Implementation of the control "Set Object" method
RM_STATUS mthdSetObject
(
    PHWINFO     pDev, 
    U032        ChID,
    U032        SubChannel,
    PCTRLMETHOD Method, 
    U032        Offset, 
    V032        Data
)
{
    U032    Context;
    POBJECT Object;
#ifdef KJK
    U032    CacheChID;
#endif

    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object.
        //
        pDev->DBfifoTable[ChID].SubchannelContext[SubChannel] = NULL;
    }
    else if (fifoSearchObject(pDev, Data, ChID, &Object) == RM_OK)
    {
    
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: SetObject on subchannel: ", SubChannel);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                      Object#: ", Object->Name);
    
        //
        // Set this as the current object for this ChID/SubChannel.
        //
        pDev->DBfifoTable[ChID].SubchannelContext[SubChannel] = Object;

        //
        // Set the current subchannel for this object, per this SetObject
        //
        Object->Subchannel = SubChannel;
        
        //
        // Update the fifo context for this subchannel back to a software object
        //
        Context = REG_RD32(NV_PFIFO_CACHE1_ENGINE);
        Context &= ~(0x03 << (SubChannel*4));
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, Context);
    }
    else
    {
        //
        // Object not found.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetObject on invalid object: ", Data);
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].SubchannelContext[SubChannel] = NULL;
    }
    
#ifdef KJK    
    //
    // Do the hash function.  Update the appropriate channel context.
    //
    fifoHashEntry(pDev->DBfifoTable[ChID].ObjectStack[SubChannel][0], ChID, &Context);
    CacheChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);
    if (CacheChID == ChID)
    {
        REG_WR32(NV_PFIFO_CACHE1_CTX(SubChannel), Context);
        REG_WR32(NV_PFIFO_CACHE1_PULL1, DRF_DEF(_PFIFO, _CACHE1_PULL1, _CTX,       _DIRTY));
    }
    else
    {
        U032  *CtxtPtr = (U032 *)pDev->Pram.FifoContextAddr;
        MEM_WR32((U032)(CtxtPtr + (ChID * 8) + SubChannel), Context);
    }
#endif // KJK
    
    return(RM_OK);
}

#ifdef OBSOLETE_FUNCTIONS
// Implementation of the control "Set Stall Notifier" method
RM_STATUS mthdSetStallNotifier
(
    PHWINFO     pDev, 
    U032        ChID,
    U032        SubChannel,
    PCTRLMETHOD Method, 
    U032        Offset, 
    V032        Data
)
{
    RM_STATUS status;

    if (!(REG_RD32(NV_PFIFO_MODE) & (1 << ChID))) 
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetStallNotifier not valid for PIO channel: ", ChID);
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].StallNotifier = NULL;
        return RM_ERR_ILLEGAL_ACTION;
    }

    status = dmaValidateObjectName(pDev, Data,
                                   ChID,
                                   &(pDev->DBfifoTable[ChID].StallNotifier));
    if (status) {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid notifier for SetStallNotifier: ", Data);
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].StallNotifier = NULL;
        return RM_ERR_BAD_OBJECT;
    }

    return RM_OK;
}


// Implementation of the control "Stall Channel" method
RM_STATUS mthdStallChannel
(
    PHWINFO     pDev, 
    U032        ChID,
    U032        SubChannel,
    PCTRLMETHOD Method, 
    U032        Offset, 
    V032        Data
)
{
    RM_STATUS status;
    U032      GetPtr;

    if (!(REG_RD32(NV_PFIFO_MODE) & (1 << ChID))) 
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: StallChannel not valid for PIO channel: ", ChID);
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].StallNotifier = NULL;
        return RM_ERR_ILLEGAL_ACTION;
    }

    // Remember the current position of the PutPtr.
    pDev->DBfifoTable[ChID].Put = REG_RD32(NV_PFIFO_CACHE1_PUT);

    // Make the Put the same as Get. The getptr will be incremented to skip 
    // over the stall channel method. Account for that when setting the putptr.
    GetPtr     = REG_RD32(NV_PFIFO_CACHE1_GET) >> 2;
    GetPtr++;
    REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT, _ADDRESS, GetPtr);

    // Mark this channel as stalled.
    pDev->DBfifoTable[ChID].IsStalledPendingVblank = TRUE;

    // Write the stall notifier.
    if (pDev->DBfifoTable[ChID].StallNotifier) 
    {
        status = notifyFillNotifierArray(pDev, pDev->DBfifoTable[ChID].StallNotifier, 
                                         0 /* info16 */, 0 /* info32 */, 
                                         Data,
                                         0 /* index */);
    }

    return RM_OK;
}

RM_STATUS mthdEnableStalledChannels
(
    PHWINFO   pDev,
    RM_STATUS status
)
{
    U032 i, currentCh, pushPending;
    BOOL isDma;
    // Check all DMA channels other than the current channel that are in use 
    // (The stalled channel cannot be the current one.)
    currentCh = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID); 
    for (i = 0; i < NUM_FIFOS; i++)
    {
        isDma = REG_RD32(NV_PFIFO_MODE) & (1 << i);
        if (pDev->DBfifoTable[i].InUse && isDma && i != currentCh && 
            pDev->DBfifoTable[i].IsStalledPendingVblank)
        {
            // This channel was stalled pending a vblank.
            // Update the put in instance memory and mark this channel as push pending.
            REG_WR32((0x714000 + i * 32), pDev->DBfifoTable[i].Put);
            pushPending = REG_RD32(NV_PFIFO_DMA);
            pushPending |= (1 << i);
            REG_WR32(NV_PFIFO_DMA, pushPending);
            // Write the stall notifier.
            if (pDev->DBfifoTable[i].StallNotifier) 
            {
                notifyFillNotifierArray(pDev, pDev->DBfifoTable[i].StallNotifier, 
                                        0 /* info16 */, 0 /* info32 */, 
                                        status,
                                        0 /* index */);
            }

            pDev->DBfifoTable[i].IsStalledPendingVblank = FALSE;
        }
    }

    return RM_OK;
}
#endif // OBSOLETE_FUNCTIONS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\dacfp.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* DAC Flat panel Control ********************\
*                                                                           *
* Module: DACFP.C                                                           *
*   Mode set for flat panel is done here.                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <dac.h>
#include <os.h>
#include <nvcm.h>
#include <edid.h>
#include <devinit.h>
#include "nvhw.h"


#if defined(NTRM) && !defined(WriteIndexed)
// For NT these are in modehw.h which is in the miniport.
VOID WriteIndexed(U032 addr, U016 datum);
U016 ReadIndexed(U032 addr, U008 reg);
#endif //NTRM

// Const strings for accessing the registry
extern char strFpMode[];

//*************************** Exported functions *****************************************

RM_STATUS dacAdjustCRTCForFlatPanel
(
    PHWINFO pDev, 
    U032 Head,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac
)
{
    U032    Ht, Hre, Vt, Vrs, Vre, Vbs, data32;
    U016    Seq, Vendor;
    U008    Cr03, Cr04, Cr05, Cr07, Cr09, Cr11, Cr25, Cr28, Cr2d, Cr33;
#if 0
    U032 cntl32;
#endif

    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);   // power on flat panel

#if 0 // If TMDS not powered up, it will hang
    //
    // First, check if the internal TMDS exists, by trying to read/write
    // the TMDS_CONTROL register. If it exists, only power up the internal
    // TMDS, if we're not using an external one.
    //
    cntl32 = DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | NV_PRAMDAC_INDIR_TMDS_PLL1;
    REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, cntl32);
    if (REG_RD32(NV_PRAMDAC_FP_TMDS_CONTROL) == cntl32)
    {
        // The internal TMDS exists, see if we're using the external TMDS
        if (REG_RD_DRF(_PRAMDAC, _FP_TEST_CONTROL, _TMDS) == NV_PRAMDAC_FP_TEST_CONTROL_TMDS_EXTERNAL)
            FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _TMDS);
    }
#endif
    // check for pixel doubled modes
    if ((GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_MONITOR) &&
        (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth < 640))
    {
        Seq = ReadIndexed(NV_PRMVIO_SRX, 1);
        Seq |= 0x800;   // divide pixel clock to double size
        WriteIndexed(NV_PRMVIO_SRX, Seq);
    }        
    // Make sure attr is set correctly
    Cr07 = REG_RD08(NV_PRMCIO_INP0__COLOR); // read 3DA to toggle (data = don't care)
    REG_WR08(NV_PRMCIO_ARX, 0x30);          // select reg 0x10, bit 5 set to access reg (not palette)
    REG_WR08(NV_PRMCIO_ARX, 0x01);          // clear bit 5

    // New rules
    // VRS = VT - 3
    // VRE = VT - 2
    // HRS = HT - 3
    // HRE = HT - 2
    // HBE = HT + 4  This is required for the overlay to sync (videos will be offset).
    CRTC_RD(NV_CIO_CRE_HEB__INDEX, Cr2d, Head);
    CRTC_RD(NV_CIO_CR_HDT_INDEX, Ht, Head);
    if (Cr2d & BIT(0))
        Ht |= BIT(8);
    Cr04 = (U008)Ht - 3; // everyone else except SGI
    // SGI is "special". We have to check for their panel and adjust HRS.
    if (pDev->Dac.CrtcInfo[Head].EDID != 0)
    {
    // EDID Version 1 version field should never be 1 on a version 2 (it's an ascii field in V2).
        if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VERSION_NUMBER_INDEX] == 1)
        {
            Vendor = (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VENDOR_ID_INDEX+1])<<8 | pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VENDOR_ID_INDEX];
            if (Vendor == 0xf84c)
            {
                Cr04 = (U008)Ht; // All modes
//                if ( (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 640) &&
//                     (pDev->Framebuffer.HalInfo.VertDisplayWidth == 480))
//                {   
//                    Cr04 = (U008)Ht+2;
//                }
            }                              
        }
    }
    CRTC_WR(NV_CIO_CR_HRS_INDEX, Cr04, Head);        // HRS
    if (Ht & BIT(8))
        Cr2d |= 8;
    CRTC_WR(NV_CIO_CRE_HEB__INDEX, Cr2d, Head);   // HRS msb
    
    CRTC_RD(NV_CIO_CR_HRE_INDEX, Hre, Head);    // read CR05 and mask 4:0
    Hre &= 0xe0;
    CRTC_WR(NV_CIO_CR_HRE_INDEX, (Ht-2) | Hre, Head);   // HRE = Ht - 2, CR04[4:0]
    
    CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
    CRTC_RD(NV_CIO_CR_HBE_INDEX, Cr03, Head);
    // HBE = HT + 4. HBE[6] = CR25[4], HBE[5] = CR5[7], HBE[4:0] = CR3[4:0]
    Cr03 &= 0xE0;   // lose 4:0, the HBE bits
    Cr03 |= (Ht + 4) & 0x1f;
    CRTC_WR(NV_CIO_CR_HBE_INDEX, Cr03, Head);     // HBE[4:0]
    CRTC_RD(NV_CIO_CR_HRE_INDEX, Cr05, Head);
    Cr05 &= 0x7f;
    if ((Ht + 4) & BIT(5))
        Cr05 |= BIT(7);
    CRTC_WR(NV_CIO_CR_HRE_INDEX, Cr05, Head);     // HBE[5]
    Cr25 &= 0xEF;
    if ((Ht + 4) & BIT(6))
        Cr25 |= BIT(4);
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, Cr25, Head);    // HBE[6]

    // gather VT bits
    CRTC_RD(NV_CIO_CR_VDT_INDEX, Vt, Head);
    if (Cr07 & BIT(0))  // bit 8 of VT
        Vt |= BIT(8);
    if (Cr07 & BIT(5))  // bit 9 of VT
        Vt |= BIT(9);
    if (Cr25 & BIT(0))  // bit 10 of VT
        Vt |= BIT(10);

    // VRS: CR10,7,25
    Vrs = Vt - 3;
    CRTC_WR(NV_CIO_CR_VRS_INDEX, Vrs, Head);
    Cr07 &= ~(BIT(7) | BIT(2)); // clear bits 7 and 2
    if (Vrs & BIT(8)) Cr07 |= BIT(2);
    if (Vrs & BIT(9)) Cr07 |= BIT(7);
    CRTC_WR(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    if (Vrs & BIT(10)) Cr25 |= BIT(2);
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
    
    // VRE: CR11[3:0]
    Vre = (Vt - 2) & 0x0f;
    CRTC_RD(NV_CIO_CR_VRE_INDEX, Cr11, Head);
    Vre |= (Cr11 & 0xf0);
    CRTC_WR(NV_CIO_CR_VRE_INDEX, Vre, Head);
    
    // VBS = VRS
    CRTC_RD(NV_CIO_CR_CELL_HT_INDEX, Cr09, Head);
    Vbs = Vrs;
                
    // write VBS            
    Cr07 &= ~BIT(3); // clear bit 3
    if (Vbs & BIT(8)) Cr07 |= BIT(3);
    Cr09 &= ~BIT(5); // clear bit 5
    if (Vbs & BIT(9)) Cr09 |= BIT(5);
    Cr25 &= ~BIT(3); // clear bit 3
    if (Vbs & BIT(10)) Cr25 |= BIT(3);
    CRTC_WR(NV_CIO_CR_VBS_INDEX, Vbs, Head);
    CRTC_WR(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, Cr09, Head);
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
            
    data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);    // usual macro won't help us here
    data32 &= ~(NV_PRAMDAC_FP_DEBUG_0_TEST_BOTH << 16);    // clear VCNTR bits
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);

    // Slave the CRTC to timing generator
    // Setup the crtc to work in slave mode (cr28).
    //
    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
    Cr28 |= BIT(7);
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head); 
    CRTC_RD(0x33, Cr33, Head);   // NV_CIO_CRE_LCD__INDEX
    Cr33 |= BIT(0);     // bit 0 is HW
    Cr33 |= BIT(1);     // bit 1 is BIOS flag
    CRTC_WR(0x33, Cr33, Head);   //NV_CIO_CRE_LCD__INDEX
                          
    return RM_OK;
}

VOID dacTMDSWrite
(
    PHWINFO pDev,
    U032    Head,
    U008    Addr,
    U008    Data
)
{
    // Due to a bug in NV15, the procedure is more complicated than intended:
    // Write the index of the register with WRITE DISABLE set.
    // Write the data.
    // Write the index with WRITE DISABLED cleared.
    // Write the index with WRITE DISABLED set.
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | Addr, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_DATA, Data, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _ENABLE) | Addr, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | Addr, Head);
}


U008 dacTMDSRead
(
    PHWINFO pDev,
    U032    Head,
    U008    Addr
)
{
    U008 Data;

    // Write the index of the register with WRITE DISABLE set.
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | Addr, Head);
    // Read the data.
    Data = (U008) ( DAC_REG_RD32(NV_PRAMDAC_FP_TMDS_DATA, Head) & 0xFF );
    return Data;
}


RM_STATUS dacSetFlatPanelMode
(
    PHWINFO pDev,
    U032    Head,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac,
    U032    FpMode,
    BOOL    commitChange
)
{
U032    data32, cntl32;
U008    est_tim1, est_tim2;
U032    fpHActive=0, fpHDispEnd=0, fpHValidStart=0, fpHValidEnd=0, fpHSyncStart=0, fpHSyncEnd=0, fpHTotal=0;
U032    fpVActive=0, fpVDispEnd=0, fpVValidStart=0, fpVValidEnd=0, fpVSyncStart=0, fpVSyncEnd=0, fpVTotal=0;
U032    fpPixClk, fpPolarity=0, M, N, P, pixels, refresh;
BOOL    ModeValid;

    RM_STATUS rmStatus = RM_OK;

    // *********************************************************
    // Power On Flat Panel TMDS and FPCLK
    // Later in dacAdjustCRTCForFlatPanel() we will power
    // down the internal TMDS if we are using an external
    // one.  -paul
    // *********************************************************
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);
    
    // *********************************************************
    // We need to stall after powering on the flat panel TMDS
    // and FPCLK and before we start programming the setup 
    // registers since there is a bit of instability immediately
    // after powerup. On win9x, we will get noise on the FP 
    // without this stall. By trial and error, we found that a 
    // 0x400000 nanosecond delay is sufficient. -paul
    // *********************************************************
    tmrDelay(pDev, 0x400000);
    // Set the scale factor in FP_DEBUG back to 0 in case the BIOS used this to get a special
    // mode, i.e. Japanese DOS. This is only done on NV10. 
    // In Windows modes, the scaling is always set by HW comparing the values in the FP timing
    // registers and the CRTC registers, so the DEBUG registers are always set to 0. 
    // For DOS 475 lines, this method doesn't work, because the scaling value is not in the HW 
    // tables on NV10, so the BIOS has to work around this by setting these DEBUG registers.
    
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_1, 0, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_2, 0, Head);
#ifndef IKOS
    if (FpMode > NV_CFGEX_GET_FLATPANEL_INFO_NATIVE)
    {
        return RM_ERROR;
    }
#else
    FpMode = NV_CFGEX_GET_FLATPANEL_INFO_NATIVE;
#endif
    // read strapping bit to set proper control width
    if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_FP_IFACE) == NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_24BIT)
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _WIDTH, _24, Head);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _WIDTH, _12, Head);
    }
    // set scaling mode
    DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _MODE, FpMode, Head);

    // If we are going native, we must reprogram the dac with new timing
    // We saved the EDID in pDev->Dac.CrtcInfo[Head].EDID[].
    if ((FpMode == NV_CFGEX_GET_FLATPANEL_INFO_NATIVE) &&
        (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL))
    {
        // Check detailed timings first
        DACFPTIMING fpTim;
        U008 block;
        
        fpPixClk = 0;
        for (block=0; block<NUM_DET_TIM; block++)           
        {
            if (edidParseDetailedTimingBlock(pDev, block, &fpTim, Head))
            {
                // Check whether this timing block is for the mode requested
                //  or the doubled mode
                ModeValid = FALSE;
                switch  (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth)
                {
                    case 1600:
                        if (fpTim.HActive == 1600)
                        {
                            if ((fpTim.VActive == 1200) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 1200)) 
                                ModeValid = TRUE;
                            if ((fpTim.VActive == 1024) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 1024))
                                ModeValid = TRUE;
                        }
                        break;
                    case 1280:
                        if (fpTim.HActive == 1280) 
                        {
                            if ((fpTim.VActive == 1024) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 1024))
                                ModeValid = TRUE;
                            if ((fpTim.VActive == 960) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 960))
                                ModeValid = TRUE;
                        }
                        break;
                    case 1024:
                    case 512:
                        if (fpTim.HActive == 1024)
                            if (fpTim.VActive == 768)
                                ModeValid = TRUE;
                        break;
                    case 800:
                    case 400:
                        if (fpTim.HActive == 800)
                            if (fpTim.VActive == 600)
                                ModeValid = TRUE;
                        break;
                    case 640:
                        if (fpTim.HActive == 640) // can be 640x480 or 640x400
                        {
                            if ((fpTim.VActive == 480) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 480))
                                ModeValid = TRUE;
                            if ((fpTim.VActive == 400) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 400))
                                ModeValid = TRUE;
                        }
                        break;
                    case 320:
                        if (fpTim.HActive == 640) // can be 640x480 or 640x400
                        {
                            if ((fpTim.VActive == 480) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 240))
                                ModeValid = TRUE;
                            if ((fpTim.VActive == 400) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 200))
                                ModeValid = TRUE;
                        }
                        break;
                }
                if (ModeValid) // Use detailed timing
                {
                    fpPixClk = fpTim.PixClk;
                    fpHActive = fpTim.HActive;
                    fpHDispEnd = fpTim.HDispEnd;
                    fpHValidEnd = fpTim.HValidEnd;
                    fpHSyncStart = fpTim.HSyncStart;
                    fpHSyncEnd = fpTim.HSyncEnd;
                    fpHValidStart = fpTim.HValidStart;
                    fpHTotal = fpTim.HTotal - 1;
                    
                    fpVActive = fpTim.VActive;
                    fpVDispEnd = fpTim.VDispEnd;
                    fpVValidEnd = fpTim.VValidEnd;
                    fpVSyncStart = fpTim.VSyncStart;
                    fpVSyncEnd = fpTim.VSyncEnd;
                    fpVValidStart = fpTim.VValidStart;
                    fpVTotal = fpTim.VTotal - 1;
                    fpPolarity = (fpTim.Flags); // assume 4&3=1 (digital), then 2=vsync, 1=hsync
                }                       
            } // if parseDetailedTimings
        }
#if IKOS // no EDID
        fpPixClk = 0;
#endif
        if (!fpPixClk)  // not found in detailed, check established
        {
            est_tim1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_1_INDEX];
            est_tim2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_2_INDEX];
            fpPolarity = 0x3;   // estab timings use positive polarities on syncs

#if IKOS // give them whatever they ask for
            est_tim1 = 0xff;
            est_tim2 = 0xff;
#endif

            // Find requested refresh rate
            pixels = pVidLutCurDac->HalObject.Dac[0].TotalWidth * pVidLutCurDac->HalObject.Dac[0].TotalHeight;
            refresh = (pVidLutCurDac->HalObject.Dac[0].PixelClock*10000) / pixels;

            // if it didn't come out exactly, set to nearest choice
            // established timings are limited to 60, 70, 72, and 75
            if (refresh < 62)
                refresh = 60;
            else 
                if (refresh < 72)
                    refresh = 70;
                else 
                    if (refresh < 74)
                        refresh = 72;
                    else
                        refresh = 75;

            switch (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth)
            {
                case 320:
                case 640:   // 640x400 is not an established timing, but we can do 640x480 panel timing and send 640x400 data within this.
                    if ((pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight==480) 
                        || (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight==240)
                        || (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight==400)
                        || (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight==200))
                    {
                        if ((refresh == 72) && (est_tim1 & EDID_ESTABLISHED_TIMING_640x480_72))
                        {
                            fpHActive =  640;
                            fpHDispEnd = 639;
                            fpHValidStart = 0;
                            fpHValidEnd = 639;
                            fpHSyncStart = 663;
                            fpHSyncEnd =  663+40;
                            fpHTotal = 831;
                            fpVActive = 480;
                            fpVDispEnd = 479;
                            fpVValidStart = 0;
                            fpVValidEnd =  479;
                            fpVSyncStart = 487;
                            fpVSyncEnd = 487+3;
                            fpVTotal = 519;
                            fpPixClk = 3150;    // 31.5 MHz
                            fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        }
                        else if ((refresh == 75) && (est_tim1 & EDID_ESTABLISHED_TIMING_640x480_75))
                        {
                            fpHActive =  640;
                            fpHDispEnd = 639;
                            fpHValidStart = 0;
                            fpHValidEnd = 639;
                            fpHSyncStart = 655;
                            fpHSyncEnd =  655+64;
                            fpHTotal = 839;
                            fpVActive = 480;
                            fpVDispEnd = 479;
                            fpVValidStart = 0;
                            fpVValidEnd =  479;
                            fpVSyncStart = 480;
                            fpVSyncEnd = 480+20;
                            fpVTotal = 480+20;
                            fpPixClk = 3150;    // 31.5 MHz
                            fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        }
                        // if none of the above, use 60 Hz
                        else if (est_tim1 & EDID_ESTABLISHED_TIMING_640x480_ANY)
                        {
                            fpHActive =  640;
                            fpHDispEnd = 639;
                            fpHValidStart = 0;
                            fpHValidEnd = 639;
                            fpHSyncStart = 655;
                            fpHSyncEnd =  655+96;
                            fpHTotal = 799;
                            fpVActive = 480;
                            fpVDispEnd = 479;
                            fpVValidStart = 0;
                            fpVValidEnd =  479;
                            fpVSyncStart = 489;
                            fpVSyncEnd = 489+2;
                            fpVTotal = 524;
                            fpPixClk = 2517;    // 25.17 MHz
                            fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        }
                    }
                    break;
                case 400:
                case 800:
                    if ((refresh == 72) && (est_tim2 & EDID_ESTABLISHED_TIMING_800x600_72))
                    {
                        fpHActive =  800;
                        fpHDispEnd = 799;
                        fpHValidStart = 0;
                        fpHValidEnd = 799;
                        fpHSyncStart = 855;
                        fpHSyncEnd =  855+120;
                        fpHTotal = 1040;
                        fpVActive = 600;
                        fpVDispEnd = 599;
                        fpVValidStart = 0;
                        fpVValidEnd =  599;
                        fpVSyncStart = 636;
                        fpVSyncEnd = 636+6;
                        fpVTotal = 666;
                        fpPixClk = 5000;    // 50 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                    }
                    else if ((refresh == 75) && (est_tim2 & EDID_ESTABLISHED_TIMING_800x600_75))
                    {
                        fpHActive =  800;
                        fpHDispEnd = 799;
                        fpHValidStart = 0;
                        fpHValidEnd = 799;
                        fpHSyncStart = 815;
                        fpHSyncEnd =  815+80;
                        fpHTotal = 1055;
                        fpVActive = 600;
                        fpVDispEnd = 599;
                        fpVValidStart = 0;
                        fpVValidEnd =  599;
                        fpVSyncStart = 600;
                        fpVSyncEnd = 600+3;
                        fpVTotal = 624;
                        fpPixClk = 4950;    // 49.5 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                    }
                    // if none of the above, use 60 Hz
                    else if ((est_tim1 & EDID_ESTABLISHED_TIMING_800x600_60) 
                        || (est_tim2 & EDID_ESTABLISHED_TIMING_800x600_ANY))
                    {
                        fpHActive =  800;
                        fpHDispEnd = 799;
                        fpHValidStart = 0;
                        fpHValidEnd = 799;
                        fpHSyncStart = 839;
                        fpHSyncEnd =  839+128;
                        fpHTotal = 1055;
                        fpVActive = 600;
                        fpVDispEnd = 599;
                        fpVValidStart = 0;
                        fpVValidEnd =  599;
                        fpVSyncStart = 600;
                        fpVSyncEnd = 600+4;
                        fpVTotal = 627;
                        fpPixClk = 4000;    // 40 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                    }
                    break;
                case 512:
                case 1024:
                    if ((refresh == 70) && (est_tim2 & EDID_ESTABLISHED_TIMING_1024x768_70))
                    {
                        fpHActive = 1024;
                        fpHDispEnd = 1023;
                        fpHValidStart = 0;
                        fpHValidEnd = 1023;
                        fpHSyncStart = 1047;
                        fpHSyncEnd = 1047+136;
                        fpHTotal = 1327;
                        fpVActive = 768;
                        fpVDispEnd = 767;
                        fpVValidStart = 0;
                        fpVValidEnd = 767;
                        fpVSyncStart = 770;
                        fpVSyncEnd = 770+6;
                        fpVTotal = 805;
                        fpPixClk = 7500;    // 75 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                    }
                    else if ((refresh == 75) && (est_tim2 & EDID_ESTABLISHED_TIMING_1024x768_75))
                    {
                        fpHActive = 1024;
                        fpHDispEnd = 1023;
                        fpHValidStart = 0;
                        fpHValidEnd = 1023;
                        fpHSyncStart = 1039;
                        fpHSyncEnd = 1039+96;
                        fpHTotal = 1311;
                        fpVActive = 768;
                        fpVDispEnd = 767;
                        fpVValidStart = 0;
                        fpVValidEnd = 767;
                        fpVSyncStart = 769;
                        fpVSyncEnd = 769+3;
                        fpVTotal = 799;
                        fpPixClk = 7875;    // 78.75 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                    }
                    else if (est_tim2 & EDID_ESTABLISHED_TIMING_1024x768_ANY)
                    {
                        fpHActive = 1024;
                        fpHDispEnd = 1023;
                        fpHValidStart = 0;
                        fpHValidEnd = 1023;
                        fpHSyncStart = 1047;
                        fpHSyncEnd = 1047+136;
                        fpHTotal = 1343;
                        fpVActive = 768;
                        fpVDispEnd = 767;
                        fpVValidStart = 0;
                        fpVValidEnd = 767;
                        fpVSyncStart = 770;
                        fpVSyncEnd = 770+6;
                        fpVTotal = 805;
                        fpPixClk = 6500;    // 65 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                    }
                    break;
                case 1280:
                    if ((refresh == 75) && (est_tim2 & EDID_ESTABLISHED_TIMING_1280x1024_75))
                    {
                        fpHActive = 1280;
                        fpHDispEnd = 1279;
                        fpHValidStart = 0;
                        fpHValidEnd = 1279;
                        fpHSyncStart = 1295;
                        fpHSyncEnd = 1295+144;
                        fpHTotal = 1687;
                        fpVActive = 1024;
                        fpVDispEnd = 1023;
                        fpVValidStart = 0;
                        fpVValidEnd = 1024;
                        fpVSyncStart = 1024;
                        fpVSyncEnd = 1024+3;
                        fpVTotal = 1065;
                        fpPixClk = 13500;   // 135 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                    }
                    break;
                default:
                    break;
            } //switch
        } // if not PixClk

        if (!fpPixClk) // If not found in detailed or established, try standard timings
        {
            U008 stdTiming1, stdTiming2, i;
            U016 hRes, vRes;

            for (i=0; i<EDID_V1_NUM_STANDARD_TIMINGS; i++) 
            {
                // Translate coded value into H + V resolution
                stdTiming1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_STANDARD_TIMING_1_INDEX + i*2];
                stdTiming2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_STANDARD_TIMING_1_INDEX + i*2 +1];
                hRes = (stdTiming1 + 31) * 8;
                switch (stdTiming2>>6)
                {
                    case 0:
                        vRes = (hRes / 16) * 10;
                        break;
                    case 1:
                        vRes = (hRes / 4) * 3;
                        break;
                    case 2:
                        vRes = (hRes / 5) * 4;
                        break;
                    case 3:
                        vRes = (hRes / 16) * 9;
                        break;
                }
                // Standard timing could also specify any refresh rate from 60-123 Hz. This only handles 60 Hz.
                if (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth == hRes) 
                {
                    switch (hRes) 
                    {
                    case 640:
                        fpHActive =  640;
                        fpHDispEnd = 639;
                        fpHValidStart = 0;
                        fpHValidEnd = 639;
                        fpHSyncStart = 655;
                        fpHSyncEnd =  655+96;
                        fpHTotal = 799;
                        fpVActive = 480;
                        fpVDispEnd = 479;
                        fpVValidStart = 0;
                        fpVValidEnd =  479;
                        fpVSyncStart = 489;
                        fpVSyncEnd = 489+2;
                        fpVTotal = 524;
                        fpPixClk = 2517;    // 25.17 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        break;
                    case 800:
                        fpHActive =  800;
                        fpHDispEnd = 799;
                        fpHValidStart = 0;
                        fpHValidEnd = 799;
                        fpHSyncStart = 839;
                        fpHSyncEnd =  839+128;
                        fpHTotal = 1055;
                        fpVActive = 600;
                        fpVDispEnd = 599;
                        fpVValidStart = 0;
                        fpVValidEnd =  599;
                        fpVSyncStart = 600;
                        fpVSyncEnd = 600+4;
                        fpVTotal = 627;
                        fpPixClk = 4000;    // 40 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                        break;
                    case 1024:
                        fpHActive = 1024;
                        fpHDispEnd = 1023;
                        fpHValidStart = 0;
                        fpHValidEnd = 1023;
                        fpHSyncStart = 1047;
                        fpHSyncEnd = 1047+136;
                        fpHTotal = 1343;
                        fpVActive = 768;
                        fpVDispEnd = 767;
                        fpVValidStart = 0;
                        fpVValidEnd = 767;
                        fpVSyncStart = 770;
                        fpVSyncEnd = 770+6;
                        fpVTotal = 805;
                        fpPixClk = 6500;    // 65 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        break;
                    case 1280:
                        if (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 960) 
                        {   // GTF
                            fpHActive = 1280;
                            fpHDispEnd = 1279;
                            fpHValidStart = 0;
                            fpHValidEnd = 1279;
                            fpHSyncStart = 1279+80;
                            fpHSyncEnd = 1279+80+136;
                            fpHTotal = 1711;
                            fpVActive = 960;
                            fpVDispEnd = 959;
                            fpVValidStart = 0;
                            fpVValidEnd = 959;
                            fpVSyncStart = 960;
                            fpVSyncEnd = 963;
                            fpVTotal = 993;
                            fpPixClk = 10200;    // 102 MHz
                            fpPolarity = VSYNC_POS | HSYNC_POS;
                        }
                        if (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 1024) 
                        {   // DMT
                            fpHActive = 1280;
                            fpHDispEnd = 1279;
                            fpHValidStart = 0;
                            fpHValidEnd = 1279;
                            fpHSyncStart = 1327;
                            fpHSyncEnd = 1327+112;
                            fpHTotal = 1687;
                            fpVActive = 1024;
                            fpVDispEnd = 1023;
                            fpVValidStart = 0;
                            fpVValidEnd = 1023;
                            fpVSyncStart = 1024;
                            fpVSyncEnd = 1024+3;
                            fpVTotal = 1065;
                            fpPixClk = 10800;    // 108 MHz
                            fpPolarity = VSYNC_POS | HSYNC_POS;
                        }
                        break;
                    case 1600:
                        fpHActive = 1600;
                        fpHDispEnd = 1599;
                        fpHValidStart = 0;
                        fpHValidEnd = 1599;
                        fpHSyncStart = 1599+104;
                        fpHSyncEnd = 1599+104+176;
                        fpHTotal = 2159;
                        fpVActive = 1024;
                        fpVDispEnd = 1023;
                        fpVValidStart = 0;
                        fpVValidEnd = 1023;
                        fpVSyncStart = 1024;
                        fpVSyncEnd = 1024+3;
                        fpVTotal = 1060;
                        fpPixClk = 16000;    // 160 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        break;
                    }
                }
                if (fpPixClk) // found? break for loop
                    break;
            } // for loop

        }
        if (!fpPixClk) // Did we find a detailed, established, or standard timings for the requested mode?
        {
            // No, did we find any valid timings in the EDID? Then fall back to adapter scaling.
            if (pDev->Dac.fpPixClk) 
            {
                // These values were gotten when we read the Edid. It should be the preferred mode.
                fpHActive = pDev->Dac.fpHActive;
                fpHDispEnd = pDev->Dac.fpHDispEnd;
                fpHValidStart = pDev->Dac.fpHValidStart;
                fpHValidEnd = pDev->Dac.fpHValidEnd;
                fpHSyncStart = pDev->Dac.fpHSyncStart;
                fpHSyncEnd = pDev->Dac.fpHSyncEnd;
                fpHTotal = pDev->Dac.fpHTotal - 1;
                fpVActive = pDev->Dac.fpVActive;
                fpVDispEnd = pDev->Dac.fpVDispEnd;
                fpVValidStart = pDev->Dac.fpVValidStart;
                fpVValidEnd = pDev->Dac.fpVValidEnd;
                fpVSyncStart = pDev->Dac.fpVSyncStart;
                fpVSyncEnd = pDev->Dac.fpVSyncEnd;
                fpVTotal = pDev->Dac.fpVTotal - 1;
                fpPixClk = pDev->Dac.fpPixClk;
                fpPolarity = (pDev->Dac.fpFlags); // assume 4&3=1 (digital), then 2=vsync, 1=hsync
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _MODE, 0, Head);   // scaled mode
            }
            else
            {
                // No EDID info: set 640x480. We need valid timing, especially the clock, so we will generate interrupts
                // and notifiers which depend on vblank interrupt will get written.
                fpHActive =  640;
                fpHDispEnd = 639;
                fpHValidStart = 0;
                fpHValidEnd = 639;
                fpHSyncStart = 655;
                fpHSyncEnd =  655+96;
                fpHTotal = 799;
                fpVActive = 480;
                fpVDispEnd = 479;
                fpVValidStart = 0;
                fpVValidEnd =  479;
                fpVSyncStart = 489;
                fpVSyncEnd = 489+2;
                fpVTotal = 524;
                fpPixClk = 2517;    // 25.17 MHz
                fpPolarity = VSYNC_NEG | HSYNC_NEG;
                return RM_ERROR;
            }
        }
    }
    else if ((GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR))
    {
        // These values are gotten from the LUT_CURSOR_DAC class
        fpHActive = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
        fpHDispEnd = fpHActive - 1;
        fpHValidStart = 0;
        fpHValidEnd = fpHDispEnd;
        fpHSyncStart = pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart - 1;
        fpHSyncEnd = fpHSyncStart + pVidLutCurDac->HalObject.Dac[0].HorizontalSyncWidth;
        fpHTotal = pVidLutCurDac->HalObject.Dac[0].TotalWidth - 1;

        fpVActive = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
        // check for scanline doubled modes
        if (pVidLutCurDac->HalObject.Dac[0].Format.DoubleScanMode)
            fpVActive *= 2;

        fpVDispEnd = fpVActive - 1;
        fpVValidStart = 0;
        fpVValidEnd = fpVDispEnd;
        fpVSyncStart = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart - 1;
        fpVSyncEnd = fpVSyncStart + pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight;
        fpVTotal = pVidLutCurDac->HalObject.Dac[0].TotalHeight - 1;

        fpPixClk = pVidLutCurDac->HalObject.Dac[0].PixelClock;
        // make sure we're not exceeding our max pixclk for this head
        RM_ASSERT((fpPixClk * 10000) <= GETCRTCHALINFO(pDev, Head, PCLKLimit32bpp));

        fpPolarity = ((!pVidLutCurDac->HalObject.Dac[0].Format.VerticalSyncPolarity) << 2) | 
                     ((!pVidLutCurDac->HalObject.Dac[0].Format.HorizontalSyncPolarity) << 1);
    }
    else    // FP not native mode, restore full resolution
    {
        // These values were gotten when we read the Edid.
        fpHActive = pDev->Dac.fpHActive;
        fpHDispEnd = pDev->Dac.fpHDispEnd;
        fpHValidStart = pDev->Dac.fpHValidStart;
        fpHValidEnd = pDev->Dac.fpHValidEnd;
        fpHSyncStart = pDev->Dac.fpHSyncStart;
        fpHSyncEnd = pDev->Dac.fpHSyncEnd;
        fpHTotal = pDev->Dac.fpHTotal - 1;
        fpVActive = pDev->Dac.fpVActive;
        fpVDispEnd = pDev->Dac.fpVDispEnd;
        fpVValidStart = pDev->Dac.fpVValidStart;
        fpVValidEnd = pDev->Dac.fpVValidEnd;
        fpVSyncStart = pDev->Dac.fpVSyncStart;
        fpVSyncEnd = pDev->Dac.fpVSyncEnd;
        fpVTotal = pDev->Dac.fpVTotal - 1;
        fpPixClk = pDev->Dac.fpPixClk;
        fpPolarity = (pDev->Dac.fpFlags); // assume 4&3=1 (digital), then 2=vsync, 1=hsync
    }
    // Work-around for HW bug: can't set HT lsb's to 00 in 1280 mode.
    if (fpHActive == 1280)
        if (!(fpHTotal & 0x03))
            fpHTotal += 1;  // if x...x00, make it 01
    // We are switching modes, so program the DAC with new timings.
    // If switching between scaled and centered, this isn't necessary, but it won't hurt.
    if (fpPolarity & VSYNC_POS)
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _POS, Head);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _NEG, Head);
    }
    if (fpPolarity & HSYNC_POS)
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _POS, Head);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _NEG, Head);
    }
    // Pixel Clock
#ifdef NV11_PCLK_HACK
    if (fpHActive == 1024)
    {
        fpPixClk = 5000;    // lower pixclk on NV11 for demo. 
    }
#endif
    dacCalcMNP(pDev, Head, fpPixClk, &M, &N, &P);
    // VPLL doesn't follow the pattern of addressing by adding a fixed offset. VPLL2 has an address in the same range (680xxx) as the
    // primary head. This makes the DAC_REG_WR32 macros useless.
    if (Head == 0) 
    {
        REG_WR32(NV_PRAMDAC_VPLL_COEFF, DRF_NUM(_PRAMDAC, _VPLL_COEFF, _MDIV, M) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _NDIV, N) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _PDIV, P));
    }
    else
    {
        // Tell DAC to use programmed M,N,P values, then give it M,N,P.
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _MSOURCE, _PROG); 
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V1SOURCE, _PROG); 
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _NVSOURCE, _PROG); 
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V2SOURCE, _PROG); 
        REG_WR32(NV_PRAMDAC_VPLL2_COEFF, DRF_NUM(_PRAMDAC, _VPLL_COEFF, _MDIV, M) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _NDIV, N) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _PDIV, P));
    }

    //
    // Set Link depending on which head we want to drive fp.
    //
    if (IsNV11(pDev))
    {
        // Some boards have only one link, and that should be connected to the second head
        if (Head == 0)
            FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK1, _SEL_FPCLK1);
        else
            FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK2, _SEL_FPCLK2);

        // Mobile is dual link LVDS, so both links are used
        if (pDev->Power.MobileOperation)
            if (Head == 0)
            {
                // If using Head==0, both links use primary clock
                FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK1, _SEL_FPCLK1);
                FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK2, _SEL_FPCLK1);
            }
            else
            {
                // If using Head==1, both links use secondary clock
                FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK1, _SEL_FPCLK2);
                FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK2, _SEL_FPCLK2);
            }
    }

    //
    // If an integrated TMDS exists (we can read/write TMDS_CONTROL),
    // set the PLL values there, as well.
    //
    // TMDS access is in the address range of the primary head. (680xxx)
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);     // FP on to access TMDS

    cntl32 = DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | NV_PRAMDAC_INDIR_TMDS_PLL1;
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, cntl32, Head);

    if (DAC_REG_RD32(NV_PRAMDAC_FP_TMDS_CONTROL, Head) == cntl32) // IF TMDS present
    {
        U008 tmds_pll0, tmds_pll1, tmds_pll2;

        // make sure PLL is enabled, or we'll hang
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head); 

        if (IsNV15(pDev))
        {
            // TMDS settings

            // Run BIOS TMDS single, link A or link B table
            if ( Head == 0 )
            {
                rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_TMDS_SINGLE_A );
            }
            else
            {
                rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_TMDS_SINGLE_B );
            }

            if ( rmStatus != RM_OK )
            {
                BOOL isMode4 = FALSE;

                // clear error
                rmStatus = RM_OK;

                // Determine PLL values based on pixclk
                if (fpPixClk <= 6400)
                {         // pixclk <= 64MHz
                    tmds_pll0 = 0x31;
                    tmds_pll1 = 0x5F;
                }
                else if (fpPixClk == 6500)
                {  // pixclk == 65MHz
                    tmds_pll0 = 0x31;
                    tmds_pll1 = 0x49;
                }
                else if (fpPixClk <= 8000)
                {  // pixclk <= 80Mhz
                    tmds_pll0 = 0x29;
                    tmds_pll1 = 0x4E;
                }
                else if (fpPixClk <= 10000)
                {  // pixclk <= 100Mhz
                    tmds_pll0 = 0x29;
                    tmds_pll1 = 0x49;
                }
                else
                {                        // pixclk > 100MHz
                    tmds_pll0 = 0x30;
                    tmds_pll1 = 0x4F;
                    isMode4 = TRUE;
                }

                if (isMode4)
                {
                    static U032 mode4_delay = 1000000;  // delay 1 ms between programming

                    //
                    // To set TMDS_PLL0 to 0x30, we need to transition through 0x31 first
                    // (setting TMDS_PLL1 both times), with a little delay in between.
                    //
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL0, 0x31);         // set PLL0
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL1, tmds_pll1);    // set PLL1
                    tmrDelay(pDev, mode4_delay);
                }

                dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL0, tmds_pll0);    // set PLL0
                dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL1, tmds_pll1);    // set PLL1
            }
        }
        else
        {
            // First, check if we're in TMDS or LVDS mode
            // Currently looking at one of the registers
            // TODO: should look at the BIOS tables instead?
            DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, 
                         DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | NV_PRAMDAC_INDIR_TMDS_MODE,
                         Head);
            if ((DAC_REG_RD32(NV_PRAMDAC_FP_TMDS_DATA, Head) & 0x1) || pDev->Power.MobileOperation)
            {
                // LVDS mode

                // Run BIOS LVDS dual table
                rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_LVDS_DUAL );

                if ( rmStatus == RM_OK )
                {
                    // Head selection does not occur in BIOS, so we do this manually
                    // after the other stuff is done.
                    if (Head == 0)
                    {
                        U008 Data;
                        // read register NV_PRAMDAC_INDIR_TMDS_MODE in LINK B
                        Data = dacTMDSRead(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE );
                        // Or with 0x0C to say get from alternate source
                        // write register back to Link B
                        dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE, (U008)( Data | 0x0C ));
                    }
                    else
                    {
                        U008 Data;
                        // read register NV_PRAMDAC_INDIR_TMDS_MODE in LINK A
                        Data = dacTMDSRead(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE );
                        // Or with 0x0C to say get from alternate source
                        // write register back to Link A
                        dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE, (U008)( Data | 0x0C ));
                    }
                }
                else
                {
                    // We failed to process the table, so do it the hardcoded way

                    if (!IsNV11(pDev))
                    {
                        // We only know how to do NV11
                        return RM_ERROR;
                    }

                    // Clear the error
                    rmStatus = RM_OK;

                    // Setup Link0
                    dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_PLL0, 0x32);
                    dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_PLL1, 0xF7);
                    dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x3A);
                    dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);
                    dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_IDLY, 0x00);
                    if (Head == 0)
                        dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_MODE, 0x81);
                    else
                        dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_MODE, 0x8D);
                    dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_LVDS, 0x6E);

                    // Setup Link1
                    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, 0x1101111, 0x1);

                    dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_PLL0, 0x32);
                    dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_PLL1, 0xF7);
                    dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x3A);
                    dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);
                    dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_IDLY, 0x00);
                    if (Head == 0)
                        dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE, 0x8D);
                    else
                        dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE, 0x81);
                    dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_LVDS, 0x2E);

                    // Setup both Links to run at 1/2 the fpclk frequency
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _FPCLK_RATIO, _DB2, 0);
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _FPCLK_RATIO, _DB2, 1);
                    tmrDelay(pDev, 2000000);    // delay to let PLL's stabilize
                }
            }
            else
            {
                // TMDS settings

                // Run BIOS TMDS single, link A or link B table
                if ( Head == 0 )
                {
                    rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_TMDS_SINGLE_A );
                }
                else
                {
                    rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_TMDS_SINGLE_B );
                }

                if ( rmStatus != RM_OK )
                {
                    // We failed to process the table, so do it the hardcoded way

                    if (!IsNV11(pDev))
                    {
                        // We only know how to do NV11
                        return RM_ERROR;
                    }

                    // Clear the error
                    rmStatus = RM_OK;

                    // Determine PLL values based on pixclk
                    if (fpPixClk <= 6500) {         // pixclk <= 65MHz
                        tmds_pll0 = 0xB2;
                        tmds_pll1 = 0xF7;
                        tmds_pll2 = 0x00;
                    } else {                        // pixclk > 65MHz
                        tmds_pll0 = 0x32;
                        tmds_pll1 = 0x6F;
                        tmds_pll2 = 0x20;
                    }

                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL0, tmds_pll0);    // set PLL0
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL1, tmds_pll1);    // set PLL1
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL2, tmds_pll2);    // set PLL2

                    // Link0 gets data from CRTC0; Link1 gets data from CRTC1, so set "normal" for DINSEL
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_MODE, 0x80);    // get data from CRTCx

                }
            }
        }
    }


    if (IsNV11(pDev))
    {
        U032    HSyncOffset;
        
        // For NV11, there is a clock synchronization problem when scaling:
        // At H display end, the CRTC clock must be held off until sync start, but if the period between end of active display
        // and sync start is too small, there is not enough time to synchronize, so we will reduce HCRTC, which is the synchronization
        // point.
        HSyncOffset = fpHSyncStart - fpHActive;    // find period between display end and sync start
        if (HSyncOffset < 28) 
        {
            fpHActive = fpHActive - (28 - HSyncOffset); // reduce HCRTC by an appropriate amount
        }
    }

    data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, (data32 & 0xfff0ffff) | 0x00020000, Head);
    
    DAC_REG_WR32(NV_PRAMDAC_FP_HCRTC, fpHActive, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HDISPLAY_END, fpHDispEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_START, fpHValidStart, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_END, fpHValidEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_START, fpHSyncStart, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_END, fpHSyncEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HTOTAL, fpHTotal, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VCRTC, fpVActive, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VDISPLAY_END, fpVDispEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_START, fpVValidStart, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_END, fpVValidEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_START, fpVSyncStart, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_END, fpVSyncEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VTOTAL, fpVTotal, Head);
    
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);

    if (commitChange)
    {
        // write this mode to the registry
        // fill in the path to the registry key--last character is the display number
       return osWriteRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strFpMode, FpMode);
    }

    return RM_OK;
}

// TODOMK: What is this for?  Can it be replaced with BIOS table usage?
RM_STATUS dacPowerOnMobilePanel
(
    PHWINFO pDev,
    U032    Head
)
{

    U008 lock;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"dacPowerOnMobilePanel on Head");
    DBG_PRINT_VALUE(DEBUGLEVEL_TRACEINFO,Head);
    
    // make sure PLL is enabled, or we'll hang
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);     // FP on to access TMDS

    // make sure PLL is enabled, or we'll hang
    FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE); 

	// Enable Head2 GPIO
    lock = UnlockCRTC(pDev, 1);
    CRTC_WR(NV_CIO_GPIO23_INDEX, 0x00, 1);
    RestoreLock(pDev, 1, lock);

#ifdef MACOS
	//MACOS specific panel init
	
	// Disable panel I/O
    dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x62);    // set PLL0
    dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x62);    // set PLL0

	// Enable GPIO3 to a zero, set breaker
    REG_WR32(NV_PCRTC_GPIO_EXT, 0x2200);

	// Enable panel I/O
    dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x3A);    // set PLL0
    dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x3A);    // set PLL0
#endif
   
#ifndef MACOS
	// Disable panel I/O
    dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x52);    // set PLL0
    dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x52);    // set PLL0
    
    // Wait a bit
    tmrDelay(pDev, 1000000);

    dacTMDSWrite(pDev, 0, 0xF7, 1);

    tmrDelay(pDev, 1000000);

    dacTMDSWrite(pDev, 0, 0x94, 1);

    // Wait a bit
    tmrDelay(pDev, 100000);

    // Let DivBy7 go again -- this leaves us in LVDS
    dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);    // set PLL1
    dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);    // set PLL1

    // Wait a moderate bit
    tmrDelay(pDev, 2000000);
#endif

    //
    // Power on the BL so we can see
    //
    REG_WR32(NV_PCRTC_GPIO_EXT, 0x2211);

	return (RM_OK);
}

RM_STATUS dacPowerOffMobilePanel
(
    PHWINFO pDev,
    U032    Head
)
{
    
    U008 lock;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"dacPowerOffMobilePanel on Head");
    DBG_PRINT_VALUE(DEBUGLEVEL_TRACEINFO,Head);
    
	// Enable Head2 GPIO
    lock = UnlockCRTC(pDev, 1);
    CRTC_WR(NV_CIO_GPIO23_INDEX, 0x00, 1);
    RestoreLock(pDev, 1, lock);

#ifndef MACOS
	// make sure PLL is enabled, or we'll hang
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, 0);     // FP on to access TMDS
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, 1);     // FP on to access TMDS

    // BL disable
	REG_WR32(NV_PCRTC_GPIO_EXT, 0x2210);

	// Disable panel I/O
    dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x52);    // set PLL0
    dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x52);    // set PLL0

    tmrDelay(pDev, 1000000);
#endif

	REG_WR32(NV_PCRTC_GPIO_EXT, 0x2200);

	return (RM_OK);
}

void dacZeroPWMController(PHWINFO pDev)
{
	REG_WR32(NV_PBUS_PWM,0);
}

void dacSetPWMController(PHWINFO pDev)
{
	REG_WR32(NV_PBUS_PWM,pDev->Dac.fpPWMRegisterContents);
}

void dacGetPWMController(PHWINFO pDev)
{
	U032 NvPbusPwmHighValue,ControllerRegisterValue,FpDynamicRange;
    U032 NvPbusPwmPeriodValue;
    U032 MinPeriodValue,RelativePeriod;
	
	//we need to init the variable for the flat panel brightness
    if(!pDev->Dac.fpRelativeBrightness)
    {
    	ControllerRegisterValue=REG_RD32(NV_PBUS_PWM);
    	NvPbusPwmHighValue=(ControllerRegisterValue>>16)&0x7fff;
    	NvPbusPwmPeriodValue=ControllerRegisterValue&0x7fff;
    	
    	//a kludge - 40% to 100%
    	MinPeriodValue=((NvPbusPwmPeriodValue*40)+50)/100;
    	
    	FpDynamicRange=NvPbusPwmPeriodValue-MinPeriodValue;
    	
    	RelativePeriod=NvPbusPwmHighValue-MinPeriodValue;
    	
    	pDev->Dac.fpRelativeBrightness=(((RelativePeriod*10000)/(FpDynamicRange*10000/255))*10+5)/10;
    	
    	//store this raw PWM value also into the DAC.fpPWMRegisterContents save/restore var.
    	pDev->Dac.fpPWMRegisterContents=ControllerRegisterValue;
    }
}

RM_STATUS  dacSetFlatPanelBrightness(PHWINFO pDev, U032 Head, U032 Brightness, U032 Frequency, U032 MaxPercent, U032 MinPercent,BOOL ControllerIsOn)
{

	
	U032 TicksNeededForClock;
	U032 TicksNeededForHigh;
	
	U032 ControlValue=0;
	
	//clip if necessary
	if(Brightness>255)
	{
		Brightness=255;
	}
	
	//enable PWM output
	if(ControllerIsOn)
	{
		FLD_WR_DRF_DEF(_PBUS,_PWM,_EN,_ENABLED);
	}
	else
	{
		FLD_WR_DRF_DEF(_PBUS,_PWM,_EN,_DISABLED);
	}
	
	TicksNeededForClock=GetTicksForFrequency(Frequency);
	TicksNeededForHigh=GetRequiredTickCount(Frequency,MaxPercent,MinPercent,Brightness);
	
	//program the chip
	FLD_WR_DRF_NUM(_PBUS,_PWM,_HI,TicksNeededForHigh);
	FLD_WR_DRF_NUM(_PBUS,_PWM,_PERIOD,TicksNeededForClock);
	
	//store multiplier for get
	pDev->Dac.fpRelativeBrightness=Brightness;
	
	//store the raw PWM value in case someone triggers an on without an off
	pDev->Dac.fpPWMRegisterContents = REG_RD32(NV_PBUS_PWM);
			
	return RM_OK;
}

RM_STATUS  dacGetFlatPanelBrightness(PHWINFO pDev, U032 Head, U032 * Brightness,BOOL * ControllerIsOn)
{
	U032 NvPbusPwmEnable;
	
	//read register
	NvPbusPwmEnable=REG_RD_DRF(_PBUS,_PWM,_EN);
	
	//retrieve last brightness setting
	*Brightness=pDev->Dac.fpRelativeBrightness;
	
	//check the status of the control bit
	if(NvPbusPwmEnable)
	{
		*ControllerIsOn=TRUE;
	}
	else
	{
		*ControllerIsOn=FALSE;
	}
	
	return RM_OK;
}

U032 GetAbsoluteDifference(U032 value_a, U032 value_b)
{
	if(value_a>value_b)
	{
		return value_a-value_b;
	}
	else
	{
		return value_b-value_a;
	}
}

U032 GetTicksForFrequency(U032 Frequency)
{
	//this replaced alot of code - overcomplication on my part
	return 33333333/Frequency;
}

U032 GetPortionOfTotalSizeBasedOnPercentage(U032 TotalSize,U032 Percentage)
{

	//do calculation, round up
	return (((TotalSize*Percentage)+50)/100);
}

U032 DetermineFrequencyFromTickCount(U032 NumTicks)
{
	return ((333333330/NumTicks)+5)/10;
}

U032 GetRequiredTickCount(U032 Frequency,U032 MaxPercent,U032 MinPercent,U032 BaseMultiplier)
{
	U032 TicksInClockPeriod;
	U032 MaxTicks;
	U032 MinTicks;
	U032 DynamicRange;
	U032 PreliminaryTickCount;

	TicksInClockPeriod=GetTicksForFrequency(Frequency);
	MaxTicks=GetPortionOfTotalSizeBasedOnPercentage(TicksInClockPeriod,MaxPercent);
	MinTicks=GetPortionOfTotalSizeBasedOnPercentage(TicksInClockPeriod,MinPercent);

	DynamicRange=MaxTicks-MinTicks;

	PreliminaryTickCount=MinTicks+(((((DynamicRange*10)/255)+5)/10)*BaseMultiplier);
	
	if (PreliminaryTickCount>MaxTicks)
	{
		//if rounding produces a number too large, clip it
		PreliminaryTickCount=MaxTicks;
	}
	
	return PreliminaryTickCount;
}

BOOL dacIsFlatPanelOn(PHWINFO pDev,U032 Head)
{
    U008 lock;
    
	// Enable Head2 GPIO
    lock = UnlockCRTC(pDev, 1);
    CRTC_WR(NV_CIO_GPIO23_INDEX, 0x00, 1);
    RestoreLock(pDev, 1, lock);

    if((BIT(4)|BIT(6))&REG_RD32(NV_PCRTC_GPIO_EXT))
    {
        return TRUE;
    }
    
    return FALSE;
}

/*
//we are going to memorize the setting that we spec'd before, because we cannot reliably reproduce the same setting as
//was spec'd for. The specing is more like a hash than an exact formula. And hashes cannot be reversed easily....
U032 DetermineMultiplierForCurrentPeriod(PHWINFO pDev, U032 ClockTicksTotal,U032 DutyCycle)
{
	U032 DynamicRange,MaxTicks,MinTicks,PreliminaryMultiplier;

	MaxTicks=GetPortionOfTotalSizeBasedOnPercentage(ClockTicksTotal,pDev->Dac.fpMaxPercentDutyCycle);
	MinTicks=GetPortionOfTotalSizeBasedOnPercentage(ClockTicksTotal,pDev->Dac.fpMinPercentDutyCycle);
	DynamicRange=MaxTicks-MinTicks;
	
	PreliminaryMultiplier=((((DutyCycle-MinTicks)*10000)/(DynamicRange*10000/255))*10+5)/10;
	
	if(PreliminaryMultiplier>255)
	{
		PreliminaryMultiplier=255;
	}
	
		if(DutyCycle==MaxTicks)
		{
			PreliminaryMultiplier=255;
		}
		
		if(DutyCycle==MinTicks)
		{
			PreliminaryMultiplier=0;
		}
	
	
	return PreliminaryMultiplier;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\dac.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Manager ******************************\
*                                                                           *
* Module: DAC.C                                                             *
*   The DAC control management is updated here.                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include <i2c.h>
#include "nvhw.h"
#include <vga.h>
#include <nvcm.h>
#include <edid.h>
#include <tv.h>
#include <devinit.h>
#include <smp.h>

/* This file simulates the NV arbitor */
#include <arb_fifo.h>


// Const strings for accessing the registry

extern U008    CH_Init[];
// The "leaf" subkeys are OS-independent

#ifdef NTRM    
char strDisplayType[] = "Display Type";
char strDisplay2Type[] = "Display2 Type";
char strTVtype[] = "TV Type";
char strTVOutType[] = "TV Out";
char    strFpMode[] = "FlatPanelMode";
#else
extern char strDisplayType[];
extern char strDisplay2Type[];
extern char strTVtype[];
extern char strTVOutType[];
extern char strFpMode[];
#endif // NTRM

#define RED_OUT_300MV   0x800001A0
#define MAXCRTRETRIES   5

// remove this after all drivers switch to the new devices based API.
static BOOL using_new_api = FALSE;

//
// Set Display Power Managememnt Level.
//
RM_STATUS dacSetDpmLevel
(
    PHWINFO      pDev
)
{
    switch (pDev->Dac.DpmLevel)
    {
        default:
            break;
    }
    return (RM_OK);
}

RM_STATUS dacLoadWidthDepth
(
   PHWINFO pDev,
   U032    Head
)
{
    U032 data;

    switch (pDev->Dac.HalInfo.Depth)
    {
        case 8:
            data = NV_CIO_CRE_PIXEL_FORMAT_8BPP;
            break;
        case 15:
        case 16:
            data = NV_CIO_CRE_PIXEL_FORMAT_16BPP;
            break;
        case 24:
        case 30:
        case 32:
        default:
            data = NV_CIO_CRE_PIXEL_FORMAT_32BPP;
            break;
    }
    //
    // Write the CRTC register
    //
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);

    return (RM_OK);
}

//
// Find closest DAC PLL parameters for a given frequency.
//
RM_STATUS dacCalcPLL
(
    PHWINFO pDev 
)
{
    U032 DeltaNew;
    U032 DeltaOld;
    U032 VClk;
    U032 Freq;
    U032 M;
    U032 N;
    U032 P;

    //
    // Calc VPLL.
    //
    DeltaOld = 0xFFFFFFFF;
    VClk     = pDev->Dac.HalInfo.VClk / 1000;
    //
    // Calculate frequencies using KHz to keep the math precision inside 32 bits.
    //
    for (P = 1; P <= 8; P <<= 1)
    {
        Freq = VClk * P;
        //
        // Bound the parameters to the internal frequencies of the DAC.
        //
        if ((Freq >= 64000) && (Freq <= 170000))
        {
            for (M = 7; M <= 12; M++)
            {
                N    = VClk * P * M / 12096;
                Freq = N * 12096 / P / M;
                if (Freq > VClk)
                    DeltaNew = Freq - VClk;
                else
                    DeltaNew = VClk - Freq;
                if (DeltaNew < DeltaOld)
                {
                    //
                    // Closer match.
                    //
                    pDev->Dac.HalInfo.VPllM = M;
                    pDev->Dac.HalInfo.VPllN = N;
                    pDev->Dac.HalInfo.VPllO = 1;
                    if (P==8)
                        pDev->Dac.HalInfo.VPllP = 3;
                    else if (P==4)
                        pDev->Dac.HalInfo.VPllP = 2;
                    else if (P==2)
                        pDev->Dac.HalInfo.VPllP = 1;
                    else 
                        pDev->Dac.HalInfo.VPllP = 0;
                    DeltaOld = DeltaNew;
                }
            }
        }
    }
    return (RM_OK);
}


//
//       dacCalcMNP - Return the PLL values for a specified frequency
//
//          Clock frequency in MHz * 100
//
// The algorithm is constrained to keep within 0.5% error
// to remain inside the VBE spec.
// However, if you have a choice of what frequencies you
// request, try to avoid the following requested frequencies
// when you get above 300MHz, as they require M values > 3.
//
//  14.31818 MHz
// 29739 - 29918
// 30219 - 30393
// 31178 - 31343
// 31658 - 31818
// 32617 - 32767
// 33097 - 33243
// 34056 - 34193
// 34536 - 34668
//
//  13.5000 MHz
// 29397 - 29552
// 29849 - 30000
// 30754 - 30896
// 31206 - 31344
// 32110 - 32239
// 32563 - 32767
// 33467 - 33582
// 33919 - 34030
// 34824 - 34926
//
U032 dacCalcMNP(
    PHWINFO  pDev,
    U032     Head,
    U032     Clock,
    U032    *M,    
    U032    *N,    
    U032    *P    
)
{
    U016  crystalFreq;
    U032  vclk;
    U016  vclkClosest = 0;
    U016  deltaOld;
    U016  bestM = 0;
    U016  bestP = 0;
    U016  bestN = 0;
    U016  lowM;
    U016  highM;
    U016  lowP, highP;
    U032  hiVclk1, hiVclk2;
    U032  FminVco, FmaxVco;
    
    U016  powerP;
    U016  m;
    U016  n;
    U016  i, j;
    U032  lwv, lwv2;
    
    U016  lwvs, vclks;
    U016  t;
    
    vclk = (U032)(Clock * 10);     // Make KHz
    
    deltaOld = 0xFFFF;
    hiVclk1 = 250000;
    hiVclk2 = 340000;
    lowP  = 0;
    highP = 4;

    // if initDac() has run then FminVco and FmaxVco will be set.
    // But we might be called during devinit processing prior to
    //    initDac(), so we need a fallback...
    // NOTE: these defaults duplicated in initDac()
    if ((pDev->Dac.FminVco == 0) || (pDev->Dac.FmaxVco == 0))
    {
        if (IsNV15orBetter(pDev)) {
            if (IsNV15MaskRevA01(pDev))
                pDev->Dac.FminVco = 200000;
            else
                pDev->Dac.FminVco = 250000;
            
            pDev->Dac.FmaxVco = pDev->Dac.FminVco * 2; 
        } else {
            pDev->Dac.FminVco = 128000;
            pDev->Dac.FmaxVco = 256000;
        }
    }
    
    FminVco = pDev->Dac.FminVco;
    FmaxVco = pDev->Dac.FmaxVco;

    // Apply any adjusts needed to FminVco/FmaxVco.
    //
    // 1). Make sure vclk is not so low that we'll miss the whole VCO range.
    //     Adjust FminVco to hit with the highest P (post divide).
    //
    if ((vclk << highP) < FminVco)
        FminVco = vclk << highP;

    //
    // 2). Also, check if two consecutive P values would cause us to miss
    //     the whole VCO range, where the first P is beneath FminVco and
    //     the next P is above FmaxVco.
    //
    for (powerP = lowP; powerP < highP; powerP++)
    {
        lwv = vclk << powerP;
        if ((lwv < FminVco) && ((lwv << 1) > FmaxVco))
        {
            // adjust FminVco or FmaxVco, whichever is closer
            if ((FminVco - lwv) < ((lwv << 1) - FmaxVco))
                FminVco = lwv;
            else
                FmaxVco = (lwv << 1);
        }
    }

    //
    // 3). Let a high vclk set the upper bound.
    //
    if (vclk > FmaxVco)
        FmaxVco = vclk;

    //
    // For NV15, we've got a bit in CR33 that indicates we're setting the
    // PLL in the "upper" VCO range.
    //
    if (IsNV15(pDev))
    {
        U008 lock, cr33;

        // unlock the extended regs
        CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, Head);
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

        // put NV15 into NV15 VPLL VCO programming mode
        CRTC_RD(NV_CIO_CRE_LCD__INDEX, cr33, Head);
        cr33 |= (1 << DRF_SHIFT(NV_CIO_CRE_LCD_VPLL_VCO));
        CRTC_WR(NV_CIO_CRE_LCD__INDEX, cr33, Head);

        // restore lock, if previously locked
        if (lock == 0)
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, Head);
    }

    //
    // Determine the current crystal frequency
    //   
    if (pDev->Chip.HalInfo.CrystalFreq == 14318180)
    {
        // 14.3Khz
        crystalFreq = 14318;

        lowM = 1;
             
        if (vclk > hiVclk2)
            highM = 2;
        else if (vclk > hiVclk1)
            highM = 6;
        else
            highM = 14;
    }
    else
    {
        // 13.5Khz
        crystalFreq = 13500;

        lowM = 1;

        if (vclk > hiVclk2)
            highM = 2;
        else if (vclk > hiVclk1)
            highM = 6;
        else
            highM = 13;
    }                      
    
    //
    // P Loop
    //
    for (powerP = lowP; powerP <= highP; powerP++) // Init Power of P
    {                             
        // M Loop
        for (m = lowM; m <= highM; m++)
        {                          
            lwv = vclk << powerP;   // vclk * P
            
            // Compare with internal range of DAC
            if ((lwv >= FminVco) && (lwv <= FmaxVco))
            {
                lwv *= (U032)m;    // vclk * P * M
                
                // Add crystal Frequency /2 - will round better
                lwv += (crystalFreq >> 1);
                
                lwv /= crystalFreq; // N = vclk*P*M/crystal
                n = (U016)(lwv & 0xFFFF);
                
                if (n > 0xFF)
                    break;
                    
                lwv *= crystalFreq; // N * crystal
                   
                i = 1 << powerP;    // for rounding
                i >>= 1;            // /2
                
                lwv += i;           // Add 1/2 of P
                lwv >>= powerP;     // N*cyrstal/P
                
                i = m;
                j = m;
                
                j >>= 1;            // M/2
                lwv += j;           // For rounding
                lwv /= m;           // Freq = N*crystal/P/M
                                       
                lwv2 = lwv;          // Save a copy

                // Because the only divide in computing N is by the
                // crystal frequency, the remainder will always be
                // less than the crystal frequency which fits into
                // a word, so we can do the delta math on words
                //
                // Compute delta
                
                lwvs = (U016)(lwv & 0xFFFF);
                vclks = (U016)(vclk & 0xFFFF);
                
                if (lwvs < vclks)
                {               
                    // Exchange the values
                    t = lwvs;
                    lwvs = vclks;
                    vclks = t;
                }            
                    
                lwvs -= vclks;      // ABS(Freq-Vclk);
                
                //
                // If this is an NV5 or better, allow the higher PCLK settings to use a lower M
                // if the error is small enough.  Just looking for the lowest overall error
                // may result in an M that is too high, possibly introducing PLL jitter.
                //
                if (IsNV5orBetter(pDev))
                {                
                    //
                    // If VCLK > 250MHz and error is less than 0.2%, drop out
                    //
                    if (vclk > hiVclk1)
                    {
                        if (((vclk/lwvs) > 200) || (lwvs == 0)) // zero error; rare, but would cause exception
                        {
                            *P = powerP;
                            *M = m;
                            *N = n;
                            lwv2 /= 10;
                            return ((U016)(lwv2 & 0xFFFF));
                        } 
                    }
                    
                    if (lwvs < deltaOld) // go to closest match with M < highM
                    {
                        // Closer match
                        deltaOld = lwvs;
                        
                        bestP = powerP;
                        bestM = m;
                        bestN = n;
                        
                        lwv2 /= 10;
                        
                        vclkClosest = (U016)(lwv2 & 0xFFFF);
                    }
                                            
                }
                else // !NV5
                {
                    if (lwvs < deltaOld)
                    {
                        // Closer match
                        deltaOld = lwvs;
                        
                        bestP = powerP;
                        bestM = m;
                        bestN = n;
                        
                        lwv2 /= 10;
                        
                        vclkClosest = (U016)(lwv2 & 0xFFFF);
                    }
                }
            }
        }
    }                             
    
    // Verify we've established M, N, P values to use
    if (!bestM && !bestN && !bestP)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: dacCalcMNP didn't set any M, N, P values!!!\n");
        DBG_BREAKPOINT();
    }

    //
    // Return the results
    //
    *M = bestM;
    *N = bestN;
    *P = bestP;
    
    return (vclkClosest);
} 

//
// Clock programming methods
//

//
// dacProgramMClk - Program MCLK based on the value in pDev->Dac.HalInfo.MClk
//
// This routine uses the value in pDev->Dac.HalInfo.MClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS dacProgramMClk
(
    PHWINFO pDev
)
{
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 Head = 0;  // MPLL is on head 0

    // Compute M, N, O, and P values
    dacCalcMNP( pDev, Head, pDev->Dac.HalInfo.MClk / 10000, &mNew, &nNew, &pNew );

    // Update Dac structure
    pDev->Dac.HalInfo.MPllM = mNew;
    pDev->Dac.HalInfo.MPllN = nNew;
    pDev->Dac.HalInfo.MPllO = 1;
    pDev->Dac.HalInfo.MPllP = pNew;

    return(nvHalDacProgramMClk(pDev));
}

//
// dacProgramNVClk - Program NVCLK based on the value in
// pDev->Dac.HalInfo.NVClk
//
// This routine uses the value in pDev->Dac.HalInfo.NVClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS dacProgramNVClk
(
    PHWINFO pDev 
)
{
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 Head = 0; // NVPLL is on head 0

    // Compute M, N, O, and P values
    dacCalcMNP(pDev, Head, pDev->Dac.HalInfo.NVClk / 10000, &mNew, &nNew, &pNew);

    // Update Dac structure
    pDev->Dac.HalInfo.NVPllM = mNew;
    pDev->Dac.HalInfo.NVPllN = nNew;
    pDev->Dac.HalInfo.NVPllO = 1;
    pDev->Dac.HalInfo.NVPllP = pNew;

    return(nvHalDacProgramNVClk(pDev));
}

RM_STATUS dacGetDisplayInfo
(
    PHWINFO pDev,
    U032 DisplayMap,
    U032 *Head,
    U032 *DisplayType,
    U032 *I2CWritePort,
    U032 *I2CReadPort
)
{
    U032 flag = 0;
    PDACDCBDEVDESC pDevDesc;
    pDACDCBI2CRECORD pDCBI2c;

    pDevDesc = pDev->Dac.DCBDesc;
    pDCBI2c  = pDev->Dac.DCBI2c;

    while (pDevDesc->DCBRecType != DCB_DEV_REC_TYPE_EOL)
    {
        if (pDevDesc->DevTypeUnit == DisplayMap)
        {
            flag = 1;
            break;
        }
        pDevDesc++;
        pDCBI2c++;
    }

    if (!flag) return RM_ERROR;

    if (Head)         *Head = pDevDesc->DCBRecHead;
    if (DisplayType)  *DisplayType = pDevDesc->DCBRecType;
    if (I2CWritePort) *I2CWritePort = pDCBI2c->WritePort;
    if (I2CReadPort)  *I2CReadPort = pDCBI2c->ReadPort;

    return RM_OK;
}

//
// dacProgramPClk - Program PCLK based on the value in pDev->Dac.PClk
//
// This routine uses the value in pDev->Dac.PClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS dacProgramPClk
(
    PHWINFO pDev, 
    U032    Head,
    U032    PixelClock
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT vidLutCurDacHalObj;
    U032 mNew;
    U032 nNew;
    U032 pNew;

    // Compute M, N, O, and P values
    dacCalcMNP( pDev, Head, PixelClock, &mNew, &nNew, &pNew );

    // Update Dac structure
    pDev->halHwInfo.pDacHalInfo->VPllM = mNew;
    pDev->halHwInfo.pDacHalInfo->VPllN = nNew;
    pDev->halHwInfo.pDacHalInfo->VPllO = 1;
    pDev->halHwInfo.pDacHalInfo->VPllP = pNew;

    vidLutCurDacHalObj.Head = Head;

    return(nvHalDacProgramPClk(pDev, PixelClock, (VOID*) &vidLutCurDacHalObj));
}

// This function just enables the cursor by setting bit 0 of config register 0x31 to 1.
// The cursor image is not changed in any way.
VOID dacEnableCursor
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    cr31;
    U008    lock;
    
    // Unlock CRTC extended regs
    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
    
    CRTC_RD(NV_CIO_CRE_HCUR_ADDR1_INDEX, cr31, Head);           
    CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, (cr31 | (1 << DRF_SHIFT(NV_CIO_CRE_HCUR_ADDR1_ENABLE))), Head);

    // Relock CRTC extended regs
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);

}

// This function just disables the cursor by setting bit 0 of config register 0x31 to 0.
// The cursor image is not changed in any way.
VOID dacDisableCursor
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    cr31;
    U008    lock;
    
    // Unlock CRTC extended regs
    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
    
    CRTC_RD(NV_CIO_CRE_HCUR_ADDR1_INDEX, cr31, Head);           
    CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, (cr31 & ~(1 << DRF_SHIFT(NV_CIO_CRE_HCUR_ADDR1_ENABLE))), Head);

    // Relock CRTC extended regs
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
}

/*  This function is mis-named. It also loads the cursor image offset in addition to enabling the
    cursor. This is used by the old style of cursor manipulation. 
*/
VOID enableCursor
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    lock;
    
    // Unlock CRTC extended regs
    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
    
#ifdef NTRM    
	// Tell the DAC where to load the image from
	// The address is in pages, so shift 4 bits.
	if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x00000001)    // color or mono?
	{
        CRTC_WR(NV_CIO_CRE_HCUR_ADDR0_INDEX, (pDev->Dac.CursorImageInstance >> 12) & 0x7f, Head);
        CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, ((pDev->Dac.CursorImageInstance >> 4) & 0xf8), Head);
	}
	else
	{
        // call crtc_wrm: need to add this routine
        CRTC_WRM(NV_CIO_CRE_HCUR_ADDR0_INDEX, (pDev->Dac.CursorImageInstance >> 12) & 0x7f);
        CRTC_WRM(NV_CIO_CRE_HCUR_ADDR1_INDEX, ((pDev->Dac.CursorImageInstance >> 4) & 0xf8) | 1);
	}
#else
    // Tell the DAC where to load the image from. The address is in pages, so shift 4 bits.
#ifdef WIN31
    // On NV4 and later HCUR_ADDR0 is 23:17, HCUR_ADDR1 is 16:11 (on NV3 its 22:16)
    CRTC_WR(NV_CIO_CRE_HCUR_ADDR0_INDEX, (pDev->Dac.CursorImageInstance >> 13) & 0x7f);
    CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, ((pDev->Dac.CursorImageInstance >> 5) & 0xfc) | 1);
//JohnH The Win9x code below is incorrect for NV4 and up, but the correct address
//JohnH gets set in dacProgramCursorImage.
//JohnH CRTC_WR(NV_CIO_CRE_HCUR_ADDR0_INDEX, (pDev->Dac.CursorImageInstance >> 12) & 0x7f);
//JohnH CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, (pDev->Dac.CursorImageInstance >> 4) & 0xf8);
#endif // WIN31
#endif // NTRM
    
    // JJV - I am removing this call. Vblank will call this later if needed.
    //       This will fix a multimonitor cursor problem.  
    // Enable the cursor.
    //dacEnableCursor(pDev);

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
        
    return;
}

/*  Turn off the enable bit in CRTC reg
    This function unlocks the CRTC extended registers and calls dacDisableCursor.
    This is used by the old style cursor manipulation functions. */
VOID disableCursor
(
    PHWINFO pDev,
    U032    Head
)
{
    U008 lock;

#ifndef NTRM
    pDev->Dac.CrtcInfo[Head].CursorType = DAC_CURSOR_DISABLED;    // disable updates in vblank
#endif

    // Unlock CRTC extended regs
    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

    dacDisableCursor(pDev, Head);

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
}

RM_STATUS dacProgramCursorPosition
(
    PHWINFO pDev, 
    U032    Head,
    U032    cursorX, 
    U032    cursorY 
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    // on modes below 400 lines, scanline doubling is used. we need to adjust cursor y postion
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    if (pVidLutCurDac && pVidLutCurDac->HalObject.Dac[0].Format.DoubleScanMode)
        cursorY *= 2;

//    if (CRTCHALINFO(pDev, Head, DisplayType) == TV)
        cursorX += pDev->Framebuffer.CursorAdjust;  // HW bug in NV4, position is off a little on TV

    DAC_REG_WR32(NV_PRAMDAC_CU_START_POS, cursorX | (cursorY << 16), Head);

    return RM_OK;
}

VOID dacDisableImage
(
    PHWINFO pDev,
    U032 Head
)
{
    U016 data;
    U032 prevHead = (pDev->Dac.HalInfo.Head2RegOwner & 0x1);

    EnableHead(pDev, Head);        // sequencer updates require setting CR44 

    // turn on blank
    data = ReadIndexed(NV_PRMVIO_SRX, 0x01);
    data |= 0x2000;
    WriteIndexed(NV_PRMVIO_SRX, data);

    EnableHead(pDev, prevHead);    // restore previous CR44 value
}

VOID dacEnableImage
(
    PHWINFO pDev,
    U032 Head
)
{
    U016 data;
    U032 prevHead = (pDev->Dac.HalInfo.Head2RegOwner & 0x1);

    EnableHead(pDev, Head);        // sequencer updates require setting CR44 

    // turn off blank
    data = ReadIndexed(NV_PRMVIO_SRX, 0x01);
    data &= ~0x2000;
    WriteIndexed(NV_PRMVIO_SRX, data);

    EnableHead(pDev, prevHead);    // restore previous CR44 value
}


VOID dacEnableDac
(
    PHWINFO pDev,
    U032 Head
)
{
    U008 lock, data08;    
    
    if (!IsNV11(pDev) && (Head == 1)) // if not dual-head
    {
        return;
    }
    
    // unlock CRTC extended regs
    CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

    // enable vblank interrupt
    DAC_REG_WR32(NV_PCRTC_INTR_EN_0, 1, Head);
    pDev->Dac.CrtcInfo[Head].StateFlags |= DAC_CRTCINFO_VBLANK_ENABLED;
    
    switch (GETDISPLAYTYPE(pDev, Head))
    {
        case DISPLAY_TYPE_MONITOR:
        
            // TO DO: this decision must be made by the HAL
            // if normal VGA (internal DAC)
            if (Head == 0) 
            {
                dacEnableImage(pDev, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _ON, Head);  // CRT on
                //
                // We need to be careful about powering down the TMDS
                // transmitter on NV11 because we can lose a flat
                // panel connected to the second crtc (head 1).
                //
                if (IsNV11(pDev))
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _FPCLK, Head);     // FPCLK off only;leave TMDS going for secondary crtc
                else
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _BOTH, Head);      // FPCLK/TMDS both off
                CRTC_RD(0x33, data08, Head);
                CRTC_WR(0x33, (data08 & ~0x02), Head);  // clear CR33[1] (BIOS flag)
                CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 & 0x3F, Head);
                dacSetCursorBlink(pDev, Head, 0); // set cursor blink rate for DOS
            }
        
            // PRAMDAC_FP is driving analog
            else
            {
                // restore sync states
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, pDev->Dac.CrtcInfo[Head].CurrentVsyncState, Head);
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, pDev->Dac.CrtcInfo[Head].CurrentHsyncState, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);
            }
            
            break;   
                                       
        case DISPLAY_TYPE_FLAT_PANEL:
        
            // restore sync states
            DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, pDev->Dac.CrtcInfo[Head].CurrentVsyncState, Head);
            DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, pDev->Dac.CrtcInfo[Head].CurrentHsyncState, Head);
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);

            if (pDev->Power.MobileOperation)
    	   		dacPowerOnMobilePanel(pDev,Head);
            break;                              
            
        case DISPLAY_TYPE_TV:
            dacEnableTV(pDev, Head);
            break;
            
        default:
            break;
    }

    // relock extended regs
    if (lock == 0)
    {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, Head);
    }

} // end of dacEnableDac()

VOID dacDisableDac
(
    PHWINFO pDev,
    U032 Head
)
{
    if (!IsNV11(pDev) && (Head == 1)) // if not dual-head
    {
        return;
    }

    // disable vblank interrupt
    DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, Head);
    DAC_REG_WR32(NV_PCRTC_INTR_EN_0, 0, Head);
    pDev->Dac.CrtcInfo[Head].StateFlags &= ~DAC_CRTCINFO_VBLANK_ENABLED;

    // device-specific disabling...
    switch (GETDISPLAYTYPE(pDev, Head))
    {
        case DISPLAY_TYPE_MONITOR:
        
            // TO DO: this decision must be made by the HAL
            // head 0 -- treat as CRT
            if (Head == 0)
            {
                // disable sync
                dacSetSyncState(pDev, Head, 0, 0);
                //
                // BIOS WORKAROUND
                //
                // For now the Mobile BIOS does not reenable the dac power when performing
                // a modeset, therefore after we disable the power upon windows exit,
                // the CRT remains blank (even after warm restart).  Until the BIOS is
                // updated to account for this, I need to make sure we don't power
                // off the dac.
                //
                // The only issue with not doing the powerdown is with monitors that
                // don't abide by the blank-on-disabled-syncs rule, but that exposure
                // is small.
                //
                // Only do this for mobile
                //
                if (!pDev->Power.MobileOperation) {
                    dacDisableImage(pDev, Head);
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head);
                }
            }
            
            // head 1 -- treat as DFP
            else
            {    
                // disable sync
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _DISABLE, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _DISABLE, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _BOTH, Head);
            }
            break;
            
        case DISPLAY_TYPE_FLAT_PANEL:
        
            // disable sync
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _DISABLE, Head);
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _DISABLE, Head);
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _BOTH, Head);

            // if we're mobile, turn the power off as well
            if (pDev->Power.MobileOperation)
                dacPowerOffMobilePanel(pDev, Head);
            
            break;
            
        case DISPLAY_TYPE_TV:
        
            // this has to be encoder dependent
            dacDisableTV(pDev, Head);
            break;
            
        default:
            break;
    }

} // end of dacDisableDac()

RM_STATUS dacProgramVideoStart
(
    PHWINFO pDev, 
    U032    Head,
    U032    StartAddr, 
    U032    Pitch 
)
{
    if (!pDev->Vga.Enabled)
    {
        VIDEO_LUT_CURSOR_DAC_HAL_OBJECT vidLutCurDacHalObj;

        vidLutCurDacHalObj.Head = Head;

        //
        // If the pitch of the RGB surface does not match the current display width, we
        // need to tweak the CRTC to a different pitch adjust.
        //
        // Compare Pitch against pDev->Framebuffer.DisplayPitch rather than trying to
        // calculate it, since DisplayPitch has been aligned for the HW already (e.g. NV10).
        //
        // Checking against DisplayPitch actually doesn't save us in the case where the 2
        // surfaces have different pitch values. This really needs to be checking against
        // the last loaded pitch ... but then we'd be programming more than just the start
        // addr 1/2 the time.
        //
        // For now, print out a message, so the driver can be changed to flip between
        // surfaces of the same pitch making our job easier and giving us the best perf.
        //        
//#if 0 // This was used for video class63, but later classes take care of this case
//        if (Pitch != pDev->Framebuffer.DisplayPitch)
        {

            U008      i, lock, crtc_index;
            U032      val32;

//            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Flipping between different pitched surfaces!!!\n\r");

            //
            // Save the current CRTC index
            //
            if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)    // color or mono?
                crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);    // save crtc index
            else
                crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO); // save crtc index

            // Unlock CRTC extended regs
            lock = ReadCRTCLock(pDev, Head);
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

            // Write the alternative pitch to the CRTC Offset Register
            // The value written to CR13/CR19 is the number of 8-byte chunks
            CRTC_WR(NV_CIO_CR_OFFSET_INDEX, (Pitch >> 3) & 0xFF, Head);

            // Modify the bits in the extended register as well
            CRTC_RD(NV_CIO_CRE_RPC0_INDEX, i, Head);
            i &= 0x1F;
            val32 = ((Pitch >> 3) & 0x700) >> 3;
            i |= (U008)val32; 
            CRTC_WR(NV_CIO_CRE_RPC0_INDEX, i, Head);

            // Relock extended regs
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);

            // Restore index
            if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)
                REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index); // restore crtc index
            else
                REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);  // restore crtc index

        }
//#endif

        // Program the new start address; this will latch at the end of blank
#ifdef  STEREO_SUPPORT
        if (pDev->pStereoParams)
        {
            pDev->pStereoParams->FlipOffsets[3][0] = StartAddr;
            if (pDev->pStereoParams->Flags & STEREOCFG_STEREOACTIVATED)
            {
                return RM_OK;
            }
        }
#endif  //STEREO_SUPPORT
        nvHalDacSetStartAddr(pDev, StartAddr, &vidLutCurDacHalObj);
    }
    return RM_OK;
}

RM_STATUS dacProgramLUT
(
    PHWINFO pDev, 
    U032    Head,
    U032*   Palette, 
    U032    numEntries 
)
{
    U032    i, rgb;

    // start at palette 0 and autoincrement
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0, Head);
    for (i = 0; i < numEntries; i++)
    {
        rgb = Palette[i];
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)(rgb >> 16), Head);    // b
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)(rgb >> 8), Head);     // g
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)rgb, Head);            // r
    }
    return RM_OK;
}

RM_STATUS dacProgramScanRegion
(
    PHWINFO pDev,
    U032    Head,
    U032    startLine,
    U032    stopLine,
    U032    polarity
)
{
    //
    // Note that this routine should only be called for NV15, the only
    // chip with this support.  Since no other chips will have this
    // feature (past or future), no need to overload a chip func.
    //
    if (IsNV15(pDev) || IsNV11(pDev) || IsNV20(pDev))
    {
        DAC_REG_WR32(NV_PCRTC_RASTER_START, startLine | DRF_NUM(_PCRTC, _RASTER_START, _POL, polarity), Head);
        DAC_REG_WR32(NV_PCRTC_RASTER_STOP,  stopLine, Head);
        return (RM_OK);    
    }
    else
        return (RM_ERROR);
}

/************************************************************
* Here is how the H & V blank and retrace values map to the config registers:
    Hbs<0:7> = CR02<0:7>
    Hbe<0:4> = CR03<0:4>
    Hbe<5>   = CR05<7>
    Hbe<6>   = CR25<4>
    Vbs<0:7> = CR15<0:7>
    Vbs<8>   = CR07<3>
    Vbs<9>   = CR09<5>
    Vbs<10>  = CR25<3>
    Vbe<0:7> = CR16<0:7>
    
    Hrs<0:7> = CR04<0:7>
    Hre<0:4> = CR05<0:4>
    Vrs<0:7> = CR10<0:7>
    Vrs<8>   = CR07<2>
    Vrs<9>   = CR07<7>
    Vrs<10>  = CR25<2>
    Vre<0:3> = CR11<0:3>
***********************************************************/

//  After every mode set, we save the H & V retrace in nvinfo, so we can restore the default screen position
VOID dacSaveMonitorDefaultPosition
(
    PHWINFO pDev,
    U032    Head
)
{
    PDACMONITORPOSITION pDacMonPos;
    U016    Hrs, Hre, Vrs, Vre;
    U016    Hbs, Hbe, Vbs, Vbe;
    U008    Cr03, Cr05, Cr07, Cr09, Cr25;
    short   temp;

// debug 
    CRTC_RD(NV_CIO_CR_HBE_INDEX, Cr03, Head);

    // read all the necessary config registers.
    CRTC_RD(NV_CIO_CR_HBE_INDEX, Cr03, Head);
    CRTC_RD(NV_CIO_CR_HRE_INDEX, Cr05, Head);
    CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_RD(NV_CIO_CR_CELL_HT_INDEX, Cr09, Head);
    CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);

    // Construct Hbs
    CRTC_RD(NV_CIO_CR_HBS_INDEX, Hbs, Head);
    // Construct Hbe
    Hbe = Cr03 & BITS0_4;
    if (Cr05 & BIT7)
        Hbe |= BIT5;
    if (Cr25 & BIT4)
        Hbe |= BIT6;
    // Construct Vbs
    CRTC_RD(NV_CIO_CR_VBS_INDEX, Vbs, Head);
    if (Cr07 & BIT3)
        Vbs |= BIT8;
    if (Cr09 & BIT5)
        Vbs |= BIT9;
    if (Cr25 & BIT3)
        Vbs |= BIT10;
    // Construct Vbe
    CRTC_RD(NV_CIO_CR_VBE_INDEX, Vbe, Head);

    // Construct Hrs
    CRTC_RD(NV_CIO_CR_HRS_INDEX, Hrs, Head);
    // Construct Hre
    Hre = Cr05 & BITS0_4;
    // Construct Vrs
    CRTC_RD(NV_CIO_CR_VRS_INDEX, Vrs, Head);
    if (Cr25 & BIT2)
        Vrs |= BIT10;
    if (Cr07 & BIT7)
        Vrs |= BIT9;
    if (Cr07 & BIT2)
        Vrs |= BIT8;
    // Construct Vre
    CRTC_RD(NV_CIO_CR_VRE_INDEX, Vre, Head);
    Vre &= BITS0_3;

    // The horizontal/vertical, blank/retrace end values are really the width of the respective signal.
    // Calculate the absolute end values. It is a bit cumbursome because the number of bits of information
    // is not uniform.
    // The formula is: <Absolute end value> = <start-value> + ((<width> - <start-value>) & (# of bits))
    temp = (short)Hbe - (short)Hbs; 
    temp &= 0x7f; // just take the low 7 bits
    Hbe = Hbs + temp;
    
    temp = (short)Hre - (short)Hrs; 
    temp &= 0x1f; // just take the lower 5 bits
    Hre = Hrs + temp;

    temp = (short)Vbe - (short)Vbs; 
    temp &= 0x7f; // just take the low 7 bits
    Vbe = Vbs + temp;
    
    temp = (short)Vre - (short)Vrs; 
    temp &= 0xf; // just take the lower 4 bits
    Vre = Vrs + temp;

    // save it off in nvinfo
    pDacMonPos = &pDev->Dac.CrtcInfo[Head].MonitorPosition;
    pDacMonPos->Hbs = Hbs;
    pDacMonPos->Hbe = Hbe;
    pDacMonPos->Vbs = Vbs;
    pDacMonPos->Vbe = Vbe;
    pDacMonPos->Hrs = Hrs;
    pDacMonPos->Hre = Hre;
    pDacMonPos->Vrs = Vrs;
    pDacMonPos->Vre = Vre;
}

//****************************************************************************************
/*  Adjust monitor horizontal position
    This is accomplished by increasing/decreasing the retrace start/end values
    The adjustment is character granularity
*/
static VOID SetRetraceH
(   PHWINFO pDev, 
    U032    Head,
    U032    Hrs, 
    U032    Hre
)
{
    U008    Cr05;

    // Get HRE
    CRTC_RD(NV_CIO_CR_HRE_INDEX, Cr05, Head);
    Cr05 &= ~BITS0_4;        // Clear bits 0:4
    Cr05 |= (Hre & BITS0_4); // Combine new HRE bits 0:4 with other bits

    // Write out adjustment
    CRTC_WR(NV_CIO_CR_HRS_INDEX, Hrs, Head);
    CRTC_WR(NV_CIO_CR_HRE_INDEX, Cr05, Head);
}

//****************************************************************************************
/*  Adjust monitor vertical position
    This is accomplished by increasing/decreasing the retrace start/end values
    The adjustment is scanline granularity
*/
static VOID SetRetraceV
(   PHWINFO pDev, 
    U032    Head,
    U032    Vrs, 
    U032    Vre
)
{
    U008    Cr10, Cr11, Cr07, Cr25;

    // Get CR25, CR7, CR11, mask VR bits
    CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    Cr07 &= ~(BIT7 | BIT2);
    CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
    Cr25 &= ~BIT2;
    CRTC_RD(NV_CIO_CR_VRE_INDEX, Cr11, Head);
    Cr11 &= ~BITS0_3;
        
    Cr10 = (U008)(Vrs & BITS0_7);
    // Combine new VRS value with other bits in CR07, CR25.
    if (Vrs & BIT10)
        Cr25 |= BIT2;
    if (Vrs & BIT9)
        Cr07 |= BIT7;
    if (Vrs & BIT8)
        Cr07 |= BIT2;

    // Combine VRE with other bits in CR11
    Cr11 |= (Vre & BITS0_3);
    
    // Write out adjustment
    CRTC_WR(NV_CIO_CR_VRS_INDEX, Cr10, Head);  
    CRTC_WR(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
    CRTC_WR(NV_CIO_CR_VRE_INDEX, Cr11, Head);
}

//****************************************************************************************
/*  Adjust monitor postion
*/
RM_STATUS dacSetMonitorPosition
(
    PHWINFO pDev,
    U032    Head,
    U032    Hrs,
    U032    Hre,
    U032    Vrs,
    U032    Vre
)
{
U032    Vde, Vt;
U008    Cr01, Cr07, Cr11, Cr21, Cr25, val;
U008    lock;
U008    UpdatedCr11;

    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

    CRTC_RD(NV_CIO_CR_VRE_INDEX, Cr11, Head);
    val = Cr11 & 0x7f;                          // clear write protection bit
    CRTC_WR(NV_CIO_CR_VRE_INDEX, val, Head);

    CRTC_RD(0x21, Cr21, Head);
    CRTC_WR(0x21, 0xf8, Head);       // disable shadowing for TV
    
    CRTC_RD(NV_CIO_CR_HDE_INDEX, Cr01, Head);     // read H display end

    // Check that the sync width doesn't go to 0 and that the sync pulse is beyond display end
    if ((Hre <= (Hrs & 0x1f)) || (Hrs <= Cr01))
    {
        return RM_ERROR;
    }

    // Get overflow bits
    CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);    

    // Check that the sync width doesn't go to 0 and that the sync pulse is beyond display end
    CRTC_RD(NV_CIO_CR_VDE_INDEX, Vde, Head);    // read V display end (CR12)
    if (Cr07 & BIT(1)) Vde |= 0x100;
    if (Cr07 & BIT(6)) Vde |= 0x200;
    if (Cr25 & BIT(1)) Vde |= 0x400;
    
    // Check also that the sync pulse doesn't enter the display start (vertical total)
    CRTC_RD(NV_CIO_CR_VDT_INDEX, Vt, Head);
    if (Cr07 & BIT(0)) Vt |= 0x100;
    if (Cr07 & BIT(5)) Vt |= 0x200;    
    if (Cr25 & BIT(0)) Vt |= 0x400; 

    // Check for error conditions
    if ((Vre <= Vrs) || (Vrs <= Vde) || (Vre >= Vt))
    {
        return RM_ERROR;
    }

    /*
    // Make sure we don't change these values during the vblank interval.
    while (REG_RD_DRF(_PCRTC, _RASTER, _VERT_BLANK) != NV_PCRTC_RASTER_VERT_BLANK_ACTIVE)
        ;
    while (REG_RD_DRF(_PCRTC, _RASTER, _VERT_BLANK) != NV_PCRTC_RASTER_VERT_BLANK_INACTIVE)
        ;
    */

    SetRetraceH(pDev, Head, Hrs, Hre);
    SetRetraceV(pDev, Head, Vrs, Vre);

    CRTC_WR(0x21, Cr21, Head);

    // the lower 4 bits in CR11 were updated by SetRetraceV(), don't mess it up
    CRTC_RD(NV_CIO_CR_VRE_INDEX, UpdatedCr11, Head);
    Cr11 = (Cr11 & ~BITS0_3) | (UpdatedCr11 & BITS0_3);
    CRTC_WR(NV_CIO_CR_VRE_INDEX, Cr11, Head);

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);

    return RM_OK;
}
 
//  Get the H & V Blank and retrace values from nvinfo.
VOID dacGetMonitorDefaultPosition
(
    PHWINFO pDev,
    U032    Head,
    U032    *pHbs,
    U032    *pHbe,
    U032    *pVbs,
    U032    *pVbe,
    U032    *pHrs,
    U032    *pHre,
    U032    *pVrs,
    U032    *pVre
)
{
    PDACMONITORPOSITION pDacMonPos;

    pDacMonPos = &pDev->Dac.CrtcInfo[Head].MonitorPosition;

    *pHbs = pDacMonPos->Hbs;
    *pHbe = pDacMonPos->Hbe;
    *pVbs = pDacMonPos->Vbs;
    *pVbe = pDacMonPos->Vbe;
    *pHrs = pDacMonPos->Hrs;
    *pHre = pDacMonPos->Hre;
    *pVrs = pDacMonPos->Vrs;
    *pVre = pDacMonPos->Vre;
}

//  Get a string pointing to a key in the Display section
//  The string is of the type hresxyres, e.g. "1024x768"
//  Return 0 if its not a desktop mode
void dacFindRegistryKeyDisplayPosition
(
    PHWINFO pDev,
    U032    Head,
    BOOL    isMonitor,
    char    *strDisplayMode
)
{
    U032    hres, vres;
    U032    strIndex;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hres = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vres = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

    //
    // For non-TV modes, convert the resolution into a string
    //
    // Oh, to have a sscanf() handy...
    //
    strIndex = 0;   // start at the beginning

    //
    // Prepend the TV format if necessary
    //
    if (!isMonitor)
    {
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
            case NTSC_J:
                strDisplayMode = osStringCopy(strDisplayMode, "NTSC");
                strIndex = 4;
                break;
            case PAL_M: // unique case; does not use normal PAL timing
                strDisplayMode = osStringCopy(strDisplayMode, "PALM");
                strIndex = 4;
                break;
            default:    // rest are PAL modes
                strDisplayMode = osStringCopy(strDisplayMode, "PAL");
                strIndex = 3;
                break;     
        }
    }

    //
    // Assume the resolution is always below 9999x9999 and above 99x99
    // (this makes it a bit easier, especially with floating 0's)
    //
    // Start with the horizontal resolution first
    //
    if (hres / 1000)
    {
        strDisplayMode[strIndex++] = (U008)(hres/1000)+'0';
        hres -= (hres/1000)*1000;
    }

    if (hres / 100)
    {
        strDisplayMode[strIndex++] = (U008)(hres/100)+'0';
        hres -= (hres/100)*100;
    }
    else
        strDisplayMode[strIndex++] = '0';
    
    if (hres / 10)
    {
        strDisplayMode[strIndex++] = (U008)(hres/10)+'0';
        hres -= (hres/10)*10;
    }
    else
        strDisplayMode[strIndex++] = '0';
    
    strDisplayMode[strIndex++] = (U008)hres + '0';

    //
    // Append a lower case 'x'
    //
    strDisplayMode[strIndex++] = 'x';

    // 
    // Now generate the vertical value
    //
    if (vres / 1000)
    {
        strDisplayMode[strIndex++] = (U008)(vres/1000)+'0';
        vres -= (vres/1000)*1000;
    }
    
    if (vres / 100)
    {
        strDisplayMode[strIndex++] = (U008)(vres/100)+'0';
        vres -= (vres/100)*100;
    }
    else
        strDisplayMode[strIndex++] = '0';
    
    if (vres / 10)
    {
        strDisplayMode[strIndex++] = (U008)(vres/10)+'0';
        vres -= (vres/10)*10;
    }
    else
        strDisplayMode[strIndex++] = '0';
    
    strDisplayMode[strIndex++] = (U008)vres + '0';

    //
    // Zero append to the end
    //
    strDisplayMode[strIndex] = NULL;

    return;

}

//  Save the screen position for the current mode in the registry
//  Find the registry key for this device and this mode
RM_STATUS dacWriteDesktopPositionToRegistry
(
    PHWINFO pDev,
    U032    Head,
    BOOL    isMonitor,
    U008 *  position, 
    U032    numBytes
)
{
    U032    i;
    char    strDisplayMode[] = "12345678901234567890";
    //
    // Generate the path to the registry key--last character is the display number
    //
    dacFindRegistryKeyDisplayPosition(pDev, Head, isMonitor, strDisplayMode);
    i = osStringLength(strDisplayMode);
    strDisplayMode[i++] = '_';
    strDisplayMode[i++] = ((U008)Head + '0');
    strDisplayMode[i] = NULL;

    return osWriteRegistryBinary(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, position, numBytes);
}

//  Read the screen position for the current mode from the registry
RM_STATUS dacReadDesktopPositionFromRegistry
(
    PHWINFO pDev,
    U032    Head,
    BOOL    isMonitor,
    U008 *  position, 
    U032 *  numBytes
)
{
    U032    i;
    char    strDisplayMode[] = "12345678901234567890";

    //
    // Generate the path to the registry key--last character is the display number
    //
    dacFindRegistryKeyDisplayPosition(pDev, Head, isMonitor, strDisplayMode);
    i = osStringLength(strDisplayMode);
    strDisplayMode[i++] = '_';
    strDisplayMode[i++] = ((U008)Head + '0');
    strDisplayMode[i] = NULL;

    return osReadRegistryBinary(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, position, numBytes);
}

//  Return the registry values for TV position, brightness, contrast and flicker filter.
RM_STATUS dacReadTVDesktopPositionFromRegistry
(
    PHWINFO pDev,
    U032 Head,
    U008 *Params,
    U032 *numBytes
)
{
    U032    i;
    char    strDisplayMode[] = "12345678901234567890";

    //
    // Generate the path to the registry key--last character is the display number
    //
    dacFindRegistryKeyDisplayPosition(pDev, Head, 0, strDisplayMode);
    i = osStringLength(strDisplayMode);
    strDisplayMode[i++] = '_';
    strDisplayMode[i++] = ((U008)Head + '0');
    strDisplayMode[i] = NULL;

    return osReadRegistryBinary(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, Params, numBytes);
}

//  Read the TV Out format (Composite on S-video, S-Video, Auto select)
//  The registry key is DeviceX, X= 0,1,2,... under the Display key.
RM_STATUS dacReadTVOutFromRegistry
(
    PHWINFO pDev,
    U032    Head,
    U032   *type
)
{
    return OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strTVOutType, type);
}

//  Check Registry for Philips 7108B special setting
RM_STATUS dacReadTVPhilipsBFromRegistry
(
    PHWINFO pDev,
    U032    Head,
    U032   *type
)
{
char strTVPhilipsB[] = "Philips7108B";

    return OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strTVPhilipsB, type);
}

//  Write the TV Out format (Composite on S-video, S-Video, Auto select)
//  The registry key is DeviceX, X= 0,1,2,... under the Display key.
RM_STATUS dacWriteTVOutToRegistry
(
    PHWINFO pDev,
    U032    Head,
    U032    type
)
{
    pDev->Dac.TVoutput = type;  // save in pDev, because NT cannot read registry at modeset time.
    return osWriteRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strTVOutType, type);
}

RM_STATUS dacGetMonitorInfo
(
    PHWINFO pDev,
    U032    Head,
    U032    *MonitorConnected
)
{
    *MonitorConnected = 0;

    if (dacMonitorConnectStatus(pDev, Head))
        *MonitorConnected = 1;
    return RM_OK;
}
// Write a CRTC timing parameter into the CRTC registers
VOID dacSetCRTC
(
    PHWINFO pDev, 
    U032 Head, 
    U032 Param, 
    U032 Val
)
{
    U008 Crtc;
    U032 Val2;

    switch (Param) 
    {
    case H_TOTAL:
        Val2 = (Val >> 3) - 5;
        Crtc = (U008)(Val2 & 0xff);
        CRTC_WR(0, Crtc, Head);
        CRTC_RD(0x2D, Crtc, Head);
        Crtc &= ~BIT(0);
        if (Val2 & 0x100)               
            Crtc |= BIT(0);
        CRTC_WR(0x2D, Crtc, Head);
        break;
    case H_DISPLAY_END:
        Crtc = (U008) ((Val >> 3) - 1);
        CRTC_WR(1, Crtc, Head);
        break;
    case H_BLANK_START:
        Val2 = (Val >> 3) - 1;
        Crtc = (U008)(Val2 & 0xff);
        CRTC_WR(2, Crtc, Head);
        CRTC_RD(0x2D, Crtc, Head);
        Crtc &= ~BIT(2);
        if (Val2 & 0x100)               
            Crtc |= BIT(2);
        CRTC_WR(0x2D, Crtc, Head);
        break;
    case H_BLANK_END:
        Val2 = (Val >> 3) - 1;
        CRTC_RD(3, Crtc, Head);     // HBE bits 4:0
        Crtc &= 0xe0;
        Crtc |= (U008)(Val2 & 0x1f);
        CRTC_WR(3, Crtc, Head);
        CRTC_RD(5, Crtc, Head);
        Crtc &= ~BIT(7);
        if (Val2 & 0x20)               // HBE bit 5
            Crtc |= BIT(7);
        CRTC_WR(5, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(4);
        if (Val2 & 0x40)
            Crtc |= BIT(4);             // HBE bit 6
        CRTC_WR(0x25, Crtc, Head);
        break;
    case H_RETRACE_START:
        Val2 = (Val >> 3) + 1;
        Crtc = (U008) (Val2 & 0xFF);
        CRTC_WR(4, Crtc, Head);
        CRTC_RD(0x2D, Crtc, Head);
        Crtc &= ~BIT(3);
        if (Val2 & 0x100)
            Crtc |= BIT(3);
        CRTC_WR(0x2D, Crtc, Head);
        break;
    case H_RETRACE_END:
        Val2 = (Val >> 3) + 1;
        CRTC_RD(5, Crtc, Head);     // HRE bits 4:0
        Crtc &= 0xe0;
        Crtc |= (U008)(Val2 & 0x1f);
        CRTC_WR(5, Crtc, Head);
        break;
    case V_TOTAL:
        Val2 = Val - 2;
        Crtc = (U008) Val2;
        CRTC_WR(6, Crtc, Head);
        CRTC_RD(7, Crtc, Head);
        Crtc &= ~(0x21);
        if (Val2 & 0x100) Crtc |= BIT(0);
        if (Val2 & 0x200) Crtc |= BIT(5);
        CRTC_WR(7, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(0);
        if (Val2 & 0x400) Crtc |= BIT(0);
        CRTC_WR(0x25, Crtc, Head);
        CRTC_RD(0x41, Crtc, Head);
        Crtc &= ~BIT(0);
        if (Val2 & 0x800) Crtc |= BIT(0);
        CRTC_WR(0x41, Crtc, Head);
        break;
    case V_DISPLAY_END:
        Val2 = Val - 1;
        Crtc = (U008) Val2;
        CRTC_WR(0x12, Crtc, Head);    // VDE 7:0
        CRTC_RD(7, Crtc, Head);
        Crtc &= ~(0x42);
        if (Val2 & 0x100) Crtc |= BIT(1);  // VDE 8
        if (Val2 & 0x200) Crtc |= BIT(6);  // VDE 9
        CRTC_WR(7, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(1);
        if (Val2 & 0x400) Crtc |= BIT(1);  // VDE 10
        CRTC_WR(0x25, Crtc, Head);
        break;
    case V_RETRACE_START:
        Val2 = Val - 1;
        Crtc = (U008) Val2;
        CRTC_WR(0x10, Crtc, Head);
        CRTC_RD(7, Crtc, Head);
        Crtc &= ~(BIT(2) | BIT(7));
        if (Val2 & 0x100) Crtc |= BIT(2);  // VRS 8
        if (Val2 & 0x200) Crtc |= BIT(7);  // VRS 9
        CRTC_WR(7, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(2);
        if (Val2 & 0x400) Crtc |= BIT(2);  // VRS 10
        CRTC_WR(0x25, Crtc, Head);
        CRTC_RD(0x41, Crtc, Head);
        Crtc &= ~BIT(4);
        if (Val2 & 0x800) Crtc |= BIT(4);  // VRS 11
        CRTC_WR(0x41, Crtc, Head);
        break;
    case V_RETRACE_END:
        Val2 = Val - 1;
        CRTC_RD(0x11, Crtc, Head);
        Crtc &= 0xF0;
        Crtc |= (U008) (Val2 & 0x0F);
        CRTC_WR(0x11, Crtc, Head);
        break;
    case V_BLANK_START:
        Val2 = Val - 1;
        Crtc = (U008) Val2;
        CRTC_WR(0x15, Crtc, Head);
        CRTC_RD(7, Crtc, Head);
        Crtc &= ~BIT(3);
        if (Val2 & 0x100) Crtc |= BIT(3);  // VBS 8
        CRTC_WR(7, Crtc, Head);
        CRTC_RD(9, Crtc, Head);
        Crtc &= ~BIT(5);
        if (Val2 & 0x200) Crtc |= BIT(5);  // VBS 9
        CRTC_WR(9, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(3);
        if (Val2 & 0x400) Crtc |= BIT(3);  // VBS 10
        CRTC_WR(0x25, Crtc, Head);
        CRTC_RD(0x41, Crtc, Head);
        Crtc &= ~BIT(6);
        if (Val2 & 0x800) Crtc |= BIT(6);  // VBS 11
        CRTC_WR(0x41, Crtc, Head);
        break;
    case V_BLANK_END:
        Crtc = (U008) Val - 1;
        CRTC_WR(0x16, Crtc, Head);
        break;
    }
}

// Write a CRTC timing parameter into the CRTC registers
U032 dacGetCRTC
(
    PHWINFO pDev, 
    U032 Head, 
    U032 Param
)
{
    U008 Crtc;
    U032 Val=0, Val2;

    switch (Param) 
    {
    case H_TOTAL:
        CRTC_RD(0, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(0x2D, Crtc, Head);
        if (Crtc & BIT(0)) Val |= 0x100;
        Val = (Val + 5) * 8;
        break;
    case H_DISPLAY_END:
        CRTC_RD(1, Crtc, Head);
        Val = (U032)(Crtc + 1) * 8;
        break;
    case H_BLANK_START:
        CRTC_RD(2, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(0x2D, Crtc, Head);
        if (Crtc & BIT(2)) Val |= 0x100;
        Val = (Val + 1) * 8;
        break;
    case H_BLANK_END:
        CRTC_RD(3, Crtc, Head);     // HBE bits 4:0
        Val = (U032)(Crtc & 0x1f);
        CRTC_RD(5, Crtc, Head);
        if (Crtc & 0x80) Val |= 0x20;
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(4)) Val |= 0x40;
        Val++;
        Val2 = dacGetCRTC(pDev, Head, H_BLANK_START);
        Val2 >>= 3;                     // convert HRS back to real chars
        Val2++;
        if (Val >= (Val2 & 0x7f))       // if end > start, just add upper bits of start 
        {
            Val |= (Val2 & 0x180);
        }
        else
        {
            Val |= ((Val2 + 0x80) & 0x180);    // add Start + carry
        }
        Val *= 8;
        break;
    case H_RETRACE_START:
        CRTC_RD(4, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(0x2D, Crtc, Head);
        if (Crtc & BIT(3)) Val |= 0x100;
        Val--;
        Val *= 8;
        break;
    case H_RETRACE_END:
        CRTC_RD(5, Crtc, Head);     // HRE bits 4:0
        Val = (U032)(Crtc & 0x1f);
        Val--;
        Val2 = dacGetCRTC(pDev, Head, H_RETRACE_START);
        Val2 >>= 3;                     // convert HRS back to real chars
        Val2--;
        if (Val >= (Val2 & 0x1f))       // if end > start, just add upper bits of start 
        {
            Val |= (Val2 & 0x1E0);
        }
        else
        {
            Val |= ((Val2 + 0x20) & 0x1E0);    // add Start + carry
        }
        Val *= 8;
        break;
    case V_TOTAL:
        CRTC_RD(6, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(7, Crtc, Head);
        if (Crtc & BIT(0)) Val |= 0x100;
        if (Crtc & BIT(5)) Val |= 0x200;
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(0)) Val |= 0x400;
        CRTC_RD(0x41, Crtc, Head);
        if (Crtc & BIT(0)) Val |= 0x800;
        Val += 2;
        break;
    case V_DISPLAY_END:
        CRTC_RD(0x12, Crtc, Head);    // VDE 7:0
        Val = (U032)Crtc;
        CRTC_RD(7, Crtc, Head);
        if (Crtc & BIT(1)) Val |= 0x100;  // VDE 8
        if (Crtc & BIT(6)) Val |= 0x200;  // VDE 9
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(1)) Val |= 0x400;  // VDE 10
        Val++;
        break;
    case V_RETRACE_START:
        CRTC_RD(0x10, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(7, Crtc, Head);
        if (Crtc & BIT(2)) Val |= 0x100;  // VRS 8
        if (Crtc & BIT(7)) Val |= 0x200;  // VRS 9
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(2)) Val |= 0x400;  // VRS 10
        CRTC_RD(0x41, Crtc, Head);
        if (Crtc & BIT(4)) Val |= 0x800;  // VRS 11
        Val++;
        break;
    case V_RETRACE_END:
        CRTC_RD(0x11, Crtc, Head);
        Val = (U032)(Crtc & 0x0f);
        Val2 = dacGetCRTC(pDev, Head, V_RETRACE_START);
        if (Val >= (Val2 & 0x0f))       // if end > start, just add upper bits of start 
        {
            Val |= (Val2 & 0xFF0);
        }
        else
        {
            Val |= ((Val2 + 0x10) & 0xFF0);    // add Start + carry
        }
        Val++;
        break;
    case V_BLANK_START:
        CRTC_RD(0x15, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(7, Crtc, Head);
        if (Crtc & BIT(3)) Val |= 0x100;  // VBS 8
        CRTC_RD(9, Crtc, Head);
        if (Crtc & BIT(5)) Val |= 0x200;  // VBS 9
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(3)) Val |= 0x400;  // VBS 10
        CRTC_RD(0x41, Crtc, Head);
        if (Crtc & BIT(6)) Val |= 0x800;  // VBS 11
        Val++;
        break;
    case V_BLANK_END:
        CRTC_RD(0x16, Crtc, Head);
        Val = (U032)Crtc + 1;
        Val2 = dacGetCRTC(pDev, Head, V_RETRACE_START); // End = Start + width of sync
        if (Val >= (Val2 & 0xff))    // if low byte of end > low byte of start 
        {
            Val |= (Val2 & 0xf00);  // combine with upper bits of V_BLANK_START
        }
        else
        {
            Val |= ((Val2 + 0x100) & 0xf00);    // combine with upper bits of V_BLANK_START plus carry
        }
        break;
    }
    return Val;
}
//  Get CRTC timing values from either CRTC registers or Windows registry
RM_STATUS dacGetCRTCTiming
(
    PHWINFO pDev,
    U032    Head,
    NV_CFGEX_CRTC_TIMING_PARAMS    *Params
)
{
    U008    lock;

    if (Params->Reg & NV_CFGEX_CRTC_TIMING_REGISTER) // Get currect CRTC values
    {
        // Unlock extended registers
        lock = ReadCRTCLock(pDev, Head);
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
        
        Params->HTotal = dacGetCRTC(pDev, Head, H_TOTAL);    
        Params->HDisplayEnd = dacGetCRTC(pDev, Head, H_DISPLAY_END);    
        Params->HBlankStart = dacGetCRTC(pDev, Head, H_BLANK_START);    
        Params->HBlankEnd = dacGetCRTC(pDev, Head, H_BLANK_END);    
        Params->HRetraceStart = dacGetCRTC(pDev, Head, H_RETRACE_START);    
        Params->HRetraceEnd = dacGetCRTC(pDev, Head, H_RETRACE_END);    
        Params->VTotal = dacGetCRTC(pDev, Head, V_TOTAL);    
        Params->VDisplayEnd = dacGetCRTC(pDev, Head, V_DISPLAY_END);    
        Params->VRetraceStart = dacGetCRTC(pDev, Head, V_RETRACE_START);    
        Params->VRetraceEnd = dacGetCRTC(pDev, Head, V_RETRACE_END);    
        Params->VBlankStart = dacGetCRTC(pDev, Head, V_BLANK_START);    
        Params->VBlankEnd = dacGetCRTC(pDev, Head, V_BLANK_END);    
        
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
        return RM_OK;
    }
    else if (Params->Reg & NV_CFGEX_CRTC_TIMING_REGISTRY)   // Get values from registry
    {

        char    *strptr;
        U032    numBytes;
        char    strDisplayMode[] = "12345678901234567890";

        // fill in the path to the registry key--last character is the display number
        //JJV-New registry Process size = osStringLength(strDevNodeDisplayNumber);
        //JJV-New registry Process strDevNodeDisplayNumber[size - 1] = ('0' | (U008)devInstance);    // fill in ascii device #
        // now get the specific entry we need
        dacFindRegistryKeyDisplayPosition(pDev, Head, TRUE, strDisplayMode);
        // Copy the string and append the head number
        
        for (strptr = strDisplayMode; *strptr != NULL; strptr++) 
            ;
        *strptr++ = '_';
        *strptr++ = (char)(Head | 0x30);
        *strptr++ = 'T';                    // make sure to use different key than desktop position
        *strptr   = NULL;
        return osReadRegistryBinary(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, (U008 *)&Params->HTotal, &numBytes);
    }
    else // return default values for current mode
    {

        PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

        //
        // Grab the current dac settings (last modeset to come through on this head)
        //
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;


        Params->HTotal = pVidLutCurDac->HalObject.Dac[0].TotalWidth;    
        Params->HDisplayEnd = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
        Params->HBlankStart = pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart;
        Params->HBlankEnd = (pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart +
                                            pVidLutCurDac->HalObject.Dac[0].HorizontalBlankWidth);
        Params->HRetraceStart = pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart;
        Params->HRetraceEnd = (pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart +
                                            pVidLutCurDac->HalObject.Dac[0].HorizontalSyncWidth);
        Params->VTotal = pVidLutCurDac->HalObject.Dac[0].TotalHeight;
        Params->VDisplayEnd = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
        Params->VRetraceStart = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart;
        Params->VRetraceEnd = (pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart +
                                           pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight);
        Params->VBlankStart = pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart;
        Params->VBlankEnd = (pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart +
                                            pVidLutCurDac->HalObject.Dac[0].VerticalBlankHeight);

        //
        // There is a bug in NV hardware where the hardware cursor will not clip correctly
        // if a border is defined in the display timings (blank start != visible end).
        //
        // Borders are only defined in two specific DMT modes, so generally this is
        // not a problem.
        //
        // To fix this, set the blank starts to match the visible totals and remove the 
        // implicit borders.
        //
        // Remove this code when the hardware gets fixed.  Since this bug has been in the 
        // hardware since 1994, don't expect a fix soon.
        //
        //HorizontalBlankStart = HorizontalVisible;
        //HorizontalBlankEnd   = HorizontalTotal;
        //VerticalBlankStart   = VerticalVisible;
        //VerticalBlankEnd     = VerticalTotal;
        //
        // We want to return "default" values that match what the hardware really wants
        // us to program, not the true borders that exist in the DMT.  Otherwise a
        // client that uses this call to get hardware defaults, and then turns around
        // and programs the hardware with them, will get incorrect timings.
        //
        Params->HBlankStart = Params->HDisplayEnd;
        Params->HBlankEnd = Params->HTotal;
        Params->VBlankStart = Params->VDisplayEnd;
        Params->VBlankEnd = Params->VTotal;

        return RM_OK;
    }
}

//  Write caller's CRTC timing values into CRTC register and/or Windows Registry
RM_STATUS dacSetCRTCTiming
(
    PHWINFO pDev,
    U032    Head,
    NV_CFGEX_CRTC_TIMING_PARAMS    *Params
)
{

    U008    lock, data08;

    if (Params->Reg & NV_CFGEX_CRTC_TIMING_REGISTER) // Set CRTC values
    {
        
        // Unlock extended registers
        lock = ReadCRTCLock(pDev, Head);
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

        CRTC_RD(NV_CIO_CR_VRE_INDEX, data08, Head);
        CRTC_WR(NV_CIO_CR_VRE_INDEX, data08 & ~0x80, Head);    // unlock CR0-7


        // Write the CRTC's        
        dacSetCRTC(pDev, Head, H_TOTAL, Params->HTotal);
        dacSetCRTC(pDev, Head, H_DISPLAY_END, Params->HDisplayEnd);
        dacSetCRTC(pDev, Head, H_BLANK_START, Params->HBlankStart);
        dacSetCRTC(pDev, Head, H_BLANK_END, Params->HBlankEnd);       
        dacSetCRTC(pDev, Head, H_RETRACE_START, Params->HRetraceStart);
        dacSetCRTC(pDev, Head, H_RETRACE_END, Params->HRetraceEnd);     
        dacSetCRTC(pDev, Head, V_TOTAL, Params->VTotal);
        dacSetCRTC(pDev, Head, V_DISPLAY_END, Params->VDisplayEnd);
        dacSetCRTC(pDev, Head, V_BLANK_START, Params->VBlankStart);
        dacSetCRTC(pDev, Head, V_BLANK_END, Params->VBlankEnd);
        dacSetCRTC(pDev, Head, V_RETRACE_START, Params->VRetraceStart);
        dacSetCRTC(pDev, Head, V_RETRACE_END, Params->VRetraceEnd);

        //
        // Lock everything back up again
        //
        CRTC_RD(NV_CIO_CR_VRE_INDEX, data08, Head);
        CRTC_WR(NV_CIO_CR_VRE_INDEX, data08 | 0x80, Head);    // lock CR0-7
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);

    }
    if (Params->Reg & NV_CFGEX_CRTC_TIMING_REGISTRY) // Set Register values
    {
        char    *strptr;
        U032    numBytes = (NV_CFGEX_CRTC_PARAMS * 4) - 8;  // HTotal is 8 bytes in
        char    strDisplayMode[] = "12345678901234567890";

        // fill in the path to the registry key--last character is the display number
        //JJV-New registry Process size = osStringLength(strDevNodeDisplayNumber);
        //JJV-New registry Process strDevNodeDisplayNumber[size - 1] = ('0' | (U008)devInstance);    // fill in ascii device #
        // now get the specific entry we need
        dacFindRegistryKeyDisplayPosition(pDev, Head, TRUE, strDisplayMode);
        // append the head number
        for (strptr = strDisplayMode; *strptr != NULL; strptr++) 
            ;
        *strptr++ = '_';
        *strptr++ = (char)(Head | 0x30);
        *strptr++ = 'T';                    // make sure to use different key than desktop position
        *strptr   = NULL;
        return osWriteRegistryBinary(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, (U008 *)&Params->HTotal, numBytes);
    }
    return RM_OK;
}

//	See what is currently being used as a display
U032 dacGetBiosDisplayType
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    rc;
    U032    displayType;
    U008    lock;               

    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, rc, Head);
    if (rc & 0x80)    // is VGA slaved to something?
    {
        CRTC_RD(NV_CIO_CRE_LCD__INDEX, rc, Head);
        if (rc & 0x01)
            displayType = DISPLAY_TYPE_FLAT_PANEL;   
        else
            displayType = DISPLAY_TYPE_TV;      
    }
    else
    {
        displayType = DISPLAY_TYPE_MONITOR;
    }

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
    return displayType;
}

//  Read analog out comparator 
//  If the output is loaded, it will be below threshold
//  If no CRT is attached, it will trip
BOOL dacDetectTrigger(
    PHWINFO pDev
)
{
    U008 blank, data8;
    U032 retry;

#define MAXRETRIES 500000
    
    // wait for active
    retry = 0;
    do {
        blank = REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x1;
        retry++;
    } while ((retry < MAXRETRIES) && blank);
    if (retry >= MAXRETRIES)
        goto timedout;

    // wait for blank
    retry = 0;
    do {
        blank = REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x1;
        retry++;
    } while ((retry < MAXRETRIES) && !blank);
    if (retry >= MAXRETRIES)
        goto timedout;

    // wait for active
    retry = 0;
    do {
        blank = REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x1;
        retry++;
    } while ((retry < MAXRETRIES) && blank);
    if (retry >= MAXRETRIES)
        goto timedout;

    // get 2 samples which are the same to debounce
    retry = 0;
    do {
        data8 = (REG_RD08(NV_PRMCIO_INP0) & 0x10);
        retry++;
    } while ((retry < MAXRETRIES) && ((REG_RD08(NV_PRMCIO_INP0) & 0x10) != data8));
    if (retry >= MAXRETRIES)
    {
 timedout:
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: trigger detect timed out\n");
        return FALSE;
    }

    // sense bit in NV_PRMCIO_INP0 is inverted (0x1 = no trigger).
    if (data8)
        return FALSE;    // no trigger
    else
        return TRUE;     // trigger
}



// Check whether monitor is currently connected
BOOL dacMonitorConnectStatus
(
    PHWINFO pDev,
    U032    Head
)
{
    RM_STATUS status;
    U008    lock;
    U032    Current;

    if (using_new_api == FALSE) {
        //
        // Make sure monitor is supported on this head.
        //
        if ((GETCRTCHALINFO(pDev, Head, DisplayTypesAllowed) & DISPLAYTYPEBIT(DISPLAY_TYPE_MONITOR)) == 0)
            return FALSE;

        //
        // For NV11 TwinView, make sure head isn't in use by another display device
        //
        if (!pDev->Power.MobileOperation)
            if (IsNV11(pDev))
            {
                if (GETDISPLAYTYPE(pDev, Head ^ 1) != 0xFFFFFFFF) // if both heads in use
                {
                    Current = GETDISPLAYTYPE(pDev, Head);
                    if (Current == DISPLAY_TYPE_FLAT_PANEL) // then only the current type is allowed (except TV)
                        return FALSE;
                }
            }

        // Mobile devices should never have CRT on Head 1
        if (pDev->Power.MobileOperation && (Head == 1)) 
            return FALSE;
    }

//#ifdef USE_EDID_TO_TEST_CRT_CONNECT
    if ((IsNV11(pDev)) && (Head == 1))
    {
    // Attempt to read EDID and check for analog display. On head 1 there is no way to do the analog out test below.
        lock = ReadCRTCLock(pDev, Head);    // Unlock the registers

        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

        // read EDID 
        status = EDIDRead(pDev, Head, DISPLAY_TYPE_MONITOR);        // Try to read EDID

        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);

        if (status == RM_OK)        
        {
            if (edidIsAnalogDisplay(pDev, Head))
                return TRUE;
            else    
                return FALSE;
        }
        else
            return FALSE;   // the analog test (below) will not work on head 1--it always returns TRUE.
    }
//#endif

    status = EDIDDetect(pDev, Head, DISPLAY_TYPE_MONITOR);      // Try to read EDID
    if (status) 
    {
        if (Head != 1) // Head 1 does not have an internal DAC, so we cannot do the analog check.
        {
            // EDID did not confirm that a CRT is connected, but it may be an older non-DDC CRT,
            // so procede with analog out test.
            return (dacVGAConnectStatus(pDev, Head));
        }
        return FALSE;       // EDID read failed on Head1, so no CRT
    }

    return TRUE;
}

#ifdef MACOS
// XXX Enable old style on the Mac
//     This one can timeout 5 times in dacDetectTrigger(), the new one 
//     can time out about 255 times!

#define USE_TESTPOINT_DATA
#endif

BOOL dacVGAConnectStatus
(
    PHWINFO pDev, 
    U032    Head
)
{
    U032	dacPowerDown;
    U016	Sr1;
    U008	retries;
    BOOL    result = 0;
#ifndef USE_TESTPOINT_DATA
    U032 bgr, cur_palette[256], red_palette[256];
    U032 i, red_trigger, dacControl;
#endif

    // This test drives a selected amount of current out the DAC Red
    // output. This currect causes a voltage drop over the terminating
    // resistor (no CRT connected) or the terminating resistor in parallel
    // with the CRT load.  There is a voltage comparator which is sampled at
    // port 3C2. (Actually 3, on for each color.)  This indicates whether the
    // voltage at the output resistor has crossed a reference level.  If a CRT
    // is connected, the amount of current required to reach this level will
    // be twice (this can vary depending on the board) that required if there
    // is not a CRT.  (e.g. 75 ohms on the board, in parallel with 75 ohms at
    // the monitor = 37.5 ohms).  At the selected current level, we check to
    // see whether the comparator has flipped.  If so, there must be no CRT
    // connected (75 ohm load). If not, there is additional loading, i.e.  a
    // CRT is connected.

#ifdef USE_TESTPOINT_DATA
    // This shortened test replaces the traditional method of ramping up the
    // palette. We set the DAC into a test mode which bypasses the palette,
    // and set one level of analog out which we know will differentiate
    // between CRT and no CRT.
#endif
    
    Sr1 = ReadIndexed(NV_PRMVIO_SRX, 0x01);      
    if (Sr1 & 0x2000)
        WriteIndexed(NV_PRMVIO_SRX, (U016)(Sr1 & ~0x2000)); // turn off blank

    // make sure the DAC is driving RGB out
    dacPowerDown = REG_RD32(NV_PRAMDAC_TEST_CONTROL);
    FLD_WR_DRF_DEF( _PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _ON);

#ifdef USE_TESTPOINT_DATA
    // set to test mode--bypass palette
    FLD_WR_DRF_DEF( _PRAMDAC, _TEST_CONTROL, _TP_INS_EN, _ASSERTED);
    // set to level corresponding to roughly 300 mv
    REG_WR32(NV_PRAMDAC_TESTPOINT_DATA, RED_OUT_300MV);
#endif

    tmrDelay(pDev, 10000000);	// delay 10 ms to allow DAC to power up
    
#ifdef USE_TESTPOINT_DATA
    // The function dacDetectTrigger debounces the samples.
    // We will call dacDetectTrigger multiple times to insure
    // stability on a longer time interval as well.
    retries = 0;
    result = dacDetectTrigger(pDev);
    while (retries < MAXCRTRETRIES) 
    {
        BOOL result2;	

        result2 = dacDetectTrigger(pDev);
        if (result == result2) 
            break;
        result = result2;
        retries++;
    }
    FLD_WR_DRF_DEF( _PRAMDAC, _TEST_CONTROL, _TP_INS_EN, _DEASSERTED); // test mode off

    if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_MONITOR)
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head);   // CRT off

    if (retries == MAXCRTRETRIES)
        result = TRUE;  // if the test is not working, assume CRT is present        
    
    return result;
#else
    //
    // Here's the "ramping up the palette" method for detecting if a CRT is
    // present, reimplemented from what the BIOS had. The USE_TESTPOINT_DATA
    // version seemed not very reliable and frequently gave false CRT
    // detections. 
    // 
    // The palette version in testing gave no false detections for many test
    // loops and did correctly detect the monitor when it was present. The
    // red_trigger value used was tested on NV5/NV10/NV15 and NV11.
    //

    // save the current palette 
    DAC_REG_WR08(NV_USER_DAC_READ_MODE_ADDRESS, 0, Head);
    for (i = 0; i < 256; i++)
    {
        bgr = DAC_REG_RD08(NV_USER_DAC_PALETTE_DATA, Head);     // b
        bgr <<= 8;
        bgr |= DAC_REG_RD08(NV_USER_DAC_PALETTE_DATA, Head);    // g
        bgr <<= 8;
        bgr |= DAC_REG_RD08(NV_USER_DAC_PALETTE_DATA, Head);    // r
        cur_palette[i] = bgr;
    }

    // these red values rely on being interpreted as 6 bits per color
    dacControl = DAC_REG_RD32(NV_PRAMDAC_GENERAL_CONTROL, Head);
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _6BITS, Head);

    for (red_trigger = 0x8; red_trigger < 0x3F; red_trigger++)
    {
        // Load the red palette with the new values
        for (i = 0; i < 256; i++)
            red_palette[i] = (0x8 << 16) | (0x8 << 8) | red_trigger;

        dacProgramLUT(pDev, Head, red_palette, 256);

        for (retries = 0; retries < MAXCRTRETRIES; retries++) {
            result = dacDetectTrigger(pDev);
            if (result == dacDetectTrigger(pDev))
                break;
        }

        if (retries == MAXCRTRETRIES)
            return TRUE;    // no consistent read (assume something's connected)

        if (result == TRUE)
            break;          // triggered, so check the value
    }

    // restore the previous dac control
    DAC_REG_WR32(NV_PRAMDAC_GENERAL_CONTROL, dacControl, Head);

    // restore the previous palette
    dacProgramLUT(pDev, Head, cur_palette, 256);

    if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_MONITOR)
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head);	// CRT off

    if (red_trigger < 0x18)
        return FALSE;
    else
        return TRUE;
#endif
}


// Check whether flat panel is currently connected
BOOL dacFlatPanelConnectStatus
(
    PHWINFO pDev,
    U032    Head
)
{
    RM_STATUS status;
    U008 lock;

    if (using_new_api == FALSE) {
        //
        // Make sure flatpanel allowed on this head.
        //
        if ((GETCRTCHALINFO(pDev, Head, DisplayTypesAllowed) & DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL)) == 0)
            return FALSE;

        //
        // If the other head is TV, we can't do it (P38 with external TMDS, P41 with internal is OK)
        // TODO: Need to change this to a dynamic check based on feedback from the BIOS topology table
        // If we're using the 12bit wide FP interface, then FP/TV can share and are allowed.
        //
        if ((GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_TV) && !pDev->Power.MobileOperation &&
            (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_FP_IFACE) == NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_24BIT))
            return FALSE;
    
        // if the other head is already a DFP, we can't do it (P38).
        //
        // TODO: Need to change this to a dynamic check based on feedback from the BIOS topology table
        //
        // Check dac object for the other head to see if the driver is using the flat panel. Previous check in HAL for 
        // display type is not correct because the boot device may be flat panel, but this should not limit us from changing
        // to a new configuration when the driver loads.
        if (pDev->Dac.DFP2PortID == NV_I2C_PORT_SECONDARY)   // is P38? 
        {
#if 0
            PVIDEO_LUT_CURSOR_DAC_OBJECT AltDacObj = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head^1].pVidLutCurDac;
            if (AltDacObj != NULL) 
            {
                if (AltDacObj->DisplayType == DISPLAY_TYPE_FLAT_PANEL)
        //        if (GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_FLAT_PANEL)
                    return FALSE;
            }
#endif    
            if ((pDev->Dac.DesktopState == NV_DAC_DESKTOP_STATE_MULTI) && (Head == 0))  
                            // In multi head mode, limit DFP to head 1 only, since we can't know what the driver is going to do
                            // i.e., this gets called for both heads before the driver does a modeset on either head,
                            // so the driver could attempt to use DFP on both.
            {
                return FALSE;
            }
        }
    }

    lock = UnlockCRTC(pDev, Head);

	// read EDID 
    status = EDIDRead(pDev, Head, DISPLAY_TYPE_FLAT_PANEL);     // Try to read EDID

    RestoreLock(pDev, Head, lock);

    if (status != RM_OK)
        return FALSE;

	if (edidIsDigitalDisplay(pDev, Head)) 				// Check the display technology byte
    {
        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_FLAT_PANEL;
        return TRUE;
    }
    return FALSE;
}

U032 dacGetFlatPanelConfig
(
    PHWINFO pDev,
    U032    Head
)
{
    U032 mode;
    
    mode = DAC_REG_RD32(NV_PRAMDAC_FP_TG_CONTROL, Head); 
    return(DRF_VAL(_PRAMDAC, _FP_TG_CONTROL, _MODE, mode)); 
}
    


RM_STATUS dacGetFlatPanelInfo
(
    PHWINFO pDev,
    U032    Head,
    U032    *FpMode,
    U032    *FpMaxX,
    U032    *FpMaxY,
    BOOL    *FpConnected,
    BOOL    *FlatPanelNativeSupported,
    BOOL    fromRegistry
)
{
    U032      mode;
    RM_STATUS status;

    // Get info from EDID
	if (!dacFlatPanelConnectStatus(pDev, Head))	// FP connected?
	{
		*FpConnected = NV_CFGEX_GET_FLATPANEL_INFO_NOT_CONNECTED;
		return RM_OK;						// then no more to do
	}
	if ((status = fpParseEDID(pDev, Head)) != RM_OK) // parse EDID to get timing info
        return status;
    
    *FpConnected = NV_CFGEX_GET_FLATPANEL_INFO_CONNECTED;
    *FpMaxX = pDev->Dac.fpHMax;
    *FpMaxY = pDev->Dac.fpVMax;
    *FlatPanelNativeSupported = FALSE;
    if (pDev->Dac.fpNative)
        *FlatPanelNativeSupported = TRUE;

    if (fromRegistry)
    {
        //JJV-New registry Process   char * strDisplayMode;
        //JJV-New registry Process   U032   size;
        // read it from the registry
        // fill in the path to the registry key--last character is the display number
        //JJV-New registry Process size = osStringLength(pDev->Registry.DBstrDevNodeDisplayNumber);
        //JJV-New registry Process pDev->Registry.DBstrDevNodeDisplayNumber[size - 1] = ('0' | (U008)devInstance);    // fill in ascii device #
        status = OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strFpMode, &mode);
    if (status == RM_OK)
            *FpMode = mode;
    else
        *FpMode = NV_CFGEX_GET_FLATPANEL_INFO_NATIVE;
    }
    else
    {
        mode = dacGetFlatPanelConfig(pDev, Head);
        *FpMode = mode;
        status = RM_OK;
    }

    return status;
}

// Check whether TV is currently connected
// This only works for the Brooktree encoder
BOOL dacTVConnectStatus
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    read, ack, lock, encoderPower, reg0e, reg10, reg3d, i;
    BOOL    connect;
    U032    retry;

    if (using_new_api == FALSE) {
        //
        // Make sure TV allowed on this head.
        //
        if ((GETCRTCHALINFO(pDev, Head, DisplayTypesAllowed) & DISPLAYTYPEBIT(DISPLAY_TYPE_TV)) == 0)
            return FALSE;
    }

    //
    // For NV11, make sure TV isn't in use by other head.
    // For P38 boards (external TMDS), we cannot run both TV and flat panel. This will change if we use internal TMDS,
    // but we'll have to get that info from the BIOS. Until then, TV + DFP is not allowed.
    //
    if (IsNV11(pDev))
    {
        if (using_new_api == FALSE) {
            // If the other head already has the TV, we can't use it.
            if (GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_TV)  
                return FALSE;

            //
            // If the other head is flat panel, we can't do it (only if this board is using external TMDS)
            // or if we're using the 12bit wide FP interface, then FP/TV can share and are allowed.
            //
            if ((GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_FLAT_PANEL) && !pDev->Power.MobileOperation &&
                (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_FP_IFACE) == NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_24BIT))
                return FALSE;

            // If the other head is CRT on head 1, we can't do it (only if this board is using external TMDS)
            if ((GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_MONITOR) && (Head == 0))
                return FALSE;
        }
        
        //
        // Make sure that i2c/tv ownership is setup properly.
        //
        AssocDDC(pDev, Head);
        AssocTV(pDev, Head);
    }

    lock = UnlockCRTC(pDev, Head);
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_CHRONTEL:
            // Set power to "normal"
            // Chrontel 7007 wants bit 7 set on register address
            
            // Read Power Management Register to preserve contents
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID));
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0E); // 0x0e = PM register
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &reg0e,1);
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            
            // Powered up? No, then do so
            if ((reg0e & 3) != 3) {
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0E); // 0e = power register
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x0b); // ON + RESET HIGH
                }
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);


            // Some initialization is necessary on the 7007 to make the detection work.
            // Exactly what needs to be set, I don't know, but the following 2 register initializations do it.

            // Set data format
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // 04 = input data format reg
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x05);      // set to NTSC for now
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            
            // Set clocking
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // 06 = clock mode
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x40);      // 
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            
            // In the 7008, reg 3D bits 2:0 must be cleared for detection to work
            // Don't know what effect it has on others, so we'll special case it.
            if (pDev->Dac.EncoderType == NV_ENCODER_CHRONTEL_7008) {

                // Read Reg 3D to preserve contents
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_3D); // 3D = ?
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                    i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &reg3d,1);
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

                if (ack == 0) {
                    // clear mystery bits 2:0 so TV connect detection will work
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                        ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                    }
                    if (ack == 0) {
                        ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_3D); // 
                        ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(reg3d & 0xf8)); 
                    }
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                }
            } // 7008

            // Read Connection Detect Register to preserve contents
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_10); // 10 = connect detect register
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &reg10,1);
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

            if (ack == 0) {
                // Set Sense bit to tell encoder to check for TV connected
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_10); // 10 = connect detect register
                    reg10 &= 0x0f;  // clear bits 7:4
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(reg10 | 1)); // sense bit <= 1
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }

            if (ack == 0) {
                // Reset Sense bit 
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_10); // 10 = connect detect register
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x00); // sense bit <= 0
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }

            if (ack == 0) {
                // Read Connect reg - restart read
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_10); // 10 = connect detect register
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                    i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }
            // If no head is using TV, blank image.
            for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
                    break;
            if (i == pDev->Dac.HalInfo.NumCrtcs)
                dacDisableTV(pDev, Head);
            if  ((ack == 0 ) &&     // If we failed some how, we fail this
                 ((read & 0x0e) ^ 0x0e))     // 0 indicates connection
                                    // bit 3: Y (luma), bit 2: C (chroma), bit 1: composite
                connect = TRUE;
            else
                connect =  FALSE;
            break;
   

        case TV_ENCODER_BROOKTREE:

            // Turn DAC on before checking status
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);   // subaddress
            ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_ON);    // DAC ON
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

            // Give it some time for the outputs to stabilize
            tmrDelay(pDev, 20000000);         // 20 ms delay    

            // Set Check Status bit to tell encoder to check for TV connected.
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                if (ack)
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after first address byte while detecting TV connection\n\r");
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL); // subaddress
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_STAT); // set check stat
            } else {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after first address byte while detecting TV connection\n\r");
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            if (ack != 0) {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK during first transaction while detecting TV connection\n\r");
            }

            //870/871 supports direct register reads.  The older chips require a more involved procedure.
            if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871) {
                if (ack == 0) {
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                        if (ack)
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after third address byte while detecting TV connection\n\r");
                    }
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x06);
                }

                if (ack == 0) {
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID | 1));   // Add read bit
                        if (ack)
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after third address byte while detecting TV connection\n\r");
                    }
                    if (ack == 0) {
                        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read, 1);
                    } else {
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after third address byte while detecting TV connection\n\r");
                    }
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                }
            } else {
                if (ack == 0) {
                    // Set Estat to select status register 1
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                        if (ack)
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after second address byte while detecting TV connection\n\r");
                    }
                    if (ack == 0) {
                        ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0xC4);   // subaddress
                        ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x41);   // set estat (estat 01 + en_out)
                    } else {
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after second address byte while detecting TV connection\n\r");
                    }
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                    if (ack != 0) {
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK during second transaction while detecting TV connection\n\r");
                    }
                }

                if (ack == 0) {
                    // Read Monitor Status bits
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID | 1));   // Add read bit
                        if (ack)
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after third address byte while detecting TV connection\n\r");
                    }
                    if (ack == 0) {
                        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read, 1);
                    } else {
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after third address byte while detecting TV connection\n\r");
                    }
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                } 
            }

            if (ack == 0) {
                // Reset Check Status -- not documented, but very important (can't program encoder if not done).
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                    ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                    if (ack)
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after last address byte while detecting TV connection\n\r");
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL); // subaddress
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_OFF); // set check stat
                } else {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after last address byte while detecting TV connection\n\r");
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                if (ack != 0) {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK during last transaction while detecting TV connection\n\r");
                }
            }

            if (ack) // if any error occurred, go to monitor
                return (FALSE);

            if (read & BT_MONSTAT)  // any connection deteced?
                connect = TRUE;
            else
                connect =  FALSE;

            // If no head is using TV, blank image.
            for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
                    break;
            if (i == pDev->Dac.HalInfo.NumCrtcs)
                dacDisableTV(pDev, Head);
            break;
        
       case TV_ENCODER_PHILIPS:
           // Turn Power On -- Read/Modify/Write
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
           }
           if (ack == 0) {
              ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x61); // 
              i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
              ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
              i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           encoderPower = read;
           read &= 0x3f;   // power on
           // Write Power bits
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x61);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) read);   // 
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           
           // Set Monitor Sense Threshold
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1a);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x46);   // MSM threshold
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

           // Set Monitor Sense Threshold
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1a);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x46);   // MSM threshold
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

           // Set Monitor Sense Mode
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1b);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x80);   // MSM
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

           // Read sense bits
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
           }
           if (ack == 0) {
              ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x1b); // 
              i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
              ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
              i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           if ((read & 0x07) == 0x07)    // check C and Y inputs
               connect = FALSE;
           else
               connect = TRUE;                                    
           // Reset Monitor Sense Mode
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1b);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x00);   // MSM
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           // Restore power state
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x61);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) encoderPower);   // power
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           break;
        default:
                connect =  FALSE;
    }
    RestoreLock(pDev, Head, lock);

    // restore TV connection if TV is connected on the other head
    if (GETDISPLAYTYPE(pDev, Head ^ 0x1) == DISPLAY_TYPE_TV) {
        AssocDDC(pDev, Head ^ 0x1);
        AssocTV(pDev, Head ^ 0x1);
    }
    return connect;
}

//  Set the text cursor blink rate depending on the display type
//  The BIOS won't do this, so we have to.
VOID dacSetCursorBlink
(
    PHWINFO pDev,
    U032    Head,
    U008    Rate
)
{
U008    data;

    if (IsNV5(pDev)) // This is a problem in NV5 only
    {
        // another undocumented register
        CRTC_RD(NV_CIO_CRE_TREG__INDEX, data, Head);
        data &= ~0x80;
        if (Rate)   // CRT set bit 7 to 0, FP & TV set to 1
            data |= 0x80;
        CRTC_WR(NV_CIO_CRE_TREG__INDEX, data, Head);
    }
}

// Unlock extended CRTC and return former state of lock
U008 UnlockCRTC
(
    PHWINFO pDev,
    U032    Head
)
{
U008 lock;
    
    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
    return lock;
}
VOID RestoreLock
(
    PHWINFO pDev, 
    U032    Head, 
    U008    lock
)
{
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
}
//  Read extended CRTC lock register and return corresponding write value
U008 ReadCRTCLock
(
    PHWINFO pDev,
    U032    Head
)
{
U008 data;

    CRTC_RD(NV_CIO_SR_LOCK_INDEX, data, Head);
    switch (data)
    {
        case 0x03:
            data = 0x57;
            break;
        case 0x01:
            data = 0x75;
            break;
        case 0x00:
        default:
            data = 0x99;
            break;
    }
    return data;
}

VOID dacSetFan
(
    PHWINFO pDev,
    U008    state
)
{
U008 data, lock;
U032 Head = 0;

    if(IsNV10orBetter(pDev))
    {
        lock = ReadCRTCLock(pDev, Head);
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
        CRTC_RD(0x35, data, Head);
        data &= ~0x02;      // bit 1 = output enable (active low) 
        if (state == 0)
        {
            // OFF
            CRTC_WR(0x35, data & ~0x01, Head);  // bit 0 = fan control (active high)
        }
        else
        {
            // ON
            CRTC_WR(0x35, data | 0x01, Head);       // bit 0 = fan control (active high)
        }
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
    }
}

RM_STATUS dacGetColorSaturationBoost
(
    PHWINFO pDev,
    U032    Head,
    U008    *boostValue
)
{
    U008 lock;

    if (IsNV11(pDev) == FALSE)
        return CONFIG_GETEX_BAD_READ;    // not supported pre-NV11

    // unlock extended regs
    CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

    // get the color boost value
    CRTC_RD(NV_CIO_CRE_CSB, *boostValue, Head);

    // restore extended regs lock state
    if (lock == 0) {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, Head);
    } else if (lock == 1) {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RO_VALUE, Head);
    }
    return RM_OK;
}

RM_STATUS dacSetColorSaturationBoost
(
    PHWINFO pDev,
    U032    Head,
    U008    boostValue
)
{
    U008 lock;

    if (IsNV11(pDev) == FALSE)
        return CONFIG_GETEX_BAD_READ;    // not support pre-NV11

    if (boostValue > NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_750)
        return CONFIG_SETEX_BAD_PARAM;    // 75% is the largest value

    // unlock extended regs
    CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

    // set the color saturation boost value
    CRTC_WR(NV_CIO_CRE_CSB, boostValue, Head);

    // restore extended regs lock state
    if (lock == 0) {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, Head);
    } else if (lock == 1) {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RO_VALUE, Head);
    }
    return RM_OK;
}

#ifdef MACOS
/*
 * The fcode on the mac implements Apple's monitor selection policy
 *  (what device to boot on, etc).  The fcode then publishes this information
 *  in the registry.
 *
 * Here we read that information.
 *
 * "displayA"      --  HHIILLTT
 * "displayB"      --  HHIILLTT
 * "display-type"  -- "CRT" or "LCD"  preferred boot device
 *
 * Decoder ring:
 *             HH -- head
 *             II -- i2c status port base
 *             LL -- TMDS link info
 *             TT -- display type (0 = crt, 3 = digital flat panel)
 *
 * If a display is not present, then the value will be 0x??FFFFFF.
 *
 * On the iMac / P11, displayA would be 00FFFF00 (Head A, no I2C port, no TMDS
 * link, CRT) and displayB would be 013E0103 (Head B, I2C 3E/3F, Link 2, DFP).
 *
 */

RM_STATUS dacMacReadBIOSDisplaySettings(
    PHWINFO pDev
)
{
    U032 displayA, displayB;
    U032 head, i2cport, tmdslink, displaytype;
    char primary_displaytype_string[16];
    U032 reglen;

    displayA = ~0;
    displayB = ~0;

    osReadRegistryDword(pDev, (char *) 0, "displayA", &displayA);
    osReadRegistryDword(pDev, (char *) 0, "displayB", &displayB);
    if ((displayA == ~0) && (displayB == ~0))
        return RM_ERROR;

    // what is 

    reglen = sizeof(primary_displaytype_string);
    osMemSet(primary_displaytype_string, 0, reglen);
    osReadRegistryBinary(pDev,
                         (char *) 0,
                         "display-type",
                         (U008 *) primary_displaytype_string,
                         &reglen);


    // parse out displayA settings

    if ((displayA & 0x00FFFFFF) != 0x00FFFFFF)
    {
        head =        (displayA >> 24) & 0xFF;
        i2cport =     (displayA >> 16) & 0xFF;
        tmdslink =    (displayA >> 8)  & 0xFF;
        displaytype = (displayA >> 0)  & 0xFF;

        if (i2cport == 0xff)
            i2cport = 0x36;
        pDev->Dac.I2CPrimaryStatusIndex = i2cport;
        pDev->Dac.I2CPrimaryWriteIndex = i2cport + 1;
    }
    
    if ((displayB & 0x00FFFFFF) != 0x00FFFFFF)
    {
        head =        (displayB >> 24) & 0xFF;
        i2cport =     (displayB >> 16) & 0xFF;
        tmdslink =    (displayB >> 8)  & 0xFF;
        displaytype = (displayB >> 0)  & 0xFF;

        pDev->Dac.I2CSecondaryStatusIndex = i2cport;
        pDev->Dac.I2CSecondaryWriteIndex = i2cport + 1;
    }

    // is CRT on primary or secondary
    pDev->Dac.CRTPortID  = NV_I2C_PORT_PRIMARY;
    pDev->Dac.DFPPortID  = NV_I2C_PORT_PRIMARY;
    pDev->Dac.CRT2PortID = NV_I2C_PORT_SECONDARY;
    pDev->Dac.DFP2PortID = NV_I2C_PORT_SECONDARY;
 
    return  RM_OK;
}

#endif // MACOS



//
// Extract the relevant I2C values from any arbitrary version of BMP structure
// Update the nvInfo structure with the location of the TV and FP ports.
RM_STATUS dacReadBIOSI2CSettings(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;

#ifdef IKOS
    pDev->Dac.I2CPrimaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
    pDev->Dac.I2CPrimaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
    pDev->Dac.I2CSecondaryWriteIndex = NV_CIO_CRE_DDC0_WR__INDEX;
    pDev->Dac.I2CSecondaryStatusIndex = NV_CIO_CRE_DDC0_STATUS__INDEX;
    pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
    pDev->Dac.TVOutPortID = NV_I2C_PORT_SECONDARY;
    pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
#else

    if ( !IsNV5orBetter(pDev) || IsNV0A(pDev) )
    {
        // This is a one DDC port device
        pDev->Dac.I2CPrimaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
        pDev->Dac.I2CPrimaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
        pDev->Dac.I2CSecondaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
        pDev->Dac.I2CSecondaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
        pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
        pDev->Dac.TVOutPortID = NV_I2C_PORT_PRIMARY;
        pDev->Dac.DFPPortID = NV_I2C_PORT_PRIMARY;
    }
    else
    {
        U032 offset;
        BMP_Control_Block bmpCtrlBlk;

        // This device has two DDC ports, set defaults

        pDev->Dac.I2CPrimaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
        pDev->Dac.I2CPrimaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
        pDev->Dac.I2CSecondaryWriteIndex = NV_CIO_CRE_DDC0_WR__INDEX;
        pDev->Dac.I2CSecondaryStatusIndex = NV_CIO_CRE_DDC0_STATUS__INDEX;
        pDev->Dac.I2CTertiaryWriteIndex = NV_CIO_CRE_DDC2_WR__INDEX;
        pDev->Dac.I2CTertiaryStatusIndex = NV_CIO_CRE_DDC2_STATUS__INDEX;
        pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
        pDev->Dac.TVOutPortID = NV_I2C_PORT_SECONDARY;
        pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
        
        // NV11, NV20 have three DDC ports
        if (IsNV11(pDev))
        {
#if 0 // We can no longer assume that VGA is the boot device. We assume that we can talk to VGA over I2C 0 and DFP over I2C 1
      // unless we find a registry override.
            // determine if this is VGA + ? or DVI/DVI board
            if (dacVGAConnectStatus(pDev, 0))  // Is there VGA on I2C 0? (Uses analog comparator)
            {
                // VGA is mapped to I2C 0, so the secondary could be VGA or DFP on I2C 1
                pDev->Dac.CRT2PortID = NV_I2C_PORT_SECONDARY;   // second CRT uses I2C 1
                pDev->Dac.DFPPortID = NV_I2C_PORT_TERTIARY;     // No primary DFP--set to unused port
                pDev->Dac.DFP2PortID = NV_I2C_PORT_SECONDARY;   // second DFP uses I2C 1
            }
            else // no CRT, assume dual DFP
            {
                if (dacFlatPanelConnectStatus(pDev, 0)) // this will try to find EDID on I2C 1
                {
                    // DVI on I2C 1 and 2                
                    pDev->Dac.DFP2PortID = NV_I2C_PORT_TERTIARY;   // secondary DFP uses I2c 2
                }
                else // No DFP after all, assume CRT with no EDID
                {
                    pDev->Dac.CRT2PortID = NV_I2C_PORT_SECONDARY;   // second CRT uses I2C 1
                    pDev->Dac.DFPPortID = NV_I2C_PORT_TERTIARY;    // set to unused port
                    pDev->Dac.DFP2PortID = NV_I2C_PORT_TERTIARY;   // set to unused port
                }
            }
#else
            U032 val = 0;
            char strDualDVI[] = "Dual DVI";

            // VGA is mapped to I2C 0, so the secondary could be VGA or DFP on I2C 1
            pDev->Dac.CRT2PortID = NV_I2C_PORT_SECONDARY;   // second CRT uses I2C 1
            pDev->Dac.DFPPortID = NV_I2C_PORT_TERTIARY;     // No primary DFP--set to unused port
            pDev->Dac.DFP2PortID = NV_I2C_PORT_SECONDARY;   // second DFP uses I2C 1
            
            // registry override for dual DVI board -- Flat Panels connected to I2C 1 and 2
            OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strDualDVI, &val);
            if (val) 
            {
                pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
                pDev->Dac.DFP2PortID = NV_I2C_PORT_TERTIARY;   // secondary DFP uses I2c 2
            }
#endif        
        }

#ifdef MACOS
        // the Mac is *special*
        // The fcode sets registry properties to indicate i2c mappings
        //    If we find these registry settings, we'll use them,
        //    otherwise we'll look for the BMP bios table.
        if (RM_OK == dacMacReadBIOSDisplaySettings(pDev))
            return RM_OK;
#endif

        // Attempt to find the I2C info in the BIOS' BMP tables
        rmStatus = DevinitGetBMPControlBlock(pDev,
                                             &bmpCtrlBlk,
                                             &offset);
        if (rmStatus == RM_OK)
        {
            switch ( bmpCtrlBlk.CTL_Version )
            {
                // version 0 is for Nv3, no others exist
                case BMP_INIT_TABLE_VER_0:
                case BMP_INIT_TABLE_VER_1:
                {
                    // There is no I2C info in these BIOS's.
                    break;
                }
                    
                // BMP init table version 2 & 3
                case BMP_INIT_TABLE_VER_2:
                case BMP_INIT_TABLE_VER_3:
                {
                    //PBMP_Struc_Rev3 BMP_InitTableInfo = (PBMP_Struc_Rev3)pBmpCtrlBlk;
                    BIOSI2CTable biosI2CTable;
                    
                    rmStatus = BiosReadStructure(pDev,
                                                 (U008 *) &biosI2CTable,
                                                 0x40,
                                                 (U032 *) 0,
                                                 BMP_I2C_FMT);
                    if (rmStatus == RM_OK)
                    {
                        pDev->Dac.I2CPrimaryWriteIndex = biosI2CTable.I2CPort0IO & 0xFF;
                        pDev->Dac.I2CPrimaryStatusIndex = ( biosI2CTable.I2CPort0IO >> 8 ) & 0xFF;
                        pDev->Dac.I2CSecondaryWriteIndex = biosI2CTable.I2CPort1IO & 0xFF;;
                        pDev->Dac.I2CSecondaryStatusIndex = ( biosI2CTable.I2CPort1IO >> 8 ) & 0xFF;
                        pDev->Dac.CRTPortID = biosI2CTable.CRTI2CPort;
                        pDev->Dac.TVOutPortID = biosI2CTable.TVI2CPort;
                        pDev->Dac.DFPPortID = biosI2CTable.DFPI2CPort;
                    }
                    break;
                }
        
                // BMP init table version >= BMP_INIT_TABLE_VER_4 ( 4 )
                default:
                {
                    BMP_Struc_Rev4 bmp_InitTableInfo ;
                    
                    rmStatus = BiosReadStructure(pDev,
                                                 (U008 *) &bmp_InitTableInfo,
                                                 offset,
                                                 (U032 *) 0,
                                                 BMP_INIT4_FMT);

                    if (rmStatus == RM_OK)
                    {
                        pDev->Dac.I2CPrimaryWriteIndex = bmp_InitTableInfo.BMP_I2CPort0IO & 0xFF;
                        pDev->Dac.I2CPrimaryStatusIndex = ( bmp_InitTableInfo.BMP_I2CPort0IO >> 8 ) & 0xFF;
                        pDev->Dac.I2CSecondaryWriteIndex = bmp_InitTableInfo.BMP_I2CPort1IO & 0xFF;;
                        pDev->Dac.I2CSecondaryStatusIndex = ( bmp_InitTableInfo.BMP_I2CPort1IO >> 8 ) & 0xFF;
                        pDev->Dac.CRTPortID = bmp_InitTableInfo.BMP_CRTI2CPort;
                        pDev->Dac.TVOutPortID = bmp_InitTableInfo.BMP_TVI2CPort;
                        pDev->Dac.DFPPortID = bmp_InitTableInfo.BMP_DFPI2CPort;
                    }
                    break;
                }
            }
        }

        // Verify that there are no non-zero values in these reg indexes as these should never be 0       
        // This fixes a bug in which Diamond stuffs 0s into the bitmap
        if( (pDev->Dac.I2CPrimaryWriteIndex == 0x00)   ||
            (pDev->Dac.I2CPrimaryStatusIndex == 0x00)  ||
            (pDev->Dac.I2CSecondaryWriteIndex == 0x00) ||
            (pDev->Dac.I2CSecondaryStatusIndex == 0x00) ) {

            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid I2C info in bios image\n");

            // Someone gave us bogus values, so set all of these to the defaults
            pDev->Dac.I2CPrimaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
            pDev->Dac.I2CPrimaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
            pDev->Dac.I2CSecondaryWriteIndex = NV_CIO_CRE_DDC0_WR__INDEX;
            pDev->Dac.I2CSecondaryStatusIndex = NV_CIO_CRE_DDC0_STATUS__INDEX;
            pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
            pDev->Dac.TVOutPortID = NV_I2C_PORT_SECONDARY;
            pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
        }

    }
#endif

    return rmStatus;
}

//
// Return head number specified in alloc request.
//
U032 dacGetHead
(
    PCLASS pClass,
    VOID *pCreateParms
)
{
    RM_STATUS   status = RM_OK;
    U032 Head = 0;

    if (pCreateParms == NULL)
        return Head;

    switch (pClass->Type)
    {
        case NV15_VIDEO_LUT_CURSOR_DAC:
        {
            NV07C_ALLOCATION_PARAMETERS Class07cParams;
            status = osCopyIn(pCreateParms, (U008*) &Class07cParams, sizeof (NV07C_ALLOCATION_PARAMETERS));
            if (status != RM_OK)
                return 0;
            Head = Class07cParams.logicalHeadId;
        }
        default:
            // for everything else, it's head 0
            break;
    }

    return Head;
}

RM_STATUS
dacCreateObj(VOID* pDevHandle, PCLASSOBJECT ClassObject, U032 Name, POBJECT *Object, VOID *pCreateParms)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;
    RM_STATUS                    status = RM_OK;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    PCLASS                       pClass = ClassObject->Base.ThisClass;
    U008                         *bytePtr;
    U032                          i, head;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: dacCreateObj\r\n");
    
    //
    // Check allocation restrictions.
    //

    //
    // Check head assignment.
    //
    head = dacGetHead(pClass, pCreateParms);
    if (head >= pDev->Dac.HalInfo.NumCrtcs)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: dacCreateObj: invalid logical head number ", head);
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    //
    // For synchronized multi-head flips, init the sync counter
    //
    pDev->Dac.MultiSyncCounter = pDev->Dac.HalInfo.NumCrtcs;

    //
    // Alloc memory for class dependent object state.
    // All DAC engine objects currently use the same structure.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEO_LUT_CURSOR_DAC_OBJECT));
    if (status)
        return (status);

    //
    // Nice casts to make the code more readable.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)*Object;

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pVidLutCurDac;
    for (i = 0; i < sizeof (VIDEO_LUT_CURSOR_DAC_OBJECT); i++)
       *bytePtr++ = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(&pVidLutCurDac->CBase, ClassObject, Name);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    pVidLutCurDac->HalObject.Head = head;
    status = nvHalDacAlloc(pDev, pVidLutCurDac->CBase.ChID, pVidLutCurDac->CInstance, pClass->Type, (VOID *)&pVidLutCurDac->HalObject);

    if (status == RM_OK)
    {
        //
        // Build a FIFO/Hash context for this object
        //
        status = fifoUpdateObjectInstance(pDev,
                                          &pVidLutCurDac->CBase, 
                                          pVidLutCurDac->CBase.ChID, 
                                          pVidLutCurDac->CInstance);
    }

    if (status)
    {
        osFreeMem(*Object);
        return (status); 
    }

    //
    // If we're in a multimon mode, and this is the first dac object
    // to be instantiated for a given head, be sure to swing the
    // VGA space over the *other* head.  By doing this, we can
    // be sure that any VGA accesses done between the time the
    // first and second heads are accessible will safely go out
    // to the second head.  This won't always necessarily be what
    // we want (e.g. blue screens), but it's better than having
    // Windows start routing VGA accesses to the primary head (while
    // it's got a desktop going) in response to detection of
    // the second head.
    //
    if (pDev->Dac.DesktopState == NV_DAC_DESKTOP_STATE_MULTI)
    {
        if (pDev->Dac.CrtcInfo[head].RefCount == 0)
            EnableHead(pDev, head^1);
    }

    //
    // Bump up reference count on this.
    //
    pDev->Dac.CrtcInfo[head].RefCount++;

    return (RM_OK);
}

RM_STATUS
dacDestroyObj(VOID* pDevHandle, POBJECT Object)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;
    RM_STATUS               status = RM_OK;
    PCLASS                  pClass;
    U032                    buffNum;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

#if !defined(NTRM)
    U008    data08, lock;
#endif

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: dacDestroyObj\r\n");

    //
    // Just in case...
    //
    if (Object == NULL)
        return (RM_OK);

    //
    // Clear the subChannel ptrs for this object 
    //
	osEnterCriticalCode(pDev);
	fifoDeleteSubchannelContextEntry(pDev, Object);
	osExitCriticalCode(pDev);

    //
    // Nice cast to make the code more readable.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    pClass = Object->ThisClass;
    nvHalDacFree(pDev, pVidLutCurDac->CBase.ChID, pVidLutCurDac->CInstance, pClass->Type, (VOID *)&pVidLutCurDac->HalObject);

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pVidLutCurDac->CBase, pVidLutCurDac->CBase.ChID); 
    if (status)
        return (status);

    //
    // Cleanup any pending VBlank callbacks
    //
    for (buffNum = 0; buffNum < 2; buffNum++) {
        VBlankDeleteCallback(pDev, pVidLutCurDac->HalObject.Head, &(pVidLutCurDac->Image[buffNum].ImageCallback));
        VBlankDeleteCallback(pDev, pVidLutCurDac->HalObject.Head, &(pVidLutCurDac->LUT[buffNum].LUTCallback));
        VBlankDeleteCallback(pDev, pVidLutCurDac->HalObject.Head, &(pVidLutCurDac->CursorImage[buffNum].CursorImageCallback));
    }

    //
    // Decrement reference count.
    //
    // Turn off DAC if this is last object instance associated
    // with this (non-primary) head
    //
    if (--pDev->Dac.CrtcInfo[pVidLutCurDac->HalObject.Head].RefCount == 0)
    {
        if (pVidLutCurDac->HalObject.Head != 0)
            dacDisableDac(pDev, pVidLutCurDac->HalObject.Head);
    }

    //Remove the pointer to this object -- whether this ptr is NULL is used
    // to determine whether this head is disabled.
    if (pVidLutCurDac == (PVIDEO_LUT_CURSOR_DAC_OBJECT)(pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac)) 
    {
#if !defined(NTRM)
        //Runtime clone mode switch support -- turn off display when associated object it is destroyed.
        if (!pDev->Vga.Enabled) {
            dacDisableDac(pDev, pVidLutCurDac->HalObject.Head); 

            //Also, if mobile BIOS, let the BIOS know we've done this.
            lock = ReadCRTCLock(pDev, pVidLutCurDac->HalObject.Head);           //Back up lock state
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, pVidLutCurDac->HalObject.Head);    //Unlock CRTC extended regs
            if (pDev->Power.MobileOperation &&  pDev->HotKeys.enabled) {
                CRTC_RD(0x3B, data08, pVidLutCurDac->HalObject.Head);
                CRTC_WR(0x3B, (data08 & 0x0F), pVidLutCurDac->HalObject.Head);
            }

            CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, pVidLutCurDac->HalObject.Head); // Restore lock state
        }
#endif                                                          
        SETDISPLAYTYPE(pDev, DACGETHEAD(pVidLutCurDac), DISPLAY_TYPE_NONE);
        pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = NULL;
        pDev->Dac.HalInfo.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = NULL;
    }

    //
    // And finally delete the object itself    
    //    
    return (osFreeMem(Object));
}

//
// EnableHead
//
// Set DAC address space mode in CR44 (H2OWNS)
// register so that CIO/VIO/PRMVIO addressing 
// goes to the specified head.
//
VOID EnableHead
(
    PHWINFO pDev,
    U032    Head
)
{
    U008 data08, temp;

    if (!IsNV11(pDev))
        return;

    if (pDev->Dac.HalInfo.Head2RegOwner == HEAD2_OWNER_UNKNOWN) {
        // Set the initial values, if this is the first call.
        if (Head == 1)
            data08 = 3;
        else
            data08 = 0;
    } else {
        // CR44 has a bug; memory mapped reads don't work, so we use a shadow copy.
        data08 = (U008)pDev->Dac.HalInfo.Head2RegOwner;
        if (Head == 1) 
        {
            // Did CR44 already point to head 1
            if ((data08 & 0x3) == 3)
                return;
            data08 |= 3;
        }
        else
        {
            // Did CR44 already point to head 0
            if ((data08 & 0x3) == 0)
                return;
            data08 &= ~3;
        }
    }

    //We've determined experimentally that leaving 3d4 pointing at CR44
    // gives rise to many complications.  So we do a dummy access here
    // to avoid that problem.
    CRTC_WR(NV_CIO_CRE_H2OWNS, data08, 0);
    CRTC_RD(NV_CIO_SR_LOCK_INDEX, temp, 0);
    pDev->Dac.HalInfo.Head2RegOwner = (U032)data08;
}

// Multi-head DDC switching (ENGINE_CTRL update routine).
VOID AssocDDC(PHWINFO pDev, U032 Head)
{
    if (Head == 0)
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _I2C, _ENABLE, 0);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _I2C, _DEFAULT, 1);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _I2C, _ENABLE, 1);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _I2C, _DEFAULT, 0);
    }
}

// Multi-head TV switching (ENGINE_CTRL update routine).
VOID AssocTV(PHWINFO pDev, U032 Head)
{
    if (Head == 0)
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _TV, _ENABLE, 0);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _TV, _DEFAULT, 1);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _TV, _ENABLE, 1);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _TV, _DEFAULT, 0);
    }
}

// Multi-head VideoScalar switching (ENGINE_CTRL update routine).
VOID AssocVideoScalar(PHWINFO pDev, U032 Head)
{
    if (Head == 0)
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _VS, _ENABLE, 0);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _VS, _DEFAULT, 1);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _VS, _ENABLE, 1);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _VS, _DEFAULT, 0);
    }
}


//Set a flag to let the BIOS know not to handle hotkey events itself.
//Set while in Windows, cleared in full-screen DOS.  Mobile only.
VOID EnableMobileHotkeyHandling(PHWINFO pDev)
{
    U008 lock, data;

    if (pDev->Power.MobileOperation) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Driver-based hotkey handling enabled\n\r");

        lock = ReadCRTCLock(pDev, 0);           //Back up lock state
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 0);    //Unlock CRTC extended regs

        //Clear any pending events
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, data, 0);
        data &= ~(NV_MOBILE_FLAG_SCALE_MASK | NV_MOBILE_FLAG_DISPLAY_MASK);
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, data, 0);

        //Notify BIOS we're enabling driver hotkey handling.
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, data, 0);
        CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, data | NV_DRIVER_HANDLES_HOTKEYS, 0);

        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, 0); // Restore lock state

        //Workaround: head 1's bit, too.
        lock = ReadCRTCLock(pDev, 1);           //Back up lock state
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 1);    //Unlock CRTC extended regs

        //Clear any pending events
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, data, 1);
        data &= ~(NV_MOBILE_FLAG_SCALE_MASK | NV_MOBILE_FLAG_DISPLAY_MASK);
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, data, 1);

        //Notify BIOS we're enabling driver hotkey handling.
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, data, 1);
        CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, data | NV_DRIVER_HANDLES_HOTKEYS, 1);

        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, 1); // Restore lock state

        pDev->HotKeys.enabled = TRUE;
    }
}


//Clear flag so BIOS knows to handle hotkey events itself.
//Set while in Windows, cleared in full-screen DOS.  Mobile only.
VOID DisableMobileHotkeyHandling(PHWINFO pDev)
{
    U008 lock, data;

    if (pDev->Power.MobileOperation) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Driver-based hotkey handling disabled\n\r");

        lock = ReadCRTCLock(pDev, 0);           //Back up lock state
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 0);    //Unlock CRTC extended regs

        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, data, 0);
        CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, data & ~NV_DRIVER_HANDLES_HOTKEYS, 0);

        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, 0); // Restore lock state

        //Workaround: head 1's bit, too.
        lock = ReadCRTCLock(pDev, 1);           //Back up lock state
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 1);    //Unlock CRTC extended regs

        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Driver-based hotkey handling disabled\n\r");
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, data, 1);
        CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, data & ~NV_DRIVER_HANDLES_HOTKEYS, 1);

        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, 1); // Restore lock state

        pDev->HotKeys.enabled = FALSE;
    }
}

//---------------------------------------------------------------------------
//
//  VBlank service handler.
//
//---------------------------------------------------------------------------
V032 dacService
(
    PHWINFO pDev
)
{
    U032 head, pmc, pending;
    RM_STATUS status;

    pending = 0;

    pmc = REG_RD32(NV_PMC_INTR_0);
    if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
        pending |= 0x1;
    if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING))
        pending |= 0x2;

    //
    // Check for any VBlank actions. Service count was already updated in VBlank
    //
    status = RM_OK;
    if (pDev->Framebuffer.FinishFlags)
        status |= grVBlank(pDev);
#if DEBUG
    if (status)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Problems in dacService.\n\r");
        DBG_BREAKPOINT();
    }
#endif // DEBUG

    VBlank(pDev);

    // Clear 'em all...
    for (head = 0; head < MAX_CRTCS; head++)
    {
        if (pending & BIT(head))
            DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, head);
    }
    return (0x00000000);
}

// read/parse the Display Config Block (DCB) from the BIOS.  only revisions 1.2 and up support
// this feature
RM_STATUS dacParseDCBFromBIOS
(
    PHWINFO pDev
)
{
    extern char strDevNodeRM[];
    U016        offset;             // offset from NV BIOS base
    U016        DCBBase;            // offset of DCB from BIOS base
    U032        CRTs = 0;           // # of CRT connectors
    U032        DDs = 0;            // # of DD connectors
    U032        TVs = 0;            // # of TV connectors
    U032        DevDescs = 0;       // # of valid DCB device descriptors
    U032        CRTCs = 0;          // # of CRTCs
    U032        I2cPorts;           // # of I2C ports
    U032        i;
    U032        j;
    U032        *pI2cPort;

    DCBBase = BIOS_RD16(DCB_PTR_OFFSET);
    //if (BIOS_RD08(DCBBase + DCB_REVISION_OFFSET) < DCB_FIRST_REVISION) {
    if (1) {
        // fake DCB records for older board
#define SETUP_DCB_DESC(i,a,b,c,d,e,f,g)                                     \
        pDev->Dac.DCBDesc[i].DCBRecType = DCB_DEV_REC_TYPE_##a;             \
        pDev->Dac.DCBDesc[i].DCBRecSubtype = DCB_DEV_REC_SUBTYPE_##b;       \
        pDev->Dac.DCBDesc[i].DCBRecFmt = DCB_DEV_REC_FMT_##c;               \
        pDev->Dac.DCBDesc[i].DCBRecIdxToICB = DCB_DEV_REC_LOGICAL_PORT_##d; \
        pDev->Dac.DCBDesc[i].DCBRecHead = DCB_DEV_REC_HEAD_##e;             \
        pDev->Dac.DCBDesc[i].DCBRecLocation = DCB_DEV_REC_LOCATION_##f;     \
        pDev->Dac.DCBDesc[i].DCBRecBus = DCB_DEV_REC_BUS_##g;

        if (IsNV11(pDev)) {
            pDev->Dac.DCBI2c[0].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[0].WritePort = I2C_PHYSICAL_PORT_A_DATA;
            pDev->Dac.DCBI2c[0].ReadPort = I2C_PHYSICAL_PORT_A_STATUS;

            pDev->Dac.DCBI2c[1].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[1].WritePort = I2C_PHYSICAL_PORT_B_DATA;
            pDev->Dac.DCBI2c[1].ReadPort = I2C_PHYSICAL_PORT_B_STATUS;

            pDev->Dac.DCBI2c[2].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[2].WritePort = I2C_PHYSICAL_PORT_C_DATA;
            pDev->Dac.DCBI2c[2].ReadPort = I2C_PHYSICAL_PORT_C_STATUS;

            pDev->Dac.DCBI2c[3].I2cAccess = I2C_PORT_ACCESS_UNUSED;
            I2cPorts = 3;

            if (pDev->Power.MobileOperation) {
                //                TYPE      SUBTYPE FMT     I2C_IDX HEAD    LOCATION BUS
                SETUP_DCB_DESC(0, DD_SLINK, UNUSED, UNUSED, UNUSED, B,      UNUSED, 0); 
                SETUP_DCB_DESC(1, DD_SLINK, UNUSED, UNUSED, UNUSED, A,      UNUSED, 0); 
                SETUP_DCB_DESC(2, CRT,      UNUSED, UNUSED, 0,      A,      UNUSED, 1); 
                SETUP_DCB_DESC(3, CRT,      UNUSED, UNUSED, 0,      B,      UNUSED, 1); 
                SETUP_DCB_DESC(4, TV,       UNUSED, UNUSED, 1,      A,      UNUSED, 2); 
                SETUP_DCB_DESC(5, TV,       UNUSED, UNUSED, 1,      B,      UNUSED, 2); 
                SETUP_DCB_DESC(6, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED); 
                DevDescs = 6;
                CRTCs = 2;
            }
            else {
                //                TYPE      SUBTYPE FMT     I2C_IDX HEAD    LOCATION BUS
                SETUP_DCB_DESC(0, CRT,      UNUSED, UNUSED, 0,      A,      UNUSED, 0); 
                SETUP_DCB_DESC(1, DD_SLINK, UNUSED, UNUSED, 1,      A,      UNUSED, 1); 
                SETUP_DCB_DESC(2, DD_SLINK, UNUSED, UNUSED, 1,      B,      UNUSED, 1); 
                SETUP_DCB_DESC(3, CRT,      UNUSED, UNUSED, 1,      B,      UNUSED, 2); 
                SETUP_DCB_DESC(4, TV,       UNUSED, UNUSED, 1,      A,      UNUSED, 1); 
                SETUP_DCB_DESC(5, TV,       UNUSED, UNUSED, 1,      B,      UNUSED, 1); 
                SETUP_DCB_DESC(6, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED); 
                DevDescs = 6;
                CRTCs = 2;
            }
        }
        else {  // non NV11 boards
            pDev->Dac.DCBI2c[0].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[0].WritePort = I2C_PHYSICAL_PORT_A_DATA;
            pDev->Dac.DCBI2c[0].ReadPort = I2C_PHYSICAL_PORT_A_STATUS;
            pDev->Dac.DCBI2c[1].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[1].WritePort = I2C_PHYSICAL_PORT_B_DATA;
            pDev->Dac.DCBI2c[1].ReadPort = I2C_PHYSICAL_PORT_B_STATUS;
            pDev->Dac.DCBI2c[2].I2cAccess = I2C_PORT_ACCESS_UNUSED;
            I2cPorts = 2;

            //                TYPE      SUBTYPE FMT     I2C_IDX HEAD    LOCATION BUS
            SETUP_DCB_DESC(0, CRT,      UNUSED, UNUSED, 0,      A,      UNUSED, 0); 
            SETUP_DCB_DESC(1, DD_SLINK, UNUSED, UNUSED, 1,      A,      UNUSED, 0); 
            SETUP_DCB_DESC(2, TV,       UNUSED, UNUSED, 1,      A,      UNUSED, 0); 
            SETUP_DCB_DESC(3, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED); 
            DevDescs = 3;
            CRTCs = 1;
        }
    }
    else {
        // read DCB device descriptors. endianess ?
        offset = DCBBase + DCB_DEV_DESC_OFFSET;
        for (i = 0; i < DCB_MAX_NUM_DEVDESCS; i++) {
            pDev->Dac.DCBDesc[i].DCBDevRec.DevRec_U032 = BIOS_RD32(offset);
            if (pDev->Dac.DCBDesc[i].DCBRecType == DCB_DEV_REC_TYPE_EOL)
                break;
            offset += sizeof(U032);

            pDev->Dac.DCBDesc[i].DataPtr = BIOS_RD16(offset);
            offset += sizeof(U016);

            pDev->Dac.DCBDesc[i].DCBDevData.DataDword = BIOS_RD32(offset);
            offset += sizeof(U032);

            // keep track of the highest head number
            if (pDev->Dac.DCBDesc[i].DCBRecHead > CRTCs)
                CRTCs = pDev->Dac.DCBDesc[i].DCBRecHead;
        }
        DevDescs = i;   // # of device descriptors, excluding EOL
        CRTCs++;        // head number is zero based

        // read the I2C Configuration Block (ICB). endianess ?
        offset = BIOS_RD16(DCBBase + DCB_ICB_OFFSET);
        pI2cPort = (U032 *)pDev->Dac.DCBI2c;
        for (i = 0; i < DCB_MAX_NUM_I2C_RECORDS; i++) {
            *pI2cPort++ = BIOS_RD32(offset);
    
            if (pDev->Dac.DCBI2c[i].I2cAccess == I2C_PORT_ACCESS_UNUSED)
                break;

            offset += sizeof(U032);
        }
        I2cPorts = i;
    }
    
    // override nvHalmcControl_nv10 setting
    DACHALINFO(pDev, NumCrtcs) = CRTCs;

    // find all devices with no I2C port.  these are the built in devices.
    // currently, only the flat panel on laptop doesn't have an I2C port
    // associate with it.  assume at most one device of each type.
    for (i = 0; i < DevDescs; i++) {
        if (pDev->Dac.DCBDesc[i].DCBRecIdxToICB == DCB_DEV_REC_LOGICAL_PORT_UNUSED) {
            switch (pDev->Dac.DCBDesc[i].DCBRecType) {
            case DCB_DEV_REC_TYPE_CRT:
                pDev->Dac.DCBDesc[i].DevTypeUnit = 0x1 << DAC_CRT_OFFSET_IN_MAP;
                CRTs = 1;
                break;

            case DCB_DEV_REC_TYPE_TV:
                pDev->Dac.DCBDesc[i].DevTypeUnit = 0x1 << DAC_TV_OFFSET_IN_MAP;
                TVs = 1;
                break;

            case DCB_DEV_REC_TYPE_DD_SLINK:
            case DCB_DEV_REC_TYPE_DD_DLINK:
                pDev->Dac.DCBDesc[i].DevTypeUnit = 0x1 << DAC_DD_OFFSET_IN_MAP;
                DDs = 1;
                break;
            }
        }
    }

    // assign device unit number according to the I2C port number.  devices
    // of the same type connected to the same I2C port have the same unit
    // number since they use the same connnector.
    for (i = 0; i < I2cPorts; i++) {
        int     CRTFound;
        int     TVFound;
        int     DDFound;

        CRTFound = TVFound = DDFound = 0;
        for (j = 0; j < DevDescs; j++) {
            if (pDev->Dac.DCBDesc[j].DCBRecIdxToICB != i)
                continue;

            switch (pDev->Dac.DCBDesc[j].DCBRecType) {
            case DCB_DEV_REC_TYPE_CRT:
                pDev->Dac.DCBDesc[j].DevTypeUnit = 0x1 << (DAC_CRT_OFFSET_IN_MAP + CRTs);
                CRTFound = 1;
                break;

            case DCB_DEV_REC_TYPE_TV:
                pDev->Dac.DCBDesc[j].DevTypeUnit = 0x1 << (DAC_TV_OFFSET_IN_MAP + TVs);
                TVFound = 1;
                break;

            case DCB_DEV_REC_TYPE_DD_SLINK:
            case DCB_DEV_REC_TYPE_DD_DLINK:
                pDev->Dac.DCBDesc[j].DevTypeUnit = 0x1 << (DAC_DD_OFFSET_IN_MAP + DDs);
                DDFound = 1;
                break;

            }
        }

        CRTs += CRTFound;
        TVs += TVFound;
        DDs += DDFound;
    }

    // create devices bitmap
    pDev->Dac.DevicesBitMap = (((0x1 << CRTs) - 1) << DAC_CRT_OFFSET_IN_MAP) |
        (((0x1 << TVs) - 1) << DAC_TV_OFFSET_IN_MAP) |
        (((0x1 << DDs) - 1) << DAC_DD_OFFSET_IN_MAP);

    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "DevicesConnected", &pDev->Dac.DevicesNoCheck) != RM_OK)
        pDev->Dac.DevicesNoCheck = 0x0;

    return RM_OK;
}

// find the connect status of the specified devices.  a set bit
// in the bit map mean the calling routine want to know the connect
// status of the corresponding device.  this routine will keep a set
// bit set if the corresponding device is connected, clear a set bit
// if the corresponding device is not connected.
VOID dacDevicesConnectStatus
(
    PHWINFO pDev,
    U032    *pDevBitMap
)
{
    U032            dev = *pDevBitMap;
    PDACDCBDEVDESC  pDevDesc;
    U032            CurrDevTypeUnit = 0x1;
    BOOL            status;

    using_new_api = TRUE;
    while (dev) {
        if (dev & 0x1) {
            if (CurrDevTypeUnit & pDev->Dac.DevicesNoCheck)
                goto NextDev;

            // go through all entries in the DCB to find matching devices.
            pDevDesc = pDev->Dac.DCBDesc;
            while (pDevDesc->DCBRecType != DCB_DEV_REC_TYPE_EOL) {
                if  (pDevDesc->DevTypeUnit == CurrDevTypeUnit) {
                    if (pDevDesc->DCBRecIdxToICB == DCB_DEV_REC_LOGICAL_PORT_UNUSED)
                        goto NextDev;

                    switch (pDevDesc->DCBRecType)  {
                    case DCB_DEV_REC_TYPE_CRT:
                        status = dacMonitorConnectStatus(pDev, pDevDesc->DCBRecHead);
                        break;

                    case DCB_DEV_REC_TYPE_TV:
                        status = dacTVConnectStatus(pDev, pDevDesc->DCBRecHead);
                        break;

                    case DCB_DEV_REC_TYPE_DD_SLINK:
                    case DCB_DEV_REC_TYPE_DD_DLINK:
                        status = dacFlatPanelConnectStatus(pDev, pDevDesc->DCBRecHead);
                        break;
                    }

                    if (status == FALSE)
                        // clear the corresponding bit if no devices found.
                        *pDevBitMap &= ~CurrDevTypeUnit;

                    goto NextDev;
                }
                pDevDesc++;
            }
        }

NextDev:
        dev >>= 1;
        CurrDevTypeUnit <<= 1;
    }
    using_new_api = FALSE;
}

// this routine will try to find a configuration for the specified
// devices. return FALSE if a suitable configuration cannot be found.
// the configuration is returned in pAllocationMap with the first nibble
// corresponds to the first/rightmost device, second nibble corresponds
// to the second device, ... up to 8 devices can be specified. the nibble
// value is the head that should be connected to the device.
static BOOL dacMapDeviceToHead
(
    PHWINFO     pDev,
    U032        DevBitMap,          // devices in configuration
    U032        HeadsUsed,          // assigned heads
    U032        BusesUsed,          // assigned buses
    U032        CurrDev,            // current device
    U032        NibbleToUse,        // nibble to use for the next allocation
    U032        *pAllocationMap     // allocation map, result that will be passed
                                    // back to the calling routine
)
{
    PDACDCBDEVDESC  pDevDesc;

    // done, no more device
    if (!DevBitMap)
        return TRUE;

    // look for the rightmost set bit
    while (!(DevBitMap & 0x1)) {
        DevBitMap >>= 1;
        CurrDev++;
    }

    // use recursion to map device to head, one at a time.
    pDevDesc = pDev->Dac.DCBDesc;
    while (pDevDesc->DCBRecType != DCB_DEV_REC_TYPE_EOL) {
        if (pDevDesc->DevTypeUnit != ((U032)0x1 << CurrDev))
            goto NextDevDesc;

        // make sure we are not using resources assigned already.
        if (((0x1 << pDevDesc->DCBRecHead) & HeadsUsed) ||
            ((0x1 << pDevDesc->DCBRecBus) & BusesUsed))
            goto NextDevDesc;

        if (dacMapDeviceToHead(pDev,
                               DevBitMap >> 1,
                               HeadsUsed | (0x1 << pDevDesc->DCBRecHead),
                               BusesUsed | (0x1 << pDevDesc->DCBRecBus),
                               CurrDev + 1,
                               NibbleToUse + 1,
                               pAllocationMap) == TRUE) {
            *pAllocationMap |= pDevDesc->DCBRecHead << (NibbleToUse * 4);
            return TRUE;
        }

NextDevDesc:
        pDevDesc++;
    }

    return FALSE;
}

// find a suitable configuration for the specified devices.
RM_STATUS dacFindDevicesConfiguration
(
    PHWINFO pDev,
    U032    NewDevBitMap,
    U032    *pNewAllocationMap,
    U032    OldDevBitMap,
    U032    OldAllocationMap
)
{
    U032        DevBitMap;
    U032        CurrDev;
    U032        NibbleToUse;
    U032        HeadsUsed = 0x0;     // heads used
    U032        BusesUsed = 0x0;     // buses used
    U032        head;
    PDACDCBDEVDESC pDevDesc;
    U032        AdjustedOldAllocationMap = 0x0;
    U032        AdjustedNibbleToUse;
    U032        NewConfig;

    // find common devices between the old and new configurations. keep them
    // attaching to the same CRTCs if possible.
    DevBitMap = OldDevBitMap;
    CurrDev = NibbleToUse = AdjustedNibbleToUse = 0;
    while (DevBitMap) {
        if (!(DevBitMap & 0x1))
            goto NextDev_0;

        // device in the old but not in the new configuration ?
        if (!(OldDevBitMap & NewDevBitMap & (0x1 << CurrDev))) {
            NibbleToUse++;
            goto NextDev_0;
        }

        // device is in both the old and new configurations.
        // find CRTCs attached to the device and mark it as used.
        // adjust old allocation map such that we can merge it with the new
        // allocation map later.
        head = (OldAllocationMap >> (NibbleToUse++ * 4)) & 0xf;
        HeadsUsed |= 0x1 << head;
        AdjustedOldAllocationMap |= head << (AdjustedNibbleToUse++ * 4);

        // determine other non-shared resources used by this device.
        pDevDesc = pDev->Dac.DCBDesc;
        while (pDevDesc->DCBRecType != DCB_DEV_REC_TYPE_EOL) {
            if ((pDevDesc->DevTypeUnit != ((U032)0x1 << CurrDev)) ||
                (pDevDesc->DCBRecHead != head))
                pDevDesc++;
            else {
                BusesUsed |= 0x1 << pDevDesc->DCBRecBus;
                break;
            }
        }

NextDev_0:
        DevBitMap >>= 1;
        CurrDev++;
    }

    // find new allocation with common devices at fixed CRTCs.
    NewConfig = 0x0;
    if (dacMapDeviceToHead(pDev,
                           (NewDevBitMap ^ OldDevBitMap) & NewDevBitMap,
                           HeadsUsed,
                           BusesUsed,
                           0,
                           0,
                           &NewConfig) == TRUE) {

        // no merging necessary if there are no common devices.
        if (!(OldDevBitMap & NewDevBitMap)) {
            *pNewAllocationMap = NewConfig;
            return RM_OK;
        }

        // merge configuration.
        DevBitMap = NewDevBitMap;
        *pNewAllocationMap = 0x0;
        CurrDev = NibbleToUse = 0;
        while (DevBitMap) {
            if (!(DevBitMap & 0x1))
                goto NextDev_1;

            if ((0x1 << CurrDev) & OldDevBitMap) {
                *pNewAllocationMap |= (AdjustedOldAllocationMap & 0xf) << (NibbleToUse++ * 4);
                AdjustedOldAllocationMap >>= 4;
            }
            else {
                *pNewAllocationMap |= (NewConfig & 0xf) << (NibbleToUse++ * 4);
                NewConfig >>= 4;
            }

NextDev_1:
            DevBitMap >>= 1;
            CurrDev++;
        }

        return RM_OK;
    }

    // couldn't find allocation with common devices at fixed CRTCs.
    // try to get allocation with no CRTCs fixed.
    if (OldDevBitMap & NewDevBitMap) {
        *pNewAllocationMap = 0x0;
        if (dacMapDeviceToHead(pDev,
                               NewDevBitMap,
                               0x0,
                               0x0,
                               0,
                               0,
                               pNewAllocationMap) == TRUE)
            return RM_OK;
    }

    return RM_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\class\nv\class.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CLASS.C                                                           *
*     Object Classes are defined in this module.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <mc.h>
#include <gr.h>
#include <dac.h>
#include <tmr.h>
#include <os.h>
#include <modular.h>
#include <nv32.h>


//---------------------------------------------------------------------------
//
//  Class methods.
//
//---------------------------------------------------------------------------

METHOD NvPatchcordMethods[] =
{
    {mthdSetNotifyCtxDma,           0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107}
    //{mthdValidate,                  0x0300, 0x0303}
};
METHOD NvClassMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdCreateLegacy,              0x0300, 0x0303},
    {mthdDestroy,                   0x0304, 0x0307},
};
METHOD NvDmaFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetDmaSpecifier,           0x0300, 0x030b}
};
METHOD NvDmaToMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetDmaSpecifier,           0x0300, 0x030b}
};
METHOD NvDmaInMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetDmaSpecifier,           0x0300, 0x030b}
};
METHOD NvVideoSinkMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetVideoInput,             0x0200, 0x02ff}
};
METHOD NvVideoColormapMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetColormapCtxDma,         0x0184, 0x0187},
    {mthdSetVideoOutput,            0x0200, 0x0203},
    {mthdSetVideoInput,             0x0204, 0x0207},
    {mthdSetColormapStart,          0x0308, 0x030b},
    {mthdSetColormapLength,         0x030c, 0x030f},
    {mthdColormapDirtyStart,        0x0310, 0x0313},
    {mthdColormapDirtyLength,       0x0314, 0x0317}
};
METHOD Nv04VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class046SetNotify,             0x0104, 0x0107},
    {class046StopImage,             0x0108, 0x010f},
    {class046StopLUT,               0x0110, 0x0117},
    {class046StopCursorImage,       0x0118, 0x011f},
    {class046StopDAC,               0x0120, 0x0128},
    {class046SetNotifyCtxDma,       0x0180, 0x0183},
    {class046SetImageCtxDma,        0x0184, 0x018b},
    {class046SetLUTCtxDma,          0x018c, 0x0193},
    {class046SetCursorCtxDma,       0x0194, 0x019b},
    {class046SetPanOffset,          0x0220, 0x0223},
    {class046GetOffset,             0x02fc, 0x02ff},
    {class046SetImageValues,        0x0300, 0x030f},
    {class046SetLUTValues,          0x0310, 0x031f},
    {class046SetCursorImageValues,  0x0320, 0x032f},
    {class046SetCursorPoint,        0x0330, 0x0333},
    {class046SetDACValues,          0x0340, 0x037c}
};

METHOD Nv04VideoOverlayMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class047SetNotify,             0x0104, 0x0107},
    {class047StopOverlay,           0x0120, 0x0127},
    {class047SetNotifyCtxDma,       0x0180, 0x0183},
    {class047SetOverlayCtxDma,      0x019c, 0x01a3},
    {class047GetOffset,             0x02fc, 0x02ff},
    {class047SetOverlayValues,      0x0400, 0x04ff},
    {class047SetOverlayPointOutNow, 0x0500, 0x0503}
};

METHOD Nv05VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class049SetNotify,             0x0104, 0x0107},
    {class049StopImage,             0x0108, 0x010f},
    {class049StopLUT,               0x0110, 0x0117},
    {class049StopCursorImage,       0x0118, 0x011f},
    {class049StopDAC,               0x0120, 0x0128},
    {class049SetNotifyCtxDma,       0x0180, 0x0183},
    {class049SetImageCtxDma,        0x0184, 0x018b},
    {class049SetLUTCtxDma,          0x018c, 0x0193},
    {class049SetCursorCtxDma,       0x0194, 0x019b},
    {class049SetPanOffset,          0x0220, 0x0223},
    {class049GetOffset,             0x02fc, 0x02ff},
    {class049SetImageValues,        0x0300, 0x030f},
    {class049SetLUTValues,          0x0310, 0x031f},
    {class049SetCursorImageValues,  0x0320, 0x032f},
    {class049SetCursorPoint,        0x0330, 0x0333},
    {class049SetDACValues,          0x0340, 0x037c}
};

METHOD NvVideoFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class63SetNotify,              0x0104, 0x0107},
    {class63StopTransfer,           0x0108, 0x010b},
    {class63SetNotifyCtxDma,        0x0180, 0x0183},
    {class63SetImageCtxDma,         0x0184, 0x018b},
    {class63SetVideoOutput,         0x0200, 0x0203},
    {class63ImageScan,              0x0300, 0x0327},
    {class63GetOffsetNotify,        0x0328, 0x032f}
};
METHOD NvVideoScalerMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class64SetNotify,              0x0104, 0x0107},
    {class64SetNotifyCtxDma,        0x0180, 0x0183},
    {class64SetVideoOutput,         0x0200, 0x0203},
    {class64SetVideoInput,          0x0204, 0x0207},
    {class64SetDeltaDuDx,           0x0300, 0x0303},
    {class64SetDeltaDvDy,           0x0304, 0x0307},
    {class64SetPoint,               0x0308, 0x030b}
};
METHOD NvVideoColorKeyMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class65SetNotify,              0x0104, 0x0107},
    {class65SetNotifyCtxDma,        0x0180, 0x0183},
    {class65SetVideoOutput,         0x0200, 0x0203},
    {class65SetVideoInput,          0x0204, 0x020f},
    {class65SetColorFormat,         0x0300, 0x0303},
    {class65SetColorKey,            0x0304, 0x0307},
    {class65SetPoint,               0x0308, 0x030b},
    {class65SetSize,                0x030c, 0x030f}
};

/*
METHOD NvVideoCaptureToMemoryMethods[] =
{
    {class66SetNotifyCtxDma,        0x0100, 0x0103},
    {class66SetNotify,              0x0104, 0x0107},
    {class66StopTransfer,           0x0108, 0x010b},
    {class66SetVideoInput,          0x0200, 0x0203},
    {class66SetImageCtxDma,         0x0300, 0x0307},
    {class66SetImageNotifyCtxDma,   0x0308, 0x030f},
    {class66ImageCapture,           0x0310, 0x0337},
    {class66SetVbiCtxDma,           0x0400, 0x0407},
    {class66SetVbiNotifyCtxDma,     0x0408, 0x040f},
    {class66VbiCapture,             0x0410, 0x0437}
};
*/

METHOD Nv10VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class067SetNotify,             0x0104, 0x0107},
    {class067StopImage,             0x0108, 0x010f},
    {class067StopLUT,               0x0110, 0x0117},
    {class067StopCursorImage,       0x0118, 0x011f},
    {class067StopDAC,               0x0120, 0x0128},
    {class067SetNotifyCtxDma,       0x0180, 0x0183},
    {class067SetImageCtxDma,        0x0184, 0x018b},
    {class067SetLUTCtxDma,          0x018c, 0x0193},
    {class067SetCursorCtxDma,       0x0194, 0x019b},
    {class067SetPanOffset,          0x0220, 0x0223},
    {class067GetOffset,             0x02fc, 0x02ff},
    {class067SetImageValues,        0x0300, 0x030f},
    {class067SetLUTValues,          0x0310, 0x031f},
    {class067SetCursorImageValues,  0x0320, 0x032f},
    {class067SetCursorPoint,        0x0330, 0x0333},
    {class067SetDACValues,          0x0340, 0x037c}
};

METHOD Nv10VideoOverlayMethods[] =
{
    {mthdNoOperation,                  0x0100, 0x0103},
    {class07ASetNotify,                0x0104, 0x0107},
    {class07AStopOverlay,              0x0120, 0x0127},
    {class07ASetNotifyCtxDma,          0x0180, 0x0183},
    {class07ASetOverlayCtxDma,         0x019c, 0x01a3},
    {class07AGetOffset,                0x02fc, 0x02ff},
    {class07ASetOverlayValues,         0x0400, 0x04ff},
    {class07ASetOverlayPointOutNow,    0x0500, 0x0503},
    {class07ASetOverlayLuminanceNow,   0x0504, 0x0507},
    {class07ASetOverlayChrominanceNow, 0x0508, 0x050b}
};

METHOD Nv15VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class07CSetNotify,             0x0104, 0x0107},
    {class07CStopImage,             0x0108, 0x010f},
    {class07CStopLUT,               0x0110, 0x0117},
    {class07CStopCursorImage,       0x0118, 0x011f},
    {class07CStopDAC,               0x0120, 0x0128},
    {class07CSetNotifyCtxDma,       0x0180, 0x0183},
    {class07CSetImageCtxDma,        0x0184, 0x018b},
    {class07CSetLUTCtxDma,          0x018c, 0x0193},
    {class07CSetCursorCtxDma,       0x0194, 0x019b},
    {class07CSetSemaphoreCtxDma,    0x019c, 0x019f},
    {class07CSetPanOffset,          0x0220, 0x0223},
    {class07CSetSemaphoreOffset,    0x02f0, 0x02f3},
    {class07CSetSemaphoreRelease,   0x02f4, 0x02f7},
    {class07CSetOffsetRange,        0x02f8, 0x02fb},
    {class07CGetOffset,             0x02fc, 0x02ff},
    {class07CSetImageValues,        0x0300, 0x030f},
    {class07CSetLUTValues,          0x0310, 0x031f},
    {class07CSetCursorImageValues,  0x0320, 0x032f},
    {class07CSetCursorPoint,        0x0330, 0x0333},
    {class07CSetDACValues,          0x0340, 0x037c},
};

/*
METHOD NvVideoSourceMethods[] =
{
    {class74SetNotifyCtxDma,        0x0100, 0x0103},
    {class74SetNotify,              0x0104, 0x0107},
    {class74SetVideoOutput,         0x0200, 0x0203},
};
*/

METHOD Nv1TimerMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {tmrStopTransfer,               0x0108, 0x010b},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetAlarmTime,              0x0300, 0x0307},
    {mthdSetAlarmTimeRelative,      0x0308, 0x030f},
    {mthdSetAlarmNotify,            0x0320, 0x0323}
};
METHOD Nv1BetaSolidMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class012Notify,                0x0104, 0x0107},
    {class012SetContextDmaNotifies, 0x0180, 0x0183},
    {class012SetBeta,               0x0300, 0x0303}
};
METHOD Nv1ImageSolidMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class017Notify,                0x0104, 0x0107},
    {class017SetContextDmaNotifies, 0x0180, 0x0183},
    {class017SetColorFormat,        0x0300, 0x0303},
    {class017SetColor,              0x0304, 0x0307}
};
METHOD Nv1ImagePatternMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class018Notify,                0x0104, 0x0107},
    {class018SetContextDmaNotifies, 0x0180, 0x0183},
    {class018SetColorFormat,        0x0300, 0x0303},
    {class018SetMonochromeFormat,   0x0304, 0x0307},
    {class018SetPatternShape,       0x0308, 0x030b},
    {class018SetColor0,             0x0310, 0x0313},
    {class018SetColor1,             0x0314, 0x0317},
    {class018SetPattern,            0x0318, 0x031f}
};
METHOD Nv1ImageRectangleBlackMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class019Notify,                0x0104, 0x0107},
    {class019SetContextDmaNotifies, 0x0180, 0x0183},
    {class019SetRectangle,          0x0300, 0x0307}
};
METHOD Nv1RenderSolidLinMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class01CNotify,                0x0104, 0x0107},
    {class01CSetContextDmaNotifies, 0x0180, 0x0183},
    {class01CSetContextClip,        0x0184, 0x0187},
    {class01CSetContextPattern,     0x0188, 0x018b},
    {class01CSetContextRop,         0x018c, 0x018f},
    {class01CSetContextBeta1,       0x0190, 0x0193},
    {class01CSetContextSurface,     0x0194, 0x0197},
    {class01CSetOperation,          0x02fc, 0x02ff},
    {class01CSetColorFormat,        0x0300, 0x0303},
    {class01CColor,                 0x0304, 0x0307},
    {class01CLin,                   0x0400, 0x047f},
    {class01CLin32,                 0x0480, 0x04ff},
    {class01CPolyLin,               0x0500, 0x057f},
    {class01CPolyLin32,             0x0580, 0x05ff},
    {class01CColorPolyLin,          0x0600, 0x067f}
};
METHOD Nv1RenderSolidTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class01DNotify,                0x0104, 0x0107},
    {class01DSetContextDmaNotifies, 0x0180, 0x0183},
    {class01DSetContextClip,        0x0184, 0x0187},
    {class01DSetContextPattern,     0x0188, 0x018b},
    {class01DSetContextRop,         0x018c, 0x018f},
    {class01DSetContextBeta1,       0x0190, 0x0193},
    {class01DSetContextSurface,     0x0194, 0x0197},
    {class01DSetOperation,          0x02fc, 0x02ff},
    {class01DSetColorFormat,        0x0300, 0x0303},
    {class01DColor,                 0x0304, 0x0307},
    {class01DTriangle,              0x0310, 0x031b},
    {class01DTriangle32,            0x0320, 0x0337},
    {class01DTrimesh,               0x0400, 0x047f},
    {class01DTrimesh32,             0x0480, 0x04ff},
    {class01DColorTriangle,         0x0500, 0x057f},
    {class01DColorTrimesh,          0x0580, 0x05ff}
};
METHOD Nv1RenderSolidRectangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class01ENotify,                0x0104, 0x0107},
    {class01ESetContextDmaNotifies, 0x0180, 0x0183},
    {class01ESetContextClip,        0x0184, 0x0187},
    {class01ESetContextPattern,     0x0188, 0x018b},
    {class01ESetContextRop,         0x018c, 0x018f},
    {class01ESetContextBeta1,       0x0190, 0x0193},
    {class01ESetContextSurface,     0x0194, 0x0197},
    {class01ESetOperation,          0x02fc, 0x02ff},
    {class01ESetColorFormat,        0x0300, 0x0303},
    {class01EColor,                 0x0304, 0x0307},
    {class01ERectangle,             0x0400, 0x047f}
};
METHOD Nv1ImageBlitMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class01FNotify,                0x0104, 0x0107},
    {class01FSetContextDmaNotifies, 0x0180, 0x0183},
    {class01FSetContextColorKey,    0x0184, 0x0187},
    {class01FSetContextClip,        0x0188, 0x018b},
    {class01FSetContextPattern,     0x018c, 0x018f},
    {class01FSetContextRop,         0x0190, 0x0193},
    {class01FSetContextBeta1,       0x0194, 0x0197},
    {class01FSetContextSurfaceSource, 0x0198, 0x019b},
    {class01FSetContextSurface,     0x019c, 0x019f},
    {class01FSetOperation,          0x02fc, 0x02ff},
    {class01FPointIn,               0x0300, 0x0303},
    {class01FPointOut,              0x0304, 0x0307},
    {class01FSize,                  0x0308, 0x030b}
};
METHOD Nv1ImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class021Notify,                0x0104, 0x0107},
    {class021SetContextDmaNotifies, 0x0180, 0x0183},
    {class021SetContextColorKey,    0x0184, 0x0187},
    {class021SetContextClip,        0x0188, 0x018b},
    {class021SetContextPattern,     0x018c, 0x018f},
    {class021SetContextRop,         0x0190, 0x0193},
    {class021SetContextBeta1,       0x0194, 0x0197},
    {class021SetContextSurface,     0x0198, 0x019b},
    {class021SetOperation,          0x02fc, 0x02ff},
    {class021SetColorFormat,        0x0300, 0x0303},
    {class021Point,                 0x0304, 0x0307},
    {class021Size,                  0x0308, 0x030b},
    {class021SizeIn,                0x030c, 0x030f},
    {class021Color,                 0x0400, 0x047f}
};
METHOD Nv3StretchedImageFromCPUMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class036Notify,                0x0104, 0x0107},
    {class036SetContextDmaNotifies, 0x0180, 0x0183},
    {class036SetContextColorKey,    0x0184, 0x0187},
    {class036SetContextPattern,     0x0188, 0x018b},
    {class036SetContextRop,         0x018c, 0x018f},
    {class036SetContextBeta1,       0x0190, 0x0193},
    {class036SetContextSurface,     0x0194, 0x0197},
    {class036SetOperation,          0x02fc, 0x02ff},
    {class036SetColorFormat,        0x0300, 0x0303},
    {class036SizeIn,                0x0304, 0x0307},
    {class036DeltaDxDu,             0x0308, 0x030b},
    {class036DeltaDyDv,             0x030c, 0x030f},
    {class036Clip,                  0x0310, 0x0317},
    {class036Point12d4,             0x0318, 0x031b},
    {class036Color,                 0x0400, 0x1fff}
};
METHOD Nv3ScaledImageFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class037Notify,                0x0104, 0x0107},
    {class037SetContextDmaNotifies, 0x0180, 0x0183},
    {class037SetContextDmaImage,    0x0184, 0x0187},
    {class037SetContextPattern,     0x0188, 0x018b},
    {class037SetContextRop,         0x018c, 0x018f},
    {class037SetContextBeta1,       0x0190, 0x0193},
    {class037SetContextSurface,     0x0194, 0x0197},
    {class037SetColorFormat,        0x0300, 0x0303},
    {class037SetOperation,          0x0304, 0x0307},
    {class037Clip,                  0x0308, 0x030f},
    {class037RectangleOut,          0x0310, 0x0317},
    {class037DeltaDuDx,             0x0318, 0x031b},
    {class037DeltaDvDy,             0x031c, 0x031f},
    {class037ImageIn,               0x0400, 0x040f}
};
METHOD Nv3MemoryToMemoryFormatMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class039Notify,                0x0104, 0x0107},
    {class039SetContextDmaNotifies, 0x0180, 0x0183},
    {class039SetContextDmaBufferIn, 0x0184, 0x0187},
    {class039SetContextDmaBufferOut, 0x0188, 0x018b},
    {class039BufferTransfer,        0x030c, 0x032b}
};
METHOD Nv3DX3TexturedTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class048Notify,                0x0104, 0x0107},
    {class048SetContextDmaNotifies, 0x0180, 0x0183},
    {class048SetTextureCtxDma,      0x0184, 0x0187},
    {class048SetContextClip,        0x0188, 0x018b},
    {class048SetContextSurfaceColor, 0x018c, 0x018f},
    {class048SetContextSurfaceZeta, 0x0190, 0x0193},
    {class048TextureOffset,         0x0304, 0x0307},
    {class048TextureFormat,         0x0308, 0x030b},
    {class048Filter,                0x030c, 0x030f},
    {class048FogColor,              0x0310, 0x0313},
    {class048ControlOut0,           0x0314, 0x0317},
    {class048ControlOut1,           0x0318, 0x031b},
    {class048ControlPoint,          0x1000, 0x1fff}
};
METHOD Nv3GDIRectangleTextMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04BNotify,                0x0104, 0x0107},
    {class04BSetContextDmaNotifies, 0x0180, 0x0183},
    {class04BSetContextPattern,     0x0184, 0x0187},
    {class04BSetContextRop,         0x0188, 0x018b},
    {class04BSetContextBeta1,       0x018c, 0x018f},
    {class04BSetContextSurface,     0x0190, 0x0193},
    {class04BSetOperation,          0x02fc, 0x02ff},
    {class04BSetColorFormat,        0x0300, 0x0303},
    {class04BSetMonochromeFormat,   0x0304, 0x0307},
    {class04BColor1A,               0x03fc, 0x03ff},
    {class04BUnclippedRectangle,    0x0400, 0x05ff},
    {class04BClipB,                 0x07f4, 0x07fb},
    {class04BColor1B,               0x07fc, 0x07ff},
    {class04BClippedRectangle,      0x0800, 0x09ff},
    {class04BClipC,                 0x0bec, 0x0bf3},
    {class04BColor1C,               0x0bf4, 0x0bf7},
    {class04BSizeC,                 0x0bf8, 0x0bfb},
    {class04BPointC,                0x0bfc, 0x0bff},
    {class04BMonochromeColor1C,     0x0c00, 0x0dff},
    {class04BClipD,                 0x0fe8, 0x0fef},
    {class04BColor1D,               0x0ff0, 0x0ff3},
    {class04BSizeInD,               0x0ff4, 0x0ff7},
    {class04BSizeOutD,              0x0ff8, 0x0ffb},
    {class04BPointD,                0x0ffc, 0x0fff},
    {class04BMonochromeColor1D,     0x1000, 0x11ff},
    {class04BClipE,                 0x13e4, 0x13eb},
    {class04BColor0E,               0x13ec, 0x13ef},
    {class04BColor1E,               0x13f0, 0x13f3},
    {class04BSizeInE,               0x13f4, 0x13f7},
    {class04BSizeOutE,              0x13f8, 0x13fb},
    {class04BPointE,                0x13fc, 0x13ff},
    {class04BMonochromeColor01E,    0x1400, 0x15ff}
};
METHOD Nv3ExternalVideoDecoderMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04DNotify,                0x0104, 0x0107},
    {class04DStopTransferVbi,       0x0108, 0x010b},
    {class04DStopTransferImage,     0x010c, 0x010f},
    {class04DSetContextDmaNotifies, 0x0180, 0x0183},
    {class04DSetContextDmaVbi,      0x0184, 0x018b},
    {class04DSetContextDmaImage,    0x018c, 0x0193},
    {class04DSetImageConfig,        0x02f8, 0x02fb},
    {class04DSetImageStartLine,     0x02fc, 0x02ff},
    {class04DSetVbi,                0x0300, 0x0317},
    {class04DGetVbiOffsetNotify,    0x0318, 0x031f},
    {class04DSetImage,              0x0320, 0x033f},
    {class04DGetImageOffsetNotify,  0x0340, 0x0347}
};
METHOD Nv3ExternalVideoDecompressorMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04ENotify,                0x0104, 0x0107},
    {class04EStopTransfer,          0x0108, 0x010b},
    {class04ESetContextDmaNotifies, 0x0180, 0x0183},
    {class04ESetContextDmaData,     0x0184, 0x018b},
    {class04ESetContextDmaImage,    0x018c, 0x0193},
    {class04EReadData,              0x0300, 0x0317},
    {class04EWriteImage,            0x0318, 0x033f}
};
METHOD Nv1ExternalParallelBusMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04FNotify,                0x0104, 0x0107},
    {class04FStopTransfer,          0x0108, 0x010b},
    {class04FSetContextDmaNotifies, 0x0180, 0x0183},
    {class04FWrite,                 0x0300, 0x030b},
    {class04FRead,                  0x030c, 0x0317},
    {class04FSetInterruptNotify,    0x0318, 0x031b}
};
METHOD Nv3ExternalMonitorBusMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class050Notify,                0x0104, 0x0107},
    {class050StopTransfer,          0x0108, 0x010b},
    {class050SetContextDmaNotifies, 0x0180, 0x0183},
    {class050Write,                 0x0300, 0x030b},
    {class050Read,                  0x030c, 0x0317},
    {class050SetInterruptNotify,    0x0318, 0x031b}
};
METHOD Nv4ExternalSerialBusMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class051Notify,                0x0104, 0x0107},
    {class051StopTransfer,          0x0108, 0x010b},
    {class051SetContextDmaNotifies, 0x0180, 0x0183},
    {class051Write,                 0x0300, 0x030b},
    {class051Read,                  0x030c, 0x0317},
    {class051SetInterruptNotify,    0x0318, 0x031b}
};
METHOD Nv3ContextSurface0Methods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class058Notify,                0x0104, 0x0107},
    {class058SetContextDmaNotifies, 0x0180, 0x0183},
    {class058SetContextDmaImage,    0x0184, 0x0187},
    {class058SetColorFormat,        0x0300, 0x0303},
    {class058SetImagePitch,         0x0308, 0x030b},
    {class058SetImageOffset,        0x030c, 0x030f}
};
METHOD Nv3ContextSurface1Methods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class059Notify,                0x0104, 0x0107},
    {class059SetContextDmaNotifies, 0x0180, 0x0183},
    {class059SetContextDmaImage,    0x0184, 0x0187},
    {class059SetColorFormat,        0x0300, 0x0303},
    {class059SetImagePitch,         0x0308, 0x030b},
    {class059SetImageOffset,        0x030c, 0x030f}
};
METHOD Nv3ContextSurface2Methods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05ANotify,                0x0104, 0x0107},
    {class05ASetContextDmaNotifies, 0x0180, 0x0183},
    {class05ASetContextDmaImage,    0x0184, 0x0187},
    {class05ASetColorFormat,        0x0300, 0x0303},
    {class05ASetImagePitch,         0x0308, 0x030b},
    {class05ASetImageOffset,        0x030c, 0x030f}
};
METHOD Nv3ContextSurface3Methods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05BNotify,                0x0104, 0x0107},
    {class05BSetContextDmaNotifies, 0x0180, 0x0183},
    {class05BSetContextDmaImage,    0x0184, 0x0187},
    {class05BSetColorFormat,        0x0300, 0x0303},
    {class05BSetImagePitch,         0x0308, 0x030b},
    {class05BSetImageOffset,        0x030c, 0x030f}
};
METHOD Nv3ContextRopMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class043Notify,                0x0104, 0x0107},
    {class043SetContextDmaNotifies, 0x0180, 0x0183},
    {class043SetRop5,               0x0300, 0x0303}
};
METHOD Nv4DvdSubpictureMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class038Notify,                0x0104, 0x0107},
    {class038SetContextDmaNotifies, 0x0180, 0x0183},
    {class038SetContextDmaOverlay,  0x0184, 0x0187},
    {class038SetContextDmaImageIn,  0x0188, 0x018b},
    {class038SetContextDmaImageOut, 0x018c, 0x018f},
    {class038ImageOutPoint,         0x0300, 0x0303},
    {class038ImageOutSize,          0x0304, 0x0307},
    {class038ImageOutFormat,        0x0308, 0x030b},
    {class038ImageOutOffset,        0x030c, 0x030f},
    {class038ImageInDeltaDuDx,      0x0310, 0x0313},
    {class038ImageInDeltaDvDy,      0x0314, 0x0317},
    {class038ImageInSize,           0x0318, 0x031b},
    {class038ImageInFormat,         0x031c, 0x031f},
    {class038ImageInOffset,         0x0320, 0x0323},
    {class038ImageInPoint,          0x0324, 0x0317},
    {class038OverlayDeltaDuDx,      0x0328, 0x032b},
    {class038OverlayDeltaDvDy,      0x032c, 0x032f},
    {class038OverlaySize,           0x0330, 0x0333},
    {class038OverlayFormat,         0x0334, 0x0337},
    {class038OverlayOffset,         0x0338, 0x033b},
    {class038OverlayPoint,          0x033c, 0x033f}
};
METHOD Nv4ContextSurfaces2DMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class042Notify,                0x0104, 0x0107},
    {class042SetContextDmaNotifies, 0x0180, 0x0183},
    {class042SetContextDmaSource,   0x0184, 0x0187},
    {class042SetContextDmaDestin,   0x0188, 0x018b},
    {class042SetColorFormat,        0x0300, 0x0303},
    {class042SetPitch,              0x0304, 0x0307},
    {class042SetOffsetSource,       0x0308, 0x030b},
    {class042SetOffsetDestin,       0x030c, 0x030f}
};
METHOD Nv4ContextPatternMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class044Notify,                0x0104, 0x0107},
    {class044SetContextDmaNotifies, 0x0180, 0x0183},
    {class044SetColorFormat,        0x0300, 0x0303},
    {class044SetMonochromeFormat,   0x0304, 0x0307},
    {class044SetMonochromeShape,    0x0308, 0x030b},
    {class044SetPatternSelect,      0x030c, 0x030f},
    {class044SetMonochromeColor,    0x0310, 0x0317},
    {class044SetMonochromePattern,  0x0318, 0x031f},
    {class044SetPatternY8,          0x0400, 0x043f},
    {class044SetPatternR5G6B5,      0x0500, 0x057f},
    {class044SetPatternX8R8G8B8,    0x0700, 0x07ff}
};
METHOD Nv4GDIRectangleTextMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04ANotify,                0x0104, 0x0107},
    {class04ASetContextDmaNotifies, 0x0180, 0x0183},
    {class04ASetContextFonts,       0x0184, 0x0187},
    {class04ASetContextPattern,     0x0188, 0x018b},
    {class04ASetContextRop,         0x018c, 0x018f},
    {class04ASetContextBeta1,       0x0190, 0x0193},
    {class04ASetContextBeta4,       0x0194, 0x0197},
    {class04ASetContextSurface,     0x0198, 0x019b},
    {class04ASetOperation,          0x02fc, 0x02ff},
    {class04ASetColorFormat,        0x0300, 0x0303},
    {class04ASetMonochromeFormat,   0x0304, 0x0307},
    {class04AColor1A,               0x03fc, 0x03ff},
    {class04AUnclippedRectangle,    0x0400, 0x04ff},
    {class04AClipB,                 0x05f4, 0x05fb},
    {class04AColor1B,               0x05fc, 0x05ff},
    {class04AClippedRectangle,      0x0600, 0x06ff},
    {class04AClipC,                 0x07ec, 0x07f3},
    {class04AColor1C,               0x07f4, 0x07f7},
    {class04ASizeC,                 0x07f8, 0x07fb},
    {class04APointC,                0x07fc, 0x07ff},
    {class04AMonochromeColor1C,     0x0800, 0x09ff},
    {class04AClipE,                 0x0be4, 0x0beb},
    {class04AColor0E,               0x0bec, 0x0bef},
    {class04AColor1E,               0x0bf0, 0x0bf3},
    {class04ASizeInE,               0x0bf4, 0x0bf7},
    {class04ASizeOutE,              0x0bf8, 0x0bfb},
    {class04APointE,                0x0bfc, 0x0bff},
    {class04AMonochromeColor01E,    0x0c00, 0x0dff},
    {class04AFontF,                 0x0ff0, 0x0ff3},
    {class04AClipF,                 0x0ff4, 0x0ffb},
    {class04AColor1F,               0x0ffc, 0x0fff},
    {class04ACharacterColor1F,      0x1000, 0x13ff},
    {class04AFontG,                 0x17f0, 0x17f3},
    {class04AClipG,                 0x17f4, 0x17fb},
    {class04AColor1G,               0x17fc, 0x17ff},
    {class04ACharacterColor1G,      0x1800, 0x1fff}
};
METHOD Nv4ContextSurfaceSwizzledMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class052Notify,                0x0104, 0x0107},
    {class052SetContextDmaNotifies, 0x0180, 0x0183},
    {class052SetContextDmaImage,    0x0184, 0x0187},
    {class052SetFormat,             0x0300, 0x0303},
    {class052SetOffset,             0x0304, 0x0307}
};
METHOD Nv4ContextSurfacesArgbZsMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class053Notify,                0x0104, 0x0107},
    {class053SetContextDmaNotifies, 0x0180, 0x0183},
    {class053SetContextDmaColor,    0x0184, 0x0187},
    {class053SetContextDmaZeta,     0x0188, 0x018b},
    {class053SetClipHorizontal,     0x02f8, 0x02fb},
    {class053SetClipVertical,       0x02fc, 0x02ff},
    {class053SetFormat,             0x0300, 0x0303},
    {class053SetClipSize,           0x0304, 0x0307},
    {class053SetPitch,              0x0308, 0x030b},
    {class053SetOffsetColor,        0x030c, 0x030f},
    {class053SetOffsetZeta,         0x0310, 0x0313}
};
METHOD Nv4DX5TexturedTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class054Notify,                0x0104, 0x0107},
    {class054SetContextDmaNotifies, 0x0180, 0x0183},
    {class054SetContextDmaA,        0x0184, 0x0187},
    {class054SetContextDmaB,        0x0188, 0x018b},
    {class054SetContextSurface,     0x018c, 0x018f},
    {class054ColorKey,              0x0300, 0x0303},
    {class054Offset,                0x0304, 0x0307},
    {class054Format,                0x0308, 0x030b},
    {class054Filter,                0x030c, 0x030f},
    {class054Blend,                 0x0310, 0x0313},
    {class054Control,               0x0314, 0x0317},
    {class054FogColor,              0x0318, 0x031b},
    {class054Tlvertex,              0x0400, 0x05ff},
    {class054DrawPrimitive,         0x0600, 0x06ff}
};
METHOD Nv4DX6MultiTextureTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class055Notify,                0x0104, 0x0107},
    {class055SetContextDmaNotifies, 0x0180, 0x0183},
    {class055SetContextDmaA,        0x0184, 0x0187},
    {class055SetContextDmaB,        0x0188, 0x018b},
    {class055SetContextSurface,     0x018c, 0x018f},
    {class055Offset,                0x0308, 0x030f},
    {class055Format,                0x0310, 0x0317},
    {class055Filter,                0x0318, 0x031f},
    {class055Combine0Alpha,         0x0320, 0x0323},
    {class055Combine0Color,         0x0324, 0x0327},
    {class055Combine1Alpha,         0x032c, 0x032f},
    {class055Combine1Color,         0x0330, 0x0333},
    {class055CombineFactor,         0x0334, 0x0337},
    {class055Blend,                 0x0338, 0x033b},
    {class055Control,               0x033c, 0x0347},
    {class055FogColor,              0x0348, 0x034b},
    {class055Tlmtvertex,            0x0400, 0x053f},
    {class055DrawPrimitive,         0x0540, 0x05ff}
};
METHOD Nv10CelsiusPrimitiveMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class056Notify,                0x0104, 0x0107},
    {class056SetWarningEnable,      0x0108, 0x010b},
    //{class056GetState,              0x010c, 0x010f},
    {class056WaitForIdle,           0x0110, 0x0113},
    {class056PMTrigger,             0x0140, 0x0143},
    {class056SetContextDmaNotifies, 0x0180, 0x0183},
    {class056SetContextDmaA,        0x0184, 0x0187},
    {class056SetContextDmaB,        0x0188, 0x018b},
    {class056SetContextDmaVertex,   0x018c, 0x018f},
    {class056SetContextDmaState,    0x0190, 0x0193},
    {class056SetContextDmaColor,    0x0194, 0x0197},
    {class056SetContextDmaZeta,     0x0198, 0x019b},
    {class056MethodCatcher,         0x019c, 0x17ff},    // catch any in between methods
    //{class056SetMaterialEmission,   0x1628, 0x1633},    // HW workaround for NV10
    //{class056MethodCatcher,         0x1634, 0x17ff},    // catch any in between methods
    {class056InlineArray,           0x1800, 0x1fff},
};
METHOD Nv4ContextColorKeyMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class057Notify,                0x0104, 0x0107},
    {class057SetContextDmaNotifies, 0x0180, 0x0183},
    {class057SetColorFormat,        0x0300, 0x0303},
    {class057SetColor,              0x0304, 0x0307}
};
METHOD Nv4RenderSolidLinMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05CNotify,                0x0104, 0x0107},
    {class05CSetContextDmaNotifies, 0x0180, 0x0183},
    {class05CSetContextClip,        0x0184, 0x0187},
    {class05CSetContextPattern,     0x0188, 0x018b},
    {class05CSetContextRop,         0x018c, 0x018f},
    {class05CSetContextBeta1,       0x0190, 0x0193},
    {class05CSetContextBeta4,       0x0194, 0x0197},
    {class05CSetContextSurface,     0x0198, 0x019b},
    {class05CSetOperation,          0x02fc, 0x02ff},
    {class05CSetColorFormat,        0x0300, 0x0303},
    {class05CColor,                 0x0304, 0x0307},
    {class05CLin,                   0x0400, 0x047f},
    {class05CLin32,                 0x0480, 0x04ff},
    {class05CPolyLin,               0x0500, 0x057f},
    {class05CPolyLin32,             0x0580, 0x05ff},
    {class05CColorPolyLin,          0x0600, 0x067f}
};
METHOD Nv4RenderSolidTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05DNotify,                0x0104, 0x0107},
    {class05DSetContextDmaNotifies, 0x0180, 0x0183},
    {class05DSetContextClip,        0x0184, 0x0187},
    {class05DSetContextPattern,     0x0188, 0x018b},
    {class05DSetContextRop,         0x018c, 0x018f},
    {class05DSetContextBeta1,       0x0190, 0x0193},
    {class05DSetContextBeta4,       0x0194, 0x0197},
    {class05DSetContextSurface,     0x0198, 0x019b},
    {class05DSetOperation,          0x02fc, 0x02ff},
    {class05DSetColorFormat,        0x0300, 0x0303},
    {class05DColor,                 0x0304, 0x0307},
    {class05DTriangle,              0x0310, 0x031b},
    {class05DTriangle32,            0x0320, 0x0337},
    {class05DTrimesh,               0x0400, 0x047f},
    {class05DTrimesh32,             0x0480, 0x04ff},
    {class05DColorTriangle,         0x0500, 0x057f},
    {class05DColorTrimesh,          0x0580, 0x05ff}
};
METHOD Nv4RenderSolidRectangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05ENotify,                0x0104, 0x0107},
    {class05ESetContextDmaNotifies, 0x0180, 0x0183},
    {class05ESetContextClip,        0x0184, 0x0187},
    {class05ESetContextPattern,     0x0188, 0x018b},
    {class05ESetContextRop,         0x018c, 0x018f},
    {class05ESetContextBeta1,       0x0190, 0x0193},
    {class05ESetContextBeta4,       0x0194, 0x0197},
    {class05ESetContextSurface,     0x0198, 0x019b},
    {class05ESetOperation,          0x02fc, 0x02ff},
    {class05ESetColorFormat,        0x0300, 0x0303},
    {class05EColor,                 0x0304, 0x0307},
    {class05ERectangle,             0x0400, 0x047f}
};
METHOD Nv4ImageBlitMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05FNotify,                0x0104, 0x0107},
    {class05FSetContextDmaNotifies, 0x0180, 0x0183},
    {class05FSetContextColorKey,    0x0184, 0x0187},
    {class05FSetContextClip,        0x0188, 0x018b},
    {class05FSetContextPattern,     0x018c, 0x018f},
    {class05FSetContextRop,         0x0190, 0x0193},
    {class05FSetContextBeta1,       0x0194, 0x0197},
    {class05FSetContextBeta4,       0x0198, 0x019b},
    {class05FSetContextSurfaces2d,  0x019c, 0x019f},
    {class05FSetOperation,          0x02fc, 0x02ff},
    {class05FControlPointIn,        0x0300, 0x0303},
    {class05FControlPointOut,       0x0304, 0x0307},
    {class05FSize,                  0x0308, 0x030b}
};
METHOD Nv4IndexedImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class060Notify,                0x0104, 0x0107},
    {class060SetContextDmaNotifies, 0x0180, 0x0183},
    {class060SetContextDmaLut,      0x0184, 0x0187},
    {class060SetContextColorKey,    0x0188, 0x018b},
    {class060SetContextClip,        0x018c, 0x018f},
    {class060SetContextPattern,     0x0190, 0x0193},
    {class060SetContextRop,         0x0194, 0x0197},
    {class060SetContextBeta1,       0x0198, 0x019b},
    {class060SetContextBeta4,       0x019c, 0x019f},
    {class060SetContextSurface,     0x01a0, 0x01a3},
    {class060SetColorConversion,    0x03e0, 0x03e3},
    {class060SetOperation,          0x03e4, 0x03e7},
    {class060SetColorFormat,        0x03e8, 0x03eb},
    {class060IndexFormat,           0x03ec, 0x03ef},
    {class060LutOffset,             0x03f0, 0x03f3},
    {class060Point,                 0x03f4, 0x03f7},
    {class060SizeOut,               0x03f8, 0x03fb},
    {class060SizeIn,                0x03fc, 0x03ff},
    {class060Indices,               0x0400, 0x1fff}
};
METHOD Nv4ImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class061Notify,                0x0104, 0x0107},
    {class061SetContextDmaNotifies, 0x0180, 0x0183},
    {class061SetContextColorKey,    0x0184, 0x0187},
    {class061SetContextClip,        0x0188, 0x018b},
    {class061SetContextPattern,     0x018c, 0x018f},
    {class061SetContextRop,         0x0190, 0x0193},
    {class061SetContextBeta1,       0x0194, 0x0197},
    {class061SetContextBeta4,       0x0198, 0x019b},
    {class061SetContextSurface,     0x019c, 0x019f},
    {class061SetOperation,          0x02fc, 0x02ff},
    {class061SetColorFormat,        0x0300, 0x0303},
    {class061Point,                 0x0304, 0x0307},
    {class061SizeOut,               0x0308, 0x030b},
    {class061SizeIn,                0x030c, 0x030f},
    {class061Color,                 0x0400, 0x1fff}
};

METHOD Nv5ScaledImageFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class063Notify,                0x0104, 0x0107},
    {class063SetContextDmaNotifies, 0x0180, 0x0183},
    {class063SetContextDmaImage,    0x0184, 0x0187},
    {class063SetContextPattern,     0x0188, 0x018b},
    {class063SetContextRop,         0x018c, 0x018f},
    {class063SetContextBeta1,       0x0190, 0x0193},
    {class063SetContextBeta4,       0x0194, 0x0197},
    {class063SetContextSurface,     0x0198, 0x019b},
    {class063SetColorConversion,    0x02fc, 0x02ff},
    {class063SetColorFormat,        0x0300, 0x0303},
    {class063SetOperation,          0x0304, 0x0307},
    {class063Clip,                  0x0308, 0x030f},
    {class063RectangleOut,          0x0310, 0x0317},
    {class063DeltaDuDx,             0x0318, 0x031b},
    {class063DeltaDvDy,             0x031c, 0x031f},
    {class063ImageIn,               0x0400, 0x040f}
};

METHOD Nv5IndexedImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class064Notify,                0x0104, 0x0107},
    {class064SetContextDmaNotifies, 0x0180, 0x0183},
    {class064SetContextDmaLut,      0x0184, 0x0187},
    {class064SetContextColorKey,    0x0188, 0x018b},
    {class064SetContextClip,        0x018c, 0x018f},
    {class064SetContextPattern,     0x0190, 0x0193},
    {class064SetContextRop,         0x0194, 0x0197},
    {class064SetContextBeta1,       0x0198, 0x019b},
    {class064SetContextBeta4,       0x019c, 0x019f},
    {class064SetContextSurface,     0x01a0, 0x01a3},
    {class064SetColorConversion,    0x03e0, 0x03e3},
    {class064SetOperation,          0x03e4, 0x03e7},
    {class064SetColorFormat,        0x03e8, 0x03eb},
    {class064IndexFormat,           0x03ec, 0x03ef},
    {class064LutOffset,             0x03f0, 0x03f3},
    {class064Point,                 0x03f4, 0x03f7},
    {class064SizeOut,               0x03f8, 0x03fb},
    {class064SizeIn,                0x03fc, 0x03ff},
    {class064Indices,               0x0400, 0x1fff}
};

METHOD Nv5ImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class065Notify,                0x0104, 0x0107},
    {class065SetContextDmaNotifies, 0x0180, 0x0183},
    {class065SetContextColorKey,    0x0184, 0x0187},
    {class065SetContextClip,        0x0188, 0x018b},
    {class065SetContextPattern,     0x018c, 0x018f},
    {class065SetContextRop,         0x0190, 0x0193},
    {class065SetContextBeta1,       0x0194, 0x0197},
    {class065SetContextBeta4,       0x0198, 0x019b},
    {class065SetContextSurface,     0x019c, 0x019f},
    {class065SetColorConversion,    0x02f8, 0x02fb},
    {class065SetOperation,          0x02fc, 0x02ff},
    {class065SetColorFormat,        0x0300, 0x0303},
    {class065Point,                 0x0304, 0x0307},
    {class065SizeOut,               0x0308, 0x030b},
    {class065SizeIn,                0x030c, 0x030f},
    {class065Color,                 0x0400, 0x1fff}
};
METHOD Nv5StretchedImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class066Notify,                0x0104, 0x0107},
    {class066SetContextDmaNotifies, 0x0180, 0x0183},
    {class066SetContextColorKey,    0x0184, 0x0187},
    {class066SetContextPattern,     0x0188, 0x018b},
    {class066SetContextRop,         0x018c, 0x018f},
    {class066SetContextBeta1,       0x0190, 0x0193},
    {class066SetContextBeta4,       0x0194, 0x0197},
    {class066SetContextSurface,     0x0198, 0x019b},
    {class066SetColorConversion,    0x02f8, 0x02fb},
    {class066SetOperation,          0x02fc, 0x02ff},
    {class066SetColorFormat,        0x0300, 0x0303},
    {class066SizeIn,                0x0304, 0x0307},
    {class066DeltaDxDu,             0x0308, 0x030b},
    {class066DeltaDyDv,             0x030c, 0x030f},
    {class066Clip,                  0x0310, 0x0317},
    {class066Point12d4,             0x0318, 0x031b},
    {class066Color,                 0x0400, 0x1fff}
};
METHOD Nv4ContextBetaMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class072Notify,                0x0104, 0x0107},
    {class072SetContextDmaNotifies, 0x0180, 0x0183},
    {class072SetBetaFactor,         0x0300, 0x0303}
};
METHOD Nv4StretchedImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class076Notify,                0x0104, 0x0107},
    {class076SetContextDmaNotifies, 0x0180, 0x0183},
    {class076SetContextColorKey,    0x0184, 0x0187},
    {class076SetContextPattern,     0x0188, 0x018b},
    {class076SetContextRop,         0x018c, 0x018f},
    {class076SetContextBeta1,       0x0190, 0x0193},
    {class076SetContextBeta4,       0x0194, 0x0197},
    {class076SetContextSurface,     0x0198, 0x019b},
    {class076SetOperation,          0x02fc, 0x02ff},
    {class076SetColorFormat,        0x0300, 0x0303},
    {class076SizeIn,                0x0304, 0x0307},
    {class076DeltaDxDu,             0x0308, 0x030b},
    {class076DeltaDyDv,             0x030c, 0x030f},
    {class076Clip,                  0x0310, 0x0317},
    {class076Point12d4,             0x0318, 0x031b},
    {class076Color,                 0x0400, 0x1fff}
};
METHOD Nv4ScaledImageFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class077Notify,                0x0104, 0x0107},
    {class077SetContextDmaNotifies, 0x0180, 0x0183},
    {class077SetContextDmaImage,    0x0184, 0x0187},
    {class077SetContextPattern,     0x0188, 0x018b},
    {class077SetContextRop,         0x018c, 0x018f},
    {class077SetContextBeta1,       0x0190, 0x0193},
    {class077SetContextBeta4,       0x0194, 0x0197},
    {class077SetContextSurface,     0x0198, 0x019b},
    {class077SetColorFormat,        0x0300, 0x0303},
    {class077SetOperation,          0x0304, 0x0307},
    {class077Clip,                  0x0308, 0x030f},
    {class077RectangleOut,          0x0310, 0x0317},
    {class077DeltaDuDx,             0x0318, 0x031b},
    {class077DeltaDvDy,             0x031c, 0x031f},
    {class077ImageIn,               0x0400, 0x040f}
};
METHOD Nv10ContextSurfaces2DMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class062Notify,                0x0104, 0x0107},
    {class062SetContextDmaNotifies, 0x0180, 0x0183},
    {class062SetContextDmaSource,   0x0184, 0x0187},
    {class062SetContextDmaDestin,   0x0188, 0x018b},
    {class062SetColorFormat,        0x0300, 0x0303},
    {class062SetPitch,              0x0304, 0x0307},
    {class062SetOffsetSource,       0x0308, 0x030b},
    {class062SetOffsetDestin,       0x030c, 0x030f}
};
METHOD Nv10TextureFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class07BNotify,                0x0104, 0x0107},
    {class07BSetContextDmaNotifies, 0x0180, 0x0183},
    {class07BSetContextSurface,     0x0184, 0x0187},
    {class07BSetColorFormat,        0x0300, 0x0303},
    {class07BPoint,                 0x0304, 0x0307},
    {class07BSize,                  0x0308, 0x030b},
    {class07BClipHorizontal,        0x030c, 0x030f},
    {class07BClipVertical,          0x0310, 0x0313},
    {class07BColor,                 0x0400, 0x1fff}
};
METHOD Nv10DvdSubpictureMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class088Notify,                0x0104, 0x0107},
    {class088SetContextDmaNotifies, 0x0180, 0x0183},
    {class088SetContextDmaOverlay,  0x0184, 0x0187},
    {class088SetContextDmaImageIn,  0x0188, 0x018b},
    {class088SetContextDmaImageOut, 0x018c, 0x018f},
    {class088ImageOutPoint,         0x0300, 0x0303},
    {class088ImageOutSize,          0x0304, 0x0307},
    {class088ImageOutFormat,        0x0308, 0x030b},
    {class088ImageOutOffset,        0x030c, 0x030f},
    {class088ImageInDeltaDuDx,      0x0310, 0x0313},
    {class088ImageInDeltaDvDy,      0x0314, 0x0317},
    {class088ImageInSize,           0x0318, 0x031b},
    {class088ImageInFormat,         0x031c, 0x031f},
    {class088ImageInOffset,         0x0320, 0x0323},
    {class088ImageInPoint,          0x0324, 0x0317},
    {class088OverlayDeltaDuDx,      0x0328, 0x032b},
    {class088OverlayDeltaDvDy,      0x032c, 0x032f},
    {class088OverlaySize,           0x0330, 0x0333},
    {class088OverlayFormat,         0x0334, 0x0337},
    {class088OverlayOffset,         0x0338, 0x033b},
    {class088OverlayPoint,          0x033c, 0x033f}
};
METHOD Nv10ScaledImageFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class089Notify,                0x0104, 0x0107},
    {class089SetContextDmaNotifies, 0x0180, 0x0183},
    {class089SetContextDmaImage,    0x0184, 0x0187},
    {class089SetContextPattern,     0x0188, 0x018b},
    {class089SetContextRop,         0x018c, 0x018f},
    {class089SetContextBeta1,       0x0190, 0x0193},
    {class089SetContextBeta4,       0x0194, 0x0197},
    {class089SetContextSurface,     0x0198, 0x019b},
    {class089SetColorConversion,    0x02fc, 0x02ff},
    {class089SetColorFormat,        0x0300, 0x0303},
    {class089SetOperation,          0x0304, 0x0307},
    {class089Clip,                  0x0308, 0x030f},
    {class089RectangleOut,          0x0310, 0x0317},
    {class089DeltaDuDx,             0x0318, 0x031b},
    {class089DeltaDvDy,             0x031c, 0x031f},
    {class089ImageIn,               0x0400, 0x040f}
};
METHOD Nv10ImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class08ANotify,                0x0104, 0x0107},
    {class08ASetContextDmaNotifies, 0x0180, 0x0183},
    {class08ASetContextColorKey,    0x0184, 0x0187},
    {class08ASetContextClip,        0x0188, 0x018b},
    {class08ASetContextPattern,     0x018c, 0x018f},
    {class08ASetContextRop,         0x0190, 0x0193},
    {class08ASetContextBeta1,       0x0194, 0x0197},
    {class08ASetContextBeta4,       0x0198, 0x019b},
    {class08ASetContextSurface,     0x019c, 0x019f},
    {class08ASetColorConversion,    0x02f8, 0x02fb},
    {class08ASetOperation,          0x02fc, 0x02ff},
    {class08ASetColorFormat,        0x0300, 0x0303},
    {class08APoint,                 0x0304, 0x0307},
    {class08ASizeOut,               0x0308, 0x030b},
    {class08ASizeIn,                0x030c, 0x030f},
    {class08AColor,                 0x0400, 0x1fff}
};
METHOD Nv10ContextSurfaces3DMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class093Notify,                0x0104, 0x0107},
    {class093SetContextDmaNotifies, 0x0180, 0x0183},
    {class093SetContextDmaColor,    0x0184, 0x0187},
    {class093SetContextDmaZeta,     0x0188, 0x018b},
    {class093SetClipHorizontal,     0x02f8, 0x02fb},
    {class093SetClipVertical,       0x02fc, 0x02ff},
    {class093SetFormat,             0x0300, 0x0303},
    {class093SetClipSize,           0x0304, 0x0307},
    {class093SetPitch,              0x0308, 0x030b},
    {class093SetOffsetColor,        0x030c, 0x030f},
    {class093SetOffsetZeta,         0x0310, 0x0313}
};
METHOD Nv10DX5TexturedTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class094Notify,                0x0104, 0x0107},
    {class094SetContextDmaNotifies, 0x0180, 0x0183},
    {class094SetContextDmaA,        0x0184, 0x0187},
    {class094SetContextDmaB,        0x0188, 0x018b},
    {class094SetContextSurface,     0x018c, 0x018f},
    {class094ColorKey,              0x0300, 0x0303},
    {class094Offset,                0x0304, 0x0307},
    {class094Format,                0x0308, 0x030b},
    {class094Filter,                0x030c, 0x030f},
    {class094Blend,                 0x0310, 0x0313},
    {class094Control,               0x0314, 0x0317},
    {class094FogColor,              0x0318, 0x031b},
    {class094Tlvertex,              0x0400, 0x05ff},
    {class094DrawPrimitive,         0x0600, 0x06ff}
};
METHOD Nv10DX6MultiTextureTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class095Notify,                0x0104, 0x0107},
    {class095SetContextDmaNotifies, 0x0180, 0x0183},
    {class095SetContextDmaA,        0x0184, 0x0187},
    {class095SetContextDmaB,        0x0188, 0x018b},
    {class095SetContextSurface,     0x018c, 0x018f},
    {class095Offset,                0x0308, 0x030f},
    {class095Format,                0x0310, 0x0317},
    {class095Filter,                0x0318, 0x031f},
    {class095Combine0Alpha,         0x0320, 0x0323},
    {class095Combine0Color,         0x0324, 0x0327},
    {class095Combine1Alpha,         0x032c, 0x032f},
    {class095Combine1Color,         0x0330, 0x0333},
    {class095CombineFactor,         0x0334, 0x0337},
    {class095Blend,                 0x0338, 0x033b},
    {class095Control,               0x033c, 0x0347},
    {class095FogColor,              0x0348, 0x034b},
    {class095Tlmtvertex,            0x0400, 0x053f},
    {class095DrawPrimitive,         0x0540, 0x05ff}
};
METHOD Nv15CelsiusPrimitiveMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class096Notify,                0x0104, 0x0107},
    {class096SetWarningEnable,      0x0108, 0x010b},
    //{class096GetState,              0x010c, 0x010f},
    {class096WaitForIdle,           0x0110, 0x0113},
    {class096SyncSetRead,           0x0120, 0x0123},
    {class096SyncSetWrite,          0x0124, 0x0127},
    {class096SyncSetModulo,         0x0128, 0x012b},
    {class096SyncIncrementWrite,    0x012c, 0x012f},
    {class096SyncStall,             0x0130, 0x0133},
    {class096PMTrigger,             0x0140, 0x0143},
    {class096SetContextDmaNotifies, 0x0180, 0x0183},
    {class096SetContextDmaA,        0x0184, 0x0187},
    {class096SetContextDmaB,        0x0188, 0x018b},
    {class096SetContextDmaVertex,   0x018c, 0x018f},
    {class096SetContextDmaState,    0x0190, 0x0193},
    {class096SetContextDmaColor,    0x0194, 0x0197},
    {class096SetContextDmaZeta,     0x0198, 0x019b},
    //...
    // for now, catch anything in between
    {class096MethodCatcher,         0x0200, 0x17ff},
    //...
    {class096InlineArray,           0x1800, 0x1fff},
    {class096DebugInit,             0x2000, 0x2027}
};
METHOD Nv15ImageBlitMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class09FNotify,                0x0104, 0x0107},
    {class09FSyncSetRead,           0x0120, 0x0123},
    {class09FSyncSetWrite,          0x0124, 0x0127},
    {class09FSyncSetModulo,         0x0128, 0x012b},
    {class09FSyncIncrementWrite,    0x012c, 0x012f},
    {class09FSyncStall,             0x0130, 0x0133},
    {class09FSyncIncrementReadRange,0x0134, 0x0137},
    {class09FSetContextDmaNotifies, 0x0180, 0x0183},
    {class09FSetContextColorKey,    0x0184, 0x0187},
    {class09FSetContextClip,        0x0188, 0x018b},
    {class09FSetContextPattern,     0x018c, 0x018f},
    {class09FSetContextRop,         0x0190, 0x0193},
    {class09FSetContextBeta1,       0x0194, 0x0197},
    {class09FSetContextBeta4,       0x0198, 0x019b},
    {class09FSetContextSurfaces2d,  0x019c, 0x019f},
    {class09FSetOperation,          0x02fc, 0x02ff},
    {class09FControlPointIn,        0x0300, 0x0303},
    {class09FControlPointOut,       0x0304, 0x0307},
    {class09FSize,                  0x0308, 0x030b}
};

//
// These classes are supported across all chips.
//
CLASSDESCRIPTOR Common_ClassDescriptors[] =
{
    MKCLASSDECL(TMR_ENGINE_TAG, 0, NV01_TIMER),

    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_COLOR_KEY),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_SCALER),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_FROM_MEMORY),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_COLORMAP),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_SINK),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_PATCHCORD_VIDEO),

    MKCLASSDECL(DMA_ENGINE_TAG, 0, NV01_CONTEXT_DMA_FROM_MEMORY),
    MKCLASSDECL(DMA_ENGINE_TAG, 0, NV01_CONTEXT_DMA_TO_MEMORY),
    MKCLASSDECL(DMA_ENGINE_TAG, 0, NV01_CONTEXT_DMA_IN_MEMORY),

    MKCLASSDECL(NO_ENGINE, 0, NV01_MEMORY_SYSTEM),
    MKCLASSDECL(NO_ENGINE, 0, NV01_MEMORY_LOCAL_PRIVILEGED),
    MKCLASSDECL(NO_ENGINE, 0, NV01_MEMORY_LOCAL_USER),

    // MAKE THIS LAST !!!!
    MKCLASSDECL(CLASS_PSEUDO_ENGINE_TAG, 0, NV_CLASS),
};

#define NUM_COMMONCLASSDESCRIPTORS          (sizeof (Common_ClassDescriptors) / sizeof (CLASSDESCRIPTOR))

CLASSMETHODS classMethodsTable[] =
{
    {NV1_CLASS,                             NULL, 0},

    {NV1_CONTEXT_DMA_FROM_MEMORY,           NULL, 0},

    {NV1_CONTEXT_DMA_TO_MEMORY,             NULL, 0},

    {NV1_TIMER,                             Nv1TimerMethods,
                                            sizeof(Nv1TimerMethods)/sizeof(METHOD)},

    {NV1_BETA_SOLID,                        Nv1BetaSolidMethods,
                                            sizeof(Nv1BetaSolidMethods)/sizeof(METHOD)},

    {NV1_IMAGE_SOLID,                       Nv1ImageSolidMethods,
                                            sizeof(Nv1ImageSolidMethods)/sizeof(METHOD)},

    {NV1_IMAGE_PATTERN,                     Nv1ImagePatternMethods,
                                            sizeof(Nv1ImagePatternMethods)/sizeof(METHOD)},

    {NV1_IMAGE_BLACK_RECTANGLE,             Nv1ImageRectangleBlackMethods,
                                            sizeof(Nv1ImageRectangleBlackMethods)/sizeof(METHOD)},

    {NV1_RENDER_SOLID_LIN,                  Nv1RenderSolidLinMethods,
                                            sizeof(Nv1RenderSolidLinMethods)/sizeof(METHOD)},

    {NV1_RENDER_SOLID_TRIANGLE,             Nv1RenderSolidTriangleMethods,
                                            sizeof(Nv1RenderSolidTriangleMethods)/sizeof(METHOD)},

    {NV1_RENDER_SOLID_RECTANGLE,            Nv1RenderSolidRectangleMethods,
                                            sizeof(Nv1RenderSolidRectangleMethods)/sizeof(METHOD)},

    {NV1_IMAGE_BLIT,                        Nv1ImageBlitMethods,
                                            sizeof(Nv1ImageBlitMethods)/sizeof(METHOD)},

    {NV1_IMAGE_FROM_CPU,                    Nv1ImageFromCpuMethods,
                                            sizeof(Nv1ImageFromCpuMethods)/sizeof(METHOD)},

    {NV1_NULL,                              NULL, 0},

    {NV3_STRETCHED_IMAGE_FROM_CPU,          Nv3StretchedImageFromCPUMethods,
                                            sizeof(Nv3StretchedImageFromCPUMethods)/sizeof(METHOD)},


    {NV3_SCALED_IMAGE_FROM_MEMORY,          Nv3ScaledImageFromMemoryMethods,
                                            sizeof(Nv3ScaledImageFromMemoryMethods)/sizeof(METHOD)},

                                            
    {NV3_MEMORY_TO_MEMORY_FORMAT,           Nv3MemoryToMemoryFormatMethods,
                                            sizeof(Nv3MemoryToMemoryFormatMethods)/sizeof(METHOD)},
                                            
    {NV1_CONTEXT_DMA_IN_MEMORY,             NULL, 0},

    {NV_CONTEXT_ERROR_TO_MEMORY,            NULL, 0},

    {NV1_CONTEXT_ERROR_TO_MEMORY,           NULL, 0},

    {NV1_MEMORY_PRIVILEGED,                 NULL, 0},

    {NV1_MEMORY_USER,                       NULL, 0},

    {NV3_CONTEXT_ROP,                       Nv3ContextRopMethods,
                                            sizeof(Nv3ContextRopMethods)/sizeof(METHOD)},

    {NV04_VIDEO_LUT_CURSOR_DAC,             Nv04VideoLUTCursorDACMethods,
                                            sizeof(Nv04VideoLUTCursorDACMethods)/sizeof(METHOD)},

    {NV04_VIDEO_OVERLAY,                    Nv04VideoOverlayMethods,
                                            sizeof(Nv04VideoOverlayMethods)/sizeof(METHOD)},

    {NV3_DX3_TEXTURED_TRIANGLE,             Nv3DX3TexturedTriangleMethods,
                                            sizeof(Nv3DX3TexturedTriangleMethods)/sizeof(METHOD)},

    {NV05_VIDEO_LUT_CURSOR_DAC,             Nv05VideoLUTCursorDACMethods,        
                                            sizeof(Nv05VideoLUTCursorDACMethods)/sizeof(METHOD)},

    {NV3_GDI_RECTANGLE_TEXT,                Nv3GDIRectangleTextMethods,   
                                            sizeof(Nv3GDIRectangleTextMethods)/sizeof(METHOD)},

    {NV03_EXTERNAL_VIDEO_DECODER,           Nv3ExternalVideoDecoderMethods,
                                            sizeof(Nv3ExternalVideoDecoderMethods)/sizeof(METHOD)},

    {NV3_EXTERNAL_VIDEO_DECOMPRESSOR,       Nv3ExternalVideoDecompressorMethods,   
                                            sizeof(Nv3ExternalVideoDecompressorMethods)/sizeof(METHOD)},

    {NV1_EXTERNAL_PARALLEL_BUS,             Nv1ExternalParallelBusMethods,
                                            sizeof(Nv1ExternalParallelBusMethods)/sizeof(METHOD)},

    {NV3_EXTERNAL_MONITOR_BUS,              Nv3ExternalMonitorBusMethods,
                                            sizeof(Nv3ExternalMonitorBusMethods)/sizeof(METHOD)},

    {NV3_EXTERNAL_SERIAL_BUS,               Nv4ExternalSerialBusMethods,
                                            sizeof(Nv4ExternalSerialBusMethods)/sizeof(METHOD)},

    {NV3_CONTEXT_SURFACE_0,                 Nv3ContextSurface0Methods,
                                            sizeof(Nv3ContextSurface0Methods)/sizeof(METHOD)},

    {NV3_CONTEXT_SURFACE_1,                 Nv3ContextSurface1Methods,   
                                            sizeof(Nv3ContextSurface1Methods)/sizeof(METHOD)},

    {NV3_CONTEXT_SURFACE_2,                 Nv3ContextSurface2Methods,   
                                            sizeof(Nv3ContextSurface2Methods)/sizeof(METHOD)},

    {NV3_CONTEXT_SURFACE_3,                 Nv3ContextSurface3Methods,   
                                            sizeof(Nv3ContextSurface3Methods)/sizeof(METHOD)},

    {NV4_DVD_SUBPICTURE,                    Nv4DvdSubpictureMethods,
                                            sizeof(Nv4DvdSubpictureMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_SURFACES_2D,               Nv4ContextSurfaces2DMethods,
                                            sizeof(Nv4ContextSurfaces2DMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_PATTERN,                   Nv4ContextPatternMethods,
                                            sizeof(Nv4ContextPatternMethods)/sizeof(METHOD)},

    {NV4_GDI_RECTANGLE_TEXT,                Nv4GDIRectangleTextMethods,
                                            sizeof(Nv4GDIRectangleTextMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_SURFACE_SWIZZLED,          Nv4ContextSurfaceSwizzledMethods,
                                            sizeof(Nv4ContextSurfaceSwizzledMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_SURFACES_ARGB_ZS,          Nv4ContextSurfacesArgbZsMethods,
                                            sizeof(Nv4ContextSurfacesArgbZsMethods)/sizeof(METHOD)},

    {NV4_DX5_TEXTURED_TRIANGLE,             Nv4DX5TexturedTriangleMethods,
                                            sizeof(Nv4DX5TexturedTriangleMethods)/sizeof(METHOD)},

    {NV4_DX6_MULTI_TEXTURE_TRIANGLE,        Nv4DX6MultiTextureTriangleMethods,
                                            sizeof(Nv4DX6MultiTextureTriangleMethods)/sizeof(METHOD)},

    {NV10_CELSIUS_PRIMITIVE,                Nv10CelsiusPrimitiveMethods,
                                            sizeof(Nv10CelsiusPrimitiveMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_COLOR_KEY,                 Nv4ContextColorKeyMethods,
                                            sizeof(Nv4ContextColorKeyMethods)/sizeof(METHOD)},

    {NV4_RENDER_SOLID_LIN,                  Nv4RenderSolidLinMethods,
                                            sizeof(Nv4RenderSolidLinMethods)/sizeof(METHOD)},

    {NV4_RENDER_SOLID_TRIANGLE,             Nv4RenderSolidTriangleMethods,
                                            sizeof(Nv4RenderSolidTriangleMethods)/sizeof(METHOD)},

    {NV4_RENDER_SOLID_RECTANGLE,            Nv4RenderSolidRectangleMethods,
                                            sizeof(Nv4RenderSolidRectangleMethods)/sizeof(METHOD)},

    {NV4_IMAGE_BLIT,                        Nv4ImageBlitMethods,
                                            sizeof(Nv4ImageBlitMethods)/sizeof(METHOD)},

    {NV4_INDEXED_IMAGE_FROM_CPU,            Nv4IndexedImageFromCpuMethods,   
                                            sizeof(Nv4IndexedImageFromCpuMethods)/sizeof(METHOD)},

    {NV4_IMAGE_FROM_CPU,                    Nv4ImageFromCpuMethods,   
                                            sizeof(Nv4ImageFromCpuMethods)/sizeof(METHOD)},

    {NV05_SCALED_IMAGE_FROM_MEMORY,         Nv5ScaledImageFromMemoryMethods,   
                                            sizeof(Nv5ScaledImageFromMemoryMethods)/sizeof(METHOD)},

    {NV05_INDEXED_IMAGE_FROM_CPU,           Nv5IndexedImageFromCpuMethods,
                                            sizeof(Nv5IndexedImageFromCpuMethods)/sizeof(METHOD)},

    {NV05_IMAGE_FROM_CPU,                   Nv5ImageFromCpuMethods,
                                            sizeof(Nv5ImageFromCpuMethods)/sizeof(METHOD)},

    {NV05_STRETCHED_IMAGE_FROM_CPU,         Nv5StretchedImageFromCpuMethods,
                                            sizeof(Nv5StretchedImageFromCpuMethods)/sizeof(METHOD)},

    {NV10_VIDEO_LUT_CURSOR_DAC,             Nv10VideoLUTCursorDACMethods,
                                            sizeof(Nv10VideoLUTCursorDACMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_BETA,                      Nv4ContextBetaMethods,
                                            sizeof(Nv4ContextBetaMethods)/sizeof(METHOD)},

    {NV4_STRETCHED_IMAGE_FROM_CPU,          Nv4StretchedImageFromCpuMethods,
                                            sizeof(Nv4StretchedImageFromCpuMethods)/sizeof(METHOD)},

    {NV4_SCALED_IMAGE_FROM_MEMORY,          Nv4ScaledImageFromMemoryMethods,
                                            sizeof(Nv4ScaledImageFromMemoryMethods)/sizeof(METHOD)},

    {NV_VIDEO_COLOR_KEY,                    NvVideoColorKeyMethods,
                                            sizeof(NvVideoColorKeyMethods)/sizeof(METHOD)},

    {NV_VIDEO_SCALER,                       NvVideoScalerMethods,
                                            sizeof(NvVideoScalerMethods)/sizeof(METHOD)},

    {NV_VIDEO_FROM_MEMORY,                  NvVideoFromMemoryMethods,
                                            sizeof(NvVideoFromMemoryMethods)/sizeof(METHOD)},

    {NV_VIDEO_COLORMAP,                     NvVideoColormapMethods,   
                                            sizeof(NvVideoColormapMethods)/sizeof(METHOD)},

    {NV_VIDEO_SINK,                         NvVideoSinkMethods,   
                                            sizeof(NvVideoSinkMethods)/sizeof(METHOD)},

    {NV_PATCHCORD_VIDEO,                    NvPatchcordMethods,
                                            sizeof(NvPatchcordMethods)/sizeof(METHOD)},

    {NV_CONTEXT_DMA_IN_MEMORY,              NvDmaInMemoryMethods,
                                            sizeof(NvDmaInMemoryMethods)/sizeof(METHOD)},
                                            
    {NV_CONTEXT_DMA_TO_MEMORY,              NvDmaToMemoryMethods,
                                            sizeof(NvDmaToMemoryMethods)/sizeof(METHOD)},
                                            
    {NV_CONTEXT_DMA_FROM_MEMORY,            NvDmaFromMemoryMethods,
                                            sizeof(NvDmaFromMemoryMethods)/sizeof(METHOD)},
                                            
    {NV10_CONTEXT_SURFACES_2D,              Nv10ContextSurfaces2DMethods,
                                            sizeof(Nv10ContextSurfaces2DMethods)/sizeof(METHOD)},

    {NV10_VIDEO_OVERLAY,                    Nv10VideoOverlayMethods,
                                            sizeof(Nv10VideoOverlayMethods)/sizeof(METHOD)},

    {NV10_TEXTURE_FROM_CPU,                 Nv10TextureFromCpuMethods,
                                            sizeof(Nv10TextureFromCpuMethods)/sizeof(METHOD)},

    {NV15_VIDEO_LUT_CURSOR_DAC,             Nv15VideoLUTCursorDACMethods,
                                            sizeof(Nv15VideoLUTCursorDACMethods)/sizeof(METHOD)},

    {NV10_DVD_SUBPICTURE,                   Nv10DvdSubpictureMethods,
                                            sizeof(Nv10DvdSubpictureMethods)/sizeof(METHOD)},
                                            
    {NV10_SCALED_IMAGE_FROM_MEMORY,         Nv10ScaledImageFromMemoryMethods,
                                            sizeof(Nv10ScaledImageFromMemoryMethods)/sizeof(METHOD)},
                                            
    {NV10_IMAGE_FROM_CPU,                   Nv10ImageFromCpuMethods,
                                            sizeof(Nv10ImageFromCpuMethods)/sizeof(METHOD)},

    {NV10_CONTEXT_SURFACES_3D,              Nv10ContextSurfaces3DMethods,   
                                            sizeof(Nv10ContextSurfaces3DMethods)/sizeof(METHOD)},

    {NV10_DX5_TEXTURED_TRIANGLE,            Nv10DX5TexturedTriangleMethods,
                                            sizeof(Nv10DX5TexturedTriangleMethods)/sizeof(METHOD)},

    {NV10_DX6_MULTI_TEXTURE_TRIANGLE,       Nv10DX6MultiTextureTriangleMethods,
                                            sizeof(Nv10DX6MultiTextureTriangleMethods)/sizeof(METHOD)},

    {NV15_CELSIUS_PRIMITIVE,                Nv15CelsiusPrimitiveMethods,
                                            sizeof(Nv15CelsiusPrimitiveMethods)/sizeof(METHOD)},

    {NV15_IMAGE_BLIT,                       Nv15ImageBlitMethods,
                                            sizeof(Nv15ImageBlitMethods)/sizeof(METHOD)},

    // NV11 and NV15 Celsius share the same method struct.
    {NV11_CELSIUS_PRIMITIVE,                Nv15CelsiusPrimitiveMethods,
                                            sizeof(Nv15CelsiusPrimitiveMethods)/sizeof(METHOD)},

    //
    // MAKE THIS LAST!!!
    //                                     
    {NV_CLASS,                              NvClassMethods,
                                            sizeof(NvClassMethods)/sizeof(METHOD)},
};

#define CLASSMETHODSTABLE_SIZE              (sizeof(classMethodsTable) / sizeof(CLASSMETHODS))

//---------------------------------------------------------------------------
//
//  Class table access.
//
//---------------------------------------------------------------------------

RM_STATUS classGetClass
(
    PCLASSDB pClassDB,
	U032 classNum, 
	PCLASS *ppClass
)
{
    U032 i;

	for (i = 0; i < pClassDB->numClasses; i++)
    {
		if (pClassDB->pClasses[i].Type == classNum)
        {
			*ppClass = &pClassDB->pClasses[i];
			return RM_OK;
        }
    }

	return RM_ERROR;
}

//
// classGetInfo
//
// This routine sets up method handling for the specified class
// It also binds the class to a a particular engine.
//
RM_STATUS classGetInfo
(
    PENGINEDB pEngineDB, 
    PCLASSDB pClassDB,
    PCLASS pClass
)
{
    U032 classNum;
    PENGINEINFO pEngineInfo;
    PENGINEDESCRIPTOR pEngineDecl;
    U032 engine;
	U032 i;

    //
    // Get class number and engine tag.
    //
    classNum = CLASSDECL_FIELD(*pClass->ClassDecl, _CLASS);
    engine = CLASSDECL_FIELD(*pClass->ClassDecl, _TAG);

    //
    // Wire up engine data first.
    //
    if (engineGetInfo(pEngineDB, engine, &pEngineInfo, &pEngineDecl) != RM_OK)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: classGetInfo: bad engine tag ", engine);
        return RM_ERROR;
    }

    pClass->EngineDecl = pEngineDecl;
    pClass->EngineInfo = pEngineInfo;

    //
    // Now wire up method routines.
    //
    for (i = 0; i < CLASSMETHODSTABLE_SIZE; i++)
    {
        if (classMethodsTable[i].Type == classNum)
        {
            pClass->Method = classMethodsTable[i].Method;
            pClass->MethodMax = classMethodsTable[i].MethodMax;
            break;
        }
    }

    //
    // If we don't have an entry in the resman method table for the
    // given class, then use the engine-specific default table
    // (usually just filled with a hardware method stub).
    //
    if (i == CLASSMETHODSTABLE_SIZE)
    {
        pClass->Method = pEngineInfo->Methods;
        pClass->MethodMax = pEngineInfo->MethodMax;
    }
    
	return RM_OK;
}

//
// classBuildDB
//
// This routine generates the class database for the
// specified device.
//
RM_STATUS classBuildDB
(
    PENGINEDB pEngineDB,
    PCLASSDB pClassDB
)
{
    PCLASS pClass;
    PCLASSDESCRIPTOR pClassDesc;
    U032 numClasses;
    U032 i, j;
    RM_STATUS status;

    //
    // Calculate number of classes supported by this device.
    //
    // For now, just add the size of the common class descriptor
    // table to the number of class descriptors in the pClassDB table (we
    // should probably allow for overlaps between the two).
    //
    j = 0;
    for (i = 0; i < pClassDB->numClassDescriptors; i++)
    {
        if (CLASSDECL_FIELD(pClassDB->pClassDescriptors[i], _OPCODE) == CLASSDECL_INSTR)
            j++;
            
    }

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvInfo class descriptors ",  j);

    numClasses = NUM_COMMONCLASSDESCRIPTORS + j;

    //
    // Allocate space for correct number of entries.
    //
    status = osAllocMem((VOID **)&pClass, sizeof (CLASS) * numClasses);
    if (status)
        return status;

    //
    // Load up the fixed (common) classes.
    //
    pClassDesc = &Common_ClassDescriptors[0];
    for (i = 0; i < NUM_COMMONCLASSDESCRIPTORS; i++)
    {
        pClass[i].Type = CLASSDECL_FIELD(pClassDesc[i], _CLASS);
        pClass[i].ClassDecl = &pClassDesc[i];
        status = classGetInfo(pEngineDB, pClassDB, &pClass[i]);
        if (status != RM_OK)
        {
            //
            // This shouldn't happen; treat as a fatal error.
            //
            osFreeMem((VOID *)pClass);
            return (RM_ERROR);
        }
    }

    //
    // Load up chip-dependent classes.
    //
    pClassDesc = &pClassDB->pClassDescriptors[0];
    for (i = NUM_COMMONCLASSDESCRIPTORS, j = 0; i < numClasses; i++)
    {
        //
        // Advance to next class descriptor header
        // (i.e. skip over any class extension descriptors).
        //
        while (CLASSDECL_FIELD(pClassDesc[j], _OPCODE) != CLASSDECL_INSTR)
            j++;
        pClass[i].Type = CLASSDECL_FIELD(pClassDesc[j], _CLASS);
        pClass[i].ClassDecl = &pClassDesc[j];
        if (CLASSDECL_FIELD(pClassDesc[++j], _OPCODE) == CLASSINSTMALLOC_INSTR)
            pClass[i].ClassInstMalloc = &pClassDesc[j];
        else
            pClass[i].ClassInstMalloc = NULL;
        
        status = classGetInfo(pEngineDB, pClassDB, &pClass[i]);
        if (status != RM_OK)
        {
            //
            // This shouldn't happen; treat as a fatal error.
            //
            osFreeMem((VOID *)pClass);
            return (RM_ERROR);
        }
    }

    pClassDB->pClasses = pClass;
    pClassDB->numClasses = numClasses;

    return (RM_OK);
}

RM_STATUS classDestroyDB
(
    PCLASSDB  pClassDB
)
{
    osFreeMem((VOID *)pClassDB->pClasses);
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class object initial creation.
//
//---------------------------------------------------------------------------

RM_STATUS classCreateWellKnownObjects
(
    PHWINFO pDev,
    U032    ChID
)
{
    RM_STATUS    status;
    U032         i;
    U032         j;
    PCLASSDB pClassDB;
    PCLASSOBJECT ClassObject;
    PCLASSOBJECT *ClassObjects;
    PRENDERCOMMONOBJECT nullObject;
    PCLASS classTable;
#ifdef LEGACY_ARCH
    PDMAOBJECT   ErrNotifier;
#endif

    pClassDB = &pDev->classDB;

    //
    // Create and initialize all CLASS objects.  These are the master
    // class instances for this particular channel.  All user objects
    // created in this channel will be children of these master class
    // objects.
    //
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: numClasses ", pClassDB->numClasses);

    //
    // Allocate ClassObjects[] table.
    //
    status = osAllocMem((VOID **)&ClassObjects, sizeof (PCLASSOBJECT) * pClassDB->numClasses);
    if (status)
        return (status);

    classTable = pClassDB->pClasses;
    for (i = 0; i < pClassDB->numClasses; i++)
    {
        status = osAllocMem((VOID **)&ClassObject, sizeof (CLASSOBJECT));
        if (status)
        {
            while (i)
                osFreeMem(ClassObjects[--i]);
            osFreeMem(ClassObjects);
            return status;
        }

        //
        // Init global state.
        //
        ClassObjects[i]                 = ClassObject;
        ClassObject->Base.Name          = classTable[i].Type;
        //ClassObject->Base.Class         = &(classTable[i]);
        ClassObject->Base.Class         = &(classTable[NUM_COMMONCLASSDESCRIPTORS-1]);
        ClassObject->Base.ThisClass     = &(classTable[i]);
        ClassObject->Base.ChID          = ChID;
        ClassObject->Base.NotifyXlate   = NULL;
        ClassObject->Base.NotifyAction  = 0;
        ClassObject->Base.NotifyTrigger = 0;
        ClassObject->Base.NotifyEvent   = NULL;

        //
        // Add object into FIFO object tree.
        //
        status = fifoAddObject(pDev, (POBJECT)ClassObject);
        if (status != RM_OK)
        {
            while (i)
                osFreeMem(ClassObjects[--i]);
            osFreeMem(ClassObjects);
            return (status);
        }
    }

    //
    // Create and initialize NV_ERROR_NOTIFIER.
    //
    // jsw: this is no longer necessary with the new architecture
    //      error notifiers are explicitly created.
#ifdef LEGACY_ARCH
    // Find the DMA_TO_MEM master class object first.
    //
    j = 0;
    while ((j < pClassDB->numClasses) && (ClassObjects[j]->Base.Name != NV_CONTEXT_DMA_TO_MEMORY))
        j++;
    if (j == pClassDB->numClasses)
    {
        // Kinda silly error, but just in case we can't find the class
        while (i)
            osFreeMem(ClassObjects[--i]);
        osFreeMem(ClassObjects);
        return (status);
    }
    //
    // Now create our instance
    //
    status = dmaCreate(pDev, ClassObjects[j], NV_CONTEXT_ERROR_TO_MEMORY, (POBJECT *)&ErrNotifier, NULL);
    if (status)
    {
        while (i)
            osFreeMem(ClassObjects[--i]);
        osFreeMem(ClassObjects);
        dmaDelete((VOID*)pDev, (POBJECT)ErrNotifier);
        return (status);
    }
    ErrNotifier->Base.Name          = NV_CONTEXT_ERROR_TO_MEMORY;
    ErrNotifier->Base.Class         = &(classTable[j]);
    ErrNotifier->Base.ThisClass     = &(classTable[j]);
    ErrNotifier->Base.ChID          = ChID;
    ErrNotifier->Base.NotifyXlate   = NULL;
    ErrNotifier->Base.NotifyAction  = 0;
    ErrNotifier->Base.NotifyTrigger = 0;
    ErrNotifier->Base.NotifyEvent   = NULL;
    if ((status = fifoAddObject(pDev, (POBJECT)ErrNotifier)) != RM_OK)
    {
        dmaDelete((VOID*)pDev, (POBJECT)ErrNotifier);
        //return (status);
    }
#endif

    //
    // Create and initialize NV1_NULL_OBJECT.
    //
    // Find the NV1_NULL master class object first.
    //
    j = 0;
    while ((j < pClassDB->numClasses) && (ClassObjects[j]->Base.Name != NV1_NULL))
        j++;

    if (j == pClassDB->numClasses)
    {
        // Kinda silly error, but just in case we can't find the class
        while (i)
            osFreeMem(ClassObjects[--i]);
        osFreeMem(ClassObjects);
        return (status);
    }       

    //
    // Now create our instance
    // 
    status = grCreateObj(pDev, ClassObjects[j], 0, (POBJECT *)&nullObject, NULL);
    if (status)
    {
        while (i)
            osFreeMem(ClassObjects[--i]);
        osFreeMem(ClassObjects);
        grDestroyObj(pDev, (POBJECT)nullObject);
        return (status);
    }

    if ((status = fifoAddObject(pDev, (POBJECT)nullObject)) != RM_OK)
    {
        grDestroyObj(pDev, (POBJECT)nullObject);
        //return (status);
    }

    osFreeMem(ClassObjects);

    return (RM_OK);
}

RM_STATUS classDeleteWellKnownObjects
(
    VOID*   pDevHandle,
    POBJECT Object
)
{
    return (osFreeMem(Object));
}

RM_STATUS classInitCommonObject
(
    POBJECT pObject,
    PCLASSOBJECT pClassObject,
    U032 Name
)
{
    PCOMMONOBJECT pCommonObject;

    //
    // Initialize base object data.
    //
    pCommonObject = (PCOMMONOBJECT)pObject;

    pCommonObject->Base.Name = Name;
    pCommonObject->Base.ChID = pClassObject->Base.ChID;
    pCommonObject->Base.Class = pClassObject->Base.ThisClass;
    pCommonObject->Base.ThisClass = pClassObject->Base.ThisClass;
    pCommonObject->Base.NotifyXlate   = NULL;
    pCommonObject->Base.NotifyAction  = 0;
    pCommonObject->Base.NotifyTrigger = 0;
    pCommonObject->Base.NotifyEvent   = NULL;

    //
    // Initialize common object data.
    //
    pCommonObject->Valid            = FALSE;
    pCommonObject->NotifyPending    = FALSE;
    pCommonObject->Instance         = 0;
    pCommonObject->NotifyObject     = NULL;
    pCommonObject->Dma0Object       = NULL;
    pCommonObject->Dma1Object       = NULL;

    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  NOP methods.
//
//---------------------------------------------------------------------------

RM_STATUS nopCreate
(
    VOID*        pDevHandle,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *UserObject,
    VOID*        pCreateParms
)
{
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: Class not implemented yet: ", ClassObject->Base.Class->Type);
    return (RM_ERR_CREATE_BAD_CLASS);
}
RM_STATUS nopDelete
(
    PHWINFO pDev,
    POBJECT Object
)
{
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: Class not implemented yet: ", Object->Class->Type);
    return (RM_ERR_DELETE_BAD_CLASS);
}
RM_STATUS mthdNoOperation
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: Method NoOperation", Object->Class->Type);
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Create object.
//
//---------------------------------------------------------------------------

RM_STATUS classCreate
(
    VOID*        pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *UserObject,
    VOID*        pCreateParms
)
{
    //
    // Class specific create procedure.
    //

    DBG_VAL_PTR(ClassObject);
    return ((*(ClassObject->Base.ThisClass->EngineInfo->CreateObject))(pDev, ClassObject, UserName, UserObject, pCreateParms)); //KJK YUCK!!
}

//---------------------------------------------------------------------------
//
//  Destroy object.
//
//---------------------------------------------------------------------------

RM_STATUS classDestroy
(
    VOID*   pDev,
    POBJECT Object
)
{
    //
    // Class specific delete procedure.
    //
    DBG_VAL_PTR(Object);
    return ((*(Object->Class->EngineInfo->DestroyObject))(pDev, Object));    //KJK YUCK!!
}

//---------------------------------------------------------------------------
//
//  Software methods.
//  Emulate the device access in software.
//
//---------------------------------------------------------------------------

RM_STATUS classSoftwareMethod
(
    PHWINFO pDev,
    POBJECT Object,
    U032    Offset,
    V032    Data
)
{
    RM_STATUS  status;
    U032       i;

#if DEBUG
    //
    // Reject unaligned accesses.
    //
    if (Offset & 0x0003)
        return (RM_ERR_FIFO_BAD_ACCESS);
#endif // DEBUG
    if (Object != NULL)
    {
        //
        // Search for object method.
        //
        DBG_VAL_PTR(Object);
        for (i = 0; i < Object->Class->MethodMax; i++)
        {
            if ((Offset >= Object->Class->Method[i].Low)
            &&  (Offset <  Object->Class->Method[i].High))
            {

                status = Object->Class->Method[i].Proc(pDev,
                                                       Object,
                                                       &(Object->Class->Method[i]),
                                                       Offset,
                                                       Data);
                //
                // Send completion notification.
                //
                notifyMethodComplete(pDev, Object, Offset, Data, status);
                return (status);
            }
        }
        //
        // Method not found, so report the error if notify pending.
        //
        notifyMethodComplete(pDev, Object, Offset, Data, RM_ERR_FIFO_BAD_ACCESS);
    }
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: invalid access ", RM_ERROR);
    if (Object)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "              object ", Object->Class->Type);
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "              object NULL");
    }
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "              offset ", Offset);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "                data ", Data);
    return (RM_ERR_FIFO_BAD_ACCESS);
}

//
// SMP wrapper for classSoftwareMethod
//
RM_STATUS classDirectSoftwareMethod
(
    PHWINFO pDev,
    POBJECT Object,
    U032    Offset,
    V032    Data
)
{
    RM_STATUS status;

    osEnterCriticalCode(pDev);
    status = classSoftwareMethod(pDev, Object, Offset, Data);
    osExitCriticalCode(pDev);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\dacstate.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Manager ******************************\
*                                                                           *
* Module: DACSTATE.C                                                        *
*   The DAC state is changed in this module.                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <dac.h>
#include <os.h>
#include <vga.h>
#include "nvhw.h"

VOID enableCursor(PHWINFO, U032);
VOID disableCursor(PHWINFO, U032);

//
// Change DAC hardware state.
//
RM_STATUS stateDac
(
    PHWINFO pDev,
    U032    msg
)
{
    U032 i;

    switch (msg)
    {
        case STATE_UPDATE:
            //
            // Only the Dpm Level and APLL are changed here.  All other
            // updates occur in the VBlank interrupt handler.
            //
            if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_VPLL)
            {
                dacCalcPLL(pDev);
                pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_VPLL;
            }

            // NOTE: MCLK and NVCLK updates are done in mcState.c:stateMc
            
            if (pDev->Framebuffer.UpdateFlags & UPDATE_HWINFO_DISPLAY_PARAMS)
            {

                //
                // Program the new DAC settings
                //    
                // NT NOW calls dacSetMode to do the modesets !!! (Miniport no longer sets the mode)
                // However, the NT driver does NOT use the class interface to do the modeset.
                // Instead it calls RmSetMode.

                dacSetMode(pDev, 0);

#ifdef NTRM
                osSetVideoMode(pDev);
#endif                
                //
                // Perform any necessary OS-specific function
                // after the change to the DAC
                //
                osStateDacEx(pDev, msg);

                pDev->Framebuffer.UpdateFlags &= ~UPDATE_HWINFO_DISPLAY_PARAMS;
            }
            
            if (!pDev->Vga.Enabled)
            {
                for (i = 0; i < MAX_CRTCS; i++)
                {
                    enableCursor(pDev, i);
                    pDev->Dac.CrtcInfo[i].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_IMAGE;	// force an update from image in nvInfo
                }
            }
            else
            {
                for (i = 0; i < MAX_CRTCS; i++)
                    disableCursor(pDev, i);
            }
                
            break;
        case STATE_LOAD:
            //
            // Initialize DAC cursor emulation.
            //
#ifdef NTRM
            for (i = 0; i < MAX_CRTCS; i++)
                pDev->Dac.CrtcInfo[i].CursorType = DAC_CURSOR_TWO_COLOR_XOR;
#else
// Don't turn on cursor until asked to by Windows.
//            pDev->Dac.CursorType      = DAC_CURSOR_TWO_COLOR_XOR;
#endif

            //
            // Make sure we enable the backend video overlay, if req'd
            //
            // KJK: Move this to the new video engine code
            //
            /*
            //
            // New DDraw protocol will enable the overlay on its own
            //
            if ((pDev->Video.Enabled == 1) && !pDev->Vga.Enabled)
                FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _ON);
            */                

            if (!pDev->Vga.Enabled)
            {
#ifdef NTRM
                osSetVideoMode(pDev);
#endif            
                //
                // Perform any necessary OS-specific function
                // after the change to the DAC
                //
                osStateDacEx(pDev, msg);
            
                //
                // Load cursor on head 0 only.
                //
                enableCursor(pDev, 0);
                pDev->Dac.CrtcInfo[0].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_IMAGE;	// force an update from image in nvInfo

                //
                // Load pallette.
                //
                
				// set flag to update palette in vblank
#ifndef NTRM
                // There is a synchronization issue with NT/Win2K SMP where this code could
                // be running at the same time as the mode set code on another CPU which will
                // cause corruption in the LUT.  This code is, strictly speaking, not necessary 
                // for NT/Win2K.  However, the kernel code is NOT supposed to contain OS dependencies, 
                // so this must be changed to be OS independent.
	            pDev->Dac.UpdateFlags |= UPDATE_HWINFO_DAC_COLORMAP;
#endif            

                //
                // Enable the vertical blank interrupt on primary device.
                // XXXscottl - assume it's on head 0 for now.
                //
                DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, 0);
                DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_EN_0, _VBLANK, _ENABLED, 0);
                
                pDev->Dac.CrtcInfo[0].StateFlags |= DAC_CRTCINFO_VBLANK_ENABLED;
            }
			else
            {
                for (i = 0; i < MAX_CRTCS; i++)
                {
                    DAC_REG_WR32(NV_PCRTC_INTR_EN_0, 0, i);
                    disableCursor(pDev, i);
                }
            }
            break;
        case STATE_UNLOAD:

            // Disable the cursor and the vertical blank interrupt(s).
            //
            for (i = 0; i < MAX_CRTCS; i++)
            {
                disableCursor(pDev, i);
                DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, i);
                DAC_REG_WR32(NV_PCRTC_INTR_EN_0, 0, i);
                pDev->Dac.CrtcInfo[i].StateFlags &= ~DAC_CRTCINFO_VBLANK_ENABLED;
            }
            break;
        case STATE_INIT:
            initDac(pDev);
            break;
        case STATE_DESTROY:
            break;
    }
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\dacinit.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Manager ******************************\
*                                                                           *
* Module: DACINIT.C                                                         *
*   The DAC is initialized in this module.                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <dac.h>
#include <os.h>
#include <i2c.h>
#include <edid.h>
#include "nvhw.h"
#include "nvcm.h"
#include <devinit.h>

//
// DAC names.
//
char dac16Name[] = "SGS 16-bit DAC                ";
char dac32Name[] = "SGS 32-bit DAC (Van Gogh)     ";
char dac64Name[] = "SGS 64-bit DAC (Van Dyke)     ";
char dac128Name[] = "NV 128-bit DAC (Picasso)    ";

//
// Externals.
//

extern char strDevNodeRM[];
char strEnable256Burst[] = "Enable256Burst";
char strTVOutOnPrimary[] = "TVOutOnPrimary";
BOOL dacTVConnected(PHWINFO);

BOOL dacMonitorConnectStatus(PHWINFO,U032);
BOOL dacFlatPanelConnectStatus(PHWINFO pDev, U032);

static U032 dacGetDisplayType(PHWINFO, U032);

//
// Initialize the DAC.
//
RM_STATUS initDac
(
    PHWINFO pDev
)
{
    U032 i;
    U032 j;
    U032 k;
    U032 data, data32;
#ifndef IKOS
    U008 lockA, lockB, cr3BhA, cr3BhB;
    U008 data08;
#endif
    U032 freq = 0;

    nvHalDacControl(pDev, DAC_CONTROL_INIT);

    if ( BiosGetMaxExternalPCLKFreq( pDev, 1, &freq ) == RM_OK )
    {
        if ( freq != 0 )
        {
            // Convert freq from freq(Mhz)*100 to plain Hz
            freq = freq * 10000;
            pDev->halHwInfo.pDacHalInfo->CrtcInfo[1].PCLKLimit8bpp  = freq;
            pDev->halHwInfo.pDacHalInfo->CrtcInfo[1].PCLKLimit16bpp = freq;
            pDev->halHwInfo.pDacHalInfo->CrtcInfo[1].PCLKLimit32bpp = freq;
        }
    }

    // Determine I2C setup from BIOS
    dacReadBIOSI2CSettings(pDev);

    // Read/Parse BIOS Display Config Block
    dacParseDCBFromBIOS(pDev);

    //
    // Find out where to send TV Out commands (overrides dacReadBIOSI2CSettings)
    //
    // NV_I2C_PORT_SECONDARY is the default (unless the BIOS overrode it), but
    // we can override everything here with the registry
    if ( OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, strTVOutOnPrimary, &data32) == RM_OK)
    {
        pDev->Dac.TVOutPortID = NV_I2C_PORT_PRIMARY;
    }

    //
    // Initialize flags.
    //
    pDev->Dac.UpdateFlags = 0;

    //
    // Initialize cursor.
    //
    for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
    {
        pDev->Dac.CrtcInfo[i].CursorType      = DAC_CURSOR_TWO_COLOR_XOR;
        pDev->Dac.CrtcInfo[i].UpdateFlags = 0;
    }

    //
    // Start the cursor cache at 0
    //
    pDev->Dac.CursorCacheCount = 0;
    pDev->Dac.CursorCacheEntry = 0;
    pDev->Dac.CursorCacheEnable = 1;
    
    //
    // Clear the initial cursor cache data
    //
    for (k = 0; k < MAX_CACHED_CURSORS; k++)
    {
        pDev->Dac.CursorMaskCRC[k] = 0;    
        for (i = 0; i < 32; i++)    
            for (j = 0; j < 32; j++)
                pDev->Dac.CursorImageCache[i][j][k] = 0;
    }                
            
    //
    // Initialize palette to grey scale ramp.
    //
    for (i = 0; i < 256; i++)
        pDev->Dac.Palette[i] = (i << 16) | (i << 8) | i;
    //
    // Initialize gamma to unity translation.
    //
    for (i = 0; i < 256; i++)
        pDev->Dac.Gamma[i] = (i << 16) | (i << 8) | i;
    //
    // Initialize power management state.
    //
    pDev->Dac.DpmLevel = 0;

    //
    // Check for a registry override to temporarily enable the 256Burst setting
    // within the DAC.
    //    
    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, strEnable256Burst, &data) == RM_OK)
        pDev->Dac.HalInfo.Enable256Burst = data;

    //
    // Set the min/max VCO values from the BIOS. This call may fail if we're
    // running an older BIOS, so in this case we'll use the RM defaults.
    //
    if (DevinitGetMinMaxVCOValues(pDev,
                                  &pDev->Dac.FminVco,
                                  &pDev->Dac.FmaxVco) != RM_OK)
    {
        // Use the RM default values for these chips
        // NOTE: These defaults are duplicated in dacCalcMNP() which may
        //       be called before initDac()
        if (IsNV15orBetter(pDev)) {
            if (IsNV15MaskRevA01(pDev))
                pDev->Dac.FminVco = 200000;
            else
                pDev->Dac.FminVco = 250000;

            pDev->Dac.FmaxVco = pDev->Dac.FminVco * 2; 
        } else {
            pDev->Dac.FminVco = 128000;
            pDev->Dac.FmaxVco = 256000;
        }
    }

    //
    // Look for a registry override for min/max VCO (in MHz).
    //
    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "FminVCO", &data32) == RM_OK)
        pDev->Dac.FminVco = data32 * 1000;

    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "FmaxVCO", &data32) == RM_OK)
        pDev->Dac.FmaxVco = data32 * 1000;

    //
    // Set current desktop state to default.
    //
    pDev->Dac.DesktopState = NV_DAC_DESKTOP_STATE_DEFAULT;

    //
    // Attempt to detect the presense of an external TV chip.  Attempt to also
    // identify the part so we know how to program it up when a modeset comes
    // through a bit later.
    //    

    //Skip TV encoder detection for IKOS.
#ifndef IKOS
    //
    // If Canopus, skip the detection
    //
    if (pDev->Video.HalInfo.CustomizationCode & CUSTOMER_CANOPUS)
        pDev->Dac.EncoderType = NV_ENCODER_NONE;
    else
    {        
        // Use head 0 for decoder detection.
        dacDetectEncoder(pDev, 0);
    } // !Canopus

    // Get TV output format.
    if (dacReadTVOutFromRegistry(pDev, 0, &data32) == RM_OK)
        pDev->Dac.TVoutput = data32;
    else
        pDev->Dac.TVoutput = 0xffffffff;

    // Set TV format to be what the BIOS chose
    CRTC_RD(NV_CIO_CRE_SCRATCH0__INDEX, data08, 0);
    pDev->Dac.TVStandard = data08 & 0x7;

    //
    // We're about to setup head 0's default display type.
    // Before we do that, invalidate any other heads.
    //
    for (i = 1; i < pDev->Dac.HalInfo.NumCrtcs; i++)
    {
        SETDISPLAYTYPE(pDev, i, 0xffffffff);
        SETMONITORTYPE(pDev, i, 0xffffffff);
    }


    
    //Mobile hotkey support initialization.

    pDev->HotKeys.queueHead = 0;
    pDev->HotKeys.queueTail = 0;
    pDev->HotKeys.enabled = FALSE;

    if (pDev->Power.MobileOperation) {

        EnableMobileHotkeyHandling(pDev);

        lockA = ReadCRTCLock(pDev, 0);           //Back up lock state
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 0);    //Unlock CRTC extended regs
        lockB = ReadCRTCLock(pDev, 1);           //Back up lock state
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 1);    //Unlock CRTC extended regs

        //Read CR3B regs -- used below to set default display types.
        // Write back the registers with the 'enable' bits cleared.
        // They will be set as needed via display driver calls to dacSetModeMulti.
        CRTC_RD(0x3B, cr3BhA, 0);
        CRTC_WR(0x3B, cr3BhA & 0x0F, 0);

        CRTC_RD(0x3B, cr3BhB, 1);
        CRTC_WR(0x3B, cr3BhB & 0x0F, 1);

        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lockA, 0); // Restore lock state
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lockB, 0); // Restore lock state
    }

    if ((pDev->Power.MobileOperation) && ((pDev->Chip.BiosRevision & 0xFF0000FF) >= 0x03000019)) {
    //Set startup display options based on BIOS CR3B settings.
    /*        if (cr3BhA & 0x10) {
            data = DISPLAY_TYPE_FLAT_PANEL; //internal LCD
        } else */
        if (cr3BhA & 0x20) {
            data = DISPLAY_TYPE_MONITOR;
        } else if (cr3BhA & 0x40) {
            data = DISPLAY_TYPE_TV;
        } else if (cr3BhA & 0x80) {
            data = DISPLAY_TYPE_FLAT_PANEL; //external DFP
        } else {
            data = DISPLAY_TYPE_NONE;
        }

        SETDISPLAYTYPE(pDev, 0, data);

        if (cr3BhB & 0x10) {
            data = DISPLAY_TYPE_FLAT_PANEL; //internal LCD
/*        } else if (cr3BhB & 0x20) {
            data = DISPLAY_TYPE_MONITOR;
        } else if (cr3BhB & 0x40) {
            data = DISPLAY_TYPE_TV;
        } else if (cr3BhB & 0x80) {
            data = DISPLAY_TYPE_FLAT_PANEL; //external DFP
            */
        } else {
            data = DISPLAY_TYPE_NONE;
        }

        SETDISPLAYTYPE(pDev, 1, data);

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR3B/0 register init:", cr3BhA);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR3B/1 register init:", cr3BhB);

    } else {

    //
    // Set default boot display type...first, use what the
    // CR28/CR33 registers tell us via the BIOS settings.
    //
        SETDISPLAYTYPE(pDev, 0, dacGetBiosDisplayType(pDev, 0));
        SETDISPLAYTYPE(pDev, 0, dacGetDisplayType(pDev, 0));
    }


    //Determine which displays the VGA BIOS enabled at boot time, so that on mobile systems
    //we can have the same ones enabled in Windows.  The result is reported to the display
    //driver as a device bit mask rather than the old head-based system.
    data = 0;   //clear boot device bitmask
    //Loop over all heads
    for (j = 0; j < MAX_CRTCS; j++) {   //Head
//        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "*** Head:", j);
        k = GETDISPLAYTYPE(pDev, j);    //Device on this head
        //Loop over all list entries
        for (i = 0; (i < DCB_MAX_NUM_DEVDESCS) && (pDev->Dac.DCBDesc[i].DCBRecType != DCB_DEV_REC_TYPE_EOL); i++)
        {
//            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  *** Checking for: ", pDev->Dac.DCBDesc[i].DevTypeUnit);
            //If list entry is for this head...
            if (pDev->Dac.DCBDesc[i].DCBRecHead == (U032)(j?DCB_DEV_REC_HEAD_B:DCB_DEV_REC_HEAD_A))
            {
                //...and display type matches the BIOS's...
                if (((pDev->Dac.DCBDesc[i].DCBRecType == DCB_DEV_REC_TYPE_CRT) && (k == DISPLAY_TYPE_MONITOR))
                    || ((pDev->Dac.DCBDesc[i].DCBRecType == DCB_DEV_REC_TYPE_DD_SLINK) && (k == DISPLAY_TYPE_FLAT_PANEL))
                    || ((pDev->Dac.DCBDesc[i].DCBRecType == DCB_DEV_REC_TYPE_TV) && (k == DISPLAY_TYPE_TV)))
                {
                    //...OR this entry's mask into the boot device mask
                    data |= pDev->Dac.DCBDesc[i].DevTypeUnit;   //Device bitmask for device on this head.
                }
            }
        }
    }
    pDev->Dac.BootDevicesBitMap = data;
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Boot device(s):", pDev->Dac.BootDevicesBitMap);

    //LPL: This forcing of the display type in the mobile case is a workaround
    // while the display driver still determines which display we booted on (or
    // which display is the primary, in extended mode) using the old method.
    // Once the switch to the new, improved method implemented above (using
    // NV_CFG_GET_BOOT_DEVICES) is complete, the code below should be deleted.
    if (pDev->Power.MobileOperation && (GETDISPLAYTYPE(pDev, 1) == DISPLAY_TYPE_FLAT_PANEL))
        SETDISPLAYTYPE(pDev, 0, DISPLAY_TYPE_FLAT_PANEL);
    //


    //
    // Set the MonitorType for head 0 *only*
    //
    switch (GETDISPLAYTYPE(pDev, 0))
    {
        case DISPLAY_TYPE_MONITOR:
            SETMONITORTYPE(pDev, 0, MONITOR_TYPE_VGA);
            break;
        case DISPLAY_TYPE_TV:
            switch (pDev->Dac.TVStandard)
            {
                case NTSC_M:
                case NTSC_J:
                    SETMONITORTYPE(pDev, 0, MONITOR_TYPE_NTSC);
                    break;
                case PAL_A:
                case PAL_M:
                case PAL_N:
                case PAL_NC:
                    SETMONITORTYPE(pDev, 0, MONITOR_TYPE_PAL);
                    break;
            }
            break;
        case DISPLAY_TYPE_FLAT_PANEL:        
            SETMONITORTYPE(pDev, 0, MONITOR_TYPE_FLAT_PANEL);
            break;
        default:
            SETDISPLAYTYPE(pDev, 0, DISPLAY_TYPE_MONITOR);
    }
#endif // not IKOS

    //
    // initialize per-crtc state
    //
    for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
    {
        pDev->Dac.CrtcInfo[i].RefCount = 0;
        pDev->Dac.CrtcInfo[i].StateFlags = 0;
        pDev->Dac.CrtcInfo[i].VBlankCounter = 0;
        pDev->Dac.CrtcInfo[i].VBlankToggle = 0;
        pDev->Dac.CrtcInfo[i].VBlankCallbackList = NULL;
        pDev->Dac.CrtcInfo[i].CurrentPanOffset = 0;
        pDev->Dac.CrtcInfo[i].CurrentImageOffset = 0;
    }

    //
    // Perform any os initialization
    //
    initDacEx(pDev);
    
    //
    // initialize I2C lock flags
    //
    pDev->I2CAcquired = 0;

    //
    // Initialize CR44 contents to UNKNOWN 
    //
    pDev->Dac.HalInfo.Head2RegOwner = HEAD2_OWNER_UNKNOWN;

    //
    // Determine which head was used to boot the system
    //
    // NEED TO DO: Get this from the BIOS, but for now if we're
    // a mobile system booting the DFP let's get the drivers to swing
    // over to the secondary head.
    // LPL : preliminary version that reads from BIOS in place above.
    //
    pDev->Dac.HalInfo.InitialBootHead = 0;
#ifdef MACOS
    if (pDev->Dac.HalInfo.NumCrtcs > 1)    // ie: NV11
        if (GETDISPLAYTYPE(pDev, 1) == DISPLAY_TYPE_FLAT_PANEL)
            pDev->Dac.HalInfo.InitialBootHead = 1;
#else
    if (pDev->Power.MobileOperation && (GETDISPLAYTYPE(pDev, 0) == DISPLAY_TYPE_FLAT_PANEL))
        pDev->Dac.HalInfo.InitialBootHead = 1;
#endif

    //
    // WORKAROUND - REMOVE QUICKLY BEFORE SCOTT LONG CATCHES ME
    //
    // The current PCLK limits programmed by the HAL are head driven.
    // They really need to be device driven, as the head can drive any
    // one of many devices.  The current HeadB limits were dictated by
    // an external CRT (150MHz max) and were fine while the possible
    // DFP's and TV's stayed below that ceiling.  Now mobile is appearing
    // with huge DFP's, and therefore the 150 limit is insufficient.
    //
    // Since mobile will never use an external DAC, override in this one
    // case to 170MHz in order to handle 16x12 panels.
    //
    // The real limits will actually come from the BIOS via the BIP/3
    // parser.
    //
    if (pDev->Power.MobileOperation)
    {
        pDev->Dac.HalInfo.CrtcInfo[1].PCLKLimit8bpp = 170000000;
        pDev->Dac.HalInfo.CrtcInfo[1].PCLKLimit16bpp = 170000000;
        pDev->Dac.HalInfo.CrtcInfo[1].PCLKLimit32bpp = 170000000;
    }

    return (RM_OK);
}

// WinNT / Win2k Notes:
//
//        Before RmInitDevice() is called in the NT miniport, we need
//        to make sure that any non-primary monitor is 'alive',  so that
//        dacMonitorConnectStatus() works correctly.  We do this by using
//        the 'WakeUpCard' function in the miniport.
//  
//        dacMonitorConnectStatus() sometimes returns FALSE POSITIVE 
//        when on a FLAT PANEL panel or TV.  So to make NT initialization
//        as safe as possible, we need to use combinations of these functions.
//
//        1) Check for CRT first
//        2) Check for Flat Panel
//        3) Check for TV
//        4) Fall back to CRT
//

#ifdef MACOS        /* macos9 or macosX */

// Mac algorithm for monitor selection is different from windows:
//
//   if flat panel avail
//      use it
//   else if CRT attached
//      use it
//   else
//      no device, error.
//

static U032 dacGetDisplayType(
    PHWINFO pDev,
    U032 Head
)
{
    U032   BootDisplayDevice;
    U008   lock;
    RM_STATUS status;

    //
    // Use our current setting as the desired display type.
    //
    BootDisplayDevice = GETDISPLAYTYPE(pDev, Head);

    if (dacFlatPanelConnectStatus(pDev, Head))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Digital Flat Panel\n");

        BootDisplayDevice = DISPLAY_TYPE_FLAT_PANEL;
        
        dacGetPWMController(pDev);        	
    }
    else if (dacVGAConnectStatus(pDev, Head))
    {
        lock = UnlockCRTC(pDev, Head);
        status = EDIDRead(pDev, Head, DISPLAY_TYPE_MONITOR);
        RestoreLock(pDev, Head, lock);
        
        if ((status == RM_OK) && (edidIsAnalogDisplay(pDev, Head)))
            BootDisplayDevice = DISPLAY_TYPE_MONITOR;
    }

    return BootDisplayDevice;
}

#else

static U032 dacGetDisplayType(
    PHWINFO pDev,
    U032 Head
)
{
    U032 BootDisplayDevice;
    BOOL MonitorAvail, FlatPanelAvail, TVAvail, RequestedDisplayDeviceAvail;
    U032 RequestedDisplayDevice;

    //
    // Use our current setting as the desired display type.
    //
    RequestedDisplayDevice = GETDISPLAYTYPE(pDev, Head);

    // @ Detect avail display devices
    // - Check the MONITOR status
    if(dacMonitorConnectStatus(pDev, Head)) {
        MonitorAvail = TRUE;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Monitor connected\n\r");
    }
    else {
        MonitorAvail = FALSE;
    }

    // - Check the FLATPANEL status
    if(IsNV5orBetter(pDev) && dacFlatPanelConnectStatus(pDev, Head)) {
        FlatPanelAvail = TRUE;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Digital Flat Panel connected\n\r");
    }
    else {
        FlatPanelAvail = FALSE;
    }

    // - Check the TV status
    if(dacTVConnectStatus(pDev, Head)) {
        TVAvail = TRUE;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - TV connected\n\r");
    }
    else {
        TVAvail = FALSE;
    }

    // - Assume the requested display device is not available
    RequestedDisplayDeviceAvail = FALSE;

    switch(RequestedDisplayDevice) {
        case DISPLAY_TYPE_MONITOR:
            if(MonitorAvail)
                RequestedDisplayDeviceAvail = TRUE;
            break;

        case DISPLAY_TYPE_FLAT_PANEL:
            if(FlatPanelAvail)
                RequestedDisplayDeviceAvail = TRUE;
            break;

        case DISPLAY_TYPE_TV:
            if(TVAvail)
                RequestedDisplayDeviceAvail = TRUE;
            break;

        default:
            break;
    }

    // - If the requested device is unavail, determine the next best thing
    if(!RequestedDisplayDeviceAvail)
    {
        if(MonitorAvail)
        {
            BootDisplayDevice = DISPLAY_TYPE_MONITOR;
        }
        else
        {
            if(FlatPanelAvail)
            {
                BootDisplayDevice = DISPLAY_TYPE_FLAT_PANEL;
            }
            else
            {
                if(TVAvail)
                    BootDisplayDevice = DISPLAY_TYPE_TV;
                else
                    BootDisplayDevice = dacGetBiosDisplayType(pDev, 0);
            }
        }
    }

    // - If the requested device is present, use it
    if(RequestedDisplayDeviceAvail)
        BootDisplayDevice = RequestedDisplayDevice;

    // Display the resulting display device
    switch(BootDisplayDevice) {

        case DISPLAY_TYPE_MONITOR:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Monitor selected as display device\n\r");
            break;

        case DISPLAY_TYPE_FLAT_PANEL:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Digital Flat Panel selected as display device\n\r");
            break;

        case DISPLAY_TYPE_TV:
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - TV selected as display device\n\r");
               break;

        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Display device is unknown\n\r");
            break;
    }

    return BootDisplayDevice;
}
#endif   /* ! MACOS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\dacmode.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* DAC Mode Control ***************************\
*                                                                           *
* Module: DACMODE.C                                                         *
*   The DAC mode control management is updated here.                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>
#include <nvcm.h>
#include <bios.h>   //For hotkey defs.  Can remove once those are put in nv_ref.h


//------------------------------------------------------------------------
// First 16 colors for mode 13h (compatible R'G'B'RGB)
//
U008 CompatColors[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07,
                        0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F};
                         
//------------------------------------------------------------------------
// Gray values for next 16 (6 bits of intensity)
//
U008 GrayColors[] = {0x00, 0x05, 0x08, 0x0B, 0x0E, 0x11, 0x14, 0x18,
                      0x1C, 0x20, 0x24, 0x28, 0x2D, 0x32, 0x38, 0x3F};
                                                                              
//------------------------------------------------------------------------
// Fixup values for DAC color registers after summing to gray shades
//
U008 FixupColors[] = {0x00, 0x05, 0x11, 0x1C, 0x08, 0x0B, 0x14, 0x28,
                       0x0E, 0x18, 0x2D, 0x32, 0x20, 0x24, 0x38, 0x3F};
                                                                       
//------------------------------------------------------------------------
// 9 groups of five intensities are used to generate the next 216 colors.
// Each group is used to generate 24 colors by walking around a "color
// triangle" with eight colors per side.
//
U008 IntenseTable[] =
{
    0x00, 0x10, 0x1F, 0x2F, 0x3F,
    0x1F, 0x27, 0x2F, 0x37, 0x3F,
    0x2D, 0x31, 0x36, 0x3A, 0x3F,
                                
    0x00, 0x07, 0x0E, 0x15, 0x1C,
    0x0E, 0x11, 0x15, 0x18, 0x1C,
    0x14, 0x16, 0x18, 0x1A, 0x1C,
                                
    0x00, 0x04, 0x08, 0x0C, 0x10,
    0x08, 0x0A, 0x0C, 0x0E, 0x10,
    0x0B, 0x0C, 0x0D, 0x0F, 0x10
};                              

//
// KJK I suspect this could be removed (or at least shortened) since we only used
//      one of the mode settings
//

//------------------------------------------------------------------------
//  Basic VGA mode default settings. This setup is used initially in all 
//  mode sets.
//
VGATBL   VGATable =
{
    // U008   columns;
    // U008   rows;
    // U008   char_height;
    // U016   RegenLenght;
    // SEQ    seq_regs;              // SR1-4
    // U008   PT_Misc;               // Misc Register
    // CRTC   crtc_regs;             // CR0-18
    // U008   PT_ATC[20];            // Attribute Controller
    // GR     gr_regs;               // GR0-8

    // Basic CRTC Table for Packed Pixel Graphics Modes.
     0x50, 0x1D, 0x10,
     0xFFFF,
    {0x01, 0x0F, 0x00, 0x0E},               // Seq
     0xEB,
    {0x5F, 0x4F, 0x4F, 0x83, 0x53, 0x9F,    // CR0-18
     0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xEA, 0x0C,
     0xDF, 0x50, 0x00, 0xDF, 0x0C, 0xE3,
     0xFF},
    {0x00, 0x01, 0x02, 0x03, 0x04, 0x05,    // Attr
     0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
     0x0C, 0x0D, 0x0E, 0x0F, 0x01, 0x00,
     0x0F, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x40,    // GR
     0x05, 0x0F, 0xFF}
};    

/*************************** Helper functions *******************************/
//
//       dacWriteColor - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
static VOID dacWriteColor(PHWINFO pDev, U032 head, U008 colorval)
{
    U008   component;          // color component 4=red/2=green/1=blue
    U008   color;              // Color component to write
    
    for (component = 0x04; component; component >>= 1)
    {
        // Color?
        if (colorval & component)
            color = 0x2A;               // Add color
        else
            color = 0;                  // No color on this component
        
        // Intensity?
        if (colorval & (component << 3))
            color += 0x15;
    
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, color, head);
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, color);
    }
}        
        
//
//       dacWriteColor2 - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
static VOID dacWriteColor2(PHWINFO pDev, U032 head, U016 red, U016 green, U016 blue, U016 tblidx)
{
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+red], head);
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+green], head);
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+blue], head);

    ////WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+red]);
    ////WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+green]);
    ////WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+blue]);
}

//
//       dacLoadColorDACTable - Load the DAC for the 16-color modes
//
static VOID dacLoadColorDACTable(PHWINFO pDev, U032 head)
{
    U008  i;
    
    // Select the DAC address
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00, head);
    ////WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);
    
    // Do the first 64 locations
    for (i = 0; i < 64; i++)
        dacWriteColor(pDev, head, i);
        
}
    
//
//       dacLoadColor256DAC - Load the DAC for the 256-color modes
//
static VOID dacLoadColor256DAC(PHWINFO pDev, U032 head)
{
    U016  i;
    U016  red;
    U016  green;
    U016  blue;
    
    // Select the DAC address
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00, head);
    ////WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);
    
    //--------------------------------------------------------------------
    // The first 16 colors are the compatible colors (i.e. 0,1,2,3,4,5,14,
    // 7,38,39,3A,3B,3C,3D,3E,3F).
    //
    for (i = 0; i < 16; i++)
        dacWriteColor(pDev, head, CompatColors[i]);
    
    //--------------------------------------------------------------------
    // The next 16 give various intensities of gray (0,5,8,B,E,11,14,18,
    // 1C,20,24,28,2D,32,38,3F).
    //
    for (i = 0; i < 16; i++)
    {
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i], head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i], head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i], head);
        
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
    }                                                
        
    //--------------------------------------------------------------------
    // The next 216 registers give a variety of colors.
    //
    
    red = 0;
    green = 0;
    blue = 4;

    for (i = 0; i < 9; i++)
    {                       
    
        // I know these could probably be a function, but for now...
        // (this is getting tedious).
        
        // Traverse(blue, red);
        do
        {
            // To loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            red++;                                          
        } while (red < blue);
        
        do
        {
            // From loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            blue--;
        } while (blue);
        
        // Traverse(red, green);
        do
        {
            // To loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            green++;
        } while (green < red);
                         
        do
        {
            // From loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            red--;
        } while (red);
                 
            
        // Traverse(green, blue);
        do
        {
            // To loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            blue++;
        } while (blue < green);
                         
        do
        {
            // From loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            green--;
        } while (green);
    }                
             
    //-----------------------------------------------------------------------
    // The last 8 colors are black.
    //
    //               +---+-- 8 blanks * 3 locations (r/g/b)
    for (i = 0; i < (8 * 3); i++)
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, 0x00, head);
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, 0x00);
}

//
//       dacLoadIdentityDAC - Load the DAC with a gamma ramp
//
static VOID dacLoadIdentityDAC(PHWINFO pDev, U032 head)
{
    U016  i;
    
    // Select the DAC address
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00, head);
                                                  
    for (i = 0; i < 256; i++)
    {           
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)i, head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)i, head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)i, head);
        
    }                                     
}

//
// Program the default video palette
//
static VOID dacLoadPalette
(
    PHWINFO pDev,
    U032    Head,
    U032    PixelDepth
)
{
    U008 i;
    U008 *pal = (U008 *)&(VGATable.PT_ATC); // default packed pixel palette
    volatile U008 scratch8;
    
    scratch8 = REG_RD08(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    
    for (i = 0; i < 20; i++)
    {
        ATR_WR(i, *pal++, Head);               
        
        ////WritePriv08(NV_PRMCIO_ARX, i);      // Select AR
        ////WritePriv08(NV_PRMCIO_ARX, *pal++); // Write color data
    }
                                                
    scratch8 = REG_RD08(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);        // Reset ATC FlipFlop
    
//    DAC_WR08(NV_PRMCIO_ARX, 0x14);   // Select AR14
//    DAC_WR08(NV_PRMCIO_ARX, 0x00);   // Zero it!
    ATR_WR(0x14, 0, Head);                 // Write 0 to AR14
    DAC_REG_WR08(NV_USER_DAC_PIXEL_MASK, 0xFF, Head);      // Write DAC Mask

    ////WritePriv08(NV_PRMCIO_ARX, 0x14);   // Select AR14
    ////WritePriv08(NV_PRMCIO_ARX, 0x00);   // Zero it!
    ////WritePriv08(NV_USER_DAC_PIXEL_MASK, 0xFF);      // Write DAC Mask

#ifdef MACOS9
// We don't write the palette on the Mac; its already been set
//   to their own style of LUT and these default just cause flashing
#else
    switch(PixelDepth)
    {
        case    4:          // 4bpp - Planar -- CAN'T HAPPEN IN WINDOWS DRIVER
            dacLoadColorDACTable(pDev, Head);
            break;

        case    8:          // 8bpp - Packed
            dacLoadColor256DAC(pDev, Head);
            break;

        case    16:         // 16bpp - Packed
        case    15:         // 16bpp - Packed
        case    24:
        case    32:
        default:
            dacLoadIdentityDAC(pDev, Head);
            break;
    }
#endif // ! MACOS9
}

static VOID dacLoadIndexRange(PHWINFO pDev, U032 addr, U008 st_idx, U008 count, U008 *regs)
{
    U016  i;
    U016  wv;
    
    // Program <addr> register from <st_idx> to <st_idx + count>, using data from <regs>
    for (i = 0; i < count; i++)
    {               
        wv = *regs++;
        wv <<= 8;               // Put data in high half
        wv |= st_idx++;         // Get index and increment it
        WriteIndexed(addr, wv);
    }               
}                                  



//
// Program the default sequencer/graphics controller parameters
// PRMVIO for head 2 is accessed by setting CR44.
//
static VOID dacProgramSeq
(
    PHWINFO pDev,
    U032    Head
)
{
    U016  wv;
    
    // Load Sequencer and Misc. Output
    WriteIndexed(NV_PRMVIO_SRX, 0x0100);         // Sync Reset
    
    REG_WR08(NV_PRMVIO_MISC__WRITE, VGATable.PT_Misc);
                                                   
    // Load Sequencers, beginning at SR1, load 4 SR's (SR1-4), from the mode table
    dacLoadIndexRange(pDev, NV_PRMVIO_SRX, 1, sizeof(SEQ), (U008 *)&(VGATable.seq_regs));
                                            
    WriteIndexed(NV_PRMVIO_SRX, 0x0300);         // End Sync Reset
                                  
    // Load GDC's
    // Load GR, beginning at GR0, for all GR's (GR0-8), from the mode table
    dacLoadIndexRange(pDev, NV_PRMVIO_GRX, 0, sizeof(GR), (U008 *)&(VGATable.gr_regs));

    //
    // Common area of OEMSetRegs()
    //
    
    // User select MNP for VPLL, enable CPU access to FB, enable CGA I/O space.
    REG_WR08(NV_PRMVIO_MISC__WRITE, 0x2B);
                                                                  
    wv = 0x01;
    wv <<= 8;
    wv |= 0x01;
    WriteIndexed(NV_PRMVIO_SRX, wv); // Write SR01
    
}

//
// Program the CRTC timing (plus PRAMDAC_GENERAL_CONTROL and MISC OUTPUT sync polarities)
//
static VOID dacProgramCRTC
(
    PHWINFO pDev,
    U032    Head,
    U032    HorizontalVisible,        // in pixels
    U032    HorizontalBlankStart,     // in pixels
    U032    HorizontalRetraceStart,   // in pixels
    U032    HorizontalRetraceEnd,     // in pixels
    U032    HorizontalBlankEnd,       // in pixels
    U032    HorizontalTotal,          // in pixels
    U032    VerticalVisible,          // in lines
    U032    VerticalBlankStart,       // in lines
    U032    VerticalRetraceStart,     // in lines
    U032    VerticalRetraceEnd,       // in lines
    U032    VerticalBlankEnd,         // in lines
    U032    VerticalTotal,            // in lines
    U032    PixelDepth,
    U032    PixelClock,
    U032    HorizontalSyncPolarity,
    U032    VerticalSyncPolarity,
    U032    DoubleScannedMode
)
{
    U032 logicalwidth;
    
    U032 ramDacControl;
    U008 val08;
    U016 LC;

    // Here is how these timing values map to nv registers.
    // 
    // HorizontalTotal[8]           -> cr2D[0]  (# of characters - 5)
    // HorizontalTotal[7:0]         -> cr0[7:0] (# of characters - 5)
    // HorizontalVisible[8]         -> cr2D[1]  (in characters - 1)
    // HorizontalVisible[7:0]       -> cr1[7:0] (in characters - 1)
    // HorizontalBlankStart[8]      -> cr2D[2]  (in characters - 1)
    // HorizontalBlankStart[7:0]    -> cr2[7:0] (in characters - 1)
    // HorizontalBlankEnd[6]        -> cr25[4]
    // HorizontalBlankEnd[5]        -> cr5[7]
    // HorizontalBlankEnd[4:0]      -> cr3[4:0]
    // HorizontalRetraceStart[8]    -> cr2D[3]  (in characters + 1)
    // HorizontalRetraceStart[7:0]  -> cr4[7:0] (in characters + 1)
    // HorizontalRetraceEnd         -> cr5[4:0] (RetraceStart + pulseWidth = value programmed in this register)
    // VerticalVisible[10]          -> cr25[1]
    // VerticalVisible[9]           -> cr7[6]
    // VerticalVisible[8]           -> cr7[1]
    // VerticalVisible[7:0]         -> cr12[7:0]
    // VerticalBlankStart[10]       -> cr25[3]
    // VerticalBlankStart[9]        -> cr9[5]
    // VerticalBlankStart[8]        -> cr7[3]
    // VerticalBlankStart[7:0]      -> cr15[7:0]
    // VerticalRetraceStart[10]     -> cr25[2]
    // VerticalRetraceStart[9]      -> cr7[7]
    // VerticalRetraceStart[8]      -> cr7[2]
    // VerticalRetraceStart[7:0]    -> cr10[7:0]
    // VerticalRetraceEnd           -> cr11[3:0] (RetraceStart + pulseWidth = value programmed in this register)
    // VerticalBlankEnd             -> cr16
    // VerticalTotal[10]            -> cr25[0]
    // VerticalTotal[9]             -> cr7[5]
    // VerticalTotal[8]             -> cr7[0]
    // VerticalTotal[7:0]           -> cr6[7:0] (#of scanlines - 2)
    // PixelDepth                   -> cr13 (logical display width)
    //                              -> NV_PRAMDAC_GENERAL_CONTROL
    //                              -> cr28[1:0]
    // PixelClock                   -> NV_PRAMDAC_VPLL_COEFF
    // HorizontalSyncPolarity       -> NV_PRMVIO_MISC__WRITE[6]
    // VerticalSyncPolarity         -> NV_PRMVIO_MISC__WRITE[7]
    // DoubleScannedMode            -> cr9[7]
    //

    // Program up the basic registers first
    //
    
    //
    // Although the VGA spec is not clear on this, there is a single implicit line delay in the VRS and VRE
    // signals, so preadjust these values.
    //
    VerticalRetraceStart--;
    VerticalRetraceEnd--;
    
    // Line compare register is used to split the screen in half. We don't support this feature.
    // So the Line Compare register value is always 0x3ff.
    LC = 0x3ff;

    if (DoubleScannedMode)
    {
        // The verticalVisible and verticalBlankStart need to be doubled. 
        // The rest of the vertical timing modes are already doubled in the table.
        VerticalVisible *= 2;
        VerticalBlankStart *= 2;
    }

    //
    // CR0 (Horizontal Total) 
    //  Total number of horizontal characters in a scan line - 5
    //  Maximum horizontal resolution is 260 * 8 * (0.8), where (0.8) is visible %
    //
    CRTC_WR(NV_CIO_CR_HDT_INDEX, (U008)(HorizontalTotal >> 3) - 5, Head);
    
    //
    // CR1 (Horizontal Display End)
    //  Total number of displayed characters in a scan line - 1
    //
    CRTC_WR(NV_CIO_CR_HDE_INDEX, (U008)(HorizontalVisible >> 3) - 1, Head);
                   
    //
    // CR2 (Horizontal Blanking Start)
    //  Location where the horizontal blanking will start (in characters)
    //
    CRTC_WR(NV_CIO_CR_HBS_INDEX, (U008)((HorizontalBlankStart >> 3) - 1), Head);                   
        
    //
    // CR3 (Horizontal Blanking End)
    //  [7:7] CR (must be 1)
    //  [6:5] Display skew control (should be 0)
    //  [4:0] least significant 5 bits of Horizontal blanking end value (in characters).
    //
    CRTC_WR(NV_CIO_CR_HBE_INDEX, (U008)(((HorizontalBlankEnd >> 3) - 1) & 0x1F) | BIT(7), Head);
                   
    //
    // CR4 (Horizontal Retrace Start)
    //  Character position where the horizontal Retrace becomes active
    //
    CRTC_WR(NV_CIO_CR_HRS_INDEX, (U008)(HorizontalRetraceStart >> 3) + 1, Head);
                   
    //
    // CR5 (Horizontal Retrace End)
    //  [7:7] Bit6 of HBE (CR3)
    //  [6:5] Display skew control (should be 0)
    //  [4:0] Location of the end of the horizontal retrace period (in characters)
    //
    CRTC_WR(NV_CIO_CR_HRE_INDEX, ((U008)(((HorizontalRetraceEnd >> 3) + 1) & 0x1f))
                               | ((((HorizontalBlankEnd >> 3) - 1) & BIT(5)) ? BIT(7) : 0), Head);

    //
    // CR6 (Vertical Total)
    //  Total number of vertical scan lines on the monitor - 2
    //
    CRTC_WR(NV_CIO_CR_VDT_INDEX, (U008)((VerticalTotal - 2) & 0xFF), Head);
                   
    //
    // CR7 (Overflow Register)
    //  [7:7] Bit9 of VRS (CR10)
    //  [6:6] Bit9 of VDE (CR12)
    //  [5:5] Bit9 of VTR (CR6)
    //  [4:4] Bit8 of LC (CR18) 
    //  [3:3] Bit8 of VBS (CR15)
    //  [2:2] Bit8 of VRS (CR10)
    //  [1:1] Bit8 of VDE (CR12)
    //  [0:0] Bit8 of VTR (CR6)
    //
    CRTC_WR(NV_CIO_CR_OVL_INDEX, ((VerticalRetraceStart & BIT(9))     ? BIT(7) : 0x00)
                               | (((VerticalVisible - 1) & BIT(9))    ? BIT(6) : 0x00) 
                               | (((VerticalTotal - 2) & BIT(9))      ? BIT(5) : 0x00)
                               | ((LC & BIT(8))                       ? BIT(4) : 0x00)
                               | (((VerticalBlankStart - 1) & BIT(8)) ? BIT(3) : 0x00)
                               | ((VerticalRetraceStart & BIT(8))     ? BIT(2) : 0x00)
                               | (((VerticalVisible - 1) & BIT(8))    ? BIT(1) : 0x00)
                               | (((VerticalTotal - 2) & BIT(8))      ? BIT(0) : 0x00), Head);
                   
    //
    // CR8 (Screen A preset row scan)
    //  Should be set to 0 for us.
    CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0, Head);

    //
    // CR9 (Character Cell Height register)
    //  [7:7] Scan double mode
    //  [6:6] Bit9 of LC (CR18) 
    //  [5:5] Bit9 of VBS (CR15)
    //  [4:0] Scan lines per character row - 1
    //
    CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, ((DoubleScannedMode)                 ? BIT(7) : 0x00)
                                   | ((LC & BIT(9))                       ? BIT(6) : 0x00)
                                   | (((VerticalBlankStart - 1) & BIT(9)) ? BIT(5) : 0x00), Head);
                 
    //
    // CR0C/CR0D (Start Address)
    //
    CRTC_WR(NV_CIO_CR_SA_HI_INDEX, 0, Head);                 
    CRTC_WR(NV_CIO_CR_SA_LO_INDEX, 0, Head);                 
                 
    //
    // CR10 (Vertical Retrace Start)
    //  Line position of the vertical Retrace start
    //
    CRTC_WR(NV_CIO_CR_VRS_INDEX, (U008)(VerticalRetraceStart & 0xFF), Head);
                   
    //
    // CR11 (Vertical Retrace End)
    //  [7:7] WriteProtect for CR0-7
    //  [6:6] Reserved (Bandwidth)
    //  [5:5] Vertical Interrupts (0)
    //  [4:4] Clear Vertical Interrupt (0)
    //  [3:0] Vertical Retrace End Width
    //
    CRTC_WR(NV_CIO_CR_VRE_INDEX, (U008)(VerticalRetraceEnd & 0x0f), Head); 
                               
    //
    // CR12 (Vertical Display End)
    //  Total number of displayed lines - 1
    //
    CRTC_WR(NV_CIO_CR_VDE_INDEX, (U008)((VerticalVisible - 1) & 0xFF), Head);
    
    //
    // CR13 (Logical Display Width)
    //  Display Pitch
    //  The value written to CR13/CR19 is the number 8-byte chunks
    //
    logicalwidth = pDev->Dac.DisplayPitch >> 3;
    CRTC_WR(NV_CIO_CR_OFFSET_INDEX, logicalwidth & 0xFF, Head);
    
    //
    // CR14 (Underline Location)
    //  Double Word mode
    //  Bit 6 is set in some VGA modes to change CRTC addressing
    //
    CRTC_WR(NV_CIO_CR_ULINE_INDEX, 0, Head);
    
    //
    // CR14 (Underline Location)
    //  Double Word mode
    //  Bit 6 is set in some VGA modes to change CRTC addressing into framebuffer
    //
    CRTC_WR(NV_CIO_CR_ULINE_INDEX, 0, Head);
    
    //
    // CR15 (Vertical Blank Start)
    //  Scan line value where the vertical blanking begins
    //
    CRTC_WR(NV_CIO_CR_VBS_INDEX, (U008)((VerticalBlankStart - 1) & 0xFF), Head);
    
    //
    // CR16 (Vertical Blank End)
    //  Scan line value where the vertical blanking Ends
    //
    CRTC_WR(NV_CIO_CR_VBE_INDEX, (U008)((VerticalBlankEnd - 1) & 0xFF), Head);

    //
    // CR17 (Mode register)
    //  bit 7 - retrace enable, bits 1,0 - memory addressing
    CRTC_RD(NV_CIO_CR_MODE_INDEX, val08, Head);
    CRTC_WR(NV_CIO_CR_MODE_INDEX, val08 | BIT(7) | BIT(1) | BIT(0), Head);

    //
    // CR18 (Line Compare Register)
    //  Bits 7:0 of the line compare value
    //  This is useful only when we want to split the screen. We just program this to 0x3ff
    //
    CRTC_WR(NV_CIO_CR_LCOMP_INDEX, (U008)(LC & 0xFF), Head);

    //
    // CR19 (Repaint control register 0)
    //  [7:5] Bits 10:8 of CRTC Offset register (CR13)
    //
    CRTC_WR(NV_CIO_CRE_RPC0_INDEX, (U008)(((logicalwidth & 0x700) >> 8) << 5), Head);

    //
    // CR1a (Repaint control register 1)
    //  [2] large screen bit. 
    //  NOTE: The manual says bit 2 should be set to 1 for modes < 1280x1024 and 
    //        0 for modes >= 1280x1024. However, that is not correct according to Peter Tong.
    //        It should be set to 0 for all non-vga modes (CR28).
    //          Safer to follow the original meaning of this bit.
    //  The rest of the bits are constant for all modes.
    //
    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, ((VerticalVisible < 1024) && (HorizontalVisible < 1280)) ? 0x3c : 0x38, Head);

    //
    // CR1c (Enhancement Register)
    //  This is a constant 0x1c for us.
    if (IsNV11(pDev)) {
        CRTC_WR(NV_CIO_CRE_ENH_INDEX, 0x3c, Head);
    } else {
        CRTC_WR(NV_CIO_CRE_ENH_INDEX, 0x1c, Head);
    }

    // Cr25 (Overflow register)
    //  [5:5] Bit 11 of CRTC offset register (this is 0)
    //  [4:4] Bit 6 of Horizontal Blanking End 
    //  [3:3] Bit 10 of Vertical Blank Start
    //  [2:2] Bit 10 of Vertical Retrace Start
    //  [1:1] Bit 10 of Vertical Display End
    //  [0:0] Bit 10 of Vertical Total
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, ((((HorizontalBlankEnd >> 3) - 1) & BIT(6)) ? BIT(4) : 0x00)
                                | (((VerticalBlankStart - 1) & BIT(10))       ? BIT(3) : 0x00)
                                | ((VerticalRetraceStart & BIT(10))           ? BIT(2) : 0x00)
                                | (((VerticalVisible - 1) & BIT(10))          ? BIT(1) : 0x00) 
                                | (((VerticalTotal - 2) & BIT(10))            ? BIT(0) : 0x00), Head);

    // 
    // CR28 (Pixel Format Register)
    //  [1:0] Pixel depth encoded as:
    //        0 - VGA
    //        1 - 8bpp
    //        2 - 16bpp
    //        3 - 32bpp

    // Also set PRAMDAC_GENERAL_CONTROL register. ALT_MODE field depends on the pixel depth. The rest
    // of the fields are the same for all pixel depths.
    
    ramDacControl = DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIXMIX,      _ON) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _VGA_STATE,   _SEL) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BLK_PEDSTL,  _OFF) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _TERMINATION, _37OHM) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC,         _8BITS) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _DAC_SLEEP,   _DIS) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PALETTE_CLK, _EN);
        
    switch (PixelDepth)
    {
        case 8:
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _NOTSEL);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_8BPP, Head);    
            break;                
        
        case 15:
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _15);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_16BPP, Head);    
            break;                
        
        case 16:
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _16);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_16BPP, Head);    
            break;                
        
        case 24:
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _24);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_32BPP, Head);    
            break;                
        
        case 32:        
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _30);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_32BPP, Head);    
            break;                
    } // switch on pixel depth       

    DAC_REG_WR32(NV_PRAMDAC_GENERAL_CONTROL, ramDacControl, Head);

    // 
    // cr2D (Horizontal Extra Bits Register)
    //  [5] Bit 23 of start address field (This is 0 for us)
    //  [4] Bit 8 of interlace half field start (This is 0 for us)
    //  [3] Bit 8 of Horizontal Retrace Start
    //  [2] Bit 8 of Horizontal Blank Start
    //  [1] Bit 8 of Horizontal Display End
    //  [0] Bit 8 of Horizontal Total
    CRTC_WR(NV_CIO_CRE_HEB__INDEX, ((((HorizontalRetraceStart >> 3) + 1) & BIT(8)) ? BIT(3) : 0x00)
                                 | ((((HorizontalBlankStart >> 3) - 1) & BIT(8))   ? BIT(2) : 0x00)
                                 | ((((HorizontalVisible >> 3) - 1) & BIT(8)) ? BIT(1) : 0x00) 
                                 | ((((HorizontalTotal >> 3) - 5) & BIT(8))  ? BIT(0) : 0x00), Head);

    // 0x3c2 (Misc output register)
    // Program the sync polarities.
    // [7] Vertical Sync Polarity:   0 - active High, 1 - active low 
    // [6] Horizontal Sync Polarity: 0 - active High, 1 - active low 
    val08 = (REG_RD08(NV_PRMVIO_MISC__READ) & 0x3f); // just take bits 5:0
    val08 |= (HorizontalSyncPolarity) ? BIT(6) : 0;
    val08 |= (VerticalSyncPolarity)   ? BIT(7) : 0;
    REG_WR08(NV_PRMVIO_MISC__WRITE, val08);
} // end of dacProgramCustomCRTC


// This is the entry point for non-multi-head-aware modeset methods.
RM_STATUS dacSetMode
(
    PHWINFO pDev,
    U032 head
)
{
    VIDEO_LUT_CURSOR_DAC_OBJECT DacObj;
    // Copy the parameters from the pDev into a local Dac object and call new multi-head aware function
    // (The Dac[] array is for multiple buffers, not multiple Dacs)
    DacObj.HalObject.Dac[0].VisibleImageWidth           = pDev->Dac.HorizontalVisible;
    DacObj.HalObject.Dac[0].HorizontalBlankStart        = pDev->Dac.HorizontalBlankStart;
    DacObj.HalObject.Dac[0].HorizontalSyncStart         = pDev->Dac.HorizontalRetraceStart;
    DacObj.HalObject.Dac[0].HorizontalSyncWidth         = pDev->Dac.HorizontalRetraceEnd - pDev->Dac.HorizontalRetraceStart;
    DacObj.HalObject.Dac[0].HorizontalBlankWidth        = pDev->Dac.HorizontalBlankEnd - pDev->Dac.HorizontalBlankStart;
    DacObj.HalObject.Dac[0].TotalWidth                  = pDev->Dac.HorizontalTotal;
    DacObj.HalObject.Dac[0].VisibleImageHeight          = pDev->Dac.VerticalVisible;
    DacObj.HalObject.Dac[0].VerticalBlankStart          = pDev->Dac.VerticalBlankStart;
    DacObj.HalObject.Dac[0].VerticalSyncStart           = pDev->Dac.VerticalRetraceStart;
    DacObj.HalObject.Dac[0].VerticalSyncHeight          = pDev->Dac.VerticalRetraceEnd - pDev->Dac.VerticalRetraceStart;
    DacObj.HalObject.Dac[0].VerticalBlankHeight         = pDev->Dac.VerticalBlankEnd - pDev->Dac.VerticalBlankStart;
    DacObj.HalObject.Dac[0].TotalHeight                 = pDev->Dac.VerticalTotal;
    DacObj.HalObject.Dac[0].PixelDepth                  = pDev->Dac.PixelDepth;
    DacObj.HalObject.Dac[0].PixelClock                  = pDev->Dac.HalInfo.PixelClock;
    DacObj.HalObject.Dac[0].Format.HorizontalSyncPolarity    = pDev->Dac.HorizontalSyncPolarity;
    DacObj.HalObject.Dac[0].Format.VerticalSyncPolarity      = pDev->Dac.VerticalSyncPolarity;
    DacObj.HalObject.Dac[0].Format.DoubleScanMode       = pDev->Dac.DoubleScannedMode;
    DacObj.HalObject.Head = head;
    DacObj.DisplayType = GETDISPLAYTYPE(pDev, head);
    return dacSetModeMulti(pDev, &DacObj);   // call modeset for head 0
}

/***************************** exported functions **********************************/

// Dac HSYNC & VSYNC control
//
// The Mac needs to be able to individually control these for its power management
//

// XXX couldn't find a #define for these 2 bits...
#define HSYNCBIT   BIT(7)
#define VSYNCBIT   BIT(6)

RM_STATUS dacGetSyncState(
    PHWINFO pDev,
    U032    Head,
    U032   *pHsync,
    U032   *pVsync
)
{
    U008 data08;
    U008 lock;
    
    lock = UnlockCRTC(pDev, Head);
    
    if(GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
	   	
	   	if(dacIsFlatPanelOn(pDev,Head))
	   	{
	   		//if there was a bit 4 present, it implies *enabled*
	   		*pHsync=1;
	   		*pVsync=1;
	   	}
	   	else
	   	{
	   		*pHsync=0;
	   		*pVsync=0;
	   	}
	}
	else
	{
    
    	CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
    	*pHsync = ! (data08 & HSYNCBIT);
    	*pVsync = ! (data08 & VSYNCBIT);
    }
    
    RestoreLock(pDev, Head, lock);
    	
    return RM_OK;
}

RM_STATUS dacSetSyncState(
    PHWINFO pDev,
    U032    Head,
    U032    Hsync,
    U032    Vsync
)
{
    U008 data08;
    U008 lock;
    
    #ifdef DEBUG
    extern int cur_debuglevel;
    int old_debuglevel;
    
    old_debuglevel=cur_debuglevel;
    cur_debuglevel=DEBUGLEVEL_TRACEINFO;
    #endif

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"SetSyncState on Head");
    DBG_PRINT_VALUE(DEBUGLEVEL_TRACEINFO,Head);
    
    #ifdef DEBUG
    if((!Hsync)||(!Vsync))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"Shutoff of sync requested.");
    }
    #endif
	
	lock = UnlockCRTC(pDev, Head);
	
    if(GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
	   	if((!Hsync)||(!Vsync))
	   	{
	   	    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"Specifically the flatpanel.");
	   	    
      		//power off flat panel
	   		dacPowerOffMobilePanel(pDev,Head);
	   		
	   		//kill PWM
	   		dacZeroPWMController(pDev);
	   	}
	   	else
	   	{
	   		//power on the flat panel
	   		dacPowerOnMobilePanel(pDev,Head);
	   		
	   		//restore PWM
	   		dacSetPWMController(pDev);

	   	}
	}
	else
	{
		
	    
		// read current value
	    CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);

	    // clear both
	    data08 &= ~(HSYNCBIT | VSYNCBIT);

	    // set to 1 if no sync
	    if ( ! Hsync)
	        data08 |= HSYNCBIT;
	    if ( ! Vsync)
	        data08 |= VSYNCBIT;

	    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08, Head);
	}
	
	RestoreLock(pDev, Head, lock);
	
#ifdef DEBUG
 	cur_debuglevel=old_debuglevel;
#endif
	
    return RM_OK;
}
#undef HSYNCBIT
#undef VSYNCBIT


//
// Program the dac video parameters
//
//  Note that the video parameters have already been deposited in pDev.  This allows us to go
//  through multiple load/unload pairs (like DOS boxes) while still maintaining the original
//  video mode parameters.  It also makes it easier for an applet (like the control panel)
//  to tweak one value, then force an unload/load to make it affective.
//
RM_STATUS dacSetModeMulti(
    PHWINFO pDev,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac
)
{
    RM_STATUS status = RM_OK;
    U016      data,save_sr1 = 0;
    U032      data32;
    U008      shadow,data08, i, cr3Bmod;
    volatile U032 scratch;
    
    // Extract parameters from the VIDEO_LUT_CURSOR_DAC object.
    U032      HorizontalVisible         = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    U032      HorizontalBlankStart      = pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart;
    U032      HorizontalRetraceStart    = pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart;
    U032      HorizontalRetraceEnd      = (pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart +
                                           pVidLutCurDac->HalObject.Dac[0].HorizontalSyncWidth);
    U032      HorizontalBlankEnd        = (pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart +
                                           pVidLutCurDac->HalObject.Dac[0].HorizontalBlankWidth);
    U032      HorizontalTotal           = pVidLutCurDac->HalObject.Dac[0].TotalWidth;
    U032      VerticalVisible           = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
    U032      VerticalBlankStart        = pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart;
    U032      VerticalRetraceStart      = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart;
    U032      VerticalRetraceEnd        = (pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart +
                                           pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight);
    U032      VerticalBlankEnd          = (pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart +
                                           pVidLutCurDac->HalObject.Dac[0].VerticalBlankHeight);
    U032      VerticalTotal             = pVidLutCurDac->HalObject.Dac[0].TotalHeight;
    U032      PixelDepth                = pVidLutCurDac->HalObject.Dac[0].PixelDepth;
    U032      PixelClock                = pVidLutCurDac->HalObject.Dac[0].PixelClock;
    U032      HorizontalSyncPolarity    = pVidLutCurDac->HalObject.Dac[0].Format.HorizontalSyncPolarity;
    U032      VerticalSyncPolarity      = pVidLutCurDac->HalObject.Dac[0].Format.VerticalSyncPolarity;
    U032      DoubleScannedMode         = pVidLutCurDac->HalObject.Dac[0].Format.DoubleScanMode;
    U032      Head                      = pVidLutCurDac->HalObject.Head;
    
    //
    // Validate this mode is valid for the amount of framebuffer present
    // in this specific device.
    // Watch out for pixel depth of 15; add 1 to ensure it divides by 8 and give correct #bytes
    if ((HorizontalVisible * VerticalVisible * ((PixelDepth+1) >> 3)) > 
        pDev->Framebuffer.HalInfo.RamSize)
            return RM_ERROR;

    //
    // There is a bug in NV hardware where the hardware cursor will not clip correctly
    // if a border is defined in the display timings (blank start != visible end).  
    // Borders are only defined in two specific DMT modes.
    //
    // To fix this, set the blank starts to match the visible totals and remove the 
    // implicit borders.
    //
    // Remove this code when the hardware gets fixed.  Since this bug has been in the 
    // hardware since 1994, don't expect a fix soon.
    //
    HorizontalBlankStart = HorizontalVisible;
    HorizontalBlankEnd   = HorizontalTotal;
    VerticalBlankStart   = VerticalVisible;
    VerticalBlankEnd     = VerticalTotal;

    //
    // Set display type.  We can't rely on the caller to actually
    // have specified an allowable valid type.  As one last check,
    // consult the allowed mask.  Don't reset the DisplayType field,
    // but continue on with the modeset just to be safe...
    //
    if ((GETCRTCHALINFO(pDev, Head, DisplayTypesAllowed) & DISPLAYTYPEBIT(pVidLutCurDac->DisplayType)) != 0)
        SETDISPLAYTYPE(pDev, Head, pVidLutCurDac->DisplayType);

    //
    // Now set monitor type.
    //
    switch (pVidLutCurDac->DisplayType)
    {
        case DISPLAY_TYPE_MONITOR:
            SETMONITORTYPE(pDev, Head, MONITOR_TYPE_VGA);
            break;
        case DISPLAY_TYPE_TV:
            switch (pVidLutCurDac->TVStandard)
            {
                case NTSC_M:
                case NTSC_J:
                    SETMONITORTYPE(pDev, Head, MONITOR_TYPE_NTSC);
                    break;
                case PAL_A:
                case PAL_M:
                case PAL_N:
                case PAL_NC:
                    SETMONITORTYPE(pDev, Head, MONITOR_TYPE_PAL);
                    break;
            }
            break;
        case DISPLAY_TYPE_DUALSURFACE:
            break;
        case DISPLAY_TYPE_FLAT_PANEL:        
            SETMONITORTYPE(pDev, Head, MONITOR_TYPE_FLAT_PANEL); 
            break;
        default:
            break;
    }

    //
    // Set TV standard.
    //
    pDev->Dac.TVStandard = pVidLutCurDac->TVStandard;

    //
    // We are about to set the new mode. Do any os specific actions necessary at this point.
    // This includes any registry overrides that may affect the new mode.
    // Specifically, determine what type of display device (CRT, FP, or TV), and if TV,
    // what format, and if FP, parse EDID to get timings.
    osPreModeSet(pDev, Head);

    DBG_PRINT_STRING (DEBUGLEVEL_TRACEINFO, "Setting mode \n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "    H Res:", pDev->Framebuffer.HalInfo.HorizDisplayWidth);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "    V Res:", pDev->Framebuffer.HalInfo.VertDisplayWidth);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "Bit Depth:", PixelDepth);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "  Refresh:", pDev->Framebuffer.HalInfo.RefreshRate);

    // Set the requested refresh rate
    pVidLutCurDac->RefreshRate = (PixelClock * 10000) /
                                 (HorizontalTotal * VerticalTotal);

    //
    // Update tiling configuration.
    //
    nvHalFbControl(pDev, FB_CONTROL_TILING_CONFIGURE);

    //
    // Check for a change to nvclk/mclk values.
    //
    // Since we don't go through a STATE_LOAD as part of a mode switch, this is
    // where we'll program these clocks. The values are only interesting to the
    // arbitration code below, so anytime before that should be good.
    //
    // Since we also haven't done a STATE_UNLOAD, we're assuming this SW method
    // in the host FIFO has allowed enough of the chip to idle, so we can change
    // the clocks. In limited testing, this seems to work.
    //
    if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_NVPLL)
    {
        // Program NVCLK
        status = dacProgramNVClk(pDev);
        pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_NVPLL;
    }

    if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_MPLL)
    {
        // Program MCLK
        status = dacProgramMClk(pDev);
        pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_MPLL;
    }

    //
    // Enable full CRTC access
    //           
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x57, Head);

    // If this is for CRTC2, set CRTC access bit and PRAMDAC address
    // This access bit controls accesses to Sequencer and Graphics Controller (C03xx).
    // CRTC and Attribute Controller must be accessed at different addresses for each head
    // (6103xx/6033xx), since there is only one bus.
    if (IsNV11(pDev))
    {
        EnableHead(pDev, Head);
        if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
        {
            AssocTV(pDev, Head);
            AssocDDC(pDev, Head);
        }
        if (Head == CRTC2)
        {
            REG_WR08(NV_PRMVIO_VSE2, 1);                    // enable VGA subsystem
            data08 = REG_RD08(NV_PRMVIO_MISC__READ);
            REG_WR08(NV_PRMVIO_MISC__WRITE, data08 | 1);    // enable CGA I/O space
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x57, Head);      // unlock head 2
        }            

        //
        // If there's been no modeset on the other head, disable the sequencer
        // allowing this head more FB bandwidth. When a modeset does occur,
        // dacProgramSeq will reset SR1 to the proper value.
        //
        if (pDev->Dac.CrtcInfo[Head^1].pVidLutCurDac == NULL)
            dacDisableImage(pDev, Head^1);
    }

    // Disable flat panel syncs
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _DISABLE, Head); // 
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _DISABLE, Head); // 

    CRTC_RD(NV_CIO_CR_VRE_INDEX, data08, Head);
    CRTC_WR(NV_CIO_CR_VRE_INDEX, data08 & ~0x80, Head);    // unlock CR0-7
    
    CRTC_RD(0x21, shadow, Head);      // read shadow lock
    data08 = shadow | 0xfa;     // enable HDE, VDE, and 8/9 dot chars too, for NV5.
    CRTC_WR(0x21, data08, Head);
      
    // Set H and V retrace start to a large value to prevent possible lock-up.
    // This is because if the CRTC is slaved to an external device (the TV encoder),
    // it will stall waiting for retrace start to sync up with the external clock. 
    // When we switch from TV to CRT, we may get stuck in this stall. Setting retrace 
    // start to a large value guarantees this won't happen.
    CRTC_WR(NV_CIO_CR_HRS_INDEX, 0xff, Head);
    CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xff, Head);

    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        U008 i;

        // bug workaround--disable scanline doubling and then shadow it. This allows writes to CR09 to affect the CRTC,
        //   but not the flat panel controller (else the flat panel controller may quadruple the scanline count).
        CRTC_RD(NV_CIO_CR_CELL_HT_INDEX, data, Head);         // read scanline double
        CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, (data &= ~0x80), Head);   // clear scanline double bit

        // Wait one vsync before shadowing the scanline double bit
        // Use a time-out in case the bit is stuck.
        for (i=0; i<17; i++)    // max time it can take is 16.7 ms (actually less)
        {
            if (DAC_REG_RD32(NV_PCRTC_RASTER, Head) & DRF_DEF(_PCRTC, _RASTER, _VERT_BLANK, _ACTIVE))
                break;      
            tmrDelay(pDev, 1000000);    // wait 1 ms
        }
        for (i=0; i<17; i++)    // max time it can take is 16.7 ms
        {
            if (!(DAC_REG_RD32(NV_PCRTC_RASTER, Head) & DRF_DEF(_PCRTC, _RASTER, _VERT_BLANK, _ACTIVE)))
                break;
            tmrDelay(pDev, 1000000);    // wait 1 ms
        }
    
        // shadow = CR21
        shadow &= ~0x40;  // shadow the scanline double bit
        CRTC_WR(0x21, (shadow |= 0xA8), Head); // allow horiz & vert write-thru

        // de-couple vertical sync from flat panel while setting mode
        data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head); 
        data32 |= (NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX << 16);   // set VCLK bits
        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);

        // power off the panel until the mode is all setup
        if (pDev->Power.MobileOperation)
        {
            dacPowerOffMobilePanel(pDev, Head);
        }
    }
    else
    {
        //
        // We aren't driving DFP on this head, so we need to make sure to flush the overlay
        // clocking in the chip so it's not accidently left pointing at the DFP clocks.
        //
        // If we're not careful, the fp_newline signal inside the chip may still be driven
        // from fpclk, even though we aren't actively using fpclk.  This will result in
        // the overlay video engine not sending output data
        //
        // Here's the HW description of the bug
        //
        // This is a hardware bug that exists in NV10 and subsequent designs: 
        //  *  the video scaler relies on an a signal from the flat panel timing logic, fp_newline
        //  *  when the CRTC is not slaved to the FP, fp_newline should remain 1, however, this is 
        //     not always true
        //  *  if the FP timing has been previously programmed, and the CRTC is un-slaved from the 
        //     FP timing, fp_newline will continue to toggle as if the CRTC were still slaved to the FP.
        //  * also,  if the FPCLK is powered down at a moment when fp_newline is 0, fp_newline will 
        //    remain 0 until FPCLK is powered back up
        //  * fp_newline can be made to remain 1 by doing these steps before unslaving the CRTC from 
        //    the FP timing
        //    1.) disable vertical FP scaling
        //    2.) wait until the next frame
        //    3.) FPCLK and FP syncs must be enabled during this time (steps 1 and 2), i.e., 
        //        NV_PRAMDAC_FP_TG_CONTROL bits 1 and 5 must both be 0.
        //    4.) un-slave CRTC to FP timing
        //    5.) FPCLK and FP H- and V- syncs may now be disabled if desired
        // 
        U032 savedPowerState;

        // Temporarily turn on the FPCLK
        savedPowerState = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);

        // Set the fp to centered with valid sync's 
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _NEG, Head);
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _NEG, Head);
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER, Head);

        tmrDelay(pDev, 35000000);   // this sucks; wait for one vsync to toggle, but
                                    // since the fpclk may not have valid timings
                                    // now, just wait manually for two

        // Turn FPCLK back off again
        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, savedPowerState, Head);
    }

    // Program the TV encoder if any.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
    {
        status = dacSetupTVEncoder(pDev, Head); 
        if (status)
        {
            switch (status)
            {
                case ERR_I2C_MODE:
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Can't program the TV encoder for this mode.\n");
                    break;
                case ERR_I2C_COMM:
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: I2C error programming mode\n");
                    break;
                case ERR_I2C_UNKNOWN:
                    DBG_PRINT_STRING (DEBUGLEVEL_ERRORS, "NVRM: No TV Encoder detected\n");
                    break;
            }                
            if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)      // if flat panel, leave it that way.
                SETDISPLAYTYPE(pDev, Head, DISPLAY_TYPE_MONITOR);  // No encoder set up for monitor
        }
    }

    //
    // Disable the visible screen
    //
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);       // Reset ATC FlipFlop
    REG_WR08(NV_PRMCIO_ARX, 0x00);               // Turn off screen at AR
    ////WritePriv08(NV_PRMCIO_ARX, 0x00);        // Turn off screen at AR
        
    //
    // FullCPUOn()
    //
    data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    data |= 0x2000;                             // Full Bandwidth bit ON
    WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit

    //
    // Set the sequencer & graphics controller values that are common for all packed-pixel
    // graphics modes.
    //            
    dacProgramSeq(pDev, Head);
    //
    // Program the CRTC & SR values for this particular mode.
    //
    dacProgramCRTC(pDev, Head,
                         HorizontalVisible,
                         HorizontalBlankStart,
                         HorizontalRetraceStart,
                         HorizontalRetraceEnd,
                         HorizontalBlankEnd,
                         HorizontalTotal,
                         VerticalVisible,
                         VerticalBlankStart,
                         VerticalRetraceStart,
                         VerticalRetraceEnd,
                         VerticalBlankEnd,
                         VerticalTotal,
                         PixelDepth,
                         PixelClock,
                         HorizontalSyncPolarity,
                         VerticalSyncPolarity,
                         DoubleScannedMode);

    // Set the flat panel timing registers (PRAMDAC_FP).
    // We must program the DAC before we load the palette, because the DAC is driving the 
    // VGA clock.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        U032 fpMode, fpMaxX, fpMaxY;
        BOOL fpConnect;
        BOOL fpNative;
   
// TO DO: do not use the registry for NT
#ifndef NTRM
        status = dacGetFlatPanelInfo(pDev, Head, &fpMode, &fpMaxX, &fpMaxY, &fpConnect, &fpNative,
                                     TRUE /* from registry */);
#else
        status = dacGetFlatPanelInfo
        (
            pDev, 
            Head, 
            &fpMode, 
            &fpMaxX, 
            &fpMaxY, 
            &fpConnect, 
            &fpNative,
            FALSE           /* NOT from registry for NT */
        );
#endif

        // if Native mode requested, make sure this monitor supports it
        if ((fpMode == NV_CFGEX_GET_FLATPANEL_INFO_NATIVE) && (!fpNative))
            fpMode = NV_CFGEX_GET_FLATPANEL_INFO_SCALED;    // no, then do scaled
        status = dacSetFlatPanelMode(pDev, Head, pVidLutCurDac, fpMode, FALSE /* don't commit changes */);
    }
    else
    {
        //
        // If we aren't driving the panel through this head, or
        // (or the other head) turn it off.
        // 
        if (pDev->Power.MobileOperation)
        {
            if ((pDev->Dac.CrtcInfo[Head^1].pVidLutCurDac == NULL) ||
                (((PVIDEO_LUT_CURSOR_DAC_OBJECT)(pDev->Dac.CrtcInfo[Head^1].pVidLutCurDac))->DisplayType != DISPLAY_TYPE_FLAT_PANEL))
            {
                dacPowerOffMobilePanel(pDev, Head);
            }
        }
    }

    // If using an analog CRT with the external DAC, program the PRAMDAC_FP register to generate timing
    if ((GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR) && (Head == 1))
    {
        U032 fpMode, fpMaxX, fpMaxY;
        BOOL fpConnect;
        BOOL fpNative;
   
        status = dacGetFlatPanelInfo(pDev, Head, &fpMode, &fpMaxX, &fpMaxY, &fpConnect, &fpNative, FALSE ); /* NOT from registry */
        status = dacSetFlatPanelMode(pDev, Head, pVidLutCurDac, NV_CFGEX_GET_FLATPANEL_INFO_NATIVE, FALSE);
        dacAdjustCRTCForFlatPanel(pDev, Head, pVidLutCurDac);
    }
    
    // This code is necessary to fix a bug found where the memory controller would hang if a delay
    // was NOT inserted before turning on the display after programming the pixel clock PLL's.
    // Only required for SMA mode.
    if(IsNV0A(pDev)){
        if(pDev->Framebuffer.HalInfo.RamType == BUFFER_CRUSH_UMA){
            save_sr1 = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
            data = save_sr1;
            data |= 0x2000;                             // Full Bandwidth bit ON
            WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit
        }
    }

    //
    // Program the new VPLL clock rate
    // If this is a flat panel, or flat panel engine is driving the analog monitor, we should not change the clocks
    if ((GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_FLAT_PANEL) && (Head != 1))
    {
        dacProgramPClk(pDev, Head, PixelClock);
    }

    //
    // Native modes require a divide-by-2 clock ratio
    //                                    
    if (Head == 0) 
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK_RATIO, _DB2);
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK_TV, _NONE);   // assume no TV for now
    }
    else
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK2_RATIO, _DB2);
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK2_TV, _NONE);  // assume no TV for now
    }
    pDev->Framebuffer.CursorAdjust = 0;   // default to no adjustment of cursor position
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
    {
        dacAdjustCRTCForTV(pDev, Head);              // CRTC tweaks for TV
    }
    else    
    {
        // Not TV, if flat panel, we may need to adjust CRTC's
        if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
            dacAdjustCRTCForFlatPanel(pDev, Head, pVidLutCurDac);
        if (Head == 0) 
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V1SOURCE, _PROG);
        }
        else
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V2SOURCE, _PROG);
        }
    }        
    
    //
    // Load default palette values. Do this after clock is running, else we hang.
    //
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        // Set NEWPIX before programming palette to prevent hang on some systems (i.e. VIA).
        // This prevents the PCLK from being held off. Stopping PCLK is done to allow the pixel
        // stream to sync with the flat panel controller, but is also causes the palette to stop 
        // responding, causing bus retries. The VIA chipset doesn't like a lot of bus retries, 
        // and may eventually hang the bus.
        data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);           
        data32 |= (NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX << 16);  // set NEWPIX
        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);
    }

    dacLoadPalette(pDev, Head, PixelDepth);

    // Restore normal clocking (flat panel can hold off)
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);           
        data32 &= ~(NV_PRAMDAC_FP_DEBUG_0_TEST_BOTH << 16); // set to normal mode
        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);
    }

    if(!IsNV0A(pDev)){
        //
        // FullCpuOff()
        //
        data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
        data &= 0xDFFF;                             // Full Bandwidth bit OFF
        WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit            
    }else{
        if(pDev->Framebuffer.HalInfo.RamType != BUFFER_CRUSH_UMA){
            data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
            data &= 0xDFFF;                             // Full Bandwidth bit OFF
            WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit            
        }
    }
    
    //
    // ATCOn()
    //
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);       // Reset ATC FlipFlop
    REG_WR08(NV_PRMCIO_ARX, 0x20);               // Turn off screen at AR
    ////WritePriv08(NV_PRMCIO_ARX, 0x20);        // Turn off screen at AR
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);       // Reset ATC FlipFlop
      
    // make sure test modes are off, else screen may be blanked
    DAC_REG_WR32(NV_PRAMDAC_TEST_CONTROL, 0, Head); // make sure test modes are off!

    // Enable active display, blank all non-active displays
    //  (TV is blanked in encoder-specific function).
    // + in mobile case, update BIOS's record of enabled displays
    cr3Bmod = 0;
    switch (GETDISPLAYTYPE(pDev, Head))
    {
        case DISPLAY_TYPE_MONITOR:
            if (Head == 0) // if normal VGA (internal DAC) 
            {
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _ON, Head);  // CRT on
                //
                // We need to be careful about powering down the TMDS
                // transmitter on NV11 because we can lose a flat
                // panel connected to the second crtc (head 1).
                //
                // XXX doing this on the P11 kills the FP on head 1.
                // commenting it out doesn't seem to break anything on the Mac....
                
#ifndef MACOS
                if (IsNV11(pDev))
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _FPCLK, Head);     // FPCLK off only;leave TMDS going for secondary crtc
                else
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _BOTH, Head);      // FPCLK/TMDS both off
#endif       
                CRTC_RD(0x33, data08, Head);
                CRTC_WR(0x33, (data08 & ~0x02), Head);  // clear CR33[1] (BIOS flag)
                CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 & 0x3F, Head);
                
                // make sure that head 0 is NOT driving FP output
                CRTC_RD(0x33, data08, Head);
                CRTC_WR(0x33, data08 & ~0x10, Head);    // Bit 4 = 0
                
                dacSetCursorBlink(pDev, Head, 0); // set cursor blink rate for DOS
            }
            else // PRAMDAC_FP is driving analog
            {
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head); // CRT off
                CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 & ~0x40, Head);
                
                // make head 0 drive FP output
                CRTC_RD(0x33, data08, Head);
                CRTC_WR(0x33, data08 | 0x10, Head);    // Bit 4 = FP 2
                
                dacSetCursorBlink(pDev, Head, 1); // set cursor blink rate for DOS
            }

            // If no head is using TV, blank image.
            for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
                    break;
            if (i == pDev->Dac.HalInfo.NumCrtcs)
                dacDisableTV(pDev, Head);
            //Update BIOS's record of enabled displays

            cr3Bmod = 0x20;
            break;                              
        case DISPLAY_TYPE_TV:
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head); // CRT offs
            //
            // We need to be careful about powering down the TMDS
            // transmitter on NV11 because we can lose a flat
            // panel connected to the second crtc (head 1).  This wouldn't
            // be an issue if we could 
            //
            if (IsNV11(pDev))
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _FPCLK, Head);     // FPCLK off only;leave TMDS going for secondary crtc
            else
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _BOTH, Head);      // FPCLK/TMDS both off
            CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
            CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 & ~0x40, Head);
            dacSetCursorBlink(pDev, Head, 1); // set cursor blink rate for DOS

            //Update BIOS's record of enabled displays
            cr3Bmod = 0x40;
            break;                              
        case DISPLAY_TYPE_FLAT_PANEL:
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head); // CRT off
            CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
            CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 & ~0x40, Head);
            CRTC_RD(0x33, data08, Head);
            CRTC_WR(0x33, data08 | 0x10, Head);    // Bit 4 = FP 2
            // If no head is using TV, blank image.
            for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
                    break;
            if (i == pDev->Dac.HalInfo.NumCrtcs)
                dacDisableTV(pDev, Head);
            // Need to actually power on the panel as well
            if (pDev->Power.MobileOperation)
                dacPowerOnMobilePanel(pDev, Head);
            dacSetCursorBlink(pDev, Head, 1); // set cursor blink rate for DOS

            //Update BIOS's record of enabled displays
            if (Head == 1) {
                cr3Bmod = 0x10;    //internal LCD
            } else {
                cr3Bmod = 0x80;    //external DFP
            }
            break;                              
    }

    //Update BIOS's record of enabled displays
    if (pDev->Power.MobileOperation &&  pDev->HotKeys.enabled) {
        CRTC_RD(0x3B, data08, Head);
        CRTC_WR(0x3B, (data08 & 0x0F) | cr3Bmod, Head);
    }

    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
    {
        shadow &= ~0x80;          // shadow Horiz only
        CRTC_WR(0x21, shadow, Head);    // restore the shadow lock
    }

    //Fix for Crush. TV and Flat Panel share some registers. We must
    //set the mux to pick the correct display.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL) 
    {
        if (IsNV0A(pDev)) 
        {
            data32 = 0x00000005;
            DAC_REG_WR32(NV_PRAMDAC_TV_SETUP, data32, Head); 
        }
    }    
    //
    // For NV4, change the default flip functionality to end of vsync, not start
    //
    // BUG BUG BUG:  There is a hardware bug in NV4/NV5 relating to this particular
    // register.  You must access another register in this general area before
    // accessing PCRTC_CONFIG
    //
    data32 = DAC_REG_RD32(NV_PCRTC_START, Head);
    DAC_FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _NON_VGA, Head);
    
    //
    // Update arb settings for each mode set
    //

    nvHalDacUpdateArbSettings(pDev, (VOID*) &pVidLutCurDac->HalObject);

    // Save the retrace start/end values (display position default)
    dacSaveMonitorDefaultPosition(pDev, Head);

    // We have successfully set a new mode. Do any os specific actions.
    // This includes any registry settings that should take effect at a mode set.
    osPostModeSet(pDev, Head);

    //
    // Determine if it's possible to support a video overlay in this resolution
    //

    //LPL: will later either add a new multichip function for multi-display,
    // or expand the parameter list on the existing fn.  For now, this hack
    // minimizes the changes to other files.
    nvHalDacValidateArbSettings(pDev, 
                                PixelDepth, 
                                1, 0, 
                                (PixelClock * 10000),
                                &(pDev->Video.OverlayAllowed));


    REG_WR08(NV_PRMCIO_CRX__COLOR, 0x991F & 0xFF); 
    REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x991F >> 8) & 0xFF);
    ////OEMDisableExtensions();         // Lock the registers

    if(IsNV0A(pDev)){
        if(pDev->Framebuffer.HalInfo.RamType == BUFFER_CRUSH_UMA){
            tmrDelay(pDev,/*U032 nsec*/100000000);
            save_sr1 &= 0xDFFF;                         // Full Bandwidth bit OFF
            WriteIndexed(NV_PRMVIO_SRX, save_sr1);      // Set bit            
        }
    }

    //
    // If we're on an NV11, be sure to restore VGA accesses
    // to the primary (head 0) device.
    //
    if (IsNV11(pDev) && Head != 0)
    {
        if ((pDev->Chip.BiosRevision & 0xFF0000FF) < 0x03000020)
            EnableHead(pDev, 0);
        //REG_WR08(NV_PRMVIO_VSE2, 1);                    // enable VGA subsystem
        //data08 = REG_RD08(NV_PRMVIO_MISC__READ);
        //REG_WR08(NV_PRMVIO_MISC__WRITE, data08 & ~1);   // enable CGA I/O space
    }


    return RM_OK;
} // end of dacSetMode
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\dactv.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* DAC TV Control ****************************\
*                                                                           *
* Module: DACTV.C                                                           *
*   Mode set for TV is done here.                                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include "vga.h"
#include "i2c.h"
#include "tv.h"
#include <nvcm.h>
#include <edid.h>

U008 dacGetTVmode(PHWINFO, U032);

//
//  I2C  Strings
//
//---------------------------------------------------------------------------------------
// Philips


//-----------------------------------------------------------------------------
U008 Ph_Gen_Init0[] = {  
              0x01,            //subaddress 01
              0x00,            //reg 1 - load macrovision registers with 0's ???  
              0x00,            //reg 2  
              0x00,            //reg 3  
              0x00,            //reg 4  
              0x00,            //reg 5  
              0x00,            //reg 6  
              0x00,            //reg 7  
              0x00,            //reg 8  
              0x00,            //reg 9  
              0x00,            //reg a  
              0x00,            //reg b  
              0x00,            //reg c  
              0x00,            //reg d  
              0x00,            //reg e  
              0x00,            //reg f  
              0x00,            //reg 10 
              0x00,            //reg 11 
              0x00,            //reg 12 
              0x00,            //reg 13  
              0x00,            //reg 14
              0x00,            //reg 15  
              0x00,            //reg 16
              0x1b,            //reg 17
              0x1b,            //reg 18  
              0x1f,            //reg 19
              0x46,            //reg 1a
              0x00,            //reg 1b  
              0x00,            //reg 1c
              0x00,            //reg 1d  
              0x00,            //reg 1e
              0x00,            //reg 1f  
              0x00,            //reg 20
              0x1b,            //reg 21
              0x00,            //reg 22
              0x00,            //reg 23  
              0x00,            //reg 24
              0x00,            //reg 25  
              0xff,            //reg26                  
              0x3f,            //reg27                  
              0x19,            //reg28 Burst start: PAL=21h,NTSC=19h                 
              0x1d,            //reg29 Burst End: PAL=1dh,NTSC=1dh                 
              0xff,            //reg2a copy guard          
              0xff,            //reg2b copy guard          
              0x0f,            //reg2c cg data             
              0xb4,            //reg2d (clock polarity) 
              0x00,            //reg2e null             
              0x00,            //reg2f null             
              0x00,            //reg30 macro-vision     
              0x00,            //reg31 macro data 0        
              0x00,            //reg32                  
              0x00,            //reg33 data                
              0x00,            //reg34                  
              0x00,            //reg35                  
              0x00,            //reg36 data             
              0x00,            //reg37                  
              0x1a,            //reg38 RGB luma gain       
              0x1a,            //reg39 color gain diff.    
              0x00             //reg3a Color burst Enable    3Ah = 58
};
#define Ph_Gen_Init0_Len sizeof(Ph_Gen_Init0)
        
//----------------------------------------------------------------------------
U008 Ph_Gen_Init1[] = {
              0xa2,            //subaddress a2                2
              0x10,            //rega2 border color black     3   
              0x80,            //rega3 border color           4   
              0x80             //rega4 border color           5
};
#define Ph_Gen_Init1_Len sizeof(Ph_Gen_Init1)

//-----------------------------------------------------------------------------
U008 Ph_Gen_Init2[] = {
              0xfc,            
              0x03,            //regfc cursor position, move cursor off screen     
              0x98             //regfd lut off for now...         
};
#define Ph_Gen_Init2_Len sizeof(Ph_Gen_Init2)

// Format dependent init tables
// Init string 0
U008 Ph_NTSC_Init0[] = {
              0x54,            //start at address 54,
              0x01,            //reg 54 Internal PPD1 & PPD2 clock edge
              0x0f,            //reg 55
              0xc3,            //reg 56
              0x00,            //reg 57
              0x02,            //reg 58
              0x30,            //reg 59
              0x00,            //reg 5a Chrominance Phase (was 88)
              0x76,            //reg 5b
              0xa5,            //reg 5c 
              0x3a,            //reg 5d 
              0x2e,            //reg 5e 
              0x2e,            //reg 5f Cross Color Reduction (was 6e)
              0x00,            //reg 60                 
              0x15,            //reg 61 
              0x3f,            //reg 62 
              0x1f,            //reg 63 
              0x7c,            //reg 64 
              0xf0,            //reg 65  
              0x21,            //reg 66  
              0x00,            //reg 67  
              0x00,            //reg 68  
              0x00,            //reg 69  
              0x00,            //reg 6a
              0x00,            //reg 6b reserved
              0x01,            //reg 6c  
              0x20,            //reg 6d  
              0x00,            //reg 6e Blanking Control
              0x42,            //reg 6f CCN b[7:6], SCCLN b[4:0] (was 00)
              0x48,            //reg 70
              0x44,            //reg 71
              0x61,            //reg 72
              0x90,            //reg 73
              0x94,            //reg 74
              0xB0,            //reg 75
              0x78,            //reg 76
              0xf9,            //reg 77
              0x2a,            //reg 78
              0x2a,            //reg 79
              0x29,            //reg 7a >>> was 29, maybe 1d
              0x01,            //reg 7b >>> was 01, maybe f9 or de
              0x00,            //reg 7c
              0x00,            //reg 7d
              0x0c,            //reg 7e
              0x0d,            //reg 7f
              0x00,            //reg 80
              0x48,            //reg 81 >>> was 48, maybe ad
              0x2a,            //reg 82
              0x21             //reg 83
};
#define Ph_NTSC_Init0_Len sizeof(Ph_NTSC_Init0)

//-----------------------------------------------------------------------------
U008 Ph_NTSC_Init1[] = {
              0x90,            //start at address 90,
              0x5c,            //reg 90
              0x40,            //reg 91
              0x58,            //reg 92
              0x58,            //reg 93
              0x04,            //reg 94
              0xa0,            //reg 95
              0x02,            //reg 96
              0x2e,            //reg 97
              0x1f,            //reg 98
              0x13,            //reg 99
              0xf4,            //reg 9a
              0x33,            //reg 9b
              0x7f,            //reg 9c
              0x99,            //reg 9d
              0x99             //reg 9e
};
#define Ph_NTSC_Init1_Len sizeof(Ph_NTSC_Init1)

// Init string 0
U008 Ph_PAL_Init0[] = {
              0x54,            //start at address 54,
              0x01,            //reg 54 Internal PPD1 & PPD2 clock edge
              0x0f,            //reg 55
              0xc3,            //reg 56
              0x00,            //reg 57
              0x02,            //reg 58
              0x30,            //reg 59
              0x00,            //reg 5a Chrominance Phase (was 88)
              0x7d,            //reg 5b
              0xaf,            //reg 5c 
              0x33,            //reg 5d 
              0x35,            //reg 5e 
              0x75,            //reg 5f Cross Color Reduction (was 6e)
              0x00,            //reg 60                 
              0x02,            //reg 61 
              0x2f,            //reg 62 
              0xcb,            //reg 63 
              0x8a,            //reg 64 
              0x09,            //reg 65  
              0x2a,            //reg 66  
              0x00,            //reg 67  
              0x00,            //reg 68  
              0x00,            //reg 69  
              0x00,            //reg 6a
              0x00,            //reg 6b reserved
              0x01,            //reg 6c  
              0x20,            //reg 6d  
              0x00,            //reg 6e Blanking Control
              0x42,            //reg 6f CCN b[7:6], SCCLN b[4:0] (was 00)
              0x56,            //reg 70
              0x52,            //reg 71
              0x61,            //reg 72
              0x90,            //reg 73
              0x94,            //reg 74
              0xB0,            //reg 75
              0x78,            //reg 76
              0xf9,            //reg 77
              0x2a,            //reg 78
              0xfa,            //reg 79
              0x26,            //reg 7a >>> was 29, maybe 1d
              0x27,            //reg 7b >>> was 01, maybe f9 or de
              0x40,            //reg 7c
              0x00,            //reg 7d
              0x0c,            //reg 7e
              0x0d,            //reg 7f
              0x00,            //reg 80
              0x00,            //reg 81 >>> was 48, maybe ad
              0x00,            //reg 82
              0x1c             //reg 83
};
#define Ph_PAL_Init0_Len sizeof(Ph_PAL_Init0)

//-----------------------------------------------------------------------------
U008 Ph_PAL_Init1[] = {
              0x90,            //start at address 90,
              0x68,            //reg 90
              0x40,            //reg 91
              0x45,            //reg 92
              0x45,            //reg 93
              0x04,            //reg 94
              0xb8,            //reg 95
              0x02,            //reg 96
              0x2e,            //reg 97
              0x25,            //reg 98
              0x53,            //reg 99
              0xf4,            //reg 9a
              0x89,            //reg 9b
              0x8f,            //reg 9c
              0x43,            //reg 9d
              0x43,            //reg 9e
              0x4c
};
#define Ph_PAL_Init1_Len sizeof(Ph_PAL_Init1)

// Mode Tables
U008 Ph_NTSC_640[] = {
                0x70,       //start at address 70  
                0x3e,       //reg 70 Active display H Start (horizontal centering)
                0x3e,       //reg 71 Active display H End
                0x61,       //reg 72=0x61
                0x90,       //reg 73=0x90
                0x94,       //reg 74=0x94
                0xb0,       //reg 75=0xb0
                0x78,       //reg 76=0x78
                0xf9,       //reg 77=0xf9
                0x2a,       //reg 78=0x2a
                0xfa,       //reg 79=0xfa
                0x20,       //reg 7a
                0xf6,       //reg 7b
                0x00,       //reg 7c=0x00
                0x00,       //reg 7d=0x00
                0x0c,       //reg 7e=0x0c
                0x0d,       //reg 7f=0x0d
                0x00,       //reg 80=0x00
                0x00,       //reg 81  Pix clk 0
                0x00,       //reg 82  Pix clk 1
                0x20,       //reg 83  Pix Clk 2
                0x00,       //reg 84=0x00
                0x00,       //reg 85=0x00
                0x00,       //reg 86=0x00
                0x00,       //reg 87=0x00
                0x00,       //reg 88=0x00
                0x00,       //reg 89=0x00
                0x00,       //reg 8a=0x00
                0x00,       //reg 8b=0x00
                0x00,       //reg 8c=0x00
                0x00,       //reg 8d=0x00
                0x00,       //reg 8e=0x00
                0x00,       //reg 8f=0x00
                0x64,       //reg 90=0x60
                0x40,       //reg 91=0x40
                0x45,       //reg 92
                0x45,       //reg 93
                0x04,       //reg 94=0x04
                0xa0,       //reg 95=0xa0
                0x02,       //reg 96=0x02
                0x2e,       //reg 97=0x2e
                0xf9,       //reg 98=0x1f
                0x12,       //reg 99=0x13
                0x00,       //reg 9a=0x00
                0x1b,       //reg 9b
                0x70,       //reg 9c
                0x8d,       //reg 9d
                0x8d,       //reg 9e
                0x3b,       //reg 9f=0x3b
                0x00,       //reg a0=0x00
                0x00,       //reg a1=0x00
                0x10,       //reg a2 
                0x80,       //reg a3  
                0x80        //reg a4  
};
#define Ph_NTSC_Res_Len sizeof(Ph_NTSC_640)

U008 Ph_NTSC_800[] = {
                0x70,        //begin at register 70
                0x4b,        //reg 70
                0x23,        //reg 71
                0x61,        //reg 72
                0x90,        //reg 73
                0x94,        //reg 74
                0xb0,        //reg 75
                0x78,        //reg 76
                0xf9,        //reg 77
                0x2a,        //reg 78
                0xfa,        //reg 79
                0x1e,        //reg 7a
                0xf4,        //reg 7b
                0x00,        //reg 7c
                0x00,        //reg 7d
                0x0c,        //reg 7e
                0x0d,        //reg 7f
                0x00,        //reg 80
                0x00,        //reg 81 Pix clk 0
                0x00,        //reg 82 Pix clk 1
                0x40,        //reg 83 Pix clk 2
                0x00,        //reg 84
                0x00,        //reg 85
                0x00,        //reg 86
                0x00,        //reg 87
                0x00,        //reg 88
                0x00,        //reg 89
                0x00,        //reg 8a
                0x00,        //reg 8b
                0x00,        //reg 8c
                0x00,        //reg 8d
                0x00,        //reg 8e
                0x00,        //reg 8f
                0x62,        //reg 90 [Wiped out by fine adjust]
                0x90,        //reg 91
                0x51,        //reg 92
                0x51,        //reg 93
                0x04,        //reg 94
                0xb8,        //reg 95
                0x02,        //reg 96
                0x2e,        //reg 97
                0xc5,        //reg 98 HLen 
                0x64,        //reg 99 IDEL + HLen
                0x67,        //reg 9a
                0xb1,        //reg 9b
                0x5c,        //reg 9c
                0xd8,        //reg 9d
                0xd8,        //reg 9e
                0x2a,        //reg 9f
                0x00,        //reg a0
                0x00,        //reg a1
                0x10,        //reg a2
                0x80,        //reg a3
                0x80         //reg a4
};

U008 Ph_PAL_640[] = {
                0x70,       //start at address 70  
                0x81,       //reg 70=0x44
                0x59,       //reg 71=0x44
                0x61,       //reg 72=0x61
                0x90,       //reg 73=0x90
                0x94,       //reg 74=0x94
                0xb0,       //reg 75=0xb0
                0x78,       //reg 76=0x78
                0xf9,       //reg 77=0xf9
                0x2a,       //reg 78=0x2a
                0xfa,       //reg 79=0xfa
                0x26,       //reg 7a=0x29  >>> was 29, maybe 1d
                0x27,       //reg 7b=0x01  >>> was 01, maybe f9 or de
                0x40,       //reg 7c=0x00
                0x00,       //reg 7d=0x00
                0x0c,       //reg 7e=0x0c
                0x0d,       //reg 7f=0x0d
                0x00,       //reg 80=0x00
                0x00,       //reg 81=0x48  Pix clk 0
                0x00,       //reg 82=0x21  Pix clk 1
                0x1c,       //reg 83=0x21  Pix Clk 2
                0x00,       //reg 84=0x00
                0x00,       //reg 85=0x00
                0x00,       //reg 86=0x00
                0x00,       //reg 87=0x00
                0x00,       //reg 88=0x00
                0x00,       //reg 89=0x00
                0x00,       //reg 8a=0x00
                0x00,       //reg 8b=0x00
                0x00,       //reg 8c=0x00
                0x00,       //reg 8d=0x00
                0x00,       //reg 8e=0x00
                0x00,       //reg 8f=0x00
                0x68,       //reg 90=0x60
                0x40,       //reg 91=0x40
                0x45,       //reg 92=0x58  >>> was 58, maybe 3d
                0x45,       //reg 93=0x58  >>> was 58, maybe 3d
                0x04,       //reg 94=0x04
                0xb8,       //reg 95=0xa0
                0x02,       //reg 96=0x02
                0x2e,       //reg 97=0x2e
                0x25,       //reg 98=0x1f
                0x53,       //reg 99=0x13
                0x81,       //reg 9a=0x00
                0x89,       //reg 9b=0x33  >>> was 33, maybe 4e
                0x8f,       //reg 9c=0x70  >>> was 70, maybe 70
                0x43,       //reg 9d=0x99  >>> was 99, maybe a6
                0x43,       //reg 9e=0x99  >>> was 99, maybe a6
                0x4c,       //reg 9f=0x3b
                0x00,       //reg a0=0x00
                0x00,       //reg a1=0x00
                0x10,       //reg a2 
                0x80,       //reg a3  
                0x80        //reg a4  
};
#define Ph_PAL_Res_Len sizeof(Ph_PAL_640)

U008 Ph_PAL_800[] = {
                0x70,        //begin at register 70
                0x5d,        //reg 70
                0x51,        //reg 71
                0x61,        //reg 72
                0x90,        //reg 73
                0x94,        //reg 74
                0xb0,        //reg 75
                0x78,        //reg 76
                0xf9,        //reg 77
                0x2a,        //reg 78
                0xfa,        //reg 79
                0x24,        //reg 7a
                0x29,        //reg 7b
                0x40,        //reg 7c
                0x00,        //reg 7d
                0x0c,        //reg 7e
                0x0d,        //reg 7f
                0x00,        //reg 80
                0x00,        //reg 81 Pix clk 0
                0x00,        //reg 82 Pix clk 1
                0x2c,        //reg 83 Pix clk 2
                0x00,        //reg 84
                0x00,        //reg 85
                0x00,        //reg 86
                0x00,        //reg 87
                0x00,        //reg 88
                0x00,        //reg 89
                0x00,        //reg 8a
                0x00,        //reg 8b
                0x00,        //reg 8c
                0x00,        //reg 8d
                0x00,        //reg 8e
                0x00,        //reg 8f
                0x66,        //reg 90 [Wiped out by fine adjust]
                0x90,        //reg 91
                0x50,        //reg 92
                0x50,        //reg 93
                0x04,        //reg 94
                0xb8,        //reg 95
                0x02,        //reg 96
                0x2e,        //reg 97
                0x07,        //reg 98 ,LEN was 0xxff, c,anged to non-sentinel value
                0x54,        //reg 99
                0xaf,        //reg 9a
                0xf2,        //reg 9b
                0x6c,        //reg 9c
                0x77,        //reg 9d
                0x77,        //reg 9e
                0x3b,        //reg 9f
                0x00,        //reg a0
                0x00,        //reg a1
                0x10,        //reg a2
                0x80,        //reg a3
                0x80         //reg a4
};


// Autoconfigure hack
U008    Bt_NM800[] = { 0xB8, 0x02, 0xff };
U008    Bt_NM640[] = { 0xB8, 0x00, 0xff };
//
// Brooktree strings
//

//  Init string               C4    C6    C8            CA           CC             CE
U008    BT_Init[] = { 0xC4, 0x01, 0x98, BT_FLICKER_MED, BT_LUMA_DEF, BT_CHROMA_DEF, (BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL), 0xff };
U008    BT871_Init[] = { 0xC4, 0x01, 0x98, BT_FLICKER_MED, BT871_LUMA_DEF, BT871_CHROMA_DEF, (BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL), 0xff };

/************************************************************************************************
    We now support 6 distinct TV standards: NTSC M, NTSC J, PAL NC, PAL M, PAL N, and
    PAL B, D, G, I (which are the same as far as we are concerned).
*/
//---------------------------------------------------------------------------------------
// Brooktree 800x600

// NTSC M 800x600
U008 Bt_NM600[] = {
// 0x6e, 0xe7, 0xc2, 0x00, 0x01,
// 76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90
 0x76, 
 0xA0, 0x20, 0xB6, 0xD8, 0xB9, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x42, 0x03, 0xDF,
// 92    94    96    98    9A    9C    9E    A0    A2    A4    A6    A8    AA    AC    AE
 0x56, 0x58, 0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x0A, 0xE5, 0x74, 0x77, 0x43, 0x85, 0xBA,
// B0    B2    B4    B6
 0xE8, 0xA2, 0x17, 0x00, 
 0xff};

// NTSC J 800x600
U008 Bt_NJ600[] = {
// 0x6e, 0xe7, 0xc2, 0x00, 0x01,
 0x76, 
 0xA0, 0x20, 0xB6, 0xD8, 0xB9, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x42, 0x03, 0xDF,
 0x56, 0x58, 0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x08, 0xE5, 0x74, 0x77, 0x43, 0x85, 0xBA,
 0xE8, 0xA2, 0x17, 0x00,
 0xff};

// PAL NC 800x600
U008 Bt_NC600[] = {
// 0x6e, 0xe7, 0xc2, 0x00, 0x01,
 0x76, 
 0x00, 0x20, 0xAA, 0xCA, 0xA4, 0x0D, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE, 
 0x5F, 0x58, 0x3A, 0x66, 0x96, 0x00, 0x00, 0x10, 0x24, 0xF0, 0x56, 0x7F, 0x47, 0x8C, 0x35,
 0xEF, 0x78, 0x19, 0x00,
 0xff};

// PAL B,D,G,I 800x600
U008 Bt_PA600[] = {
// 0x6e, 0x31, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x20, 0xAA, 0xCA, 0x9A, 0x0D, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE,
 0x5F, 0x58, 0x3A, 0x66, 0x96, 0x00, 0x00, 0x10, 0x24, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x18,
 0x28, 0x87, 0x1F, 0x00,
 0xff};

// PAL M 800x600
U008 Bt_PM600[] = {
// 0x6e, 0x31, 0x02, 0x00, 0x01,
 0x76, 
 0xA0, 0x20, 0xB6, 0xE0, 0xC2, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x42, 0x03, 0xDF,
 0x56, 0x58, 0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x2A, 0xF0, 0x56, 0x7E, 0x47, 0x8C, 0x7E,
 0x42, 0x9C, 0x17, 0x00,
 0xff};

// PAL N 800x600
U008 Bt_PN600[] = {
// 0x6e, 0x31, 0x02, 0x00, 0x01,
0x76, 
0x00, 0x20, 0xAA, 0xCA, 0x9A, 0xF3, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE,
0x5F, 0x58, 0x3A, 0x66, 0x56, 0x00, 0x00, 0x10, 0x2E, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x18,
0x28, 0x87, 0x1F, 0x00,
0xff};

//---------------------------------------------------------------------------------------
// Native TV modes with no overscan.  For use when playing DVD's

// Brooktree 720x480 NTSC
U008 Bt_NMDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90    92    94
    0x76, 
    0xE0, 0xD0, 0x82, 0x92, 0x5C, 0x1B, 0x13, 0xF2, 0x26, 0x00, 0x70, 0x8C, 0x03, 0x0D, 0x24, 0xE0, 
    0x36, 0x00, 0x50, 0xC5, 0x4E, 0x0C, 0x0A, 0xE5, 0x76, 0x79, 0x44, 0x85, 0xD1, 0x45, 0x17, 0x21, 
    0x00, 0xff};

U008 Bt_NJDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90    92    94
    0x76, 
    0x66, 0xD0, 0x82, 0x92, 0x5C, 0x1B, 0x13, 0xF2, 0x27, 0x00, 0x70, 0x8C, 0x03, 0x0D, 0x24, 0xE0, 
    0x36, 0x00, 0x50, 0xC5, 0x4E, 0x0C, 0x08, 0xE5, 0x76, 0x79, 0x44, 0x85, 0xD1, 0x45, 0x17, 0x21, 
    0x00, 0xff};

U008 Bt_NCDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	  8E	90    92    94
    0x76,
    0xF0, 0xD0, 0x82, 0x9C, 0x5A, 0x31, 0x16, 0x22, 0xa6, 0x00, 0x78, 0x93, 0x03, 0x71, 0x2A, 0x40,
    0x3A, 0x00, 0x50, 0x55, 0x55, 0x0C, 0x24, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0x8E, 0xB0, 0xE6, 0x28,
    0x00, 0xff};

U008 Bt_PADVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	  8E	90    92    94
    0x76,
    0xF0, 0xD0, 0x82, 0x9C, 0x5A, 0x31, 0x16, 0x22, 0xa6, 0x00, 0x78, 0x93, 0x03, 0x71, 0x2A, 0x40,
    0x3A, 0x00, 0x50, 0x55, 0x55, 0x0C, 0x24, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0x8E, 0xB0, 0xE6, 0x28,
    0x00, 0xff};

U008 Bt_PMDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	  8E	90    92    94
    0x76,
    0xF0, 0xD0, 0x82, 0x9C, 0x5A, 0x31, 0x16, 0x22, 0xa6, 0x00, 0x78, 0x93, 0x03, 0x71, 0x2A, 0x40,
    0x3A, 0x00, 0x50, 0x55, 0x55, 0x0C, 0x24, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0x8E, 0xB0, 0xE6, 0x28,
    0x00, 0xff};

U008 Bt_PNDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	  8E	90    92    94
    0x76,
    0xF0, 0xD0, 0x82, 0x9C, 0x5A, 0x31, 0x16, 0x22, 0xa6, 0x00, 0x78, 0x93, 0x03, 0x71, 0x2A, 0x40,
    0x3A, 0x00, 0x50, 0x55, 0x55, 0x0C, 0x24, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0x8E, 0xB0, 0xE6, 0x28,
    0x00, 0xff};

//---------------------------------------------------------------------------------------

// Two no-overscan modes, which will be the default on X-box:

// Brooktree 640x480 NTSC
U008 Bt_NM480x[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	   8E	 90
    0x76,
    0x08, 0x80, 0x72, 0x80, 0x42, 0xf1, 0x13, 0xf2, 0x26, 0x00, 0x04, 0x73, 0x03, 0x0d, 
    0x24, 0xe0, 0x00, 0x00, 0x10, 0x15, 0xcc, 0x0a, 0x0a, 0xe5, 0x77, 0x7a, 0x45, 0x85, // 92-AC
    0x81, 0x5f, 0xb8, 0x25, 0x00,             // AE-B6 (stop here: B8 is the autoconfig mode register)
    0xff};

// Brooktree 640x480 PAL. This one starts at reg 38.
U008 Bt_PA480x[] = {
// 38,   3A,   3C,   3E,   40,   42,   44,   46,   48,   4A,   4C,   4E,   50,   52,   54,   56,   58,   5A,   5C,   5E 
 0x38,
 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x01, 0x2e, 0x1a, 0x01, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x46, 0x00, 0x01,                                  // 60-74
 0x3c, 0x80, 0x76, 0x8c, 0x44, 0x1b, 0x16, 0x20, 0xA6, 0x00, 0xB6, 0xFB, 0x03, 0x0D,    // 76-90
 0x23, 0xe0, 0x06, 0xe1, 0x4a, 0x55, 0x15, 0x0b, 0x24, 0xf0, 0x59, 0x83, 0x4a, 0x8c,    // 92-AC
 0x33, 0x98, 0x83, 0x2d, 0x00,                                                          // AE-B6
 0xff};

// Normal modes used with 868/869:

 //---------------------------------------------------------------------------------------
// Brooktree 640x480

// NTSC 640x480
U008 Bt_NM480[] = {
// 0x6e, 0x26, 0x02, 0x00, 0x01,
// 76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90
 0x76, 
 0x00, 0x80, 0x84, 0x9E, 0x65, 0x7D, 0x22, 0xD4, 0x27, 0x00, 0x10, 0x7E, 0x03, 0x58,
 0x4B, 0xE0, 0x36, 0x92, 0x54, 0x0E, 0x88, 0x0C, 0x0A, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00,
 0x00, 0x80, 0x20, 0x00,
 0xff};

// NTSC J 640x480
U008 Bt_NJ480[] = {
// 0x6e, 0x26, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x80, 0x84, 0x9E, 0x65, 0x7D, 0x22, 0xD4, 0x27, 0x00, 0x10, 0x7E, 0x03, 0x58, 
 0x4B, 0xE0, 0x36, 0x92, 0x54, 0x0E, 0x88, 0x0C, 0x08, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00,
 0x00, 0x80, 0x20, 0x00,
 0xff};

// PAL NC 640x480
U008 Bt_NC480[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
 0x76, 
 0x60, 0x80, 0x8A, 0xA6, 0x70, 0xC1, 0x2E, 0xF2, 0x27, 0x00, 0xB0, 0x0A, 0x0B, 0x71, 
 0x5A, 0xE0, 0x36, 0x00, 0x50, 0x72, 0x1C, 0x0D, 0x24, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x1E,
 0xC0, 0x15, 0x1F, 0x00,
 0xff};

// PAL B,D,G,I 640x480
U008 Bt_PA480[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
// 0x76, 78    7a    7c    7e    80    82    84    86    88    8a    8c    8e    90
 0x76,
 0x60, 0x80, 0x8A, 0xA6, 0x68, 0xC1, 0x2E, 0xF2, 0x27, 0x00, 0xB0, 0x0A, 0x0B, 0x71,
// 92    94    96    98    9a    9c    a0    a2    a4    a6    a8    aa    ac    ae    b0
 0x5A, 0xE0, 0x36, 0x00, 0x50, 0x72, 0x1C, 0x0D, 0x24, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0x0C,
 0x8C, 0x79, 0x26, 0x00,
 0xff};

// PAL M 640x480
U008 Bt_PM480[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x80, 0x84, 0xA4, 0x6A, 0x7D, 0x22, 0xD4, 0x27, 0x00, 0x10, 0x7E, 0x03, 0x58, 
 0x4B, 0xE0, 0x36, 0x92, 0x54, 0x0E, 0x88, 0x0C, 0x2A, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x6E, 
 0xDB, 0x76, 0x20, 0x00,
 0xff};

// PAL N 640x480
U008 Bt_PN480[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
 0x76, 
 0x60, 0x80, 0x8A, 0xA6, 0x68, 0xAB, 0x2E, 0xF2, 0x27, 0x00, 0xB0, 0x0A, 0x0B, 0x71, 
 0x5A, 0xE0, 0x36, 0x00, 0x50, 0x72, 0x1C, 0x0D, 0x2E, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0x0C,
 0x8C, 0x79, 0x26, 0x00,
 0xff};

//---------------------------------------------------------------------------------------
// Brooktree 640x400

// NTSC M 640x400
U008 Bt_NM400[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x80, 0x84, 0x96, 0x60, 0x7D, 0x20, 0xD8, 0x27, 0x00, 0xC0, 0x18, 0x0B, 0xEA, 
 0x39, 0x90, 0x35, 0xDE, 0x4D, 0x0E, 0x88, 0x0C, 0x0A, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00,
 0x00, 0x80, 0x20, 0x00,
 0xff};

// NTSC J 640x400
U008 Bt_NJ400[] = {
// 0x6e, 0xc0, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x80, 0x84, 0x96, 0x60, 0x7D, 0x20, 0xD8, 0x27, 0x00, 0xC0, 0x18, 0x0B, 0xEA, 
 0x39, 0x90, 0x35, 0xDE, 0x4D, 0x0E, 0x88, 0x0C, 0x08, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00, 
 0x00, 0x80, 0x20, 0x00,
 0xff};

// PAL NC 640x400
U008 Bt_NC400[] = {
// 0x6e, 0xc0, 0x02, 0x00, 0x01,
0x76, 
0x90, 0x80, 0x8E, 0xAA, 0x76, 0xDD, 0x35, 0xE5, 0x27, 0x00, 0x4C, 0x92, 0x0C, 0x26, 
0x5B, 0x90, 0x36, 0x29, 0x4C, 0xC7, 0x71, 0x0D, 0x24, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x6B, 
0x73, 0x50, 0x1E, 0x00, 
0xff};

// PAL B,D,G,I 640x400
U008 Bt_PA400[] = {
 0x6e, 0x20, 0x42, 0x00, 0x01,
//0x76,  78    7a    7c    7e    80    82    84    86    88    8a    8c    8e    90
  0x90, 0x80, 0x8E, 0xAA, 0x6E, 0xDD, 0x35, 0xE5, 0x27, 0x00, 0x4C, 0x92, 0x0C, 0x26, 
//  92    94    96    98    9a    9c    a0    a2    a4    a6    a8    aa    ac    ae    b0
  0x5B, 0x90, 0x36, 0x29, 0x4C, 0xC7, 0x71, 0x0D, 0x24, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0xEA, 
  0x57, 0x85, 0x25, 0x00,
 0xff};

// PAL M 640x400
U008 Bt_PM400[] = {
 0x6e, 0x20, 0x42, 0x00, 0x01,
// 0x76, 
 0x00, 0x80, 0x84, 0xA4, 0x6A, 0x7D, 0x20, 0xD8, 0x27, 0x00, 0xC0, 0x18, 0x0B, 0xEA, 
 0x39, 0x90, 0x35, 0xDE, 0x4D, 0x0E, 0x88, 0x0C, 0x2A, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x6E, 
 0xDB, 0x76, 0x20, 0x00,
 0xff};

// PAL N 640x400
U008 Bt_PN400[] = {
 0x6e, 0x20, 0x42, 0x00, 0x01,
//0x76 
0x90, 0x80, 0x8E, 0xAA, 0x6E, 0xC5, 0x35, 0xE5, 0x27, 0x00, 0x4C, 0x92, 0x0C, 0x26, 
0x5B, 0x90, 0x36, 0x29, 0x4C, 0xC7, 0x71, 0x0D, 0x2E, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0xEA, 
0x57, 0x85, 0x25, 0x00, 
0xff};

//---------------------------------------------------------------------------------------
//  Centering
//  H, V Offset. 6E = H Offset Low, 70[7,6] = H Offset High, 70[5:0] = H Sync Width
//               72 = V Offset Low, 74[5:3] = V Offset High, 74[2:0] = V Sync Width
//  NV4 Horizontal Offset should be 8 pixels less than NV5 & up (see programBrooktree()).
//---------------------------------------------------------------------------------------

// NTSC M 800x600
U008 Btc_NM600[] = {
 0x6e, 0xe0, 0xc2, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 800x600
U008 Btc_PA600[] = {
 0x6e, 0x2a, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC 720x480
U008 Btc_NMDVD[] = {
 0x6e, 0x28, 0x02, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 720x576
U008 Btc_PADVD[] = {
 0x6e, 0x28, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC 640x480
U008 Btc_NM480[] = {
 0x6e, 0x1e, 0x02, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 640x480
U008 Btc_PA480[] = {
 0x6e, 0xac, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 640x400
U008 Btc_NM400[] = {
 0x6e, 0xb6, 0x02, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 640x400
U008 Btc_PA400[] = {
 0x6e, 0x2e, 0x42, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 320x400
// CURRENTLY UNUSED
U008 Btc_NM3x4[] = {
 0x6e, 0x00, 0x42, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 320X400
U008 Btc_PA3x4[] = {
 0x6e, 0x20, 0x42, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 512x384
U008 Btc_NM384[] = {
 0x6e, 0x08, 0x42, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 512x384
U008 Btc_PA384[] = {
 0x6e, 0x80, 0x42, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 480x360
U008 Btc_NM360[] = {
 0x6e, 0x08, 0x42, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 480x360
U008 Btc_PA360[] = {
 0x6e, 0x80, 0x42, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 400x300
U008 Btc_NM300[] = {
 0x6e, 0xac, 0xc2, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 400x300
U008 Btc_PA300[] = {
 0x6e, 0x05, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 320x240
U008 Btc_NM240[] = {
 0x6e, 0xd2, 0xc2, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 320x240
U008 Btc_PA240[] = {
 0x6e, 0x60, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// Brooktree 320x200

// NTSC M 320x200
U008 Btc_NM200[] = {
 0x6e, 0x6b, 0x02, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 320x200
U008 Btc_PA200[] = {
 0x6e, 0xd8, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// Brooktree I2C tables for TV modes 0..9
// Some modes are scanline and/or character doubled (e.g. 320x200 is really 640x400)
// Some modes do not have specific encoder tables; they use the next larger format
// (e.g. 512x384 uses 640x400).
// DVD native mode is the native TV resolution with overscan compensation disabled
// There are 3 sets of tables (400, 480, 600) times 6 TV formats.
//    320x200   320x240   320x400   400x300   480x360   512x384   640x400   640x480   800x600  DVD native
U008 *Bt_NM[] =    // NTSC M
    {Bt_NM400, Bt_NM480, Bt_NM400, Bt_NM600, Bt_NM400, Bt_NM400, Bt_NM400, Bt_NM480, Bt_NM600, Bt_NMDVD};

U008 *Bt_NJ[] =    // NTSC J
    {Bt_NJ400, Bt_NJ480, Bt_NJ400, Bt_NJ600, Bt_NJ400, Bt_NJ400, Bt_NJ400, Bt_NJ480, Bt_NJ600, Bt_NJDVD};

U008 *Bt_PM[] =    // PAL M
    {Bt_PM400, Bt_PM480, Bt_PM400, Bt_PM600, Bt_PM400, Bt_PM400, Bt_PM400, Bt_PM480, Bt_PM600, Bt_PMDVD};

U008 *Bt_PA[] =    // PAL BDHGI
    {Bt_PA400, Bt_PA480, Bt_PA400, Bt_PA600, Bt_PA400, Bt_PA400, Bt_PA400, Bt_PA480, Bt_PA600, Bt_PADVD};

U008 *Bt_PN[] =    // PAL N
    {Bt_PM400, Bt_PN480, Bt_PN400, Bt_PN600, Bt_PN400, Bt_PN400, Bt_PN400, Bt_PN480, Bt_PN600, Bt_PNDVD};

U008 *Bt_NC[] =   // PAL NC
    {Bt_NC400, Bt_NC480, Bt_NC400, Bt_NC600, Bt_NC400, Bt_NC400, Bt_NC400, Bt_NC480, Bt_NC600, Bt_NCDVD};

//---------------------------------------------------------------------------------------
// Brooktree Centering tables
// Centering is NTSC-like (NTSC-M, NTSC-J, PAL-M) or PAL-like (PAL-BDGHI, PAL-N, PAL-NC).
// There are 2 sets of tables for 6 TV formats.
//    320x200   320x240    320x400    400x300    480x360    512x384    640x400    640x480    800x600
U008 *Btc_NM[] =    // NTSC M
    {Btc_NM200, Btc_NM240, Btc_NM3x4, Btc_NM300, Btc_NM360, Btc_NM384, Btc_NM400, Btc_NM480, Btc_NM600, Btc_NMDVD};

U008 *Btc_NJ[] =    // NTSC J
    {Btc_NM400, Btc_NM480, Btc_NM3x4, Btc_NM300, Btc_NM360, Btc_NM384, Btc_NM400, Btc_NM480, Btc_NM600, Btc_NMDVD};

U008 *Btc_PM[] =   // PAL M
    {Btc_NM200, Btc_NM480, Btc_NM3x4, Btc_NM300, Btc_NM360, Btc_NM384, Btc_NM400, Btc_NM480, Btc_NM600, Btc_NMDVD};

U008 *Btc_PA[] =   // PAL BDHGI
    {Btc_PA200, Btc_PA240, Btc_PA3x4, Btc_PA300, Btc_PA360, Btc_PA384, Btc_PA400, Btc_PA480, Btc_PA600, Btc_PADVD};

U008 *Btc_PN[] =   // PAL N
    {Btc_PA200, Btc_PA480, Btc_PA3x4, Btc_PA300, Btc_PA360, Btc_PA384, Btc_PA400, Btc_PA480, Btc_PA600, Btc_PADVD};

U008 *Btc_NC[] =   // PAL NC
    {Btc_PA200, Btc_PA480, Btc_PA3x4, Btc_PA300, Btc_PA360, Btc_PA384, Btc_PA400, Btc_PA480, Btc_PA600, Btc_PADVD};


//---------------------------------------------------------------------------------------
// Brooktree Autoconfig tables
//
// Bit 0 indicates NTSC/PAL
// Bits 5:4 indicate overscan ratio, but not in a consisent way (640x480 standard is 0 for PAL and 1 for NTSC, and lower is the reverse).
#define BTAN_640x400    0x08    //001000b
#define BTAN_640x480    0x10    //010000b
#define BTAN_800x600    0x12    //010010b
#define BTAN_1024x768   0x1a    //001010b
#define BTAP_640x400    0x09    //001001b
#define BTAP_640x480    0x01    //000001b
#define BTAP_800x600    0x13    //010011b
#define BTAP_1024x768   0x1b    //001011b

//              640x400  640x480  800x600  1024x768
U008 BTA[] = {  BTAN_640x400, BTAN_640x480, BTAN_800x600, BTAN_1024x768,
                BTAP_640x400, BTAP_640x480, BTAP_800x600, BTAP_1024x768
};
#define BTA_LEN sizeof(BTA)/2

// H Sync
U008 BTHS0[] = { 0x19, 0x19, 0xEB, 0x23,
                  0xAC, 0xAC, 0x2C, 0xEB };
U008 BTHS1[] = { 0x02, 0x02, 0x02, 0x02,
                  0x02, 0x02, 0x02, 0x02};
// Coring & Attenuation
U008 BTCA0[] = { 0xC3, 0xC3, 0xC3, 0xC3,
                  0xC3, 0xC3, 0xC3, 0xC3 };
U008 BTCA1[] = { 0xC2, 0xC2, 0xC2, 0xC2,
                  0xC2, 0xC2, 0xC2, 0xC2 };
// V Active & Lines
U008 BTVAL[] = { 0x06, 0x06, 0x0A, 0x0F,
                  0x06, 0x06, 0x0B, 0x0F };
// Flicker Filter
U008 BTFF0[] = { 0x1B, 0x1B, 0x1B, 0x00,
                  0x12, 0x12, 0x1B, 0x00 };
U008 BTFF1[] = { 0x9B, 0x9B, 0x80, 0x80,
                  0x9B, 0x9B, 0x80, 0x80 };
U008 BTFF2[] = { 0xC0, 0xC0, 0x92, 0xF6,
                  0xC0, 0xC0, 0x92, 0xF6 };

//
//  Chrontel strings
//

//  The I2C init string
U008    CH_Init[] = { 0xea, CH_REG_04, 0x05, CH_REG_06, 0x40, CH_REG_0D, 0x07, CH_REG_0E, 0x0B, CH_REG_1B, 0x20, CH_REG_1C, 0xC0, 0xff };

CH_string  CH_NULL_STRING = {   0xff    };

//  The I2C disable string
U008    CH_Disable[] = { 0xea, CH_REG_0D, 0x03, CH_REG_0E, 0x09, 0xff };

//  Flicker filter, Brightness, and Contrast.
U008    CH_FBC[] = { 0xea, CH_REG_01, CH_FF, CH_REG_09, CH_BL, CH_REG_11, CH_CE, 0xff };

//
// Chrontel I2C timing tables. All resolutions are multiples of these modes.
// Reg A is horizontal position; Reg B is vertical position
// DEVICE REG 0       REG 7       REG A       REG B       REG13, AUTOINC TO REG 15
CH_string  CH_NTSC320X200 =
{   0xea, CH_REG_00, 0x49, CH_REG_07, 0x70, CH_REG_0A, 0x34, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x0b, 0x16, 0xff };  // NTSC 320x200 (640x400)
CH_string  CH_NTSC320X240 =
{   0xea, CH_REG_00, 0x6a, CH_REG_07, 0x5C, CH_REG_0A, 0x2a, CH_REG_0B, 0x04, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3f, 0x7e, 0xff };  // NTSC 320x240 (640x480)
CH_string CH_NTSC400X300 =
{   0xea, CH_REG_00, 0x8d, CH_REG_07, 0x84, CH_REG_0A, 0x38, CH_REG_0B, 0xe8, CH_REG_13 | I2C_AUTOINC, 0x02, 0x59, 0x2E, 0xff };  // NTSC 400x300 (800x600)
CH_string  CH_NTSC480X360 =
{   0xea, CH_REG_00, 0x49, CH_REG_07, 0x70, CH_REG_0A, 0x34, CH_REG_0B, 0x16, CH_REG_13 | I2C_AUTOINC, 0x00, 0x0b, 0x16, 0xff };  // NTSC 480x360 (640x400) 
CH_string  CH_NTSC512X384 = 
//{   0xea, CH_REG_00, 0x09, CH_REG_07, 0xd4, CH_REG_0A, 0x0a, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x63, 0x16, 0xff };  // NTSC 512x384
{   0xea, CH_REG_00, 0x49, CH_REG_07, 0x70, CH_REG_0A, 0x48, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x0b, 0x16, 0xff };  // use NTSC 640x400 
CH_string  CH_NTSC640X400 =
{   0xea, CH_REG_00, 0x49, CH_REG_07, 0x70, CH_REG_0A, 0x34, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x0b, 0x16, 0xff };  // NTSC 640x400 mode 11
CH_string  CH_NTSC640X480 = 
{   0xea, CH_REG_00, 0x6A, CH_REG_07, 0x5c, CH_REG_0A, 0x2b, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3F, 0x7E, 0xff };  // NTSC 640x480 mode 17
CH_string  CH_NTSC720X576 = 
{   0xea, CH_REG_00, 0x8C, CH_REG_07, 0x84, CH_REG_0A, 0x2D, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x13, 0x3E, 0xff };  // NTSC 800x600 mode 24
CH_string  CH_NTSC800X600 = 
{   0xea, CH_REG_00, 0x8D, CH_REG_07, 0x84, CH_REG_0A, 0x3c, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x02, 0x59, 0x2E, 0xff };  // NTSC 800x600 mode 24

// PAL values 
CH_string  CH_PAL320X200 =
{   0xea, CH_REG_00, 0x40, CH_REG_07, 0xf0, CH_REG_0A, 0x30, CH_REG_0B, 0x08, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3d, 0x6c, 0xff };  // PAL 320x200 (640x400)
CH_string  CH_PAL320X240 =
{   0xea, CH_REG_00, 0x61, CH_REG_07, 0xc0, CH_REG_0A, 0x38, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x04, 0x09, 0xff };  // PAL 320x240 (640x480)
CH_string  CH_PAL400X300 = 
{   0xea, CH_REG_00, 0x83, CH_REG_07, 0x8c, CH_REG_0A, 0x40, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x21, 0x56, 0xff };  // PAL  800x600 (800x600)
CH_string  CH_PAL480X360 = 
{   0xea, CH_REG_00, 0x40, CH_REG_07, 0x5c, CH_REG_0A, 0x40, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3d, 0x6c, 0xff };  // PAL  480x360 (640x400)
CH_string  CH_PAL512X384 = 
{   0xea, CH_REG_00, 0x40, CH_REG_07, 0xc0, CH_REG_0A, 0x20, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3d, 0x6c, 0xff };  // PAL  512x384 (640x400)
CH_string  CH_PAL640X400 = 
{   0xea, CH_REG_00, 0x40, CH_REG_07, 0xee, CH_REG_0A, 0x30, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3d, 0x6c, 0xff };  // PAL  640x400 100
CH_string  CH_PAL640X480 = 
{   0xea, CH_REG_00, 0x61, CH_REG_07, 0x6e, CH_REG_0A, 0x34, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x04, 0x09, 0xff };  // PAL  640x480 101
CH_string  CH_PAL720X576 = 
{   0xea, CH_REG_00, 0x81, CH_REG_07, 0x84, CH_REG_0A, 0x2D, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x05, 0x39, 0x87, 0xff };  // PAL  720x576
CH_string  CH_PAL800X600 = 
{   0xea, CH_REG_00, 0x83, CH_REG_07, 0x7e, CH_REG_0A, 0x40, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x21, 0x56, 0xff };  // PAL  800x600 103

// FSCI data (subcarrier frequency adjustment). If reg 21 bit 0 is set, the subcarrier frequency is automatically selected.
U008 CH_FSCI_640x480[] = {0x02, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00 }; // mode 17
U008 CH_FSCI_720x576[] = {0x01, 0x0D, 0x09, 0x0C, 0x00, 0x04, 0x06, 0x0F }; // mode 23
U008 CH_FSCI_800x600[] = {0x01, 0x09, 0x08, 0x0B, 0x03, 0x0A, 0x06, 0x03 }; // mode 24
U008 CH_FSCI_640x480NC[] = {0x01, 0x0f, 0x00, 0x0d, 0x05, 0x04, 0x05, 0x0e }; // PAL NC 640x480
U008 CH_FSCI_720x576NC[] = {0x02, 0x06, 0x07, 0x09, 0x08, 0x0C, 0x00, 0x0C }; // mode 19
U008 CH_FSCI_800x600NC[] = {0x01, 0x09, 0x07, 0x08, 0x0e, 0x0f, 0x03, 0x05 }; // PAL NC 800x600
#define numFSCIbytes    sizeof CH_FSCI_640x480

//
//  NV4 TV adjustments for Chrontel
//
TV_ADJUST CHRONTEL_NTSC[] =
{
//   hRes  vRes  SR01  CR00  CR04  CR06  CR07  CR08  CR10  CR12  CR28  encoderStringPtr
    {320,  200,  0x09, 0x2b, 0x2b, 0x0c, 0x3e, 0x00, 0xc0, 0x8f, 0x98, (U008 *)(&CH_NTSC320X200) },
    {320,  240,  0x09, 0x2b, 0x2b, 0x3c, 0x3e, 0x40, 0xe4, 0xdf, 0x88, (U008 *)(&CH_NTSC320X240) },
    {400,  300,  0x09, 0x3d, 0x3d, 0x72, 0xf0, 0x20, 0x59, 0x57, 0x80, (U008 *)(&CH_NTSC400X300) },
    // 480x360 and 512x384 use 640x400 encoder mode 
    {480,  360,  0x01, 0x49, 0x40, 0x20, 0xB3, 0x00, 0x90, 0x67, 0x80, (U008 *)(&CH_NTSC480X360) }, 
    {512,  384,  0x01, 0x5b, 0x57, 0x3c, 0x3e, 0x00, 0xd0, 0x7f, 0x80, (U008 *)(&CH_NTSC512X384) },
    {640,  400,  0x01, 0x5b, 0x57, 0x3c, 0x3e, 0x00, 0xd0, 0x8f, 0x80, (U008 *)(&CH_NTSC640X400) },
    {640,  480,  0x01, 0x5f, 0x5e, 0x3c, 0x3e, 0x00, 0xe4, 0xdf, 0x80, (U008 *)(&CH_NTSC640X480) },
    {720,  576,  0x01, 0x70, 0x6f, 0x92, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_NTSC720X576) }, //LPL: unfinished
    {800,  600,  0x01, 0x76, 0x6f, 0xb8, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_NTSC800X600) },
};
//
TV_ADJUST  CHRONTEL_PAL[] =
{
//   hRes  vRes  SR01  CR00  CR04  CR06  CR07  CR08  CR10  CR12  CR28  encoderStringPtr
    {320,  200,  0x09, 0x2e, 0x29, 0x0c, 0x3e, 0x00, 0xc0, 0x8f, 0x98, (U008 *)(&CH_PAL320X200) },     
    {320,  240,  0x09, 0x2c, 0x2a, 0x3c, 0x3e, 0x00, 0xe4, 0xdf, 0x88, (U008 *)(&CH_PAL320X240) },     
    {400,  300,  0x09, 0x3c, 0x3c, 0xb0, 0xf0, 0x00, 0x57, 0x57, 0x80, (U008 *)(&CH_PAL400X300) },    
    // 480x360 and 512x384 use 640x400 encoder mode
    {480,  360,  0x01, 0x49, 0x48, 0xf0, 0xB2, 0x00, 0x90, 0x67, 0x80, (U008 *)(&CH_PAL480X360) },   
    {512,  384,  0x01, 0x75, 0x57, 0x0e, 0x3e, 0x00, 0xc0, 0x7f, 0x80, (U008 *)(&CH_PAL512X384) },     
    {640,  400,  0x01, 0x6a, 0x57, 0x0C, 0x3e, 0x00, 0xc0, 0x8f, 0x80, (U008 *)(&CH_PAL640X400) },    
    {640,  480,  0x01, 0x59, 0x56, 0x3c, 0x3e, 0x00, 0xe4, 0xdf, 0x80, (U008 *)(&CH_PAL640X480) },   
    {720,  576,  0x01, 0x6f, 0x6a, 0xb8, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_PAL720X576) },
    {800,  600,  0x01, 0x6f, 0x6a, 0xb8, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_PAL800X600) },  
};
    
//
//  adjustments for Brooktree 
//
// New method eliminates most of the table entries. Only VT needs to be table driven.
// Now we can use normal CRTC values, except HRS = HDE + 1, HT = HRS + 1.
// There are some exceptions to this (see programTV()).
U008    VT_BT_NTSC[] =
   // 320x200,320x240,320x400,400x300,480x360,512x384,640x400,640x480,800x600, DVD
    { 0xd3,   0x32,   0xc8,   0xac,   0xe4,   0x39,   0xca,   0x34,   0xac,    0x0D}; 
U008    VT_BT_PAL[] =
    { 0xf5,   0x42,   0xcf,   0xb6,   0xe8,   0x5a,   0xf4,   0x43,   0xb6,    0x54};


/*************************** Helper functions *******************************/

U008 dacTVReadModifyWrite
(
    PHWINFO pDev, 
    U032    Head,
    U008    Reg,
    U008    WriteData,
    U008    WriteMask
)
{
U008 ReadData, ack;

     // Read register
     i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) Reg); 
     i2cStart(pDev, Head, pDev->Dac.TVOutPortID); // Start w/o Stop = Restart
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
     i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &ReadData, 1);
     i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
     
     // Combine data and write
     WriteData &= WriteMask;   // just to be safe
     WriteData |= (ReadData & ~WriteMask);
     
     i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) Reg); 
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) WriteData); 
     i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
     
     return ReadData;
}

static U032 dacGetTVAdjustTableArray
(
    PHWINFO pDev,
    U032 Head,
    TV_ADJUST **adjustTablePtr
)
{
    U032  numEntries;

    numEntries = 0;
    if (TV_ENCODER_FAMILY(pDev->Dac.EncoderType) == TV_ENCODER_CHRONTEL)
    {
        // Chrontel encoder.
        switch (pDev->Dac.TVStandard)
        {
            // modes with NTSC CRTC timing
            case NTSC_M:
            case NTSC_J:
            case PAL_M:
                *adjustTablePtr = (TV_ADJUST *)&CHRONTEL_NTSC;
                numEntries = sizeof(CHRONTEL_NTSC) / sizeof(TV_ADJUST);
                break;
            // modes with PAL CRTC timing
            case PAL_A:
            case PAL_N:
            case PAL_NC:
                *adjustTablePtr = (TV_ADJUST *)&CHRONTEL_PAL;
                numEntries = sizeof(CHRONTEL_PAL) / sizeof(TV_ADJUST);
                break;
        }
    }
#if 0   // this style table lookup not used
    else
    {
        // Brooktree encoder.
        if (pDev->Dac.TVStandard == NTSC)
        {
            // NTSC 
            *adjustTablePtr = (TV_ADJUST *)&BROOKTREE_NTSC;
            numEntries = sizeof(BROOKTREE_NTSC) / sizeof(TV_ADJUST);
        }
        else
        {
            // PAL
            *adjustTablePtr = (TV_ADJUST *)&BROOKTREE_PAL;
            numEntries = sizeof(BROOKTREE_PAL) / sizeof(TV_ADJUST);
        }
    }
#endif

    return numEntries;
} // end of dacGetTVAdjustTableArray

static RM_STATUS dacGetI2CModeString
(
    PHWINFO pDev, 
    U032 Head,
    U032 hRes, 
    U032 vRes,
    U008 **encoderStringPtr
)
{
    U032 i, numEntries;
    TV_ADJUST * adjustTable;

    numEntries = dacGetTVAdjustTableArray(pDev, Head, &adjustTable);
    for (i = 0; i < numEntries; i++)
    {
        if (adjustTable[i].hRes == hRes &&
            adjustTable[i].vRes == vRes)
        {
            // found a match.
            *encoderStringPtr = adjustTable[i].encoderString;
            return RM_OK;
        }
    }

    // did not find a match.
    return RM_ERROR;
} // end of dacGetI2CModeString

static RM_STATUS dacGetTVAdjustTableEntry
(
    PHWINFO pDev,
    U032 Head,
    U032 hRes,
    U032 vRes,
    TV_ADJUST **adjustTableEntry
)
{
    U032 i, numEntries;
    TV_ADJUST * adjustTable;

    numEntries = dacGetTVAdjustTableArray(pDev, Head, &adjustTable);
    for (i = 0; i < numEntries; i++)
    {
        if (adjustTable[i].hRes == hRes &&
            adjustTable[i].vRes == vRes)
        {
            // found a match.
            *adjustTableEntry = &adjustTable[i];
            return RM_OK;
        }
    }

    // did not find a match.
    return RM_ERROR;
} // end of dacGetTVAdjustTableEntry

// Autoconfiguration requires writing a single register.
// The resolution, TV standard, and overscan ration is encapsulated in this mode number.
// Currently, only "standard" overscan is used. 
// Note: in order to get non-overscan modes for 640x480, we can't use autoconfig, so I've added discrete tables.
RM_STATUS dacProgramBrooktreeAuto(PHWINFO pDev, U032 Head)
{
    U032    hRes, vRes;
    U016    status = 0;
    U008    mode, config1, config2, autoConfigMode, *strptr, i;
    
    hRes = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
    vRes = pDev->Framebuffer.HalInfo.VertDisplayWidth;

    // generate an index into our mode table
    mode = 0; // not really needed but some compilers complain about uninitialized use

    switch (hRes) 
    {
        case 320:
            switch (vRes) 
            {
                case 200:
                    mode = 0;   // 640x400
                    break;
                case 240:
                    mode = 1;   // 640x480
                    break;
                default:
                    return RM_ERROR;
            }
            break;
        case 400:
            if (vRes == 300) 
                mode = 2; // 800x600
            else
                return RM_ERROR;
            break;
        case 480:
            if (vRes == 360) 
                mode = 1;   // 640x480
            else
                return RM_ERROR;
            break;
        case 512:
            if (vRes == 384) 
                mode = 3;   // 1024x768
            break;
        case 640:
            switch (vRes)
            {
                case 400:
                    mode = 0;   // 640x400
                    break;
                case 480:
                    mode = 1;
                    break;
                default:
                    return RM_ERROR;
            }
            break;
        case 800:
            if (vRes == 600) 
                mode = 2;
            else
                return RM_ERROR;
            break;
        case 1024:
            if (vRes == 768) 
                mode = 3;
            else
                return RM_ERROR;
            break;
        default:
            return RM_ERROR;
    }
    // 640x480 defaults to non-overscan, for which there is no autoconfig. Use tables.
    if (mode == 1) 
    {
        // Set the auto-config mode 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CONFIG);	// subaddress
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0);	// 
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
        
        // send an init string
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        strptr = (U008 *)&BT871_Init;          // send init sequence
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        for (i=0; *strptr != 0xff; i++)
        {
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
            if (status)
                break;
        }     
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C
        
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
            case NTSC_J:
                strptr = (U008 *)&Bt_NM480x;
                break;
            case PAL_NC:
            case PAL_A:
            case PAL_M:
            case PAL_N:
                strptr = (U008 *)&Bt_PA480x;                
                break;
            default:
                break;
        }
        
        // send a timing string
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        for (i=0; *strptr != 0xff; i++)
        {
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);
            if (status)
                break;
        }
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C
        
        // Toggle TIMING_RST
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);  
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x44);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C
        tmrDelay(pDev, 10000000);
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);  
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xC4);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C

    }
    else // do autoconfig
    {
        // Now adjust index for TV standard
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
            case NTSC_J:
                break;
            case PAL_NC:
            case PAL_A:
            case PAL_M:
            case PAL_N:
                mode += BTA_LEN;  // second row of table
                break;
            default:
                break;
        }
        autoConfigMode = BTA[mode];
        // The HW designer shoved a reserved bit into the middle of the config info.
        // I could account for this in the table, but I want my table to correspond to the values in the manual, and
        // if the reserved bit is ever used, we'll have to preserve it, so it's better to leave the table as is, and insert
        // into the config byte here.
        config1 = autoConfigMode & 0x07;
        config2 = autoConfigMode & 0x38;
        config2 <<= 1;   // put a 0 in bit 3
        autoConfigMode = config2 | config1;

        // Set the auto-config mode
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CONFIG);	// subaddress
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) autoConfigMode);	// 
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    }
    
    // Some adjustments
    // Hsync offset + width
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_HS0);	    // subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTHS0[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_HS1);	    // subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTHS1[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    // Coring + attenuation
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CA0);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTCA0[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CA1);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTCA1[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    // VActive + VLines
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_VAL);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTVAL[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    // Flicker Filter
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_FF0);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTFF0[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_FF1);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTFF1[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_FF2);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTFF2[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

    return(RM_OK);
}

//****************************************************************************************
//  Program the Brooktree device for a display mode
static RM_STATUS dacProgramBrooktree(PHWINFO pDev, U032 Head)
{
U016    i, status;
U008    *strptr, *strptr2;
U008    Data, TVmode;
#if 0
U032    hRes, vRes;
#endif

    status = RM_OK;

    // to send a string to the I2C: send the start sequence, send the string, send the stop sequence

    TVmode = dacGetTVmode(pDev, Head);
    // Turn DAC on
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);   // subaddress
    status |= i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008) BT_DAC_ON);    // DAC ON
    i2cStop(pDev, Head,  pDev->Dac.TVOutPortID);
    tmrDelay(pDev, 20000000);   // delay 20 ms to allow DAC to power up. If we don't wait, check status could give wrong input.
    
    // Use Autoconfiguration for 871
    if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871)
        return dacProgramBrooktreeAuto(pDev, Head);

    // send an init string
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
    strptr = (U008 *)&BT_Init;          // send init sequence
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    for (i=0; *strptr != 0xff; i++)
    {
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
        if (status)
            break;
    }     
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C

    // Get pointers to the strings to write to the I2C controller.
    // One string sets the timing for a particular resolution.
    // The other string sets the position (centering).
    switch (pDev->Dac.TVStandard)
    {
        case NTSC_M:
            strptr = (U008 *)Bt_NM[TVmode];
            strptr2 = (U008 *)Btc_NM[TVmode];
            break;
        case NTSC_J:
            strptr = (U008 *)Bt_NJ[TVmode];
            strptr2 = (U008 *)Btc_NJ[TVmode];
            break;
        case PAL_NC:
            strptr = (U008 *)Bt_NC[TVmode];
            strptr2 = (U008 *)Btc_NC[TVmode];
            break;
        case PAL_A:
            strptr = (U008 *)Bt_PA[TVmode];
            strptr2 = (U008 *)Btc_PA[TVmode];
            break;
        case PAL_M:
            strptr = (U008 *)Bt_PM[TVmode];
            strptr2 = (U008 *)Btc_PM[TVmode];
            break;
        case PAL_N:
            strptr = (U008 *)Bt_PN[TVmode];
            strptr2 = (U008 *)Btc_PN[TVmode];
            break;
        default:
            strptr = (U008 *)Bt_NM[TVmode];
            strptr2 = (U008 *)Btc_NM[TVmode];
            break;
    }
    // send a timing string
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
//  Try autoconfigure modes
#if 0
        hRes = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
        vRes = pDev->Framebuffer.HalInfo.VertDisplayWidth;
        if (hRes == 800)
        {
            strptr = (U008 *)&Bt_NM800;
        }
        if (hRes == 640)
        {
            strptr = (U008 *)&Bt_NM640;
        }
#endif
// end hack
    for (i=0; *strptr != 0xff; i++)
    {
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);
        if (status)
            break;
    }
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C

    // send a centering string
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    for (i=0; *strptr2 != 0xff; i++)
    {
        Data = *strptr2++;
        if (i == 1) // second byte is H Offset, which differs between NV4 and NV5
        {
            if(IsNV4(pDev))
            {
                // NV4 timing 8-16 pixels different, generally
                if (TVmode <= TV_MODE_400x300)
                    Data -= 16;
                else
                    Data -= 8; 
                switch (TVmode)
                {
                    case TV_MODE_400x300:
                        if ((pDev->Dac.TVStandard != NTSC_M) && (pDev->Dac.TVStandard != NTSC_J))
                            Data = 0x31;
                        break;
                    case TV_MODE_640x480:                                           
                        if ((pDev->Dac.TVStandard != NTSC_M) && (pDev->Dac.TVStandard != NTSC_J))
                            Data = 0xa2;
                        break;
                    case TV_MODE_800x600:
                        if ((pDev->Dac.TVStandard != NTSC_M) && (pDev->Dac.TVStandard != NTSC_J))
                            Data = 0x22;
                        else
                            Data = 0xd8;
                        break;
                    case TV_MODE_320x200:
                        if ((pDev->Dac.TVStandard != NTSC_M) && (pDev->Dac.TVStandard != NTSC_J))
                            Data = 0xca;
                        break;
                }
            }
        }
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, Data);
        if (status)
            break;
    }
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C

    // Set Check Status bit to tell encoder to check for TV connected.
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_STAT);   // set check stat
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

    // Set Estat to select status register 1
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0xC4);  // subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x41);  // set estat (estat 01 + en_out)
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

    // Read Monitor Status bits
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID+1));
    i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &Data, 1);
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

    // Reset Check Status -- not documented, but very important (can't program encoder if not done).
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_OFF);    // set check stat
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

    // Read registry to decide how to output on the S-video connector--do we use straight
    // S-video, or do we output composite?
    // DAC A is always composite out. DAC B and C are S-video (chroma and luma).
    // If the user has an S-video cable attached to a TV with composite input, we want
    // to output composite on the S-video (DAC C). We try to sense whether both 
    // B and C are loaded (S-video) or only C is loaded (composite).
    // Unfortunately, we may falsely detect composite even with an S-video monitor,
    // so the registry setting is necessary to override our detection.
    // Brooktree reg CE: D7  D6  D5  D4  D3  D2  D1  D0
    //                   MUX D   MUX C   MUX  B  MUX  A 
    // MUX n:   00 = output Video 0 on DAC n
    //          01 =              1
    //          10 =              2
    //          11 =              3
    // Our default init is 18 -- DAC A = mode 0, DAC B = mode 2, DAC C = mode 1
    // DAC A is always set to composite out (mode 0), which has a value of 0.
    switch (pDev->Dac.TVoutput)
    {
        case NV_CFG_VIDEO_OUTPUT_FORMAT_AUTOSELECT:
            if ((Data & BT_MONSTAT) == BT_MONSTAT_C)    // Stat A, B, C
            {
                // Set composite out on B if DAC C only is loaded.
                // Set DAC C to output composite.
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
                // mode 2 on DAC B,  mode 0 on DAC C
                status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (BT_OUT_MUX_B_COMP | BT_OUT_MUX_C_COMP));
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }
            else
            {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
                // mode 2 on DAC B, mode 1 on DAC C
                status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL));    
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }
            break;
        case NV_CFG_VIDEO_OUTPUT_FORMAT_FORCE_COMPOSITE:
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (BT_OUT_MUX_B_COMP | BT_OUT_MUX_C_COMP));   
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
        case NV_CFG_VIDEO_OUTPUT_FORMAT_FORCE_SVIDEO:
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL));    
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
        default:
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL);  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
    }

    // If no head is using TV, blank image.
    for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
        if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
            break;
    if (i == pDev->Dac.HalInfo.NumCrtcs)
        dacDisableTV(pDev, Head);

    return (status);
} // end of dacProgramBrooktree

//****************************************************************************************
//
//  Program the Chrontel device for a display mode
//  args:       internal TV mode
//  returns:    status word
static RM_STATUS dacProgramChrontel(PHWINFO pDev, U032 Head)
{    
    RM_STATUS status;
    U016    i;
    U008    *strptr, FsciReg, read;
    U032    hRes, vRes;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
   
    if (pDev->Dac.EncoderType == NV_ENCODER_NONE) 
    {
        // Used to check for known Chrontel types. Checking in dacinit now, this is probably useless.
        return ERR_I2C_UNKNOWN;
    }
    status = RM_OK;
    // to send a string to the I2C: send the start sequence, send the string, send the stop sequence
    // Chrontel 7007 wants bit 7 of the register address set (on others it's a don't care).
        
    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

    // power up
    dacEnableTV(pDev, Head);
    
    // send an init string
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    strptr = (U008 *)&CH_Init;     // send init sequence
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
        if (status)
            break;
    }     
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C

    // get a pointer to the string to write to the I2C controller
    status = dacGetI2CModeString(pDev, Head, hRes, vRes, &strptr);
    if (status)
    {
        // could not get the encoder string for this mode.
        return ERR_I2C_MODE;
    }
            
    // send a timing string
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
//        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, " ", *strptr);
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);
        if (status)
            break;
    }
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C

    // send default flicker filter, brightness, and contrast
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    strptr = (U008 *)&CH_FBC;
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);
        if (status)
            break;
    }
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C
    
    // Set register 21 for PAL/NTSC, and reg 3 for mode 24 (800x600 NTSC)
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    
    // Reg 3 bit 7 set for mode 24 only. (Flicker filter used in 7/10 scaling modes)
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_03); // reg 3 
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x00); // 
    
    switch (pDev->Dac.TVStandard) // not supporting scaling on PAL. What happens on NTSC unscaled modes?
    {
        case NTSC_J:
        case NTSC_M:
            if ((hRes == 800) || (hRes == 720) || ((hRes == 640) && (vRes == 480)))
            {
                // 800x600 & 640x480 modes use programmed FSCI values (subcarrier frequency), others use subcarrier free-run
                // set carrier free-run bit in reg 6 and clear ACIV bit in reg 21

                // set carrier free-run bit
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // 
                read |= CH_CFR;                                             // set carrier freerun
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
                
                // Clear ACIV bit            
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_21); // reg 21
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x00); 
                
                if (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 800) // mode 24 needs this bit set. What about modes 22 & 23?
                {
                    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_03); // reg 3 
                    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x80); // 
                
                    strptr = (U008 *)&CH_FSCI_800x600;
                    FsciReg = CH_REG_18; // starting at reg 0x18
                    for (i=0; i<numFSCIbytes; i++) 
                    {
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, FsciReg++); // reg
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  // FSCI value
                    }
                }
                if (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 720) // mode 23
                {
                    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_03); // reg 3 
                    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x80); // 
                
                    strptr = (U008 *)&CH_FSCI_720x576;
                    FsciReg = CH_REG_18; // starting at reg 0x18
                    for (i=0; i<numFSCIbytes; i++) 
                    {
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, FsciReg++); // reg
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  // FSCI value
                    }
                }
                if (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 640) // write FSCI
                {
                    strptr = (U008 *)&CH_FSCI_640x480;
                    FsciReg = CH_REG_18; // starting at reg 0x18
                    for (i=0; i<numFSCIbytes; i++) 
                    {
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, FsciReg++); // 
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++); // 
                    }
                }
            }
            else    // Other NTSC modes use subcarrier free run
            {
                // set ACIV 
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_21); // reg 21
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, 0x01); // reg 21 bit 0 = 1 -> automatically increment subcarrier
                i2cStop(pDev, Head,  pDev->Dac.TVOutPortID);                       // end state for I2C

                // clear carrier free-run bit when in ACIV mode
                i2cStart(pDev, Head,  pDev->Dac.TVOutPortID);                      // start state for I2C
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
                i2cStart(pDev, Head,  pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                i2cReceiveByte(pDev, Head,  pDev->Dac.TVOutPortID, &read,1);
                i2cStop(pDev, Head,  pDev->Dac.TVOutPortID);                       // 
                read &= ~CH_CFR;                                            // clear carrier freerun
                i2cStart(pDev, Head,  pDev->Dac.TVOutPortID);                      // start state for I2C
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, read);  
            }
            break;
        case PAL_NC:
            // set carrier free-run bit
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // 
            read |= CH_CFR;                                             // set carrier freerun
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  

            // Clear ACIV bit            
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_21); // reg 21
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x00); 
            switch (hRes) 
            {
                case 640:
                case 320:
                    strptr = (U008 *)&CH_FSCI_640x480NC;
                break;
                case 720:
                    strptr = (U008 *)&CH_FSCI_720x576NC;
                break;
                case 800:
                case 400:
                    strptr = (U008 *)&CH_FSCI_800x600NC;
                break;
                default:
                    strptr = (U008 *)&CH_FSCI_640x480NC;    // 512x384 will fit in 640x480
            }
            FsciReg = CH_REG_18; // starting at reg 0x18
            for (i=0; i<numFSCIbytes; i++) 
            {
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, FsciReg++); // 
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++); // 
            }
            break;
        default:
        {
            // set ACIV 
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_21); // reg 21
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x01); // reg 21 bit 0 = 1 -> automatically increment subcarrier
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C

            // clear carrier free-run bit when in ACIV mode
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // 
            read &= ~CH_CFR;                                            // clear carrier freerun
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
        }
    }
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C
    
    // Set gain of DAC. Read/modify/write reg 4. NTSC-M and PAL-M use one level, all others use another level.
    switch (pDev->Dac.TVStandard) 
    {
        case NTSC_M:
        case PAL_M:
        {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // reg 4
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
            read &= CH_GAIN;                                            // set GAIN bits
            read |= CH_GAIN_NTSC;
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // reg 4
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
            break;
        }
        default:
        {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // reg 4
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
            read &= CH_GAIN;                                            // set GAIN bits
            read |= CH_GAIN_PAL;
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // reg 4
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
        }
    }
    // Default TV standards (in Chrontel reg 0) is 00 (PAL) or 01 (NTSC). There are 2 bits, so 4 combinations.
    // PAL B, D, G, H, I, N, NC = 00
    // NTSC-M                   = 01
    // PAL-M                    = 10
    // NTSC-J                   = 11
    
    // Set special TV standards
    if (pDev->Dac.TVStandard == NTSC_J) 
    {
        // NTSC-J should have reg 0[4:3] = 11
        // Read/Modify/Write reg 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_00); // reg 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
        read |= CH_NTSC_J;                                          // set NTSC-J bits
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_00); // reg 0
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
        
        // Brightness range for NTSC-J is wider
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_09); // reg 9
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_BL_J);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
    
    }
    if (pDev->Dac.TVStandard == PAL_M) 
    {
        // PAL-M should have reg 0[4:3] = 10. 
        // Read/Modify/Write reg 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_00); // reg 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
        read &= 0xe7;                                               // mask bits 4:3
        read |= CH_PAL_M;                                           // set PAL_M bits
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_00); // reg 0
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
    }

    return (status);
} // end of dacProgramChrontel

//****************************************************************************************
RM_STATUS dacSendEncoderString(PHWINFO pDev, U032 Head, U008 *strptr, U016 len)
{
RM_STATUS status;
U016 i;

    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    for (i=0; i<len; i++)
    {
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
        if (status)
            break;
    }     
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C
    return (status);
}

//****************************************************************************************
//
//  Program the Philips device for a display mode
//  args:       internal TV mode
//  returns:    status word
static RM_STATUS dacProgramPhilips(PHWINFO pDev, U032 Head)
{    
    RM_STATUS status;
    U032    hRes, vRes;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    // to send a string to the I2C: send the start sequence, send the string, send the stop sequence

    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

    // Send the init strings
    // Each string is a block of consecutive registers, some blocks are unique to the TV standard.
    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_Gen_Init0, Ph_Gen_Init0_Len);
    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_Gen_Init1, Ph_Gen_Init1_Len);
    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_Gen_Init2, Ph_Gen_Init2_Len);

    switch (pDev->Dac.TVStandard)
    {
        case NTSC_M:
        case NTSC_J:
            // Do NTSC init
            status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_Init0, Ph_NTSC_Init0_Len);
            status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_Init1, Ph_NTSC_Init1_Len);
            // Program the resolution    
            switch (hRes)
            {
                case 320:
                case 640:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_640, Ph_NTSC_Res_Len);
                    break;        
                case 400:
                case 800:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_800, Ph_NTSC_Res_Len);
                    break;
                default:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_640, Ph_NTSC_Res_Len);
            }            
            break;        
        break;

        case PAL_M:
        case PAL_A:
        case PAL_N:
        case PAL_NC:
            // Do PAL init
            status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_Init0, Ph_PAL_Init0_Len);
            status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_Init1, Ph_PAL_Init1_Len);
            // Program the resolution    
            switch (hRes)
            {
                case 320:
                case 640:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_640, Ph_PAL_Res_Len);
                    break;        
                case 400:
                case 800:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_800, Ph_PAL_Res_Len);
                    break;
                default:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_640, Ph_PAL_Res_Len);
            }            
            break;
        break;
    }
    return (status);
} // end of dacProgramPhilips

//*************************** Exported functions *****************************************
//
//  Program the I2C device for a display mode
//  returns:    status word
RM_STATUS dacSetupTVEncoder(PHWINFO pDev, U032 Head)   
{
    RM_STATUS status;

    // Identify which part: Chrontel or Brooktree?
    // ID was done at dacInit.
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_NONE:
            status = ERR_I2C_UNKNOWN;
            break;                        
        case TV_ENCODER_BROOKTREE:
            i2cInit(pDev, Head, pDev->Dac.TVOutPortID);
            status = dacProgramBrooktree(pDev, Head);
            break;
        case TV_ENCODER_CHRONTEL:
            i2cInit(pDev, Head, pDev->Dac.TVOutPortID);
            status = dacProgramChrontel(pDev, Head);
            break;                        
        case TV_ENCODER_PHILIPS:
            i2cInit(pDev, Head, pDev->Dac.TVOutPortID);
            status = dacProgramPhilips(pDev, Head);
            break;                        
        default:
            status = ERR_I2C_UNKNOWN;
            break;                        
    }
    return (status);
}

RM_STATUS dacAdjustCRTC_CH(PHWINFO pDev, U032 Head)
{
    RM_STATUS status;
    U008    data, hbeAdjust;
    U016    data16;
    TV_ADJUST * adjustEntry;

    // Look up the array of CRTC adjustments for Chrontel
    status = dacGetTVAdjustTableEntry(pDev,Head,
                                      pDev->Framebuffer.HalInfo.HorizDisplayWidth,
                                      pDev->Framebuffer.HalInfo.VertDisplayWidth,
                                      &adjustEntry);
    if (status)
    {
        // did not find a match.
        return status;
    }
    switch (pDev->Dac.TVStandard)
    {
        case NTSC_M:
        case NTSC_J:
        case PAL_M:
            if (pDev->Framebuffer.HalInfo.VertDisplayWidth != 576) {
            CRTC_WR(NV_CIO_CR_HDT_INDEX, adjustEntry->CR00, Head);
            CRTC_WR(NV_CIO_CR_HRS_INDEX, adjustEntry->CR04, Head);
            CRTC_WR(NV_CIO_CR_VDT_INDEX, adjustEntry->CR06, Head);
            CRTC_WR(NV_CIO_CR_OVL_INDEX, adjustEntry->CR07, Head);
            CRTC_WR(NV_CIO_CR_RSAL_INDEX, adjustEntry->CR08, Head);
            CRTC_WR(NV_CIO_CR_VRS_INDEX, adjustEntry->CR10, Head);
            CRTC_WR(NV_CIO_CR_VDE_INDEX, adjustEntry->CR12, Head);
            if (IsNV4(pDev))    // NV4 timing is slightly different
            {
                if (pDev->Framebuffer.HalInfo.VertDisplayWidth == 240) 
                    CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0x60, Head);
                if  (pDev->Framebuffer.HalInfo.VertDisplayWidth == 300)
                    CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0x40, Head);
            }
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);      // read pixel format
            data |= adjustEntry->CR28;        // OR with horizontal pixel adjust and slave TV to encoder
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);

            // write Seq 01
            WriteIndexed(NV_PRMVIO_SRX, (U016) ((adjustEntry->SR01 << 8) | NV_PRMVIO_SR_CLOCK_INDEX));         
            }
            break;

        case PAL_A:
        case PAL_N:
        case PAL_NC:
            CRTC_WR(NV_CIO_CR_HDT_INDEX, adjustEntry->CR00, Head);
            CRTC_WR(NV_CIO_CR_HRS_INDEX, adjustEntry->CR04, Head);
            CRTC_WR(NV_CIO_CR_VDT_INDEX, adjustEntry->CR06, Head);
            CRTC_WR(NV_CIO_CR_OVL_INDEX, adjustEntry->CR07, Head);
            CRTC_WR(NV_CIO_CR_RSAL_INDEX, adjustEntry->CR08, Head);
            CRTC_WR(NV_CIO_CR_VRS_INDEX, adjustEntry->CR10, Head);
            CRTC_WR(NV_CIO_CR_VDE_INDEX, adjustEntry->CR12, Head);
            if (IsNV4(pDev))    // NV4 timing is slightly different
            {
                if ((pDev->Framebuffer.HalInfo.VertDisplayWidth == 200) ||
                    (pDev->Framebuffer.HalInfo.VertDisplayWidth == 240) ||
                    (pDev->Framebuffer.HalInfo.VertDisplayWidth == 300) ||
                    (pDev->Framebuffer.HalInfo.VertDisplayWidth == 384))
                    CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0x20, Head);
                if (pDev->Framebuffer.HalInfo.VertDisplayWidth == 480)
                    CRTC_WR(NV_CIO_CR_HRS_INDEX, adjustEntry->CR04 + 1, Head);
            }
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);      // read pixel format
            data |= adjustEntry->CR28;           // OR with horizontal pixel adjust and slave TV to encoder
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);

            // write Seq 01
            WriteIndexed(NV_PRMVIO_SRX, (U016) ((adjustEntry->SR01 << 8) | NV_PRMVIO_SR_CLOCK_INDEX));         
            break;
    }
    if (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 320)
    {
        // adjust HBE = HT. This lets the cursor move across the whole screen.
        CRTC_RD(NV_CIO_CR_HDT_INDEX, data16, Head);           // get HT (CR0)
        CRTC_RD(NV_CIO_CR_HBE_INDEX, data, Head);             // CR03
        data &= ~0x1f;                                  // lose the HBE bits
        data |= (U008) data16 & 0x1F;
        CRTC_WR(NV_CIO_CR_HBE_INDEX, data, Head);             // HBE 4:0
        pDev->Framebuffer.CursorAdjust = 8;
    }
    else
    {
        if (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 400)
        {
            // 400x300
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);          // get CR28
            data &= ~0x38;
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data | (5<<3), Head); // bits[5:3] shift 5 pixels right        
            pDev->Framebuffer.CursorAdjust = 0;
            if (pDev->Dac.TVStandard == NTSC)   // PAL 400x300 requires special case for HBE for cursor position
                hbeAdjust = 4;
            else                
                hbeAdjust = 2;
        }
        else
        {
            pDev->Framebuffer.CursorAdjust = 5;
            hbeAdjust = 4;
        }
        // adjust HBE = HT + 4. This lets the cursor move across the whole screen.
        CRTC_RD(NV_CIO_CR_HDT_INDEX, data16, Head);           // get HT (CR0)
        CRTC_RD(NV_CIO_CRE_HEB__INDEX, data, Head);           // MS bit HT (CR2D)            
        if (data & 1)
            data16 |= 0x100;
        data16 += hbeAdjust;                            // HT effective
    
        CRTC_RD(NV_CIO_CR_HBE_INDEX, data, Head);             // CR03
        data &= ~0x1f;                                  // lose the HBE bits
        data |= (U008) data16 & 0x1F;
        CRTC_WR(NV_CIO_CR_HBE_INDEX, data, Head);             // HBE 4:0

        CRTC_RD(NV_CIO_CR_HRE_INDEX, data, Head);             // CR05
        data &= ~0x80;                                  // lose the HBE bit
        if (data16 & 0x20)
            data |= 0x80;
        CRTC_WR(NV_CIO_CR_HRE_INDEX, data, Head);             // HBE 5
                            
        CRTC_RD(NV_CIO_CRE_LSR_INDEX, data, Head);            // CR25
        data &= ~0x10;
        if (data16 & 0x40)
            data |= 0x10;
        CRTC_WR(NV_CIO_CRE_LSR_INDEX, data, Head);            // HBE 6
    }
    // adjust normally scanline doubled modes which are not doubled for TV
    // (512x384 and 480x360)
    if (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 512 ||   // 512x384
        pDev->Framebuffer.HalInfo.HorizDisplayWidth == 480)     // 480x360
    {
        CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, 0x40, Head);
    }
    if (!IsNV4(pDev))
        pDev->Framebuffer.CursorAdjust = 0; // cursor adjust not needed 

    return status;
}

RM_STATUS dacAdjustCRTC_BT(PHWINFO pDev, U032 Head)
{
RM_STATUS status = RM_OK;
U008    tvmode, data;
U016    data16;

        // Use the "TV mode number" lookup method
        tvmode = dacGetTVmode(pDev, Head);

        // adjust normally scanline doubled modes which are not doubled for TV
        if ((tvmode == TV_MODE_512x384) | (tvmode == TV_MODE_480x360))
            CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, 0x40, Head);

        if (tvmode <= TV_MODE_400x300)
            WriteIndexed(NV_PRMVIO_SRX, 0x901); // dot clock /2 for low res modes

        // Horizontal adjustment is very simple: HT = HDE + 2, HRS = HDE + 1
        CRTC_RD(NV_CIO_CR_HDE_INDEX, data, Head);           // get HDE
        CRTC_WR(NV_CIO_CR_HRS_INDEX, data + 1, Head);       // write HRS
        if (tvmode == TV_MODE_400x300)  // 400x300 is a special case
            data += 1;
        else
            data += 2;
        CRTC_WR(NV_CIO_CR_HDT_INDEX, data, Head);   // write HT=DE+2
        
        // NV10 makes us do some more special casing. The reason is that the video overlay
        // syncs to the CRTC differntly. Instead of using display end, it syncs off the blank
        // signal, so we have to make an adjustment to HBE.
        // We'll also add offsets via PVIDEO_POINT_OUT (see class63 for NV10).
        if (IsNV10orBetter(pDev)) 
        {
            if (tvmode == TV_MODE_640x480)
            {
                CRTC_WR(NV_CIO_CR_HBE_INDEX, 0x95, Head);       // write HBE
                CRTC_WR(NV_CIO_CR_HRE_INDEX, 0x1F, Head);       // write HBE msb
            }
            if (tvmode == TV_MODE_800x600)
            {
                CRTC_WR(NV_CIO_CR_HBE_INDEX, 0x89, Head);       // write HBE
                CRTC_WR(NV_CIO_CR_HRE_INDEX, 0x9A, Head);       // write HBE msb
            }
        }
        // Vertical total must be adjusted per resolution
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
            case NTSC_J:
            case PAL_M:
                CRTC_WR(NV_CIO_CR_VDT_INDEX, VT_BT_NTSC[ tvmode ], Head);
                break;              
            case PAL_A:
            case PAL_N:
            case PAL_NC:
                CRTC_WR(NV_CIO_CR_VDT_INDEX, VT_BT_PAL[ tvmode ], Head);
                break;
            default:
                CRTC_WR(NV_CIO_CR_VDT_INDEX, VT_BT_NTSC[ 0 ], Head);    // default to NTSC_M
        }
        if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871)
        {
            if (tvmode == TV_MODE_640x480)
            {
                // Adjust CRTC vertical
                CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x18, Head);
                CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xF6, Head);
            }
            if (tvmode == TV_MODE_800x600)
            {
                // Adjust CRTC vertical
                CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xB6, Head);
            }
            if (tvmode == TV_MODE_1024x768)
            {
                CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x83, Head);
            }
        }
        if (tvmode == TV_MODE_480x360)  // a special case
        {
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0xe806);     // VT
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0xb207);     // extra bits
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x9010);     // VRS
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x6712);     // VDE
        }
        if (tvmode == TV_MODE_512x384)  // another special case
        {
            // On a monitor, the vertical is 768, scan doubled.
            // On the TV, we want 384.
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x7f12);     // VDE
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0xb707);     // extra bits
        }
        // NV4 has a hw bug which requires adjustment to the cursor position
        if (IsNV4(pDev))
        {
            // adjust HBE = HT + 4. This lets the cursor move across the whole screen.
            CRTC_RD(NV_CIO_CR_HDT_INDEX, data16, Head);           // get HT (CR0)
            CRTC_RD(NV_CIO_CRE_HEB__INDEX, data, Head);           // MS bit HT (CR2D)            
            if (data & 1)
                data16 |= 0x100;
            data16 += 4;                                    // HT effective

            CRTC_RD(NV_CIO_CR_HBE_INDEX, data, Head);             // CR03
            data &= ~0x1f;                                  // lose the HBE bits
            data |= (U008) data16 & 0x1F;
            CRTC_WR(NV_CIO_CR_HBE_INDEX, data, Head);             // HBE 4:0

            CRTC_RD(NV_CIO_CR_HRE_INDEX, data, Head);             // CR05
            data &= ~0x80;                                  // lose the HBE bit
            if (data16 & 0x20)
                data |= 0x80;
            CRTC_WR(NV_CIO_CR_HRE_INDEX, data, Head);             // HBE 5
                            
            CRTC_RD(NV_CIO_CRE_LSR_INDEX, data, Head);            // CR25
            data &= ~0x10;
            if (data16 & 0x40)
                data |= 0x10;
            CRTC_WR(NV_CIO_CRE_LSR_INDEX, data, Head);            // HBE 6
            switch (tvmode)
            {
                // modes which are shoehorned in to 640x400 need a horiz cursor adjustment
                case TV_MODE_512x384:
                case TV_MODE_480x360:
                // likewise 640 modes
                case TV_MODE_640x400:
                case TV_MODE_640x480:
                case TV_MODE_800x600:
                    pDev->Framebuffer.CursorAdjust = 5;
                    break;          
                default:
                    pDev->Framebuffer.CursorAdjust = 0;
            }
        }
        return status;
} 


RM_STATUS dacAdjustCRTC_PH(PHWINFO pDev, U032 Head)
{
    RM_STATUS status = RM_OK;

    // No tables. No formula. 
    switch (pDev->Framebuffer.HalInfo.HorizDisplayWidth)
    {
        case 320:
            WriteIndexed(NV_PRMVIO_SRX, 0x901); // dot clock /2 for low res modes
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x27, Head);   // CR0
            break;
        case 400:
            WriteIndexed(NV_PRMVIO_SRX, 0x901); // dot clock /2 for low res modes
            break;
        case 640:
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x54, Head);   // CR0
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x52, Head);   // CR4
            break;
        case 800:
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x6A, Head);   // CR0
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x68, Head);   // CR4
            break;
        default:
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x54, Head);   // CR0
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x52, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x30, Head); // CR6
            break;
    }
    switch (pDev->Framebuffer.HalInfo.VertDisplayWidth)
    {
        case 200:
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xDE, Head); // CR6
            break;
        case 400:
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xDC, Head); // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0x90, Head); // CR10 moves display down a few lines
            break;
        case 240:
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x2C, Head); // CR6
            break;
        case 480:
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x30, Head); // CR6
            break;
        case 600:
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xAC, Head); // CR6
            break;
    }
    switch (pDev->Dac.TVStandard )
    {
        case NTSC_M:
        case NTSC_J:
            break;        
        case PAL_M:
        case PAL_A:
        case PAL_N:
        case PAL_NC:
            if (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 800)
                CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xa8, Head); // CR6
            break;    
    }
    return status;
}

RM_STATUS dacAdjustCRTCForTV(PHWINFO pDev, U032 Head)
{
    U008    data;

    // slave the CRTC clock to the encoder
    CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x20, Head);     // if TV, we can fix low water mark at 20.
    CRTC_RD(0x33, data, Head);
    data &= 0xfe;       // slave to the TV encoder
    CRTC_WR(0x33, data, Head);

    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);
    data |= 0x80;       // slave mode
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);

    //  fix up CRTC timing per encoder
    //  NOTE: Brooktree and Chrontel have incompatible CRTC and encoder tables.
    //  Until this is resolved, this code is going to be ugly.
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_CHRONTEL:
            dacAdjustCRTC_CH(pDev, Head);
            break;
        case TV_ENCODER_BROOKTREE: 
            dacAdjustCRTC_BT(pDev, Head);
            break;
        case TV_ENCODER_PHILIPS:
            dacAdjustCRTC_PH(pDev, Head);
            break;
        default:
            return RM_ERROR;
    }        
    // Fix the video scalar vertical on NV4. Also allows full range of cursor movement.
    if(IsNV4(pDev))
    {
        // adjust VBE = VT. This adjusts the position of the video scalar window.
        CRTC_RD(NV_CIO_CR_VDT_INDEX, data, Head);             // CR6
        // 7 bits of CR16 are used
        CRTC_WR(NV_CIO_CR_VBE_INDEX, data, Head);             // CR16
    }
    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);              // get CR28
    data &= ~0x38;
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);              // clear the pixel shift 

    if (pDev->Framebuffer.HalInfo.HorizDisplayWidth <= 400)    // if clock doubling
    {
        // Clock doubled mode
//        DAC_REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, 0x01030700, Head);   
        if (Head == 0) 
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _TVCLK_RATIO, _DB2);
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK_RATIO, _DB1);
        }
        else
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _TVCLK_RATIO, _DB2);
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK2_RATIO, _DB1);
        }
    }
    else
    {
        // Normal clock mode
//        DAC_REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, 0x10030700, Head);
        if (Head == 0) 
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _TVCLK_RATIO, _DB1);
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK_RATIO, _DB1);
        }
        else
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _TVCLK_RATIO, _DB1);
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK2_RATIO, _DB1);
        }
    }
    // Set source of PCLK and VSCLK to be TV encoder
    if (Head == 0) 
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK_TV, _BOTH);
    }
    else
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK2_TV, _BOTH);
    }
    // setup the DAC as the master
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TV_SETUP, _DEV_TYPE, _MASTER, Head);
    return RM_OK;
} // end of dacProgramTV

// Chrontel and Brooktree tables are incompatible
// Until we have a uniform way to deal with this, we'll use the "mode number"
// method for Brooktree (ala release 2) and the table lookup for Chrontel.
// This function is for Brooktree only.
U008 dacGetTVmode(PHWINFO pDev, U032 Head)
{
U032    hRes, vRes;
U008    TVmode;
PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

        // Get resolution
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
        hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
        vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
        
        // Assign a mode number based on the resolution
        switch (hRes)
        {
            case 320:
                if (vRes == 200)
                    TVmode = TV_MODE_320x200;
                else
                    TVmode = TV_MODE_320x240;
                break;
            case 400:
                TVmode = TV_MODE_400x300;
                break;
            case 480:
                TVmode = TV_MODE_480x360;
                break;
            case 512:
                TVmode = TV_MODE_512x384;
                break;
            case 640:
                if (vRes == 400)
                    TVmode = TV_MODE_640x400;
                else
                    TVmode = TV_MODE_640x480;
                break;
            case 800:
                TVmode = TV_MODE_800x600;
                break;
            case 720:
            case 704:
                TVmode = TV_MODE_DVD;
                break;
            case 1024:
                TVmode = TV_MODE_1024x768;
                break;
            default:
                TVmode = TV_MODE_640x480;
                break;
        }
        return TVmode;
}

//  Return the default register values for position, brightness, contrast and flicker filter.
VOID dacGetDefaultTVPosition
(
    PHWINFO pDev,
    U032    Head,
    U032    EncoderId,
    U008    Default,
    U032    *encoderParms
)
{
    U008    Cr07, Cr25;
    U032    Hrs, Hre, Vrs, Vre;
    U008    TVmode;
    U032    hRes, vRes;
    U008   *strptr;
    RM_STATUS status;
        
    if (EncoderId & TV_ENCODER_BROOKTREE)
    {
        PARAMS_BROOKTREE *regsBt;
        BT_MODE_REGS *pReg;
        BT_INIT_REGS *pRegI;

        // Get default parameters from tables
        TVmode = dacGetTVmode(pDev, Head);
        regsBt = (PARAMS_BROOKTREE *)encoderParms;

        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
                strptr = (U008 *)Bt_NM[TVmode];
                break;
            case NTSC_J:
                strptr = (U008 *)Bt_NJ[TVmode];
                break;
            case PAL_NC:
                strptr = (U008 *)Bt_NC[TVmode];
                break;
            case PAL_A:
                strptr = (U008 *)Bt_PA[TVmode];
                break;
            case PAL_M:
                strptr = (U008 *)Bt_PM[TVmode];
                break;
            case PAL_N:
                strptr = (U008 *)Bt_PN[TVmode];
                break;
            default:
                strptr = (U008 *)Bt_NM[TVmode];
            break;
        }
        pReg = (BT_MODE_REGS *) strptr;
        regsBt->reg0x80 = pReg->reg0x80;
        regsBt->reg0x82 = pReg->reg0x82;
        regsBt->reg0x92 = pReg->reg0x92;
        regsBt->reg0x98 = pReg->reg0x98;
        regsBt->reg0x9A = pReg->reg0x9A;
        if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871)
            pRegI = (BT_INIT_REGS *) &BT871_Init;
        else
            pRegI = (BT_INIT_REGS *) &BT_Init;
        regsBt->reg0xC8 = pRegI->reg0xC8;
        regsBt->reg0xCA = pRegI->reg0xCA;
        regsBt->reg0xCC = pRegI->reg0xCC;

        // Construct Horizontal Retrace Start, End, and Vertical Retrace Start, End
        CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
        CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);

        // Construct Hrs
        CRTC_RD(NV_CIO_CR_HRS_INDEX, Hrs, Head);

        // Construct Hre
        CRTC_RD(NV_CIO_CR_HRE_INDEX, Hre, Head);
        Hre = Hrs + ( ((short)Hre - (short)Hrs) & BITS0_4 );

        // Construct Vrs
        CRTC_RD(NV_CIO_CR_VRS_INDEX, Vrs, Head);
        if (Cr25 & BIT2)
            Vrs |= BIT10;
        if (Cr07 & BIT7)
            Vrs |= BIT9;
        if (Cr07 & BIT2)
            Vrs |= BIT8;

        // Construct Vre
        CRTC_RD(NV_CIO_CR_VRE_INDEX, Vre, Head);
        Vre = Vrs + ( ((short)Vre - (short)Vrs) & BITS0_3 );

        regsBt->HRetraceStart = Hrs;        
        regsBt->HRetraceEnd = Hre;      
        regsBt->VRetraceStart = Vrs;        
        regsBt->VRetraceEnd = Vre;      
    }
    if (EncoderId & TV_ENCODER_CHRONTEL)
    {
        PARAMS_CHRONTEL *regsCh;
        PCH_string  pReg;

        regsCh = (PARAMS_CHRONTEL *)encoderParms;

        hRes = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
        vRes = pDev->Framebuffer.HalInfo.VertDisplayWidth;
        status = dacGetI2CModeString(pDev, Head, hRes, vRes, &strptr);
        pReg = (PCH_string) strptr;
        if (status)
        {
            regsCh->reg0x0A = 0;
            regsCh->reg0x0B = 0;
        }
        else
        {
            regsCh->reg0x0A = pReg->data0x0A;
            regsCh->reg0x0B = pReg->data0x0B;
        }
        regsCh->reg0x08 = 0x00;
        regsCh->reg0x09 = 0x7f;
        regsCh->reg0x11 = 0x03;
        if (EncoderId == NV_ENCODER_CHRONTEL_7003)
            regsCh->reg0x01 = 0x03;
        else
            regsCh->reg0x01 = 0x29;
    }
}
//  Write TV encoder positioning registers, as well as contrast, brightness, flicker filter
//  For Brooktree positioning, we must change the CRTC's also.
VOID dacSetTVPosition
(
    PHWINFO pDev,
    U032    Head,
    U032    *encoderParms
)
{
    U008 Adr, Data, Device, lock;
    NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *Parms = (NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *) encoderParms;

    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
    if (TV_ENCODER_FAMILY(Parms->Encoder_ID) == TV_ENCODER_BROOKTREE)
    {
        // Write CRTC values (we can use the monitor position function)
        dacSetMonitorPosition(pDev, Head, Parms->u.regsBt.HRetraceStart, Parms->u.regsBt.HRetraceEnd,
                                Parms->u.regsBt.VRetraceStart, Parms->u.regsBt.VRetraceEnd);

        Data = Parms->u.regsBt.reg0x80;
        Adr = 0x80;
        Device = (U008)(pDev->Dac.EncoderID >> 1);
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0x82;
        Adr = 0x82;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0x92;
        Adr = 0x92;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0x98;
        Adr = 0x98;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0x9A;
        Adr = 0x9a;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0xC8;
        Adr = 0xc8;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0xCA;
        Adr = 0xca;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0xCC;
        Adr = 0xcc;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
    } else if (TV_ENCODER_FAMILY(Parms->Encoder_ID) == TV_ENCODER_CHRONTEL)
    {
        // Chrontel is positioned completely thru the encoder
        Data = Parms->u.regsCh.reg0x01;
        Adr = 0x01;
        Device = (U008)(pDev->Dac.EncoderID >> 1);
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x08;
        Adr = 0x08;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x09;
        Adr = 0x09;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x0A;
        Adr = 0x0A;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x0B;
        Adr = 0x0B;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x11;
        Adr = 0x11;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
    }
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
}


//  Return the default TV mode stored in the bios.
RM_STATUS dacGetBiosDefaultTVType
(
    PHWINFO pDev,
    U032    *biostvdefault
)
{
 
   U008  data, lock;
   U032  Head = 0;  // BIOS knows only about head 0

   lock = ReadCRTCLock(pDev, Head);

   CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

   CRTC_RD(NV_CIO_CRE_SCRATCH0__INDEX, data, Head); 

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);

   *biostvdefault = data & 0x07;

   return(RM_OK);
}
        
//  Detect TV encoder 
//  Find the encoder ID (i2c address) and the type (maker and version) and save in the pDev dac structure.
VOID    dacDetectEncoder
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    lock, ack, read, retry;

    // see if we have a TV encoder, and what type it is.
    // Identify which part: Chrontel or Brooktree? There are 2 possible ID's for each part
    // Unlock CRTC extended regs
    if (IsNV11(pDev))
    {
        AssocDDC(pDev, Head);
        AssocTV(pDev, Head);
    }

    lock = UnlockCRTC(pDev, Head);

    if (IsNV4(pDev) && Head == 0)   // TV and CRT share the i2c port
        EDIDRead(pDev, Head, DISPLAY_TYPE_MONITOR);   // this will stop the CRT from driving DDC1 data on the bus

    i2cInit(pDev, Head, pDev->Dac.TVOutPortID);

    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x8A);     // is it Brooktree?
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    }
    if (ack == 0) { // We got a response, so this must be our device
        pDev->Dac.EncoderID = 0x8A;
        pDev->Dac.EncoderType = TV_ENCODER_BROOKTREE;
    } else {    // Not address 8A, try alternate
        for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x88); // Brooktree alt address
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
        }
        if (ack == 0) { // We got a response, so this must be our device
            pDev->Dac.EncoderID = 0x88;
            // Differentiate between Brooktree and Philips
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1C); // Philips ID reg
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID); // Start w/o Stop = Restart
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            if (ack) 
                pDev->Dac.EncoderType = TV_ENCODER_BROOKTREE;
            else
            {
                pDev->Dac.EncoderType = TV_ENCODER_PHILIPS; // generic ID
                switch (read) 
                {
                    case 0x02:
                        pDev->Dac.EncoderType = NV_ENCODER_PHILIPS_7102;
                        break;    
                    case 0x03:
                        pDev->Dac.EncoderType = NV_ENCODER_PHILIPS_7103;
                        break;    
                }
                // If there is a decoder on the chip, then it is considered to be a 7108 or 7109
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x40); // 7114 decoder address    
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                if (ack == 0) 
                {
                    if (pDev->Dac.EncoderType == NV_ENCODER_PHILIPS_7102) 
                    {
                        pDev->Dac.EncoderType = NV_ENCODER_PHILIPS_7108;
                    }
                    if (pDev->Dac.EncoderType == NV_ENCODER_PHILIPS_7103) 
                    {
                        pDev->Dac.EncoderType = NV_ENCODER_PHILIPS_7109;
                    }
                }
            }
        } else {    // Not Brooktree
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xEA); // is it Chrontel?
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }
            if (ack == 0) { // We got a response, so this must be our device
                pDev->Dac.EncoderID = 0xEA;
                pDev->Dac.EncoderType = TV_ENCODER_CHRONTEL;
            } else {    // Try alternate Chrontel address
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                    ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xEC); // try Chrontel alt address
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                }
                if (ack == 0) { // We got a response, so this must be our device
                    pDev->Dac.EncoderID = 0xEC;
                    pDev->Dac.EncoderType = TV_ENCODER_CHRONTEL;
                } else {
                    pDev->Dac.EncoderType = NV_ENCODER_NONE;
                }
            }
        }
    }

    // if the part responded to the Chrontel address, check subaddress
    // we may have another Chrontel part (7002?)
    if (pDev->Dac.EncoderType == TV_ENCODER_CHRONTEL)
    {
        // See what BIOS booted to.
        if (dacGetBiosDisplayType(pDev, Head) == DISPLAY_TYPE_TV)  // H
            // Temporarily set DisplayType to TV. This prevents the BIOS from hanging when
            // it gets called to do a modeset, because TVConnectStatus will turn off the encoder
            // if its not the current display. The correct display type will be set later.
            // If the VCLK is coming from the encoder, we must not turn it off.

            SETDISPLAYTYPE(pDev, Head, DISPLAY_TYPE_TV);

        for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        }
        if ((ack != 0) || (i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x25))) // 25 = version register
        {
            pDev->Dac.EncoderType = NV_ENCODER_NONE;                    
        }
        else
        {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            if (ack)    // if read failed, the reg doesn't exist, probably 7002
            {
                pDev->Dac.EncoderType = NV_ENCODER_NONE; 
            }
            else
            {
                switch (read & 0xFF)
                {
                    case 0x00:  // 7003 according to spec
                    case 0x01:  // 7003 observed
                    case 0x02:  // 7003B
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7003;
                        break;
                    case 0x30:  // 7004A  From Chrontel, their data sheets are incorrect.
                    case 0x31:  // 7004B
                    case 0x32:  // 7004C
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7004;
                        break;
                    case 0x38:  // 7005A
                    case 0x39:  // 7005B
                    case 0x3a:  // 7005C
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7005;
                        break;
                    case 0x28:  // 7006A
                    case 0x29:  // 7006B
                    case 0x2A:  // 7006C
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7006;
                        break;
                    case 0x50:  // 7007
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7007;
                        break;
                    case 0x40:  // 7008
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7008;
                        break;
                    default:    // 7002 should return FF
                        pDev->Dac.EncoderType = NV_ENCODER_NONE;
                        break;
                }
            }
        }
    }

    // if Brooktree, identify which variety
    if (pDev->Dac.EncoderType == TV_ENCODER_BROOKTREE)
    {
        // Select ETSTAT 0 to read back the ID (868 or 869)
        for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        }
        if (ack == 0) {
            ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0xC4);   // subaddress
            ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x01);   // set estat (estat 0 + en_out)
        }
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

        if (ack == 0) {
            // Do the readback
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID+1));     // start readback
            }
            if (ack == 0) {
                i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read, 1);
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
        }

        if (ack) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error in I2C while identifying TV encoder\n\r");
            pDev->Dac.EncoderType = NV_ENCODER_NONE;                    
        } else {
            // Check upper 3 bits: 000 if 868, 001 if 869
            switch (read & 0xe0) {
                case 0:
                    pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_868;
                    break;
                case 0x20:
                    pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_869;
                    break;
                case 0x60:
                    pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_871;
                    break;
                default:
                    pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_868;
            }
        }
    }                
      
    //
    // Relock if necessary
    //
    RestoreLock(pDev, Head, lock);            
}

VOID
dacDisableTV
(
    PHWINFO pDev,
    U032 Head
)
{
    // On dual-headed devices, enable I2C interface
    if (IsNV11(pDev)) 
    {
        EnableHead(pDev, Head);
        AssocDDC(pDev, Head);
    }
    
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_CHRONTEL:
            // power down to blank screen
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                    // start state for I2C
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0E);      // PM register 
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_OFF);         // power down (+ reset high)  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C
            break;
        case TV_ENCODER_BROOKTREE:
            // Turn DAC off
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_OFF);    // DAC OFF
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
        case TV_ENCODER_PHILIPS:
            dacTVReadModifyWrite(pDev, Head, PH_STDCTL, PH_DAC_OFF, PH_DAC_POWER);
            break;
        case TV_ENCODER_NONE:
        default:
            // what can we do?
            break;
    }
            
    // Leave Head 0 enabled (in Win9x, the BIOS always expects head 0 to be enabled, so in situations such as shutdown
    // or DOS full screen, we can hang if leave it pointing to head 1.
    if (IsNV11(pDev)) 
    {
        if ((pDev->Chip.BiosRevision & 0xFF0000FF) < 0x03000020)
            EnableHead(pDev, 0);    
    }

}

VOID
dacEnableTV
(
    PHWINFO pDev,
    U032 Head
)
{
    // On dual-headed devices, enable I2C interface
    if (IsNV11(pDev)) 
    {
        EnableHead(pDev, Head);
        AssocDDC(pDev, Head);
    }
    
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_CHRONTEL:
            // power up DAC
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                // start state for I2C
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0E);  // PM register 
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_ON);      // power on (+ reset high)  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                 // end state for I2C
            break;
        case TV_ENCODER_BROOKTREE:
            // Turn DAC on
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_ON);    // DAC ON
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
        case TV_ENCODER_PHILIPS:
            dacTVReadModifyWrite(pDev, Head, PH_STDCTL, PH_DAC_ON, PH_DAC_POWER);
            break;
        case TV_ENCODER_NONE:
        default:
            // what can we do?
            break;
    }
            
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\edid.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* EDID Functions *****************************
*                                                                           *
* Module: EDID.C                                                            *
*   All EDID related fuctions are in this module.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nvrm.h>
#include <i2c.h>
#include <tmr.h>
#include <edid.h>
#include "nvhw.h"
#include <dac.h>
#include <devinit.h>
#include <vga.h>


U032 getI2CPort(PHWINFO pDev, U032 Head, U032 dispType )
{
    if (IsNV11(pDev)) 
    {
        // We have to know what the mappings of ports to display devices are.
        // Until we can get this from the BIOS, assume the following:
        switch (dispType)
        {
            case DISPLAY_TYPE_MONITOR:
            case DISPLAY_TYPE_DUALSURFACE:
                if (Head == 0) 
                    return pDev->Dac.CRTPortID; // VGA Head 0 use port 0
                else
                    return pDev->Dac.CRT2PortID; // DVI Head 1 use port 1
            case DISPLAY_TYPE_FLAT_PANEL:
                if (Head == 0) 
                    return pDev->Dac.DFPPortID; // DVI Head 0
                else
                    return pDev->Dac.DFP2PortID; // DVI Head 1
            case DISPLAY_TYPE_TV:
                return pDev->Dac.TVOutPortID;
            default:
                return NV_I2C_PORT_PRIMARY;
        }
    }
    else
    {
        // TODO: Use Head as an index into the Dac array
        switch (dispType)
        {
            case DISPLAY_TYPE_MONITOR:
            case DISPLAY_TYPE_DUALSURFACE:
                return pDev->Dac.CRTPortID;
            case DISPLAY_TYPE_FLAT_PANEL:
                return pDev->Dac.DFPPortID;
            case DISPLAY_TYPE_TV:
                return pDev->Dac.TVOutPortID;
            default:
                return NV_I2C_PORT_PRIMARY;
        }
    }
}

static U032 edidTranslateI2CPort(PHWINFO pDev, U008 I2CReadPort)
{
    switch (I2CReadPort)
    {
        case I2C_PHYSICAL_PORT_A_STATUS:
            return NV_I2C_PORT_PRIMARY;
        case I2C_PHYSICAL_PORT_B_STATUS:
            return NV_I2C_PORT_SECONDARY;
        case I2C_PHYSICAL_PORT_C_STATUS:
            return NV_I2C_PORT_TERTIARY;
        default:
            return NV_I2C_PORT_PRIMARY;
    }
}

static U032 edidTranslateDisplayType(U032 displayType)
{
    switch (displayType)
    {
        case DCB_DEV_REC_TYPE_CRT:
        {
            return DISPLAY_TYPE_MONITOR;
        }
        case DCB_DEV_REC_TYPE_TV:
        {
            return DISPLAY_TYPE_TV;
        }
        case DCB_DEV_REC_TYPE_DD_SLINK:
        case DCB_DEV_REC_TYPE_DD_DLINK:
        {
            return DISPLAY_TYPE_FLAT_PANEL;
        }
        default:
            return DISPLAY_TYPE_NONE;
    }
}

static RM_STATUS getDefaultEDIDFromBIOS(PHWINFO, U032, U032);

// Get the monitor to stop driving the DDC bus (DDC1)
// This may only stop the CRT momentarily; we must send a valid DDC2 address
// to be sure it stops permanently.
RM_STATUS StopDDC1(PHWINFO pDev, U032 Head, U032 dispType)
{
U032	i2cPortId = 0;	
U016	status = 1, i;
U008	Data;

    i2cPortId = getI2CPort(pDev, Head, dispType);
    i2cHardwareInit(pDev, Head, i2cPortId);
    tmrDelay(pDev, 15000);
    ResetSCLLine(pDev, Head, i2cPortId);     // drive clock low (data tristated)
    tmrDelay(pDev, 2000000);
    SetSCLLine(pDev, Head, i2cPortId);       // clock high
    SetSDALine(pDev, Head, i2cPortId);       // data high
    for (i=0; i<16; i++)	// give it 16 times
    {
        tmrDelay(pDev, 15000);
        ReadSDA(pDev, Head, i2cPortId, &Data);
        if(Data)        	// SDA = 1?
        {
            status=0;
            break;
        }
    }
    tmrDelay(pDev, 10000);
    i2cStop(pDev, Head, i2cPortId);
    
    // Leave it with clock low (problem with ViewSonic monitors)
    ResetSCLLine(pDev, Head, i2cPortId);     // drive clock low (data tristated)
    tmrDelay(pDev, 2000000);
	
    if (status)
        return (RM_ERROR);
    return (RM_OK);
}

//****************************************************************************************
/*	Determine if monitor is DDC, and in doing so, get it ready to read the EDID or VDIF
	This means get it in DDC2 mode and send the address. Try addresses A0 and A2.
*/
RM_STATUS IsMonitorDDC(PHWINFO pDev, U032 Head, U032 dispType, U008 *dispAddr)
{
    RM_STATUS status;
    U008	Adr, Data;
    U032    i2cPortId;

    i2cPortId = getI2CPort(pDev, Head, dispType);
    // NV11 can drive a CRT on either head; earlier devices only on port 0.
    if (IsNV11(pDev) || (i2cPortId == 0))  
    {
        StopDDC1(pDev, Head, dispType);	// stop the CRT from driving the bus
    }

    // now monitor is in DDC2 mode; we can talk to it
    // send address 0 (start of EDID), no other data
    Adr = 0;
    *dispAddr = DDC_CRT_ADR1;
    if (dispType == DISPLAY_TYPE_MONITOR) {
        status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data);   // if it fails, its not DDC
    }
    else if (dispType == DISPLAY_TYPE_FLAT_PANEL)
    {
        // if flat panel, device address can be A0, A2, or A6 (50/51/53 shifted left)
	    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data);   
        if (status)
        {
            *dispAddr = DDC_CRT_ADR2;
		    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR2, 1, &Adr, 0, &Data);  
            if (status)
            {
                *dispAddr = DDC_CRT_ADR3;
    		    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR3, 1, &Adr, 0, &Data);  
            }
        }
    }
    else
    {
        // not a DDC device
        status = RM_ERROR;
    }
    return status;
}

U032 edidGetVersion(PHWINFO pDev, U032 Head)
{
    U008 i, index = 0;

    // check for version 1
    if (pDev->Dac.CrtcInfo[Head].EDID[0]	== 0x00)
    {
        for (i=1; i<8; i++)
            if (pDev->Dac.CrtcInfo[Head].EDID[i] == 0xff)
                index = i;
            else 
                break;
        if (pDev->Dac.CrtcInfo[Head].EDID[index+1]	== 0x00)
            return 1;		
    }	
    if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_VERSION_NUMBER_INDEX] & 0xf0) == 0x20)
        return 2;

    return 0;	// Invalid or unknown EDID
}

//****************************************************************************************
/*	Checksum an EDID
 */
static BOOL EDIDCheckSumOk(
    PHWINFO pDev, 
    U032    Head, 
    U008   *edid,
    U032    length
)
{
    U032 j;
    int  chksum;

    // This is version 1 header
    // checksum the block
    chksum = 0;

    for (j=0; j<length; j++)
        chksum += *edid++;
 
    return ((U008) chksum) == 0;
}

//****************************************************************************************
/*	Read EDID
    Read the EDID of the specified device into the caller's buffer
    The device is specified by the DWORD which is a bit map of up to 8 CRT's, 8 DFP's, and 8 TV's.
*/
RM_STATUS edidReadDevEDID(PHWINFO pDev, U032 device, U008 *pEdid)
{
    RM_STATUS    status = RM_ERROR;
#ifndef IKOS    // This is just too painfully slow
    int	    i,j;
    U008    block_ID;
    U032    i2cPortID, Head, dispType;
	U008 	dispAddr;



    status = dacGetDisplayInfo(pDev, device, &Head, &dispType, 0, 0);

    if (status != RM_OK)
    {
        return status;
    }

    dispType = edidTranslateDisplayType(dispType);

    if (dispType == DISPLAY_TYPE_NONE)
    {
        status = RM_ERROR;
        return status;
    }
    //
    // Look for EDID overrides for mobile operation
    //
    if (dispType == DISPLAY_TYPE_FLAT_PANEL && pDev->Power.MobileOperation)
    {
        status = edidConstructMobileInfo(pDev, Head, pEdid);
        if (status == RM_OK)
            return RM_OK;
    }

	// See if device supports DDC and which address it uses
    status = IsMonitorDDC(pDev, Head, dispType, &dispAddr);
    if (status != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        goto done;
    }

    i2cPortID = getI2CPort(pDev, Head, dispType);

	for (i=0; i<DDC_RETRIES; i++)
	{
        block_ID = 0;
        // send a write command and read back a block 
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortID, dispAddr, 1, &block_ID, 128, pEdid);
        if (status == RM_OK)
        {
            // Check which version of the header. If it was version 2, we need to read
            // another 128 bytes.
            if (pEdid[0] == 0 && pEdid[1] == 0xff &&
                pEdid[EDID_V1_VERSION_NUMBER_INDEX] == 0x1)
            {
            	if (EDIDCheckSumOk(pDev, Head, pEdid, 128))
            	    goto done;
            }
            else if ((pEdid[0] >> 4) == 2)
            {
                // This is a version 2 header. Read the next 128 byte block.
                block_ID = 128;
                // send a write command and read the next block 
                // NOTE: the device address is shifted up in our function (50->A0)
                status = i2cRead(pDev, Head, i2cPortID, dispAddr, 1, &block_ID, 128, 
                                 &(pEdid[128]));
                if (status == RM_OK)
	            	if (EDIDCheckSumOk(pDev, Head, pEdid, 256))
	            	    goto done;
            }
    	}
        // if we failed, try to reset the slave
        for (j=0; j< 10; j++) 
        {
            i2cStart(pDev, Head, i2cPortID);
            tmrDelay(pDev, 10000);
            i2cStop(pDev, Head, i2cPortID);
            tmrDelay(pDev, 10000);
        }


    } // retry

	// if we fall out of the retry loop, then its an error
	status = RM_ERROR;
	
done:
	if (status == RM_OK)
	    return RM_OK;

#ifdef MACOS
    // one last chance to get an EDID
    status = getDefaultEDIDFromBIOS(pDev, Head, dispType);
#endif
#endif // defined IKOS

    return status;
}


//****************************************************************************************
/*	Read EDID
	dispType is the display we want to read, not necessarily the current device.
    This will alwasy return RM_OK, since we'll get the BIOS default EDID if none if found,
    UNLESS this if for mobile?
*/
RM_STATUS EDIDRead(PHWINFO pDev, U032 Head, U032 dispType)
{
    RM_STATUS    status = RM_ERROR;
#ifndef IKOS    // This is just too painfully slow
    int	    i,j;
    U008    block_ID;
    U032    i2cPortId;
	U008 	dispAddr;

    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);  // Connect the head to the I2C pins
    }
    
    //
    // Look for EDID overrides for mobile operation
    //
    if ((dispType == DISPLAY_TYPE_FLAT_PANEL) && pDev->Power.MobileOperation)
    {
        status = edidConstructMobileInfo(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID);
        if (status == RM_OK)
            return RM_OK;
    }

	// See if device supports DDC and which address it uses
    status = IsMonitorDDC(pDev, Head, dispType, &dispAddr);
    if (status != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        goto done;
    }

    i2cPortId = getI2CPort(pDev, Head, dispType);

	for (i=0; i<DDC_RETRIES; i++)
	{
        block_ID = 0;
        // send a write command and read back a block 
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 128, pDev->Dac.CrtcInfo[Head].EDID);
        if (status == RM_OK)
        {
            // Check which version of the header. If it was version 2, we need to read
            // another 128 bytes.
            if (pDev->Dac.CrtcInfo[Head].EDID[0] == 0 && pDev->Dac.CrtcInfo[Head].EDID[1] == 0xff &&
                pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VERSION_NUMBER_INDEX] == 0x1)
            {
            	if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, 128))
            	    goto done;
            }
            else if ((pDev->Dac.CrtcInfo[Head].EDID[0] >> 4) == 2)
            {
                // This is a version 2 header. Read the next 128 byte block.
                block_ID = 128;
                // send a write command and read the next block 
                // NOTE: the device address is shifted up in our function (50->A0)
                status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 128, 
                                 &(pDev->Dac.CrtcInfo[Head].EDID[128]));
                if (status == RM_OK)
	            	if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, 256))
	            	    goto done;
            }
    	}
        // if we failed, try to reset the slave (may be hung up and not responding)
        for (j=0; j< 20; j++) 
        {
            i2cStart(pDev, Head, i2cPortId);
            tmrDelay(pDev, 20000);      // 20 us
            i2cStop(pDev, Head, i2cPortId);
            tmrDelay(pDev, 20000);
            // one last desparate measure 
            StopDDC1(pDev, Head, dispType);	// stop the CRT from driving the bus
            tmrDelay(pDev, 2000000);    // 2 ms
        }


    } // retry

	// if we fall out of the retry loop, then its an error
	status = RM_ERROR;
	
done:
	if (status == RM_OK)
	    return RM_OK;

#ifdef MACOS
    // one last chance to get an EDID
    status = getDefaultEDIDFromBIOS(pDev, Head, dispType);
#endif
#endif // defined IKOS

    return status;
}

//****************************************************************************************
/*	See if a device has an EDID 
	dispType is the display we want to read, not necessarily the current device.
*/
RM_STATUS EDIDDetect(PHWINFO pDev, U032 Head, U032 dispType)
{
#ifndef IKOS    // This is just too painfully slow
    int	    i;
    RM_STATUS    status;
    U008    block_ID, lock;
    U032    i2cPortId;
	U008 	dispAddr;
    U008    EdidBuffer[128];

    lock = ReadCRTCLock(pDev, Head);	// Unlock the registers

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
    
    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);  // Connect the head to the I2C pins
    }
	// See if device supports DDC and which address it uses
    if (IsMonitorDDC(pDev, Head, dispType, &dispAddr) != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        return RM_ERROR;
    }

    i2cPortId = getI2CPort(pDev, Head, dispType);

	for (i=0; i<DDC_RETRIES; i++)
	{
        block_ID = 0;
        // send a write command and read back a block (at least 0x50 bytes to get version 2 display technology byte).
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 0x50, EdidBuffer);
        if (status == RM_OK)
        {
            // Check which version of the header. If it was version 2,
            if (EdidBuffer[0] == 0 && EdidBuffer[1] == 0xff &&
                EdidBuffer[EDID_V1_VERSION_NUMBER_INDEX] == 0x1)
            {
                // This is version 1 header, get video input definition
                if (EdidBuffer[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))     // digital device?
                {
                    if (dispType == DISPLAY_TYPE_FLAT_PANEL) 
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
                else
                {
                    if (dispType == DISPLAY_TYPE_MONITOR)                   // we're looking for analog
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
            }
            else if ((EdidBuffer[0] >> 4) == 2)
            {
                // This is a version 2 header.
                if ((EdidBuffer[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0) // analog device?
                {
                    if (dispType == DISPLAY_TYPE_MONITOR)                   // we're looking for analog
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
                else
                {
                    if (dispType == DISPLAY_TYPE_FLAT_PANEL) 
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
            }
            else
            {
                // Unknown edid header.
                status = RM_ERROR;
            }
    	} // Successfully read the first 128 byte block.
    } // retry
done:    
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);

	return status;
#else   // defined IKOS
    return RM_ERROR;
#endif  // IKOS
}

static RM_STATUS getDefaultEDIDFromBIOS(
    PHWINFO pDev,
    U032    Head,
    U032    dispType
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 offset;
    BMP_Control_Block bmpCtrlBlk;

#ifdef MACOS

    U032 edid_len;               //012345
    char edid_registry_name[16] = "EDID,x";

    // on the Mac, a fallback EDID could be in the registry (published by fcode)
    // Check here before falling back to the BIOS image
    // If it is in the registry
    // XXX this could be generic, I guess.
    
    edid_len = sizeof(pDev->Dac.CrtcInfo[Head].EDID);
    edid_registry_name[5] = 'A' + Head;     // "EDID,A" or "EDID,B"
    
	if ((RM_OK == osReadRegistryBinary(pDev, "", edid_registry_name, pDev->Dac.CrtcInfo[Head].EDID, &edid_len)))
	{
    	if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, edid_len))
        {
        	// Ok, it looks good so far, but is it the right "type" (fp or crt)
        	// Can't be too careful, you know....
        	BOOL analog_display;
        	BOOL expected_analog;

        	analog_display  = edidIsAnalogDisplay(pDev, Head);
        	expected_analog = dispType == DISPLAY_TYPE_MONITOR;
        	
        	if (analog_display != expected_analog)
        	{
	            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: found 'canned' EDID; but wrong type\n");
        	    return RM_ERROR;
        	}
        	
	        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: using 'canned' EDID from registry\n");
    	    return RM_OK;
    	}
	}
#endif //  MACOS

    rmStatus = DevinitGetBMPControlBlock(pDev, &bmpCtrlBlk, &offset);

    if (rmStatus == RM_OK) 
    {
        // we only care about version 5 bmp tables
        switch ( bmpCtrlBlk.CTL_Version )
        {
            case BMP_INIT_TABLE_VER_0:
            case BMP_INIT_TABLE_VER_1:
            case BMP_INIT_TABLE_VER_2:
            case BMP_INIT_TABLE_VER_3:
            case BMP_INIT_TABLE_VER_4:
                 break;
            case BMP_INIT_TABLE_VER_5:
            {
               BMP_Struc_Rev5 bmp_InitTableInfo ;
               rmStatus = BiosReadStructure(pDev,
                                            (U008 *) &bmp_InitTableInfo,
                                            offset,
                                            (U032 *) 0,
                                            BMP_INIT5_FMT);
               if (rmStatus == RM_OK) 
               {
                   rmStatus = BiosReadBytes(pDev,
                                            pDev->Dac.CrtcInfo[Head].EDID,
                                            bmp_InitTableInfo.BMP_LCDEDID,
                                            EDID_V1_SIZE);
               }
               break;
            }
            default:
                rmStatus = RM_ERROR;
        }
    }

    return rmStatus;
}


//****************************************************************************************
/*	Read VDIF
	VDIF follows after last EDID block, so to read a VDIF block we need to get the
	number of EDID blocks (*128) and add the VDIF block (*64)
*/
RM_STATUS ReadVDIF(PHWINFO pDev, U032 Head, U032 dispType, U008 *buffer, U008 device, U008 address)
{
    int     i;
    RM_STATUS  status;
    U008    Adr;
    U032    i2cPortId;

// FILL IN THIS !!!

    // get number of EDID blocks

    // calc VDIF block address

    // read VDIF
    i2cPortId = getI2CPort(pDev, Head, dispType);
    status = RM_OK;       /* macosX's version of gcc thinks 'status' may not be init before use */
    for (i=0; i<DDC_RETRIES; i++)
    {
        // send a write command and read back a block (NOTE: the device address is shifted up in our function, so 50->A0)
        status = i2cRead(pDev, Head, i2cPortId, 0x50, 0, &Adr, 128, buffer);
        if (status == RM_OK)
            break;		
    }

    return (status);
}

// Checks to see if the EDID is present in the pDev and if it matches a valid version.
// The version and revision is returned, as well as a pointer to the requested EDID buffer.
static BOOL EDIDIsValid
(
    PHWINFO pDev,
    U008    **edidPtr,
    U032    *version,
    U032    *revision,
    U032    Head
)
{
    U008 *edid;


    edid = pDev->Dac.CrtcInfo[Head].EDID;
    // Check the version of the edid header.
	if (!(edid[0] == 0 && edid[1] == 0xff))
	{
		// this is not version 1 edid header
		// check if it is version 2 header.
        // Bits 7-4 of byte 0 is the version and bits 3-0 of byte 0 is the revision
		if (((edid[0] & 0xf0) >> 4) == 2)
		{
            *version = 2;
            *revision = edid[0] & 0x0f;
            *edidPtr = edid;
            return TRUE;
		}

		// Unknown edid header.
        return FALSE;
	}

    // Check for version 1 edid header.
    if (edid[EDID_V1_VERSION_NUMBER_INDEX] == 1)
    {
        *version = 1;
        *revision = edid[EDID_V1_REVISION_NUMBER_INDEX];
        *edidPtr = edid;
        return TRUE;
    }

    // Unknown edid header.
    return FALSE;

}

// Checks to see if the EDID is present in the pDev and if it matches a valid version.
// The version and revision is returned, as well as a pointer to the requested EDID buffer.
BOOL edidLogicalEDIDIsValid
(
    U008    **edidPtr,
    U032    *version,
    U032    *revision
)
{
    U008 *edid;


    edid = *edidPtr;
    // Check the version of the edid header.
	if (!(edid[0] == 0 && edid[1] == 0xff))
	{
		// this is not version 1 edid header
		// check if it is version 2 header.
        // Bits 7-4 of byte 0 is the version and bits 3-0 of byte 0 is the revision
		if (((edid[0] & 0xf0) >> 4) == 2)
		{
            *version = 2;
            *revision = edid[0] & 0x0f;
            *edidPtr = edid;
            return TRUE;
		}

		// Unknown edid header.
        return FALSE;
	}

    // Check for version 1 edid header.
    if (edid[EDID_V1_VERSION_NUMBER_INDEX] == 1)
    {
        *version = 1;
        *revision = edid[EDID_V1_REVISION_NUMBER_INDEX];
        *edidPtr = edid;
        return TRUE;
    }

    // Unknown edid header.
    return FALSE;

}

static RM_STATUS EDIDV1Copy
(
    PHWINFO pDev,
    U008    *edid,
    U008    *buffer,
    U032    *bufLen
)
{
    // version 1
    if (*bufLen < EDID_V1_SIZE)
    {
        // There is not enough space in the buffer.
        *bufLen = 0;
        return RM_ERROR;
    }

    // There is enough space in the buffer.
    *bufLen = EDID_V1_SIZE;

	osMemCopy((U008*) buffer, (U008*) edid, *bufLen);
    return RM_OK;
}

static RM_STATUS EDIDV2Copy
(
    PHWINFO pDev,
    U008    *edid,
    U008    *buffer,
    U032    *bufLen
)
{
    // Version 2
    if (*bufLen < EDID_V2_SIZE)
    {
        // There is not enough space in the buffer.
        *bufLen = 0;
        return RM_ERROR;
    }

    // There is enough space in the buffer.
    *bufLen = EDID_V2_SIZE;
    
    osMemCopy((U008*) buffer, (U008*) edid, *bufLen);
    return RM_OK;
}

// This function copies the edid from the pDev into the buffer passed.
// Currently only version 1 edid header is supported.
RM_STATUS EDIDCopy
(
    PHWINFO pDev,
    U008    *buffer,
    U032    *bufLen,
    U032    Head
)
{
    U032 edidVersion, edidRevision;
    U008 *edid;

    if (!EDIDIsValid(pDev, &edid, &edidVersion, &edidRevision, Head)) // verify EDID and get a pointer to it
    {
        // edid not valid
        *bufLen = 0;
        return RM_ERROR;
    }

    if (edidVersion == 1)
    {
        return EDIDV1Copy (pDev, edid, buffer, bufLen);
    }
    else if (edidVersion == 2)
    {
        return EDIDV2Copy (pDev, edid, buffer, bufLen);
    }

    // Unknown edid header.
    *bufLen = 0;
    return RM_ERROR;
} // end of EDIDCopy

#if 0 // no one calling this, so turn it off 
static RM_STATUS EDIDV1GetMaxRefreshRate
(
    PHWINFO pDev,
    U008   *edid,
    U032    hRes,
    U032    vRes,
    U032   *maxRefreshRate
)
{
    U032      i, j, tmpHRes, tmpVRes = ~0, tmpRefresh;

    *maxRefreshRate = 0;
    // Get the max from the established timing section
    switch (hRes)
    {
        case 720:
            if (vRes == 400)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x40)
                {
                    // Supports 720x400 @ 88Hz.
                    *maxRefreshRate = 88;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x80)
                {
                    // supports 720x400 @ 70Hz
                    *maxRefreshRate = 70;
                }

            }
            break;
        case 640:
            if (vRes == 480)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x04)
                {
                    // Supports 640x480 @ 75Hz.
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x08)
                {
                    // supports 640x480 @ 72Hz
                    *maxRefreshRate = 72;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x10)
                {
                    // supports 640x480 @ 67Hz
                    *maxRefreshRate = 67;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x20)
                {
                    // supports 640x480 @ 60Hz
                    *maxRefreshRate = 60;
                }
            }
            break;
        case 800:
            if (vRes == 600)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x40)
                {
                    // Supports 800x600 @ 75Hz.
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x80)
                {
                    // supports 800x600 @ 72Hz
                    *maxRefreshRate = 72;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x01)
                {
                    // supports 800x600 @ 60Hz
                    *maxRefreshRate = 60;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x02)
                {
                    // supports 800x600 @ 56Hz
                    *maxRefreshRate = 56;
                }
            }
            break;
        case 832:
            if (vRes == 624)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x20)
                {
                    // Supports 832x624 @ 75Hz.
                    *maxRefreshRate = 75;
                }
            }
            break;
        case 1024:
            if (vRes == 768)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x10)
                {
                    // Supports 1024x768 @ 87Hz
                    *maxRefreshRate = 87;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x02)
                {
                    // supports 1024x768 @ 75Hz
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x04)
                {
                    // supports 1024x768 @ 70Hz
                    *maxRefreshRate = 70;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x08)
                {
                    // supports 1024x768 @ 60Hz
                    *maxRefreshRate = 60;
                }
            }
            break;
        case 1280:
            if (vRes == 1024)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x01)
                {
                    // Supports 1280x1024 @ 75Hz
                    *maxRefreshRate = 75;
                }
            }
            break;
        case 1152:
            if (vRes == 870)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_3_INDEX] & 0x80)
                {
                    // Supports 1152x870 @ 75Hz 
                    *maxRefreshRate = 75;
                }
            }
            break;
        default:
            break;
    } // switch on hRes


    // Now check the standard timings to see if there is a higher refresh rate specified.
   	for (i = 0; i < 8; i++)
	{
		if (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i * 2)] != 0x01)
		{
			// there is a standard timing specification.
			tmpHRes = (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2)] + 31) * 8;
			tmpRefresh = (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2) + 1] & 0x3f) + 60;
			switch ((edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2) + 1] & 0xc0) >> 6)
			{
			case 0x0:
				// aspect ratio 1:1
				tmpVRes = tmpHRes;
				break;
			case 0x1:
				// aspect ratio 4:3
				tmpVRes = (tmpHRes * 3) / 4;
				break;
			case 0x2:
				// aspect ratio 5:4
				tmpVRes = (tmpHRes * 4) / 5;
				break;
			case 0x3:
				// aspect ratio 16:9
				tmpVRes = (tmpHRes * 9) / 16;
				break;
			}

            // Check if this standard timing matches the resolution we want.
            if (tmpHRes == hRes && tmpVRes == vRes)
            {
                // Resolution matches. 
                // If this refresh rate is > than the one found in established timings, use it.
                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            }
		} // A valid standard timing spec
	} // iterate over all 8 standard timings

    // Now check the detailed timing specification for a macting resolution.
	for (i = 0; i < 4; i++)
	{
		int startIndex = EDID_V1_DETAILED_TIMINGS_START_INDEX + (i * EDID_V1_DETAILED_TIMINGS_SIZE);
		if (edid[startIndex] == 0 && edid[startIndex + 1] == 0)
		{
			// This is a Monitor descriptor instead of a detailed timing descriptor.
			switch (edid[startIndex + 3])
			{
                case 0xFA:
                    // Descriptor contains 6 additional standard timing identifications
                    for (j = 0; j < 6; j++)
                    {
                        if (edid[startIndex + 5 + (j * 2)] != 0x01)
                        {
                            // there is a standard timing specification.
                            tmpHRes = (edid[startIndex + 5 + (j*2)] + 31) * 8;
                            tmpRefresh = (edid[startIndex + 5 + (j*2) + 1] & 0x3f) + 60;
                            switch ((edid[startIndex + 5 + (j*2) + 1] & 0xc0) >> 6)
                            {
                            case 0x0:
                                // aspect ratio 1:1
                                tmpVRes = tmpHRes;
                                break;
                            case 0x1:
                                // aspect ratio 4:3
                                tmpVRes = (tmpHRes * 3) / 4;
                                break;
                            case 0x2:
                                // aspect ratio 5:4
                                tmpVRes = (tmpHRes * 4) / 5;
                                break;
                            case 0x3:
                                // aspect ratio 16:9
                                tmpVRes = (tmpHRes * 9) / 16;
                                break;
                            } // switch on aspect ratio

                            // Check if this standard timing matches the resolution we want.
                            if (tmpHRes == hRes && tmpVRes == vRes)
                            {
                                // Resolution matches. 
                                // If this refresh rate is > than the one found in established timings, use it.
                                if (tmpRefresh > *maxRefreshRate)
                                {
                                    *maxRefreshRate = tmpRefresh;
                                }
                            }
                        } // a valid standard timing spec
                    } // iterate over the 6 additional standard timings
                    break;
                default:
                    break;
			}
		} // monitor descriptor.
		else
		{
			// This is a detailed timing descriptor.
            // The detailed timing specification does not include the refresh rate.
			U032 pixelClock;
			U032 hActive, vActive, hBlank, vBlank;
			U032 hTotal, vTotal;


			hActive = edid[startIndex + 2] | ((edid[startIndex + 4] & 0xf0) << 4);
			vActive = edid[startIndex + 5] | ((edid[startIndex + 7] & 0xf0) << 4);
            if (hActive == hRes && vActive == vRes)
            {
                // Resolution matches the detailed spec.
                // Get the rest of the detailed timing info needed to calculate the refresh rate.
                pixelClock = edid[startIndex] | (edid[startIndex + 1] << 8);
                hBlank  = edid[startIndex + 3] | ((edid[startIndex + 4] & 0x0f) << 8);
                vBlank  = edid[startIndex + 6] | ((edid[startIndex + 7] & 0x0f) << 8);

                // Horizontal Total (hActive + hBlank) gives # of pixels / line
                // Vertical total (vActive + vBlank) gives # of lines / frame
                // so HT * VT = total # pixels per frame.
                // Pixel clock is # pixels drawn / sec
                // so pixelClock / (HT * VT) gives the refresh rate (frames / sec).
                hTotal = hActive + hBlank;
                vTotal = vActive + vBlank;
                pixelClock = pixelClock * 10000;
                tmpRefresh = pixelClock / (hTotal * vTotal);

                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            } // resolution matches the detailed spec
		} // This is a detailed timing spec
	} // parse detailed section

    return RM_OK;
}

static RM_STATUS EDIDV2GetMaxRefreshRate
(
    PHWINFO pDev,
    U008   *edid,
    U032    hRes,
    U032    vRes,
    U032   *maxRefreshRate
)
{
    U032 lumTabSize, numLumTables;
    U032 numFreqRanges, numDetailedRanges, numTimingCodes, numDetailedTimings;
    U032 detailedTimingIndex, timingCodesIndex;
    U008 timingMap1, timingMap2;
    U032 index, i;

    // We need to look in the 4-byte timing codes section and the detailed timing section for
    // the given resolution.

    // The way the 127 byte detailed information is used is given by reading bytes 0x7e and 0x7f.
    // The size and the order of the 127 byte timing section that start at byte 0x80 is:
    // x*A + 8*B + 27*c + 4*D + 18*E where
    // A = number of luminance tables (0 or 1), (given by byte 0x7e bit 5)
    // x = size of the luminance table (given by the first byte of the table itself)
    // B = number of frequency rages listed (0-7), (given by bits 4-2 of byte 0x7e)
    // C = number of detailed rage limits (0-3), (given by (bits 1-0 of byte 0x7e)
    // D = number of timing codes (0-31), (given by bits 7-3 of byte 0x7f)
    // E = number of detailed timing descriptions (0-7) (given by bits 2-0 of byte 0x7f)
    timingMap1 = edid[EDID_V2_TIMING_MAP1_INDEX];
    timingMap2 = edid[EDID_V2_TIMING_MAP2_INDEX];
    numLumTables       = (timingMap1 & 0x20) >> 5; // Bit 5
    numFreqRanges      = (timingMap1 & 0x1C) >> 2; // Bits 4-2
    numDetailedRanges  = (timingMap1 & 0x03);      // Bits 1-0
    numTimingCodes     = (timingMap2 & 0xf8) >> 3; // Bits 7-3
    numDetailedTimings = (timingMap2 & 0x07);      // Bits 2-0
    if (numLumTables != 0)
    {
        // Calculate the size of the lum table by reading byte 0x80
        U032 numLumValues;

        numLumValues = edid[EDID_V2_TIMING_SECTION_START_INDEX] & 0x1f; // bits 4-0
        if (edid[EDID_V2_TIMING_SECTION_START_INDEX] & 0x80)
        {
            // size of lum table is ((3 * numLumValues) + 1) bytes
            lumTabSize = 3 * numLumValues + 1;
        }
        else
        {
            // size of lum table is (numLumValues + 1) bytes
            lumTabSize = numLumValues + 1;
        }
    }
    else
        lumTabSize = 0;

    timingCodesIndex = EDID_V2_TIMING_SECTION_START_INDEX 
                       + lumTabSize 
                       + (8 * numFreqRanges)
                       + (27 * numDetailedRanges);
    detailedTimingIndex = timingCodesIndex + (8 * numTimingCodes);

    *maxRefreshRate = 0;

    {
        // Look in the timing codes section.
        U032 hActive;
        U032 aspectRatio;
        U032 vActive;
        for (i = 0; i < numTimingCodes; i++)
        {
            index = timingCodesIndex + (4 * i);
            hActive = (edid[index] * 16) + 256;
            aspectRatio = edid[index + 2];
            // Aspect ratio is stored in terms of N:100.
			// This is not very useful because we don't get the standard vertical values.
			// So we will use the standard aspect ratios whenever we can.
			switch (aspectRatio)
			{
			case 133:
				// 4:3
				vActive = (hActive * 3) / 4;
				break;
			case 125:
				// 5:4
				vActive = (hActive * 4) / 5;
				break;
			case 177:
				// 16:9
				vActive = (hActive * 9) / 16;
				break;
			default:
                vActive = (hActive * 100) / aspectRatio;
				break;
			}
            if (hActive == hRes && vActive == vRes)
            {
                // This is the needed resolution.
                if (edid[index + 3] > *maxRefreshRate)
                {
                    *maxRefreshRate = edid[index + 3];
                }
            } // resolution matches
        } // loop over all the timing codes
    } // look in timing codes

    {
        // look in the detailed timing section
        // The detailed timing specification does not include the refresh rate.
        U032 pixelClock;
        U032 hActive, vActive, hBlank, vBlank;
        U032 hTotal, vTotal;
        U032 tmpRefresh;

        for (i = 0; i < numDetailedTimings; i++)
        {
            index = detailedTimingIndex + (18 * i);
            hActive = edid[index + 2] | ((edid[index + 4] & 0xf0) << 4);
            vActive = edid[index + 5] | ((edid[index + 7] & 0xf0) << 4);
            if (hActive == hRes && vActive == vRes)
            {
                // Resolution matches the detailed spec.
                // Get the rest of the detailed timing info needed to calculate the refresh rate.
                pixelClock = edid[index] | (edid[index + 1] << 8);
                hBlank  = edid[index + 3] | ((edid[index + 4] & 0x0f) << 8);
                vBlank  = edid[index + 6] | ((edid[index + 7] & 0x0f) << 8);

                // Horizontal Total (hActive + hBlank) gives # of pixels / line
                // Vertical total (vActive + vBlank) gives # of lines / frame
                // so HT * VT = total # pixels per frame.
                // Pixel clock is # pixels drawn / sec
                // so pixelClock / (HT * VT) gives the refresh rate (frames / sec).
                hTotal = hActive + hBlank;
                vTotal = vActive + vBlank;
                pixelClock = pixelClock * 10000;
                tmpRefresh = pixelClock / (hTotal * vTotal);

                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            } // resolution matches the detailed spec
        } // loop over all the detailed timing specs
    } // look in detailed timing section

    return RM_OK;
}
#endif  // #if 0; no one calling this puppy


// EDID Version 1.3
// Super set of 1.2, allows range limits descriptor to define coeficients for secondary GTF curve,
// and mandates a certain set of monitor descriptors.
RM_STATUS ParseEDID13(PHWINFO pDev, U032 Head)
{
	return ParseEDID11(pDev, Head);	// we can probably treat it the same as rev 1.1
}

// EDID Version 1.2
RM_STATUS ParseEDID12(PHWINFO pDev, U032 Head)
{
	return ParseEDID11(pDev, Head);	// we can probably treat it the same as rev 1.1
}

//	Parse a detailed timing block in the current EDID
//	The EDID has been saved in the global device data structure (nvInfo).
//	When native mode is requested, it is necessary to find the correct detailed timing;
//  otherwise fpParseEDID will be used to get timing info.
U032 edidParseDetailedTimingBlock(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
	switch (pDev->Dac.CrtcInfo[Head].EdidVersion)
	{
		case EDID_VERSION_10:
		case EDID_VERSION_11:
		case EDID_VERSION_12:
		case EDID_VERSION_13:
			return edidParseDetailed1(pDev, block, fpTim, Head);
		case EDID_VERSION_20:
			return edidParseDetailed2(pDev, block, fpTim, Head);
	}

	return(0);
}

//	Parse a specific detailed timing block for EDID version 1.x
//  Detailed timings are at a fixed offset from the start of the buffer.
U032 edidParseDetailed1(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;

		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * block);
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
			VSyncPulse = (VSyncOff1 & 0xf) | (SyncOvf & 0x30)<<4;

			// Return this resolution
			fpTim->PixClk = pClk;
			fpTim->HActive = HRes;
 			fpTim->HDispEnd = HRes - 1;
			fpTim->HValidEnd = HRes - 1;
	 		fpTim->HSyncStart = HSyncOffset + fpTim->HDispEnd;
 			fpTim->HSyncEnd = HSyncPulse + fpTim->HSyncStart;
 			fpTim->HValidStart = 0;
	 		fpTim->HTotal = HTotal;
				
	 		fpTim->VActive = VRes;
 			fpTim->VDispEnd = VRes - 1;
 			fpTim->VValidEnd = VRes - 1;
	 		fpTim->VSyncStart =  VSyncOffset + fpTim->VDispEnd;
	 		fpTim->VSyncEnd = VSyncPulse + fpTim->VSyncStart;
 			fpTim->VValidStart = 0;
 			fpTim->VTotal = VTotal;
			fpTim->Flags = Flags;	// includes sync polarities
			return TRUE;
		}
		return FALSE;
} // edidParseDetailedTimingBlock

// Parse detailed timings for EDID Version 2.x
// This gets a specific timing block.
// For version 2, we have to parse from the start to find the location of the block.
U032 edidParseDetailed2(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
U008	map1, map2, index, lum, rangeLimits, detailedRangeLimits;
U008	detailedTimings, timingCodes, timingCode[4];
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags, i;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;

	map1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX];
	map2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX+1];
	index =  EDID_V2_TIMING_SECTION_START_INDEX;
	// if there is a lum table, bump index beyond
	if (map1 & EDID_V2_LUM_TABLE_EXIST)
	{
		// 1st byte in timing section gives # of bytes in lum table
		lum = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_SECTION_START_INDEX];
		if (lum & TRIPLE_LUM_ENTRIES)
			index += (lum & NUM_LUM_ENTRIES*3) + 1;
		else
			index += (lum & NUM_LUM_ENTRIES) + 1;
	}
	// if there are timing range limits, bump index
	if ((rangeLimits = (map1 & EDID_V2_FREQ_RANGES)>>EDID_V2_FREQ_RANGE_SHIFT))
		index += rangeLimits * 8;
	// if there are detailed range limits, bump index
	if ((detailedRangeLimits = map1 & EDID_V2_DETAILED_RANGE_LIMITS))
		index += detailedRangeLimits * 27;
	// if there are timing codes, save them
	if ((timingCodes = (map2 & EDID_V2_TIMING_CODES)>>EDID_V2_TIMING_CODES_SHIFT))
		for (i=0; i!=timingCodes; i++)
		{
			timingCode[i] = pDev->Dac.CrtcInfo[Head].EDID[index];
			timingCode[i+1] = pDev->Dac.CrtcInfo[Head].EDID[index+1];
			timingCode[i+2] = pDev->Dac.CrtcInfo[Head].EDID[index+2];
			timingCode[i+3] = pDev->Dac.CrtcInfo[Head].EDID[index+3];
			index += 4;
		}
	// now index points to the detailed timings (if present)
	if ((detailedTimings = (map2 & EDID_V2_DETAILED_TIMINGS)))
	{
		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = index + 18 * block;
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
			VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;

			// Return this resolution
			fpTim->PixClk = pClk;
			fpTim->HActive = HRes;
	 		fpTim->HDispEnd = HRes - 1;
			fpTim->HValidEnd = HRes - 1;
	 		fpTim->HSyncStart = HSyncOffset + fpTim->HDispEnd;
	 		fpTim->HSyncEnd = HSyncPulse + fpTim->HSyncStart;
	 		fpTim->HValidStart = 0;
	 		fpTim->HTotal = HTotal;
				
	 		fpTim->VActive = VRes;
	 		fpTim->VDispEnd = VRes - 1;
	 		fpTim->VValidEnd = VRes - 1;
	 		fpTim->VSyncStart =  VSyncOffset + fpTim->VDispEnd;
	 		fpTim->VSyncEnd = VSyncPulse + fpTim->VSyncStart;
	 		fpTim->VValidStart = 0;
	 		fpTim->VTotal = VTotal;

			fpTim->Flags = Flags;
			return RM_OK;
		} // if 
	} // if detailed timings
	// check 4 byte timing codes

	return RM_ERROR;	// not supported yet
}

// EDID Version 2.0 
// Get flat panel timing from 4 byte timing code
// Use VESA GTF timing.
RM_STATUS GetTimingFromCode(U008 code, PDACFPTIMING fpTim)
{
U016	HorizCode;

	// We should be able to determine the mode from the first byte only, UNLESS
	// we start seeing panels with variable refresh rates.
	// byte 1: active pixels/line (pixels - 256)/16. Range = 256-4336.
	// byte 2: arcane info, don't know what it means. See EDID standard.
	// byte 3: aspect ration H:V.
	// byte 4: refresh rate.
	HorizCode = code * 16 + 256;
	fpTim->Flags = 0;	// sync polarities: neg, neg
	switch (HorizCode)
	{
		case 1280:
			// 1280x1024x75;
			fpTim->HActive = 1280;
			fpTim->HDispEnd = 1279;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 1279;
			fpTim->HSyncStart = 1280+15;
			fpTim->HSyncEnd = 1280+15+2;
			fpTim->HTotal = 1280+320;
			fpTim->VActive = 1024;
			fpTim->VDispEnd = 1023;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd = 1023;
			fpTim->VSyncStart = 1023+2;
			fpTim->VSyncEnd = 1023+2+24;
			fpTim->VTotal = 1024+40;
			fpTim->PixClk = 10800;	// 108 MHz
			fpTim->Flags = VSYNC_POS | HSYNC_POS;

			break;
		case 1024:
			fpTim->HActive = 1024;
			fpTim->HDispEnd = 1023;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 1023;
			fpTim->HSyncStart = 1040;
			fpTim->HSyncEnd = 1089;
			fpTim->HTotal = 1344;
			fpTim->VActive = 768;
			fpTim->VDispEnd = 767;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd = 767;
			fpTim->VSyncStart = 770;
			fpTim->VSyncEnd = 776;
			fpTim->VTotal = 805;
			fpTim->PixClk = 6500;	// 65 MHz
			fpTim->Flags = VSYNC_NEG | HSYNC_NEG;
			break;
		case 800:
			fpTim->HActive =  800;
			fpTim->HDispEnd = 799;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 799;
			fpTim->HSyncStart = 799+16;
			fpTim->HSyncEnd =  799+16+24;
			fpTim->HTotal = 800+320;
			fpTim->VActive = 600;
			fpTim->VDispEnd = 599;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd =  599;
			fpTim->VSyncStart = 599+2;
			fpTim->VSyncEnd = 599+2+24;
			fpTim->VTotal = 600+38;
			fpTim->PixClk = 4000;	// 40 MHz
			fpTim->Flags = VSYNC_POS | HSYNC_POS;
			break;
		default:
			return RM_ERROR;
	}
	return RM_OK;
}
							
// EDID Version 1.1
// Return error if no valid resolution found
RM_STATUS ParseEDID11(PHWINFO pDev, U032 Head)
{
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;
U008	est_tim1, est_tim2, block, offset, mode_count;
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags;
U032	est_tim_total, i;

	// Look for multiple resolutions in established timings to see if it supports native mode.
	// meaning the monitor can do the scaling.
 	est_tim1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_1_INDEX];
 	est_tim2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_2_INDEX];
	est_tim_total = est_tim1 | (est_tim2<<8);
	mode_count = 0;
	pDev->Dac.fpNative = 0;
	for (i=1; i<0x10000; i<<=1)
		if (est_tim_total & i)
			mode_count++;
	if (mode_count > 1)	// if more than 1 mode, monitor supports native mode.
		pDev->Dac.fpNative = 1;

	// We'll check detailed timings first. If none, look for established timings.
	// Search for largest resolution. 
	// NEED TO ADD: There could be extensions in next EDID block, too.
	pDev->Dac.fpHActive = 0;
	mode_count = 0; // check again--multiple detailed timing block also indicates native
	for (block = 0; block <4; block++)
	{
		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * block);
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<6;
			VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;
#if 0
			// Do some error checking
			if ((HRes + HSyncOffset + HSyncPulse) > (HTotal))
			{
				HSyncPulse &= 0x0f;		// pulse is too wide
				if (HSyncPulse == 0)
					HSyncPulse = 24;		// should work
			}
			if ((VRes + VSyncOffset + VSyncPulse) > (VTotal))
			{
				HSyncPulse &= 0x0f;		// pulse is too wide
				if (VSyncPulse == 0)
					VSyncPulse = 24;		// should work
			}
#endif
			if (HRes > pDev->Dac.fpHActive)	// largest yet?
			{
				// Does this fp support native mode?
				mode_count++;	
				if (mode_count > 1)
					pDev->Dac.fpNative = 1;	
				// Save this resolution as potential maximum.
				pDev->Dac.fpPixClk = pClk;
				pDev->Dac.fpHActive = HRes;
		 		pDev->Dac.fpHDispEnd = HRes - 1;
				pDev->Dac.fpHValidEnd = HRes - 1;
		 		pDev->Dac.fpHSyncStart = HSyncOffset + pDev->Dac.fpHDispEnd;
		 		pDev->Dac.fpHSyncEnd = HSyncPulse + pDev->Dac.fpHSyncStart;
		 		pDev->Dac.fpHValidStart = 0;
		 		pDev->Dac.fpHTotal = HTotal;
					
		 		pDev->Dac.fpVActive = VRes;
		 		pDev->Dac.fpVDispEnd = VRes - 1;
		 		pDev->Dac.fpVValidEnd = VRes - 1;
		 		pDev->Dac.fpVSyncStart =  VSyncOffset + pDev->Dac.fpVDispEnd;
		 		pDev->Dac.fpVSyncEnd = VSyncPulse + pDev->Dac.fpVSyncStart;
		 		pDev->Dac.fpVValidStart = 0;
		 		pDev->Dac.fpVTotal = VTotal;
				pDev->Dac.fpFlags = Flags;

			}
		}
	}
	// save the max resolution this fp supports 
	pDev->Dac.fpHMax = pDev->Dac.fpHActive;
	pDev->Dac.fpVMax = pDev->Dac.fpVActive;

	// If we found a valid detailed timing descriptor, use it.
	if (pDev->Dac.fpHActive)
		return RM_OK;

	// Check the "established timings" and if more than one, pick the highest.
	// There are currently no flat panels supporting refresh other than 60 Hz, so 
	// treat timings with different refresh but the same resolution as the same.
	if(est_tim1 & 0x3c)
 	{
		pDev->Dac.fpHActive = 0;	// no 640 panels. Return error unless we find higher res.
	}
	if(est_tim1 & 0x03)
	{
		// 800x600 60
		pDev->Dac.fpHActive =  800;
		pDev->Dac.fpHDispEnd = 799;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 799;
		pDev->Dac.fpHSyncStart = 799+16;
		pDev->Dac.fpHSyncEnd =  799+16+24;
		pDev->Dac.fpHTotal = 800+320;
		pDev->Dac.fpVActive = 600;
		pDev->Dac.fpVDispEnd = 599;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd =  599;
		pDev->Dac.fpVSyncStart = 599+2;
		pDev->Dac.fpVSyncEnd = 599+2+24;
		pDev->Dac.fpVTotal = 600+38;
		pDev->Dac.fpPixClk = 4000;	// 40 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}

	// established timing 2 should take precedence over 1, since it has higher resolutions
	if(est_tim2 & 0xc0)
 	{
		// 800x600 60
		pDev->Dac.fpHActive =  800;
		pDev->Dac.fpHDispEnd = 799;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 799;
		pDev->Dac.fpHSyncStart = 799+16;
		pDev->Dac.fpHSyncEnd =  799+16+24;
		pDev->Dac.fpHTotal = 800+320;
		pDev->Dac.fpVActive = 600;
		pDev->Dac.fpVDispEnd = 599;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd =  599;
		pDev->Dac.fpVSyncStart = 599+2;
		pDev->Dac.fpVSyncEnd = 599+2+24;
		pDev->Dac.fpVTotal = 600+38;
		pDev->Dac.fpPixClk = 4000;	// 40 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}
	if(est_tim2 & 0x1e)	// lumping together 60Hz, 70 Hz, 75 Hz, and 87 Hz under the assumption
						// that DFP's which support > 60 Hz (if any) will have detailed timings.
	{
		// 1024x768x60;
		pDev->Dac.fpHActive = 1024;
		pDev->Dac.fpHDispEnd = 1023;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 1023;
		pDev->Dac.fpHSyncStart = 1040;
		pDev->Dac.fpHSyncEnd = 1089;
		pDev->Dac.fpHTotal = 1344;
		pDev->Dac.fpVActive = 768;
		pDev->Dac.fpVDispEnd = 767;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd = 767;
		pDev->Dac.fpVSyncStart = 770;
		pDev->Dac.fpVSyncEnd = 776;
		pDev->Dac.fpVTotal = 805;
		pDev->Dac.fpPixClk = 6500;	// 65 MHz
		pDev->Dac.fpFlags = VSYNC_NEG | HSYNC_NEG;
	}
	if(est_tim2 & 0x01)
	{
		// 1280x1024x75;
		pDev->Dac.fpHActive = 1280;
		pDev->Dac.fpHDispEnd = 1279;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 1279;
		pDev->Dac.fpHSyncStart = 1280+15;
		pDev->Dac.fpHSyncEnd = 1280+15+2;
		pDev->Dac.fpHTotal = 1280+320;
		pDev->Dac.fpVActive = 1024;
		pDev->Dac.fpVDispEnd = 1023;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd = 1023;
		pDev->Dac.fpVSyncStart = 1023+2;
		pDev->Dac.fpVSyncEnd = 1023+2+24;
		pDev->Dac.fpVTotal = 1024+40;
		pDev->Dac.fpPixClk = 10800;	// 108 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}

	if (pDev->Dac.fpHActive)
	{
		// save the max resolution this fp supports 
		pDev->Dac.fpHMax = pDev->Dac.fpHActive;
		pDev->Dac.fpVMax = pDev->Dac.fpVActive;
		return RM_OK;
	}
	else
		return RM_ERROR;
 }

// EDID Version 2.x
// The first 128 bytes is not very interesting to us (I think), except the last 2 bytes,
// which are the map into second 128 bytes, which contain the luminance table and 
// timing descriptions.
// In order to get to the detailed timings, we have to parse thru the lum table, frequency
// ranges, detailed range limits, and timing codes. These are optional fields, so nothing is
// found at a fixed offset. The map bytes tell whether the fields are present.
RM_STATUS ParseEDID2(PHWINFO pDev, U032 Head)
{
RM_STATUS status;
U008	map1, map2, index, lum, rangeLimits, detailedRangeLimits;
U008	detailedTimings, block, timingCodes;
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags, i;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;
U008    mode_count = 0;
U008	timingCode[4*31];
DACFPTIMING fpTim;

	map1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX];
	map2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX+1];
	index =  EDID_V2_TIMING_SECTION_START_INDEX;
	// if there is a lum table, bump index beyond
	if (map1 & EDID_V2_LUM_TABLE_EXIST)
	{
		// 1st byte in timing section gives # of bytes in lum table
		lum = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_SECTION_START_INDEX];
		if (lum & TRIPLE_LUM_ENTRIES)
			index += ((lum & NUM_LUM_ENTRIES)*3) + 1;
		else
			index += (lum & NUM_LUM_ENTRIES) + 1;
	}
	// if there are timing range limits, bump index
	if ((rangeLimits = (map1 & EDID_V2_FREQ_RANGES)>>EDID_V2_FREQ_RANGE_SHIFT))
		index += rangeLimits * 8;
	// if there are detailed range limits, bump index
	if ((detailedRangeLimits = map1 & EDID_V2_DETAILED_RANGE_LIMITS))
		index += detailedRangeLimits * 27;
	// if there are timing codes, save them
	if ((timingCodes = (map2 & EDID_V2_TIMING_CODES)>>EDID_V2_TIMING_CODES_SHIFT))
		for (i=0; i!=timingCodes; i++)
		{
			timingCode[i] = pDev->Dac.CrtcInfo[Head].EDID[index];
			timingCode[i+1] = pDev->Dac.CrtcInfo[Head].EDID[index+1];
			timingCode[i+2] = pDev->Dac.CrtcInfo[Head].EDID[index+2];
			timingCode[i+3] = pDev->Dac.CrtcInfo[Head].EDID[index+3];
			index += 4;
		}
	// now index points to the detailed timings (if present)
	if ((detailedTimings = (map2 & EDID_V2_DETAILED_TIMINGS)))
	{
		for (block = 0; block < detailedTimings; block++)
		{
			// A detailed timing block is 27 bytes
			// There can be up to 7 detailed timing blocks, immediately following the timing codes
			pClk = pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block];
			pClk |= (pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block + 1])<<8;
			if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
			{
				// Does this fp support native mode?
				// Another way to check would be to see if detailedTimings > 1,
				// but what if we find multiple detailed timings for the same resolution?
				mode_count++;	
				if (mode_count > 1)
					pDev->Dac.fpNative = 1;	

				// Seems valid, get info
				offset = index + 18 * block;
				HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
				HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
				HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
				VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
				VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
				VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
				HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
				HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
				VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
				SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
				Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

				// Get timing into useful format
				HRes = HActive1 | (HActive2 & 0xf0)<<4;
				VRes = VActive1 | (VActive2 & 0xf0)<<4;
				HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
				VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
				HTotal = HRes + HBlank;
				VTotal = VRes + VBlank;
				HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
				HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
				VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
				VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;

				if (HRes > pDev->Dac.fpHActive)	// largest yet?
				{
					// Return this resolution
					pDev->Dac.fpPixClk = pClk;
					pDev->Dac.fpHActive = HRes;
	 				pDev->Dac.fpHDispEnd = HRes - 1;
					pDev->Dac.fpHValidEnd = HRes - 1;
			 		pDev->Dac.fpHSyncStart = HSyncOffset + pDev->Dac.fpHDispEnd;
			 		pDev->Dac.fpHSyncEnd = HSyncPulse + pDev->Dac.fpHSyncStart;
	 				pDev->Dac.fpHValidStart = 0;
	 				pDev->Dac.fpHTotal = HTotal;
				
		 			pDev->Dac.fpVActive = VRes;
			 		pDev->Dac.fpVDispEnd = VRes - 1;
		 			pDev->Dac.fpVValidEnd = VRes - 1;
	 				pDev->Dac.fpVSyncStart =  VSyncOffset + pDev->Dac.fpVDispEnd;
		 			pDev->Dac.fpVSyncEnd = VSyncPulse + pDev->Dac.fpVSyncStart;
		 			pDev->Dac.fpVValidStart = 0;
		 			pDev->Dac.fpVTotal = VTotal;
	
					// save the max resolution this fp supports 
					pDev->Dac.fpHMax = pDev->Dac.fpHActive;
					pDev->Dac.fpVMax = pDev->Dac.fpVActive;
					pDev->Dac.fpFlags = Flags;
				}
			} // if 
		} // for
		return RM_OK;
	} // if detailed timings

	// If no detailed timings, check 4 byte timing codes
	// byte 1: active pixels/line (pixels - 256)/16. Range = 256-4336.
	// byte 2: arcane info, don't know what it means. See EDID standard.
	// byte 3: aspect ration H:V.
	// byte 4: refresh rate.
	pDev->Dac.fpHActive = 0;
	mode_count = 0;
	for (i=0; i < timingCodes; i++)	// search all codes for max res
	{
		status =  GetTimingFromCode(timingCode[i*4], &fpTim);		
		if (status == RM_OK)
			if (fpTim.HTotal > pDev->Dac.fpHActive) // new max?
			{
				mode_count++;
				pDev->Dac.fpPixClk = fpTim.PixClk;
				pDev->Dac.fpHActive = fpTim.HActive;
			 	pDev->Dac.fpHDispEnd = fpTim.HDispEnd;
				pDev->Dac.fpHValidEnd = fpTim.HValidEnd;
	 			pDev->Dac.fpHSyncStart = fpTim.HSyncStart;
			 	pDev->Dac.fpHSyncEnd = fpTim.HSyncEnd;
			 	pDev->Dac.fpHValidStart = fpTim.HValidStart;
			 	pDev->Dac.fpHTotal = fpTim.HTotal;
					
	 			pDev->Dac.fpVActive = fpTim.VActive;
			 	pDev->Dac.fpVDispEnd = fpTim.VDispEnd;
			 	pDev->Dac.fpVValidEnd = fpTim.VValidEnd;
			 	pDev->Dac.fpVSyncStart = fpTim.VSyncStart;
		 		pDev->Dac.fpVSyncEnd = fpTim.VSyncEnd;
			 	pDev->Dac.fpVValidStart = fpTim.VValidStart;
	 			pDev->Dac.fpVTotal = fpTim.VTotal;
				pDev->Dac.fpFlags = fpTim.Flags;
				pDev->Dac.fpHMax = pDev->Dac.fpHActive;
				pDev->Dac.fpVMax = pDev->Dac.fpVActive;
			}
	}
	if (pDev->Dac.fpHActive)	// if we found a mode
	{
		if (mode_count > 1)
			pDev->Dac.fpNative = 1;	
		return RM_OK;
	}
	return RM_ERROR;
}

// Parse the EDID buffer (read earlier) to determine if we have valid timings.
// 
RM_STATUS fpParseEDID(PHWINFO pDev, U032 Head)
{
U032 status = RM_ERROR;	
    // The EDID may contain "established timings", a bit map of flags showing supported 
	// resolutions, or "standard timings", a 2-byte description of horizontal res + aspect ratio,
	// or "detailed timings", an 18-byte description.
	// Version 1.x EDID starts with an 8-byte header: 00 FF FF FF FF FF FF 00.
    if (pDev->Dac.CrtcInfo[Head].EDID[0] == 0)
        if (pDev->Dac.CrtcInfo[Head].EDID[1] == 0xFF)
            if (pDev->Dac.CrtcInfo[Head].EDID[7] == 0)
            {
                // Version 1 header
                if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VERSION_NUMBER_INDEX] == 1)
                {
                    switch (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_REVISION_NUMBER_INDEX]) 
                    {
                        case 0:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_10;
                            status = ParseEDID11(pDev, Head);	// Version 1.0 just like 1.1
                            break;
                        case 1:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_11;
                            status = ParseEDID11(pDev, Head);	// Version 1.1
                            break;
                        case 2:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_12;
                            status = ParseEDID12(pDev, Head);
                            break;
                        case 3:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_13;
                            status = ParseEDID13(pDev, Head);
                            break;
                        default:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_14; // This doesn't currently exist, but just in case
                            status = ParseEDID13(pDev, Head);
                            break;
                    }

                    // Is this is a digital device or analog?
                    if (!(pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7)))
                        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_MONITOR;    
                    else    
                        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_FLAT_PANEL;    
                    return status;	

                }
                else // Version 1 header, but not version 1 ID?
                {
                    return RM_ERROR;
                }
            }
	// Does not have version 1 header, check version 2
    if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0)
    {
        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_MONITOR;    
        return RM_ERROR; // its a CRT	
    }
    else    
    {
        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_FLAT_PANEL;    
    }

    pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_20;
    return	ParseEDID2(pDev, Head);
}

BOOL edidIsAnalogDisplay(PHWINFO pDev, U032 Head) 
{
U032 version;

 	version = edidGetVersion(pDev, Head);
	if (version == 1)
	{
		// Verify this is an analog device
		if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))
			return FALSE; // 1=digital
		else
			return TRUE;
	}
	if (version == 2)
		if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0)
			return TRUE;
	return FALSE;
}

BOOL edidIsDigitalDisplay(PHWINFO pDev, U032 Head) 
{
U032 version;

 	version = edidGetVersion(pDev, Head);
	if (version == 1)
	{
		// Verify this is an analog device
		if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))
			return TRUE;
		else
            return FALSE; // 1=digital
	}
	if (version == 2)
		if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) != 0)
			return TRUE;
	return FALSE;
}

//
// Generate an EDID appropriate for the current mobile panel in use
//
RM_STATUS edidConstructMobileInfo
(
    PHWINFO pDev,
    U032    Head,
    U008    *pEdid
)
{

    //
    // We need to generate an EDID given the current BIOS default panel
    // info, but until the BIOS is ready for this, just return the
    // default EDID for the mobile panels
    //
    // 
    // We need to construct the EDID from the BIOS data, but for now just drop in a std panel EDID
    //
    U032 i, panel_type;
    U008 dfp_edid_SXGA[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x30, 0x2A, 0x78, 0x20, 0x51, 0x1A,
         0x10, 0x40, 0x30, 0x70, 0x13, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x3c, 0x3c, 0x1E,
         // original 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x64, 0x0C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x53, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0xCF
         // original 0x53, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0xD4
    };

    U008 dfp_edid_UXGA[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x48, 0x3F, 0x40, 0x30, 0x62, 0xB0,
         0x32, 0x40, 0x40, 0xC0, 0x13, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x3c, 0x3c, 0x1E,
         // original 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x64, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         // original 0x64, 0x0C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x55, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0x9A
         // original 0x55, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0xA4
    };

    U008 dfp_edid_Toshiba_10x7[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4, 
         0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02, 
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B, 
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41, 
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
         0x01, 0x01, 0x01, 0x01, 0x64, 0x19, 0x00, 0x40, 0x41, 0x00, 
         0x26, 0x30, 0x18, 0x88, 0x36, 0x00, 0x2C, 0xE4, 0x10, 0x00, 
         0x00, 0x18, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x3C, 0x3C, 0x1E,
         // original 0x00, 0x18, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x46, 0x08, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00, 
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F, 
         0x58, 0x47, 0x41, 0x0A, 0x20, 0x20, 0x00, 0x60
         // original 0x58, 0x47, 0x41, 0x0A, 0x20, 0x20, 0x00, 0x65
    };


    // Toshiba?
    if (pDev->Power.MobileOperation == 2)
    {
        for (i=0;i<128;i++)
            //pDev->Dac.CrtcInfo[Head].EDID[i] = dfp_edid_Toshiba_10x7[i];
            pEdid[i] = dfp_edid_Toshiba_10x7[i];
    } 
    else
    {

        //
        // Dell Strapping assignments
        //
        //- SXGA+ panels            Panel ID     Timing        
        //    Hitachi  15"           0xE          SXGA+ (pclk = 108Mhz)      
        //    Sharp 15"              0x8          SXGA+       
        //    Unknown supplier       0x2          SXGA+       
        //    Unknown supplier       0x7          SXGA+      
        //  
        //- UXGA panels                
        //    Unknown supplier       0x3          UXGA  ( pclk =162Mhz )
        //    Unknown supplier       0x4          UXGA  ( pclk =162Mhz )
        //    Unknown supplier       0x5          UXGA  ( pclk =162Mhz )
        //    Unknown supplier       0xA          UXGA  ( pclk =162Mhz )
        //    Unknown supplier       0xB          UXGA  ( pclk =162Mhz )
    
        //
        // Strapped for UXGA???
        //
        panel_type = REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_USER_MOBILE) & 0x0F; 
        if ((panel_type == 0x03) || (panel_type == 0x04) || (panel_type == 0x05) 
            || (panel_type == 0x0A) || (panel_type == 0x0B))
        {
            for (i=0;i<128;i++)
                //pDev->Dac.CrtcInfo[Head].EDID[i] = dfp_edid_UXGA[i];
                pEdid[i] = dfp_edid_UXGA[i];
        }
        //
        // Strapped for SXGA+???
        //
        else    // assume SXGA+ if nothing else
        {
            for (i=0;i<128;i++)
                //pDev->Dac.CrtcInfo[Head].EDID[i] = dfp_edid_SXGA[i];
                pEdid[i] = dfp_edid_SXGA[i];
        }
    }

    return RM_OK;

}

//  Get the VESA DDC Capabilites status word
//  The lower 5 bits is a bit map of addresses at which a display will respond (A0, A2, A6);
//  bit 7 is set if there is more than one controller;
//  the upper byte is the response latency in seconds.
U032 edidGetDDCCaps
(
    PHWINFO pDev
)
{
    U008 lock, Adr = 0, Data = 0;
    U032 Caps = 0x100;  // set 1 second response (minimum)
    U032 Head, i2cPortId;

    if (IsNV5orBetter(pDev)) 
    {
        Caps |= 0x80;   // multiple DDC ports
    }
    // Currently we can access any device from Head 0, but in the future, who knows?
//    for (Head = 0; Head < pDev->Dac.HalInfo.NumCrtcs; Head++)   // for all heads
    for (Head = 0; Head < 1; Head++) 
    {
        lock = ReadCRTCLock(pDev, Head);	// Unlock the registers
        if (IsNV11(pDev)) 
        {
           AssocDDC(pDev, Head);  // Connect the head to the I2C pins
        }
        // Try all I2c ports
        // NOTE: we have to know how many I2C ports there are--there is no define.
        for (i2cPortId = 0; i2cPortId < 3; i2cPortId++) 
        {
            // Send a byte (any data) to subaddress 0 and see if the device acks it.
            // Try all three monitor addresses
            if (!(Caps & 0x02)) // if we already set this bit, no need to do it again, as there is a noticeable delay
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data))
                    Caps |= 0x02;
            if (!(Caps & 0x08))
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR2, 1, &Adr, 0, &Data))
                    Caps |= 0x08;
            if (!(Caps & 0x10))
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR3, 1, &Adr, 0, &Data))
                    Caps |= 0x10;
        }
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
    }
    return Caps;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dac\nv10\dacnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Arbitration **************************\
*                                                                           *
* Module: DACARB.C                                                          *
*   The DAC Arbitration management.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>

//#include <nvd3dmac.h>

/* This file simulates the NV arbitor */
#include <arb_fifo.h>
#include "nvhalcpp.h"

//LPL - memo to myself
// - clean-up to do: may not need default settings when pVidLutCurDac ptrs NULL.
// - clean up bpp overrides
// - with new top-of-buffer lwm approach, can some of the math be simplified?
// - does setting lwm based on pre-clipped burst size cause discrepancies?

//#define NV11_DEBUG

#ifdef NV11_DEBUG
U032 nv11Aware = 1;    //debug toggle between nv10/nv11 arb fns
#endif  //#ifdef NV11_DEBUG

//////////////////////////////////////////
//
// NV 11 arbitration routines
//

U032
adjust_scaler_burstsize(U032 raw, U032 min, U032 max)
{
  U032 adj;
  
  /* scaler burst sizes are a multiple of min bytes */
  adj = (raw + (min - 1)) / min * min;
  /* max burst size is 2048 bytes */
  if (adj > max)
    adj = max;  
  return adj;
}

//LPL Moved from init.c area.
void
check_scaler_burstsize(scaler_t *scaler)
{
  U032 raw;

  if (!(scaler->enable)) 
    return;

  raw = adjust_scaler_burstsize(scaler->burst_size, scaler->min_burst_size, scaler->max_burst_size);

  if (raw != scaler->burst_size)
    scaler->burst_size = raw;
}


// Data structure init routines

void
check_crtc_burstsizes(crtc_t *crtc)
{
  U032 raw = crtc->burst_size;
  
  if (!crtc->enable) return;
 
  /* crtc burst sizes are a multiple of 16 bytes */
  raw = (raw + 15) / 16 * 16;
  /* burst sizes step by 16 up to 2048 bytes*/
  if (raw > crtc->max_burst_size)
    raw = crtc->max_burst_size;
  if (raw != crtc->burst_size)
    crtc->burst_size = raw;
}

void
init_crtc(crtc_t *crtc,
      U032 enable,
      U032 hres,
      U032 vres,
      U032 depth,
      U032 refresh,
      U032 request_delay_mclks,
      U032 request_delay_pclks,
      U032 burst_size,
      U032 min_burst_size,
      U032 max_burst_size,
      U032 cursor_burst_size,
      U032 pclk,
      U032 htotal,
      mem_t *mem
      )
{
  crtc->fifo.lwm = 0;
  crtc->enable = enable;
  crtc->hres = hres;
  crtc->vres = vres;
  crtc->depth = depth;
  crtc->drain_rate = depth*100 / 8;
  crtc->refresh = refresh;
  crtc->pclk = pclk;
  crtc->pclk_period = 1000000 / crtc->pclk; //now in ps, no longer ns
  crtc->request_delay = request_delay_mclks * mem->mclk_period + request_delay_pclks * crtc->pclk_period;
  crtc->burst_size = burst_size;
  crtc->min_burst_size = min_burst_size;
  crtc->max_burst_size = max_burst_size;
  crtc->cursor_burst_size = cursor_burst_size;
  /* make sure set burst sizes are legitimate */
  check_crtc_burstsizes(crtc);
  crtc->fifo.size = 0;
  crtc->hclk_period = crtc->pclk_period * htotal / 1000;
}

void
init_scaler(scaler_t *scaler,
        crtc_t *crtc,
        crtc_t *crtc2,
        U032 nvclk,
        U032 enable,
        U032 source_hres,
        U032 source_vres,
        U032 h2_owns_vs,
        U032 depth,
        U032 hres,
        U032 vres,
        U032 burst_size,
        U032 min_burst_size,
        U032 max_burst_size,
        U032 request_delay_nvclks,
        U032 request_delay_pclks,
        U032 max_fifo_size
        )
{
  if (h2_owns_vs)
    scaler->pclk_period = crtc2->pclk_period;
  else
    scaler->pclk_period = crtc->pclk_period;

  scaler->h2_owns_vs    = h2_owns_vs;
  scaler->max_fifo_size = max_fifo_size;
 
  scaler->enable = enable;
  if (!enable) {
    scaler->burst_size = 0;
    return;
  }
  scaler->depth = depth;

  scaler->source_hres = source_hres;
  scaler->source_vres = source_vres;

  /* assume full screen scaling */
  scaler->window_hres = (h2_owns_vs) ? crtc2->hres : crtc->hres;
  scaler->window_vres = (h2_owns_vs) ? crtc2->vres : crtc->vres;

  /* This code does not allow for distorted scaling.
   * I.e., the horizontal and vertical scale factors are 
   * forced to be the same such that the video window is as
   * large as possible on the display without any geometric
   * distortion.
   */
  scaler->hscale = (1000*scaler->window_hres) / scaler->source_hres;
  scaler->vscale = (1000*scaler->window_vres) / scaler->source_vres;
  if (scaler->hscale > scaler->vscale)
    scaler->hscale = scaler->vscale;
  else
    scaler->vscale = scaler->hscale;


  scaler->burst_size = burst_size;
  scaler->min_burst_size = min_burst_size;
  scaler->max_burst_size = max_burst_size;
  scaler->request_delay = request_delay_pclks * scaler->pclk_period + request_delay_nvclks * (1000000 / nvclk);
  /* note that we never read more than the source image,
     even if we're upscaling. that's why we take the MIN
     of 1 and hscale. */
  //scaler->drain_rate = ((scaler->depth / 8)*100000) / MIN(scaler->hscale, 1000);
  scaler->drain_rate = ((scaler->depth / 8)*100000) / ((scaler->hscale < 1000) ? scaler->hscale:1000);
  if ((scaler->vscale < 1000) || 
      ((max_fifo_size != 0) && 
       ((scaler->source_hres*(scaler->depth/8)) > max_fifo_size)
      ) 
     )
    /* we're going to decimate, so we may read 2 new lines for an output line */
    scaler->drain_rate *= 2;
  /* check for a legitimate burst size */
  check_scaler_burstsize(scaler);
  scaler->fifo.size = 0;
  scaler->fifo.lwm  = 0;
}

void
init_mem(mem_t *mem,
     U032 mclk,
     U032 ddr,
     arb_type arbiter,
     U032 partitions,
     U032 partition_data_width,
     U032 page_fault_penalty,
     U032 page_fault_width,
     U032 refresh_penalty,
     U032 arbitration_latency,
     U032 pipeline_latency,
     U032 stall_cycles,
     U032 depth_cmd,
     U032 depth_rw,
     U032 interrupt_rate
     )
{
  mem->mclk = mclk;
  mem->mclk_period = 1000000 / mclk;
  mem->partitions = partitions;
  mem->ddr = ddr;
  mem->arbiter = arbiter;
  mem->data_rate = ((ddr) ? 2 : 1) * partitions * partition_data_width / 8;
  mem->page_fault_penalty = page_fault_penalty;
  mem->page_fault_width = page_fault_width;
  mem->refresh_penalty = refresh_penalty;
  mem->arbitration_latency = arbitration_latency;
  mem->pipeline_latency = pipeline_latency;
  mem->stall_cycles = stall_cycles;
  mem->cmdq_depth_cmd = depth_cmd;
  mem->cmdq_depth_rw = depth_rw;
  /* the first number is the amount of time taken to process all the read/write
     commands; the second is to allow for bus turnaround from read->write.
     the third and fourth allow for two page faults and a refresh in the
     command queue. */
//the command_latency is included in the pipeline_latency of the FBI.
//mem->command_latency = depth_rw * ((ddr) ? 2 : 4) + (depth_rw / 2) + (depth_cmd - 1) * page_fault_penalty + refresh_penalty;
  mem->command_latency = 0;
  mem->interrupt_rate = interrupt_rate;
}

void
init_rtr(rtr_t *rtr,
     U032 burst_size,
     U032 request_delay_mclks,
     mem_t *mem
     )
{
  rtr->burst_size = burst_size;
  rtr->request_delay_mclks = request_delay_mclks;
  rtr->request_delay = request_delay_mclks * mem->mclk_period;
  rtr->latency = 0;
}


// Actual buffer size calculation routines


void
guess_scaler_burstsize(scaler_t *scaler, crtc_t *crtc, crtc_t *crtc2)
{
  U032 raw, raw1, raw2;
  
  /* take a simplistic approach to guess this */

  raw1 = ((scaler->drain_rate*1000)/crtc->drain_rate )*crtc->burst_size;
  raw2 = ((scaler->drain_rate*1000)/crtc2->drain_rate)*crtc2->burst_size;
  raw  = (scaler->h2_owns_vs) ? raw2/1000 : raw1/1000;
 
  if (raw < scaler->min_burst_size) raw = scaler->min_burst_size;
  scaler->burst_size = adjust_scaler_burstsize(raw, scaler->min_burst_size, scaler->max_burst_size);
}

U032
adjust_crtc2_burstsize(U032 raw, U032 min, U032 max)
{
  U032 adj;
  
  /* scaler burst sizes are a multiple of min bytes */
  adj = (raw + (min - 1)) / min * min;
  /* max burst size is 2048 bytes */
  if (adj > max)
    adj = max;  
  return adj;
}
    
void
guess_crtc2_burstsize(crtc_t *crtc2, crtc_t *crtc)
{
  U032 raw;
  U032 period_factorx100, drain_factorx100;
  /* take a simplistic approach to guess this */
  period_factorx100 = (100*crtc->pclk_period)/crtc2->pclk_period;
  drain_factorx100  = (100*crtc2->drain_rate)/crtc->drain_rate;
  raw = (crtc->burst_size*period_factorx100*drain_factorx100)/10000;
  if (raw < crtc2->min_burst_size) raw = crtc2->min_burst_size;
  crtc2->burst_size = adjust_crtc2_burstsize(raw, crtc2->min_burst_size, crtc->max_burst_size);
}

/************************************************/
U032
compute_fifo_size(fifo_params *fifo, U032 hres, U032 drain_rate, U032 burst_size, U032 request_delay, U032 dclk_period,
          U032 burst_latency, U032 bursts_during_active, mem_t *mem)
{
  U032 lwm, lwm_min;
  U032 fifo_size;
  U032 bursts_to_fill_lwm;
  
  /* figure out the low water mark in the fifo */
  if (((hres * drain_rate)/100) > (bursts_during_active * burst_size))
    lwm = (hres * drain_rate)/100 - bursts_during_active * burst_size;
  else
    lwm = 0;

  /* make sure we have enough data in the fifo to satisfy the
     initial wait in the active phase */
//LPL need:  NVASSERT((request_delay + mem->pipeline_latency + mem->command_latency + burst_latency - burst_size) >= 0);
  lwm_min = ((((request_delay + mem->pipeline_latency + mem->command_latency + burst_latency - burst_size)
      * mem->mclk_period) / mem->data_rate) * (drain_rate / dclk_period)
      +99)/100; //forces rounding up, needed because drain_rateis 100x

  //LPL: Eep!  How many loops are possible here?
  while (lwm < lwm_min) {
    lwm += burst_size;
    bursts_during_active--;
  }

  /*added because bursts during active could be more than necessary to fetch a line*/
  bursts_to_fill_lwm = lwm/burst_size;
  if (lwm%burst_size)
    bursts_to_fill_lwm++;

  while (((bursts_to_fill_lwm + bursts_during_active - 1)*burst_size) >= ((hres*drain_rate)/100)) {
    bursts_during_active--;
  }
  
  /* fifo_size is lwm + burst_size */
  fifo_size = lwm + burst_size;

  fifo->lwm_min = lwm_min;
  fifo->lwm     = lwm;
  fifo->size    = fifo_size;

  return bursts_during_active;
}




/************************************************/
/* check to see that we are consuming sufficient bandwidth. this
   is really just an approximation since it only really considers
   the bandwidth consumed by the crtc and scaler. */
U032
not_consuming_sufficient_bandwidth(crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler, mem_t *mem, U032 burst_latency, U032 cursor_latency)
{
  U032 reqd_crtc_bw, reqd_crtc2_bw, reqd_scaler_bw;
  U032 actual_bw;
  U032 error;

  //LPL is this if needed? What's the correct return in case of error?
  //LPL Range check.
  if ((crtc->hclk_period > cursor_latency/1000) && (crtc2->hclk_period > cursor_latency/1000)) {
      reqd_crtc_bw   = (100*crtc->enable)  *crtc->hres *(crtc->depth /8) / (crtc->hclk_period  - cursor_latency/1000);
      reqd_crtc2_bw  = (100*crtc2->enable) *crtc2->hres*(crtc2->depth/8) / (crtc2->hclk_period - cursor_latency/1000);
      reqd_scaler_bw = (100*scaler->enable)*scaler->source_hres * (scaler->depth / 8) * ((scaler->vscale <= 500) ? 2 : 1) / 
                       (crtc->hclk_period - cursor_latency/1000);
      actual_bw = (1000*100*(crtc->enable*crtc->burst_size + crtc2->enable*crtc2->burst_size + scaler->enable*scaler->burst_size))
                  / (burst_latency * mem->mclk_period); //x1000000 because other bw as bytes/ns, not bytes/ps
    error = (actual_bw < (reqd_crtc_bw + reqd_crtc2_bw + reqd_scaler_bw)) ? 1 : 0;
  } else {
      error = 0;    //LPL: proper failure?
  }
//  if (actual_bw < 0) error = 0;//overflow in weird cases
  return error;
}

/*makes sure fifo size isn't larger than the maximum*/
U032 test_fifo_constraints(U032 fifo_size, crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler) 
{
  /* If dm ("Display Matrix") isn't specified at the command line, dm
   * (fifo_size here) will be 0.  In this case, no error will be returned since
   * any fifo size is OK.
   */
  if (fifo_size == 0)
    return (0);

  /* Note that fifo.size is initialized to zero for the CRTCs and scaler.
   * So, this function will not return an error just because a fifo size has 
   * yet to be computed.
   */
  return (( crtc->enable  && (crtc->fifo.size   > fifo_size))             || 
          ( crtc2->enable && (crtc2->fifo.size  > fifo_size))             || 
          (scaler->enable && (scaler->fifo.size > scaler->max_fifo_size))   );
}

/* check that there is sufficient total bandwidth available to
   support this resolution. */
U032
insufficient_total_bandwidth(crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler, mem_t *mem)
{
  U032 error;
  U032 video_bandwidth;
  U032 available_bandwidth;

  video_bandwidth = (crtc->enable  *(crtc->hres  * crtc->vres  * crtc->depth  / 8 ) *  crtc->refresh / 10 + 
                     crtc2->enable *(crtc2->hres * crtc2->vres * crtc2->depth / 8 ) * crtc2->refresh / 10 + 
                     scaler->enable*(scaler->source_hres * scaler->source_vres * 2) *
                       ((scaler->h2_owns_vs)?crtc2->refresh : crtc->refresh) / 10           );

  //LPL: this overflowed before, but switch to /10 and U032 should
  // give us plenty of breathing room
  available_bandwidth = mem->data_rate * mem->mclk * 90000;
  error = (video_bandwidth > available_bandwidth) ? 1 : 0;
  return error;
}

/* check to see that we can read sufficient data during active time assuming LWM is already reached*/
/* ASSUMES that LWM can be filled during blank.  That is, this function should always be used with 
   cant_fill_to_lwm.  Also assumes that bursts_during_active actually fits in active. */
U032
insufficient_data(U032 hres, U032 depth, U032 lwm, U032 bursts_during_active, U032 burst_size)
{
  U032 error;
  error = ((hres * depth / 8) > 
           ((lwm + burst_size - 1) / burst_size + bursts_during_active) * burst_size
          ) ? 1 : 0;
  return error;
}


/**************************************************/
/*use for NV11, NV20 and onward*/
/*should also be used for scaler NV10 onward*/
U032
new_cant_fill_to_lwm(crtc_t *crtc, mem_t *mem, U032 burst_latency, U032 cursor_latency, U032 bursts_during_active)
{
    U032 error;
    U032 bursts_during_available;

#if 1//def TWINHEAD_OPTS
    U032 temp;
    temp = (bursts_during_active * burst_latency + cursor_latency + mem->pipeline_latency)
        * mem->mclk_period + crtc->request_delay;
    if ((crtc->hclk_period * 1000) >= temp) {
        bursts_during_available = (crtc->hclk_period * 1000 - temp)
            / (burst_latency * mem->mclk_period);
        error = (crtc->fifo.lwm > bursts_during_available * crtc->burst_size) ? 1 : 0;
    } else {
        error = 1;  //LPL: proper error?
    }
#else    //#ifdef TWINHEAD_OPTS
  bursts_during_available = ((crtc->hclk_period * 1000 -
                  bursts_during_active * burst_latency * mem.mclk_period -
                  cursor_latency                       * mem.mclk_period -
                  mem.pipeline_latency                 * mem.mclk_period -
                  crtc->request_delay
                 ) /
                 (burst_latency * mem.mclk_period)
                );
  error = (crtc->fifo.lwm > bursts_during_available * crtc->burst_size) ? 1 : 0;
#endif    //#ifdef TWINHEAD_OPTS

  return error;
}



U032
scaler_cant_fill_to_lwm(scaler_t *scaler, crtc_t *crtc, crtc_t *crtc2, mem_t *mem, U032 burst_latency, U032 cursor_latency, U032 bursts_during_active)
{
    U032 error;
    U032 bursts_during_available;
    U032 hclk_period;

#if 1//def TWINHEAD_OPTS
    U032 temp;

    if (scaler->h2_owns_vs) hclk_period = crtc2->hclk_period;
    else hclk_period = crtc->hclk_period;

    temp = (bursts_during_active * burst_latency + cursor_latency + mem->pipeline_latency) * mem->mclk_period
        + scaler->request_delay;

    if ((hclk_period * 1000) >= temp) {
        bursts_during_available = (hclk_period * 1000 - temp)
            / (burst_latency * mem->mclk_period);
        error = (scaler->fifo.lwm > bursts_during_available * scaler->burst_size) ? 1 : 0;
    } else {
        error = 0;  //LPL proper error?
    }
#else    //#ifdef TWINHEAD_OPTS
  if (scaler->h2_owns_vs)
  {
    bursts_during_available = ((crtc2->hclk_period * 1000 -
                      bursts_during_active * burst_latency * mem.mclk_period -
                    cursor_latency                       * mem.mclk_period -
                    mem.pipeline_latency                 * mem.mclk_period -
                    scaler->request_delay
                   ) /
                   (burst_latency * mem.mclk_period)
                  );
  } else
  {
    bursts_during_available = ((crtc->hclk_period * 1000  -
                      bursts_during_active * burst_latency * mem.mclk_period -
                    cursor_latency                       * mem.mclk_period -
                    mem.pipeline_latency                 * mem.mclk_period -
                    crtc->request_delay
                   ) /
                   (burst_latency * mem.mclk_period)
                  );
  }
  error = (scaler->fifo.lwm > bursts_during_available * scaler->burst_size) ? 1 : 0;
#endif    //#ifdef TWINHEAD_OPTS

  return error;
}



/***********************************************/
/*Note: this function is analogous to test_scaler_constraints.  
  Any modifications here will often also need to be made to 
  test_scaler_constraints.
  "someday" the crtc_t and scaler_t data types should be unified so these
  two functions can also be unified.  OOP would have been nice here. . .
  */
U032
test_crtc_constraints(crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler, rtr_t *rtr, mem_t *mem)
{
  U032 errors = 0;
  U032 burst_latency;
  U032 cursor_latency;
  U032 bursts_during_active;
  U032 final_bursts_during_active;
  U032 num_rtrs, total_burst_size;
  U032 burst_temp, burst_temp2;

  if (!crtc->enable) return 0;
 
  num_rtrs         = crtc->enable + crtc2->enable + scaler->enable;
  total_burst_size =  crtc->enable*crtc->burst_size + crtc2->enable*crtc2->burst_size + scaler->enable*scaler->burst_size;

  burst_latency = num_rtrs         * mem->arbitration_latency + 
                  total_burst_size / mem->data_rate           +
                  num_rtrs         * mem->stall_cycles        +
                  (crtc->enable    * ((crtc->burst_size   + mem->page_fault_width - 1) / mem->page_fault_width) +
                   crtc2->enable   * ((crtc2->burst_size  + mem->page_fault_width - 1) / mem->page_fault_width) +
                   scaler->enable  * ((scaler->burst_size + mem->page_fault_width - 1) / mem->page_fault_width)
                  ) * mem->page_fault_penalty;

  
  /*note that cursor_latency is a on a per-CRTC basis, not total cusor_latency.*/
  /*note also that NV11 needs to treat cursor latency as taking a CRTC burst.  */
  cursor_latency = mem->arbitration_latency + (crtc->cursor_burst_size) / mem->data_rate + mem->stall_cycles;
  if (not_consuming_sufficient_bandwidth(crtc, crtc2, scaler, mem, burst_latency, cursor_latency * mem->mclk_period)) {
    errors++;
  }
  if (errors)
    return errors;

  /* optimistic case */
#if 1
  burst_temp = crtc->hres * crtc->pclk_period + crtc->burst_size * mem->mclk_period / mem->data_rate;
  burst_temp2 =  crtc->request_delay
      + (mem->pipeline_latency + mem->command_latency) * mem->mclk_period
      + 100 * crtc->burst_size * crtc->pclk_period / crtc->drain_rate;

  if (burst_temp >= burst_temp2) {
      bursts_during_active =  (burst_temp - burst_temp2) / (burst_latency * mem->mclk_period);
  } else {
      bursts_during_active = 0;
  }

#else
  bursts_during_active = (crtc->hres           * crtc->pclk_period -
                  crtc->request_delay                      -
                  mem->pipeline_latency * mem->mclk_period   -
                  mem->command_latency  * mem->mclk_period   -
                  100 * crtc->burst_size     * crtc->pclk_period / crtc->drain_rate +
                  crtc->burst_size     * mem->mclk_period   / mem->data_rate
                 ) /
                 (burst_latency * mem->mclk_period);
#endif

  final_bursts_during_active = compute_fifo_size(&crtc->fifo, crtc->hres, crtc->drain_rate, crtc->burst_size,
                         crtc->request_delay, crtc->pclk_period, burst_latency, bursts_during_active,
                         mem);

  /* can we fill to the LWM mark in the blanking period?
     note that we have to wait for the cursor burst to go first.
     for "new" mode operation, we can also start filling during
     the previous scan-out. */
  if (new_cant_fill_to_lwm(crtc, mem, burst_latency, (crtc->enable+crtc2->enable)*cursor_latency, final_bursts_during_active)) {
    errors++;
  }
  
  /* can we get enough data? */
  if (insufficient_data(crtc->hres, crtc->depth, crtc->fifo.lwm, final_bursts_during_active, crtc->burst_size)) {
    errors++;
  }

  if (errors) return errors;

  /* pessimistic case -- if this is the pessimistic case, why even try the previous case?*/
  //burst_latency += MAX(((100*crtc->burst_size * crtc->pclk_period / crtc->drain_rate / mem.mclk_period) - burst_latency, 0);
  burst_temp = 100 * crtc->burst_size * crtc->pclk_period / crtc->drain_rate / mem->mclk_period;
  if (burst_temp > burst_latency)
      burst_latency = burst_temp;

#if 1
    burst_temp = crtc->hres * crtc->pclk_period + crtc->burst_size * mem->mclk_period / mem->data_rate;
    burst_temp2 = crtc->request_delay
        + (mem->pipeline_latency + mem->command_latency) * mem->mclk_period
        + 100 * crtc->burst_size * crtc->pclk_period / crtc->drain_rate;

    if (burst_temp >= burst_temp2) {
        bursts_during_active = (burst_temp - burst_temp2) / (burst_latency * mem->mclk_period);
    } else {
      bursts_during_active = 0;
    }
#else
    bursts_during_active = (crtc->hres * crtc->pclk_period -
              crtc->request_delay -
              mem->pipeline_latency * mem->mclk_period -
              mem->command_latency * mem->mclk_period -
              100*crtc->burst_size * crtc->pclk_period / crtc->drain_rate +
              crtc->burst_size * mem->mclk_period / mem->data_rate
              ) /
             (burst_latency * mem->mclk_period);
#endif

  final_bursts_during_active = compute_fifo_size(&crtc->fifo, crtc->hres, crtc->drain_rate, crtc->burst_size,
                       crtc->request_delay, crtc->pclk_period, burst_latency, bursts_during_active,
                         mem);

  /* can we fill to the LWM mark in the blanking period? */
  if (new_cant_fill_to_lwm(crtc, mem, burst_latency, (crtc->enable+crtc2->enable)*cursor_latency, final_bursts_during_active)) {
    errors++;
  }
  
  /* can we get enough data? */
  if (insufficient_data(crtc->hres, crtc->depth, crtc->fifo.lwm, final_bursts_during_active, crtc->burst_size)) {
    errors++;
  }

  return errors;
}



/***********************************************/
U032
test_scaler_constraints(scaler_t *scaler, crtc_t *crtc, crtc_t *crtc2, rtr_t *rtr, mem_t *mem)
{
  U032 errors = 0;
  U032 burst_latency;
  U032 bursts_during_active;
  U032 final_bursts_during_active;
  U032 num_rtrs, total_burst_size;
  U032 burst_temp, burst_temp2;
      
  if (!scaler->enable) return 0;

  /*intermediate values used to calculate burst_latency*/
  num_rtrs         = crtc->enable + crtc2->enable + scaler->enable;
  total_burst_size = crtc->enable*crtc->burst_size + crtc2->enable*crtc2->burst_size + scaler->enable*scaler->burst_size;

  burst_latency = num_rtrs         * mem->arbitration_latency + 
                  total_burst_size / mem->data_rate           +
                  num_rtrs         * mem->stall_cycles        +
                  (crtc->enable   * ((crtc->burst_size  +mem->page_fault_width-1) / mem->page_fault_width) +
                   crtc2->enable  * ((crtc2->burst_size +mem->page_fault_width-1) / mem->page_fault_width) +
                   scaler->enable * ((scaler->burst_size+mem->page_fault_width-1) / mem->page_fault_width)
                  ) * mem->page_fault_penalty;

  
  /* optimistic case */
#if 1
  burst_temp = scaler->window_hres * scaler->pclk_period + scaler->burst_size * mem->mclk_period / mem->data_rate;
  burst_temp2 = scaler->request_delay
      + (mem->pipeline_latency + mem->command_latency) * mem->mclk_period
      + 100 * scaler->burst_size * scaler->pclk_period / scaler->drain_rate;

    if (burst_temp >= burst_temp2) {
        bursts_during_active = (burst_temp - burst_temp2) / (burst_latency * mem->mclk_period);
    } else {
      bursts_during_active = 0;
    }
#else
  bursts_during_active = (scaler->window_hres  * scaler->pclk_period -
                 scaler->request_delay -
                 mem->pipeline_latency * mem->mclk_period -
                 mem->command_latency  * mem->mclk_period -
                 100*scaler->burst_size   * scaler->pclk_period / scaler->drain_rate +
                 scaler->burst_size   * mem->mclk_period / mem->data_rate
                 ) /
                (burst_latency * mem->mclk_period);
#endif

  final_bursts_during_active = compute_fifo_size(&scaler->fifo, scaler->window_hres, scaler->drain_rate, scaler->burst_size,
               scaler->request_delay, scaler->pclk_period, burst_latency, bursts_during_active,
               mem);

  if (scaler_cant_fill_to_lwm(scaler, crtc, crtc2, mem, burst_latency, 0, final_bursts_during_active)) {
    errors++;
  }
  
  /* can we get enough data? */
  if (insufficient_data(scaler->source_hres, scaler->depth, scaler->fifo.lwm, final_bursts_during_active, scaler->burst_size)) {
    errors++;
  }

  if (errors) return errors;

  /* pessimistic case */
  //burst_latency += MAX((100* scaler->burst_size * scaler->pclk_period / scaler->drain_rate / mem.mclk_period) - burst_latency, 0);
  burst_temp = 100* scaler->burst_size * scaler->pclk_period / scaler->drain_rate / mem->mclk_period;
  if (burst_temp > burst_latency)
      burst_latency = burst_temp;

#if 1
  burst_temp = scaler->window_hres * scaler->pclk_period + scaler->burst_size * mem->mclk_period / mem->data_rate;
  burst_temp2 = scaler->request_delay
      + (mem->pipeline_latency + mem->command_latency) * mem->mclk_period
      + 100 * scaler->burst_size * scaler->pclk_period / scaler->drain_rate;

    if (burst_temp >= burst_temp2) {
        bursts_during_active = (burst_temp - burst_temp2) / (burst_latency * mem->mclk_period);
    } else {
      bursts_during_active = 0;
    }
#else
  bursts_during_active = (scaler->window_hres  * scaler->pclk_period -
                 scaler->request_delay -
                 mem->pipeline_latency * mem->mclk_period -
                 mem->command_latency  * mem->mclk_period -
                 100* scaler->burst_size   * scaler->pclk_period / scaler->drain_rate +
                 scaler->burst_size   * mem->mclk_period / mem->data_rate
                 ) /
                (burst_latency * mem->mclk_period);
#endif

  final_bursts_during_active = compute_fifo_size(&scaler->fifo, scaler->window_hres, scaler->drain_rate, scaler->burst_size,
               scaler->request_delay, scaler->pclk_period, burst_latency, bursts_during_active,
               mem);

  /* can we fill to the LWM mark in the blanking period? */
  if (scaler_cant_fill_to_lwm(scaler, crtc, crtc2, mem, burst_latency, 0, final_bursts_during_active)) {
    errors++;
  }
  
  /* can we get enough data? */
  if (insufficient_data(scaler->source_hres, scaler->depth, scaler->fifo.lwm, final_bursts_during_active, scaler->burst_size)) {
    errors++;
  }

  return errors;
}



/******************************/
U032
test_configuration(crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler, rtr_t *rtr, U032 max_burst_size, mem_t *mem, U032 fifo_size)
{
  U032 error;

  error = insufficient_total_bandwidth(crtc, crtc2, scaler, mem);
  if (error) {
    return error;
  }

  for (crtc->burst_size = crtc->min_burst_size; crtc->burst_size <= max_burst_size; crtc->burst_size += 16) {

    error = 0;

    if (scaler->enable)
    guess_scaler_burstsize(scaler, crtc, crtc2);
    if (crtc2->enable)
    guess_crtc2_burstsize(crtc2, crtc);

    error = test_crtc_constraints(crtc, crtc2, scaler, rtr, mem);
    if (error)
      continue;
    if (crtc2->enable) {
      error = test_crtc_constraints(crtc2, crtc, scaler, rtr, mem);
      if (error)
        continue;
    }
    if (test_scaler_constraints(scaler, crtc, crtc2, rtr, mem))
      error++;
    if (scaler->burst_size > max_burst_size)
    error++;

    if (test_fifo_constraints(fifo_size, crtc, crtc2, scaler))
      error++;
    if (!error) 
      break;

     if (scaler->enable) {
    for (scaler->burst_size += scaler->min_burst_size; scaler->burst_size <= max_burst_size; scaler->burst_size += 16) {
        if (test_scaler_constraints(scaler, crtc, crtc2, rtr, mem))
          error = 1;
        if (test_fifo_constraints(fifo_size, crtc, crtc2, scaler))
          error++;
      if (!error) break;
    }
    if (!error) {
      if (test_crtc_constraints(crtc, crtc2, scaler, rtr, mem))
            error = 1;
      if (crtc2->enable && test_crtc_constraints(crtc2, crtc, scaler, rtr, mem))
            error++;
    }
    }
    if (test_fifo_constraints(fifo_size, crtc, crtc2, scaler))
      error++;
    if (!error) break;
  }

  return(error);
}

//
// Main NV11 arbitration routine
//
void NV11_dacCalculateArbitration(
    PHALHWINFO pHalHwInfo,
    fifo_info *fifo,
    sim_state *arb)
{
  crtc_t crtc;
  crtc_t crtc2;
  scaler_t scaler;
  rtr_t rtr;
  mem_t mem;
//  U032 i;
//  U032 maxd, maxr;
  U032 error;
  U032 data_in_line1, data_in_line2, data_in_lineS;
 
  /*NV11 default values*/
  U032 page_fault_penalty   = 2;
  U032 page_fault_width     = 256;
  U032 arbitration_latency  = 10;
  U032 pipeline_latency     = 28;
  U032 stall_cycles         = 3;

  U032 min_burst_size   =   16;
  U032 max_burst_size   = 2048;
  U032 crtc_fifo_size   = 2048; /*CRTC fifo size in bytes*/
  U032 scaler_fifo_size = 1856; /*video scaler's fifo size*/
 
  U032 partition_data_width;
  U032 ddr;
 
  /* set up some default values for the CRTC ... */
  U032 hres    ;
  U032 htotal  ;
  U032 hres2   ;
  U032 htotal2 ;
  U032 vres    ;
  U032 vres2   ;
  U032 refresh ;
  U032 refresh2;
  U032 depth   ;
  U032 depth2  ;
  U032 crtc_request_delay_mclks = 6;
  U032 crtc_request_delay_pclks = 6;
  U032 crtc_burst_size = 0;
  U032 cursor_burst_size = 256;
  U032 crtc2_enable, crtc_enable;
  U032 video_source_hres;
  U032 video_source_vres;
  U032 h2_owns_vs  ;
  U032 mclk;
  U032 pclk, pclk2;
 
  /* ... the scaler ... */
  U032 scaler_disable;
  U032 scaler_depth = 16;
  U032 scaler_burst_size = 0;
  /*Same as FBI interface, in bytes*/
  U032 scaler_window_hres = 0;
  U032 scaler_window_vres = 0;
  U032 scaler_request_delay_mclks = 4;
  U032 scaler_request_delay_pclks = 6;
  
  /* ... the memory controller ... */
  U032 partitions = 1;
  U032 refresh_penalty = 9;
  arb_type arbiter = round_robin;
  U032 depth_cmd = 3;
  U032 depth_rw = 8;
  U032 rtr_interrupt_rate = 0;
  
  /* ... and the real-time requestor */
  /* to disable this, just leave the burst_size as 0 */
  U032 rtr_request_delay_mclks = 4;
  U032 rtr_burst_size = 0;

  U032 who_owns_scaler;

  crtc_enable       = arb->enable_h1;
  crtc2_enable      = arb->enable_h2;
  scaler_disable    = !(arb->enable_video);
  video_source_hres = arb->video_source_hres;
  video_source_vres = arb->video_source_vres;
  h2_owns_vs        = arb->h2_owns_vs;

  hres         = arb->hres;
  htotal       = arb->htotal;
  vres         = arb->vres;
  depth        = arb->pix_bpp;
  refresh      = arb->refresh;
  pclk         = arb->pclk_khz / 1000;

  hres2        = arb->hres2;
  htotal2      = arb->htotal2;
  vres2        = arb->vres2;
  depth2       = arb->pix_bpp_h2;
  refresh2     = arb->refresh2;
  pclk2        = arb->pclk2_khz / 1000;

  partition_data_width = arb->memory_width;
  ddr                  = arb->memory_type;
  mclk                 = arb->mclk_khz / 1000;

  init_mem(&mem, mclk, ddr, arbiter, partitions, partition_data_width, page_fault_penalty,
       page_fault_width, refresh_penalty, arbitration_latency, pipeline_latency, stall_cycles,
       depth_cmd, depth_rw, rtr_interrupt_rate);
  init_crtc(&crtc, crtc_enable,
            hres, vres, depth, refresh,
            crtc_request_delay_mclks, crtc_request_delay_pclks,
         crtc_burst_size, min_burst_size, max_burst_size, cursor_burst_size,
        pclk, htotal, &mem);
  init_crtc(&crtc2, crtc2_enable,
            hres2, vres2, depth2, refresh2,
            crtc_request_delay_mclks, crtc_request_delay_pclks,
         crtc_burst_size, min_burst_size, max_burst_size, cursor_burst_size,
            pclk2, htotal2, &mem);
  init_scaler(&scaler, &crtc, &crtc2, mclk,
              (scaler_disable) ? 0 : 1, video_source_hres, video_source_vres, h2_owns_vs, scaler_depth,
              scaler_window_hres, scaler_window_vres,
           scaler_burst_size, min_burst_size, max_burst_size,
           scaler_request_delay_mclks, scaler_request_delay_pclks, scaler_fifo_size);
  init_rtr(&rtr, rtr_burst_size, rtr_request_delay_mclks, &mem);

//  if ((hres2*depth2*1000/crtc2.hclk_period) > (hres*depth*1000/crtc.hclk_period)) {
  who_owns_scaler = 0;
  if (crtc2.enable && crtc.enable) {
    if ((hres2*depth2*1000/crtc2.hclk_period) > (hres*depth*1000/crtc.hclk_period))
        who_owns_scaler = 1;
  } else {
      if (crtc2.enable)
        who_owns_scaler = 1;
  }

  if (who_owns_scaler) {
    if (crtc.enable) scaler.h2_owns_vs = !scaler.h2_owns_vs; /*swap which head scaler is owned by when swapping heads*/
    error = test_configuration(&crtc2, &crtc,  &scaler, &rtr, max_burst_size, &mem, crtc_fifo_size); 
    if (crtc.enable) scaler.h2_owns_vs = !scaler.h2_owns_vs;
  } else
    error = test_configuration(&crtc,  &crtc2, &scaler, &rtr, max_burst_size, &mem, crtc_fifo_size); 

  //Compute the amount of data in a single horizontal line
  data_in_line1 = crtc.hres          * crtc.depth   / 8;
  data_in_line2 = crtc2.hres         * crtc2.depth  / 8; 
  data_in_lineS = scaler.source_hres * scaler.depth / 8;

  //It is really inefficent to have a burst size smaller than 256 bytes.
  if (crtc.burst_size   < 256)
    crtc.burst_size   = 256;
  if (crtc2.burst_size  < 256)
    crtc2.burst_size  = 256;
  if (scaler.burst_size < 256)
    scaler.burst_size = 256;

  //It is wasteful to have a burst size larger than the amount of data in a line
  if (crtc.burst_size   > data_in_line1)
    crtc.burst_size   = data_in_line1;
  if (crtc2.burst_size  > data_in_line2)
    crtc2.burst_size  = data_in_line2;
  if (scaler.burst_size > data_in_lineS)
    scaler.burst_size = data_in_lineS;


  //LPL: addition to set watermarks as high as possible instead
  // of as low as possible.  This presumably obviates the need
  // for some other calculation effort earler.

  //Get best performance for the real-time requestors by setting LWM
  //as high as possible without risking overflow.
  crtc.fifo.lwm   = crtc_fifo_size   - crtc.burst_size  ;
  crtc2.fifo.lwm  = crtc_fifo_size   - crtc2.burst_size ;
  scaler.fifo.lwm = scaler_fifo_size - scaler.burst_size;

  //LWM should not be larger than the amount of data in a line
  if (crtc.fifo.lwm > data_in_line1)
    crtc.fifo.lwm = data_in_line1;
  if (crtc2.fifo.lwm > data_in_line2)
    crtc2.fifo.lwm = data_in_line2;
  if (scaler.fifo.lwm > data_in_lineS)
    scaler.fifo.lwm = data_in_lineS;
 
  fifo->valid = !error;
  fifo->crtc1_lwm = crtc.fifo.lwm;
  fifo->crtc2_lwm = crtc2.fifo.lwm;
  fifo->video_lwm = scaler.fifo.lwm;
  fifo->crtc1_burst_size = crtc.burst_size;
  fifo->crtc2_burst_size = crtc2.burst_size;
  fifo->video_burst_size = scaler.burst_size;
}


//////////////////////////////////////////
//
// NV 10 arbitration routines
//
static
VOID NV10_dacCalculateArbitration
(
    PHALHWINFO pHalHwInfo,
    fifo_info *fifo,
    sim_state  *arb
)
{
  int data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
  int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
  int nvclk_fill, us_extra;
  int found, mclk_extra, mclk_loop, cbs, m1;
  int mclk_freq, pclk_freq, nvclk_freq, mp_enable;
  int us_m, us_m_min, us_n, us_p, video_drain_rate, crtc_drain_rate;
  int vus_m, vus_n, vus_p;
  int vpm_us, us_video, vlwm, cpm_us, us_crt,clwm;
  int clwm_rnd_down;
  int craw, m2us, us_pipe, us_pipe_min, vus_pipe, p1clk, p2;
  int pclks_2_top_fifo, min_mclk_extra;
  int us_min_mclk_extra;

  fifo->valid = 1;
  pclk_freq = arb->pclk_khz; // freq in KHz
  mclk_freq = arb->mclk_khz;
  nvclk_freq = arb->nvclk_khz;
  pagemiss = arb->mem_page_miss;
  cas = arb->mem_latency;
  width = arb->memory_width/64;
  video_enable = arb->enable_video;
  color_key_enable = arb->gr_during_vid;
  bpp = arb->pix_bpp;
  align = arb->mem_aligned;
  mp_enable = arb->enable_mp;
  clwm = 0;
  vlwm = 1024;

  cbs = 512;
  vbs = 512;

  pclks = 4; // lwm detect.

  nvclks = 3; // lwm -> sync.
  nvclks += 2; // fbi bus cycles (1 req + 1 busy)

  mclks  = 1;   // 2 edge sync.  may be very close to edge so just put one.

  mclks += 1;   // arb_hp_req
  mclks += 5;   // ap_hp_req   tiling pipeline

  mclks += 2;    // tc_req     latency fifo
  mclks += 2;    // fb_cas_n_  memory request to fbio block
  mclks += 7;    // sm_d_rdv   data returned from fbio block

  // fb.rd.d.Put_gc   need to accumulate 256 bits for read
  if (arb->memory_type == 0)
  {
    if (arb->memory_width == 64) // 64 bit bus
      mclks += 4;
    else
      mclks += 2;
  }
  else
  {
    if (arb->memory_width == 64) // 64 bit bus
      mclks += 2;
    else
      mclks += 1;
  }

  if ((!video_enable) && (arb->memory_width == 128))
  {  
    mclk_extra = (bpp == 32) ? 31 : 42; // Margin of error
    min_mclk_extra = 17;
  }
  else
  {
    mclk_extra = (bpp == 32) ? 8 : 4; // Margin of error
    //mclk_extra = 4; // Margin of error
    min_mclk_extra = 18;
  }

  nvclks += 1; // 2 edge sync.  may be very close to edge so just put one.
  nvclks += 1; // fbi_d_rdv_n
  nvclks += 1; // Fbi_d_rdata
  nvclks += 1; // crtfifo load

  if(mp_enable)
    mclks+=4; // Mp can get in with a burst of 8.
  // Extra clocks determined by heuristics

  nvclks += 0;
  pclks += 0;
  found = 0;
  while(found != 1) {
    fifo->valid = 1;
    found = 1;
    mclk_loop = mclks+mclk_extra;
    us_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
    us_m_min = mclks * 1000*1000 / mclk_freq; // Minimum Mclk latency in us
    us_min_mclk_extra = min_mclk_extra *1000*1000 / mclk_freq;
    us_n = nvclks*1000*1000 / nvclk_freq;// nvclk latency in us
    us_p = pclks*1000*1000 / pclk_freq;// nvclk latency in us
    us_pipe = us_m + us_n + us_p;
    us_pipe_min = us_m_min + us_n + us_p;
    us_extra = 0;

    vus_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
    vus_n = (4)*1000*1000 / nvclk_freq;// nvclk latency in us
    vus_p = 0*1000*1000 / pclk_freq;// pclk latency in us
    vus_pipe = vus_m + vus_n + vus_p;

    if(video_enable) {
      video_drain_rate = pclk_freq * 4; // MB/s
      crtc_drain_rate = pclk_freq * bpp/8; // MB/s

      vpagemiss = 1; // self generating page miss
      vpagemiss += 1; // One higher priority before

      crtpagemiss = 2; // self generating page miss
      if(mp_enable)
          crtpagemiss += 1; // if MA0 conflict

      vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;

      us_video = vpm_us + vus_m; // Video has separate read return path

      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =
        us_video  // Wait for video
        +cpm_us // CRT Page miss
        +us_m + us_n +us_p // other latency
        ;

      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that
    } else {
      crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

      crtpagemiss = 1; // self generating page miss
      crtpagemiss += 1; // MA0 page miss
      if(mp_enable)
          crtpagemiss += 1; // if MA0 conflict
      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =  cpm_us + us_m + us_n + us_p ;
      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that

/*
        //
        // Another concern, only for high pclks so don't do this
        // with video:
        // What happens if the latency to fetch the cbs is so large that
        // fifo empties.  In that case we need to have an alternate clwm value
        // based off the total burst fetch
        //
        us_crt = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
        us_crt = us_crt + us_m + us_n + us_p + (4 * 1000 * 1000)/mclk_freq;
        clwm_mt = us_crt * crtc_drain_rate/(1000*1000);
        clwm_mt ++;
        if(clwm_mt > clwm)
            clwm = clwm_mt;
*/
        // Finally, a heuristic check when width == 64 bits
        if(width == 1){
            nvclk_fill = nvclk_freq * 8;
            if(crtc_drain_rate * 100 >= nvclk_fill * 102)
                    clwm = 0xfff; //Large number to fail

            else if(crtc_drain_rate * 100  >= nvclk_fill * 98) {
                clwm = 1024;
                cbs = 512;
                us_extra = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
            }
        }
    }


    /*
      Overfill check:
    */

    clwm_rnd_down = ((int)clwm/8)*8;
    if (clwm_rnd_down < clwm)
        clwm += 8;
        
    m1 = clwm + cbs -  1024; /* Amount of overfill */
    m2us = us_pipe_min + us_min_mclk_extra;
    pclks_2_top_fifo = (1024-clwm)/(8*width);
    
    /* pclk cycles to drain */
    p1clk = m2us * pclk_freq/(1000*1000); 
    p2 = p1clk * bpp / 8; // bytes drained.
    
    if((p2 < m1) && (m1 > 0)) {
        fifo->valid = 0;
        found = 0;
        if(min_mclk_extra == 0)   {
          if(cbs <= 32) {
            found = 1; // Can't adjust anymore!
          } else {
            cbs = cbs/2;  // reduce the burst size
          }
        } else {
          min_mclk_extra--;
        }
    } else {
      if (clwm > 1023){ // Have some margin
        fifo->valid = 0;
        found = 0;
        if(min_mclk_extra == 0)   
            found = 1; // Can't adjust anymore!
        else 
            min_mclk_extra--;
      }
    }
    craw = clwm;
    
    if(clwm < (1024-cbs+8)) clwm = 1024-cbs+8;
    data = (int)(clwm);
    //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
    fifo->crtc1_lwm = data;   fifo->crtc1_burst_size = cbs;

    //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
    fifo->video_lwm = 1024;  fifo->video_burst_size = 512;
  }
}

/*
//
// Determine if the video overlay is usable in the current configuration.  This
// routine will also update the global variables in pDev which determine the 
// maximum downscaling allowed at various source image sizes.
//
//  Return 0 if not capable (at any upscale or downscale factor)
//  Return ~0 if capable (see pDev for downscale limits)
//
U032 NV10_dacCalculateVideoCaps
(
    PHWINFO pDev
)
{
    //
    // First look for a match of memory type, resolution, and clocks.
    //
    // NOTE: For now, until I can straighten out all of the hardware data,
    // assume a conservative limit.
    //
    switch (pDev->Chip.HalInfo.MaskRevision)
    {
        case 0xA1:
        case 0xA2:
        case 0xA6:
        
            pDev->Video.OverlayMaxDownscale_768  = 2;
            pDev->Video.OverlayMaxDownscale_1280 = 2;
            pDev->Video.OverlayMaxDownscale_1920 = 2;
            break;
            
        default:

            pDev->Video.OverlayMaxDownscale_768  = 8;
            pDev->Video.OverlayMaxDownscale_1280 = 4;
            pDev->Video.OverlayMaxDownscale_1920 = 2;
            break;
    }

    //
    // For now, always assume we can support some level of overlay
    // (although not to the same level of downscale ability)
    //
    return 1;

}
*/

typedef struct tagNV10_DacAGPClockEntry
{
    U032 frequency;
    U032 setting;
} NV10_DacAGPClockEntry;

NV10_DacAGPClockEntry NV10_dacAGPClockTable[] =
{
    { 133000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_133MHZ },
    { 126000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_126MHZ },
    { 120000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_120MHZ },
    { 113000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_113MHZ },
    { 106000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_106MHZ },
    { 100000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_100MHZ },
    { 94000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_94MHZ },
    { 87000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_87MHZ },
    { 80000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_80MHZ },
    { 73000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_73MHZ },
    { 66000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ },
    { 0, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ - 1 }
};

//
// HAL stuff
//

// forwards
RM_STATUS nvHalDacControl_NV10(VOID *);
RM_STATUS nvHalDacAlloc_NV10(VOID *);
RM_STATUS nvHalDacFree_NV10(VOID *);
RM_STATUS nvHalDacSetStartAddr_NV10(VOID *);
RM_STATUS nvHalDacProgramMClk_NV10(VOID *);
RM_STATUS nvHalDacProgramNVClk_NV10(VOID *);
RM_STATUS nvHalDacProgramPClk_NV10(VOID *);
RM_STATUS nvHalDacProgramCursorImage_NV10(VOID *);
RM_STATUS nvHalDacGetRasterPosition_NV10(VOID *);
RM_STATUS nvHalDacValidateArbSettings_NV10(VOID *arg);
RM_STATUS nvHalDacUpdateArbSettings_NV10(VOID *arg);

//
// nvHalDacControl
//
RM_STATUS
nvHalDacControl_NV10(VOID *arg)
{
    PDACCONTROLARG_000 pDacControlArg = (PDACCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEOHALINFO pVideoHalInfo;
    PDACHALINFO_NV10 pDacHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pDacControlArg->id != DAC_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacControlArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pDacHalPvtInfo = (PDACHALINFO_NV10)pHalHwInfo->pDacHalInfo;

    switch (pDacControlArg->cmd)
    {
        case DAC_CONTROL_INIT:

            // set bus width
            if (REG_RD_DRF(_PFB, _CFG, _BUS) == NV_PFB_CFG_BUS_128)
                pDacHalInfo->InputWidth = 128;
            else
                pDacHalInfo->InputWidth = 64;

            // initialize default crtc parameters
            pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 350000000;
            pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 350000000;
            pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 300000000;
            pDacHalInfo->CrtcInfo[0].RegOffset = 0x00000000;

            //
            // Head 0 supports everything (?).
            //
            pDacHalInfo->CrtcInfo[0].DisplayTypesAllowed =
                DISPLAYTYPEBIT(DISPLAY_TYPE_MONITOR) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_TV) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_DUALSURFACE) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL);

            // if we're an nv11, we need to setup a second crtc
            // The capabilities of the second head should be determined by the BIOS,
            // but for now we will hard code them. These capabilities are such things 
            // as the presence of an external DAC, and the frequency specification.

            // The values set here will be replaced in dacinit.c/initDac if it is able
            // to find the proper tables in the BIOS
            if (IsNV11_NV10(pHalHwInfo->pMcHalInfo))
            {
                U032 i, data32, crtcAddr;
                U008 lock;

                //NVASSERT(pDacHalInfo->NumCrtcs == 2);
                pDacHalInfo->CrtcInfo[1].PCLKLimit8bpp  = 150000000;
                pDacHalInfo->CrtcInfo[1].PCLKLimit16bpp = 150000000;
                pDacHalInfo->CrtcInfo[1].PCLKLimit32bpp = 150000000;
                pDacHalInfo->CrtcInfo[1].RegOffset = 0x00002000;

                //
                // Head 1 supports TV and flat panel, and CRT, if an external DAC is present
                //
                pDacHalInfo->CrtcInfo[1].DisplayTypesAllowed =
                    DISPLAYTYPEBIT(DISPLAY_TYPE_MONITOR) |      // assume external DAC
                    DISPLAYTYPEBIT(DISPLAY_TYPE_TV) |
                    DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL);

                // turn on CRTC big endian on 2nd head if we're setup for big endian mode
                if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
                {
                    U032 crtcOffset;
                    U032 config;
                    crtcOffset = pDacHalInfo->CrtcInfo[1].RegOffset;
                    config = REG_RD32(NV_PCRTC_CONFIG + crtcOffset);
                    config |= DRF_DEF(_PCRTC, _CONFIG, _ENDIAN, _BIG);
                    REG_WR32(NV_PCRTC_CONFIG + crtcOffset, config);
                }

                //
                // While we're here, increase TV out latency.
                //
                for (i = 0; i < pDacHalInfo->NumCrtcs; i++)
                {
                    crtcAddr = pDacHalInfo->CrtcInfo[i].RegOffset;

                    // Unlock CRTC extended regs
                    HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, crtcAddr);
                    HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, crtcAddr);

                    // Add 4 per Raj Rao...
                    HAL_CRTC_RD(NV_CIO_CRE_TVOUT_LATENCY, data32, crtcAddr);
                    data32 += 4;
                    HAL_CRTC_WR(NV_CIO_CRE_TVOUT_LATENCY, data32, crtcAddr);

                    // Relock if necessary...
                    if (lock == 0)
                        HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, crtcAddr);
                }
            }

            // turn on CRTC big endian if we're setup for big endian mode
            if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
            {
                FLD_WR_DRF_NUM(_PCRTC, _CONFIG, _ENDIAN, NV_PCRTC_CONFIG_ENDIAN_BIG);
            }

            //
            // Set default downscale values.
            // 
            pVideoHalInfo->OverlayMaxDownscale_768  = 8;
            pVideoHalInfo->OverlayMaxDownscale_1280 = 8;
            pVideoHalInfo->OverlayMaxDownscale_1920 = 8;

            break;
        case DAC_CONTROL_LOAD:
        case DAC_CONTROL_UNLOAD:
        case DAC_CONTROL_DESTROY:
        case DAC_CONTROL_UPDATE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

RM_STATUS
nvHalDacAlloc_NV10(VOID *arg)
{
    PDACALLOCARG_000 pDacAllocArg = (PDACALLOCARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacAllocArg->id != DAC_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Verify that class and head parameters are legal for this chip.
    //

    return (RM_OK);
}

RM_STATUS
nvHalDacFree_NV10(VOID *arg)
{
    PDACFREEARG_000 pDacFreeArg = (PDACFREEARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacFreeArg->id != DAC_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);    

    return (RM_OK);
}

RM_STATUS
nvHalDacSetStartAddr_NV10(VOID *arg)
{
    PDACSETSTARTADDRARG_000 pDacSetStartAddrArg = (PDACSETSTARTADDRARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    PDACHALINFO pDacHalInfo;
    U032    crtcOffset;
    //
    // Verify interface revision.
    //
    if (pDacSetStartAddrArg->id != DAC_SET_START_ADDR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacSetStartAddrArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT)pDacSetStartAddrArg->pHalObjInfo;

    crtcOffset = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    REG_WR32(NV_PCRTC_START + crtcOffset, pDacSetStartAddrArg->startAddr);

    return (RM_OK);
}

//
// nvHalDacProgramMClk_NV10 - Program MCLK based on the value in pDacHalInfo->MClk
//
// This routine uses the value in pDacHalInfo->MClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramMClk_NV10(VOID *arg)
{
    PDACPROGRAMMCLKARG_000 pDacProgramMClkArg = (PDACPROGRAMMCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 oldMClk;
    U032 oldCyclesPerRefresh;
    U032 oldPeriod;
    U032 newCyclesPerRefresh;
    U032 Loops;
    U032 IsPllLocked;
    U032 Head = 0; // MPLL is on head 0
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramMClkArg->id != DAC_PROGRAMMCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramMClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->MPllM;
    nNew = pDacHalInfo->MPllN;
    pNew = pDacHalInfo->MPllP;

    // Program the hardware

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
        REG_WR32
            (
                NV_PRAMDAC_MPLL_COEFF,
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pOld)
            );

        // Wait until M PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _MPLL_LOCK)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _MPLL_LOCK)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: M PLL not locked\n");
        }
    }

    // Now we can write the final value
    REG_WR32
        (
            NV_PRAMDAC_MPLL_COEFF,
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pNew)
        );

    // Wait for M PLL to lock.
    osDelay(64 /* ms */);

    // Reset (resync) the frame buffer DRAM DLL.
    FLD_WR_DRF_DEF( _PFB, _MRS, _DLL, _RESET );

    // Update the number of clock cycles per memory refresh cycle

    // Determine original frequency from old M, N, P values
    oldMClk  = (nOld * pMcHalInfo->CrystalFreq / (1 << pOld) / mOld);

    // Determine original cycles per refresh
    oldCyclesPerRefresh = REG_RD_DRF( _PFB, _TIMING2, _REFRESH ) * 32;

    // Determine original refresh period
    oldPeriod = oldCyclesPerRefresh * 1024 / ( oldMClk / 1000 );
    
    // Now using the new MCLK, figure out the new cycles per refresh
    newCyclesPerRefresh = ( pDacHalInfo->MClk / 1000 ) * oldPeriod / 1024;

    // Store the new value
    FLD_WR_DRF_NUM( _PFB, _TIMING2, _REFRESH, newCyclesPerRefresh / 32 );
    
    return status;
}

//
// nvHalDacProgramNVClk_NV10 - Program NVCLK based on the value in pDacHalInfo->NVClk
//
// This routine uses the value in pDacHalInfo->NVClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramNVClk_NV10(VOID *arg)
{
    PDACPROGRAMNVCLKARG_000 pDacProgramNVClkArg = (PDACPROGRAMNVCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 i;
    U032 Loops;
    U032 IsPllLocked;
    U032 IsPllSlowed;
    U032 Head = 0;  // NVPLL is on head 0
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramNVClkArg->id != DAC_PROGRAMNVCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramNVClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->NVPllM;
    nNew = pDacHalInfo->NVPllN;
    pNew = pDacHalInfo->NVPllP;

    // Program the hardware

    // Make sure to disable the clock slowdown circuit
    if (IsNV11_NV10(pMcHalInfo))
    {
        IsPllSlowed = REG_RD_DRF(_PBUS, _DEBUG_1, _CORE_SLOWDWN);
        FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, 0);
    }

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _PDIV, coeff);

    // Restore the clock slowdown circuit
    if (IsNV11_NV10(pMcHalInfo))
    	FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, IsPllSlowed);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
        REG_WR32
            (
                NV_PRAMDAC_NVPLL_COEFF,
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pOld)
            );

        // Wait until NV PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _NVPLL_LOCK)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _NVPLL_LOCK)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: NV PLL not locked\n");
        }
    }

    // Now we can write the final value
    REG_WR32
        (
            NV_PRAMDAC_NVPLL_COEFF,
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pNew)
        );

    // Update NV_PBUS_DEBUG_3 to control data throttling in AGP 4X mode
    i = 0;
    while ( ( pDacHalInfo->NVClk <= NV10_dacAGPClockTable[ i ].frequency ) &&
        ( i < sizeof( NV10_dacAGPClockTable ) / sizeof( NV10_dacAGPClockTable[ 0 ] ) - 1 ) )
    {
        i++;
    }

    FLD_WR_DRF_NUM( _PBUS, _DEBUG_3, _AGP_4X_NVCLK, NV10_dacAGPClockTable[ i ].setting );
    
    return status;
}

//
// nvHalDacProgramPClk_NV10
//
RM_STATUS
nvHalDacProgramPClk_NV10(VOID *arg)
{
    PDACPROGRAMPCLKARG_000 pDacProgramPClkArg = (PDACPROGRAMPCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032            CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    U032            Head;
    U032            PixelClock;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 Loops;
    U032 IsPllLocked;

    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramPClkArg->id != DAC_PROGRAMPCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramPClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramPClkArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    mNew = pDacHalInfo->VPllM;
    nNew = pDacHalInfo->VPllN;
    pNew = pDacHalInfo->VPllP;

    Head = pDacHalObj->Head;
    PixelClock = pDacProgramPClkArg->PixelClock;

    // Program the hardware

    // Retrieve original coefficients
    // NV11 VPLL2 unfortunately is not at the "expected" offset, so we can't use the HAL macro (DAC_REG_RD32)
    if (Head == 0) 
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL_COEFF );
    }
    else
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL2_COEFF );
    }
    mOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first. 
        if (Head == 0) 
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }
        else
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL2_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }

        // Wait until V PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: VPLL not locked\n");
        }
    }

    // Now we can write the final value
    if (Head == 0) 
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }
    else
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL2_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }

    return status;
}

//
// nvHalDacProgramCursorImage_NV10
//
RM_STATUS
nvHalDacProgramCursorImage_NV10(VOID *arg)
{
    PDACPROGRAMCURSORARG_000 pDacProgramCursorImgArg = (PDACPROGRAMCURSORARG_000) arg;
    PHALHWINFO  pHalHwInfo;
    PMCHALINFO  pMcHalInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032        CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    U032        cursorConfig;

    //
    // Verify interface revision.
    //
    if (pDacProgramCursorImgArg->id != DAC_PROGRAMCURSOR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramCursorImgArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramCursorImgArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    // Read the cursorConfig register.
    cursorConfig = HAL_DAC_REG_RD32(NV_PCRTC_CURSOR_CONFIG, CurDacAdr);

    // Preserve the enable and scan_double bits. Clear the rest
    cursorConfig &= ((1 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_ENABLE)) |
                     (1 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_SCAN_DOUBLE)));

    // Mark the Address Space Indicator to indicate where the cursor image is, 
    // based on the param "asi".
    cursorConfig |= (pDacProgramCursorImgArg->asi << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_ADDRESS_SPACE));

    // The supported cursor image sizes are 32x32 or 64x64.
    if (pDacProgramCursorImgArg->width == 32)
    {
        // 32x32
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_PIXELS, NV_PCRTC_CURSOR_CONFIG_CUR_PIXELS_32);
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_LINES, NV_PCRTC_CURSOR_CONFIG_CUR_LINES_32);
    }
    else
    {
        //64x64
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_PIXELS, NV_PCRTC_CURSOR_CONFIG_CUR_PIXELS_64);
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_LINES, NV_PCRTC_CURSOR_CONFIG_CUR_LINES_64);
    }

    // The different color formats are implemented by two bits: The Blend bit and Bpp bit.
    //       Blend      Bpp        Format
    //       ----------------------------
    //         0         0     ->  ROP1R5G5B5
    //         0         1     ->  PM_A8R8G8B8  *** This format is only supported in NV15 or later.
    //         1         0     ->  A1R5G5B5
    //         1         1     ->  A8R8G8B8
    switch (pDacProgramCursorImgArg->colorFormat)
    {
        case NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A1R5G5B5:
            // Set blend = 0. Bpp is already 0
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BLEND_ALPHA << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BLEND));
            break;
        case NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A8R8G8B8:
            // set blend = 1, bpp = 1
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BLEND_ALPHA << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BLEND));
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BPP_32 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BPP));
            break;
        case NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8:
            if (IsNV15orBetter_NV10(pMcHalInfo))
            {
                // set bpp = 1, blend is already 0 (only supported in NV15 or later)
                cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BPP_32 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BPP));
            }
            // else fall through to default
        default:
            // Leave blend and bpp both 0 (ROP1R5G5B5)
            break;
    }

    // write the new cursor config register value.
    HAL_DAC_REG_WR32(NV_PCRTC_CURSOR_CONFIG, cursorConfig, CurDacAdr);

    //            
    // If not driving a TV and we're on an NV15 or later, turn on the LONG_PIPE to extend the cursor FIFO
    // when running 32bpp or alpha cursors; otherwise, keep it short.
    //
    // Note that this means that 16bpp Alpha and 32bpp cursors are not allowed on a TV.
    //
    // TO DO: there is much unnecessary logic here -- can this all be collapsed into one write?
    if (IsNV15orBetter_NV10(pMcHalInfo))
    {   
        if (HAL_GETDISPLAYTYPE(pDacHalObj->Head) != DISPLAY_TYPE_TV)
        {
            if ((pDacProgramCursorImgArg->colorFormat == NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A1R5G5B5) ||
                (pDacProgramCursorImgArg->colorFormat == NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A8R8G8B8) ||
                (pDacProgramCursorImgArg->colorFormat == NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8))
            {    
                HAL_DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIPE, _LONG, CurDacAdr);                
            }
            else
            {
                // forcing a long pipe works around a HW bug where inverted background causes screen tearing effects
                HAL_DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIPE, _LONG, CurDacAdr); 
            }    
        }
        else
        {
            HAL_DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIPE, _LONG, CurDacAdr); 
        }
    }

    // Program the start address.
    // If the address space indicator says it is in Instance Memory, the startAddr is in terms of 
    // paragraphs instead of bytes. Adjust it to bytes.
    if (pDacProgramCursorImgArg->asi == NV_PCRTC_CURSOR_CONFIG_ADDRESS_SPACE_PINST)
    {
        pDacProgramCursorImgArg->startAddr <<= 4;
    }

    HAL_DAC_REG_WR32(NV_PCRTC_CURSOR, pDacProgramCursorImgArg->startAddr, CurDacAdr);

    return RM_OK;
}

//
// nvHalDacGetRasterPosition_NV10
//
RM_STATUS
nvHalDacGetRasterPosition_NV10(VOID *arg)
{
    PDACRASTERPOSARG_000 pDacRasterPosArg = (PDACRASTERPOSARG_000) arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032        CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo

    //
    // Verify interface revision.
    //
    if (pDacRasterPosArg->id != DAC_RASTERPOS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacRasterPosArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacRasterPosArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    // no RL0/RL1 index regs, so return NV_PCRTC_RASTER_POSITION
    pDacRasterPosArg->result =  (U016) HAL_DAC_REG_RD_DRF(_PCRTC, _RASTER, _POSITION, CurDacAdr);
                                        
    return (RM_OK);
}

//
// Attempt to validate the given parameters will work with the current configuration
//
//  Return 0  if not capable
//  Return ~0 if valid
//
RM_STATUS
nvHalDacValidateArbSettings_NV10(VOID *arg)
{
    PDACVALIDATEARBSETTINGSARG_000    pDacValidateArbSettingsArg = (PDACVALIDATEARBSETTINGSARG_000) arg;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;

    fifo_info   fifo_data;
    sim_state   sim_data;
    U032        i, pclk_limit;
    U032        head = 0;

    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac0;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac1;

    //
    // Verify interface revision.
    //
    if (pDacValidateArbSettingsArg->id != DAC_VALIDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacValidateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;

    pVidLutCurDac0 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[0].pVidLutCurDac;
    pVidLutCurDac1 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[1].pVidLutCurDac;

    //
    // First we must validate that the incoming vclk is within our DAC range.
    //
    switch (pDacValidateArbSettingsArg->bpp)
    {
        case 8:
            pclk_limit = pDacHalInfo->CrtcInfo[head].PCLKLimit8bpp;
            break;
        case 15:
        case 16:
            pclk_limit = pDacHalInfo->CrtcInfo[head].PCLKLimit16bpp;
            break;
        case 24:
        case 32:
            pclk_limit = pDacHalInfo->CrtcInfo[head].PCLKLimit32bpp;
            break;
        default:
            pclk_limit = pDacHalInfo->CrtcInfo[head].PCLKLimit16bpp;
            break;
    }

    //
    // If incoming clock is greater than DAC range, return failure
    //
    if (pDacValidateArbSettingsArg->vclk > pclk_limit)
    {
        pDacValidateArbSettingsArg->result = 0;
        return (RM_OK);
    }
        
    // Make sure any uninitialized sim data starts with 0's
    for (i = 0; i < sizeof(sim_data); i++)
        ((U008 *)&sim_data)[i] = 0x0;

    //
    // Build the sim table using current system settings
    //
    sim_data.enable_video   = pDacValidateArbSettingsArg->video_enabled ? 1 : 0;
    sim_data.enable_mp      = pDacValidateArbSettingsArg->mport_enabled ? 1 : 0;
    sim_data.memory_width   = pDacHalInfo->InputWidth;
    sim_data.mem_latency    = 3;
    sim_data.memory_type    = (pFbHalInfo->RamType == BUFFER_DDRAM) ? 1 : 0; //1=DD,0=SD
    sim_data.mem_aligned    = 1;
    sim_data.mem_page_miss  = 10;
    sim_data.gr_during_vid  = pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
    sim_data.pclk_khz       = pDacValidateArbSettingsArg->vclk / 1000;  // in kHz, not MHz
    sim_data.mclk_khz       = pDacHalInfo->MClk / 1000;     // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;    // in kHz, not MHz

    // NV11 params
    fifo_data.crtc1_lwm = 0;
    fifo_data.crtc2_lwm = 0;
    fifo_data.video_lwm = 0;
    fifo_data.crtc1_burst_size = 0;
    fifo_data.crtc2_burst_size = 0;
    fifo_data.video_burst_size = 0;
    fifo_data.valid = 0;

    sim_data.enable_h1 = (pVidLutCurDac0) ? 1 : 0;    //1
    if (pVidLutCurDac0) {
        sim_data.pix_bpp      = pVidLutCurDac0->Dac[0].PixelDepth;          //May override below
        sim_data.hres         = pVidLutCurDac0->Dac[0].VisibleImageWidth;   //2048;
        sim_data.htotal       = pVidLutCurDac0->Dac[0].TotalWidth;          //2832;
        sim_data.vres         = pVidLutCurDac0->Dac[0].VisibleImageHeight;  //1536;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh      = (pVidLutCurDac0->Dac[0].PixelClock*10000) /
                                (pVidLutCurDac0->Dac[0].TotalWidth * pVidLutCurDac0->Dac[0].TotalHeight);    //75;

    //    sim_data.pix_bpp    = 32;
        sim_data.pclk_khz     = pVidLutCurDac0->Dac[0].PixelClock * 10;   //3404772;
    } else {
        sim_data.hres         = 640;
        sim_data.htotal       = 832;
        sim_data.vres         = 480;
        sim_data.refresh      = 85;     //75;
    //    sim_data.pix_bpp    = 32;
        sim_data.pclk_khz     = 36000;  //3404772;
    }
    
    sim_data.enable_h2        = (pVidLutCurDac1)?1:0;       //0
    if (pVidLutCurDac1) {
        sim_data.pix_bpp_h2   = pVidLutCurDac1->Dac[0].PixelDepth;          //May override below
        sim_data.hres2        = pVidLutCurDac1->Dac[0].VisibleImageWidth;   //1024;
        sim_data.htotal2      = pVidLutCurDac1->Dac[0].TotalWidth;          //1344;
        sim_data.vres2        = pVidLutCurDac1->Dac[0].VisibleImageHeight;  // 768;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh2     = (pVidLutCurDac1->Dac[0].PixelClock*10000) /
                                (pVidLutCurDac1->Dac[0].TotalWidth * pVidLutCurDac1->Dac[0].TotalHeight);    //60;

        sim_data.pclk2_khz    =   pVidLutCurDac1->Dac[0].PixelClock * 10;   //641088;
    } else {
        sim_data.hres2        = 640;
        sim_data.htotal2      = 832;
        sim_data.vres2        = 480;
        sim_data.refresh2     = 85;     //75;
    //    sim_data.pix_bpp    =   32;
        sim_data.pclk2_khz    =  36000; //3404772;
    }

//    sim_data.enable_video =    1;
//    sim_data.enable_mp    =    0;

//    sim_data.memory_width =  128;
//    sim_data.memory_type  =    0;
//    sim_data.mclk_mhz     =  166;

    //
    // If the overlay is active, use the head that owns the video scaler,
    // otherwise, for calculating if the overlay is allowed, assume this
    // head.
    //
	if (pVideoHalInfo->ActiveVideoOverlayObject)
        sim_data.h2_owns_vs = pVideoHalInfo->Head;
    else
        sim_data.h2_owns_vs = head;

    sim_data.video_source_hres = 720;
    sim_data.video_source_vres = 480;
// end NV11

    //Override the bit plane depth with passed parameter.
    if (head) {
        sim_data.pix_bpp_h2 = pDacValidateArbSettingsArg->bpp;   //32;
    } else {
        sim_data.pix_bpp    = pDacValidateArbSettingsArg->bpp;   //bpp;
    }

    //What if we're still not sure?  Well, for now let's pick the worst case...
    if (!sim_data.pix_bpp) sim_data.pix_bpp = 32;
    if (!sim_data.pix_bpp_h2) sim_data.pix_bpp_h2 = 32;

    //
    // Run the numbers through the ringer
    //
#ifdef NV11_DEBUG
    if (IsNV11_NV10(pMcHalInfo) && nv11Aware)
#else  //#ifdef NV11_DEBUG
    if (IsNV11_NV10(pMcHalInfo))
#endif  //#ifdef NV11_DEBUG
        NV11_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    else
        NV10_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);

    /*
    //
    // If the CRTC can do this, double check to make sure the overlay is able as well
    //
    if (fifo_data.valid && video_enabled)
        fifo_data.valid = NV10_dacCalculateVideoCaps(pDev);
    */
    
    pDacValidateArbSettingsArg->result = (U032)fifo_data.valid;
    return (RM_OK);
}

#ifdef IKOS
U032 do_pvideo = 0;
#endif

RM_STATUS
nvHalDacUpdateArbSettings_NV10(VOID *arg)
{ 
    PDACUPDATEARBSETTINGSARG_000     pDacUpdateArbSettingsArg = (PDACUPDATEARBSETTINGSARG_000) arg;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;
    PMPHALINFO          pMpHalInfo;
    U032                Head;
    U032                CurDacAdr;
    DACVALIDATEARBSETTINGSARG_000   dacValidateArbSettingsArg;

    fifo_info   fifo_data;
    sim_state   sim_data;
    U008        lock0, lock1;
    U032        i;
    U032        M, N, O, P;

    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac0;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac1;

    //
    // Verify interface revision.
    //
    if (pDacUpdateArbSettingsArg->id != DAC_UPDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacUpdateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pMpHalInfo = pHalHwInfo->pMpHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacUpdateArbSettingsArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;
    Head = pDacHalObj->Head;

    pVidLutCurDac0 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[0].pVidLutCurDac;
    pVidLutCurDac1 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[1].pVidLutCurDac;

    //
    // Recalculate the current PCLK setting.  We might have changed modes
    // recently.
    //
    M = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _MDIV);
    N = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _NDIV);
    P = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _PDIV);
    O = 1;
    
    pDacHalInfo->VPllM = M;
    pDacHalInfo->VPllN = N;
    pDacHalInfo->VPllO = O;
    pDacHalInfo->VPllP = P;
    pDacHalInfo->VClk  = (N * pMcHalInfo->CrystalFreq / (1 << P) / M);
    
    // Make sure any uninitialized sim data starts with 0's
    for (i = 0; i < sizeof(sim_data); i++)
        ((U008 *)&sim_data)[i] = 0x0;

    //
    // Check if we can support an overlay in this resolution.  If we can, set the default desktop timings
    // to assume we are running an overlay.
    //
    dacValidateArbSettingsArg.id = DAC_VALIDATEARBSETTINGS_000;
    dacValidateArbSettingsArg.pHalHwInfo = pHalHwInfo;
    dacValidateArbSettingsArg.bpp = pDacHalInfo->Depth;
    dacValidateArbSettingsArg.video_enabled = 1;
    dacValidateArbSettingsArg.mport_enabled = 0;
    dacValidateArbSettingsArg.vclk = pDacHalInfo->PixelClock * 10000;

    // if (NV11_dacValidateArbitrationSettings(pHalHwInfo, pDacHalInfo->Depth, 1, 0, (pDacHalInfo->PixelClock * 10000), Head))
    nvHalDacValidateArbSettings_NV10(&dacValidateArbSettingsArg);
    if (dacValidateArbSettingsArg.result)
        sim_data.enable_video = 1;
    else
        sim_data.enable_video = 0;
    
    //sim_data.pix_bpp      = (char)pDacHalInfo->Depth;
    //sim_data.enable_video = pDev->Video.Enabled ? 1 : 0;
    sim_data.enable_mp      = pMpHalInfo->Enabled ? 1 : 0;
    sim_data.memory_width   = pDacHalInfo->InputWidth;
    sim_data.mem_aligned    = 1;
    sim_data.memory_type    = (pFbHalInfo->RamType == BUFFER_DDRAM) ? 1 : 0; //1=DD,0=SD
    sim_data.mem_latency    = 3;
    sim_data.mem_page_miss  = 10;
    sim_data.gr_during_vid  = pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
    sim_data.pclk_khz       = pDacHalInfo->VClk / 1000;     // in kHz, not MHz
    sim_data.mclk_khz       = pDacHalInfo->MClk / 1000;     // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;    // in kHz, not MHz
 
    // 
    // Get those new numbers
    //
    fifo_data.crtc1_lwm = 0;
    fifo_data.crtc2_lwm = 0;
    fifo_data.video_lwm = 0;
    fifo_data.crtc1_burst_size = 0;
    fifo_data.crtc2_burst_size = 0;
    fifo_data.video_burst_size = 0;
    fifo_data.valid = 0;

    sim_data.enable_h1        = (pVidLutCurDac0)?1:0;    //1
    if (pVidLutCurDac0) {
        sim_data.pix_bpp      = pVidLutCurDac0->Dac[0].PixelDepth;          //May override below

        sim_data.hres         = pVidLutCurDac0->Dac[0].VisibleImageWidth;   //2048;
        sim_data.htotal       = pVidLutCurDac0->Dac[0].TotalWidth;          //2832;
        sim_data.vres         = pVidLutCurDac0->Dac[0].VisibleImageHeight;  //1536;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh      = (pVidLutCurDac0->Dac[0].PixelClock*10000) /
                                (pVidLutCurDac0->Dac[0].TotalWidth * pVidLutCurDac0->Dac[0].TotalHeight);    //75;

    //    sim_data.pix_bpp    =   32;
        sim_data.pclk_khz     =  pVidLutCurDac0->Dac[0].PixelClock * 10;    //3404772;
    } else {
        sim_data.hres         = 640;
        sim_data.htotal       = 832;
        sim_data.vres         = 480;
        sim_data.refresh      = 85;     //75;
    //    sim_data.pix_bpp    = 32;
        sim_data.pclk_khz     = 36000;  //3404772;
    }
    
    sim_data.enable_h2    = (pVidLutCurDac1)?1:0;       //0
    if (pVidLutCurDac1) {
        sim_data.pix_bpp_h2   = pVidLutCurDac1->Dac[0].PixelDepth;          //May override below
        sim_data.hres2        = pVidLutCurDac1->Dac[0].VisibleImageWidth;   //1024;
        sim_data.htotal2      = pVidLutCurDac1->Dac[0].TotalWidth;          //1344;
        sim_data.vres2        = pVidLutCurDac1->Dac[0].VisibleImageHeight;  //768;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh2     = (pVidLutCurDac1->Dac[0].PixelClock*10000) /
                                (pVidLutCurDac1->Dac[0].TotalWidth * pVidLutCurDac1->Dac[0].TotalHeight);    //60;

        sim_data.pclk2_khz    =   pVidLutCurDac1->Dac[0].PixelClock * 10;   //641088;
    } else {
        sim_data.hres2        = 640;
        sim_data.htotal2      = 832;
        sim_data.vres2        = 480;
        sim_data.refresh2     = 85;     //75;
    //    sim_data.pix_bpp    = 32;
        sim_data.pclk2_khz    = 36000;  //3404772;
    }

    if (!sim_data.pix_bpp) sim_data.pix_bpp = 32;
    if (!sim_data.pix_bpp_h2) sim_data.pix_bpp_h2 = 32;

//    sim_data.enable_video =    1;
//    sim_data.enable_mp    =    0;

//    sim_data.memory_width =  128;
//    sim_data.memory_type  =    0;
//    sim_data.mclk_mhz     =  166;

    //
    // If the overlay is active, use the head that owns the video scaler,
    // otherwise, for calculating if the overlay is allowed, assume this
    // head.
    //
	if (pVideoHalInfo->ActiveVideoOverlayObject)
        sim_data.h2_owns_vs = pVideoHalInfo->Head;
    else
        sim_data.h2_owns_vs = Head;

    sim_data.video_source_hres = 720;
    sim_data.video_source_vres = 480;
#ifdef NV11_DEBUG
    if (IsNV11_NV10(pMcHalInfo) && nv11Aware)
#else  //#ifdef NV11_DEBUG
    if (IsNV11_NV10(pMcHalInfo))
#endif //#ifdef NV11_DEBUG
        NV11_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    else
        NV10_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    
    // for now, assume pass
    //fifo_data.valid = 1;
    
//    For TV, we should not change some of these. Gfx Fifo Low Water Mark in particular should
//        not be changed. 
//    if (pDev->Framebuffer.DisplayType != DISPLAY_TYPE_TV) // leave alone if TV

    //
    // If valid settings found, update the hardware
    //
    if (fifo_data.valid)
    {
        //
        // Set the DAC FIFO Thresholds and burst size

#ifdef IKOS
        if (do_pvideo)
        {
#endif
        /*
        //
        // Check overlay capabilities.
        //
        if (!NV10_dacCalculateVideoCaps(pDev))
            pDev->Video.OverlayAllowed = 0;
        */

        if (IsNV11_NV10(pMcHalInfo)) {
            //Final clipping -- check with Jeff to see if the values are already 'safe'
            fifo_data.video_burst_size /= 32;
            if (!fifo_data.video_burst_size) fifo_data.video_burst_size = 1;
            if (fifo_data.video_burst_size > 16) fifo_data.video_burst_size = 16;
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST1, fifo_data.video_burst_size);
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST2, fifo_data.video_burst_size);

            fifo_data.video_lwm /= 16;
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK1, fifo_data.video_lwm);
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK2, fifo_data.video_lwm);
        } else {
            //
            // These are the PVIDEO burst/watermark hardcoded values
            // we've gotten from the HW engineers.
            //
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST1, 16);         // 512 bytes
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST2, 16);         // 512 bytes
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK1, 64);    // 1024 bytes
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK2, 64);    // 1024 bytes
        }

#ifdef IKOS
        }
#endif

        //
        // Update the CRTC watermarks
        // Note that for NV11 we've set the burst size registers to a different
        // operating mode -- therefore, the numbers written for NV11 and non-NV11
        // paths are not compatible.
        //
        if (IsNV11_NV10(pMcHalInfo)) {
            U032 CurDacAdr0, CurDacAdr1;

            CurDacAdr0 = pDacHalInfo->CrtcInfo[0].RegOffset;
            CurDacAdr1 = pDacHalInfo->CrtcInfo[1].RegOffset;

            // Unlock CRTC extended regs
            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock0, CurDacAdr0);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr0);
            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock1, CurDacAdr1);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr1);

            //
            // Set the CRTC watermarks and burst size
            //

            fifo_data.crtc1_lwm /= 8;
            if (fifo_data.crtc1_lwm > 255) fifo_data.crtc1_lwm = 255;
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, fifo_data.crtc1_lwm, CurDacAdr0);

            fifo_data.crtc1_burst_size /= 32;
            if (fifo_data.crtc1_burst_size) fifo_data.crtc1_burst_size--;
            if (!fifo_data.crtc1_burst_size) fifo_data.crtc1_burst_size++;
            if (fifo_data.crtc1_burst_size >= (2048/32)) fifo_data.crtc1_burst_size = 2048/32 - 1;
            HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, fifo_data.crtc1_burst_size, CurDacAdr0);

            fifo_data.crtc2_lwm /= 8;
            if (fifo_data.crtc2_lwm > 255) fifo_data.crtc2_lwm = 255;
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, fifo_data.crtc2_lwm, CurDacAdr1);

            fifo_data.crtc2_burst_size /= 32;
            if (fifo_data.crtc2_burst_size) fifo_data.crtc2_burst_size--;
            if (!fifo_data.crtc2_burst_size) fifo_data.crtc2_burst_size++;
            if (fifo_data.crtc2_burst_size >= (2048/32)) fifo_data.crtc2_burst_size = 2048/32 - 1;
            HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, fifo_data.crtc2_burst_size, CurDacAdr1);

            //
            // Relock if necessary
            //
            if (lock0 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr0);
            if (lock1 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr1);

        } else {    //if (IsNV11(pDev))
            // Unlock CRTC extended regs
            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock0, CurDacAdr);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);
       
            //
            // Set the CRTC watermarks and burst size
            //
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, (U008) (fifo_data.crtc1_lwm >> 3), CurDacAdr);
            switch (fifo_data.crtc1_burst_size)
            {
                case 512:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 5, CurDacAdr);
                    break;
                case 256:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 4, CurDacAdr);
                    break;
                case 128:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 3, CurDacAdr);
                    break;
                case 64:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 2, CurDacAdr);
                    break;
                case 32:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 1, CurDacAdr);
                    break;
                case 16:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 0, CurDacAdr);
                    break;
            }
            if (lock0 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr);
        }

        //
        // Relock if necessary
        //
        return (RM_OK);
    }
    else    //if (fifo_data.valid)
    {
        //
        // No valid setting was found!!!
        //
        //  Make a conservative guess and fail.
        //
        
        // Unlock CRTC extended regs
        if (IsNV11_NV10(pMcHalInfo)) {
            U032 CurDacAdr0, CurDacAdr1;

            CurDacAdr0 = pDacHalInfo->CrtcInfo[0].RegOffset;
            CurDacAdr1 = pDacHalInfo->CrtcInfo[1].RegOffset;

            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock0, CurDacAdr0);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr0);
        
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x72, CurDacAdr0);
            HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 1024/32 - 32, CurDacAdr0);

            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock1, CurDacAdr1);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr1);
        
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x72, CurDacAdr1);
            HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 1024/32 - 32, CurDacAdr1);

            //
            // Relock if necessary
            //
            if (lock0 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr0);
            if (lock1 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr1);

        } else {    //if (IsNV11(pDev))
            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock0, CurDacAdr);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);
        
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x72, CurDacAdr);
            HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 5, CurDacAdr);
         
            //
            // Relock if necessary
            //
            if (lock0 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr);
        }
        
        return (RM_ERROR);
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\mvision.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Macrovision support **************************\
*                                                                           *
* Module: MVISION.C                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <i2c.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>
#include <nvcm.h>
#include "mvision.h"


/*;==============================================================================
;
; Function:     HW_SetMacrovisionMode
;
; Purpose:      Sets the current Macrovision capable TV Out device to
;               the requested Macrovision copy protection mode.
;
; Arguments:    
;               
;		
;
; Returns:      
;               
;
;==============================================================================*/

#define REF(proc) (U008*)(&(proc[0]))

/*; First byte is the starting sub-address*/
U008 BtNtscMVDataMode0[] =  {0xDA, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C,
			    0xF3, 0x09, 0xBD, 0x67, 0xB5, 0x90, 0xB2, 0x7D, 0x00, 0x00};
U008 BtNtscMVDataMode1[] =  {0xDA, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C,
			    0xF3, 0x09, 0xBD, 0x67, 0xB5, 0x90, 0xB2, 0x7D, 0x63, 0x00};
U008 BtNtscMVDataMode2[] =  {0xDA, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C,
			    0xF3, 0x09, 0xBD, 0x6C, 0x31, 0x92, 0x32, 0xDD, 0xE3, 0x00};
U008 BtNtscMVDataMode3[] =  {0xDA, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C,
			    0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0xE3, 0x00};

U008 *BtNtscModeTable[] = {
    REF(BtNtscMVDataMode0), REF(BtNtscMVDataMode1), REF(BtNtscMVDataMode2), REF(BtNtscMVDataMode3)
};

U008 BtPalMVDataMode0[]	=   {0xDA, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F,
			    0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, 0x00};
U008 BtPalMVDataMode1[]	=   {0xDA, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F,
			    0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x63, 0x00};

U008 *BtPalModeTable[] = {
    REF(BtPalMVDataMode0), REF(BtPalMVDataMode1)
};

/*;Format is:  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND*/
U008 PhNtscMVDataMode0[] =  {0x5D, 0x3A, 0xC0, 0x5E, 0x2E, 0xC0, 0x7D, 0x00, 0x16, 0xFF};

U008 PhNtscMVDataMode1[] =  {0x5D, 0x1B, 0xC0, 0x5E, 0x0E, 0xC0, 0x5F, 0x2E, 0xC0, 0x60, 0x40, 0x80, 0x7D, 0xC8, 0x16,
			    0x01, 0x1E, 0xC0, 0x03, 0x11, 0xC0, 0x04, 0x26, 0xC0, 0x05, 0x0A, 0x00, 0x06, 0xC5, 0x00,
			    0x07, 0xFF, 0x00, 0x08, 0x03, 0xFC, 0x10, 0x11, 0xC0, 0x11, 0xAD, 0x00, 0x12, 0x60, 0x00,
			    0x14, 0x0F, 0x00, 0x15, 0x78, 0x80, 0x20, 0x9B, 0x40, 0x21, 0x04, 0x00, 0x24, 0x00, 0x00,
			    0x25, 0x00, 0x80, 0x30, 0x1B, 0xC0, 0x31, 0x04, 0xF8, 0x33, 0x0F, 0x00, 0x36, 0x0F, 0x00, 0xFF};

U008 PhNtscMVDataMode2[] =  {0x5D, 0x1B, 0xC0, 0x5E, 0x0E, 0xC0, 0x5F, 0x2E, 0xC0, 0x60, 0x40, 0x80, 0x7D, 0xE8, 0x16,
			    0x01, 0x1E, 0xC0, 0x03, 0x11, 0xC0, 0x04, 0x26, 0xC0, 0x05, 0x0A, 0x00, 0x06, 0xC5, 0x00,
			    0x07, 0xFF, 0x00, 0x08, 0x03, 0xFC, 0x10, 0x11, 0xC0, 0x11, 0xAD, 0x00, 0x12, 0x60, 0x00,
			    0x14, 0x0F, 0x00, 0x15, 0x78, 0x80, 0x20, 0x9B, 0x40, 0x21, 0x04, 0x00, 0x24, 0x00, 0x00,
			    0x25, 0x00, 0x80, 0x30, 0x1B, 0xC0, 0x31, 0x04, 0xF8, 0x33, 0x0F, 0x00, 0x36, 0x0F, 0x00, 0xFF};

U008 PhNtscMVDataMode3[] =  {0x5D, 0x1B, 0xC0, 0x5E, 0x0E, 0xC0, 0x5F, 0x2E, 0xC0, 0x60, 0x40, 0x80, 0x7D, 0xE8, 0x16,
			    0x01, 0x18, 0xC0, 0x03, 0x15, 0xC0, 0x04, 0x22, 0xC0, 0x05, 0x0A, 0x00, 0x06, 0xC5, 0x00,
			    0x07, 0xFF, 0x00, 0x08, 0x03, 0xFC, 0x10, 0x15, 0xC0, 0x11, 0xAD, 0x00, 0x12, 0x60, 0x00,
			    0x14, 0x0F, 0x00, 0x15, 0x78, 0x80, 0x20, 0x9B, 0x40, 0x21, 0x04, 0x00, 0x24, 0x00, 0x00,
			    0x25, 0x00, 0x80, 0x30, 0x1B, 0xC0, 0x31, 0x04, 0xF8, 0x33, 0x0F, 0x00, 0x36, 0x0F, 0x00, 0xFF};

U008 *PhNtscModeTable[] = {
    REF(PhNtscMVDataMode0), REF(PhNtscMVDataMode1), REF(PhNtscMVDataMode2), REF(PhNtscMVDataMode3)
};

U008 PhPalMVDataMode0[] =   {0x5D, 0x3A, 0xC0, 0x5E, 0x2E, 0xC0, 0x7D, 0x00, 0x16, 0xFF};

U008 PhPalMVDataMode1[] =   {0x5D, 0x17, 0xC0, 0x5E, 0x19, 0xC0, 0x5F, 0x35, 0xC0, 0x60, 0x40, 0x80, 0x7D, 0xC8, 0x16,
			    0x01, 0x1B, 0xC0, 0x03, 0x22, 0xC0, 0x04, 0x2B, 0xC0, 0x05, 0x08, 0x00, 0x06, 0x74, 0x00,
			    0x07, 0x55, 0x00, 0x08, 0x01, 0xFC, 0x10, 0x22, 0xC0, 0x11, 0x15, 0x00, 0x12, 0x60, 0x00,
			    0x14, 0x07, 0x00, 0x15, 0x7E, 0x80, 0x20, 0xBB, 0x40, 0x21, 0x72, 0x00, 0x24, 0x02, 0x00,
			    0x25, 0x54, 0x80, 0x30, 0x2C, 0xC0, 0x31, 0x04, 0xF8, 0x33, 0xFE, 0x00, 0x36, 0x7E, 0x00, 0xFF};

U008 *PhPalModeTable[] = {
    REF(PhPalMVDataMode0), REF(PhPalMVDataMode1)
};

/*;Format is:  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND*/
U008 Ch_PAL_Mode00_APS1[] = { /*; MODE 0 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x6C,0x00,0x04,0x00,0x7F,0x05,0x2E,0x00,0x08,0x18,0x07,
        0x0C,0x33,0x00,0x0E,0x40,0x3F,0x16,0x38,0x00,0x2B,0x00,0xF0,0x2C,0x9F,0x00,0x2D,0x9F,0x00,
        0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0xBA,0x00,0x0D,0x80,0x0F,0x0F,0x22,0xC0,0x13,0x40,0x1F,
        0x18,0x20,0x0F,0x19,0xA0,0x0F,0x1A,0x20,0x0F,0x2F,0x9B,0x00,0x30,0x64,0x00,0x2A,0x40,0x80,
        0x2B,0x10,0x0F,0x31,0x0A,0x00,0x32,0xEE,0x00,0x33,0x26,0x80,0x34,0x2A,0x80,0x35,0x7E,0x00,
        0x36,0x9A,0x00,0x37,0x3F,0x80,0x38,0xE0,0x00,0x39,0x15,0x80,0x3A,0x40,0x00,0x3B,0xFE,0x00,
        0x3C,0x7E,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_PAL_APS0[] = { /*; MODE 0 APS=00*/
        0x10,0x00,0x0F,0x11,0x00,0x07,0x12,0x00,0x00,0x3D,0x00,0xF8,0xFF
};

U008 Ch_NTSC_Mode03_APS3[] = { /*; MODE3 APS=11*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x30,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0x98,0x00,0x2D,0x98,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xBB,0x00,0x0D,0xB0,0x0F,0x0F,0x15,0xC0,0x13,0x80,0x1F,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2F,0x98,0x00,0x30,0x29,0x00,0x2A,0x4A,0x80,
        0x2B,0x00,0x0F,0x31,0xBD,0x00,0x32,0xBD,0x00,0x33,0x37,0x80,0x34,0x37,0x80,0x35,0xBD,0x00,
        0x36,0xBD,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode03_APS2[] = { /*; MODE3 APS=10*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x30,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0x98,0x00,0x2D,0x98,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xBB,0x00,0x0D,0xD0,0x0F,0x0F,0x11,0xC0,0x13,0x40,0x1F,
        0x18,0x10,0x0F,0x19,0x50,0x0F,0x1A,0x10,0x0F,0x2F,0x9E,0x00,0x30,0x2D,0x00,0x2A,0x4A,0x80,
        0x2B,0x00,0x0F,0x31,0xBD,0x00,0x32,0xBD,0x00,0x33,0x37,0x80,0x34,0x37,0x80,0x35,0xBD,0x00,
        0x36,0xBD,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode03_APS1[] = { /*; MODE3 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x30,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x00,0x00,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2A,0x4A,0x80,0x2B,0x00,0x0F,0x31,0xBD,0x00,
        0x32,0xBD,0x00,0x33,0x37,0x80,0x34,0x37,0x80,0x35,0xBD,0x00,0x36,0xBD,0x00,0x37,0x0F,0x80,
        0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_APS0[] = { /*; MODE3 APS=00 */
        0x10,0x00,0x0F,0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x00,0x00,0x3D,0x00,0xF8,0xFF
};

U008 Ch_PAL_Mode08_APS1[] = { /*; MODE 8 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x6C,0x00,0x04,0x00,0x7F,0x05,0x37,0x00,0x08,0x18,0x07,
        0x0C,0x33,0x00,0x0E,0x40,0x3F,0x16,0x38,0x00,0x2B,0x00,0xF0,0x2C,0xBD,0x00,0x2D,0xBD,0x00,
        0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0xDE,0x00,0x0D,0x80,0x0F,0x0F,0x22,0xC0,0x13,0x40,0x1F,
        0x18,0x20,0x0F,0x19,0xA0,0x0F,0x1A,0x20,0x0F,0x2F,0x9B,0x00,0x30,0x64,0x00,0x2A,0x4C,0x80,
        0x2B,0x30,0x0F,0x31,0x3C,0x00,0x32,0x1B,0x00,0x33,0x2E,0x80,0x34,0x32,0x80,0x35,0x96,0x00,
        0x36,0xB7,0x00,0x37,0x3F,0x80,0x38,0xE0,0x00,0x39,0x15,0x80,0x3A,0x40,0x00,0x3B,0xFE,0x00,
        0x3C,0x7E,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode11_APS3[] = { /*; MODE11 APS=11*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x3A,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0x67,0x00,0x2D,0x67,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xE2,0x00,0x0D,0xB0,0x0F,0x0F,0x15,0xC0,0x13,0x80,0x1F,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2F,0x98,0x00,0x30,0x29,0x00,0x2A,0x59,0x80,
        0x2B,0xF0,0x0F,0x31,0x08,0x00,0x32,0x08,0x00,0x33,0x42,0x80,0x34,0x42,0x80,0x35,0x08,0x00,
        0x36,0x08,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode11_APS2[] = { /*; MODE11 APS=10*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x3A,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0x67,0x00,0x2D,0x67,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xE2,0x00,0x0D,0xD0,0x0F,0x0F,0x11,0xC0,0x13,0x40,0x1F,
        0x18,0x10,0x0F,0x19,0x50,0x0F,0x1A,0x10,0x0F,0x2F,0x9E,0x00,0x30,0x2D,0x00,0x2A,0x59,0x80,
        0x2B,0xF0,0x0F,0x31,0x08,0x00,0x32,0x08,0x00,0x33,0x42,0x80,0x34,0x42,0x80,0x35,0x08,0x00,
        0x36,0x08,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode11_APS1[] = { /*; MODE11 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x3A,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x00,0x00,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2A,0x59,0x80,0x2B,0xF0,0x0F,0x31,0x08,0x00,
        0x32,0x08,0x00,0x33,0x42,0x80,0x34,0x42,0x80,0x35,0x08,0x00,0x36,0x08,0x00,0x37,0x0F,0x80,
        0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_PAL_Mode14_APS1[] = { /*; MODE 14 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x6C,0x00,0x04,0x00,0x7F,0x05,0x3A,0x00,0x08,0x18,0x07,
        0x0C,0x33,0x00,0x0E,0x40,0x3F,0x16,0x38,0x00,0x2B,0x00,0xF0,0x2C,0xC8,0x00,0x2D,0xC8,0x00,
        0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0xEA,0x00,0x0D,0x80,0x0F,0x0F,0x22,0xC0,0x13,0x40,0x1F,
        0x18,0x20,0x0F,0x19,0xA0,0x0F,0x1A,0x20,0x0F,0x2F,0x9B,0x00,0x30,0x64,0x00,0x2A,0x50,0x80,
        0x2B,0x30,0x0F,0x31,0x4C,0x00,0x32,0x29,0x00,0x33,0x30,0x80,0x34,0x34,0x80,0x35,0x9D,0x00,
        0x36,0xC0,0x00,0x37,0x3F,0x80,0x38,0xE0,0x00,0x39,0x15,0x80,0x3A,0x40,0x00,0x3B,0xFE,0x00,
        0x3C,0x7E,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode17_APS3[] = { /*; MODE17 APS=11*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x37,0x00,0x06,0x80,0x7F,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0xAE,0x00,0x2D,0xAE,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xD6,0x00,0x0D,0xB0,0x0F,0x0F,0x15,0xC0,0x13,0x80,0x1F,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2F,0x98,0x00,0x30,0x29,0x00,0x2A,0x54,0x80,
        0x2B,0x00,0x0F,0x31,0xFA,0x00,0x32,0xFA,0x00,0x33,0x3F,0x80,0x34,0x3F,0x80,0x35,0xFA,0x00,
        0x36,0xFA,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0x08,0x30,0x07,0xFF
};

U008 Ch_NTSC_Mode17_APS2[] = { /*; MODE17 APS=10*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x37,0x00,0x06,0x80,0x7F,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0xAE,0x00,0x2D,0xAE,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xD6,0x00,0x0D,0xD0,0x0F,0x0F,0x11,0xC0,0x13,0x40,0x1F,
        0x18,0x10,0x0F,0x19,0x50,0x0F,0x1A,0x10,0x0F,0x2F,0x9E,0x00,0x30,0x2D,0x00,0x2A,0x54,0x80,
        0x2B,0x00,0x0F,0x31,0xFA,0x00,0x32,0xFA,0x00,0x33,0x3F,0x80,0x34,0x3F,0x80,0x35,0xFA,0x00,
        0x36,0xFA,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0x08,0x30,0x07,0xFF
};

U008 Ch_NTSC_Mode17_APS1[] = { /*; MODE17 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x37,0x00,0x06,0x80,0x7F,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x00,0x00,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2A,0x54,0x80,0x2B,0x00,0x0F,0x31,0xFA,0x00,
        0x32,0xFA,0x00,0x33,0x3F,0x80,0x34,0x3F,0x80,0x35,0xFA,0x00,0x36,0xFA,0x00,0x37,0x0F,0x80,
        0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,0x3C,0x0F,0x00,0x3D,0x05,0xF8,
	0x08,0x30,0x07,0xFF
};

U008 Ch_PAL_Mode20_APS1[] = { /*; MODE20 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x6C,0x00,0x04,0x00,0x7F,0x05,0x47,0x00,0x08,0x18,0x07,
        0x0C,0x33,0x00,0x0E,0x40,0x3F,0x16,0x38,0x00,0x2B,0x08,0xF0,0x2C,0xF3,0x00,0x2D,0xF3,0x00,
        0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x1C,0x00,0x0D,0x80,0x0F,0x0F,0x22,0xC0,0x13,0x40,0x1F,
        0x18,0x20,0x0F,0x19,0xA0,0x0F,0x1A,0x20,0x0F,0x2F,0x9B,0x00,0x30,0x64,0x00,0x2A,0x61,0x80,
        0x2B,0x30,0x0F,0x31,0x94,0x00,0x32,0x6A,0x00,0x33,0x3B,0x80,0x34,0x40,0x80,0x35,0xC0,0x00,
        0x36,0xEA,0x00,0x37,0x3F,0x80,0x38,0xE0,0x00,0x39,0x15,0x80,0x3A,0x40,0x00,0x3B,0xFE,0x00,
        0x3C,0x7E,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode24_APS3[] = { /*; MODE24 APS=11*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x40,0x00,0x06,0x80,0x7F,
	0x08,0x30,0x07,0x1B,0x0B,0xF0,0x1C,0x04,0xF0,0x1D,0x01,0xF0,0x1E,0x06,0xF0,0x1F,0x05,0xF0,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x09,0xF0,0x2C,0xDD,0x00,0x2D,0xDD,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0x11,0x00,0x0D,0xB0,0x0F,0x0F,0x15,0xC0,0x13,0x80,0x1F,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2F,0x98,0x00,0x30,0x29,0x00,0x2A,0x6B,0x80,
        0x2B,0xF0,0x0F,0x31,0x3F,0x00,0x32,0x3F,0x00,0x33,0x50,0x80,0x34,0x50,0x80,0x35,0x3F,0x00,
        0x36,0x3F,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode24_APS2[] = { /*; MODE24 APS=10*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x40,0x00,0x06,0x80,0x7F,
	0x08,0x30,0x07,0x1B,0x0B,0xF0,0x1C,0x04,0xF0,0x1D,0x01,0xF0,0x1E,0x06,0xF0,0x1F,0x05,0xF0,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x09,0xF0,0x2C,0xDD,0x00,0x2D,0xDD,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0x11,0x00,0x0D,0xD0,0x0F,0x0F,0x11,0xC0,0x13,0x40,0x1F,
        0x18,0x10,0x0F,0x19,0x50,0x0F,0x1A,0x10,0x0F,0x2F,0x9E,0x00,0x30,0x2D,0x00,0x2A,0x6B,0x80,
        0x2B,0xF0,0x0F,0x31,0x3F,0x00,0x32,0x3F,0x00,0x33,0x50,0x80,0x34,0x50,0x80,0x35,0x3F,0x00,
        0x36,0x3F,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode24_APS1[] = { /*; MODE24 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x40,0x00,0x06,0x80,0x7F,
	0x08,0x30,0x07,0x1B,0x0B,0xF0,0x1C,0x04,0xF0,0x1D,0x01,0xF0,0x1E,0x06,0xF0,0x1F,0x05,0xF0,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x00,0x00,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2A,0x6B,0x80,0x2B,0xF0,0x0F,0x31,0x3F,0x00,
        0x32,0x3F,0x00,0x33,0x50,0x80,0x34,0x50,0x80,0x35,0x3F,0x00,0x36,0x3F,0x00,0x37,0x0F,0x80,
        0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 *Ch_PAL_Table[] = { /*; PAL formats only support APS=01*/
        REF(Ch_PAL_APS0), REF(Ch_PAL_Mode00_APS1), REF(Ch_PAL_Mode00_APS1), REF(Ch_PAL_Mode00_APS1),
        REF(Ch_PAL_APS0), REF(Ch_PAL_Mode08_APS1), REF(Ch_PAL_Mode08_APS1), REF(Ch_PAL_Mode08_APS1),
        REF(Ch_PAL_APS0), REF(Ch_PAL_Mode14_APS1), REF(Ch_PAL_Mode14_APS1), REF(Ch_PAL_Mode14_APS1),
        REF(Ch_PAL_APS0), REF(Ch_PAL_Mode20_APS1), REF(Ch_PAL_Mode20_APS1), REF(Ch_PAL_Mode20_APS1)
};

U008 *Ch_NTSC_Table[] = { /*; NTSC formats support all Macrovision modes*/
        REF(Ch_NTSC_APS0), REF(Ch_NTSC_Mode03_APS1), REF(Ch_NTSC_Mode03_APS2), REF(Ch_NTSC_Mode03_APS3),
        REF(Ch_NTSC_APS0), REF(Ch_NTSC_Mode11_APS1), REF(Ch_NTSC_Mode11_APS2), REF(Ch_NTSC_Mode11_APS3),
        REF(Ch_NTSC_APS0), REF(Ch_NTSC_Mode17_APS1), REF(Ch_NTSC_Mode17_APS2), REF(Ch_NTSC_Mode17_APS3),
        REF(Ch_NTSC_APS0), REF(Ch_NTSC_Mode24_APS1), REF(Ch_NTSC_Mode24_APS2), REF(Ch_NTSC_Mode24_APS3)
};

U032 CH_Mode_Table[] = { 512, 384, 640, 400, 640, 480, 800, 600, 0 };

RM_STATUS ReadChRegister(
    PHWINFO pDev,
    U032    Head,
    U032    dwPort,
    U008    TVOutDeviceAddr,
	U008	RegNum,
	U008	*pData
	)
{
    RM_STATUS   rmStatus = RM_ERROR;

    i2cStart(pDev, Head, dwPort);

    /* First generate the DEVICE ID with WRITE */
    if ( i2cSendByte(pDev, Head, dwPort, TVOutDeviceAddr) )
		goto RCR_Exit;

    /* Next generate the REGISTER ADDRESS */
    if ( i2cSendByte(pDev, Head, dwPort, RegNum) )
		goto RCR_Exit;

    /*  Next generate a RESTART and the DEVICE ID with READ */
    i2cStart(pDev, Head, dwPort);
    if ( i2cSendByte(pDev, Head, dwPort, (U008)(TVOutDeviceAddr+1)) )
		goto RCR_Exit;

    /* Finally, READ the data from the device */
    if( i2cReceiveByte(pDev, Head, dwPort, pData, 1) == -1 )
		goto RCR_Exit;

	rmStatus = RM_OK;

RCR_Exit:
    i2cStop(pDev, Head, dwPort);
	return rmStatus;
}

RM_STATUS WriteChRegister(
    PHWINFO pDev,
    U032    Head,
    U032    dwPort,
    U008    TVOutDeviceAddr,
	U008	RegNum,
	U008	Data
	)
{
    RM_STATUS   rmStatus = RM_ERROR;

    i2cStart(pDev, Head, dwPort);

    /* First generate the DEVICE ID with WRITE */
    if ( i2cSendByte(pDev, Head, dwPort, TVOutDeviceAddr) )
		goto WCR_Exit;

    /* Next generate the REGISTER ADDRESS */
    if ( i2cSendByte(pDev, Head, dwPort, RegNum) )
		goto WCR_Exit;

    /*  Finally, WRITE the DATA */
    if ( i2cSendByte(pDev, Head, dwPort, Data) )
		goto WCR_Exit;

	rmStatus = RM_OK;

WCR_Exit:
    i2cStop(pDev, Head, dwPort);
	return rmStatus;
}

RM_STATUS SetMacrovisionMode(
    PHWINFO pDev,
    U032    Head,
    RM_MACROVISION_CONTROL	*pCtrl
    )
{
    RM_STATUS   rmStatus;
    U032        dwCount;
    U008        *pReg, data, tb, brValue = 0;
    U032        i; 
    U032        dwNewMode, dwChangeBrightness, dwPort, dwEncoderType, dwTVStandard;
    U008        TVOutDeviceAddr;

    rmStatus = RM_OK;

    TVOutDeviceAddr = (U008)pCtrl->devAddr;
    dwNewMode = pCtrl->mode & 0x3;
	dwChangeBrightness = pCtrl->mode & 0x4;
    dwPort = pCtrl->port;
    dwEncoderType = pCtrl->encoderType;
    dwTVStandard = pCtrl->tvStandard;

    pCtrl->status = RM_OK;

    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);  // Connect the head to the I2C pins
    }

    switch( dwEncoderType )
    {
	default:
#ifdef DEBUG
        DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Unknown encoder type");
        DBG_BREAKPOINT();
#endif
	case NV_ENCODER_BROOKTREE_868:
	case NV_ENCODER_CHRONTEL_7003:
	case NV_ENCODER_CHRONTEL_7006:
	case NV_ENCODER_CHRONTEL_7008:
	    /* Macrovosion not supported */
	    pCtrl->status = RM_ERROR;
	    return RM_ERROR;

	case NV_ENCODER_BROOKTREE_869:
	case NV_ENCODER_BROOKTREE_871:

	    switch( dwTVStandard)
	    {
		case NTSC_M:
		case NTSC_J:
		    /* Limit MV mode to [0,3] */
		    if( dwNewMode > 3 )
                dwNewMode = 3;
		    pReg = BtNtscModeTable[dwNewMode];
		    break;

		case PAL_M:
		case PAL_A:
		case PAL_N:
		case PAL_NC:
		    /* Limit MV mode to 0 or 1 */
		    if( dwNewMode > 1 )
                dwNewMode = 1;
		    pReg = BtPalModeTable[dwNewMode];
		    break;

		default:
#ifdef DEBUG
		    DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Unknown TV Standard");
		    DBG_BREAKPOINT();
#endif
		    pCtrl->status = RM_ERROR;
            return RM_ERROR;
	    }

	    /*
	     * Unlock CRTC extended regs
	     */
	    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

        i2cStart(pDev, Head, dwPort);
	    
	    /* First generate the DEVICE ID with WRITE */
	    if ( i2cSendByte(pDev, Head, dwPort, TVOutDeviceAddr) )
	    {
            pCtrl->status = RM_ERROR;
            rmStatus = RM_ERROR;
            break;
	    }

        /* Now, write the data */
	    for (dwCount = 0; dwCount < 19; dwCount++)
        {
            if ( i2cSendByte(pDev, Head, dwPort, pReg[dwCount]) )
            {
                pCtrl->status = RM_ERROR;
                rmStatus = RM_ERROR;
                break;
            }
        }

        i2cStop(pDev, Head, dwPort);
	    break;

	case TV_ENCODER_PHILIPS:
	case NV_ENCODER_PHILIPS_7102:
	case NV_ENCODER_PHILIPS_7103:
	case NV_ENCODER_PHILIPS_7108:
	case NV_ENCODER_PHILIPS_7109:

	    switch( dwTVStandard)
	    {
		case NTSC_M:
		case NTSC_J:
			brValue = 0;
		    /* Limit MV mode to [0,3] */
		    if( dwNewMode > 3 )
                dwNewMode = 3;
		    pReg = PhNtscModeTable[dwNewMode];
		    break;

		case PAL_M:
		case PAL_A:
		case PAL_N:
		case PAL_NC:
			brValue = 0;
		    /* Limit MV mode to 0 or 1 */
		    if( dwNewMode > 1 )
                dwNewMode = 1;
		    pReg = PhPalModeTable[dwNewMode];
		    break;

		default:
#ifdef DEBUG
		    DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Unknown TV Standard");
		    DBG_BREAKPOINT();
#endif
		    pCtrl->status = RM_ERROR;
            return RM_ERROR;
	    }

		goto CommonForPhilipsAndChrontel;

	case NV_ENCODER_CHRONTEL_7005:
	case NV_ENCODER_CHRONTEL_7007:

	    for( i=0; ;i++ )
	    {
            if( !CH_Mode_Table[i*2] )
            {
                pCtrl->status = RM_ERROR;
                return RM_ERROR;
            }

            if( CH_Mode_Table[i*2] == pCtrl->resx && CH_Mode_Table[i*2+1] == pCtrl->resy )
                break;
	    }

	    dwNewMode &= 3;
	    switch( dwTVStandard)
	    {
		case NTSC_M:
			brValue = 2;
		case NTSC_J:
			brValue += 22;
		    pReg = Ch_NTSC_Table[i*4+dwNewMode];
		    break;

		case PAL_M:
			brValue = 2;
		case PAL_A:
		case PAL_N:
		case PAL_NC:
			brValue += 22;
		    pReg = Ch_PAL_Table[i*4+dwNewMode];
		    break;

		default:
#ifdef DEBUG
		    DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Unknown TV Standard");
		    DBG_BREAKPOINT();
#endif
		    pCtrl->status = RM_ERROR;
                    return RM_ERROR;
	    }

CommonForPhilipsAndChrontel:
	    /*
	     * Unlock CRTC extended regs
	     */
	    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

	    for(; *pReg != 0xFF; pReg += 3 )
	    {
            data = 0;
            if( *(pReg+2) != 0 )
            {
				if(ReadChRegister(pDev, Head, dwPort, TVOutDeviceAddr, *pReg, &data) != RM_OK)
				{
			        pCtrl->status = RM_ERROR;
                    rmStatus = RM_ERROR;
					break;
				}
            }

            tb = data;
            data = (data & *(pReg+2)) | *(pReg+1);

            if ( data == 0 || data != tb )
            {
				if(WriteChRegister(pDev, Head, dwPort, TVOutDeviceAddr, *pReg, data) != RM_OK)
				{
			        pCtrl->status = RM_ERROR;
                    rmStatus = RM_ERROR;
					break;
				}
            }
	    }

		if(brValue == 0 || dwChangeBrightness == 0)
			break;

		/* Increase or decrease brightness */
		if(ReadChRegister(pDev, Head, dwPort, TVOutDeviceAddr, 0x09, &data) != RM_OK)
		{
			pCtrl->status = RM_ERROR;
            rmStatus = RM_ERROR;
			break;
		}

        data = (U008)(dwNewMode ? data - brValue : data + brValue);
		if(WriteChRegister(pDev, Head, dwPort, TVOutDeviceAddr, 0x09, data) != RM_OK)
        {
            pCtrl->status = RM_ERROR;
            rmStatus = RM_ERROR;
            break;
        }

	    break;

    }

    /* Lock CRTC extended regs */
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, Head);

    return rmStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dac\nv20\dacnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Arbitration **************************\
*                                                                           *
* Module: DACNV20.C                                                         *
*   The DAC manager.                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include <vga.h>

/* This file simulates the NV arbitor */
#include <arb_fifo.h>
#include "nvhalcpp.h"

//////////////////////////////////////////
//
// Arbitration routines
//

static
VOID NV20_dacCalculateArbitration
(
    PHALHWINFO pHalHwInfo,
    fifo_info *fifo,
    sim_state  *arb
)
{
  int data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
  int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
  int nvclk_fill, us_extra;
  int found, mclk_extra, mclk_loop, cbs, m1;
  int mclk_freq, pclk_freq, nvclk_freq, mp_enable;
  int us_m, us_m_min, us_n, us_p, video_drain_rate, crtc_drain_rate;
  int vus_m, vus_n, vus_p;
  int vpm_us, us_video, vlwm, cpm_us, us_crt,clwm;
  int clwm_rnd_down;
  int craw, m2us, us_pipe, us_pipe_min, vus_pipe, p1clk, p2;
  int pclks_2_top_fifo, min_mclk_extra;
  int us_min_mclk_extra;

  fifo->valid = 1;
  pclk_freq = arb->pclk_khz; // freq in KHz
  mclk_freq = arb->mclk_khz;
  nvclk_freq = arb->nvclk_khz;
  pagemiss = arb->mem_page_miss;
  cas = arb->mem_latency;
  width = arb->memory_width/64;
  video_enable = arb->enable_video;
  color_key_enable = arb->gr_during_vid;
  bpp = arb->pix_bpp;
  align = arb->mem_aligned;
  mp_enable = arb->enable_mp;
  clwm = 0;
  vlwm = 1024;

  cbs = 512;
  vbs = 512;

  pclks = 4; // lwm detect.

  nvclks = 3; // lwm -> sync.
  nvclks += 2; // fbi bus cycles (1 req + 1 busy)

  mclks  = 1;   // 2 edge sync.  may be very close to edge so just put one.

  mclks += 1;   // arb_hp_req
  mclks += 5;   // ap_hp_req   tiling pipeline

  mclks += 2;    // tc_req     latency fifo
  mclks += 2;    // fb_cas_n_  memory request to fbio block
  mclks += 7;    // sm_d_rdv   data returned from fbio block

  // fb.rd.d.Put_gc   need to accumulate 256 bits for read
  if (arb->memory_type == 0)
  {
    if (arb->memory_width == 64) // 64 bit bus
      mclks += 4;
    else
      mclks += 2;
  }
  else
  {
    if (arb->memory_width == 64) // 64 bit bus
      mclks += 2;
    else
      mclks += 1;
  }

  if ((!video_enable) && (arb->memory_width == 128))
  {  
    mclk_extra = (bpp == 32) ? 31 : 42; // Margin of error
    min_mclk_extra = 17;
  }
  else
  {
    mclk_extra = (bpp == 32) ? 8 : 4; // Margin of error
    //mclk_extra = 4; // Margin of error
    min_mclk_extra = 18;
  }

  nvclks += 1; // 2 edge sync.  may be very close to edge so just put one.
  nvclks += 1; // fbi_d_rdv_n
  nvclks += 1; // Fbi_d_rdata
  nvclks += 1; // crtfifo load

  if(mp_enable)
    mclks+=4; // Mp can get in with a burst of 8.
  // Extra clocks determined by heuristics

  nvclks += 0;
  pclks += 0;
  found = 0;
  while(found != 1) {
    fifo->valid = 1;
    found = 1;
    mclk_loop = mclks+mclk_extra;
    us_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
    us_m_min = mclks * 1000*1000 / mclk_freq; // Minimum Mclk latency in us
    us_min_mclk_extra = min_mclk_extra *1000*1000 / mclk_freq;
    us_n = nvclks*1000*1000 / nvclk_freq;// nvclk latency in us
    us_p = pclks*1000*1000 / pclk_freq;// nvclk latency in us
    us_pipe = us_m + us_n + us_p;
    us_pipe_min = us_m_min + us_n + us_p;
    us_extra = 0;

    vus_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
    vus_n = (4)*1000*1000 / nvclk_freq;// nvclk latency in us
    vus_p = 0*1000*1000 / pclk_freq;// pclk latency in us
    vus_pipe = vus_m + vus_n + vus_p;

    if(video_enable) {
      video_drain_rate = pclk_freq * 4; // MB/s
      crtc_drain_rate = pclk_freq * bpp/8; // MB/s

      vpagemiss = 1; // self generating page miss
      vpagemiss += 1; // One higher priority before

      crtpagemiss = 2; // self generating page miss
      if(mp_enable)
          crtpagemiss += 1; // if MA0 conflict

      vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;

      us_video = vpm_us + vus_m; // Video has separate read return path

      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =
        us_video  // Wait for video
        +cpm_us // CRT Page miss
        +us_m + us_n +us_p // other latency
        ;

      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that
    } else {
      crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

      crtpagemiss = 1; // self generating page miss
      crtpagemiss += 1; // MA0 page miss
      if(mp_enable)
          crtpagemiss += 1; // if MA0 conflict
      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =  cpm_us + us_m + us_n + us_p ;
      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that

/*
        //
        // Another concern, only for high pclks so don't do this
        // with video:
        // What happens if the latency to fetch the cbs is so large that
        // fifo empties.  In that case we need to have an alternate clwm value
        // based off the total burst fetch
        //
        us_crt = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
        us_crt = us_crt + us_m + us_n + us_p + (4 * 1000 * 1000)/mclk_freq;
        clwm_mt = us_crt * crtc_drain_rate/(1000*1000);
        clwm_mt ++;
        if(clwm_mt > clwm)
            clwm = clwm_mt;
*/
        // Finally, a heuristic check when width == 64 bits
        if(width == 1){
            nvclk_fill = nvclk_freq * 8;
            if(crtc_drain_rate * 100 >= nvclk_fill * 102)
                    clwm = 0xfff; //Large number to fail

            else if(crtc_drain_rate * 100  >= nvclk_fill * 98) {
                clwm = 1024;
                cbs = 512;
                us_extra = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
            }
        }
    }


    /*
      Overfill check:

      */

    clwm_rnd_down = ((int)clwm/8)*8;
    if (clwm_rnd_down < clwm)
        clwm += 8;
        
    m1 = clwm + cbs -  1024; /* Amount of overfill */
    m2us = us_pipe_min + us_min_mclk_extra;
    pclks_2_top_fifo = (1024-clwm)/(8*width);
    
    /* pclk cycles to drain */
    p1clk = m2us * pclk_freq/(1000*1000); 
    p2 = p1clk * bpp / 8; // bytes drained.
    
    if((p2 < m1) && (m1 > 0)) {
    	fifo->valid = 0;
    	found = 0;
    	if(min_mclk_extra == 0)   {
    	  if(cbs <= 32) {
    	    found = 1; // Can't adjust anymore!
    	  } else {
    	    cbs = cbs/2;  // reduce the burst size
    	  }
    	} else {
    	  min_mclk_extra--;
    	}
    } else {
      if (clwm > 1023){ // Have some margin
    	fifo->valid = 0;
    	found = 0;
    	if(min_mclk_extra == 0)   
            found = 1; // Can't adjust anymore!
    	else 
            min_mclk_extra--;
      }
    }
    craw = clwm;
    
    if(clwm < (1024-cbs+8)) clwm = 1024-cbs+8;
    data = (int)(clwm);
    //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
    fifo->crtc1_lwm = data;   fifo->crtc1_burst_size = cbs;

    //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
    fifo->video_lwm = 1024;  fifo->video_burst_size = 512;
  }
}

/*
//
// Determine if the video overlay is usable in the current configuration.  This
// routine will also update the global variables in pDev which determine the 
// maximum downscaling allowed at various source image sizes.
//
//  Return 0 if not capable (at any upscale or downscale factor)
//  Return ~0 if capable (see pDev for downscale limits)
//
U032 NV20_dacCalculateVideoCaps
(
    PHWINFO pDev
)
{
    //
    // First look for a match of memory type, resolution, and clocks.
    //
    // NOTE: For now, until I can straighten out all of the hardware data,
    // assume a conservative limit.
    //
    switch (pDev->Chip.HalInfo.MaskRevision)
    {
        case 0xA1:
        case 0xA2:
        case 0xA6:
        
            pDev->Video.OverlayMaxDownscale_768  = 2;
            pDev->Video.OverlayMaxDownscale_1280 = 2;
            pDev->Video.OverlayMaxDownscale_1920 = 2;
            break;
            
        default:

            pDev->Video.OverlayMaxDownscale_768  = 8;
            pDev->Video.OverlayMaxDownscale_1280 = 4;
            pDev->Video.OverlayMaxDownscale_1920 = 2;
            break;
    }

    //
    // For now, always assume we can support some level of overlay
    // (although not to the same level of downscale ability)
    //
    return 1;

}
*/

typedef struct tagNV20_DacAGPClockEntry
{
    U032 frequency;
    U032 setting;
} NV20_DacAGPClockEntry;

NV20_DacAGPClockEntry NV20_dacAGPClockTable[] =
{
    { 133000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_133MHZ },
    { 126000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_126MHZ },
    { 120000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_120MHZ },
    { 113000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_113MHZ },
    { 106000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_106MHZ },
    { 100000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_100MHZ },
    { 94000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_94MHZ },
    { 87000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_87MHZ },
    { 80000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_80MHZ },
    { 73000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_73MHZ },
    { 66000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ },
    { 0, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ - 1 }
};

//
// HAL stuff
//

// forwards
RM_STATUS nvHalDacControl_NV20(VOID *);
RM_STATUS nvHalDacAlloc_NV20(VOID *);
RM_STATUS nvHalDacFree_NV20(VOID *);
RM_STATUS nvHalDacSetStartAddr_NV20(VOID *);
RM_STATUS nvHalDacProgramMClk_NV20(VOID *);
RM_STATUS nvHalDacProgramNVClk_NV20(VOID *);
RM_STATUS nvHalDacProgramPClk_NV20(VOID *);
RM_STATUS nvHalDacProgramCursorImage_NV20(VOID *);
RM_STATUS nvHalDacGetRasterPosition_NV20(VOID *);
RM_STATUS nvHalDacValidateArbSettings_NV20(VOID *arg);
RM_STATUS nvHalDacUpdateArbSettings_NV20(VOID *arg);

//
// nvHalDacControl
//
RM_STATUS
nvHalDacControl_NV20(VOID *arg)
{
    PDACCONTROLARG_000 pDacControlArg = (PDACCONTROLARG_000)arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;
    PDACHALINFO_NV20    pDacHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pDacControlArg->id != DAC_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacControlArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pDacHalPvtInfo = (PDACHALINFO_NV20)pHalHwInfo->pDacHalInfo;

    switch (pDacControlArg->cmd)
    {
        case DAC_CONTROL_INIT:
        {
            U032 i, data32, crtcAddr;
            U008 lock;

            // default to 128bit wide bus on nv20
            pDacHalInfo->InputWidth = 128;
            pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 350000000;
            pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 350000000;
            pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 300000000;
            pDacHalInfo->CrtcInfo[0].RegOffset = 0x00000000;

            //
            // Head 0 supports everything (?).
            //
            pDacHalInfo->CrtcInfo[0].DisplayTypesAllowed =
                DISPLAYTYPEBIT(DISPLAY_TYPE_MONITOR) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_TV) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_DUALSURFACE) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL);

            //
            // Head 1 supports TV and flat panel.
            //
            pDacHalInfo->CrtcInfo[1].DisplayTypesAllowed =
                DISPLAYTYPEBIT(DISPLAY_TYPE_TV) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL);


            // turn on CRTC big endian on 2nd head if we're setup for big endian mode
            if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
            {
                U032 crtcOffset;
                U032 config;
                crtcOffset = pDacHalInfo->CrtcInfo[1].RegOffset;
                config = REG_RD32(NV_PCRTC_CONFIG + crtcOffset);
                config |= DRF_DEF(_PCRTC, _CONFIG, _ENDIAN, _BIG);
                REG_WR32(NV_PCRTC_CONFIG + crtcOffset, config);
            }

            //
            // While we're here, increase TV out latency.
            //
            for (i = 0; i < pDacHalInfo->NumCrtcs; i++)
            {
                crtcAddr = pDacHalInfo->CrtcInfo[i].RegOffset;

                // Unlock CRTC extended regs
                HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, crtcAddr);
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, crtcAddr);

                // Add 4 per Raj Rao...
                HAL_CRTC_RD(NV_CIO_CRE_TVOUT_LATENCY, data32, crtcAddr);
                data32 += 4;
                HAL_CRTC_WR(NV_CIO_CRE_TVOUT_LATENCY, data32, crtcAddr);

                // Relock if necessary...
                if (lock == 0)
                    HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, crtcAddr);
            }

            //
            // Set default downscale values.
            // 
            pVideoHalInfo->OverlayMaxDownscale_768  = 8;
            pVideoHalInfo->OverlayMaxDownscale_1280 = 8;
            pVideoHalInfo->OverlayMaxDownscale_1920 = 8;

            // turn on CRTC big endian if we're setup for big endian mode
            if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
            {
                FLD_WR_DRF_NUM(_PCRTC, _CONFIG, _ENDIAN, NV_PCRTC_CONFIG_ENDIAN_BIG);
	    }
            break;
        }
        case DAC_CONTROL_LOAD:
        case DAC_CONTROL_UNLOAD:
        case DAC_CONTROL_DESTROY:
        case DAC_CONTROL_UPDATE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

RM_STATUS
nvHalDacAlloc_NV20(VOID *arg)
{
    PDACALLOCARG_000 pDacAllocArg = (PDACALLOCARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacAllocArg->id != DAC_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    return (RM_OK);
}

RM_STATUS
nvHalDacFree_NV20(VOID *arg)
{
    PDACFREEARG_000 pDacFreeArg = (PDACFREEARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacFreeArg->id != DAC_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);    

    return (RM_OK);
}

RM_STATUS
nvHalDacSetStartAddr_NV20(VOID *arg)
{
    PDACSETSTARTADDRARG_000 pDacSetStartAddrArg = (PDACSETSTARTADDRARG_000)arg;
    PHALHWINFO  pHalHwInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    PDACHALINFO pDacHalInfo;
    U032        crtcOffset;

    //
    // Verify interface revision.
    //
    if (pDacSetStartAddrArg->id != DAC_SET_START_ADDR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacSetStartAddrArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT)pDacSetStartAddrArg->pHalObjInfo;

    crtcOffset = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;
    REG_WR32(NV_PCRTC_START + crtcOffset, pDacSetStartAddrArg->startAddr);

    return (RM_OK);
}

//
// nvHalDacProgramMClk_NV20 - Program MCLK based on the value in pDev->Dac.HalInfo.MClk
//
// This routine uses the value in pDev->Dac.HalInfo.MClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramMClk_NV20(VOID *arg)
{
    PDACPROGRAMMCLKARG_000 pDacProgramMClkArg = (PDACPROGRAMMCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 oldMClk;
    U032 oldCyclesPerRefresh;
    U032 oldPeriod;
    U032 newCyclesPerRefresh;
    U032 Loops;
    U032 IsPllLocked;
    U032 Head = 0; // MPLL is on head 0
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramMClkArg->id != DAC_PROGRAMMCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramMClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->MPllM;
    nNew = pDacHalInfo->MPllN;
    pNew = pDacHalInfo->MPllP;

    // Program the hardware

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
	    REG_WR32
            (
                NV_PRAMDAC_MPLL_COEFF,
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pOld)
            );

        // Wait until M PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _MPLL_LOCK)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _MPLL_LOCK)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: M PLL not locked\n");
        }
    }

    // Now we can write the final value
	REG_WR32
        (
            NV_PRAMDAC_MPLL_COEFF,
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pNew)
        );

    // Update the number of clock cycles per memory refresh cycle
    
    // Determine original frequency from old M, N, P values
    oldMClk  = (nOld * pMcHalInfo->CrystalFreq / (1 << pOld) / mOld);

    // Determine original cycles per refresh
    oldCyclesPerRefresh = REG_RD_DRF( _PFB, _TIMING2, _REFRESH ) * 32;

    // Determine original refresh period
    oldPeriod = oldCyclesPerRefresh * 1024 / ( oldMClk / 1000 );
    
    // Now using the new MCLK, figure out the new cycles per refresh
    newCyclesPerRefresh = ( pDacHalInfo->MClk / 1000 ) * oldPeriod / 1024;

    // Store the new value
    FLD_WR_DRF_NUM( _PFB, _TIMING2, _REFRESH, newCyclesPerRefresh / 32 );
    
    return status;
}

//
// nvHalDacProgramNVClk_NV20 - Program NVCLK based on the value in pDev->Dac.HalInfo.NVClk
//
// This routine uses the value in pDev->Dac.HalInfo.NVClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramNVClk_NV20(VOID *arg)
{
    PDACPROGRAMNVCLKARG_000 pDacProgramNVClkArg = (PDACPROGRAMNVCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 i;
    U032 Loops;
    U032 IsPllLocked;
    U032 Head = 0; // NVPLL is on head 0
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramNVClkArg->id != DAC_PROGRAMNVCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramNVClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->NVPllM;
    nNew = pDacHalInfo->NVPllN;
    pNew = pDacHalInfo->NVPllP;

    // Program the hardware

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
	    REG_WR32
            (
                NV_PRAMDAC_NVPLL_COEFF,
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pOld)
            );

        // Wait until NV PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _NVPLL_LOCK)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _NVPLL_LOCK)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: NV PLL not locked\n");
        }
    }

    // Now we can write the final value
	REG_WR32
        (
            NV_PRAMDAC_NVPLL_COEFF,
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pNew)
        );

    // Update NV_PBUS_DEBUG_3 to control data throttling in AGP 4X mode
    i = 0;
    while ( ( pDacHalInfo->NVClk <= NV20_dacAGPClockTable[ i ].frequency ) &&
        ( i < sizeof( NV20_dacAGPClockTable ) / sizeof( NV20_dacAGPClockTable[ 0 ] ) - 1 ) )
    {
        i++;
    }

    FLD_WR_DRF_NUM( _PBUS, _DEBUG_3, _AGP_4X_NVCLK, NV20_dacAGPClockTable[ i ].setting );
    
    return status;
}

//
// nvHalDacProgramPClk_NV20
//
RM_STATUS
nvHalDacProgramPClk_NV20(VOID *arg)
{
    PDACPROGRAMPCLKARG_000 pDacProgramPClkArg = (PDACPROGRAMPCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032            CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    U032            Head;
    U032            PixelClock;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 Loops;
    U032 IsPllLocked;

    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramPClkArg->id != DAC_PROGRAMPCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramPClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramPClkArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    mNew = pDacHalInfo->VPllM;
    nNew = pDacHalInfo->VPllN;
    pNew = pDacHalInfo->VPllP;

    Head = pDacHalObj->Head;
    PixelClock = pDacProgramPClkArg->PixelClock;

    // Program the hardware

    // Retrieve original coefficients
    // NV11 VPLL2 unfortunately is not at the "expected" offset, so we can't use the HAL macro (DAC_REG_RD32)
    if (Head == 0) 
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL_COEFF );
    }
    else
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL2_COEFF );
    }
    mOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first. 
        if (Head == 0) 
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }
        else
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL2_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }

        // Wait until V PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: VPLL not locked\n");
        }
    }

    // Now we can write the final value
    if (Head == 0) 
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }
    else
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL2_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }

    return status;
}

//
// nvHalDacProgramCursorImage_NV20
//
RM_STATUS
nvHalDacProgramCursorImage_NV20(VOID *arg)
{
    PDACPROGRAMCURSORARG_000 pDacProgramCursorImgArg = (PDACPROGRAMCURSORARG_000) arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032        CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    U032        cursorConfig;

    //
    // Verify interface revision.
    //
    if (pDacProgramCursorImgArg->id != DAC_PROGRAMCURSOR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramCursorImgArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramCursorImgArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    // Read the cursorConfig register.
    cursorConfig = HAL_DAC_REG_RD32(NV_PCRTC_CURSOR_CONFIG, CurDacAdr);

    // Preserve the enable and scan_double bits. Clear the rest
    cursorConfig &= ((1 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_ENABLE)) |
                     (1 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_SCAN_DOUBLE)));

    // Mark the Address Space Indicator to indicate where the cursor image is, 
    // based on the param "asi".
    cursorConfig |= (pDacProgramCursorImgArg->asi << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_ADDRESS_SPACE));

    // The supported cursor image sizes are 32x32 or 64x64.
    if (pDacProgramCursorImgArg->width == 32)
    {
        // 32x32
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_PIXELS, NV_PCRTC_CURSOR_CONFIG_CUR_PIXELS_32);
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_LINES, NV_PCRTC_CURSOR_CONFIG_CUR_LINES_32);
    }
    else
    {
        //64x64
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_PIXELS, NV_PCRTC_CURSOR_CONFIG_CUR_PIXELS_64);
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_LINES, NV_PCRTC_CURSOR_CONFIG_CUR_LINES_64);
    }

    // The different color formats are implemented by two bits: The Blend bit and Bpp bit.
    //       Blend      Bpp        Format
    //       ----------------------------
    //         0         0     ->  ROP1R5G5B5
    //         0         1     ->  PM_A8R8G8B8  *** This format is only supported in NV15 or later.
    //         1         0     ->  A1R5G5B5
    //         1         1     ->  A8R8G8B8
    switch (pDacProgramCursorImgArg->colorFormat)
    {
        case NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A1R5G5B5:
            // Set blend = 0. Bpp is already 0
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BLEND_ALPHA << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BLEND));
            break;
        case NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A8R8G8B8:
            // set blend = 1, bpp = 1
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BLEND_ALPHA << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BLEND));
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BPP_32 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BPP));
            break;
        case NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8:
                // set bpp = 1, blend is already 0 (only supported in NV15 or later)
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BPP_32 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BPP));
            // else fall through to default
        default:
            // Leave blend and bpp both 0 (ROP1R5G5B5)
            break;
    }

    // write the new cursor config register value.
    HAL_DAC_REG_WR32(NV_PCRTC_CURSOR_CONFIG, cursorConfig, CurDacAdr);

    //            
    // If not driving a TV and we're on an NV15 or later, turn on the LONG_PIPE to extend the cursor FIFO
    // when running 32bpp or alpha cursors; otherwise, keep it short.
    //
    // Note that this means that 16bpp Alpha and 32bpp cursors are not allowed on a TV.
    // XXXscottl - But we've increased the TVOUT_LATENCY value, so 
    //             lets allow 32bpp cursors on tv for now.
    //
    // preset to short 
    HAL_DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIPE, _SHORT, CurDacAdr); 

    if (HAL_GETDISPLAYTYPE(pDacHalObj->Head) != DISPLAY_TYPE_TV)    
    {
        if ((pDacProgramCursorImgArg->colorFormat == NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A1R5G5B5) ||
            (pDacProgramCursorImgArg->colorFormat == NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A8R8G8B8) ||
            (pDacProgramCursorImgArg->colorFormat == NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8))
        {    
            HAL_DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIPE, _LONG, CurDacAdr);
        }
    }

    // Program the start address.
    // If the address space indicator says it is in Instance Memory, the startAddr is in terms of 
    // paragraphs instead of bytes. Adjust it to bytes.
    if (pDacProgramCursorImgArg->asi == NV_PCRTC_CURSOR_CONFIG_ADDRESS_SPACE_PINST)
    {
        pDacProgramCursorImgArg->startAddr <<= 4;
    }

    HAL_DAC_REG_WR32(NV_PCRTC_CURSOR, pDacProgramCursorImgArg->startAddr, CurDacAdr);

    return RM_OK;
}

//
// nvHalDacGetRasterPosition_NV20
//
RM_STATUS
nvHalDacGetRasterPosition_NV20(VOID *arg)
{
    PDACRASTERPOSARG_000 pDacRasterPosArg = (PDACRASTERPOSARG_000) arg;
    PHALHWINFO pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pDacRasterPosArg->id != DAC_RASTERPOS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacRasterPosArg->pHalHwInfo;

    // TO DO: use head number

    // no RL0/RL1 index regs, so return NV_PCRTC_RASTER_POSITION
    pDacRasterPosArg->result =  (U016) REG_RD_DRF(_PCRTC, _RASTER, _POSITION);

    return (RM_OK);
}

//
// Attempt to validate the given parameters will work with the current configuration
//
//  Return 0  if not capable
//  Return ~0 if valid
//
RM_STATUS
nvHalDacValidateArbSettings_NV20(VOID *arg)
{
    PDACVALIDATEARBSETTINGSARG_000    pDacValidateArbSettingsArg = (PDACVALIDATEARBSETTINGSARG_000) arg;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;

	fifo_info   fifo_data;
	sim_state   sim_data;
    U032        pclk_limit;

    //
    // Verify interface revision.
    //
    if (pDacValidateArbSettingsArg->id != DAC_VALIDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacValidateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;

    //
    // First we must validate that the incoming vclk is within our DAC range.
    //
    switch (pDacValidateArbSettingsArg->bpp)
    {
        case 8:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp;
            break;
        case 15:
        case 16:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp;
            break;
        case 24:
        case 32:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp;
            break;
        default:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp;
            break;
    }

    //
    // If incoming clock is greater than DAC range, return failure
    //
    if (pDacValidateArbSettingsArg->vclk > pclk_limit)
    {
        pDacValidateArbSettingsArg->result = 0;
        return (RM_OK);
    }
        
	//
	// Build the sim table using current system settings
	//
	sim_data.pix_bpp	    = (char) pDacValidateArbSettingsArg->bpp;
	sim_data.enable_video	= pDacValidateArbSettingsArg->video_enabled ? 1 : 0;
	sim_data.enable_mp	    = pDacValidateArbSettingsArg->mport_enabled ? 1 : 0;
	sim_data.memory_width   = pDacHalInfo->InputWidth;
	sim_data.mem_latency	= 3;
    sim_data.memory_type    = (pFbHalInfo->RamType == BUFFER_DDRAM) ? 1 : 0;    // 1=DD,0=SD
	sim_data.mem_aligned	= 1;
    sim_data.mem_page_miss  = 10;
	sim_data.gr_during_vid	= pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
	sim_data.pclk_khz	    = pDacValidateArbSettingsArg->vclk / 1000;  // in kHz, not MHz
	sim_data.mclk_khz	    = pDacHalInfo->MClk / 1000;	                // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;                // in kHz, not MHz

    //
	// Run the numbers through the ringer
	//
    NV20_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);

    /*
    //
    // If the CRTC can do this, double check to make sure the overlay is able as well
    //
    if (fifo_data.valid && video_enabled)
        fifo_data.valid = NV20_dacCalculateVideoCaps(pDev);
    */
    
    pDacValidateArbSettingsArg->result = (U032)fifo_data.valid;
    return (RM_OK);
}

RM_STATUS
nvHalDacUpdateArbSettings_NV20(VOID *arg)
{
    PDACUPDATEARBSETTINGSARG_000     pDacUpdateArbSettingsArg = (PDACUPDATEARBSETTINGSARG_000) arg;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;
    PMPHALINFO          pMpHalInfo;
    U032                Head;
    U032                CurDacAdr;
    DACVALIDATEARBSETTINGSARG_000   dacValidateArbSettingsArg;

    fifo_info   fifo_data;
    sim_state   sim_data;
    U008        lock;
    U032        M, N, O, P;

    //
    // Verify interface revision.
    //
    if (pDacUpdateArbSettingsArg->id != DAC_UPDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacUpdateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pMpHalInfo = pHalHwInfo->pMpHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacUpdateArbSettingsArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;
    Head = pDacHalObj->Head;

    //
    // Recalculate the current PCLK setting.  We might have changed modes
    // recently.
    //
    M = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _MDIV);
    N = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _NDIV);
    P = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _PDIV);
    O = 1;
    
    pDacHalInfo->VPllM = M;
    pDacHalInfo->VPllN = N;
    pDacHalInfo->VPllO = O;
    pDacHalInfo->VPllP = P;
    pDacHalInfo->VClk  = (N * pMcHalInfo->CrystalFreq / (1 << P) / M);
    
    //
    // Check if we can support an overlay in this resolution.  If we can, set the default desktop timings
    // to assume we are running an overlay.
    //
    dacValidateArbSettingsArg.id = DAC_VALIDATEARBSETTINGS_000;
    dacValidateArbSettingsArg.pHalHwInfo = pHalHwInfo;
    dacValidateArbSettingsArg.bpp = pDacHalInfo->Depth;
    dacValidateArbSettingsArg.video_enabled = 1;
    dacValidateArbSettingsArg.mport_enabled = 0;
    dacValidateArbSettingsArg.vclk = pDacHalInfo->PixelClock * 10000;

    // if (NV20_dacValidateArbitrationSettings(pHalHwInfo, pDacHalInfo->Depth, 1, 0, (pDev->Dac.PixelClock * 10000)))
    nvHalDacValidateArbSettings_NV20(&dacValidateArbSettingsArg);
    if (dacValidateArbSettingsArg.result)
        sim_data.enable_video = 1;
    else
        sim_data.enable_video = 0;
    
	sim_data.pix_bpp	    = (char) pDacHalInfo->Depth;
	//sim_data.enable_video	= pDev->Video.Enabled ? 1 : 0;
	sim_data.enable_mp	    = pMpHalInfo->Enabled ? 1 : 0;
	sim_data.memory_width   = pDacHalInfo->InputWidth;
	sim_data.mem_aligned	= 1;
    sim_data.memory_type    = (pFbHalInfo->RamType == BUFFER_DDRAM) ? 1 : 0; //1=DD,0=SD
	sim_data.mem_latency	= 3;
    sim_data.mem_page_miss  = 10;
	sim_data.gr_during_vid	= pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
	sim_data.pclk_khz	    = pDacHalInfo->VClk / 1000;	    // in kHz, not MHz
	sim_data.mclk_khz	    = pDacHalInfo->MClk / 1000;	    // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;    // in kHz, not MHz

    // 
	// Get those new numbers
	//
    NV20_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    
    // for now, assume pass
    //fifo_data.valid = 1;
	
//	For TV, we should not change some of these. Gfx Fifo Low Water Mark in particular should
//		not be changed. 
//    if (pDev->Framebuffer.DisplayType != DISPLAY_TYPE_TV) // leave alone if TV

    //
	// If valid settings found, update the hardware
	//
	if (fifo_data.valid)
	{
        //
        // Set the DAC FIFO Thresholds and burst size

        /*
        //
        // Check overlay capabilities.
        //
        if (!NV20_dacCalculateVideoCaps(pDev))
            pDev->Video.OverlayAllowed = 0;
        */

        //
        // These are the PVIDEO burst/watermark hardcoded values
        // we've gotten from the HW engineers.
        //
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST1, 16);         // 512 bytes
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST2, 16);         // 512 bytes
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK1, 64);    // 1024 bytes
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK2, 64);    // 1024 bytes

		//
        // Update the CRTC watermarks
        //
		// Unlock CRTC extended regs
        HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, CurDacAdr);
        HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);

#if 0
        // XXX these are temporary CRTC burst/watermark hardcoded values
        // we've gotten from the HW engineers.
        CRTC_WR(NV_CIO_CRE_FF_INDEX, NV_CIO_CRE_FF_BURST_512);  // 512 bytes

        // XXX bump up the LWM if we're running a higher resolution (we base
        // this check on the primary surface display pitch). This is still too
        // simple a heuristic ... but it has shown to work for 1920x1440x32.

        //if (pDev->Framebuffer.DisplayPitch < 0x2000) {
        if (pDev->Dac.HalInfo.VClk < 170000000) {
		    CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 64);               // 512 bytes
        } else {
		    CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 80);               // 640 bytes
        }

#else
        //
        // Set the CRTC watermarks and burst size
        //
		HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, (U008) (fifo_data.crtc1_lwm >> 3), CurDacAdr);
		switch (fifo_data.crtc1_burst_size)
		{
			case 512:
				HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 5, CurDacAdr);
				break;
			case 256:
				HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 4, CurDacAdr);
				break;
			case 128:
				HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 3, CurDacAdr);
				break;
			case 64:
				HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 2, CurDacAdr);
				break;
			case 32:
				HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 1, CurDacAdr);
				break;
			case 16:
				HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 0, CurDacAdr);
				break;
		}
#endif
        //
        // Relock if necessary
        //
		if (lock == 0)
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr);
        
		return (RM_OK);
	}
	else
    {
        //
        // No valid setting was found!!!
        //
        //  Make a conservative guess and fail.
        //
        
		// Unlock CRTC extended regs
        HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, CurDacAdr);
        HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);
        
		HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x72, CurDacAdr);
		HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 5, CurDacAdr);
        
        //
        // Relock if necessary
        //
		if (lock == 0)
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr);
        
		return (RM_ERROR);
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\i2c.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* I2C Control *******************************\
*                                                                           *
* Module: I2C.C                                                             *
*   The I2C port is managed within this module.                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>
#include "i2c.h"

#include <nvmisc.h>

//---------------------------------------------------------------------------
//
//  I2C support routines.
//
//---------------------------------------------------------------------------

// Serial Port Bits
#define I2C_SRCK        0x20    // Serial Clock write
#define I2C_SRD         0x10    // Serial Data  write
#define I2C_SRCK_IN     0x04    // Serial Clock read
#define I2C_SRD_IN      0x08    // Serial Data  read
#define I2C_ENABLE      0x01    // Enable Serial Port Function

///////////////////////////////////////////////////////////////////

// Constants used by I2C Protocoll:

#define SDA_REG         0x02
#define SCL_REG         0x01


#define ACK             0   // I2C Acknowledge
#define NACK            1   // I2C No Acknowledge

	
// Module Global Variables

// variables could be modified via INI file
// U008 iniFlag = FALSE;
#ifdef  IKOS
U032 wMaxWaitStates=2;     // max wait states for I2C bus syncronisation
#else   // IKOS
U032 wMaxWaitStates=3000;  // max wait states for I2C bus syncronisation
#endif  // IKOS
U032 wGpo=0;               // GPO bits for switching to I2C operation

//
// Insure register updates have been flushed out of the write buffer
// by performing a cpuid instruction
//
// XXX this should be in common/nvUtil/ or somewhere else
#ifdef WIN31

#ifdef NEWWIN31

void __cdecl FlushWB(void)
{
    __asm push esi
    __asm push edi
    __asm push ebx
    __asm mov eax, 0x0
        __asm _emit 0x0f
        __asm _emit 0xa2
    __asm pop ebx
    __asm pop edi
    __asm pop esi
}

#else  //old win31

void FlushWB(void);
#pragma aux FlushWB =				\
            "mov    EAX, 0x0"			\
            0x0F 0xA2
#endif

#elif defined(__PPC__)

void FlushWB(void)
{
    __eieio();
}


#elif defined(__GNUC__)		// UNIX and DJPP
void FlushWB(void)
{
    // save regs (especially ebx) that might get stomped by 'cpuid'
    __asm__("push %esi");
    __asm__("push %edi");
    __asm__("push %ebx");
        __asm__("xorl %eax, %eax");
        __asm__("cpuid");
    __asm__("pop %ebx");
    __asm__("pop %edi");
    __asm__("pop %esi");
}

#else   // !WIN31 !UNIX !DJPP

void __cdecl FlushWB(void)
{
// TO DO: what to do about inline asm for IA-64?       
#ifndef IA64
    __asm push esi
    __asm push edi
    __asm push ebx
    __asm mov eax, 0x0
        __asm _emit 0x0f
        __asm _emit 0xa2
    __asm pop ebx
    __asm pop edi
    __asm pop esi
#endif // IA-64 cannot tolerate inline asm
}

#endif

void i2cWriteCRTCWrIndex
(
    PHWINFO pDev,
    U032 Head,
    U032 portID,
    U008 data
)
{
    switch (portID) 
    {
    case NV_I2C_PORT_PRIMARY:
        CRTC_WR(pDev->Dac.I2CPrimaryWriteIndex, data, Head);
        break;
    case NV_I2C_PORT_SECONDARY:
        CRTC_WR(pDev->Dac.I2CSecondaryWriteIndex, data, Head);
        break;
    case NV_I2C_PORT_TERTIARY:
        CRTC_WR(pDev->Dac.I2CTertiaryWriteIndex, data, Head);
        break;
    }
}

   
U008 i2cReadCRTCWrIndex
(
    PHWINFO pDev,
    U032 Head,
    U032 portID
)
{
    U008 data = 0xFF;

    switch (portID) 
    {
    case NV_I2C_PORT_PRIMARY:
        CRTC_RD(pDev->Dac.I2CPrimaryWriteIndex, data, Head);
        break;
    case NV_I2C_PORT_SECONDARY:
        CRTC_RD(pDev->Dac.I2CSecondaryWriteIndex, data, Head);
        break;
    case NV_I2C_PORT_TERTIARY:
        CRTC_RD(pDev->Dac.I2CTertiaryWriteIndex, data, Head);
        break;
    }
    return data;
}
   

U008 i2cReadCRTCStatusIndex
(
    PHWINFO pDev,
    U032 Head,
    U032 portID
)
{
    U008 data = 0xFF;

    switch (portID) 
    {
    case NV_I2C_PORT_PRIMARY:
        CRTC_RD(pDev->Dac.I2CPrimaryStatusIndex, data, Head);
        break;
    case NV_I2C_PORT_SECONDARY:
        CRTC_RD(pDev->Dac.I2CSecondaryStatusIndex, data, Head);
        break;
    case NV_I2C_PORT_TERTIARY:
        CRTC_RD(pDev->Dac.I2CTertiaryStatusIndex, data, Head);
        break;
    }
    return data;
}

U008 i2cHardwareInit
(
    PHWINFO pDev,
    U032 Head,
    U032 portID
)
{
    // On dual-headed devices, enable I2C interface
    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);
    }
    
    //
    // If the initialization has already been done then just return
    //
    // if (iniFlag == TRUE)
    //    return TRUE;

    i2cWriteCRTCWrIndex(pDev, Head, portID, 0x31);
	
	pDev->Dac.I2cIniFlag = TRUE;
	return TRUE;
}


VOID i2cWriteCtrl
(
    PHWINFO pDev,
    U032 Head,
    U032 portID,
    U008 reg,
    U008 bit
)
{
    U008 data;

    //
    // Get the current status and toggle
    //
	data = i2cReadCRTCWrIndex(pDev, Head, portID);

	data &= 0xf0;
    data |= I2C_ENABLE;
    
    if (reg == SCL_REG)
    {
      if (bit)
        data |=  I2C_SRCK;
      else
        data &= ~I2C_SRCK;
    }
    else
    {
      if (bit)
        data |=  I2C_SRD;
      else
        data &= ~I2C_SRD;
    }    

	i2cWriteCRTCWrIndex(pDev, Head, portID, data);
    FlushWB();
}

U008 i2cReadCtrl
(
    PHWINFO pDev,
    U032 Head,
    U032 portID,
    U008 reg
)
{
    U008 data;
   
    data = i2cReadCRTCStatusIndex(pDev, Head, portID);    

    if (reg == SCL_REG)
        return ( (data & I2C_SRCK_IN) != 0);
    else
        return ( (data & I2C_SRD_IN) != 0);
}
   
/**********************************************************************/

VOID ReadSDA(PHWINFO pDev, U032 Head, U032 portID, U008 *data)
{
	*data = i2cReadCtrl(pDev, Head, portID, SDA_REG);
}

VOID ReadSCL(PHWINFO pDev, U032 Head, U032 portID, U008 *data)
{
	*data = i2cReadCtrl(pDev, Head, portID, SCL_REG);
}   

VOID SetSCLLine(PHWINFO pDev, U032 Head, U032 portID)
{
	i2cWriteCtrl(pDev, Head, portID, SCL_REG, 1);
}

VOID ResetSCLLine(PHWINFO pDev, U032 Head, U032 portID)
{
	i2cWriteCtrl(pDev, Head, portID, SCL_REG, 0);
}

VOID SetSDALine(PHWINFO pDev, U032 Head, U032 portID)
{
	i2cWriteCtrl(pDev, Head, portID, SDA_REG, 1);
}

VOID ResetSDALine(PHWINFO pDev, U032 Head, U032 portID)
{
	i2cWriteCtrl(pDev, Head, portID, SDA_REG, 0);
} 
 
/*
 * waits for a specified line til it goes high
 * giving up after MAX_WAIT_STATES attempts
 * return:  0 OK
 *         -1 fail (time out)
 */
U008 WaitHighSDALine(PHWINFO pDev, U032 Head, U032 portID)
{
    U008    data_in;
    U032    retries = wMaxWaitStates;

    do
    {
        ReadSDA(pDev, Head, portID, &data_in);      // wait for the line going high
        if (data_in)
            break;
        tmrDelay(pDev, 5000);         // 5us delay    
    } while (--retries);        // count down is running

    if (!retries)
        return((U008)-1);
    return 0;
}                    

U008 WaitHighSCLLine(PHWINFO pDev, U032 Head, U032 portID)
{
    U008    data_in;
    U032    retries = wMaxWaitStates;

    do
    {
        tmrDelay(pDev, 1000);              // 1.0 us delay    
        ReadSCL(pDev, Head, portID, (U008 *)&data_in);   // wait for the line going high
        if (data_in)
            break;
    } while (--retries);            // count down is running

    if (!retries)
        return((U008)-1);
    return(0);    
}


VOID i2cStart(PHWINFO pDev, U032 Head, U032 portID)
{
    SetSDALine(pDev, Head, portID); 
    tmrDelay(pDev, 5000); SetSCLLine(pDev, Head, portID); WaitHighSCLLine(pDev, Head, portID);
    ResetSDALine(pDev, Head, portID);
    tmrDelay(pDev, 5000);
    ResetSCLLine(pDev, Head, portID);
}


VOID i2cStop(PHWINFO pDev, U032 Head, U032 portID)
{
    tmrDelay(pDev, 200000);
    ResetSCLLine(pDev, Head, portID);
    ResetSDALine(pDev, Head, portID);
    tmrDelay(pDev, 5000); SetSCLLine(pDev, Head, portID); WaitHighSCLLine(pDev, Head, portID); 
    SetSDALine(pDev, Head, portID); 
    tmrDelay(pDev, 5000);
}


/*
 * I2cAck() returns 1: fail
 *                  0: acknolege
 */

U008 i2cAck(PHWINFO pDev, U032 Head, U032 portID)
{
    U008 ack;

    ResetSCLLine(pDev, Head, portID); tmrDelay(pDev, 5000);
    SetSDALine(pDev, Head, portID); tmrDelay(pDev, 5000);
    SetSCLLine(pDev, Head, portID); WaitHighSCLLine(pDev, Head, portID);
    ReadSDA(pDev, Head, portID, &ack);
    ResetSCLLine(pDev, Head, portID);
    return (ack);
}


VOID i2cInit(PHWINFO pDev, U032 Head, U032 portID)
{
    SetSCLLine(pDev, Head, portID); WaitHighSCLLine(pDev, Head, portID);
    SetSDALine(pDev, Head, portID); 
}


U008 i2cSendByte(PHWINFO pDev, U032 Head, U032 portID, U008 byte)
{
    U008 i;

    for (i=0;i<8;i++)
    {
	    ResetSCLLine(pDev, Head, portID);
	    tmrDelay(pDev, 2500);
        if (byte & 0x80)
		    SetSDALine(pDev, Head, portID);
	    else
		    ResetSDALine(pDev, Head, portID);
	    tmrDelay(pDev, 2500);
	    SetSCLLine(pDev, Head, portID); WaitHighSCLLine(pDev, Head, portID);
	    byte <<= 1;
    }
    
    return (i2cAck(pDev, Head, portID));
}


RM_STATUS i2cReceiveByte(PHWINFO pDev, U032 Head, U032 portID, U008 *byte, U008 ack)
{
    U008 data=0;
    U008 i;
    RM_STATUS status;

    ResetSCLLine(pDev, Head, portID);
    SetSDALine(pDev, Head, portID); 
    tmrDelay(pDev, 1000);

    for (i=0;i<8;i++)
	{
	    ResetSCLLine(pDev, Head, portID);
	    ResetSCLLine(pDev, Head, portID);	/* this second reset seems to be needed, why? (jsun) */
	    SetSCLLine(pDev, Head, portID); 
        status = WaitHighSCLLine(pDev, Head, portID) ? RM_ERROR : RM_OK;
        if (status != RM_OK)
            goto done;

	    ReadSDA(pDev, Head, portID, &data);
	    *byte <<= 1;
	    *byte  |= (data == 1);
	}

    ResetSCLLine(pDev, Head, portID);
    if (ack) 
    {
        SetSDALine(pDev, Head, portID);         // send Nack
	tmrDelay(pDev, 1000);
    }
    else
        ResetSDALine(pDev, Head, portID);       // send Ack
    
    SetSCLLine(pDev, Head, portID); 
    status = WaitHighSCLLine(pDev, Head, portID) ? RM_ERROR : RM_OK;
    ResetSCLLine(pDev, Head, portID);

done:
    return status;
}


RM_STATUS i2cWrite(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    if ( i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1)) ) // send chip adr. with write bit
    {
        i2cStop(pDev, Head, portID);                         // ack failed --> generate stop condition
        return(RM_ERROR); 
    }
    for ( ; AdrLen; AdrLen--)             
    {
        if ( i2cSendByte(pDev, Head, portID, *Adr++) )        // send sub-register byte(s)
        {
            i2cStop(pDev, Head, portID);                    // ack failed --> generate stop condition
            return(RM_ERROR); 
        }
    }
    for ( ; DataLen; DataLen--)            // send data byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Data++) )
        {
            i2cStop(pDev, Head, portID);                     // ack failed --> generate stop condition
            return(RM_ERROR);
        }
    }
    i2cStop(pDev, Head, portID);
    return(RM_OK);
}


RM_STATUS i2cRead(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    U008 dat;
    RM_STATUS status = RM_ERROR;        // pessimist
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: ChipAdr ", (U032)ChipAdr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: AdrLen ", (U032)AdrLen);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Adr ", (U032)*Adr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: DataLen ", (U032)DataLen);

    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1));        // send chip adr. with write bit

    for ( ; AdrLen; AdrLen--)               // send sub-register address byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Adr++) )
        {
            goto done;
        }
    }
    i2cStart(pDev, Head, portID);                             // send again chip address for switching to read mode
    if ( i2cSendByte(pDev, Head, portID, (U008)((ChipAdr<<1) | 1)) )  // send chip adr. with read bit
    {
        goto done;
    }

    for (status = RM_OK; DataLen && (status == RM_OK); DataLen--)
    {
        status = i2cReceiveByte(pDev,
                                Head,
                                portID, 
                                (U008 *)&dat, 
                                (U008)((DataLen == 1) ? NACK : ACK));         // receive byte(s)
        *Data++ = dat;
    }

done:
    i2cStop(pDev, Head, portID);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Data ", (U032)*Data);
    
    return status;
}

RM_STATUS i2cSend(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data, U032 NoStopFlag)
{

    if ( ChipAdr ) {
        //
        // Enable writes to the I2C port
        //
        i2cHardwareInit(pDev, Head, portID);

        i2cStart(pDev, Head, portID);
        if ( i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1)) ) // send chip adr. with write bit
        {
            i2cStop(pDev, Head, portID);                         // ack failed --> generate stop condition
            return(RM_ERROR); 
        }
    }

    for ( ; AdrLen; AdrLen--)             
    {
        if ( i2cSendByte(pDev, Head, portID, *Adr++) )        // send sub-register byte(s)
        {
            i2cStop(pDev, Head, portID);                    // ack failed --> generate stop condition
            return(RM_ERROR); 
        }
    }

    for ( ; DataLen; DataLen--)            // send data byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Data++) )
        {
            i2cStop(pDev, Head, portID);                     // ack failed --> generate stop condition
            return(RM_ERROR);
        }
    }

    if ( NoStopFlag == 0 )
        i2cStop(pDev, Head, portID);

    return(RM_OK);
}


RM_STATUS i2cWrite_ALT(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    if ( i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1)) ) // send chip adr. with write bit
    {
        i2cStop(pDev, Head, portID);                         // ack failed --> generate stop condition
        return(RM_ERROR); 
    }
    for ( ; DataLen; DataLen--)            // send data byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Data++) )
        {
            i2cStop(pDev, Head, portID);                     // ack failed --> generate stop condition
            return(RM_ERROR);
        }
    }
    i2cStop(pDev, Head, portID);
    return(RM_OK);
}


RM_STATUS i2cRead_ALT(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    U008 dat;
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: ChipAdr ", (U032)ChipAdr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: AdrLen ", (U032)AdrLen);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Adr ", (U032)*Adr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: DataLen ", (U032)DataLen);

    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    i2cSendByte(pDev, Head, portID, (U008)((ChipAdr<<1) | 1));        // send chip adr. with write bit
    for ( ; DataLen ; DataLen--)
    {
        i2cReceiveByte(pDev, Head, portID, (U008 *)&dat, (U008)((DataLen == 1) ? NACK : ACK));         // receive byte(s)
        *Data++ = dat;
    }
    i2cStop(pDev, Head, portID);
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Data ", (U032)*Data);
    
    return(RM_OK);
}


RM_STATUS i2cRead_ALT2(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    U008 dat;
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: ChipAdr ", (U032)ChipAdr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: AdrLen ", (U032)AdrLen);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Adr ", (U032)*Adr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: DataLen ", (U032)DataLen);

    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1));        // send chip adr. with write bit

    for ( ; AdrLen; AdrLen--)               // send sub-register address byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Adr++) )
        {
            i2cStop(pDev, Head, portID);                      // ack failed --> generate stop condition
            return(RM_ERROR); 
        }
    }
    i2cStop(pDev, Head, portID);
    
    i2cStart(pDev, Head, portID);                             // send again chip address for switching to read mode
    if ( i2cSendByte(pDev, Head, portID, (U008)((ChipAdr<<1) | 1)) )  // send chip adr. with read bit
    {
        i2cStop(pDev, Head, portID);                         // ack failed --> generate stop condition
        return(RM_ERROR); 
    }

    for ( ; DataLen ; DataLen--)
    {
        i2cReceiveByte(pDev, Head, portID, (U008 *)&dat, (U008)((DataLen == 1) ? NACK : ACK));         // receive byte(s)
        *Data++ = dat;
    }

    i2cStop(pDev, Head, portID);
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Data ", (U032)*Data);
    
    return(RM_OK);
}

RM_STATUS i2cAccess
(
    PHWINFO pDev,
    U032 Head,
    NVRM_I2C_ACCESS_CONTROL    *pCtrl
)
{

    RM_STATUS rmStatus = RM_OK;

    U032	startFlag;
    U032	stopFlag;
    U032	ackFlag;
    U032	port;
    U008	data = 0;

    /*
     * verify the token
     *
     * NOTE: we allow I2C Access if the token is 0 AND no one
     * else has acquired it.  The idea is that 3rd party vendors
     * will not be able to acquire/lock I2C; however, we can still
     * acquire/lock I2C internally and lock 3rd party access out.
     * The reason is that we don't a 3rd party app to crash while
     * still holding a lock on I2C and thus lock us out from internal
     * access.  We have priority in this scheme and 3rd party
     * apps must deal with contention by checking return codes for
     * errors.
     */
     
    if(pDev->Power.State == MC_POWER_LEVEL_3)
    {
    	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"Attempted I2C access before waking up. Invalid request denied.\n");
    
    	//if we are at a state of power management, we need to reject this call
    	return NVRM_I2C_ACCESS_STATUS_ERROR;
    }
     
    if ((pCtrl->cmd == NVRM_I2C_ACCESS_CMD_WRITE_BYTE) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_READ_BYTE) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_NULL) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_RESET) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_READ_SDA) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_READ_SCL) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_WRITE_SDA) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_WRITE_SCL)) {

        if (pCtrl->token != pDev->I2CAcquired) {
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_DEVICE_BUSY;
            return RM_ERROR;
        }

    }

    /*
     * Unlock CRTC extended regs
     */

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

    /*
     * retrieve the flags and port
     */

    startFlag = pCtrl->flags & NVRM_I2C_ACCESS_FLAG_START;
    stopFlag = pCtrl->flags & NVRM_I2C_ACCESS_FLAG_STOP;
    ackFlag = pCtrl->flags & NVRM_I2C_ACCESS_FLAG_ACK;

    if ( pCtrl->port == NVRM_I2C_ACCESS_PORT_PRIMARY ) {
        port = NV_I2C_PORT_PRIMARY;
    }
    else {
        port = NV_I2C_PORT_SECONDARY;
    }

    /*
     * handle the command
     */

    pCtrl->status = NVRM_I2C_ACCESS_STATUS_SUCCESS;

    switch ( pCtrl->cmd ) {

      case NVRM_I2C_ACCESS_CMD_ACQUIRE:

        if ( pDev->I2CAcquired ) {
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_DEVICE_BUSY;
            rmStatus = RM_ERROR;
        }
        else {
            pDev->I2CAcquired = 0xbeeffeed; /* arbtrary */
            pCtrl->token = pDev->I2CAcquired;
            i2cHardwareInit(pDev, Head, port);
        }

        break;

      case NVRM_I2C_ACCESS_CMD_RELEASE:

        if ( pDev->I2CAcquired != pCtrl->token ) {
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_ERROR;
            rmStatus = RM_ERROR;
        }
        else {
            pDev->I2CAcquired = 0;
            pCtrl->token = 0;
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_SUCCESS;
        }

        break;

      case NVRM_I2C_ACCESS_CMD_WRITE_BYTE:

        if ( startFlag ) {
            i2cStart(pDev, Head, port);
        }

        data = (U008)(pCtrl->data);
        if ( i2cSendByte(pDev, Head, port,data) ) {
            i2cStop(pDev, Head, port);
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_PROTOCOL_ERROR;
            rmStatus = RM_ERROR;
        }

        if ( stopFlag ) {
            i2cStop(pDev, Head, port);
        }

      	break;

      case NVRM_I2C_ACCESS_CMD_READ_BYTE:

        if ( startFlag ) {
            i2cStart(pDev, Head, port);
        }

        // check for restart read 
        if ( startFlag ) {
            data = (U008)(pCtrl->data);
            if ( i2cSendByte(pDev, Head, port,data) ) {
                i2cStop(pDev, Head, port);
                pCtrl->status = NVRM_I2C_ACCESS_STATUS_PROTOCOL_ERROR;
                rmStatus = RM_ERROR;
            }
        }
        else {
            i2cReceiveByte(pDev, Head, port, &data, (U008)((ackFlag) ? 0 : 1));
            pCtrl->data = data;
        }

        if ( stopFlag ) {
            i2cStop(pDev, Head, port);
        }

      	break;

      case NVRM_I2C_ACCESS_CMD_NULL:

        if ( startFlag ) {
            i2cStart(pDev, Head, port);
        }

        if ( stopFlag ) {
            i2cStop(pDev, Head, port);
        }

      	break;

      case NVRM_I2C_ACCESS_CMD_RESET:

        i2cStop(pDev, Head, port);

      	break;

      case NVRM_I2C_ACCESS_CMD_READ_SDA:

        ReadSDA(pDev, Head, port, &data);
        pCtrl->data = data;

        break;

      case NVRM_I2C_ACCESS_CMD_READ_SCL:

        ReadSCL(pDev, Head, port, &data);
        pCtrl->data = data;

        break;

      case NVRM_I2C_ACCESS_CMD_WRITE_SDA:

        if ( pCtrl->data ) {
            SetSDALine(pDev, Head, port);
        }
        else {
            ResetSDALine(pDev, Head, port);
        }

      case NVRM_I2C_ACCESS_CMD_WRITE_SCL:

        if ( pCtrl->data ) {
            SetSCLLine(pDev, Head, port);
        }
        else {
            ResetSCLLine(pDev, Head, port);
        }

        break;

      default:

        pCtrl->status = NVRM_I2C_ACCESS_STATUS_ERROR;
        rmStatus = RM_ERROR;
        break;

    }

    /* Lock CRTC extended regs */
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, Head);

    return rmStatus;

}

#if 0

///////////////////////////////////////////////////////////////////////////////////////
//
// The following routines were rewritten to not use the NV timer for 
// self-timing.  Don't use them, but keep them around in case we do need them 
// in the future.
//

//
//  delay
//
i2cdelay(int count)
{
	while(count) 
    {
        _asm {
            push dx
            mov  dx,0x80
            in   al,dx
            pop  dx
        }
		count--;
	}
}

//****************************************************************************************
//
//  Send a byte out the I2C interface
int sendbyte(int serial_data) {
	int i, rval=0;
	int readback=0 ; // clear the readback byte
	int r;

    r=0;

// send the bits
	for (i=128; i>=1; i=i/2)
    {

//set the data with clock low
		if (serial_data & i) 
			DDCout(clock0_hi);
		else
			DDCout(clock0_lo);
		i2cdelay(I2C_DELAY/2);

// set clock hi
		if (serial_data & i) 
			DDCout(clock1_hi);
		else
			DDCout(clock1_lo);
		i2cdelay(I2C_DELAY);

// read the data port
#if DEBUG4
		r=input(read_port) ; printf ("port= %x",r);
		r=~r ; printf (", inv, %x",r);
		r=r & SDATA ; printf (", \&, %x",r);
		r=r/2 ; printf (", div, %x",r);
		r=r*i ; printf (", bit #, %x",r);
		readback=readback+r ; printf (", readback=%x \n",readback);
#else
		readback+=i * ( ( (~DDCin() ) & SDATA) >> SDATA_BIT ) ;  // read data in case this is a read
#endif

//return the clock low
		if (serial_data & i) 
			DDCout(clock0_hi);
		else
			DDCout(clock0_lo);
		i2cdelay(I2C_DELAY/2);
	}

// ack bit
	DDCout(ack_state0);
	i2cdelay(I2C_DELAY/2);
	DDCout(ack_state1);
	i2cdelay(I2C_DELAY);

#if DEBUG2
	if ((input(read_port) & 0x02)) printf(" ack\n");
	else printf(" no ack\n");
#endif

	if ((DDCin() & data_in)) rval=ERR_I2C_COMM;	// return a fail.

//	printf (" readback=%x \n", readback );
	DDCout(ack_state2);
	i2cdelay(I2C_DELAY/2);
//   DDCout(i2c_state0);                 // bring both high
	return rval;
}

//****************************************************************************************
//
//  read a byte from the I2C interface
//  this is almost identical to the send byte function
int readbyte(int *read_data) {
	int i, rval=0;
	int readback=0 ; // clear the readback byte
    int serial_data = 0xff;
	int r;

    r=0;

// send the bits
	for (i=128; i>=1; i=i/2)
    {

// send all 1's, which tristates the line, and read back what the encoder is driving
//set the data with clock low
		if (serial_data & i) 
			DDCout(clock0_hi);
		else
			DDCout(clock0_lo);
		i2cdelay(I2C_DELAY/2);

// set clock hi
		if (serial_data & i) 
			DDCout(clock1_hi);
		else
			DDCout(clock1_lo);
		i2cdelay(I2C_DELAY);

//return the clock low
		if (serial_data & i) 
			DDCout(clock0_hi);
		else
			DDCout(clock0_lo);
		i2cdelay(I2C_DELAY/2);

// read the data port
		readback+=i * ( ( (DDCin() ) & SDATA) >> SDATA_BIT) ;  
	}

// ack bit
	DDCout(ack_state0);
	i2cdelay(I2C_DELAY/2);
	DDCout(ack_state1);
	i2cdelay(I2C_DELAY);

	if ((DDCin() & data_in)) rval=ERR_I2C_COMM;	// return a fail.

//	printf (" readback=%x \n", readback );
	DDCout(ack_state2);
	i2cdelay(I2C_DELAY/2);
//   DDCout(i2c_state0);                 // bring both high
    *read_data = readback;
	return rval;
}

//****************************************************************************************
//
void clockStart() {	// creates the start condition

#if DEBUG3
      output(write_port,0x0C); // create a strobe on pin 16 & 17
	i2cdelay(I2C_DELAY);
#endif
	DDCout(i2c_state0);
	i2cdelay(I2C_DELAY/2);
	DDCout(i2c_state1);
	i2cdelay(I2C_DELAY/2);
	DDCout(i2c_state2);
	i2cdelay(I2C_DELAY/2);

}

//****************************************************************************************
//
void clockEnd() {	// creates the end condition

	DDCout(i2c_state2);
	i2cdelay(I2C_DELAY/2);
	DDCout(i2c_state1);
	i2cdelay(I2C_DELAY/2);
	DDCout(i2c_state0);
	i2cdelay(I2C_DELAY/2);
}

//****************************************************************************************
//
VOID DDCout(U008 data)
{
    CRTC_WR(NV_CIO_CRE_DDC_WR__INDEX, data);
}

//****************************************************************************************
//
U008 DDCin()
{
U008 data;

    CRTC_RD(NV_CIO_CRE_DDC_STATUS__INDEX, data);
    return data;
}

/////////////////////////////////////////////////////////////////////

#endif /* 0 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\grayclk.c ===
#include <nvrm.h>
#include <nvhw.h>
#include <nvos.h>
#include <bios.h>            // need BIOS_ROM_CODE_SIZE
#include <nv10_ref.h>

#define __KERNEL__
#include <nv.h>
#include <Nvcm.h>

//doubled table length to avoid wasted effort of boundary checking for something so small
static const U032 GrayCodeLookupTable[16]={0,1,3,2,6,7,5,4,0,1,3,2,6,7,5,4};
static const U032 GrayCodeLookupTableLength=16;

static U032 GrayCodeLookup(U032 Value,U032 starting_position)
{
	U032 x;
	
	Value=Value&0x7;
	
	//looks up 3 bit value in lookup table and returns the position
	for(x=starting_position;x<GrayCodeLookupTableLength;x++)
	{
		if(GrayCodeLookupTable[x]==Value)
		{
			return x;
		}
	}
	
	return 0;
}

void RmProperClockPdivProgrammer(PHWINFO pDev,U032 ClockAddress,U032 NewValue)
{
	U032 OldValue;
	U032 OldPdiv;
	U032 NewPdiv;
	U032 PllValLessPdiv;
	U032 ListPosition;
	U032 TargetPosition;
	U032 CurrentPosition;
	
	//read old value
	OldValue=REG_RD32(ClockAddress);
	
	//obtain old pdiv (16 though 18)
	OldPdiv=(OldValue>>16)&0x7;
	
	//obtain the desired Pll value less the Pdiv
	PllValLessPdiv=NewValue&0xffff;
	
	//obtain the desired Pdiv
	NewPdiv=(NewValue>>16)&0x7;
	
	//lookup position of the items we have and want
	ListPosition=GrayCodeLookup(OldPdiv,0);
	TargetPosition=GrayCodeLookup(NewPdiv,ListPosition);
	
	//transition via gray code to desired setting
	for(CurrentPosition=ListPosition;CurrentPosition<=TargetPosition;CurrentPosition++)
	{
		REG_WR32(ClockAddress,(GrayCodeLookupTable[CurrentPosition]<<16)|PllValLessPdiv);
		
		//wait to allow settle before transitioning again
		osDelay(10);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dac\nv4\dacnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Arbitration **************************\
*                                                                           *
* Module: DACARB.C                                                          *
*   The DAC Arbitration management.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>

/* This file simulates the NV arbitor */
#include <arb_fifo.h>
#include "nvhalcpp.h"

//////////////////////////////////////////
//
// Arbitration routines
//

//
// Calculate the closest arbitration values for a given system configuration
//

static
VOID NV04_dacCalculateArbitration
(
    PHALHWINFO pHalHwInfo,
    fifo_info *fifo,
    sim_state  *arb
)
{
    PFBHALINFO      pFbHalInfo = pHalHwInfo->pFbHalInfo;
    PMCHALINFO      pMcHalInfo = pHalHwInfo->pMcHalInfo;
    PVIDEOHALINFO   pVideoHalInfo = pHalHwInfo->pVideoHalInfo;

    int data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
    int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
    int nvclk_fill, us_extra, clwm_mt;
    int found, mclk_extra, mclk_loop, cbs, m1;
    int mclk_freq, pclk_freq, nvclk_freq, mp_enable;
    int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;
    int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;
    int craw, vraw, m2us, us_pipe, p1clk, p2;
    int h_size, v_size;
    int ram_conf;
  
    fifo->valid = 1;
    pclk_freq = arb->pclk_khz; // freq in KHz
    mclk_freq = arb->mclk_khz;
    nvclk_freq = arb->nvclk_khz;
    pagemiss = arb->mem_page_miss;
    cas = arb->mem_latency;
    width = arb->memory_width/64;
    video_enable = arb->enable_video;
    color_key_enable = arb->gr_during_vid;
    bpp = arb->pix_bpp;
    align = arb->mem_aligned;
    mp_enable = arb->enable_mp;
    clwm = 0;
    vlwm = 0;

    h_size   = pFbHalInfo->HorizDisplayWidth;
    v_size   = pFbHalInfo->VertDisplayWidth;
    ram_conf = arb->ram_config;

    // NV4 can not support 256 burst
    if (IsNV4_NV04(pMcHalInfo))
        cbs = 128;
    else
        cbs = 256;

    pclks = 2;   // lwm detect.

    nvclks = 2;  // lwm -> sync.
    nvclks += 2; // fbi bus cycles (1 req + 1 busy)
    nvclks += 1; // fbi reqsync

    mclks = 5;  // Fifo
    mclks += 3; // MA0 -> MA2
    mclks += 1; // pad->out
    mclks += cas; // Cas Latency.
    mclks += 1; // pad in
    mclks += 1; // latch data
    mclks += 1; // fifo load
    mclks += 1; // fifo write
  
  
    if ((video_enable) && (arb->memory_width == 128))
        mclk_extra = 3; // Margin of error
    else    
        mclk_extra = 17; // Margin of error

    nvclks += 2; // fifo sync
    nvclks += 1; // read data
    nvclks += 1; // fbi_rdata
    nvclks += 1; // crtfifo load

    if(mp_enable)
        mclks+=4; // Mp can get in with a burst of 8.
        
    // Extra clocks determined by heuristics
    nvclks += 0;
    pclks += 0;
    found = 0;
    while(found != 1) 
    {
        fifo->valid = 1;
        found = 1;
        mclk_loop = mclks+mclk_extra;
        us_m = mclk_loop *1000*1000 / mclk_freq;    // Mclk latency in us
        us_n = nvclks*1000*1000 / nvclk_freq;       // nvclk latency in us
        us_p = nvclks*1000*1000 / pclk_freq;        // nvclk latency in us
        us_pipe = us_m + us_n + us_p;
        us_extra = 0;
        if(video_enable) 
        {
            video_drain_rate = pclk_freq * 2;       // MB/s
            crtc_drain_rate = pclk_freq * bpp/8;    // MB/s

            vpagemiss = 1; // self generating page miss
            vpagemiss += 1; // One higher priority before

            crtpagemiss = 2; // self generating page miss

            vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;


            if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
                video_fill_us = 256*1000*1000 / 16 / nvclk_freq ;
            else
                video_fill_us = 256*1000*1000 / (8 * width) / mclk_freq;

            us_video = vpm_us + us_m + us_n + us_p + video_fill_us;

            vlwm = us_video * video_drain_rate/(1000*1000);
            vlwm+=2; // fixed point <= float_point - 1.  Fixes that
            vbs = 128;

            //
            // Video tweaking specific to Canopus
            //
            if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
            {
                //
                // Canopus specific code
                //      
                if (IsNV4_NV04(pMcHalInfo))
                {
                    if(bpp == 32)
                    {
                        if(vlwm > 110)
                            vbs = 64;
                        if(vlwm > (256-64))
                            vbs = 32;
                    }
                    else
                    {
                        if(vlwm > 110)
                            vbs = 64;
                        if(vlwm > (256-27)) // 229
                            vbs = 32;
                    }
                }
                else
                {
                    if(bpp == 32)
                    {
                        if(vlwm > 77)
                            vbs = 64;
                        if(vlwm > (256-64)) // 192
                            vbs = 32;
                    }
                    else
                    {
                        if(vlwm > 135)      // 146)
                            vbs = 64;
                        if(vlwm > 201)
                            vbs = 32;
                    }
                }

            } else {
                //
                // Generic code
                //
                if(vlwm > 256 - 64)
                    vbs = 32;
                else if(vlwm > 146) 
                    vbs = 64;
            }        

            if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
                video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;
            else
                video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;

            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
            us_crt =
              us_video  // Wait for video
              +video_fill_us // Wait for video to fill up
              +cpm_us // CRT Page miss
              +us_m + us_n +us_p // other latency
              ;
              
            clwm = us_crt * crtc_drain_rate/(1000*1000);
            clwm++; // fixed point <= float_point - 1.  Fixes that

            //
            // Video tweaking specific to Canopus
            //
            if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
            {
                if(ram_conf == 0x0003)  
                {
                    clwm -= 32;     // SPECTRA Lite 
                    if(bpp == 32)
                        clwm -= 72; // SPECTRA Lite 
                }
            }

        } 
        else    // !video_enable
        {
        
            crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

            crtpagemiss = 1; // self generating page miss
            crtpagemiss += 1; // MA0 page miss
            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
            us_crt =  cpm_us + us_m + us_n + us_p ;
            clwm = us_crt * crtc_drain_rate/(1000*1000);
            clwm++; // fixed point <= float_point - 1.  Fixes that
    
            //
            // Another concern, only for high pclks so don't do this
            // with video:
            // What happens if the latency to fetch the cbs is so large that
            // fifo empties.  In that case we need to have an alternate clwm value
            // based off the total burst fetch
            //
            us_crt = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
            us_crt = us_crt + us_m + us_n + us_p + (4 * 1000 * 1000)/mclk_freq;
            clwm_mt = us_crt * crtc_drain_rate/(1000*1000); 
            clwm_mt ++;
            if(clwm_mt > clwm)
                clwm = clwm_mt;
                
            //    
            // Finally, a heuristic check when width == 64 bits
            //
            if(width == 1)
            {
                nvclk_fill = nvclk_freq * 8;
                if(crtc_drain_rate * 100 >= nvclk_fill * 102) 
                    clwm = 0xfff; //Large number to fail
                else if (crtc_drain_rate * 100  >= nvclk_fill * 98) 
                {
                    clwm = 512;
                    cbs = 256;
                    us_extra = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
                    //if(crtc_drain_rate * 100 >= nvclk_fill * 102) 
                    //    clwm = 0xfff; //Large number to fail
                }
            }         
        }
    
    
        //
        // Overfill check:
        //

        m1 = clwm + cbs -  512; /* Amount of overfill */

        //
        // Video tweaking specific to Canopus
        //
        if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
        {
            p2 = m1 * pclk_freq / mclk_freq;  // pclk cycles to drain
            p2 = p2 * bpp / 8;                // bytes drained.
        }
        else
        {
            // Generic coding
            //      
            m2us = us_pipe + us_extra;
            p1clk = m2us * pclk_freq/(1000*1000); /* pclk cycles to drain */
            p2 = p1clk * bpp / 8; // bytes drained.
        }   
           
        if((p2 < m1) && (m1 > 0)) 
        {
            fifo->valid = 0;
            found = 0;
            if (video_enable)
            {
                if(cbs <= 32) 
                    found = 1;      // Can't adjust anymore!
                else
                    cbs = cbs/2;    // reduce the burst size
            } 
            else
            {
            
                //
                // Video tweaking specific to Canopus
                //
                if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
                {
                    if(mclk_extra ==0)   
                        found = 1; // Can't adjust anymore!
                    mclk_extra--;
                }
                else
                {         
                    //
                    // Generic coding
                    //   
                    if(mclk_extra ==0)   
                    {
                        if(cbs <= 32) 
                            found = 1;      // Can't adjust anymore!
                        else
                            cbs = cbs/2;    // reduce the burst size
                    } 
                    else 
                        mclk_extra--;
                }            
            }            
        }
        else if (video_enable)
        {

            //
            // Canopus specific code
            //
            if (IsNV4_NV04(pMcHalInfo) && (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS))
            {
                if ((clwm > 621) || (vlwm > 255)) 
                {
                    fifo->valid = 0;
                    found = 0;
                    if(mclk_extra == 0)   
                        found = 1; // Can't adjust anymore!
                    mclk_extra--;
                }
            }
            else
            {
                //
                // Generic coding
                //
                if ((clwm > 511) || (vlwm > 255)) 
                {
                    fifo->valid = 0;
                    found = 0;
                    if(mclk_extra <= 5)   
                        found = 1; // Can't adjust anymore!
                    mclk_extra--;
                }
            }            
            
        } 
        else 
        {  
            if (clwm > 519)
            { // Have some margin
                fifo->valid = 0;
                found = 0;
                if(mclk_extra ==0)   
                    found = 1; // Can't adjust anymore!
                mclk_extra--;
            }
        }
        
        craw = clwm;
        vraw = vlwm;
        //if(clwm < 256) clwm = 256;
        if (clwm < (512-cbs)) 
            clwm = 512-cbs;

        //
        // Video tweaking specific to Canopus
        //
        if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
        {    
            if (IsNV4_NV04(pMcHalInfo))
            {
                if (vlwm < 128)
                {
                    if (bpp == 32)
                    {
                        if (h_size == 1408)
                        {
                            vlwm = 176;
                            vbs = 64;
                        }
                        else if (h_size == 1024)
                        {
                            vlwm = 144;
                            vbs = 64;
                        }
                        else if (h_size < 1024)
                        {
                            vlwm = 128-16;
                        }
                        else
                        {
                            vlwm = 160;
                            vbs = 64;
                        }
                    }
                    else
                        vlwm = 128;
                }
            }
            else
            {
                if (vlwm < 128)
                {
                    if (bpp == 32)  
                    {
                        if (h_size >= 1152)
                        {
                            vlwm = 176;
                            vbs = 64;
                        }
                        else
                            vlwm = 144-16;
                    }
                    else
                        vlwm = 128;
                }

                if ((!video_enable) && (ram_conf == 0x0003))    
                {
                    if (bpp == 32)
                    {
                        if ((h_size >= 1024) && (h_size <= 1408))
                            clwm += 88;     // SPECTRA Lite 
                        else if (h_size == 960)
                            clwm += 48;
                        else
                            clwm += 32;
                    }
                    else if ((bpp == 16) && (h_size == 1920) && (v_size == 1440))
                    {
                        clwm += 8;
                    }
                }

                if (cbs == 256)    
                {
                    if (clwm > 271)    
                        clwm -= 16;
                    if ((!video_enable) && (ram_conf == 0x0003))    
                    {
                        if (clwm > 400)     // SP Lite
                            clwm = 400;
                    }
                    else
                    {
                        if (clwm > 384)     
                            clwm = 384; // 400;
                    }
                }

                // For 1920x1440x32 of Spectra5400PE
                if ((!video_enable) && (ram_conf != 0x0003) && (clwm < 384) &&
                    (h_size == 1920) && (v_size == 1440) && (bpp == 32))
                {
                    clwm = 384;
                }

            }
            
            if(clwm > 511)
                clwm = 511;
        } 
        else
        {    
            //
            // Generic coding
            //
            if(vlwm < 128) 
                vlwm = 128;
        }        
    
    
        if(vlwm < 128) vlwm = 128;
    
        data = (int)(clwm);
        //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
        fifo->crtc1_lwm = data;   fifo->crtc1_burst_size = cbs;
        //    fifo->craw = craw;

        //
        // Video tweaking specific to Canopus
        //
        if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
        {    
            if (IsNV4_NV04(pMcHalInfo))
                data = (int)((vlwm+24));
            else
                data = (int)((vlwm+24));        // 15));

            if (data > 255)
                data = 255;
        }
        else      
        {
            // Generic coding    
            //
            data = (int)((vlwm+15));
            
            // Preset ranges for vlwm and vbs based on calculated vlwm
            if (vlwm > 256-32) 
            {
                data = 256;
                vbs = 32;
            } 
            else if (vlwm > 256-64) 
            {
                data = 256-32+16;
                vbs = 32;
            } 
            else if (vlwm > 256-128) 
            {
                data = 256-64+16;
                vbs = 64;
            } 
            else 
            {
                data = 256-128+16;
                vbs = 128;
            }
            
        }        

        //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
        fifo->video_lwm = data;  
        fifo->video_burst_size = vbs;
    }
}


static
void NV04_dacCalculateArbitration_SMA
(
    PHALHWINFO pHalHwInfo,
    fifo_info *fifo,
    sim_state  *arb
)
{
    PFBHALINFO  pFbHalInfo = pHalHwInfo->pFbHalInfo;

    int data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
    int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
    int nvclk_fill, us_extra, clwm_mt;
    int found, mclk_extra, mclk_loop, cbs, m1;
    int mclk_freq, pclk_freq, nvclk_freq, mp_enable;
    int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;
    int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;
    int craw, vraw, m2us, us_pipe, p1clk, p2;
    int h_size, v_size;
    int ram_conf;
  
  
    fifo->valid = 1;
    pclk_freq = arb->pclk_khz; // freq in KHz
    //mclk_freq = arb->mclk_khz;
    mclk_freq = 100000;
    nvclk_freq = arb->nvclk_khz;
    //pagemiss = arb->mem_page_miss;
    pagemiss = 7;
    //cas = arb->mem_latency;
    cas = 3;
    width = 1;
    video_enable = arb->enable_video;
    color_key_enable = arb->gr_during_vid;
    bpp = arb->pix_bpp;
    align = arb->mem_aligned;
    mp_enable = arb->enable_mp;
    clwm = 0;
    vlwm = 0;

    h_size   = pFbHalInfo->HorizDisplayWidth;
    v_size   = pFbHalInfo->VertDisplayWidth;
    ram_conf = arb->ram_config;

    // NV4 can not support 256 burst
    //if (IsNV4(pDev))
    if (/*IsNV4(pDev)*/ 1)
        cbs = 128;
    else
        cbs = 256;

    pclks = 2;   // lwm detect.

    nvclks = 2;  // lwm -> sync.
    nvclks += 2; // fbi bus cycles (1 req + 1 busy)
    nvclks += 1; // fbi reqsync

    mclks = 5;  // Fifo
    mclks += 3; // MA0 -> MA2
    mclks += 4; // prev burst
    mclks += 2; // ALI arb
    mclks += 1; // pad->out
    mclks += cas; // Cas Latency.
    mclks += 1; // pad in
    mclks += 2; // ALI rd pipe
    mclks += 1; // latch data
    mclks += 1; // fifo load
    mclks += 1; // fifo write
  
  
    if ((video_enable) && (arb->memory_width == 128))
        mclk_extra = 12; // Margin of error
    else    
        mclk_extra = 17; // Margin of error

    nvclks += 2; // fifo sync
    nvclks += 1; // read data
    nvclks += 1; // fbi_rdata
    nvclks += 1; // crtfifo load

    if(mp_enable)
        mclks+=4; // Mp can get in with a burst of 8.
        
    // Extra clocks determined by heuristics
    nvclks += 0;
    pclks += 0;
    found = 0;
    while(found != 1) 
    {
        fifo->valid = 1;
        found = 1;
        mclk_loop = mclks+mclk_extra;
        us_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
        us_n = nvclks*1000*1000 / nvclk_freq;// nvclk latency in us
        us_p = nvclks*1000*1000 / pclk_freq;// nvclk latency in us
        us_pipe = us_m + us_n + us_p;
        us_extra = 0;
        if(video_enable) 
        {
            video_drain_rate = pclk_freq * 2; // MB/s
            crtc_drain_rate = pclk_freq * bpp/8; // MB/s

            vpagemiss = 1; // self generating page miss
            vpagemiss += 1; // One higher priority before

            crtpagemiss = 2; // self generating page miss

            vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;


            if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
                video_fill_us = 256*1000*1000 / 16 / nvclk_freq ;
            else
                video_fill_us = 256*1000*1000 / (8 * width) / mclk_freq;

            us_video = vpm_us + us_m + us_n + us_p + video_fill_us;

            vlwm = us_video * video_drain_rate/(1000*1000);
            vlwm+=2; // fixed point <= float_point - 1.  Fixes that
            vbs = 128;

            //
            // Generic code
            //
            if(vlwm > 256 - 64)
                vbs = 32;
            else if(vlwm > 146) 
                vbs = 64;

            if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
                video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;
            else
                video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;

            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
            us_crt =
              us_video  // Wait for video
              +video_fill_us // Wait for video to fill up
              +cpm_us // CRT Page miss
              +us_m + us_n +us_p // other latency
              ;
              
            clwm = us_crt * crtc_drain_rate/(1000*1000);
            clwm++; // fixed point <= float_point - 1.  Fixes that

        } 
        else    // !video_enable
        {
            crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

            crtpagemiss = 1; // self generating page miss
            crtpagemiss += 1; // MA0 page miss
            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
            us_crt =  cpm_us + us_m + us_n + us_p ;
            clwm = us_crt * crtc_drain_rate/(1000*1000);
            clwm++; // fixed point <= float_point - 1.  Fixes that
    
            //
            // Another concern, only for high pclks so don't do this
            // with video:
            // What happens if the latency to fetch the cbs is so large that
            // fifo empties.  In that case we need to have an alternate clwm value
            // based off the total burst fetch
            //
            us_crt = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
            us_crt = us_crt + us_m + us_n + us_p + (4 * 1000 * 1000)/mclk_freq;
            clwm_mt = us_crt * crtc_drain_rate/(1000*1000); 
            clwm_mt ++;
            if(clwm_mt > clwm)
                clwm = clwm_mt;
                
            //    
            // Finally, a heuristic check when width == 64 bits
            //
            if(width == 1)
            {
                nvclk_fill = nvclk_freq * 8;
                if(crtc_drain_rate * 100 >= nvclk_fill * 102) 
                    clwm = 0xfff; //Large number to fail
                else if (crtc_drain_rate * 100  >= nvclk_fill * 98) 
                {
                    clwm = 512;
                    cbs = 256;
                    us_extra = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
                    //if(crtc_drain_rate * 100 >= nvclk_fill * 102) 
                    //    clwm = 0xfff; //Large number to fail
                }
        }         
        }
    
        //
        // Overfill check:
        //

        m1 = clwm + cbs -  512; /* Amount of overfill */

        // Generic coding
        //      
        m2us = us_pipe + us_extra;
        p1clk = m2us * pclk_freq/(1000*1000); /* pclk cycles to drain */
        p2 = p1clk * bpp / 8; // bytes drained.
           
        if((p2 < m1) && (m1 > 0)) 
        {
            fifo->valid = 0;
            found = 0;
            if (video_enable)
            {
                if(cbs <= 32) 
                    found = 1;      // Can't adjust anymore!
                else
                    cbs = cbs/2;    // reduce the burst size
            } 
            else
            {
            
                //
                // Generic coding
                //   
                if(mclk_extra ==0)   
                {
                    if(cbs <= 32) 
                        found = 1;      // Can't adjust anymore!
                    else
                        cbs = cbs/2;    // reduce the burst size
                } 
                else 
                    mclk_extra--;
            }            
        }
        else if (video_enable)
        {

            //
            // Generic coding
            //
            if ((clwm > 511) || (vlwm > 255)) 
            {
                fifo->valid = 0;
                found = 0;
                if(mclk_extra <= 5)   
                    found = 1; // Can't adjust anymore!
                mclk_extra--;
            }
            
        } 
        else 
        {  
            if (clwm > 519)
            { // Have some margin
                fifo->valid = 0;
                found = 0;
                if(mclk_extra ==0)   
                    found = 1; // Can't adjust anymore!
                mclk_extra--;
            }
        }
        
        craw = clwm;
        vraw = vlwm;
        //if(clwm < 256) clwm = 256;
        if (clwm < (512-cbs)) 
            clwm = 512-cbs;

        //
        // Generic coding
        //
        if(vlwm < 128) 
            vlwm = 128;
    
    
        if(vlwm < 128) vlwm = 128;
    
        data = (int)(clwm);
        //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
        fifo->crtc1_lwm = data;   fifo->crtc1_burst_size = cbs;
        if (data > 511) fifo->valid = 0;
        //    fifo->craw = craw;

        //
        // Video tweaking 
        //
        data = (int)((vlwm+15));
        
        // Preset ranges for vlwm and vbs based on calculated vlwm
        if (vlwm > 256-32) 
        {
            data = 256;
            vbs = 32;
        } 
        else if (vlwm > 256-64) 
        {
            data = 256-32+16;
            vbs = 32;
        } 
        else if (vlwm > 256-128) 
        {
            data = 256-64+16;
            vbs = 64;
        } 
        else 
        {
            data = 256-128+16;
            vbs = 128;
        }
            

        if (data > 255) fifo->valid = 0;

        //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
        fifo->video_lwm = data;  
        fifo->video_burst_size = vbs;
    }
}


typedef struct tagNV04_DacAGPClockEntry
{
    U032 frequency;
    U032 setting;
} NV04_DacAGPClockEntry;

NV04_DacAGPClockEntry NV04_dacAGPClockTable[] =
{
    { 133000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_133MHZ },
    { 126000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_126MHZ },
    { 120000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_120MHZ },
    { 113000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_113MHZ },
    { 106000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_106MHZ },
    { 100000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_100MHZ },
    { 94000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_94MHZ },
    { 87000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_87MHZ },
    { 80000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_80MHZ },
    { 73000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_73MHZ },
    { 66000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ },
    { 0, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ - 1 }
};

//
// HAL stuff
//
 
// forwards
RM_STATUS nvHalDacAlloc_NV04(VOID *);
RM_STATUS nvHalDacFree_NV04(VOID *);
RM_STATUS nvHalDacControl_NV04(VOID *);
RM_STATUS nvHalDacUpdateStartAddress_NV04(VOID *);
RM_STATUS nvHalDacProgramMClk_NV04(VOID *);
RM_STATUS nvHalDacProgramNVClk_NV04(VOID *);
RM_STATUS nvHalDacProgramPClk_NV04(VOID *);
RM_STATUS nvHalDacProgramCursorImage_NV04(VOID *);
RM_STATUS nvHalDacGetRasterPosition_NV04(VOID *);
RM_STATUS nvHalDacValidateArbSettings_NV04(VOID *arg);
RM_STATUS nvHalDacUpdateArbSettings_NV04(VOID *arg);

//
// nvHalDacControl
//
RM_STATUS
nvHalDacControl_NV04(VOID *arg)
{
    PDACCONTROLARG_000 pDacControlArg = (PDACCONTROLARG_000)arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PFBHALINFO  pFbHalInfo;
    PMCHALINFO  pMcHalInfo;
    PVIDEOHALINFO pVideoHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PDACHALINFO_NV04    pDacHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pDacControlArg->id != DAC_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacControlArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pDacHalPvtInfo = (PDACHALINFO_NV04)pHalHwInfo->pDacHalPvtInfo;

    switch (pDacControlArg->cmd)
    {
        case DAC_CONTROL_INIT:
            //
            // Set bus width.
            //
            if (REG_RD_DRF(_PFB, _BOOT_0, _RAM_WIDTH_128) == NV_PFB_BOOT_0_RAM_WIDTH_128_ON)
                pDacHalInfo->InputWidth = 128;
            else
                pDacHalInfo->InputWidth = 64;

            //
            // Initialize video clock.
            //
            pDacHalInfo->VClk = 0;

            //
            // Determine the maximum pixel clock for 8bpp, 16bpp, and 32bpp for this configuration.
            //
            // This will rely on silicon DAC speed, memory bandwidth, and arbitration limits.
            //
            // For now, hardcode the known values.
            //
            if (IsNV4_NV04(pMcHalInfo))
            {
                pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 215000000;
            }
            else if (IsNV5_NV04(pMcHalInfo))
            {
                switch (REG_RD_DRF(_PBUS, _PCI_NV_0, _DEVICE_ID_FUNC))
                {
                    // Std TNT2
                    case NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_VGA:
                    // Std Ultra
                    case NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_ALT1:
                    // Std TNT2 Model64
                    case NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_LC1:
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 300000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 300000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 250000000;
                        break;

                    // Std Vanta
                    case NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_LC0:
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 203000000;
                        break;

                    // Default
                    default:
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 215000000;
                        break;
                } 

                // 
                // If we're running in SMA mode, drop down the limits accordingly
                //
                if (pFbHalInfo->RamType == BUFFER_CRUSH_UMA)
                {
                    //
                    // Determine how much bandwidth we probably have to system memory
                    //
                    if (pProcessorHalInfo->SystemMemoryFreq == 133000000)
                    {
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 300000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 300000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 162000000;
                    }
                    else if (pProcessorHalInfo->SystemMemoryFreq == 100000000)
                    {
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 126000000;
                    }
                    else // (pProcessorHalInfo->SystemMemoryFreq == 66000000)
                    {
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 162000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 162000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp =  85000000;
                    }
                }

            }
            else
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: unknown chip; using pixelclock defaults\n");
                // defaults
                pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 215000000;
            }
            pDacHalInfo->CrtcInfo[0].RegOffset = 0x00000000;

            //
            // All display types allowed.
            //
            pDacHalInfo->CrtcInfo[0].DisplayTypesAllowed =
                DISPLAYTYPEBIT(DISPLAY_TYPE_MONITOR) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_TV) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_DUALSURFACE) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL);

            //
            // No downscaling on nv4 and family...
            // 
            pVideoHalInfo->OverlayMaxDownscale_768  = 1;
            pVideoHalInfo->OverlayMaxDownscale_1280 = 1;
            pVideoHalInfo->OverlayMaxDownscale_1920 = 1;

            break;
        case DAC_CONTROL_LOAD:
        case DAC_CONTROL_UNLOAD:
        case DAC_CONTROL_DESTROY:
        case DAC_CONTROL_UPDATE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

RM_STATUS
nvHalDacAlloc_NV04(VOID *arg)
{
    PDACALLOCARG_000 pDacAllocArg = (PDACALLOCARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacAllocArg->id != DAC_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    return (RM_OK);
}

RM_STATUS
nvHalDacFree_NV04(VOID *arg)
{
    PDACFREEARG_000 pDacFreeArg = (PDACFREEARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacFreeArg->id != DAC_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);    

    return (RM_OK);
}

RM_STATUS
nvHalDacSetStartAddr_NV04(VOID *arg)
{
    PDACSETSTARTADDRARG_000 pDacSetStartAddrArg = (PDACSETSTARTADDRARG_000)arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032 StartAddress = pDacSetStartAddrArg->startAddr;
    U032 prev_bit24, curr_bit24;
    U008 lock, crtc_index, temp;
    U032 CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    //
    // Verify interface revision.
    //
    if (pDacSetStartAddrArg->id != DAC_SET_START_ADDR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacSetStartAddrArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT)pDacSetStartAddrArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;
    
    // Only NV5 needs special treatment regarding PCRTC_START
    if (!IsNV5_NV04(pHalHwInfo->pMcHalInfo))
    {
        REG_WR32(NV_PCRTC_START, StartAddress);
        return (RM_OK);
    }

    //
    // NV5 Bug. Eventhough bit24 should be writable in PCRTC_START, it's not.
    // So, if we need to change its value (i.e. bit24 goes from 0->1 or 1->0),
    // then we'll set/clear bit24 value via the CRE_HEB CRTC reg.
    //
    prev_bit24 = REG_RD32(NV_PCRTC_START) & 0x1000000;
    curr_bit24 = StartAddress & 0x1000000;

    // For NV5, this will properly write bits 23:0
    REG_WR32(NV_PCRTC_START, StartAddress);
    if (prev_bit24 ^ curr_bit24)
    {
        // Save the current CRTC index
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)          // color or mono?
            crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);    // save crtc index
        else
            crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO);     // save crtc index

        // Unlock CRTC extended regs (following is from ReadCRTCLock)
        // lock = ReadCRTCLock(pDev);
        CRTC_READ(NV_CIO_SR_LOCK_INDEX, temp);
        switch (temp)
        {
            case 0x03:
                lock = 0x57;
                break;
            case 0x01:
                lock = 0x75;
                break;
            case 0x00:
                lock = 0x99;
                break;
            default:
                lock = temp;
                break;
        }
        CRTC_WRITE(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE);

        // bit6 corresponds to StartAddress bit24. All other
        // bits were successfully written via PCRTC_START.
        CRTC_READ(NV_CIO_CRE_HEB__INDEX, temp);
        temp &= 0xBF;                           // mask off bit6
        temp |= ((curr_bit24 >> 24) << 6);      // set/clear bit6
        CRTC_WRITE(NV_CIO_CRE_HEB__INDEX, temp);

        // Relock extended regs
        CRTC_WRITE(NV_CIO_SR_LOCK_INDEX, lock);
        // Restore index
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)
            REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index);     // restore crtc index
        else
            REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);      // restore crtc index
    }

    return (RM_OK);
}

//  Read extended CRTC lock register and return corresponding write value
static U008 ReadCRTCLock_NV04
(
    PHALHWINFO pHalHwInfo,
    U032    Head
)
{
    U008 data;

    HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, data, Head);
    switch (data)
    {
        case 0x03:
            data = 0x57;
            break;
        case 0x01:
            data = 0x75;
            break;
        case 0x00:
            data = 0x99;
            break;
    }
    return data;
}

//
// nvHalDacProgramMClk_NV04 - Program MCLK based on the value in pDev->Dac.HalInfo.MClk
//
// This routine uses the value in pDev->Dac.HalInfo.MClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramMClk_NV04(VOID *arg)
{
    PDACPROGRAMMCLKARG_000 pDacProgramMClkArg = (PDACPROGRAMMCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 temp;
    U032 oldMClk;
    U032 oldCyclesPerRefresh;
    U032 oldPeriod;
    U032 newCyclesPerRefresh;
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramMClkArg->id != DAC_PROGRAMMCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramMClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->MPllM;
    nNew = pDacHalInfo->MPllN;
    pNew = pDacHalInfo->MPllP;

    // Program the hardware

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
        REG_WR32
            (
                NV_PRAMDAC_MPLL_COEFF,
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pOld)
            );

        // Read the register to give the PLL enough time to adjust
        temp = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
    }

    // Now we can write the final value
    REG_WR32
        (
            NV_PRAMDAC_MPLL_COEFF,
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pNew)
        );

    // Update the number of clock cycles per memory refresh cycle

    // Determine original frequency from old M, N, P values
    oldMClk  = (nOld * pMcHalInfo->CrystalFreq / (1 << pOld) / mOld);

    // Determine original cycles per refresh
    oldCyclesPerRefresh = REG_RD_DRF( _PFB, _DEBUG_0, _REFRESH_COUNTX64 ) * 64;

    // Determine original refresh period
    oldPeriod = oldCyclesPerRefresh * 1024 / ( oldMClk / 1000 );
    
    // Now using the new MCLK, figure out the new cycles per refresh
    newCyclesPerRefresh = ( pDacHalInfo->MClk / 1000 ) * oldPeriod / 1024;

    // Store the new value
    FLD_WR_DRF_NUM( _PFB, _DEBUG_0, _REFRESH_COUNTX64, newCyclesPerRefresh / 64 );
    
    return status;
}

//
// nvHalDacProgramNVClk_NV04 - Program NVCLK based on the value in pDev->Dac.HalInfo.NVClk
//
// This routine uses the value in pDev->Dac.HalInfo.NVClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramNVClk_NV04(VOID *arg)
{
    PDACPROGRAMNVCLKARG_000 pDacProgramNVClkArg = (PDACPROGRAMNVCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 temp;
    U032 i;
    U032 Head = 0; // NVPLL is on head 0
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramNVClkArg->id != DAC_PROGRAMNVCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramNVClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->NVPllM;
    nNew = pDacHalInfo->NVPllN;
    pNew = pDacHalInfo->NVPllP;

    // Program the hardware

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
        REG_WR32
            (
                NV_PRAMDAC_NVPLL_COEFF,
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pOld)
            );

        // Read the register to give the PLL enough time to adjust
        temp = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
    }

    // Now we can write the final value
    REG_WR32
        (
            NV_PRAMDAC_NVPLL_COEFF,
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pNew)
        );

    // Update NV_PBUS_DEBUG_3 to control data throttling in AGP 4X mode
    i = 0;
    while ( ( pDacHalInfo->NVClk <= NV04_dacAGPClockTable[ i ].frequency ) &&
        ( i < sizeof( NV04_dacAGPClockTable ) / sizeof( NV04_dacAGPClockTable[ 0 ] ) - 1 ) )
    {
        i++;
    }

    FLD_WR_DRF_NUM( _PBUS, _DEBUG_3, _AGP_4X_NVCLK, NV04_dacAGPClockTable[ i ].setting );
    
    return status;
}

//
// nvHalDacProgramPClk_NV04 - Program PCLK based on the value in pDev->Dac.PClk
//
// This routine uses the value in pDev->Dac.PClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramPClk_NV04(VOID *arg)
{
    PDACPROGRAMPCLKARG_000 pDacProgramPClkArg = (PDACPROGRAMPCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032            CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    U032            Head;
    U032            PixelClock;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 Loops;
    U032 IsPllLocked;

    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramPClkArg->id != DAC_PROGRAMPCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramPClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramPClkArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    mNew = pDacHalInfo->VPllM;
    nNew = pDacHalInfo->VPllN;
    pNew = pDacHalInfo->VPllP;

    Head = pDacHalObj->Head;
    PixelClock = pDacProgramPClkArg->PixelClock;

    // Program the hardware

    // Retrieve original coefficients
    // NV11 VPLL2 unfortunately is not at the "expected" offset, so we can't use the HAL macro (DAC_REG_RD32)
    if (Head == 0) 
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL_COEFF );
    }
    else
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL2_COEFF );
    }
    mOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first. 
        if (Head == 0) 
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }
        else
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL2_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }

        // Wait until V PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: VPLL not locked\n");
        }
    }

    // Now we can write the final value
    if (Head == 0) 
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }
    else
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL2_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }

    return status;
}

//
// nvHalDacProgramCursorImage_NV04
//
RM_STATUS
nvHalDacProgramCursorImage_NV04(VOID *arg)
{
    PDACPROGRAMCURSORARG_000 pDacProgramCursorImgArg = (PDACPROGRAMCURSORARG_000) arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032        CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo

    U008    cr31, cr2f;
    U008    lock;

    //
    // Verify interface revision.
    //
    if (pDacProgramCursorImgArg->id != DAC_PROGRAMCURSOR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramCursorImgArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramCursorImgArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    // Unlock CRTC extended regs
    lock = ReadCRTCLock_NV04(pHalHwInfo, pDacHalObj->Head);
    HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);

    // On chips < NV10, the cursor image is always assumed to be a 32x32 image with a color
    // format LE_ROP1R5G5B5. So we ignore the width, height and colorFormat parameters.

    // Mark the Address Space Indicator (bit 7 in NV_CIO_CRE_HCUR_ADDR0_INDEX) 
    // to indicate where the cursor image is based on the param "asi".

    // If the address space indicator says it is in Instance Memory, the startAddr is in terms of 
    // paragraphs instead of bytes. Adjust it to bytes.
    if (pDacProgramCursorImgArg->asi == DAC_ASI_INSTMEM)
    {
        pDacProgramCursorImgArg->startAddr <<= 4;
    }

    // The startAddr is programmed into two config registers as follows:
    // cr2f<0>   = startAddr<24>
    // cr30<6:0> = startAddr<23:17>
    // cr31<7:2> = startAddr<16:11>
    // startAddr<10:0> is assumed to be 0.
    HAL_CRTC_RD(NV_CIO_CRE_HCUR_ADDR2_INDEX, cr2f, CurDacAdr);
    cr2f &= 0xFE;
    cr2f |= (U008)((pDacProgramCursorImgArg->startAddr >> 24) & 0x01);
    HAL_CRTC_WR(NV_CIO_CRE_HCUR_ADDR2_INDEX, cr2f, CurDacAdr);
    
    HAL_CRTC_WR(NV_CIO_CRE_HCUR_ADDR0_INDEX, 
               (U008) ( ((pDacProgramCursorImgArg->startAddr >> 17) & 0x7f) | (pDacProgramCursorImgArg->asi << DEVICE_BASE(NV_CIO_CRE_HCUR_ASI)) ),
               CurDacAdr);
            
    // store startAddr bits 16:11 in cr31 bits 7:2
    HAL_CRTC_RD(NV_CIO_CRE_HCUR_ADDR1_INDEX, cr31, CurDacAdr);
    cr31 &= 0x03; // Clear bits 7:2
    cr31 |= (U008)((pDacProgramCursorImgArg->startAddr >> 9) & 0xfc); // Set the new start address
    HAL_CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, cr31, CurDacAdr);

    // Restore original state of CRTC lock register
    HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, CurDacAdr);
    
    return RM_OK;
}

//
// nvHalDacGetRasterPosition_NV04
//
RM_STATUS
nvHalDacGetRasterPosition_NV04(VOID *arg)
{
    PDACRASTERPOSARG_000 pDacRasterPosArg = (PDACRASTERPOSARG_000) arg;
    PHALHWINFO pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pDacRasterPosArg->id != DAC_RASTERPOS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacRasterPosArg->pHalHwInfo;

    // TO DO: use head number

    // no RL0/RL1 index regs, so return NV_PCRTC_RASTER_POSITION
    pDacRasterPosArg->result = (U016) REG_RD_DRF(_PCRTC, _RASTER, _POSITION);

    return (RM_OK);
}

//
// Attempt to validate the given parameters will work with the current configuration
//       
//  Return 0  if not capable
//  Return ~0 if valid  
//
RM_STATUS
nvHalDacValidateArbSettings_NV04(VOID *arg)
{
    PDACVALIDATEARBSETTINGSARG_000    pDacValidateArbSettingsArg = (PDACVALIDATEARBSETTINGSARG_000) arg;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;

    fifo_info fifo_data;
    sim_state sim_data;
    U032 pclk_limit;

    //
    // Verify interface revision.
    //
    if (pDacValidateArbSettingsArg->id != DAC_VALIDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacValidateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;

    //
    // First we must validate that the incoming vclk is within our DAC range.
    //
    switch (pDacValidateArbSettingsArg->bpp)
    {
        case 8:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp;
            break;
        case 15:
        case 16:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp;
            break;
        case 24:
        case 32:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp;
            break;
        default:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp;
            break;
    }            
    //
    // If incoming clock is greater than DAC range, return failure
    //        
    if (pDacValidateArbSettingsArg->vclk > pclk_limit)
    {
        pDacValidateArbSettingsArg->result = 0;
        return (RM_OK);
    }
        
    //
    // Although the memory arbiter may allow video accesses, we can't exceed
    // the video pipeline's circuit limits
    //
    // Hardcode NV4 to 163MHz.  32bpp video may fail due to arbiter failure
    // even under this rate, but that check comes next.
    //
    if (IsNV4_NV04(pMcHalInfo))
        if ((pDacValidateArbSettingsArg->video_enabled) &&
            (pDacValidateArbSettingsArg->vclk > 163000000))
        {
            pDacValidateArbSettingsArg->result = 0;
            return (RM_OK);
        }
    //
    // Hardcode NV5 to 235MHz.  32bpp video may fail due to arbiter failure
    // even under this rate, but that check comes next.
    //
    if (IsNV5_NV04(pMcHalInfo))
        if ((pDacValidateArbSettingsArg->video_enabled) &&
            (pDacValidateArbSettingsArg->vclk > 235000000))
        {
            pDacValidateArbSettingsArg->result = 0;
            return (RM_OK);
        }
    //
    // Hardcode NV0A 8/16bpp to a 206MHz limit, or in the UMA mode, based on memory speed
    //
    // NOTE This is just for Crush level integrated products
    //
    if (IsNV0A_NV04(pMcHalInfo))
    {
        //
        // Never let Crush enable video above 206MHz
        //
        if ((pDacValidateArbSettingsArg->video_enabled) &&
            (pDacValidateArbSettingsArg->bpp < 32) &&
            (pDacValidateArbSettingsArg->vclk > 206000000))
        {
            pDacValidateArbSettingsArg->result = 0;
            return (RM_OK);
        }

        //
        // Further restrictions for UMA configurations due to limited bandwidth
        //
        if (pFbHalInfo->RamType == BUFFER_CRUSH_UMA)
        {
            // Is this 133MHz memory?
            if (pProcessorHalInfo->SystemMemoryFreq == 133000000)
            {
                if ((pDacValidateArbSettingsArg->bpp == 32) &&
                    (pDacValidateArbSettingsArg->vclk > 70000000))
                {
                    pDacValidateArbSettingsArg->result = 0;
                    return (RM_OK);
                }
            }
            // or 100MHz memory?
            else if (pProcessorHalInfo->SystemMemoryFreq == 100000000)
            {
                if ((pDacValidateArbSettingsArg->bpp < 32) &&
                    (pDacValidateArbSettingsArg->vclk > 110000000))
                {
                    pDacValidateArbSettingsArg->result = 0;
                    return (RM_OK);
                }           

                if ((pDacValidateArbSettingsArg->bpp == 32) &&
                    (pDacValidateArbSettingsArg->vclk > 70000000))
                {
                    pDacValidateArbSettingsArg->result = 0;
                    return (RM_OK);
                }      
            }
            else // we must be using 66MHz memory or lower
            {
                if ((pDacValidateArbSettingsArg->bpp < 32) &&
                    (pDacValidateArbSettingsArg->vclk > 60000000))
                {
                    pDacValidateArbSettingsArg->result = 0;
                    return (RM_OK);
                }      

                if ((pDacValidateArbSettingsArg->bpp == 32) &&
                    (pDacValidateArbSettingsArg->vclk > 53000000))
                {
                    pDacValidateArbSettingsArg->result = 0;
                    return (RM_OK);
                }      
            }
        }
    }

    //
    // Current NV10 video has no limit in this range
    //            
            
    //
    // Build the sim table using current system settings
    //
    sim_data.pix_bpp        = (char) pDacValidateArbSettingsArg->bpp;
    sim_data.enable_video   = pDacValidateArbSettingsArg->video_enabled ? 1 : 0;
    sim_data.enable_mp      = pDacValidateArbSettingsArg->mport_enabled ? 1 : 0;
    sim_data.memory_width   = pDacHalInfo->InputWidth;
    sim_data.mem_latency    = (char)REG_RD_DRF(_PFB, _CONFIG_1, _CAS_LATENCY); //3
    sim_data.mem_aligned    = 1;
    sim_data.mem_page_miss  = (char)(REG_RD_DRF(_PFB, _CONFIG_1, _RAS_RAS) + REG_RD_DRF(_PFB, _CONFIG_1, _READ_TO_PCHG)); //10;
    sim_data.ram_config     = (int)REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_RAMCFG); 
    sim_data.gr_during_vid  = pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
    sim_data.pclk_khz       = pDacValidateArbSettingsArg->vclk / 1000;  // in kHz, not MHz
    sim_data.mclk_khz       = pDacHalInfo->MClk / 1000;     // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;    // in kHz, not MHz

    // 
    // Run the numbers through the ringer
    //
    if (pFbHalInfo->RamType == BUFFER_CRUSH_UMA)
        NV04_dacCalculateArbitration_SMA(pHalHwInfo, &fifo_data, &sim_data);
    else
        NV04_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    
    pDacValidateArbSettingsArg->result = (U032)fifo_data.valid;
    return (RM_OK);
}                
                                                      
RM_STATUS
nvHalDacUpdateArbSettings_NV04(VOID *arg)
{
    PDACUPDATEARBSETTINGSARG_000     pDacUpdateArbSettingsArg = (PDACUPDATEARBSETTINGSARG_000) arg;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;
    PMPHALINFO          pMpHalInfo;
    U032                Head;
    U032                CurDacAdr;

    fifo_info   fifo_data;
    sim_state   sim_data;
    U008        lock;
    U032        M, N, O, P;

    //
    // Verify interface revision.
    //
    if (pDacUpdateArbSettingsArg->id != DAC_UPDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacUpdateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pMpHalInfo = pHalHwInfo->pMpHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacUpdateArbSettingsArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;
    Head = pDacHalObj->Head;

    //
    // Recalculate the current PCLK setting.  We might have changed modes
    // recently.
    //
    M = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _MDIV);
    N = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _NDIV);
    P = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _PDIV);
    O = 1;
    
    pDacHalInfo->VPllM = M;
    pDacHalInfo->VPllN = N;
    pDacHalInfo->VPllO = O;
    pDacHalInfo->VPllP = P;
    pDacHalInfo->VClk  = (N * pMcHalInfo->CrystalFreq / (1 << P) / M);
    
    //
    // Build the sim table using current system settings
    //
    sim_data.pix_bpp        = (char) pDacHalInfo->Depth;
    sim_data.enable_video   = pVideoHalInfo->Enabled ? 1 : 0;
    sim_data.enable_mp      = pMpHalInfo->Enabled ? 1 : 0;
    sim_data.memory_width   = pDacHalInfo->InputWidth;
    sim_data.mem_latency    = (char) REG_RD_DRF(_PFB, _CONFIG_1, _CAS_LATENCY); //3
    sim_data.mem_aligned    = 1;
    sim_data.mem_page_miss  = (char) (REG_RD_DRF(_PFB, _CONFIG_1, _RAS_RAS) + REG_RD_DRF(_PFB, _CONFIG_1, _READ_TO_PCHG)); //10;
    sim_data.ram_config     = (int) REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_RAMCFG); 
    sim_data.gr_during_vid  = pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
    sim_data.pclk_khz       = pDacHalInfo->VClk / 1000;     // in kHz, not MHz
    sim_data.mclk_khz       = pDacHalInfo->MClk / 1000;     // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;    // in kHz, not MHz

    // 
    // Get those new numbers
    //
    if (pFbHalInfo->RamType == BUFFER_CRUSH_UMA)
        NV04_dacCalculateArbitration_SMA(pHalHwInfo, &fifo_data, &sim_data);
    else
        NV04_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    
    //
    // If valid settings found, update the hardware
    //
    if (fifo_data.valid)
    {
        //
        // Set the DAC FIFO Thresholds and burst size
        //
        if (HAL_GETDISPLAYTYPE(Head) == DISPLAY_TYPE_TV)
        {
            REG_WR32(NV_PVIDEO_FIFO_BURST, 3);
            REG_WR32(NV_PVIDEO_FIFO_THRES, fifo_data.video_lwm >> 1);
        }
        else
        {
            // If we are upscaling video, we may not drain fast enough (fifo overflow), since
            // for every pixel from the framebuffer, we've got to send out more than one pixel. 
            // On 64 bit devices at high pixel clocks, the watermark will be set to maximum,
            // to solve the opposite problem (fifo underflow, draining faster than we fill),
            // This makes it more likely to overflow, so make sure we are not set to max 
            // low water mark. (At 16x12 > 60 Hz, we will get set to max lwm, causing us to
            // overflow when scaling the video to full screen.)
            if ((pDacHalInfo->InputWidth == 64) && pVideoHalInfo->Enabled)
            {
                if (fifo_data.video_lwm == 128*2)           // if set to max
                    fifo_data.video_lwm -= 8*2;             // drop down one notch
                // We must also prevent underflow. Letting the CRTC fifo use max bursts can starve video.
                if (fifo_data.crtc1_burst_size == 256)      // if set to max
                    fifo_data.crtc1_burst_size >>= 1;       // drop down on notch
            }

            REG_WR32(NV_PVIDEO_FIFO_THRES, fifo_data.video_lwm >> 1);
            switch (fifo_data.video_burst_size)
            {
                case 128:
                    REG_WR32(NV_PVIDEO_FIFO_BURST, 3);
                    break;

                case 64:
                    REG_WR32(NV_PVIDEO_FIFO_BURST, 2);
                    break;

                case 32:
                    REG_WR32(NV_PVIDEO_FIFO_BURST, 1);
                    break;
            }
        }

        //
        // If the video LWM is maxed out in a 64bit device, make sure to drop the graphics burst down
        // to provide additional bandwidth.
        //
        if ((pDacHalInfo->InputWidth == 64) && pVideoHalInfo->Enabled && ((fifo_data.video_lwm >> 1) == 0x80))
        {        
            // Make sure we've got room to drop
            if ((fifo_data.crtc1_burst_size > 128) && (pDacHalInfo->Depth==8)) 
                fifo_data.crtc1_burst_size >>= 2;
        }            
        
        //
        // Update the CRTC watermarks
        //
        // Unlock CRTC extended regs
        HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, CurDacAdr);
        HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);

        //
        // Set the CRTC watermarks and burst size
        //
        if (HAL_GETDISPLAYTYPE(Head) != DISPLAY_TYPE_TV) // leave alone if TV
        {       
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, (U008) (fifo_data.crtc1_lwm >> 3), CurDacAdr);

            switch (fifo_data.crtc1_burst_size)
            {
                // If the DFP uses shortened blanking, we may run out of time.
                // Limiting burst to 64 prevents starving the fifo when running video.
                // This is not a problem on NV10 because of larger fifo size.
                // We're not checking for shortened blanking, instead we'll always limit burst
                // size for video + DFP. This may reduce performance, but we assume no one cares.
                case 256:
                    if ((HAL_GETDISPLAYTYPE(Head) == DISPLAY_TYPE_FLAT_PANEL) && (pVideoHalInfo->Enabled))
                    {
                        HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 2, CurDacAdr);
                    }
                    else
                        HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 4, CurDacAdr);
                    break;

                case 128:
                    if ((HAL_GETDISPLAYTYPE(Head) == DISPLAY_TYPE_FLAT_PANEL) && (pVideoHalInfo->Enabled))
                    {
                        HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 2, CurDacAdr);
                    }
                    else
                        HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 3, CurDacAdr);
                    break;

                case 64:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 2, CurDacAdr);
                    break;

                case 32:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 1, CurDacAdr);
                    break;

                case 16:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 0, CurDacAdr);
                    break;
            }
            //
            // Manual override of LWM and Burst, if necessary and possible
            //
            if (pDacHalInfo->Enable256Burst && !pVideoHalInfo->Enabled && (pDacHalInfo->InputWidth == 128))
            {
        
                if ((pFbHalInfo->HorizDisplayWidth == 1024)
                    && (pFbHalInfo->VertDisplayWidth == 768)
                    && (pDacHalInfo->Depth == 16)
                    && ((pFbHalInfo->RefreshRate == 75) || (pFbHalInfo->RefreshRate == 85)))
                {
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 4, CurDacAdr);
                    HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x0F, CurDacAdr);
                }            
        
                if ((pFbHalInfo->HorizDisplayWidth == 1024)
                    && (pFbHalInfo->VertDisplayWidth == 768)
                    && (pDacHalInfo->Depth >= 24)
                    && ((pFbHalInfo->RefreshRate == 75) || (pFbHalInfo->RefreshRate == 85)))
                {
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 4, CurDacAdr);
                }            

                if ((pFbHalInfo->HorizDisplayWidth == 1280)
                    && (pFbHalInfo->VertDisplayWidth == 1024)
                    && (pDacHalInfo->Depth >= 24)
                    && ((pFbHalInfo->RefreshRate == 75) || (pFbHalInfo->RefreshRate == 85)))
                {
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 4, CurDacAdr);
                }            
            
            }
        }        
        //
        // Relock if necessary
        //
        if (lock == 0)
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr);
        
        return (RM_OK);
    }
    else
        //
        // No valid setting was found!!!  Either we fail this configuration
        // or we live with the current default settings for this mode.
        //
        return (RM_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\bios.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*   Module: bios.c
*
*   Description:
*       generic bios read/write routines
*
*   Revision History:
*       Original -- 2/99 Jeff Westerinen
*
**************************************************************************************************************/

#include <nvrm.h>
#include <nvhw.h>
#include <nv4_ref.h>
#include <os.h>

#include <bios.h>

RM_STATUS BiosReadBytes(
    PHWINFO pDev,
    U008    buffer[],
    U032    offset,
    U032    size
)
{
    U032 i;

    for (i = 0; i < size; i++)
    {
        buffer[i] = BIOS_RD08(pDev->biosOffset + offset + i);
    }

    return RM_OK;
}

RM_STATUS BiosCalculateSizes(
    const char *format,
    U032       *pPackedSize,
    U032       *pPaddedSize
)
{
    U032 packed_size = 0;
    U032 padded_size = 0;
    char fmt;

    while ((fmt = *format++))
    {
        U032 count;

        count = 0;
        while ((fmt >= '0') && (fmt <= '9'))
        {
            count *= 10;
            count += fmt - '0';
            fmt = *format++;
        }
        if (count == 0) count = 1;

        switch (fmt)
        {
            case 'b':
                packed_size += count * 1;
                padded_size += count * sizeof(bios_U008);
                break;
            case 'w':
                packed_size += count * 2;
                padded_size += count * sizeof(bios_U016);
                break;
            case 'd':
                packed_size += count * 4;
                padded_size += count * sizeof(bios_U032);
                break;
        }
    }

    if (pPackedSize) *pPackedSize = packed_size;
    if (pPaddedSize) *pPaddedSize = padded_size;

    return RM_OK;
}


/*
  Unpack little-endian byte stream data, and expand to an array of 32-bit values.
*/
RM_STATUS BiosUnpackLittleEndianStructure(
    U008 *packedLEData,
    U032 *unpackedData,
    const char *format,
    U032 *fields,
    U032 *unpacked_bytes
)
{
    U032 count;
    U032 unpacked;
    char fmt;

    *fields = 0;
    *unpacked_bytes = 0;

    for ( ; (fmt = *format++); )
    {
        count = 0;
        while ((fmt >= '0') && (fmt <= '9'))
        {
            count *= 10;
            count += fmt - '0';
            fmt = *format++;
        }
        if (count == 0) count = 1;

        while (count--)
        {
            switch (fmt)
            {
                case 'b':
                    unpacked = *packedLEData++;
                    *unpacked_bytes += 1;
                    break;

                case 'w':
                    unpacked =  *packedLEData++;
                    unpacked |= *packedLEData++ << 8;
                    *unpacked_bytes += 2;
                    break;

                case 'd':
                    unpacked =  *packedLEData++;
                    unpacked |= *packedLEData++ << 8;
                    unpacked |= *packedLEData++ << 16;
                    unpacked |= *packedLEData++ << 24;
                    *unpacked_bytes += 4;
                    break;

                default:
                    return RM_ERROR;
            }
            *unpackedData++ = unpacked;
            (*fields)++;
        }
    }

    return RM_OK;
}

RM_STATUS BiosReadStructure(
    PHWINFO     pDev,
    void       *structure,
    U032        offset,
    U032       *ppacked_size,
    const char *format
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 packed_size;
    void *packed_data = 0;
    U032 fields;
    U032 unpacked_bytes;
    U008 small_buffer[256];

    // calculate the size of the data as indicated by its packed format.
    BiosCalculateSizes(format, &packed_size, (U032 *) 0);
    if (ppacked_size)
        *ppacked_size = packed_size;

    if (packed_size <= sizeof(small_buffer))
        packed_data = small_buffer;
    else
    {
        rmStatus = osAllocMem((VOID **) &packed_data, packed_size);
        if (rmStatus != RM_OK)
            goto done;
    }

    rmStatus = BiosReadBytes(pDev, (U008*) packed_data, offset, packed_size);
    if (rmStatus != RM_OK)
        goto done;

    rmStatus = BiosUnpackLittleEndianStructure(packed_data, structure, format, &fields, &unpacked_bytes);

 done:
    if (packed_data && (packed_data != small_buffer))
        osFreeMem(packed_data);

    return rmStatus;
}

RM_STATUS BiosReadArray(
    PHWINFO     pDev,
    void       *buffer,
    U032        offset,
    U032        count,
    U032       *ppacked_size,
    const char *format
)
{
    U032 packed_size, padded_size;
    U032 i;
    
    BiosCalculateSizes(format, &packed_size, &padded_size);

    for (i=0; i<count; i++)
    {
        if (RM_OK != BiosReadStructure(pDev,
                                       (U008*)buffer + (i * padded_size),
                                       offset + (i * packed_size),
                                       (U032 *) 0,
                                       format))
            return RM_ERROR;
    }

    // packed_size will be size of 1 element, what is total?
    if (ppacked_size) *ppacked_size = count * packed_size;

    return RM_OK;
}

U008 BiosRead8(
    PHWINFO  pDev,
    U032     offset
)
{
    bios_U008 data;     // BiosReadStructure expects 'bios' types

    (void) BiosReadStructure(pDev, &data, offset, (U032 *) 0, "b");

    return (U008) data;
}


U016 BiosRead16(
    PHWINFO  pDev,
    U032     offset
)
{
    bios_U032 data;     // BiosReadStructure expects 'bios' types

    (void) BiosReadStructure(pDev, &data, offset, (U032 *) 0, "w");
    return (U016) data;
}

U032 BiosRead32(
    PHWINFO  pDev,
    U032     offset
)
{
    bios_U032 data;     // BiosReadStructure expects 'bios' types

    (void) BiosReadStructure(pDev, &data, offset, (U032 *) 0, "d");

    return (U032) data;
}


RM_STATUS BiosFindString(
    PHWINFO pDev,
    U008 string[],
    U032 *offset,
    U032 string_size
)
{
    int i, j;
    int bios_size;

    bios_size = BIOS_ROM_CODE_SIZE - string_size + 1;
    for (i = 0; i < bios_size; i++)   /* i is offset into bios */
    {
        j = 0;  /* j is offset into search string */

        /* while the bios substring matches the desired string.. */
        while (string[j] == BIOS_RD08(i + j)) j++;

        /* if we're on the null character, we found the string.. */
        if (string[j] == NULL)
        {
            *offset = i;
            return RM_OK;
        }
    }
    return RM_ERROR;
}


RM_STATUS BiosGetMaxExternalPCLKFreq
(
    PHWINFO pDev,
    U032 head,
    U032* freq
)
{
    // Try to find the frequency of an external DAC for the given head
    // The frequency return is in freq(Mz)*100
    RM_STATUS status = RM_OK;
    DEV_HEAD dev_head;
    U032 dev_offset = 0; 
    U032 offset = 0;
    U032 size = 0;

    // Display_Devices offset is found at offset 0x0036
    offset = BiosRead16( pDev, 0x0036 );

    if ( offset == 0 )
    {
        status = RM_ERROR;
    }
    else
    {
        // Read header to check version
        status = BiosReadStructure( pDev, &dev_head, offset, &size, DEV_HEAD_FMT );
        dev_offset = offset + size;

        if ( status == RM_OK )
        {
            if ( dev_head.version >= 0x13 )
            {
                // Start reading DEVICE structures 1 at a time until we hit the end
                BOOL bDone = FALSE;
                int i = 0;

                while ( !bDone )
                {
                    DEV_REC_STRUC dev_rec_struc;

                    status = BiosReadStructure( pDev, &dev_rec_struc, dev_offset, &size, DEV_REC_STRUC_FMT );
                    dev_offset = dev_offset + size;
                    i++;

                    // Check for end 
                    if ( dev_rec_struc.dev_type == DEV_REC_UNUSED_DEV )
                    {
                        status = RM_ERROR;
                        bDone = TRUE;
                    }
                    else if ( ( dev_rec_struc.dev_type & DEV_REC_CRT_DEV_MASK ) == 
                        ( DEV_REC_CRT_DEV_EXTERNAL_DAC | ( head << DEV_REC_HEAD_SHIFT ) ) )
                    {
                        // We found an external DAC
                        *freq = dev_rec_struc.data_rsvr;
                        status = RM_OK;
                        bDone = TRUE;
                    }
                    else if ( i > 128 )
                    {
                        // This is a safety check for a bad BIOS
                        // We should never ever hit this!
                        status = RM_ERROR;
                        bDone = TRUE;
                    }
                }
            }
            else
            {
                status = RM_ERROR;
            }
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\nv15mem.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*	Module: nv15mem.c
*
*	Description:
*		Device-specific memory sizing code, for Nv15 and NV11.
*
*	Revision History:
*		Original -- 1/00 Jeff Westerinen
*
**************************************************************************************************************/

#ifdef NV_PORTABLE

/* "portable" form for use outside resman and by external source customers */
/* look in devinit/portable/ for more details */
#include <nv_portable.h>
#include <nv_ref.h>
#include <nv10_ref.h>
#include <devinit.h>

#else	/* not NV_PORTABLE --> Nvidia internal */

#include <nvrm.h>
#include <nvhw.h>
#include <nv10_ref.h>
#include <os.h>
#include <devinit.h>

#endif

RM_STATUS Nv15MemConfigureClocks
(
    PHWINFO pDev,
    MEM_INIT_TABLE_NV15 memInitTable
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 clk;
    U032 memInitTableIndex;
    U032 M,N,P;
    U032 Head = 0;  // MPLL & NVPLL are on Head 0

    // get the index in the memory init table from scratch register 4
    CRTC_RD(NV_CIO_CRE_SCRATCH4__INDEX, memInitTableIndex, 0);
    memInitTableIndex >>= 4;
    
    // program NVCLK
    clk = memInitTable[memInitTableIndex].NVClk_PLL;
    dacCalcMNP(pDev, Head, clk, &M, &N, &P);
    REG_WR32(
        NV_PRAMDAC_NVPLL_COEFF, 
        DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _MDIV, M) |
            DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _NDIV, N) |
            DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _PDIV, P)
    );
                                        
    // program MCLK -- double the clock if flags indicate DDR memory
    clk = memInitTable[memInitTableIndex].MClk_PLL;
    if (memInitTable[memInitTableIndex].Flags == DDR)
    {
        clk *= 2;
    }
    dacCalcMNP(pDev, Head, clk, &M, &N, &P);
    REG_WR32(
        NV_PRAMDAC_MPLL_COEFF, 
        DRF_NUM(_PRAMDAC, _MPLL_COEFF, _MDIV, M) |
            DRF_NUM(_PRAMDAC, _MPLL_COEFF, _NDIV, N) |
            DRF_NUM(_PRAMDAC, _MPLL_COEFF, _PDIV, P));
            
    return rmStatus;
    
} // end of Nv15MemConfigureClocks()

    
RM_STATUS Nv15MemConfigureMemory
(
    PHWINFO pDev,
    MEM_INIT_TABLE_NV15 memInitTable, 
    U032 SDRSeqTable[], 
    U032 DDRSeqTable[]
)
{
    RM_STATUS rmStatus = RM_OK;
    U032* seqTable;
    U032 memInitTableIndex, initValue;
    U032 memInitDataIndex = 0; 
    U032 seqTableIndex = 0;
    
    
    
    // get the index in the memory init table from scratch register 4
    CRTC_RD(NV_CIO_CRE_SCRATCH4__INDEX, memInitTableIndex, 0);
    memInitTableIndex >>= 4;
    
    // set proper sequence table
    switch (memInitTable[memInitTableIndex].Flags)
    {
        case SDR:
            seqTable = SDRSeqTable;
            break;
            
        case DDR:
            seqTable = DDRSeqTable;
            break;
            
        default:
            return RM_ERROR;
    }
    
    // execute the memory init sequence
    while (seqTable[seqTableIndex] != MEM_INIT_END_OF_SEQUENCE)
    {
        switch (seqTable[seqTableIndex])
        {
            case NV_PFB_PRE:
	            FLD_WR_DRF_DEF(_PFB,_PRE,_CMD,_PRECHARGE);
                break;
                
            case NV_PFB_PAD:
	            FLD_WR_DRF_DEF(_PFB,_PAD,_CKE,_NORMAL);
                break;
                
            case NV_PFB_REF:
	            FLD_WR_DRF_DEF(_PFB,_REF,_CMD,_REFRESH);
                break;
                
            case NV_PFB_EMRS:
                if ((initValue = memInitTable[memInitTableIndex].data[memInitDataIndex++]) != 0xffffffff)
                {
                    REG_WR32(NV_PFB_EMRS, initValue);
                }
                break;
                
            default:
                REG_WR32(seqTable[seqTableIndex], memInitTable[memInitTableIndex].data[memInitDataIndex++]);
                break;
        }
        seqTableIndex++;
    }
    
    return rmStatus;
    
} // end of Nv15MemConfigureMemory()



// end of nv15mem.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\devinit\portable\nv_local.h ===
/*
 * nv_local.h
 *     placeholder for customer/OEM definitions for required
 *     macros for devinit() code.  It is hoped that all customer
 *     changes can be confined to this file.
 */

/*
 * read/write memory
 */

#define REG_WR32(a,d)   
#define REG_RD32(a)       0
#define REG_WR08(a,d)   
#define REG_RD08(a)       0

#define PRMCIO_REG_WR32(b,o,d)   
#define PRMCIO_REG_RD32(b,o)     0

#define CRTC_WR(i,d)    
#define CRTC_RD(i,d)       0


#ifdef DEBUG
#include <stdout.h>
#define DBG_PRINT_STR(s)  fprintf(stderr, (s))
#else
#define DBG_PRINT_STR(s)  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\nv04mtbl.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*****************************************************************************
*
*	Header: nv04mtbl.c
*
*	Description:
*		This file contains the initialization code used to POST an NV4 device.
*	The init code was taken from the BIOS source file, nvinit.inc.
*
*	Revision History:
*		Original -- 2/99 Jeff Westerinen
*
*
*	Steps to convert nvinit.inc to initcode.h
*
*		1.	enclose data in: U032 Nv04_bmp_GenInitTbl[] = { <data> }; 
*		2.	convert ; to //
*		3.  remove all db, dw, and dd, and add comma separaters
*		4.  convert IFDEF to #ifdef
*		5.	convert ELSE to #else
*		6.	convert ENDIF to #endif
*		7.	convert OR \ to |
*		8.	convert <num>h to 0x<num>
*		9 .	format -- at least line up data to left indent
*		10. comment out all table delimiters
*		11. remove bmp_ExtraInitTbl
*
******************************************************************************/

#include <nv4_ref.h>
#include <nvrm.h>
#include <bios.h>

U032 Nv04_bmp_GenInitTbl[] = 
{

	//IFNDEF NVIDIA_RESET
	//        // Reset engines
	//        INIT_ZM_REG
	//        NV_PMC_ENABLE      // NV 32 bit address.
	//        DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
	//           DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
	//                DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED)
	//#endif // NVIDIA_RESET

	// Comment to fix assembler bug
	INIT_RESET,
	NV_PMC_ENABLE,      // NV 32 bit address.
	// Off state
	DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED),
		DRF_DEF(_PMC,_ENABLE,_PFB,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED),

	//#ifdef NVIDIA_RESET
	//        INIT_RESET
	//#else // NVIDIA_RESET
	//        // Reset engines
	//        INIT_ZM_REG
	//        NV_PMC_ENABLE      // NV 32 bit address.
	////#endif // NVIDIA_RESET
	//        DRF_DEF(_PMC,_ENABLE,_PFB,_ENABLED) |
	//                DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
	//                DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
	//                DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED)

	// Comment to fix assembler bug

#ifdef DISABLE_SIDEBAND

	INIT_NV_REG,                 // Write register with Mask
	NV_PEXTDEV_BOOT_0,               // Strap Register for Memory
	0xFFFFFBFF,                  // AND Mask
	0x00000C00,                  // OR Mask
#else 
	INIT_NV_REG,                 // Write register with Mask
	NV_PEXTDEV_BOOT_0,               // Strap Register for Memory
	0xFFFFFBFF,                  // AND Mask
	0x00000800,                  // OR Mask

#endif  // DISABLE_SIDEBAND

	// Barry's memory fix for AGP
	INIT_ZM_REG,
	NV_PBUS_DEBUG_0,

	////        0E0F0000h    
	////        04050000h   // 7/23/98

	0x20F0000,    // 11/13/98 - New value from Dave Reed for 110Mhz MCLK

	// Comment to fix assembler bug

	// 13,500,000 MHz - MCLK = M:11:0B, N:163:A3, P:4:04 LOG2P:2 50 MHz
	// 14,318,180 MHz - MCLK = M:14:0E, N:196:C4, P:4:04 LOG2P:2 50 MHz
	INIT_PLL,
	NV_PRAMDAC_NVPLL_COEFF,       // Actually, this is NVPLL (680500)
#ifdef INTEL 
	8500,        // 85Mhz
#else                      
	9000,        // 90Mhz
#endif 


	// Comment to fix assembler bug

	// 13,500,000 MHz - MCLK = M:11:0B, N:163:A3, P:4:04 LOG2P:2 50 MHz
	// 14,318,180 MHz - MCLK = M:14:0E, N:196:C4, P:4:04 LOG2P:2 50 MHz
	INIT_PLL,
	NV_PRAMDAC_MPLL_COEFF,

#ifdef INTEL 
	10000,   // 100Mhz
#else                  
	11000,   // 110Mhz
#endif 


	// Comment to fix assembler bug

	// NV_PFB_CONFIG_0
	INIT_ZM_REG,
	NV_PFB_CONFIG_0,      // NV 32 bit address.
	DRF_DEF(_PFB,_CONFIG_0,_RESOLUTION,_DEFAULT) |
		DRF_DEF(_PFB,_CONFIG_0,_PIXEL_DEPTH,_DEFAULT) |
		DRF_DEF(_PFB,_CONFIG_0,_TILING,_DISABLED) |
		DRF_DEF(_PFB,_CONFIG_0,_TILING_DEBUG,_DISABLED),

	// Comment to fix assembler bug

	// VCLK.
	// 13,500,000 MHz - VCLK = M:12:0C, N:064:40, P:2:02 LOG2P:1 36.00 MHz
	// 14,318,180 MHz - VCLK = M:14:0E, N:141:8D, P:4:04 LOG2P:2 36.05 MHz
	INIT_PLL,
	NV_PRAMDAC_VPLL_COEFF,        // NV 32 bit address.
	3600,
	//        00001400Ch
	//        000028D0Eh

	// Comment to fix assembler bug

	// NV_PFB_GREEN_0
	INIT_ZM_REG,
	NV_PFB_GREEN_0,   // NV 32 bit address.
	DRF_DEF(_PFB,_GREEN_0,_LEVEL,_VIDEO_ENABLED),   // NV 32 bit data.

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PFB_DEBUG_0,
#ifdef IKOS
	//        20005000h            // IKOS value - turns on slow clock
	0x20000100,          // Per RussM on 10/14
#else   // IKOS                   
	0x20001D00,            // 7/23
#endif 

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PFB_CONFIG_1,
	0xC1016293,          // This value works for about everything

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PFB_RTL,
	0,

	// Comment to fix assembler bug

	// Per Dave Reed
	// Setup more optimal PCI interface
	INIT_ZM_REG,
	NV_PBUS_DEBUG_1,
	DRF_DEF(_PBUS,_DEBUG_1,_PCIM_THROTTLE,_DISABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIM_CMD,_SIZE_BASED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_PCIM_AGP,_IS_AGP) |			// !!!!!!!!!!!
		DRF_DEF(_PBUS,_DEBUG_1,_AGPM_CMD,_LP_ONLY) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WRITE,_0_CYCLE) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_2_1,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RETRY,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RD_BURST,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WR_BURST,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_EARLY_RTY,_ENABLED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RMAIO,_DISABLED) |		// !!!!!!!!!!!
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_CPUQ,_ENABLED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_SPARE1,_ZERO) |
		DRF_DEF(_PBUS,_DEBUG_1,_FBI_DIFFERENTIAL,_DISABLED) |	// !!!!!!!!!!!
		DRF_DEF(_PBUS,_DEBUG_1,_SPARE2,_ONE),

	// Comment to fix assembler bug

	INIT_COMPUTE_MEM,             // Compute frame buffer size

	//=============================================================
	//       Memory Dependent Initialization Table.
	//=============================================================

#ifdef  NV5
	INIT_NV_REG,                 // Write register with Mask
	NV_PFB_BOOT_0,               // Strap Register for Memory
	0xFFFFFF00,                  // AND Mask
	0x00000024,                  // OR Mask - 32MB SDRAM
	//        00000001Fh                  // OR Mask - 16MB SDRAM
#else               
	INIT_NV_REG,                 // Write register with Mask
	NV_PFB_BOOT_0,               // Strap Register for Memory
	0xFFFFFFFF,                  // AND Mask
	0x00000000,                  // OR Mask
#endif     
	INIT_MEM_RESTRICT,
	0x18,                        // Strip to memory type (AND MASK)
	0x18,                        // Compare value = SDRAM

	INIT_ZM_REG,
	NV_PFB_CONFIG_1,

#ifdef INTEL 
	0xC1016293,          // This value works for about everything
#else 
	0x31012132,                  // Set DRAM value
#endif   

	INIT_RESUME,                 // No more SDRAM stuff
	     
	INIT_MEM_RESTRICT,
	0x18,                        // Strip to memory type (AND MASK)
	0x10,                        // Compare value = SDRAM

	INIT_ZM_REG,
	NV_PFB_CONFIG_1,

#ifdef  INTEL 
	0xC1016293,          // This value works for about everything
#else 
	0x31012132,                  // Set DRAM value
#endif 

	INIT_RESUME,                 // No more SDRAM stuff

	//------------------------------------------------------------
	//       Final Initialization Tables.
	//------------------------------------------------------------
	//
	//       Max allocated Final init space is
	//       INIT_ADDITION_REG_SPACE. This includes the FinalInit
	//       table and the FinalInit tables for all the FinalMem
	//       inits. OEM will utilize the BMP to maximize the
	//       utilization of addition table space.
	//

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PRAMDAC_PLL_COEFF_SELECT,   // NV 32 bit address.
	0x0000500,                   // PROG_MPLL & PROG_NVPLL

	// Comment to fix assembler bug

	// tbo
	INIT_ZM_REG,
	NV_PBUS_DEBUG_2,
	0x00011F0,               // Per Jill S. -  5/12

	INIT_ZM_REG,
	NV_PBUS_DEBUG_3,
	NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES,
	// tbo

	// Comment to fix assembler bug

	// Force real mode window default state to off
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	NV_CIO_CRE_RMA__INDEX,0x00,0x00,

	// Make sure hsync and vsync are on (we only set them in DPMS calls)
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x1A,0x00,0x3F,

	// Comment to fix assembler bug

	// Boot with TV off, and set for NTSC if it was on.
	// Also set horizontal pixel adjustment
	// Sets pixel format to VGA
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x28,0x00,0x00,

	// Comment to fix assembler bug
#ifdef NV5 
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x21,0x00,0xFA,         // Force Lock register to 0FAh
#endif  // NV5                        

	// Clear scratch to default state
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x2C,0x30,0x00,         // Use this line to use straps

	//        02Ch,000h,010h          // Use this line to force NTSC Boot
	//        02Ch,000h,020h          // Use this line to force PAL Boot
	//        02Ch,000h,000h         // Use this line to force NOTV Boot
	                   
	// Float DDC pins high (not touched during a mode set or save/restore state)
	//        INIT_INDEX_IO
	//        CRTC_INDEX_COLOR
	//        03Fh,000h,033h

	// Disable DDC
	//        INIT_INDEX_IO
	//        CRTC_INDEX_COLOR
	//        03Fh,000h,032h

	// Comment to fix assembler bug

	INIT_DONE
	//        EOL //END OF LIST

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\nv10mem.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*	Module: nv10mem.c
*
*	Description:
*		Device-specific memory sizing code, for Nv10.
*
*	Revision History:
*		Original -- 6/99 Jeff Westerinen
*
**************************************************************************************************************/

#ifdef NV_PORTABLE

/* "portable" form for use outside resman and by external source customers */
/* look in devinit/portable/ for more details */
#include <nv_portable.h>
#include <nv_ref.h>
#include <nv10_ref.h>
#include <devinit.h>

#else	/* not NV_PORTABLE --> Nvidia internal */

#include <nvrm.h>
#include <nvhw.h>
#include <nv10_ref.h>
#include <os.h>
#include <devinit.h>

#endif

RM_STATUS Nv10MemConfigureClocks
(
    PHWINFO pDev,
    MEM_INIT_TABLE_NV10 memInitTable
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 clk;
    U032 memInitTableIndex;
    U032 M,N,P;
    U032 Head = 0; // straps are on head 0; likewise NVPLL, MPLL
/*
        ; Get straps, and turn AL into an index to the table
        ;                       
        mov     al,NV_CIO_SCRATCH4_INDEX        ; CR3C
        call    ReadCRTCReg                     ; Read current value
        shr     ax,12                           ; bits 0:3
*/
    // get the index in the memory init table from scratch register 4
    CRTC_RD(NV_CIO_CRE_SCRATCH4__INDEX, memInitTableIndex, Head);
    memInitTableIndex >>= 4;
    
/*
        ; Size of config structure
        mov     cl, SIZEOF MEM_INIT_VALS        ; Get the size of the config struct
        mul     cl
        
        ; Now point at the right structure with CS:SI
        mov     di, offset bmp_MemInitTbl
        add     di,ax                           ; Add offset into init table

        ; Program NVCLK first, since we've always done it that way
        ;

        mov     ax, cs:[di].MEM_INIT_VALS._NVClk_PLL    ; Get MCLK value
        push    bx      ; BX returns data from this call that we won't use
        call    CalcMNP                         ; Get MNP parameters
        pop     bx
        
        ;       AL = M parameter
        ;       AH = N parameter
        ;       DL = P parameter
        mov     esi,NV_PRAMDAC_NVPLL_COEFF
        call    ProgPLL                         ; Program the PLL's
*/
    // program NVCLK
#ifdef FORCE_NVCLOCKMHZ
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_WARNINGS, "NVRM: Nv10MemConfigureClocks: forcing NVCLK Mhz to ", FORCE_NVCLOCKMHZ);
    clk = FORCE_NVCLOCKMHZ * 100;	// Clock MHz * 100
#else
    clk = memInitTable[memInitTableIndex].NVClk_PLL;
#endif
// Use dacCalcMFP instead of DevinitCalcMNP,
// since the devinit version seems to be returning wrong values.
//    REG_WR32(NV_PRAMDAC_NVPLL_COEFF, DevinitCalcMNP(pDev, &clk));
    dacCalcMNP(pDev, Head, clk, &M, &N, &P);
    REG_WR32(NV_PRAMDAC_NVPLL_COEFF, DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _MDIV, M) |
             DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _NDIV, N) |
             DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _PDIV, P));
                                        
/*
        ; Now, get the sequence table and the MCLK value
        ;
        mov     ax, cs:[di].MEM_INIT_VALS._MClk_PLL     ; Get MCLK value
        test    cs:[di].MEM_INIT_VALS._Flags, 01h        ; SDR or DDR?
        jz      @got_sdr2
        shl     ax,1                            ; Double MCLK on DDR
@got_sdr2:
        
        ; Here, ax = the decimal MCLK value
                
        push    bx      ; BX returns data from this call that we won't use
        call    CalcMNP                         ; Get MNP parameters
        pop     bx
        
        ;       AL = M parameter
        ;       AH = N parameter
        ;       DL = P parameter
        mov     esi,NV_PRAMDAC_MPLL_COEFF
        call    ProgPLL                         ; Program the PLL's
*/
    // program MCLK -- double the clock if flags indicate DDR memory
#ifdef FORCE_MCLOCKMHZ
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_WARNINGS, "NVRM: Nv10MemConfigureClocks: forcing MCLK Mhz to ", FORCE_MCLOCKMHZ);
    clk = FORCE_MCLOCKMHZ * 100;	// Clock MHz * 100
#else
    clk = memInitTable[memInitTableIndex].MClk_PLL;
#endif

    if (memInitTable[memInitTableIndex].Flags == DDR)
    {
        clk *= 2;
    }
    
    // use the RM kernel (dacCalcMFP()) to calculate M, N, and P values
    dacCalcMNP(pDev, Head, clk, &M, &N, &P);
    REG_WR32(
        NV_PRAMDAC_MPLL_COEFF, 
        DRF_NUM(_PRAMDAC, _MPLL_COEFF, _MDIV, M) |
            DRF_NUM(_PRAMDAC, _MPLL_COEFF, _NDIV, N) |
            DRF_NUM(_PRAMDAC, _MPLL_COEFF, _PDIV, P)
    );
    return rmStatus;
    
} // end of Nv10MemConfigureClocks()

    
RM_STATUS Nv10MemConfigureMemory
(
	PHWINFO pDev,
    MEM_INIT_TABLE_NV10 memInitTable, 
    U032 SDRSeqTable[], 
    U032 DDRSeqTable[]
)
{
	RM_STATUS rmStatus = RM_OK;
    U032* seqTable;
    U032 memInitTableIndex, initValue;
    U032 memInitDataIndex = 0; 
    U032 seqTableIndex = 0;
    
    U032 Head = 0;    
    
/*
        call    FullCpuOn               ; Turn on full CPU access
        
        ; Configure memory type by way of straps
        ;
        
        ; Get straps, and turn AL into an index to the table
        ;                       
        mov     al,NV_CIO_SCRATCH4_INDEX        ; CR3C
        call    ReadCRTCReg                     ; Read current value
;        shr    ah,4                            ; Move bits to AH[3:0]
;        shr    ax,8                            ; Move AH->AL
        shr     ax,12                           ; bits 0:3
        
;        mov     esi,NV_PEXTDEV_BOOT_0           ; Get strapping bits
;        NV_DOS_GET      esi
;        and     ax, NV_PEXTDEV_BOOT_0_STRAP_RAMCFG      ; Keep RAMCFG bits
;        shr     ax, RAMCFG_SHIFT
*/
    // get the index in the memory init table from scratch register 4
    CRTC_RD(NV_CIO_CRE_SCRATCH4__INDEX, memInitTableIndex, Head);
    memInitTableIndex >>= 4;
    
/*
        ; Size of config structure
        mov     cl, SIZEOF MEM_INIT_VALS        ; Get the size of the config struct
        mul     cl
        
        ; Now point at the right structure with CS:SI
        mov     di, offset bmp_MemInitTbl
        add     di,ax                           ; Add offset into init table
        
        mov     bx, offset SDR_Sequence_Table
        test    cs:[di].MEM_INIT_VALS._Flags, 01h        ; SDR or DDR?
        jz      @got_sdr

        ; We have DDR memory - turn on FBI_DIFFERENTIAL
        ; 8/25/99
        ;
        mov     esi,NV_PBUS_DEBUG_1
        NV_DOS_GET      esi                     ; Read register
        and     eax,NOT (NV_PBUS_DEBUG_1_FBI_DIFFERENTIAL)
        or      eax, NV_PBUS_DEBUG_1_FBI_DIFFERENTIAL_ENABLED
        NV_DOS_PUT      esi                     ; Re-write register
        
        mov     bx, offset DDR_Sequence_Table
@got_sdr: 
*/
    // set proper sequence table
    switch (memInitTable[memInitTableIndex].Flags)
    {
        case SDR:
            seqTable = SDRSeqTable;
            break;
            
        case DDR:
            seqTable = DDRSeqTable;
            break;
            
        default:
            return RM_ERROR;
    }
    
/*
        add     di,6                            ; Skip Flags, MCLK, NVCLK values
        
        ; CS:BX = pointer to sequence list
        ; CS:DI = pointer to sequence data (MEM_INIT_VALS)
@next_sequence:
        mov     esi, cs:[bx]                    ; Get Sequence
        cmp     esi, 0FFFFFFFFh                 ; End of sequence?
        je      @end_sequence
        
        cmp     esi,NV_PFB_PRE                  ; Precharge command?
        jne     @f  
        
        mov     eax, NV_PFB_PRE_CMD_PRECHARGE   ; Issue precharge command
        jmp     @set_pfb_reg
@@:
        cmp     esi,NV_PFB_PAD
        jne     @f            
        
        mov     eax, NV_PFB_PAD_CKE_NORMAL      ; Enable
        jmp     @set_pfb_reg
@@:
        cmp     esi,NV_PFB_REF                  ; Recharge command?
        jne     @f  
        
        mov     eax, NV_PFB_REF_CMD_REFRESH     ; Issue Refresh command
        jmp     @set_pfb_reg
@@:
        cmp     esi,NV_PFB_EMRS                 ; EMRS command?
        jne     @f  
        
        mov     eax, cs:[di]                    ; Read data value
        cmp     eax, 0FFFFFFFFh                 ; Is it a -1? (SDR)
        jne     @f                              ; Nope - program value
        
        add     di, 4                           ; Skip data value
        jmp     @skip_val                       ; Yep - skip the data value
@@:      
        mov     eax, cs:[di]                    ; Read data value
        add     di, 4                           ; Next data value
        
@set_pfb_reg:   
        NV_DOS_PUT      esi     
@skip_val:
        add     bx, 4                           ; Next sequence value
        jmp     @next_sequence
                
@end_sequence:
*/

    // execute the memory init sequence
    while (seqTable[seqTableIndex] != MEM_INIT_END_OF_SEQUENCE)
    {
        switch (seqTable[seqTableIndex])
        {
            case NV_PFB_PRE:
	            FLD_WR_DRF_DEF(_PFB,_PRE,_CMD,_PRECHARGE);
                break;
                
            case NV_PFB_PAD:
	            FLD_WR_DRF_DEF(_PFB,_PAD,_CKE,_NORMAL);
                break;
                
            case NV_PFB_REF:
	            FLD_WR_DRF_DEF(_PFB,_REF,_CMD,_REFRESH);
                break;
                
            case NV_PFB_EMRS:
                initValue = memInitTable[memInitTableIndex].data[memInitDataIndex++];
                if (initValue != 0xffffffff)
                {
                    REG_WR32(NV_PFB_EMRS, initValue);
                }
                break;
                
            default:
                REG_WR32(seqTable[seqTableIndex], memInitTable[memInitTableIndex].data[memInitDataIndex++]);
                break;
        }
        seqTableIndex++;
    }
    
    return rmStatus;
    
} // end of Nv10MemConfigureMemory()

RM_STATUS Nv10MemChipPreInit
(
	PHWINFO pDev
)
{
	RM_STATUS rmStatus = RM_OK;
    U016 crystalVal, ramcfgVal, data;
    U032 Head = 0;
/*
        mov     esi,NV_PEXTDEV_BOOT_0           ; Get strapping bits
        NV_DOS_GET      esi
        
        test    eax, NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180
        jz      @freq_13
                 
        ; Bit set - we're on 14.318 reference frequency
        mov     ax,((NV_CIO_SCRATCH4_14MHZ SHL 8) OR (NV_CIO_SCRATCH4_INDEX))
        jmp     @f
        
@freq_13: 
        mov     ax,((NV_CIO_SCRATCH4_13MHZ SHL 8) OR (NV_CIO_SCRATCH4_INDEX))
@@:                                   
        call    WriteCRTCReg            ; Write the unlock   
        
        mov     esi,NV_PEXTDEV_BOOT_0           ; Get strapping bits
        NV_DOS_GET      esi
        and     ax, NV_PEXTDEV_BOOT_0_STRAP_RAMCFG ; Keep RAMCFG bits 5:2
        shl     ax, RAMCFG_SHIFT                ; Shift into bits 7:4
        mov     bh,al                           ; Put in BH a while
        mov     al,NV_CIO_SCRATCH4_INDEX        ; CR3C
        call    ReadCRTCReg                     ; Read current value
        or      ah,bh                           ; Or in new values
        call    WriteCRTCReg                    ; Write CR3C
*/
    // pack and save away the strapping values into scratch register 4
    crystalVal = (U016)REG_RD_DRF(_PEXTDEV,_BOOT_0,_STRAP_CRYSTAL);
    ramcfgVal = (U016)REG_RD_DRF(_PEXTDEV,_BOOT_0,_STRAP_RAMCFG);
    data = (U008)(ramcfgVal << 4 & 0x00f0) | (crystalVal & 0x000f);
    CRTC_WR(NV_CIO_CRE_SCRATCH4__INDEX, data, Head);

    return rmStatus;
    
    
} // end of Nv10MemChipPreInit()

RM_STATUS Nv10MemComputeMemory
(
	PHWINFO pDev
)
{
	RM_STATUS rmStatus = RM_OK;
	U032 testAddress;
    
/*
        call    FullCpuOn               ; Turn on full CPU access
        
        ; Ensure refresh is on
        mov     eax,NV_PFB_REFCTRL_VALID_1  ; NV_PFB_REFCTRL
        mov     esi,NV_PFB_REFCTRL
        NV_DOS_PUT      esi             ; Set Memory Config register
        
        ;
        ; Check for RAM width
        ;           
*/
    // ensure refresh is on
	FLD_WR_DRF_DEF(_PFB,_REFCTRL,_VALID,_1);
    
/*
        ; Write to Frame Buffer.
        mov     esi,(NV_PDFB OR NV_PDFB_ACCESS)
        add     si,1Ch                  ; Write to NV_PDFB+1Ch
        mov     eax,'NV10'              ; Write value to test.
        mov     edx, eax                ; Save write value
        
        NV_DOS_PUT      esi
        
        add     si,20h                  ; Write to NV_PDFB+3Ch
        xor     eax,eax                 ; Write 0's to drive pads low
                                                           
        NV_DOS_PUT      esi
        
        sub     si,20h                  ; Move back to offset 1Ch
        
        ; Read 2 bytes at 0MB + 0x1C (Lower 16 bits of 128-bit word)
        NV_DOS_GET      esi                            
        cmp     eax,edx                 ; Is EAX = 'NV5A'?            
                                                    
        je      @GoodBusSize            ; Yep - it's 128-bit bus
                                                
        ; Set PFB_CFG with correct BUS size                                   
        mov     esi,NV_PFB_CFG
        NV_DOS_GET      esi             ; Get Memory Config register
        and     eax,0FFFFFFEFh          ; Clear RAM width bit to make 64-bit
        NV_DOS_PUT                      ; Write it back out
        
@GoodBusSize:                         
*/
    // check for RAM width as follows:
    //   1.  write non-zero test word to 0x0000001c
    //   2.  write out a zero word to 0x0000003c
    //   3.  attempt to read lower word at 0x0000001c
    //   4.  if not successful, change bus width to 64 bits
    //   5.  otherwise, bus width remains at default of 128 bits
    FB_WR32(0x0000001c, 'NV10');
    FB_WR32(0x0000003c, 0x00000000);
    if (FB_RD16(0x0000001c) != '10')
    {
        FLD_WR_DRF_DEF(_PFB,_CFG,_BUS,_64);
        //Nv05MemLatchMemConfig(pDev);
    }
    
/*
        ;
        ; Get memory size now
        ;
        
        ; Default value in PFB_CFG is largest memory buffer supported
        ;
        mov     esi,NV_PFB_CSTATUS
        NV_DOS_GET      esi             ; Get Memory Size register
        
        ; EAX now has the largest memory size supported, as calc'd by the HW
        shr     eax,1                   ; Make next size down - this will
                                        ; force a write at the MB just above
                                        ; the next smaller size.
        mov     esi,(NV_PDFB OR NV_PDFB_ACCESS)
        add     esi,eax                 ; Add in max size
                           
        mov     eax,'NVDA'              ; Write value to test.
        mov     edx, eax                ; Save write value
                           
        NV_DOS_PUT      esi             ; Write test value to memory
        add     si,20h                  ; Write another address w/diff data
        xor     eax,eax
        NV_DOS_PUT      esi             ; Force pad's low
        sub     si,20h                  ; Return to original address
        NV_DOS_GET      esi             ; Read it back        

        cmp     eax,edx                 ; Read back our original write value?
        je      @Exit                   ; Correct memory size is already set.
                                                              
        mov     esi,NV_PFB_CFG
        NV_DOS_GET      esi             ; Get Memory Config register
                                                     
        and     ah,0EFh                 ; Clear EXT_BANK to 1 bank
                                                                
        NV_DOS_PUT      esi             ; Set Memory Config register
@Exit:
*/    
    // check for RAM width as follows:
    //   1.  get what the HW thinks is the largest memory size supported
    //   2.  write test word to 1 byte beyond half the largest
    //   3.  write zero word to 16 bytes beyond half 
    //   4.  attempt to read the original test word
    //   5.  if successful, memory size is already correct;
    //       otherwise, adjust memory size
    testAddress = REG_RD32(NV_PFB_CSTATUS) / 2;
    FB_WR32(testAddress, 'NVDA');
    FB_WR32(testAddress + 0x10, 0x00000000);
    if (FB_RD32(testAddress) != 'NVDA')
    {
        FLD_WR_DRF_DEF(_PFB,_CFG,_EXTBANK,_0);
    }
    
	return rmStatus;

} // end of Nv10MemComputeMemory()


// end of nv10mem.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\nv05mem.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*	Module: nv05mem.c
*
*	Description:
*		Device-specific memory sizing code, for NV5.
*
*	Revision History:
*		Original -- 5/99 Jeff Westerinen
*
**************************************************************************************************************/

#ifdef NV_PORTABLE

/* "portable" form for use outside resman and by external source customers */
/* look in devinit/portable/ for more details */
#include <nv_portable.h>
#include <nv_ref.h>
#include <nv4_ref.h>
#include <devinit.h>

#else	/* not NV_PORTABLE --> Nvidia internal */

#include <nvrm.h>
#include <nvhw.h>
#include <nv4_ref.h>
#include <os.h>
#include <devinit.h>

#endif

extern bmpMemInitData Nv05_bmp_MemInitTbl[];
extern U032 Nv05_bmp_ScrambleTbl[];

RM_STATUS Nv05MemResizeMemory
(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 i, data;

	// TO DO: is this necessary?
    // turn on full CPU access
	//...
     
    /*
        ; For UMA mode, we don't configure the memory
        ;
        mov     esi,NV_PFB_BOOT_0
        NV_DOS_GET      esi             ; Get Memory Config register
        test    ah,01h                  ; Is bit 8 set?
        jnz     @Exit                   ; Yep - UMA is on! Nada to configure!
        ;
        ; For UMA mode above.
        ;
    */
    // only size memory if UMA is disabled
    if (REG_RD_DRF(_PFB,_BOOT_0,_UMA) == NV_PFB_BOOT_0_UMA_DISABLE)
    {
	    // enable refresh for memory sizing
        FLD_WR_DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED);

        // TO DO: remove this when KevinM says OK
        // scramble the RAM from the table
        for (i = 0; i < 8; i++)
        {
            REG_WR32(NV_PFB_SCRAMBLE(i), Nv05_bmp_ScrambleTbl[i]);
        }
    
        // configure memory type by way of straps as follows:
        //   1.  get the strapping value from NV_PEXTDEV_BOOT_0
        //   2.  use that value as an index into the memory init table
        //   3.  the first member of the selected table element configures NV_PFB_BOOT_0
        //   4.  the second member of the selected table element configures PFB_CONFIG_1
        i = REG_RD_DRF(_PEXTDEV,_BOOT_0,_STRAP_RAMCFG);
        data = (REG_RD32(NV_PFB_BOOT_0) & 0xFFFFFFC0) | Nv05_bmp_MemInitTbl[i].PFB_BOOT_0_value;
        REG_WR32(NV_PFB_BOOT_0, data);
    
        // scramble the RAM, if indicated
    /*    
            ; Here, look for need to scramble RAM
            test    cl,SCRAMBLE_RAM                 ; Bit says to scramble the RAM?
            jz      @no_scramble
    
            ; Scramble the RAM according to the RAM table defined
            ; earlier.
            ;
            mov     di, offset bmp_ScrambleTbl      ; Point at table of RAM values
            mov     esi,NV_PFB_SCRAMBLE_RAM_0       ; Get strapping bits
            mov     cx,8                            ; Do 8 locations
    @@: 
            mov     eax,cs:[di]                     ; Read value 1
            NV_DOS_PUT      esi                     ; Write it out
            add     di,4                            ; Next DWORD
            add     esi,4                           ; Next DWORD
            loop    @b        
                                  ; and loop again
            ; Enable the scramble
            mov     esi,NV_PFB_CONFIG_0             ; Access Scramble RAM
            NV_DOS_GET      esi        
            or      eax, NV_PFB_CONFIG_0_SCRAMBLE_ACTIVE
            NV_DOS_PUT      esi        
                   
    @no_scramble:
    */
        if (Nv05_bmp_MemInitTbl[i].PFB_CONFIG_1_value == SCRAMBLE_RAM)
        {
    // TO DO: enable this code when Kevin M says OK
    #if 0
            for (i = 0; i < 8; i++)
            {
                REG_WR32(NV_PFB_SCRAMBLE_RAM_0 + (i * 4), Nv05_bmp_ScrambleTbl[i]);
            }
    #endif    
            FLD_WR_DRF_DEF(_PFB,_CONFIG_0,_SCRAMBLE,_ACTIVE);
        }
      
        // toggle latency bit to latch in the config, as follows:
        //   1. Clear to CL=2 and the SPECIAL32 bit or default SPECIAL32 value
        //   2. Set back to CL=3 
    /*
            pop     ecx                             ; Get flags back
            and     cl,SPECIAL_32                   ; Keep only SPECIAL_32 bit
            shl     ecx,20                          ; put in proper bit location
        
            ; Toggle PFB_CONFIG_1 CAS latency bit to generate MRS cycle.
            mov     esi,NV_PFB_CONFIG_1             ; Get Config1 bits
            NV_DOS_GET      esi
        
            and     eax,0FF8FFFFEh                  ; Clear to CL=2 and the SPECIAL32 bit
            or      eax,ecx                         ; Or default SPECIAL32 value in.
            NV_DOS_PUT      esi                     ; Write it back out
        
            or      al,01h                          ; Set back to CL=3
            NV_DOS_PUT      esi                     ; Write it back out
    */
        data = (REG_RD32(NV_PFB_CONFIG_1) & 0xFF8FFFFE) | ((Nv05_bmp_MemInitTbl[i].PFB_CONFIG_1_value & SPECIAL_32) << 20);
        REG_WR32(NV_PFB_CONFIG_1, data);
        data |= 0x00000001;
        REG_WR32(NV_PFB_CONFIG_1, data);
    
        // check for RAM width as follows:
        //   1.  assume width is 128 bits
        //   2.  write out a 128 bit test data word
        //   3.  attempt to read lower word
        //   4.  if not successful, change bus width to 64 bits
        //   5.  otherwise, bus width remains at default of 128 bits
        for (i = 0; i < 4; i++)
        {
            FB_WR32(i * 4, 'NV5A');
        }    
        if (FB_RD16(0x0000000C) != '5A')
        {
            FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_WIDTH_128,_OFF);
        }
    
        // determine the memory size -- default amount is 32Meg
        if (REG_RD_DRF(_PFB,_BOOT_0,_RAM_AMOUNT) == NV_PFB_BOOT_0_RAM_AMOUNT_32MB)
        {
            // write at 16Meg+1 to determine 32 or 16 Meg
            FB_WR32(0x01000000, 'NV5B');
            if (FB_RD32(0x01000000) == 'NV5B')
            {
                // read at 0 to determine if it wrapped on VANTA
                FB_WR32(0x00000000, 'A5VN');
                if (FB_RD32(0x00000000) != 'A5VN')
                {
                    // 16MB detected, so change config
                    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_16MB);
                }
            }
            else
            {
                // 16MB detected, so change config
                FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_16MB);
            }
        }
        else
        {
            // test for 16 Meg
            if (REG_RD_DRF(_PFB,_BOOT_0,_RAM_AMOUNT) == NV_PFB_BOOT_0_RAM_AMOUNT_16MB)
            {
                // write at 8Meg+1 to determine 16Meg or less
                FB_WR32(0x00800000, 'NV5C');
                if (FB_RD32(0x00800000) != 'NV5C')
                {
                    // write at 4Meg+1 to determine 8 or 4 Meg
                    FB_WR32(0x00400000, 'NV5D');
                    if (FB_RD32(0x00400000) == 'NV5D')
                    {
                        // 8MB detected, so change config
                        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_8MB);
                    }
                    else
                    {
                        // 4MB detected, so change config
                        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_4MB);
                    }
                }
            }
            else
            {
                // write at 4Meg+1 to determine 8 or 4 Meg
                FB_WR32(0x00400000, 'NV5D');
                if (FB_RD32(0x00400000) == 'NV5D')
                {
                    // 8MB detected, so change config
                    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_8MB);
                }
                else
                {
                    // 4MB detected, so change config
                    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_4MB);
                }
            }
        }
    }    
    
	// TO DO: is this necessary?
	// turn off full CPU access
	//...

	return rmStatus;

} // end of DevinitResizeSgram()

VOID Nv05MemLatchMemConfig
(
    PHWINFO pDev
)
{
    // save the original CAS latency
    U032 latency = REG_RD_DRF(_PFB,_CONFIG_1,_CAS_LATENCY);
    
    // toggle the LSB 1-0-1
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3);
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_2);
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3);
    
    // restore original CAS latency
    FLD_WR_DRF_NUM(_PFB,_CONFIG_1,_CAS_LATENCY,latency);
    
} // end of Nv04MemLatchMemConfig()


// end of nv04mem.c


// end of nv05mem.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\nv05mtbl.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*****************************************************************************
*
*	Header: nv05mtbl.c
*
*	Description:
*		This file contains the initialization code used to POST an NV5 device.
*	The init code was taken from the BIOS source file, nvinit.inc.
*
*	Revision History:
*		Original -- 5/99 Jeff Westerinen
*
*
*	Steps to convert nvinit.inc to initcode.h
*
*		1.	enclose data in: U032 Nv04_bmp_GenInitTbl[] = { <data> }; 
*		2.	convert ; to //
*		3.  remove all db, dw, and dd, and add comma separaters
*		4.  convert IFDEF to #ifdef
*		5.	convert ELSE to #else
*		6.	convert ENDIF to #endif
*		7.	convert "OR \" and "OR " to |
*		8.	convert <num>h to 0x<num>
*		9 .	format -- at least line up data to left indent
*		10. comment out all table delimiters
*		11. remove bmp_ExtraInitTbl
*
******************************************************************************/

#include <nv4_ref.h>
#include <nvrm.h>
#include <bios.h>

bmpMemInitData Nv05_bmp_MemInitTbl[] = 
/*
{
	{
		0x24,
		0x00
	},

	{
		0x28,
		0x00
	},

	{
		0x24,
		0x01
	},

	{
		0x1F,
		0x00
	},

	{
		0x0F,
		0x00
	},

	{
		0x17,
		0x00
	},

	{
		0x06,
		0x00
	},

	{
		0x00,
		0x00
	}
};
*/
{
    {
        // 0000 - 2Mx32 64Mbit 16/32mb
        0x00000024,             // bits 0-2 vary
        0x00000000              // Special 32 field
    },
    
    {
        // 0001 - 4Mx16 64Mbit 32mb
        0x00000028,        
        0x00000000              // Special 32 field
    },

    {
        // 0010 - 1Mx32 32Mbit 32mb + special32
        0x00000024,
        SPECIAL_32              // Flag field
    },

    {
        // 0011 - 1Mx16 16Mbit 8/16mb
        0x0000001F,
        0x00000000              // Special 32 field
    },
    
    {
        // 0100 - 512Kx32 16Mbit (2 bank) 4/8/16mb 
        0x0000000F,  
        0x00000000              // Special 32 field
    },
    
    {
        // 0101 - 512Kx32 16Mbit (4 bank) 4/8/16mb
        0x00000017,
        0x00000000              // Special 32 field
    },
    
    {
        // 0110 - 4Mx16 64Mbit 16MB (looks like 32MB) - "hokey rams"
        0x00000028,               
        SCRAMBLE_RAM            // Flag field
    },
                
    {
        // 0111 - whatever 0110 used to be... some 8mbit 4/8mb type
        0x00000006,             // This looks like 8mbit - 4/8mb
        0x00000000              // Flag field          
    }
};
        
U032 Nv05_bmp_ScrambleTbl[] = 
{
    0x03020100,     // SCRAMBLE_RAM_0 value
    0x07060504,     // SCRAMBLE_RAM_1 value
    0x0B0A0908,     // SCRAMBLE_RAM_2 value
    0x0F0E0D0C,     // SCRAMBLE_RAM_3 value
    0x03020100,     // SCRAMBLE_RAM_4 value
    0x07060504,     // SCRAMBLE_RAM_5 value
    0x0B0A0908,     // SCRAMBLE_RAM_6 value
    0x0F0E0D0C      // SCRAMBLE_RAM_7 value
};
        
U032 Nv05_bmp_GenInitTbl[] = 
{

	INIT_RESET,
	NV_PMC_ENABLE,      // NV 32 bit address.
	// Off state
	DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED),
	DRF_DEF(_PMC,_ENABLE,_PFB,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED),

	INIT_NV_REG,                          // Write register with Mask
	NV_PEXTDEV_BOOT_0,                    // Strap Register Update
	//
	//  +---------------------------------- OVERWRITE_ENABLED
	//  |++++++++++++++++------------------ UNUSED
	//  |||||||||||||||||+----------------- FB32MB
	//  ||||||||||||||||||++--------------- PCI_DEVID[1:0]
	//  ||||||||||||||||||||+-------------- RESERVED_11
	//  |||||||||||||||||||||+------------- AGP_SBA_DISABLED
	//  ||||||||||||||||||||||+------------ AGP_4X_DISABLED
	//  |||||||||||||||||||||||++---------- TVMODE[1:0]
	//  |||||||||||||||||||||||||+--------- CRYSTAL_14318180
	//  ||||||||||||||||||||||||||++++----- RAMCFG[3:0]
	//  ||||||||||||||||||||||||||||||+---- SUB_VENDOR_BIOS              
	//  |||||||||||||||||||||||||||||||+--- PCI_AD_NORMAL
	//  VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
	//  3322222222221111111111
	//  10987654321098765432109876543210
	//11111111111111111111111111111111b    // AND Mask  
	0xFFFFFFFF,    
	//10000000000000000000100000000000b    // OR  Mask      
	0x80000800,
	                               
	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PBUS_DEBUG_PRIV_ASRC,
	//        00000000h                  // 2/26/99 per Quang - fixes TV shimmer
#ifdef ULTRA
	0xF0F000F0,                  // 4/07/99 per Dave Reed
#else                                                 
	0x00000000,                   // 4/07/99 per Dave Reed
#endif  // ULTRA                                       
                                          
	// Barry's memory fix for AGP
	INIT_ZM_REG,
	NV_PBUS_DEBUG_0,
	//        01020101h    // 1/29/99 - Per Dave Reed
#ifdef ULTRA
	0x01000105,           // 4/07/99 - Per Dave Reed
#else              
	0x01020101,           // 4/07/99 - Per Dave Reed
#endif  // ULTRA     

	INIT_ZM_REG,                 // Write with mask
	NV_PBUS_DEBUG_CTRIM_0,
	//       0F00BBA7h                   // 8x6 & 10x7 panels (as of 3/22/99)
	0x0800BBA7,                   // 04/07/99

	INIT_ZM_REG,                 // Write with mask
	NV_PBUS_DEBUG_CTRIM_1,
	//       0h                          // as of 3/22/99
	0x0EFE00000,                   // 04/07/99
	                                 
	INIT_ZM_REG,                 // Write with mask
	NV_PBUS_DEBUG_CTRIM_2,
	//       0F8C98200h                  // 8x6 & 10x7 panels (as of 3/22/99)
	0x088C98200,                  // 04/07/99
	                                
	INIT_ZM_REG,                 // Write with mask
	NV_PBUS_DEBUG_CTRIM_3,
	//       0FF988AA9h                  // prior to 3/22/99
#ifdef ULTRA
	0x0FF988DDC,                  // 4/07/99
#else                                    
	0x0FF988AA9,                  // 4/07/99
#endif  // ULTRA                          
                           
	// Comment to fix assembler bug

	// 13,500,000 MHz - MCLK = M:11:0B, N:163:A3, P:4:04 LOG2P:2 50 MHz
	// 14,318,180 MHz - MCLK = M:14:0E, N:196:C4, P:4:04 LOG2P:2 50 MHz
	INIT_PLL,
	NV_PRAMDAC_NVPLL_COEFF,       // Actually, this is NVPLL (680500)
#ifdef VANTA
	10000,       // 100Mhz
#else   // VANTA
#ifdef  ULTRA
	15000,       // 150Mhz
#else   // ULTRA
	12500,       // 125Mhz
#endif  // ULTRA           
#endif  // VANTA

	// In all of these cases, Model64 (/DM64) will use the TNT2 settings

	// Comment to fix assembler bug

	// 13,500,000 MHz - MCLK = M:11:0B, N:163:A3, P:4:04 LOG2P:2 50 MHz
	// 14,318,180 MHz - MCLK = M:14:0E, N:196:C4, P:4:04 LOG2P:2 50 MHz
	INIT_PLL,
	NV_PRAMDAC_MPLL_COEFF,
#ifdef VANTA
	12500,   // 125Mhz
#else   // VANTA
#ifdef ULTRA
	18300,   // 183Mhz
#else   // ULTRA
	15000,   // 150Mhz
#endif  // ULTRA
#endif  // VANTA

	// Comment to fix assembler bug

	// NV_PFB_CONFIG_0
	INIT_ZM_REG,
	NV_PFB_CONFIG_0,      // NV 32 bit address.
	DRF_DEF(_PFB,_CONFIG_0,_RESOLUTION,_DEFAULT) |
		DRF_DEF(_PFB,_CONFIG_0,_PIXEL_DEPTH,_DEFAULT) |
		DRF_DEF(_PFB,_CONFIG_0,_TILING,_DISABLED) |
		DRF_DEF(_PFB,_CONFIG_0,_TILING_DEBUG,_DISABLED),

	// Comment to fix assembler bug

	// VCLK.
	// 13,500,000 MHz - VCLK = M:12:0C, N:064:40, P:2:02 LOG2P:1 36.00 MHz
	// 14,318,180 MHz - VCLK = M:14:0E, N:141:8D, P:4:04 LOG2P:2 36.05 MHz
	INIT_PLL,
	NV_PRAMDAC_VPLL_COEFF,        // NV 32 bit address.
	3600,
	//        00001400Ch
	//        000028D0Eh

	// Comment to fix assembler bug

	// NV_PFB_GREEN_0
	INIT_ZM_REG,
	NV_PFB_GREEN_0,   // NV 32 bit address.
	DRF_DEF(_PFB,_GREEN_0,_LEVEL,_VIDEO_ENABLED),   // NV 32 bit data.

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PFB_DEBUG_0,
#ifdef IKOS
	0x20000100,          // Per RussM on 10/14
#else   // IKOS                   
	//      20001D00h            // 7/23
#ifdef ULTRA
	0x20002D00,            // Per Dave R on 4/7/99
#else
	0x20002500,            // Per Dave R on 4/7/99
#endif  // ULTRA 
#endif 

	// Comment to fix assembler bug

	// Default Value - pre-memory config
	INIT_ZM_REG,
	NV_PFB_CONFIG_1,
	0x41016293,          // This value works for about everything

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PFB_RTL,
	0x00000000,

	// Comment to fix assembler bug

	// Per Dave Reed
	// Setup more optimal PCI interface
	INIT_ZM_REG,
	NV_PBUS_DEBUG_1,
	DRF_DEF(_PBUS,_DEBUG_1,_PCIM_THROTTLE,_DISABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIM_CMD,_SIZE_BASED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_PCIM_AGP,_IS_AGP) |			// !! undefined for NV5
		DRF_DEF(_PBUS,_DEBUG_1,_AGPM_CMD,_LP_ONLY) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WRITE,_0_CYCLE) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_2_1,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RETRY,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RD_BURST,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WR_BURST,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_EARLY_RTY,_ENABLED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RMAIO,_DISABLED) |		// !! undefined for NV5
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_CPUQ,_ENABLED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_SPARE1,_ZERO) |				// !! exactly wrong
		DRF_DEF(_PBUS,_DEBUG_1,_FBI_DIFFERENTIAL,_DISABLED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_SPARE2,_ONE),					// !! exactly wrong
		DRF_DEF(_PBUS,_DEBUG_1,_SPARE2,_ZERO),

	// Comment to fix assembler bug

                               
	INIT_COMPUTE_MEM,             // Compute frame buffer size
          
	//=============================================================
	//       Memory Dependent Initialization Table.
	//=============================================================

	INIT_NV_REG,                 // Write register with Mask
	NV_PFB_BOOT_0,               // Strap Register for Memory
	0xFFFFFFFF,                  // AND Mask
	0x00000000,                  // OR Mask

	// Final value for running after sizing
	INIT_NV_REG,                 // Write register with Mask
	NV_PFB_CONFIG_1,
	0x00F00000,                  // AND Mask
	0x41016293,          // This value works for about everything
        
	//        INIT_MEM_RESTRICT
	//        018h                        // Strip to memory type (AND MASK)
	//        018h                        // Compare value = SDRAM
	//        
	//        INIT_RESUME                 // No more SDRAM stuff
	//                                         
	//        INIT_MEM_RESTRICT
	//        018h                        // Strip to memory type (AND MASK)
	//        010h                        // Compare value = SDRAM
	//             
	//        INIT_RESUME                 // No more SDRAM stuff
	        
	//------------------------------------------------------------
	//       Final Initialization Tables.
	//------------------------------------------------------------
	//
	//       Max allocated Final init space is
	//       INIT_ADDITION_REG_SPACE. This includes the FinalInit
	//       table and the FinalInit tables for all the FinalMem
	//       inits. OEM will utilize the BMP to maximize the
	//       utilization of addition table space.
	//

	// Comment to fix assembler bug

	//public  bmp_FinalInit
	//bmp_FinalInit:
	INIT_ZM_REG,
	NV_PRAMDAC_PLL_COEFF_SELECT,   // NV 32 bit address.
	0x00000500,                   // PROG_MPLL & PROG_NVPLL

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PBUS_DEBUG_2,
	0x000001F0,                // Per K^2 -  4/09/99
	//#ifdef OLD_BOARDS                                  
	//       000011F0h               // Per Jill S. -  5/12/98
	//#else   // OLD_BOARDS
	//       000001F1h               // Per Dave R. -  3/24/99
	//#endif  // OLD_BOARDS
                                               
	INIT_ZM_REG,
	NV_PBUS_DEBUG_3,
#ifdef VANTA
	NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_94MHZ | NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES,
#else   // VANTA
#ifdef  ULTRA
	NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_133MHZ | NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES,
#else   // ULTRA
	NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_120MHZ | NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES,
#endif  // ULTRA
#endif  // VANTA

	// Comment to fix assembler bug

	// Force real mode window default state to off
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	//NVRM_ACCESS,0x000,0x000,				// !! undefined
	NV_CIO_CRE_RMA__INDEX,0x000,0x000,

	// Make sure hsync and vsync are on (we only set them in DPMS calls)
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x01A,0x000,0x03F,
                       
	// Comment to fix assembler bug

	// Boot with TV off, and set for NTSC if it was on.
	// Also set horizontal pixel adjustment
	// Sets pixel format to VGA
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x028,0x000,0x000,

	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x033,0x000,0x000,         // Clear slave registers

	// Comment to fix assembler bug
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x021,0x000,0x0FA,         // Force Lock register to 0FAh
        
   // Clear TV device selection
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	//        02Bh,000h,000h        // 
	0x02B,0x007,0x000,         // Amask to retain Strap or override
        
        // Replace the above line with one of the following
        // to override the default settings for TV
	//       02Bh,000h,000h         // Force NTSC_M (Std)
	//       02Bh,000h,001h         // Force NTSC_J (BT869 Only)
	//       02Bh,000h,002h         // Force PAL-M (NTSC w/PAL encoding) (BT869 Only)
	//       02Bh,000h,003h         // Force PAL_BDGHI (Std)
	//       02Bh,000h,004h         // Force PAL-N (BT869 Only)
	//       02Bh,000h,005h         // Force PAL-NC (BT869 Only)
                                                           
	// Clear scratch to default state
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x02C,0x000,0x000,         // Clear all scratch bits for default
        
        // Old values for TV override selection
	//        02Ch,030h,000h         // Use this line to use straps
	//        02Ch,000h,010h          // Use this line to force NTSC Boot
	//        02Ch,000h,020h          // Use this line to force PAL Boot
	//        02Ch,000h,000h         // Use this line to force NOTV Boot
                                                       
        // Float DDC pins high (not touched during a mode set or save/restore state)
	//        INIT_INDEX_IO
	//        CRTC_INDEX_COLOR
	//        03Fh,000h,033h

        // Disable DDC
	//        INIT_INDEX_IO
	//        CRTC_INDEX_COLOR
	//        03Fh,000h,032h

	 // Comment to fix assembler bug

	INIT_DONE
	//        EOL //END OF LIST
};

// raw BMP table for TNT2 Pro 
U032 Nv05Pro_bmp_GenInitTbl[] = 
{
    0x00000065, 0x00000200, 0x01010100, 0x01110100,
    0x0000006e, 0x00101000, 0xffff4c43, 0x8000018c,
    0x0000007a, 0x000010e0, 0xf0f000f0, 0x0000007a,
    0x00001080, 0x04040000, 0x0000007a, 0x000010b0,
    0x0800bba7, 0x0000007a, 0x000010b4, 0xefe00000,
    0x0000007a, 0x000010b8, 0x88c98200, 0x0000007a,
    0x000010bc, 0xff988aa9, 0x00000079, 0x00680500,
    0x00003778, 0x00000079, 0x00680504, 0x00003fac,

    0x0000007a, 0x00100200, 0x00001114, 0x00000079,
    0x00680508, 0x00000e10, 0x0000007a, 0x001000c0,
    0x00000000, 0x0000007a, 0x00100080, 0x20002800,
    0x0000007a, 0x00100204, 0x41016293, 0x0000007a,
    0x00100300, 0x00000000, 0x0000007a, 0x00001084,
    0x000057c8, 0x00000063, 0x0000006e, 0x00100000,
    0xffffffff, 0x00000000, 0x0000006e, 0x00100204,
    0x00f00000, 0x42216293, 0x0000007a, 0x0068050c,

    0x00000500, 0x0000007a, 0x00001088, 0x000011f0,
    0x0000007a, 0x0000108c, 0x000000e1, 0x00000078,
    0x000003d4, 0x00000038, 0x00000000, 0x00000000,
    0x00000078, 0x000003d4, 0x0000001a, 0x00000000,
    0x0000003f, 0x00000078, 0x000003d4, 0x00000028,
    0x00000000, 0x00000000, 0x00000078, 0x000003d4,
    0x00000033, 0x00000000, 0x00000000, 0x00000078,
    0x000003d4, 0x00000021, 0x00000000, 0x000000fa,

    0x00000078, 0x000003d4, 0x0000002b, 0x00000007,
    0x00000000, 0x00000078, 0x000003d4, 0x0000002c,
    0x00000000, 0x00000000, 0x00000071
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\devinit.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*   Module: devinit.c
*
*   Description:
*       Device POST code.
*
*   Revision History:
*       Original -- 2/99 Jeff Westerinen
*
**************************************************************************************************************/


#ifdef NV_PORTABLE

/* "portable" form for use outside resman and by external source customers */
/* look in devinit/portable/ for more details */
#include <nv_portable.h>
#include <nv_ref.h>
#include <nv4_ref.h>
#include <devinit.h>

#else   /* not NV_PORTABLE --> Nvidia internal */

#include <nvrm.h>
#include <nvhw.h>
#include <nv4_ref.h>
#include <os.h>
#include <devinit.h>

#endif

// TO DO: this is a hack to avoid osallocmem() from an isr (the TMDS bip3 interpret is called during modeset)
static BIOS_BIP3_TABLES bip3_static_tables;


// ***** MAIN ENTRY POINT FOR DEVICE INITIALIZATIONS *****

RM_STATUS DevinitInitializeDevice
(
    PHWINFO pDev,
    PHWREG  externalBiosImage,
    BOOL   *pBiosUsedToInit
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 lock, offset;
    PHWREG tempBiosAddr;
    BMP_Control_Block bmpCtrlBlk;
    U032 Head = 0;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: initializing device...\n");

    // enable VGA subsystem
    FLD_WR_DRF_DEF(_PBUS,_PCI_NV_21,_VGA,_ENABLED);

    // Unlock CRTC extended regs
    CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

    // determine current strap crystal frequency (in Hz), if it has not already been set
    if (pDev->Chip.HalInfo.CrystalFreq == 0)
    {
        if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K)
            pDev->Chip.HalInfo.CrystalFreq = 13500000;
        else if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180)
            pDev->Chip.HalInfo.CrystalFreq = 14318180;
    }

    // be pessimistic
    *pBiosUsedToInit = FALSE;

    // use the external bios image, if present
    tempBiosAddr = biosAddr;
    if (externalBiosImage)
    {
        biosAddr = externalBiosImage;
    }

    // pull in the BMP control block
    rmStatus = DevinitGetBMPControlBlock(pDev, &bmpCtrlBlk, &offset);

    // process the initialization code
    if (rmStatus == RM_OK)
    {
        // use the BIOS image to init
        if ((bmpCtrlBlk.CTL_Version >= BMP_INIT_TABLE_VER_5) &&
            (bmpCtrlBlk.CTL_Flags >= BMP_INIT_TABLE_SUBVER_0x10))
        {
            // initialize the device using BIP/3 code
            rmStatus = DevinitProcessBip3(pDev);
            if (rmStatus == RM_OK)
                *pBiosUsedToInit = TRUE;
        }
        else
        {
            // initialize the device using BIP/2 code
            rmStatus = DevinitProcessBip2(pDev, offset, bmpCtrlBlk, pBiosUsedToInit);
        }
    }
    else
    {
        // use the static tables to init
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: cannot find BMP Control Block, using static tables...\n");
        rmStatus = DevinitProcessStaticTables(pDev);
    }

    // restore original biosAddr
    biosAddr = tempBiosAddr;

    // restore original extended CRTC register lock value
    if (lock == 0)
    {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, Head);
    }

    // enable shadowing of BIOS
    FLD_WR_DRF_DEF(_PBUS,_PCI_NV_20,_ROM_SHADOW,_ENABLED);

    if (rmStatus == RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ...device initialization succeeded\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ...device initialization *** FAILED ***\n");
    }

    return rmStatus;

} // end of DevinitInitializeDevice()

RM_STATUS DevinitGetBMPControlBlock
(
    PHWINFO             pDev,
    BMP_Control_Block  *pControlBlock,
    U032               *offset
)
{
    RM_STATUS rmStatus = RM_ERROR;
    int i;

    // attempt to find the init info in the BIOS
    for (i = 0; i < MAX_BIOS_SCAN-3; i++)
        if (BIOS_RD32(i) == CTRL_BLK_ID)
            break;

    if (i < MAX_BIOS_SCAN-3)
    {
        int so;

        // going to recalc offset, so make sure it is zero now since the
        //   following read must happen at exactly 'i'
        pDev->biosOffset = 0;

        rmStatus = BiosReadStructure(pDev,
                                     (U008*) pControlBlock,
                                     i,
                                     (U032 *) 0,
                                     BMP_CONTROL_BLOCK_FMT);
        if (rmStatus != RM_OK)
            goto done;

        // The BMP tables have offsets with them relative to the beginning
        //   of the rom.  If the rom has been relocated, these offsets will
        //   be bogus.
        //   Calculate an 'extra offset' to compensate and save it in the pDev
        //
        //   This happens on Mac roms when the devinit portion is relocated
        //   from its normal location in the pc bios image to the end of the
        //   openforth image.
        //

        for (so = i-2; so >= 0; so--)
            if ((BIOS_RD08(so) == 0x55) && (BIOS_RD08(so+1) == 0xAA))
                break;
        if (so >= 0)
            pDev->biosOffset = so;

        // where did we get the table from?
        *offset = i - pDev->biosOffset;
    }

 done:
    return rmStatus;
}


// ***** CORE 2 SCRIPT PROCESSING *****

RM_STATUS DevinitProcessBip2
(
    PHWINFO pDev,
    U032 offset,
    BMP_Control_Block bmpCtrlBlk,
    BOOL* pBiosUsedToInit
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 genInitTableOffset, extraInitTableOffset, sizeInitTable, memInitTableOffset, SDRSeqTableOffset, DDRSeqTableOffset;
    devinit_tables_t *dt = 0;

    rmStatus = DevinitGetInitTableInfo(pDev,
                                       offset,
                                       &bmpCtrlBlk,
                                       &genInitTableOffset,
                                       &extraInitTableOffset,
                                       &sizeInitTable,
                                       &memInitTableOffset,
                                       &SDRSeqTableOffset,
                                       &DDRSeqTableOffset);

    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: invalid BIOS init info version\n");
        goto fallback;
    }

    if (sizeInitTable > BMP_INIT_CODE_SIZE_MAX)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: genInitData too large\n");
        goto fallback;
    }

    // allocate space for init tables
    rmStatus = osAllocMem((VOID **) &dt, sizeof(*dt));
    if (rmStatus != RM_OK)
        goto done;
    dt->genInitData   = (U008 *) 0;      // allocate later based on actual size
    dt->genInitCode   = (U032 *) 0;      // allocate later based on actual size
    dt->extraInitData = (U008 *) 0;      // allocate later based on actual size
    dt->extraInitCode = (U032 *) 0;      // allocate later based on actual size

    // allocate room for the genInitData
    rmStatus = osAllocMem((VOID **) &dt->genInitData, sizeInitTable);
    if (rmStatus != RM_OK)
        goto done;
    rmStatus = osAllocMem((VOID **) &dt->genInitCode, sizeInitTable * sizeof(U032));
    if (rmStatus != RM_OK)
        goto done;
    if (extraInitTableOffset)
    {
        // assume any extra init table no bigger than 'sizeInitTable'
        rmStatus = osAllocMem((VOID **) &dt->extraInitData, sizeInitTable);
        if (rmStatus != RM_OK)
            goto done;
        rmStatus = osAllocMem((VOID **) &dt->extraInitCode, sizeInitTable * sizeof(U032));
        if (rmStatus != RM_OK)
            goto done;
    }

    // extract the memory init code from the BIOS into a buffer
    if (memInitTableOffset)
    {
        int   padded_size_each;
        char *fmt;

        // figure out if using NV10 or NV15 format
        DevinitMeminitFormat(pDev, &fmt, &padded_size_each);

        // extract the array of memory formats
        // trick is that this array has to look right to the NV10 or NV15
        // routines which are expecting their own slice typedef
        BiosReadArray(pDev,
                      (VOID *) dt->memInitTable,
                      memInitTableOffset,
                      MEM_INIT_STRAP_MAX + 1,
                      (U032 *) 0,
                      fmt);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS,
                             "NVRM: could not unpack meminit table data\n");
            goto fallback;
        }
    }

    // extract the SDR init sequence from the BIOS into a buffer
    if (SDRSeqTableOffset)
    {
        rmStatus = BiosReadStructure(pDev,
                                     (U008*) dt->SDRSeqTable,
                                     SDRSeqTableOffset,
                                     (U032 *) 0,
                                     MEM_SEQ_FMT);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: could not extract SDR data\n");
            goto fallback;
        }
    }

    // extract the DDR init sequence from the BIOS into a buffer
    if (DDRSeqTableOffset)
    {
        rmStatus = BiosReadStructure(pDev,
                                     (U008*)dt->DDRSeqTable,
                                     DDRSeqTableOffset,
                                     (U032 *) 0,
                                     MEM_SEQ_FMT);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: could not extract DDR data\n");
            goto fallback;
        }
    }

    // Make sure we don't overflow the init code buffer
    if (sizeInitTable > BMP_INIT_CODE_SIZE_MAX)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Init table too large\n");
        rmStatus = RM_ERROR;
        goto fallback;
    }

    rmStatus = BiosReadBytes(pDev, dt->genInitData, genInitTableOffset, sizeInitTable);
    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: invalid or incomplete general init data found in BIOS\n");
        goto fallback;
    }

    // convert byte-wise init data from the BIOS to dword-wise init code
    rmStatus = DevinitInitDataToCode(dt->genInitCode, dt->genInitData);
    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: old or unusable BIOS init data\n");
        goto fallback;
    }

    // initialize with the buffer of previously extracted code
    rmStatus = InitNV(pDev, dt->genInitCode, (VOID *) dt->memInitTable, dt->SDRSeqTable, dt->DDRSeqTable);
    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: cannot initialize device using BIOS\n");
        goto fallback;
    }

    if (extraInitTableOffset)
    {
        rmStatus = BiosReadBytes(pDev, dt->extraInitData, extraInitTableOffset, sizeInitTable);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: invalid or incomplete extra init data found in BIOS\n");
            goto fallback;
        }

        // TO DO: change the code to byte-wise structs to remove the need for this
        // convert byte-wise init data from the BIOS to dword-wise init code
        rmStatus = DevinitInitDataToCode(dt->extraInitCode, dt->extraInitData);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: old or unusable BIOS extra init data\n");
            goto fallback;
        }

        // initialize with the buffer of previously extracted code
        rmStatus = InitNV(pDev, dt->extraInitCode, (VOID *) 0, (VOID *) 0, (VOID *) 0);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: cannot perform 'extra init' using BIOS\n");
            goto fallback;
        }

    }

    // Whew!
    *pBiosUsedToInit = TRUE;


 fallback:
    // could not rely on the init code in the BIOS, so use a static init table
    if ( ! *pBiosUsedToInit)
    {
        rmStatus = DevinitProcessStaticTables(pDev);
    }

 done:
    if (dt)
    {
        if (dt->genInitData)
            osFreeMem(dt->genInitData);
        if (dt->genInitCode)
            osFreeMem(dt->genInitCode);
        if (dt->extraInitData)
            osFreeMem(dt->extraInitData);
        if (dt->extraInitCode)
            osFreeMem(dt->extraInitCode);
        osFreeMem(dt);
    }

    return rmStatus;

} // end of DevinitProcessBip2()

RM_STATUS InitNV
(
    PHWINFO pDev,
    U032 genInitCode[],
    VOID* memInitTable,
    U032 SDRSeqTable[],
    U032 DDRSeqTable[]
)
{
    RM_STATUS rmStatus = RM_OK;
    U008 opcode;
    char opcodeStr[] = "NVRM: \' \' BMP operation...\n";
    U032 ip = 0;
    BOOL conditionFlag = TRUE;

    // execute the microcode referenced by the instruction pointer
    while ((opcode = DevinitFetchByte(genInitCode, &ip)) != INIT_DONE)
    {
        // extract the operands from the table and perform the operation
        opcodeStr[7] = opcode;
#ifndef UNIX
        // this debug printf to the VGA console messes up the init sequence
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, opcodeStr);
#endif
        switch (opcode)
        {
            case INIT_NV_REG:
            {
                U032 addr = DevinitFetchDword(genInitCode, &ip);
                U032 mask = DevinitFetchDword(genInitCode, &ip);
                U032 data = DevinitFetchDword(genInitCode, &ip);
                rmStatus = init_NV(pDev, addr, mask, data, conditionFlag);
                break;
            }

            case INIT_ZM_REG:
            {
                U032 addr = DevinitFetchDword(genInitCode, &ip);
                U032 data = DevinitFetchDword(genInitCode, &ip);
                rmStatus = init_NV(pDev, addr, 0, data, conditionFlag);
                break;
            }

            case INIT_ZM_WREG:
            {
                U032 addr = DevinitFetchDword(genInitCode, &ip);
                U016 data = DevinitFetchWord(genInitCode, &ip);
                rmStatus = init_NV(pDev, addr, 0, (U032)(data) & 0x0000ffff, conditionFlag);
                break;
            }

            case INIT_PLL:
            {
                // fetch the address
                U032 addr = DevinitFetchDword(genInitCode, &ip);
                U016 data = DevinitFetchWord(genInitCode, &ip);
                rmStatus = init_PLL_Values(pDev, addr, data, conditionFlag);
                break;
            }

            case INIT_TIME:
            {
                U032 ticks = DevinitFetchWord(genInitCode, &ip);
                rmStatus = init_TIME_Delay(pDev, ticks);
                break;
            }

            case INIT_INDEX_IO:
            {
                U016 addr = DevinitFetchWord(genInitCode, &ip);
                U008 index = DevinitFetchByte(genInitCode, &ip);
                U008 mask = DevinitFetchByte(genInitCode, &ip);
                U008 data = DevinitFetchByte(genInitCode, &ip);
                rmStatus = init_INDEX_IO_Write(pDev, addr, index, mask, data, conditionFlag);
                break;
            }

            case INIT_MEM_RESTRICT:
            {
                U032 mask = DevinitFetchByte(genInitCode, &ip);
                U032 value = DevinitFetchByte(genInitCode, &ip);
                rmStatus = init_MEM_RESTRICT_SCRIPT(pDev, mask, value, &conditionFlag);
                break;
            }

            case INIT_STRAP_RESTRICT:
            {
                U032 mask = DevinitFetchDword(genInitCode, &ip);
                U032 value = DevinitFetchDword(genInitCode, &ip);
                rmStatus = init_STRAP_RESTRICT_SCRIPT(pDev, mask, value, &conditionFlag);
                break;
            }

            case INIT_RESUME:
            {
                conditionFlag = TRUE;
                break;
            }

            case INIT_CONFIGURE_CLK:
            {
                rmStatus = init_CONFIGURE_Clocks(pDev, memInitTable);
                break;
            }

            case INIT_CONFIGURE_MEM:
            {
                rmStatus = init_CONFIGURE_Memory(pDev, memInitTable, SDRSeqTable, DDRSeqTable);
                break;
            }

            case INIT_CONFIGURE_PREINIT:
            {
                rmStatus = init_CONFIGURE_PreInit(pDev);
                break;
            }

            case INIT_COMPUTE_MEM:
            {
                rmStatus = init_COMPUTE_Memory(pDev);
                break;
            }

            case INIT_RESET:
            {
                U032 addr = DevinitFetchDword(genInitCode, &ip);
                U032 data1 = DevinitFetchDword(genInitCode, &ip);
                U032 data2 = DevinitFetchDword(genInitCode, &ip);
                rmStatus = init_Reset_Chip(pDev, addr, data1, data2);
                break;
            }

            default:
                rmStatus = RM_ERROR;
                break;
        }
        if (rmStatus != RM_OK)
        {
            break;
        }
    }

    return rmStatus;

} // end of InitNV()

// parse the little-endian init data to convert all opcodes and operands
// to big-endian 32-bit values
RM_STATUS DevinitInitDataToCode
(
    U032 *code,
    U008 *data
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 codeIndex = 0, dataIndex = 0;
    U032 fields;
    U032 unpacked_bytes;

    // parse all instructions
    while (data[dataIndex] != INIT_DONE) // Byte quantity, no swap needed
    {
        // convert instruction based on the opcode
        // copy byte/word/dword of data into a dword of code
        switch (data[dataIndex])     // Byte quantity, no swap needed
        {
            case INIT_NV_REG:
            case INIT_RESET:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT1_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }
            case INIT_ZM_REG:
            case INIT_STRAP_RESTRICT:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT2_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            case INIT_ZM_WREG:
            case INIT_PLL:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT3_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            case INIT_TIME:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT4_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            case INIT_INDEX_IO:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT5_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            case INIT_MEM_RESTRICT:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT6_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            case INIT_RESUME:
            case INIT_CONFIGURE_MEM:
            case INIT_CONFIGURE_CLK:
            case INIT_CONFIGURE_PREINIT:
            case INIT_COMPUTE_MEM:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT7_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            default:
                rmStatus = RM_ERROR;
                break;
        }

        if (rmStatus != RM_OK)
            break;

        dataIndex += unpacked_bytes;
        codeIndex += fields;
    }

    // append init code delimiter
    if (rmStatus == RM_OK)
        code[codeIndex] = (U032)INIT_DONE;

    return rmStatus;

} // end of DevinitInitDataToCode()


RM_STATUS DevinitProcessStaticTables
(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;

#ifndef MACOS // no fallback tables for MAC
    DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: using static tables for device init\n");

    // initialize with the proper device-specific initialization code table
    switch (REG_RD_DRF(_PBUS,_PCI_NV_0,_DEVICE_ID_CHIP))
    {
        case NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV4:
            rmStatus = InitNV(pDev, Nv04_bmp_GenInitTbl, NULL, NULL, NULL);
            break;

        case NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV5:
            switch (REG_RD_DRF(_PBUS,_PCI_NV_11,_SUBSYSTEM_ID))
            {
                case NV_PBUS_PCI_NV_11_SUBSYSTEM_ID_TNT2PRO:
                    rmStatus = InitNV(pDev, Nv05Pro_bmp_GenInitTbl, Nv05_bmp_MemInitTbl, NULL, NULL);
                    break;

                default:
                    rmStatus = InitNV(pDev, Nv05_bmp_GenInitTbl, Nv05_bmp_MemInitTbl, NULL, NULL);
                    break;
            }
            break;

        case NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV10:
            rmStatus =
                InitNV
                (
                    pDev,
                    Nv10_bmp_GenInitTbl,
                    Nv10_bmp_MemInitTbl,
                    Nv10_SDR_Sequence_Table,
                    Nv10_DDR_Sequence_Table
                );
            break;

        default:
            rmStatus = RM_ERROR;
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: no static tables for device\n");
            break;
    }
#endif // MACOS

    return rmStatus;

} // end of DevinitProcessStaticTables()


// extract the relavant values from any arbitrary version of BMP structure
RM_STATUS DevinitGetInitTableInfo
(
    PHWINFO pDev,
    U032    offset,
    PBMP_Control_Block pBmpCtrlBlk,
    U032*   pGenInitTable,
    U032*   pExtraInitTable,
    U032*   pSizeInitTable,
    U032*   pMemInitTable,
    U032*   pSDRSequenceTable,
    U032*   pDDRSequenceTable
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (pBmpCtrlBlk->CTL_Version)
    {
        // BMP init table version 0 is for Nv3
        case BMP_INIT_TABLE_VER_0:
            rmStatus = RM_ERROR;
            break;

        // BMP init table version 1 and 2 use the version 1 base-level functionality
        case BMP_INIT_TABLE_VER_1:
        case BMP_INIT_TABLE_VER_2:
        {
            BMP_Struc_Rev1 BMP_InitTableInfo;
            rmStatus = BiosReadStructure(pDev,
                                         (U008*) &BMP_InitTableInfo,
                                         offset,
                                         (U032 *) 0,
                                         BMP_INIT1_FMT);
            if (rmStatus != RM_OK)
                break;

            *pGenInitTable = BMP_InitTableInfo.BMP_GenInitTable;
            *pExtraInitTable = BMP_InitTableInfo.BMP_ExtraInitTable;
            *pSizeInitTable = BMP_InitTableInfo.BMP_SizeInitTable;
            *pMemInitTable = 0;
            *pSDRSequenceTable = 0;
            *pDDRSequenceTable = 0;
            break;
        }

        // default is BMP init table version 3 base-level functionality
        default:
        {
            BMP_Struc_Rev3 BMP_InitTableInfo;
            BiosReadStructure(pDev,
                              (U008*) &BMP_InitTableInfo,
                              offset,
                              (U032 *) 0,
                              BMP_INIT3_FMT);

            *pGenInitTable = BMP_InitTableInfo.BMP_GenInitTable;
            *pExtraInitTable = BMP_InitTableInfo.BMP_ExtraInitTable;
            *pSizeInitTable = BMP_InitTableInfo.BMP_SizeInitTable;
            *pMemInitTable = BMP_InitTableInfo.BMP_MemInitTable;
            *pSDRSequenceTable = BMP_InitTableInfo.BMP_SDRSequenceTable;
            *pDDRSequenceTable = BMP_InitTableInfo.BMP_DDRSequenceTable;
            break;
        }
    }

    return rmStatus;

} // end of DevinitGetInitTableInfo()

U008 DevinitFetchByte(U032 code[], U032* pIp)
{
    return (U008)code[(*pIp)++];
}

U016 DevinitFetchWord(U032 code[], U032* pIp)
{
    return (U016)code[(*pIp)++];
}

U032 DevinitFetchDword(U032 code[], U032* pIp)
{
    return (U032)code[(*pIp)++];
}


// ***** CORE 3 SCRIPT PROCESSING *****

RM_STATUS DevinitProcessBip3
(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus;
    EXECUTION_CONTEXT context;
    U032 scriptOffset;
    U032 scriptIndex = 0;

    // initialize execution context
    context.conditionFlag = TRUE;
    context.loopStack.sp = 0;
    context.tables = (VOID *) 0;


    // get all table offsets
    rmStatus = DevinitGetBIP3TableOffsets(pDev, &context);
    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: invalid BIOS init info version\n");
        return rmStatus;
    }

    // extract all tables from the BIOS image
    rmStatus = DevinitReadBIP3Tables(pDev, &context);
    if (rmStatus == RM_OK)
    {
        // interpret all scripts in the script table in order
        do
        {
            context.doJump = FALSE;
            scriptOffset = BiosRead16(pDev, context.scriptTableOffset + (scriptIndex * 2));
            if (scriptOffset != SCRIPT_TERMINATE)
            {
                // interpret the script at the script's offset into the BIP code
                DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: interpreting script...\n");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   script table index: ", scriptIndex);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   script offset:      ", scriptOffset);
                rmStatus = DevinitInterpretBIP3Script(pDev, &context, scriptOffset);
                if (rmStatus == RM_OK)
                {
                    scriptIndex = (context.doJump) ? context.jumpIndex : scriptIndex + 1;
                }
                else
                {
                    DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS, "NVRM: could not interpret script...\n");
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:   script table index: ", scriptIndex);
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:   script offset:      ", scriptOffset);
                    break;
                }
            }
        }
        while (scriptOffset != SCRIPT_TERMINATE);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: number of scripts interpreted = ", scriptIndex);
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: could not read BIP3 tables\n");
    }    

    // release all local tables
    DevinitCleanupBIP3Tables(pDev, &context);

    return rmStatus;

} // end of DevinitProcessBip3()

RM_STATUS DevinitInterpretBIP3Script
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT pContext,
    U032               ip
)
{
    RM_STATUS rmStatus = RM_OK;
    U008 opcode;
    U008 opcodeStr[] = "NVRM: \' \' BMP operation...\n";
    BOOL done = FALSE;
    U032 packed_size, extra_packed_size;
    U008 instruction_buffer[BMP_MAX_PADDED_SIZE];
    VOID *instruction = instruction_buffer;

    // interpret the current script -- the instruction pointer, ip, always points to the next instruction
    do
    {
        // extract the operands from the current instruction and perform the operation
        opcode = 
            DevinitFetchInstruction
            (
                pDev,
                ip,
                instruction,
                &packed_size,
                &extra_packed_size
            );

        // go ahead and advance past the opcode proper.
        // After this we'll be pointing at the next instruction *or*
        //   any extra data as in BMP formats 12, 13, 14
        // At bottom we skip over any extra data associated with the opcode.
        ip += packed_size;

        if (opcode < ' ' || opcode > '~')
        {
            opcodeStr[7] = '?';
        }
        else
        {
            opcodeStr[7] = opcode;
        }
#ifndef UNIX // this debug printf to the VGA console messes up the init sequence
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, opcodeStr);
#endif

#if 0 && defined(MACOSX)
        // info only for those ports with decent printfs :-)
        DBG_PRINTF(DEBUGLEVEL_ERRORS,
                   "NVRM: op: %c, 0x%x, from 0x%x, packed: %d, extra: %d\n",
                   opcode, opcode,
                   ip - packed_size,     // already added in
                   packed_size,
                   extra_packed_size);
#endif

                        
        switch (opcode)
        {
            case INIT_COMPUTE_MEM:
            {
                rmStatus = init_COMPUTE_Memory(pDev);
                break;
            }

            case INIT_RESET:
            {
                BMP_FORMAT_1 *bmp1 = instruction;
                init_Reset_Chip
                (
                    pDev, 
                    bmp1->operand1, 
                    bmp1->operand2, 
                    bmp1->operand3
                );
                break;
            }

            case INIT_IO:
            {
                BMP_FORMAT_9 *bmp9 = instruction;
                init_IO
                (
                    pDev,
                    bmp9->operand1,
                    bmp9->operand2,
                    bmp9->operand3,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_MEM_RESTRICT:
            {
                BMP_FORMAT_6 *bmp6 = instruction;
                init_MEM_RESTRICT_SCRIPT
                (
                    pDev,
                    bmp6->operand1,
                    bmp6->operand2,
                    &pContext->conditionFlag
                );
                break;
            }

            case INIT_NV_REG:
            {
                BMP_FORMAT_1 *bmp1 = instruction;
                init_NV
                (
                    pDev,
                    bmp1->operand1,
                    bmp1->operand2,
                    bmp1->operand3,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_RESUME:
            {
                pContext->conditionFlag = TRUE;
                break;
            }

            case INIT_TIME:
            {
                BMP_FORMAT_4 *bmp4 = instruction;
                init_TIME_Delay
                (
                    pDev, 
                    bmp4->operand1
                );
                break;
            }

            case INIT_INDEX_IO:
            {
                BMP_FORMAT_5 *bmp5 = instruction;
                init_INDEX_IO_Write
                (
                    pDev,
                    bmp5->operand1,
                    bmp5->operand2,
                    bmp5->operand3,
                    bmp5->operand4,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_PLL:
            {
                BMP_FORMAT_3 *bmp3 = instruction;
                init_PLL_Values
                (
                    pDev,
                    bmp3->operand1,
                    bmp3->operand2,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_ZM_REG:
            {
                BMP_FORMAT_2 *bmp2 = instruction;
                init_NV
                (
                    pDev,
                    bmp2->operand1,
                    0,
                    bmp2->operand2,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_SUB:
            {
                BMP_FORMAT_8* bmp8 = instruction;
                init_Sub
                (
                    pDev,
                    pContext,
                    bmp8->operand1,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_ZM_INDEX_IO:
            {
                BMP_FORMAT_9 *bmp9 = instruction;
                init_INDEX_IO_Write
                (
                    pDev,
                    bmp9->operand1,
                    bmp9->operand2,
                    0,
                    bmp9->operand3,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_ZM_IO:
            {
                BMP_FORMAT_10 *bmp10 = instruction;
                init_ZM_IO
                (
                    pDev,
                    bmp10->operand1,
                    bmp10->operand2,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_MACRO:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_Macro
                (
                    pDev,
                    pContext,
                    bmp8->operand1,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_CONDITION:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_Condition
                (
                    pDev,
                    pContext,
                    bmp8->operand1,
                    &pContext->conditionFlag
                );
                break;
            }

            case INIT_IO_CONDITION:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_IoCondition
                (
                    pDev,
                    pContext,
                    bmp8->operand1,
                    &pContext->conditionFlag
                );
                break;
            }

            case INIT_IO_FLAG_CONDITION:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_IoFlagCondition
                (
                    pDev,
                    pContext,
                    bmp8->operand1,
                    &pContext->conditionFlag
                );
                break;
            }

            case INIT_NOT:
            {
                pContext->conditionFlag = !pContext->conditionFlag;
                break;
            }

            case INIT_COPY:
            {
                BMP_FORMAT_11 *bmp11 = instruction;
                init_Copy
                (
                    pDev,
                    pContext,
                    bmp11->operand1,
                    (S008) bmp11->operand2,
                    bmp11->operand3,
                    bmp11->operand4,
                    bmp11->operand5,
                    bmp11->operand6,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_RESTRICT_PROG:
            {
                BMP_FORMAT_12 *bmp12 = instruction;
                init_RestrictProg
                (
                    pDev,
                    pContext,
                    bmp12->operand1,
                    bmp12->operand2,
                    bmp12->operand3,
                    bmp12->operand4,
                    bmp12->operand5,
                    ip,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_IO_RESTRICT_PROG:
            {
                BMP_FORMAT_13 *bmp13 = instruction;
                init_IoRestrictProg
                (
                    pDev,
                    pContext,
                    bmp13->operand1,
                    bmp13->operand2,
                    bmp13->operand3,
                    bmp13->operand4,
                    bmp13->operand5,
                    bmp13->operand6,
                    ip,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_IO_RESTRICT_PLL:
            {
                BMP_FORMAT_14 *bmp14 = instruction;
                init_IoRestrictPll
                (
                    pDev,
                    pContext,
                    bmp14->operand1,
                    bmp14->operand2,
                    bmp14->operand3,
                    bmp14->operand4,
                    bmp14->operand5,
                    bmp14->operand6,
                    bmp14->operand7,
                    ip,
                    pContext->conditionFlag
                );
                break;
            }
                
            case INIT_INDEX_ADDRESS_LATCHED:
            {
                BMP_FORMAT_15 *bmp15 = instruction;
                init_IndexAddressLatched
                (
                    pDev,
                    bmp15->operand1,
                    bmp15->operand2,
                    bmp15->operand3,
                    bmp15->operand4,
                    bmp15->operand5,
                    ip,
                    pContext->conditionFlag
                );
                break;
            }
                
            case INIT_REPEAT:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_Repeat
                (
                    pDev,
                    pContext,
                    ip,
                    bmp8->operand1
                );
                break;
            }

            case INIT_END_REPEAT:
            {
                init_EndRepeat
                (
                    pDev,
                    pContext,
                    &ip
                );
                break;
            }

            case INIT_FUNCTION:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_Function
                (
                    pDev,
                    pContext,
                    bmp8->operand1
                );
                break;
            }

            // all of these stop the processing of the current script
            case INIT_JUMP:
            {
                if (pContext->conditionFlag)
                {
                    // extract the destination script index and fall thru to end execution of the current script
                    BMP_FORMAT_8 *bmp8 = instruction;
                    pContext->doJump = TRUE;
                    pContext->jumpIndex = bmp8->operand1;
                    done = TRUE;
                }
                break;
            }

            case INIT_DONE:
            case INIT_EOS:
            case INIT_CONFIGURE_CLK:
            case INIT_CONFIGURE_MEM:
            case INIT_CONFIGURE_PREINIT:
                done = TRUE;
                break;

            default:
                if (opcode == 0x00)
                {
                    // screen out benign NULL opcodes
                    DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Benign opcode found in BIP3 table, skipping...\n");
                }
                else
                {    
                    // fail on undefined opcodes
                    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Bad opcode encountered\n");
                    rmStatus = RM_ERROR;
                }
                break;
        }
        if (rmStatus != RM_OK)
        {
            break;
        }

        // adjust the instruction pointer for those instruction with variable-sized operands
        ip += extra_packed_size;

    } while (!done);

    return rmStatus;

} // end of DevinitInterpretBIP3Script()

RM_STATUS DevinitProcessBip3InternalTMDS
(
    PHWINFO pDev,
    U032    fpPixClk,
    U032    interfaceType
)
{
    RM_STATUS rmStatus = RM_OK;
    EXECUTION_CONTEXT context;
    U032 TableOffset;
    
    // initialize execution context
    context.conditionFlag = TRUE;
    context.loopStack.sp = 0;

    // get all table offsets
    rmStatus = DevinitGetBIP3TableOffsets(pDev, &context);

    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: invalid BIOS init info version\n");
        return rmStatus;
    }
    
    switch ( interfaceType )
    {
        case TMDSIT_TMDS_SINGLE_A:
        {
            TableOffset = context.TMDSSingleAOffset;
            break;
        }
        case TMDSIT_TMDS_SINGLE_B:
        {
            TableOffset = context.TMDSSingleBOffset;
            break;
        }
        case TMDSIT_TMDS_DUAL:
        {
            TableOffset = context.TMDSDualOffset;
            break;
        }
        case TMDSIT_LVDS_SINGLE_A:
        {
            TableOffset = context.LVDSSingleAOffset;
            break;
        }
        case TMDSIT_LVDS_SINGLE_B:
        {
            TableOffset = context.LVDSSingleBOffset;
            break;
        }
        case TMDSIT_LVDS_DUAL:
        {
            TableOffset = context.LVDSDualOffset;
            break;
        }
        case TMDSIT_OFF_SINGLE_A:
        {
            TableOffset = context.OffSingleAOffset;
            break;
        }
        case TMDSIT_OFF_SINGLE_B:
        {
            TableOffset = context.OffSingleBOffset;
            break;
        }
        default:
        {
            return RM_ERROR;
        }
    }

    // Is this table present in the BIOS?
    if ( TableOffset == 0 )
    {
        return RM_ERROR;
    }

    // Find out which script index to use and process it
    rmStatus = DevinitProcessBip3InternalTMDSTable
        (
            pDev,
            &context,
            fpPixClk,
            TableOffset
        );

    return rmStatus;

} // end of DevinitProcessBip3InternalTMDS()


// Process an internal TMDS programming table
RM_STATUS DevinitProcessBip3InternalTMDSTable
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT context,
    U032               fpPixClk,
    U032               TableOffset
)
{
    RM_STATUS rmStatus = RM_OK;

    U032 scriptIndex = 0;

    U032 LastFreq;
    U032 Entries;
    BOOL Found = FALSE;

    U032 currentScriptOffset;
    TMDS_MODE_ENTRY tmdsModeEntry;
    U032            packed_size;

    LastFreq = 0;
    Entries = 0;

    // Scan for frequency
    do
    {
        // Because we don't know the size, extract one entry at a time
        rmStatus = BiosReadStructure(pDev,
                                     &tmdsModeEntry,
                                     TableOffset,
                                     &packed_size,
                                     TMDS_MODE_FORMAT);
        if (rmStatus != RM_OK)
        {
            return rmStatus;
        }
        // Is the pixel clock greater than or equal to this entries frequency
        if ( fpPixClk >= tmdsModeEntry.tmdsmFreq )
        {
            scriptIndex = tmdsModeEntry.tmdsmScript;
            Found = TRUE;
        }
        else if ( ( Entries > 0 ) && ( LastFreq <= tmdsModeEntry.tmdsmFreq ) )
        {
            // We didn't find a match yet, we saw at least two values,
            // and the frequencies are not decreasing
            return RM_ERROR;
        }
        else
        {
            LastFreq = tmdsModeEntry.tmdsmFreq;
            Entries++;
            TableOffset += packed_size;
        }
    } while ( ! Found);

    // interpret the script in the script table at the given index
    currentScriptOffset = BiosRead16(pDev, context->scriptTableOffset + (scriptIndex*2));
    return DevinitInterpretBIP3Script(pDev, context, currentScriptOffset);
}


// extract the relavant values from any arbitrary version of BIP/3 structure
RM_STATUS DevinitGetBIP3TableOffsets
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp
)
{
    RM_STATUS rmStatus = RM_OK;
    BMP_Control_Block bmpCtrlBlk;
    U032 offset;

    cp->TMDSSingleAOffset = 0;
    cp->TMDSSingleBOffset = 0;
    cp->TMDSDualOffset = 0;
    cp->LVDSSingleAOffset = 0;
    cp->LVDSSingleBOffset = 0;
    cp->LVDSDualOffset = 0;
    cp->OffSingleAOffset = 0;  
    cp->OffSingleBOffset = 0; 

    // get the offset of the BMP init table
    rmStatus = DevinitGetBMPControlBlock(pDev, &bmpCtrlBlk, &offset);
    if (rmStatus != RM_OK)
    {
        return rmStatus;
    }

    // get the BMP init table
    if (bmpCtrlBlk.CTL_Version == BMP_INIT_TABLE_VER_5)
    {
        // Core 3 type devinit tables should only be used with BMP 0x05.0x10 or greater.
        if ( bmpCtrlBlk.CTL_Flags < 0x10 )
        {
            return RM_ERROR;
        }
        switch (bmpCtrlBlk.CTL_Flags)
        {
            // Version 0x10 did not have TMDS tables
            case 0x10:
            {
                BMP_Struc_Rev5_0x10 bmpInitTable;
                BiosReadStructure(pDev,
                                  &bmpInitTable,
                                  offset,
                                  (U032 *) 0,
                                  BMP_INIT5_0x10_FMT);
                cp->scriptTableOffset          = bmpInitTable.BMP_InitScriptTablePtr;
                cp->macroIndexTableOffset      = bmpInitTable.BMP_MacroIndexTablePtr;
                cp->macroTableOffset           = bmpInitTable.BMP_MacroTablePtr;
                cp->conditionTableOffset       = bmpInitTable.BMP_ConditionTablePtr;
                cp->ioConditionTableOffset     = bmpInitTable.BMP_IOConditionTablePtr;
                cp->ioFlagConditionTableOffset = bmpInitTable.BMP_IOFlagConditionTablePtr;
                cp->functionTableOffset        = bmpInitTable.BMP_InitFunctionTablePtr;

                rmStatus = RM_OK;

                break;
            }


            // default is BIP/3 BMP init table version 5, subversion 0x11 base-level functionality or above
            default:
            {
                BMP_Struc_Rev5_0x11 bmpInitTable;
                BiosReadStructure(pDev,
                                  &bmpInitTable,
                                  offset,
                                  (U032 *) 0,
                                  BMP_INIT5_0x11_FMT);
                cp->scriptTableOffset          = bmpInitTable.BMP_InitScriptTablePtr;
                cp->macroIndexTableOffset      = bmpInitTable.BMP_MacroIndexTablePtr;
                cp->macroTableOffset           = bmpInitTable.BMP_MacroTablePtr;
                cp->conditionTableOffset       = bmpInitTable.BMP_ConditionTablePtr;
                cp->ioConditionTableOffset     = bmpInitTable.BMP_IOConditionTablePtr;
                cp->ioFlagConditionTableOffset = bmpInitTable.BMP_IOFlagConditionTablePtr;
                cp->functionTableOffset        = bmpInitTable.BMP_InitFunctionTablePtr;
                
                cp->TMDSSingleAOffset          = bmpInitTable.BMP_TMDSSingleAPtr;
                cp->TMDSSingleBOffset          = bmpInitTable.BMP_TMDSSingleBPtr;
                cp->TMDSDualOffset             = bmpInitTable.BMP_TMDSDualPtr;   
                cp->LVDSSingleAOffset          = bmpInitTable.BMP_LVDSSingleAPtr;
                cp->LVDSSingleBOffset          = bmpInitTable.BMP_LVDSSingleBPtr;
                cp->LVDSDualOffset             = bmpInitTable.BMP_LVDSDualPtr;   
                cp->OffSingleAOffset           = bmpInitTable.BMP_OffSingleAPtr; 
                cp->OffSingleBOffset           = bmpInitTable.BMP_OffSingleBPtr; 

                rmStatus = RM_OK;
                break;
            }
        }
    }
    else
    {
        rmStatus = RM_ERROR;
    }

    return rmStatus;

} // end of DevinitGetBIP3TableOffsets()

RM_STATUS DevinitReadBIP3Tables
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp    
)
{
    RM_STATUS rmStatus;

    // allocate space for the tables
    cp->tables = (VOID *) 0;

#ifdef USE_STATIC_BIP3_TABLES
    cp->tables = &bip3_static_tables;
#else
    rmStatus = osAllocMem((VOID *) &cp->tables, sizeof(*cp->tables));
    if (rmStatus != RM_OK)
        goto done;
#endif
        
    // go ahead and read entire macro index table into memory
    rmStatus = BiosReadArray(pDev,
                             cp->tables->macroIndexTable,
                             cp->macroIndexTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             MACRO_INDEX_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;

    // read macro table itself into memory
    rmStatus = BiosReadArray(pDev,
                             cp->tables->macroTable,
                             cp->macroTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             MACRO_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;
    
    // read condition table into memory
    rmStatus = BiosReadArray(pDev,
                             cp->tables->conditionTable,
                             cp->conditionTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             CONDITION_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;
    
    // read io condition table    
    rmStatus = BiosReadArray(pDev,
                             cp->tables->ioConditionTable,
                             cp->ioConditionTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             IO_CONDITION_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;

    // read io flag condition table    
    rmStatus = BiosReadArray(pDev,
                             cp->tables->ioFlagConditionTable,
                             cp->ioFlagConditionTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             IO_FLAG_CONDITION_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;

    // read function table
    rmStatus = BiosReadArray(pDev,
                             cp->tables->functionTable,
                             cp->functionTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             FUNCTION_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;

 done:
    return rmStatus;
    
} // end of DevinitReadBIP3Tables()

VOID DevinitCleanupBIP3Tables
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp    
)
{
#ifndef USE_STATIC_BIP3_TABLES
    if (cp->tables)
    {
        osFreeMem(cp->tables);
    }
#endif
    cp->tables = (VOID *) 0;
    
} // end of DevinitCleanupBIP3Tables()

U008 DevinitFetchInstruction
(
    PHWINFO pDev,
    U032    ip,
    VOID   *pInstruction,
    U032   *pPackedSize,
    U032   *pExtraPackedSize
)
{
    U032 padded_size;
    U008 opcode;
    U032 extra_packed_size = 0;
    U032 count;
    U032 elementSize;
    char *format;
    RM_STATUS rmStatus;

    // set current instruction
    opcode = BiosRead8(pDev, ip);

    // figure out what we are looking at here...
    switch (opcode)
    {
        case INIT_RESET:
        case INIT_NV_REG:
            padded_size = sizeof(BMP_FORMAT_1);
            format = INIT_FMT1_FMT;
            break;

        case INIT_ZM_REG:
            padded_size = sizeof(BMP_FORMAT_2);
            format = INIT_FMT2_FMT;
            break;

        case INIT_PLL:
            padded_size = sizeof(BMP_FORMAT_3);
            format = INIT_FMT3_FMT;
            break;

        case INIT_TIME:
            padded_size = sizeof(BMP_FORMAT_4);
            format = INIT_FMT4_FMT;
            break;

        case INIT_INDEX_IO:
            padded_size = sizeof(BMP_FORMAT_5);
            format = INIT_FMT5_FMT;
            break;

        case INIT_MEM_RESTRICT:
            padded_size = sizeof(BMP_FORMAT_6);
            format = INIT_FMT6_FMT;
            break;

        case INIT_COMPUTE_MEM:
        case INIT_CONFIGURE_MEM:
        case INIT_CONFIGURE_CLK:
        case INIT_CONFIGURE_PREINIT:
        case INIT_DONE:
        case INIT_RESUME:
        case INIT_EOS:
        case INIT_END_REPEAT:
        case INIT_NOT:
            padded_size = sizeof(BMP_FORMAT_7);
            format = INIT_FMT7_FMT;
            break;

        case INIT_SUB:
        case INIT_JUMP:
        case INIT_MACRO:
        case INIT_CONDITION:
        case INIT_IO_CONDITION:
        case INIT_IO_FLAG_CONDITION:
        case INIT_REPEAT:
        case INIT_FUNCTION:
            padded_size = sizeof(BMP_FORMAT_8);
            format = INIT_FMT8_FMT;
            break;

        case INIT_IO:
        case INIT_ZM_INDEX_IO:
            padded_size = sizeof(BMP_FORMAT_9);
            format = INIT_FMT9_FMT;
            break;

        case INIT_ZM_IO:
            padded_size = sizeof(BMP_FORMAT_10);
            format = INIT_FMT10_FMT;
            break;

        case INIT_COPY:
            padded_size = sizeof(BMP_FORMAT_11);
            format = INIT_FMT11_FMT;
            break;

        case INIT_RESTRICT_PROG:
            padded_size = sizeof(BMP_FORMAT_12);
            format = INIT_FMT12_FMT;
            break;

        case INIT_IO_RESTRICT_PROG:
            padded_size = sizeof(BMP_FORMAT_13);
            format = INIT_FMT13_FMT;
            break;

        case INIT_IO_RESTRICT_PLL:
            padded_size = sizeof(BMP_FORMAT_14);
            format = INIT_FMT14_FMT;
            break;

        case INIT_INDEX_ADDRESS_LATCHED:
            padded_size = sizeof(BMP_FORMAT_15);
            format = INIT_FMT15_FMT;
            break;
        
        default:
            // assume unknown opcodes are 1-byte instructions
            padded_size = sizeof(bios_U008);
            format = "b";
            break;
    }

    // now extract the instruction and convert it.
    rmStatus = BiosReadStructure(pDev,
                                 pInstruction,
                                 ip,
                                 pPackedSize,
                                 format);
    if (rmStatus != RM_OK)
        goto failed;

    // now find size of any 'extra' stuff that is part of this instruction...
    // we are not reading it in, just calculating its size

    switch (opcode)
    {
        case INIT_RESTRICT_PROG:
        {
            BMP_FORMAT_12 *bmp12 = pInstruction;
            count = bmp12->operand4;
            elementSize = 4;
            extra_packed_size = count * elementSize;
            break;
        }

        case INIT_IO_RESTRICT_PROG:
        {
            BMP_FORMAT_13 *bmp13 = pInstruction;
            count = bmp13->operand5;
            elementSize = 4;
            extra_packed_size = count * elementSize;
            break;
        }

        case INIT_IO_RESTRICT_PLL:
        {
            BMP_FORMAT_14 *bmp14 = pInstruction;
            count = bmp14->operand6;
            elementSize = 2;
            extra_packed_size = count * elementSize;
            break;
        }

        case INIT_INDEX_ADDRESS_LATCHED:
        {
            BMP_FORMAT_15 *bmp15 = pInstruction;
            count = bmp15->operand5;
            elementSize = 2;
            extra_packed_size = count * elementSize;
            break;
        }

        default:
            extra_packed_size = 0;
            break;
    }

    *pExtraPackedSize = extra_packed_size;

    // return actual opcode
    if (rmStatus == RM_OK)
        return opcode;

 failed:
    // Error path
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: error in DevinitFetchInstruction\n");
    return 0;             // bad opcode

} // end of DevinitFetchInstruction()


// ***** SCRIPT INSTRUCTION IMPLEMENTATION *****

// NV register initialization
RM_STATUS init_NV
(
    PHWINFO pDev,
    U032 reg,
    U032 mask,
    U032 data,
    BOOL conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 value;

    // read, modify, and rewrite the value
    if (conditionFlag)
    {
        value = REG_RD32(reg);
        value = (value & mask) | data;
        REG_WR32(reg, value);
    }

    return rmStatus;

} // end of init_NV()

// NV PLL initialization
RM_STATUS init_PLL_Values
(
    PHWINFO pDev,
    U032 reg,
    U032 MhzX100,
    BOOL conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;

    if (conditionFlag)
    {
        // program the proper clock using the RM kernel
        switch (reg)
        {
            case NV_PRAMDAC_NVPLL_COEFF:
                pDev->Dac.HalInfo.NVClk = MhzX100 * 10000;
                rmStatus = dacProgramNVClk(pDev);
                break;
            
            case NV_PRAMDAC_MPLL_COEFF:
                pDev->Dac.HalInfo.MClk = MhzX100 * 10000;
                rmStatus = dacProgramMClk(pDev);
                break;
            
            case NV_PRAMDAC_VPLL_COEFF:
                rmStatus = dacProgramPClk(pDev, 0, MhzX100);
                break;
            
            default:
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Cannot program unknown clock\n");
                rmStatus = RM_ERROR;
                break;
        }
    }    

    return rmStatus;

} // end of init_PLL_Values()

// initialization time delay
RM_STATUS init_TIME_Delay
(
    PHWINFO pDev,
    U032 mSec
)
{
    return osDelay(mSec);

} // end of init_TIME_Delay()

// indexed I/O Register initialization
RM_STATUS init_INDEX_IO_Write
(
    PHWINFO pDev,
    U032 port,
    U032 index,
    U032 mask,
    U032 data,
    BOOL conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U008 value;

    if (conditionFlag)
    {
        // read, modify, and write the value
        rmStatus = DevinitReadPort(pDev, port, index, &value);
        if (rmStatus == RM_OK)
        {
            value = (value & (U008) mask) | (U008) data;
            rmStatus = DevinitWritePort(pDev, port, index, value);
        }
    }

    return rmStatus;

} // end of init_INDEX_IO_Write()

//  inhibit processing based on memory size
RM_STATUS init_MEM_RESTRICT_SCRIPT
(
    PHWINFO pDev,
    U032 mask,
    U032 value,
    BOOL* pConditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;

    if ((REG_RD32(NV_PFB_BOOT_0) & mask) != value)
    {
        *pConditionFlag = FALSE;
    }

    return rmStatus;

} // end of init_MEM_RESTRICT_SCRIPT()

//  inhibit processing based on strapping
RM_STATUS init_STRAP_RESTRICT_SCRIPT
(
    PHWINFO pDev,
    U032 mask,
    U032 value,
    BOOL* pConditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;

    if ((REG_RD32(NV_PEXTDEV_BOOT_0) & mask) != value)
    {
        *pConditionFlag = FALSE;
    }

    return rmStatus;

} // end of init_STRAP_RESTRICT_SCRIPT()

RM_STATUS init_CONFIGURE_Clocks
(
    PHWINFO pDev,
    VOID* memInitTable
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (REG_RD32(NV_PBUS_PCI_NV_0) >> 16 & 0x0000ffff)
    {
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3:
            rmStatus = Nv10MemConfigureClocks(pDev, (MEM_INIT_VALS_NV10*)memInitTable);
            break;

        default:
            rmStatus = Nv15MemConfigureClocks(pDev, (MEM_INIT_VALS_NV15*)memInitTable);
            break;
    }

    return rmStatus;

} // end of init_CONFIGURE_Clocks()

// configure the device memory
RM_STATUS init_CONFIGURE_Memory
(
    PHWINFO pDev,
    VOID* memInitTable,
    U032 SDRSeqTable[],
    U032 DDRSeqTable[]
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (REG_RD32(NV_PBUS_PCI_NV_0) >> 16 & 0x0000ffff)
    {
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3:
            rmStatus = Nv10MemConfigureMemory(pDev, (MEM_INIT_VALS_NV10*)memInitTable, SDRSeqTable, DDRSeqTable);
            break;

        default:
            rmStatus = Nv15MemConfigureMemory(pDev, (MEM_INIT_VALS_NV15*)memInitTable, SDRSeqTable, DDRSeqTable);
            break;
    }

    return rmStatus;

} // end of init_CONFIGURE_Memory()

// configure RAM type and specifiers
RM_STATUS init_CONFIGURE_PreInit
(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (REG_RD32(NV_PBUS_PCI_NV_0) >> 16 & 0x0000ffff)
    {
        default:
            rmStatus = Nv10MemChipPreInit(pDev);
            break;
    }

    return rmStatus;

} // end of init_CONFIGURE_PreInit()

// compute the memory size of the device
RM_STATUS init_COMPUTE_Memory
(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (REG_RD32(NV_PBUS_PCI_NV_0) >> 16 & 0x0000ffff)
    {
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV04:
            rmStatus = Nv04MemResizeMemory(pDev);
            break;

        // TO DO: modify NV5 memory resizing to use data from the BIOS instead of static data
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID3:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID3:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID3:
            rmStatus = Nv05MemResizeMemory(pDev);
            break;

        default:
            rmStatus = Nv10MemComputeMemory(pDev);
            break;
    }

    return rmStatus;

} // end of init_COMPUTE_Memory()

// reset the device
RM_STATUS init_Reset_Chip
(
    PHWINFO pDev,
    U032 reg,
    U032 enginesOff,
    U032 enginesOn
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 saveValue;

    // save and toggle the AGP command register (don't disturb the FW enable)
    saveValue = REG_RD32(NV_PBUS_PCI_NV_19);
    REG_WR32(NV_PBUS_PCI_NV_19,
             (saveValue & ~(DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON) |
                            DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_AGP_ENABLE, _ON))));

    // write out engines to turn off and on
    REG_WR32(reg, enginesOff);
    REG_WR32(reg, enginesOn);

    // restore AGP command register
    REG_WR32(NV_PBUS_PCI_NV_19, saveValue);

    // set access to the ROM thru instance mem
    FLD_WR_DRF_DEF(_PBUS,_PCI_NV_20,_ROM_SHADOW,_DISABLED);

    return rmStatus;

} // end of init_Reset_Chip()

RM_STATUS init_IO
(
    PHWINFO pDev,
    U032 port,
    U032 mask,
    U032 data,
    BOOL conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 reg, value;

    if (conditionFlag)
    {
        // convert the CRTC port into a priv register
        rmStatus = DevinitPortToPrivReg(port, &reg);
        if (rmStatus == RM_OK)
        {
            // read, modify, and rewrite the value
            value = REG_RD32(reg);
            value = (value & mask) | data;
            REG_WR32(reg, value);
        }
    }

    return rmStatus;

} // end of init_IO()

// set the condition flag based on the results of the given condition
RM_STATUS init_Condition
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               conditionId,
    BOOL              *pConditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 reg;
    U032 mask;
    U032 comparison;
    U032 value;
    CONDITION_ENTRY *pCondEntry;

    if (conditionId != NO_CONDITION)
    {
        // grab out our fields
        pCondEntry = &cp->tables->conditionTable[conditionId];
        reg         = pCondEntry->condAddress;
        mask        = pCondEntry->condMask;
        comparison  = pCondEntry->condCompare;

        // read, modify, reset condition flag on miscompare
        value = REG_RD32(reg);
        value = value & mask;
        if (value != comparison)
        {
            *pConditionFlag = FALSE;
        }
    }    

    return rmStatus;

} // end of init_Condition()

RM_STATUS init_IoCondition
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               conditionId,
    BOOL              *pConditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 port;
    U032 index, mask, comparison;
    U008 value;
    IO_CONDITION_ENTRY* pCondition;

    // modify the flag only if there is a valid condition
    if (conditionId != NO_CONDITION)
    {
        // grab out our fields
        pCondition = &cp->tables->ioConditionTable[conditionId];
        port        = pCondition->iocondPort;
        index       = pCondition->iocondIndex;
        mask        = pCondition->iocondMask;
        comparison  = pCondition->iocondCompare;

        // read, modify, reset condition flag on miscompare
        rmStatus = DevinitReadPort(pDev, port, index, &value);
        if (rmStatus == RM_OK)
        {
            value = value & (U008) mask;
            if (value != (U008) comparison)
            {
                *pConditionFlag = FALSE;
            }
        }
    }    

    return rmStatus;

} // end of init_IoCondition()

// set a flag based on the results of the given I/O flag condition
RM_STATUS init_IoFlagCondition
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               conditionId,
    BOOL              *pFlag
)
{
    U032 port;
    U032 index;
    U032 mask;
    U032 shift;
    U032 flagArrayOffset;
    U032 flag;
    U032 flagMask;
    U032 comparison;
    U008 flagIndex;
    IO_FLAG_CONDITION_ENTRY *pIoFlagCondEntry;
    RM_STATUS rmStatus = RM_OK;

    // set the flag if there is a valid condition
    if (conditionId != NO_CONDITION)
    {
        // grab our fields..
        pIoFlagCondEntry = &cp->tables->ioFlagConditionTable[conditionId];
        port            = pIoFlagCondEntry->iofcondPort;
        index           = pIoFlagCondEntry->iofcondIndex;
        mask            = pIoFlagCondEntry->iofcondMask;
        shift           = pIoFlagCondEntry->iofcondShift;
        flagArrayOffset = pIoFlagCondEntry->iofcondFlagArray;
        flagMask        = pIoFlagCondEntry->iofcondFlagMask;
        comparison      = pIoFlagCondEntry->iofcondFlagCompare;

        // read, modify, reset condition flag on miscompare
        rmStatus = DevinitReadPort(pDev, port, index, &flagIndex);
        if (rmStatus == RM_OK)
        {
            // set the flag based on the contents the flag array contents
            flagIndex = (flagIndex & (U008) mask) >> shift;
            flag = BiosRead8(pDev, flagArrayOffset + flagIndex);
            flag = flag & flagMask;
            if (flag != comparison)
            {
                *pFlag = FALSE;
            }
        }
    }

    return rmStatus;

} // end of init_IoFlagCondition()

RM_STATUS init_RestrictProg
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               indexReg,
    U032               mask,
    U032               shift,
    U032               dataTableSize,
    U032               reg,
    U032               dataTableOffset,
    BOOL               conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 dataIndex, data;

    // only perform the instruction if the condition flag is TRUE and the register is defined, i.e. not 0
    if (conditionFlag && reg)
    {
        // get the index of the data table
        dataIndex = REG_RD32(indexReg);

        // write the register from the data table
        dataIndex = (dataIndex & mask) >> shift;
        if (dataIndex >= dataTableSize)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: range check failure in init_IoRestrictProg\n");
            rmStatus = RM_ERROR;
        }
        else
        {
            data = BiosRead32(pDev, dataTableOffset + (dataIndex * sizeof(U032)));
            REG_WR32(reg, data);
        }
    }

    return rmStatus;

} // end of init_IoRestrictProg()

RM_STATUS init_IoRestrictProg
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               port,
    U032               index,
    U032               mask,
    U032               shift,
    U032               dataTableSize,
    U032               reg,
    U032               dataTableOffset,
    BOOL               conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U008 dataIndex;

    // only perform the instruction if the condition flag is TRUE and
    //   the register is defined, i.e. not 0
    if (conditionFlag && reg)
    {
        // get the index of the data table
        rmStatus = DevinitReadPort(pDev, port, index, &dataIndex);
        if (rmStatus == RM_OK)
        {
            U032 word32;

            // write the register from the data table
            dataIndex = (dataIndex & (U008) mask) >> shift;
            if (dataIndex >= dataTableSize)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: range check failure in init_IoRestrictProg\n");
                rmStatus = RM_ERROR;
            }
            else
            {
                word32 = BiosRead32(pDev, dataTableOffset + (dataIndex * sizeof(U032)));
                REG_WR32(reg, word32);
            }
        }
    }

    return rmStatus;

} // end of init_IoRestrictProg()

RM_STATUS init_IoRestrictPll
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               port,
    U032               index,
    U032               mask,
    U032               shift,
    U032               doubleFlagCondition,
    U032               freqTableSize,
    U032               pllReg,
    U032               freqTableOffset,
    BOOL               conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U008 freqIndex;
    BOOL doubleFlag = FALSE;
    U032 freq;

    // only perform the instruction if the condition flag is TRUE and the
    //   register is defined, i.e. not 0

    if (conditionFlag && pllReg)
    {
        // get the index of the frequency table
        rmStatus = DevinitReadPort(pDev, port, index, &freqIndex);
        if (rmStatus == RM_OK)
        {
            // program the PLL register from the frequency table
            freqIndex = (freqIndex & (U008) mask) >> shift;
            init_IoFlagCondition(pDev, cp, doubleFlagCondition, &doubleFlag);
            if (freqIndex >= freqTableSize)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: range check failure in init_IoRestrictPll\n");
                rmStatus = RM_ERROR;
            }
            else
            {
                freq = BiosRead16(pDev, freqTableOffset + (freqIndex * 2));
                freq = (doubleFlag) ? freq * 2 : freq;
                rmStatus = init_PLL_Values(pDev, pllReg, freq, conditionFlag);
            }
        }
    }

    return rmStatus;

} // end of init_IoRestrictPll()

RM_STATUS init_IndexAddressLatched
(
    PHWINFO pDev,
    U032    controlReg,
    U032    dataReg,
    U032    mask,
    U032    writeOr,
    U032    dataTableSize,
    U032    dataTableOffset,
    BOOL    conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;

    // only perform the instruction if the condition flag is TRUE and
    //  the register is defined, i.e. not 0
    if (conditionFlag && (dataReg != 0))
    {
        U032 i;

        for ( i = 0; i < dataTableSize; i++ )
        {
            U032 index;
            U032 dataValue;
            U032 controlValue;

            index = BiosRead8(pDev, dataTableOffset + (i * 2));
            dataValue = BiosRead8(pDev, dataTableOffset + (i * 2) + 1);

            REG_WR32( dataReg, dataValue );

            controlValue = REG_RD32( controlReg );
            controlValue &= mask;
            controlValue |= writeOr;
            controlValue |= index;

            REG_WR32( controlReg, controlValue );
        }
    }    
    
    return rmStatus;

} // end of init_IndexAddressLatched()


RM_STATUS init_Sub
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               scriptIndex,
    BOOL               conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 scriptOffset;
    
    if (conditionFlag)
    {
        scriptOffset = BiosRead16(pDev, cp->scriptTableOffset + (scriptIndex * 2));
        if (scriptOffset != SCRIPT_TERMINATE)
        {
            // interpret the script at the script's offset into the BIP code
            DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: interpreting sub script...\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   script table index: ", scriptIndex);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   script offset:      ", scriptOffset);
            rmStatus = DevinitInterpretBIP3Script(pDev, cp, scriptOffset);
            if (rmStatus != RM_OK)
            {
                DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS, "NVRM: could not interpret sub script...\n");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:   script table index: ", scriptIndex);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:   script offset:      ", scriptOffset);
            }
        }
    }    
    
    return rmStatus;

} // end of init_Sub()

RM_STATUS init_Macro
(
    PHWINFO            pDev,
    EXECUTION_CONTEXT *cp,
    U032               macroId,
    BOOL               conditionFlag
)
{
    RM_STATUS           rmStatus = RM_OK;
    MACRO_ENTRY        *pMacro;
    U032                macroCount;
    U032                i, reg, data;
    MACRO_INDEX_ENTRY  *pMacroIndexEntry;

    if (conditionFlag)
    {
        pMacroIndexEntry = &cp->tables->macroIndexTable[macroId];

        macroCount = pMacroIndexEntry->macroCount;
        pMacro = &cp->tables->macroTable[pMacroIndexEntry->macroIndex];

        // perform the set of register writes defined in the macro
        for (i = 0; i < macroCount; i++)
        {
            reg = pMacro[i].macroAddress;
            data = pMacro[i].macroValue;
            REG_WR32(reg, data);
        }
    }

    return rmStatus;

} // end of init_Macro()

RM_STATUS init_ZM_IO
(
    PHWINFO pDev,
    U032 port,
    U032 value,
    BOOL conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 reg;

    if (conditionFlag)
    {
        // convert the CRTC port into a priv register
        rmStatus = DevinitPortToPrivReg(port, &reg);
        if (rmStatus == RM_OK)
        {
            // write the value
            REG_WR32(reg, value);
        }
    }

    return rmStatus;

} // end of init_ZM_IO()

RM_STATUS init_Copy
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               srcReg,
    S008               srcShift,
    U032               srcMask,
    U032               port,
    U032               index,
    U032               destMask,
    BOOL               conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 srcValue;
    U032 value;
    U008 destValue;

    if (conditionFlag)
    {
        srcValue = REG_RD32(srcReg);
        if (srcShift >= 0)
        {
            srcValue >>= srcShift;
        }
        else
        {
            srcValue <<= -srcShift;
        }
        value = srcValue & srcMask;
        rmStatus = DevinitReadPort(pDev, port, index, &destValue);
        if (rmStatus == RM_OK)
        {
            destValue = (destValue & (U008) destMask) | (U008) value;
            rmStatus = DevinitWritePort(pDev, port, index, destValue);
        }
    }

    return rmStatus;

} // end of init_Copy()

RM_STATUS init_Repeat
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               ip,
    U032               loopCount
)
{
    RM_STATUS rmStatus = RM_OK;

    // setup the loop stack to contain the loop offset and the current loop count
    DevinitStackPush(&cp->loopStack, ip);
    DevinitStackPush(&cp->loopStack, loopCount);
    
    return rmStatus;

} // end of init_Repeat()

RM_STATUS init_EndRepeat
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032*              pip
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 count;

    // pop the current loop count from the loop stack and decrement it
    count = DevinitStackPop(&cp->loopStack);
    if (--count > 0)
    {
        // continue looping -- adjust offset to the top of the loop and push the counter back on
        *pip = DevinitStackTop(&cp->loopStack);
        DevinitStackPush(&cp->loopStack, count);
    }
    else
    {
        // terminate looping -- clear the rest of loop stack and go on to the next instruction
        (VOID)DevinitStackPop(&cp->loopStack);
    }
    
    return rmStatus;

} // end of init_EndRepeat()

RM_STATUS init_Function
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               functionIndex
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 functionId;

    // call the HAL to execute this "escape" function
    functionId = cp->tables->functionTable[functionIndex];
    // HalExecuteFunction(functionId);

    return rmStatus;

} // end of init_Function()

VOID DevinitMeminitFormat
(
    PHWINFO   pDev,
    char    **fmt,
    int      *padded_size
)
{
    U032 value;

    value = REG_RD32(NV_PBUS_PCI_NV_0);
    value >>= 16;
    value &= 0xffff;

    switch (value)
    {
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3:
            *padded_size = sizeof(MEM_INIT_VALS_NV10);
            *fmt = MEM_INIT_VALS_NV10_FMT;
            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID3:

        default:

            *padded_size = sizeof(MEM_INIT_VALS_NV15);
            *fmt = MEM_INIT_VALS_NV15_FMT;
            break;
    }
}

RM_STATUS DevinitReadPort
(
    PHWINFO pDev,
    U032    port,
    U032    index,
    U008   *pValue
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 privReg;
    U008 prevIndex;

    // convert the CRTC port into a priv register
    rmStatus = DevinitPortToPrivReg(port, &privReg);
    if (rmStatus == RM_OK)
    {
        // save the old index
        prevIndex = REG_RD08(privReg);

        // read the value
        REG_WR08(privReg, index);
        *pValue = REG_RD08(privReg + 1);

        // restore the old index
        REG_WR08(privReg, prevIndex);
    }

    return rmStatus;

} // end of DevinitReadPort()

RM_STATUS DevinitWritePort
(
    PHWINFO pDev,
    U032 port,
    U032 index,
    U032 value
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 privReg;
    U008 prevIndex;

    // convert the CRTC port into a priv register
    rmStatus = DevinitPortToPrivReg(port, &privReg);
    if (rmStatus == RM_OK)
    {
        // save the old index
        prevIndex = REG_RD08(privReg);

        // write the value
        REG_WR08(privReg, index);
        REG_WR08(privReg + 1, value);

        // restore the old index
        REG_WR08(privReg, prevIndex);
    }

    return rmStatus;

} // end of DevinitWritePort()

RM_STATUS DevinitPortToPrivReg
(
    U032 crtcReg, 
    U032* pPrivReg
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (crtcReg)
    {
        case CRTC_INDEX_MONO:
        case CRTC_INDEX_COLOR:
        case ATC_INDEX:
        //...
            *pPrivReg = DEVICE_BASE(NV_PRMCIO) + crtcReg;
            break;

        case SEQ_INDEX:
        case GDC_INDEX:
        //...
            *pPrivReg = DEVICE_BASE(NV_PRMVIO) + crtcReg;
            break;

        default:
            rmStatus = RM_ERROR;
            break;
    }

    return rmStatus;

} // end of DevinitPortToPrivReg()

VOID DevinitStackPush
(
    PDEVINIT_STACK pStack,
    U032 value
)
{
    if (pStack->sp < DEVINIT_STACK_MAX)
    {
        (*pStack).body[++pStack->sp] = value;
    }

} // end of DevinitStackPush()

U032 DevinitStackPop
(
    PDEVINIT_STACK pStack
)
{
    if (pStack->sp > 0)
    {
        return (*pStack).body[pStack->sp--];
    }

    // on stack underflow, return 0
    return 0;

} // end of DevinitStackPop()

U032 DevinitStackTop
(
    PDEVINIT_STACK pStack
)
{
    return (*pStack).body[pStack->sp];

} // end of DevinitStackTop()

RM_STATUS DevinitShadowBios
(
    PHWINFO pDev,
    PHWREG  externalBiosImage
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWREG tempBiosAddr;
    U032 i;

    if (externalBiosImage)
    {
        // setup for ROM reads
        tempBiosAddr = biosAddr;
        biosAddr = externalBiosImage;

        // copy the BIOS image into upper instance memory
        for (i = 0; i < BIOS_ROM_CODE_SIZE; i++)
        {
            REG_WR08(pDev->Pram.HalInfo.PraminOffset + i, BIOS_RD08(i));
        }

        // restore original biosAddr
        biosAddr = tempBiosAddr;
    }
    else
    {
        rmStatus = RM_ERROR;
    }

    return rmStatus;

} // end of DevinitShadowBios()

// extract the FminVCO/FmaxVCO values from the BIOS, if available
RM_STATUS DevinitGetMinMaxVCOValues
(
    PHWINFO    pDev,
    U032       *FminVCO,
    U032       *FmaxVCO
)
{
    RM_STATUS rmStatus = RM_OK;
    BMP_Control_Block bmpCtrlBlk;
    U032 offset;

    *FminVCO = *FmaxVCO = 0x0;

    // determine if we've got the correct BIOS rev
    rmStatus = DevinitGetBMPControlBlock(pDev, &bmpCtrlBlk, &offset);
    if (rmStatus != RM_OK)
        return rmStatus;

    if (bmpCtrlBlk.CTL_Version == BMP_INIT_TABLE_VER_5)
    {
        // FminVCO/FmaxVCO are only available in BMP 0x05.0x10 or greater
        if (bmpCtrlBlk.CTL_Flags < 0x10)
            return RM_ERROR;

        switch (bmpCtrlBlk.CTL_Flags)
        {
            // Version 0x10 did not have TMDS tables
            case 0x10:
            {
                BMP_Struc_Rev5_0x10 bmpInitTable;
                BiosReadStructure(pDev,
                                  &bmpInitTable,
                                  offset,
                                  (U032 *) 0,
                                  BMP_INIT5_0x10_FMT);

                *FminVCO = bmpInitTable.BMP_FminVco;
                *FmaxVCO = bmpInitTable.BMP_FmaxVco;
                rmStatus = RM_OK;
                break;
            }

            // default is BIP/3 BMP init table version 5, subversion 0x11 base-level functionality or above
            default:
            {
                BMP_Struc_Rev5_0x11 bmpInitTable;
                BiosReadStructure(pDev,
                                  &bmpInitTable,
                                  offset,
                                  (U032 *) 0,
                                  BMP_INIT5_0x11_FMT);

                *FminVCO = bmpInitTable.BMP_FminVco;
                *FmaxVCO = bmpInitTable.BMP_FmaxVco;
                rmStatus = RM_OK;
                break;
            }
        }
    }
    else
        rmStatus = RM_ERROR;

    return rmStatus;

} // end of DevinitGetGetMinMaxVCOValues()

// end of devinit.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\nv10mtbl.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*****************************************************************************
*
*	Header: nv10mtbl.c
*
*	Description:
*		This file contains the initialization code tables used to POST an NV10 device.
*   The init code was taken from the BIOS source file, nvinit.inc.
*
*	Revision History:
*		Original -- 6/99 Jeff Westerinen
*
*   Steps to convert all tables
*
*		1.	convert ; to //
*		2.  remove all db, dw, and dd, and add comma separaters
*		3.  convert IFDEF to #ifdef
*		4.	convert ELSE to #else
*		5.	convert ENDIF to #endif
*		6.	convert "OR \" and "OR " to "| "
*		7.	convert asm hex numbers to C hex numbers: ([0-9A-Fa-f]+)h\, to 0x\1\,
*       8.  convert asm binary numbers to C hex numbers
*		9.	format -- at least line up data to left indent
*		10. comment out all table delimiters
*
*   Steps to convert sequence tables from memcfg.asm
*
*		1.	convert SDR_Sequence_Table data to: U032 Nv10_SDR_Sequence_Table[] = { <data> }; 
*		2.	convert DDR_Sequence_Table data to: U032 Nv10_DDR_Sequence_Table[] = { <data> }; 
*
*   Steps to convert mem init table from memcfg.asm
*
*		1.	convert bmp_MemInitTbl data to: MEM_INIT_VALS Nv10_bmp_MemInitTbl[] = { <data> }; 
*       2.  remove MEM_INIT_VALS for each entry
*       3.  add defaults to elements 4, 10, and 14
*       4.  separate records with commas
*
*	Steps to convert bmp_GenInitTbl in nvinit.inc
*
*		1.	convert bmp_GenInitTbl data to: U032 Nv04_bmp_GenInitTbl[] = { <data> }; 
*		2.  remove bmp_ExtraInitTbl
*
******************************************************************************/

#include <nv10_ref.h>
#include <nvrm.h>
#include <bios.h>

U032 Nv10_SDR_Sequence_Table[] = 
{
    NV_PFB_REFCTRL,
    NV_PFB_CFG,
    NV_PFB_TIMING0,
    NV_PFB_TIMING1,
    NV_PFB_TIMING2,
    NV_PBUS_DEBUG_CTRIM_4,
    NV_PFB_PRE,
    NV_PFB_PIN,
    NV_PFB_PAD,
    NV_PFB_EMRS,
    NV_PFB_MRS,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_PRE,
    NV_PFB_PRE,
    NV_PFB_PRE,
    NV_PFB_MRS,
    NV_PFB_REFCTRL,
    0xFFFFFFFF,
    0xFFFFFFFF,
    0xFFFFFFFF,
    0xFFFFFFFF      // List terminator
};
        
U032 Nv10_DDR_Sequence_Table[] = 
{
    NV_PFB_REFCTRL,
    NV_PFB_CFG,
    NV_PFB_TIMING0,
    NV_PFB_TIMING1,
    NV_PFB_TIMING2,
    NV_PBUS_DEBUG_CTRIM_4,
    NV_PFB_PIN,
    NV_PFB_PAD,
    NV_PFB_PRE,
    NV_PFB_EMRS,
    NV_PFB_MRS,
    NV_PFB_PRE,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_MRS,
    NV_PFB_REFCTRL,
    0xFFFFFFFF,
    0xFFFFFFFF,
    0xFFFFFFFF,
    0xFFFFFFFF      // List terminator
};
   
MEM_INIT_TABLE_NV10 Nv10_bmp_MemInitTbl = 
{
    // Note - PFB_TIMING2: 61A = 100Mhz
    //                     91F = 150Mhz
    //                     **A2C = 166Mhz** old value
    //                     9FF = 166Mhz
    //                     B1F = 183Mhz
    //                       
    // 0000 = 64MBit x 32 SDR 166Mhz
    // Strap 0000 - 2M x 32 SDR @ 166Mhz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B11110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL,0xFFFFFFFF, 
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0000
    // 0001 =                                 
    // Strap 0001 - 4Mx16 SDR @ 166MHz 
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08C11110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,    
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0001
    // 0010 =                                                       
    // Strap 0010 - 1Mx32 SDR @ 166MHz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B01110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0010
    // 0011 = 16MBit x 16 SDR 200Mhz
    // Strap 0011 - 16MBit x 16 SDR @ 166Mhz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B01110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0011
    // 0100 =            
    // Strap 0100 - 512Kx32(2-bank) SDR SGRAM @ 166Mhz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08A01110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0100
    // 0101 =            
    // Strap 0101 - 512Kx32(2-bank) SDR SGRAM @ 166Mhz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08911110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0101
    // 0110 =            
    // Strap 0110 - 8Mx16 SDR @ 100 Mhz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x09C11110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0110
    // 0111 =            
    // Strap 0111 - 8M x 8 SDR SDRAM @ 166MHz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x09C11110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0111
                     
    // 1000 = 64MBit x 32 SDR 150Mhz
    // Strap 0000 - 2M x 32 SDR @ 150Mhz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B11110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL,0xFFFFFFFF, 
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0000
    // 1001 =                                 
    // Strap 0001 - 4Mx16 SDR @ 150MHz 
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08C11110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,    
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0001
    // 1010 =                                                       
    // Strap 0010 - 1Mx32 SDR @ 150MHz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B01110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0010
    // 1011 = 16MBit x 16 SDR 200Mhz
    // Strap 0011 - 16MBit x 16 SDR @ 150Mhz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B01110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0011
    // 1100 =            
    // Strap 0100 - 512Kx32(2-bank) SDR SGRAM @ 150Mhz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08A01110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0100
    // 1101 =            
    // Strap 0101 - 512Kx32(2-bank) SDR SGRAM @ 150Mhz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08911110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0101
    // 1110 =            
    // Strap 0110 - 8Mx16 SDR @ 150 Mhz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x09C11110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0110
    // 1111 =            
    // Strap 0111 - 8M x 8 SDR SDRAM @ 150MHz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x09C11110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}}   // 0111
};
                         
U032 Nv10_bmp_GenInitTbl[] = 
{
#if 0
    //-----------------------------------------------------
    // Do a software reset here
    //-----------------------------------------------------
    INIT_RESET,                          // Sequence ID byte
    NV_PMC_ENABLE,                       // NV 32 bit address.
    // 
    // Off state
    NV_PMC_ENABLE_BUF_RESET_DISABLE | 
       NV_PMC_ENABLE_PMEDIA_DISABLED   | 
       NV_PMC_ENABLE_PFIFO_DISABLED    | 
       NV_PMC_ENABLE_PGRAPH_DISABLED   | 
       NV_PMC_ENABLE_PPMI_DISABLED     | 
       NV_PMC_ENABLE_PFB_DISABLED      | 
       NV_PMC_ENABLE_PCRTC_ENABLED     | 
       NV_PMC_ENABLE_PVIDEO_DISABLED,
                                  
    //
    // On state
    NV_PMC_ENABLE_BUF_RESET_DISABLE  | 
       NV_PMC_ENABLE_PMEDIA_ENABLED     | 
       NV_PMC_ENABLE_PFIFO_ENABLED      | 
       NV_PMC_ENABLE_PGRAPH_DISABLED    | 
       NV_PMC_ENABLE_PPMI_ENABLED       | 
       NV_PMC_ENABLE_PFB_ENABLED        | 
       NV_PMC_ENABLE_PCRTC_ENABLED      | 
       NV_PMC_ENABLE_PVIDEO_DISABLED,
       
    //-----------------------------------------------------
    // Configure the strap fields here
    //-----------------------------------------------------
    INIT_NV_REG,                          // Write with Mask
    NV_PEXTDEV_BOOT_0,                    // Strap Register Update
    // 
    //   +---------------------------------- OVERWRITE_ENABLED
    //   |++++++++++++++++------------------ UNUSED
    //   |||||||||||||||||+----------------- FB32MB
    //   ||||||||||||||||||++--------------- PCI_DEVID[1:0]
    //   ||||||||||||||||||||+-------------- RESERVED_11 (NV5)/AGP_FASTWR (NV10)
    //   |||||||||||||||||||||+------------- AGP_SBA_DISABLED
    //   ||||||||||||||||||||||+------------ AGP_4X_DISABLED
    //   |||||||||||||||||||||||++---------- TVMODE[1:0]
    //   |||||||||||||||||||||||||+--------- CRYSTAL_14318180
    //   ||||||||||||||||||||||||||++++----- RAMCFG[3:0]
    //   ||||||||||||||||||||||||||||||+---- SUB_VENDOR_BIOS              
    //   |||||||||||||||||||||||||||||||+--- PCI_AD_NORMAL
    //   VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
    //   3322222222221111111111
    //   10987654321098765432109876543210
    //11111111111111111111011111111111b    // AND Mask      
    0xfffff7ff,    // AND Mask      
    //10000000000000000000000000000000b    // |  Mask - force write
    0x80000000,    // |  Mask - force write

    INIT_CONFIGURE_PREINIT,               // Read RAM type and Ref Freq
                                           // This also inits CR3C

    //-----------------------------------------------------
    // Make sure the NV10 fan is running
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x035,0x0FE,0x001,
                   
    //-----------------------------------------------------
    // Set Scratch4 to let the VESA interface know the fan is on
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x03C,0x0F7,0x008,
                                              
    // Disable Framebuffer
    INIT_ZM_REG,                         // Write register
    NV_PMC_ENABLE,                       // NV 32 bit address.
    NV_PMC_ENABLE_BUF_RESET_ENABLE   | 
       NV_PMC_ENABLE_PMEDIA_ENABLED     | 
       NV_PMC_ENABLE_PFIFO_ENABLED      | 
       NV_PMC_ENABLE_PGRAPH_DISABLED    | 
       NV_PMC_ENABLE_PPMI_ENABLED       | 
       NV_PMC_ENABLE_PFB_DISABLED       | 
       NV_PMC_ENABLE_PCRTC_ENABLED      | 
       NV_PMC_ENABLE_PVIDEO_DISABLED,
       
    INIT_INDEX_IO,
    SEQ_INDEX,
    0x001,0x0FF,0x020,           // FullCPU Access On/CRTC Refresh off

    // Note: CRTC Refresh and the Framebuffer need to be disabled
    //       while programming NVCLK and MCLK
       
    INIT_PLL,
    NV_PRAMDAC_NVPLL_COEFF,              // Program default NVCLOCK
    10000,                               // 100Mhz   
                                              
    INIT_PLL,
    NV_PRAMDAC_MPLL_COEFF,               // Program default MCLOCK
    8300,                                // 83Mhz        
                                              
    //-----------------------------------------------------
    // Set per MK on 5/26/99
    //-----------------------------------------------------
    INIT_ZM_REG,                         // Write register
    NV_PBUS_DEBUG_CTRIM_0,                       
    0x03115223,                           // 05/26/99

    //-----------------------------------------------------
    //-----------------------------------------------------
    INIT_NV_REG,                         // Write with Mask
    NV_PBUS_DEBUG_CTRIM_1,                       
    0x0FFFFFFFF,                          // AND Mask
    0x000000000,                          // | Mask

    //-----------------------------------------------------
    //-----------------------------------------------------
    INIT_ZM_REG,                         // Write register
    NV_PBUS_DEBUG_CTRIM_2,                       
    0x000000000,
           
    //-----------------------------------------------------
    //-----------------------------------------------------
    INIT_ZM_REG,                         // Write register
    NV_PBUS_DEBUG_CTRIM_3,                       
    0x0FF223003,

    //-----------------------------------------------------
    // Set per MK on 5/26/99
    //-----------------------------------------------------
    // INIT_ZM_REG                         // Write register
    // NV_PBUS_DEBUG_CTRIM_4               
    // 9CAB1433h                           // 05/26/99
    //
    // above now done in memcfg.asm
    //

    //-----------------------------------------------------
    //-----------------------------------------------------
    INIT_NV_REG,                         // Write with Mask
    NV_PBUS_DEBUG_CTRIM_5,                       
    0x0FFFFFFFF,                          // AND Mask
    0x000000000,                          // | Mask

    //-----------------------------------------------------
    //-----------------------------------------------------
    INIT_NV_REG,                         // Write with Mask
    NV_PBUS_DEBUG_CTRIM_6,                       
    0x0FFFFFFFF,                          // AND Mask
    0x000000000,                          // | Mask

    INIT_ZM_REG,                         // Write register
    NV_PRAMDAC_PLL_COEFF_SELECT,         // NV 32 bit address.
    0x00000500,                           // PROG_MPLL & PROG_NVPLL

    INIT_CONFIGURE_CLK,                  // Set MCLK/NVCLK

    // Enable Framebuffer
    INIT_ZM_REG,                         // Write register
    NV_PMC_ENABLE,                       // NV 32 bit address.
    NV_PMC_ENABLE_BUF_RESET_ENABLE   | 
       NV_PMC_ENABLE_PMEDIA_ENABLED     | 
       NV_PMC_ENABLE_PFIFO_ENABLED      | 
       NV_PMC_ENABLE_PGRAPH_DISABLED    | 
       NV_PMC_ENABLE_PPMI_ENABLED       | 
       NV_PMC_ENABLE_PFB_ENABLED        | 
       NV_PMC_ENABLE_PCRTC_ENABLED      | 
       NV_PMC_ENABLE_PVIDEO_DISABLED,

    //-----------------------------------------------------
    // Set the drive strengh register. The default AND/OR
    // mask causes the BIOS to initialize with the power
    // on default value.
    //-----------------------------------------------------
    INIT_NV_REG,                         // Write with Mask
    NV_PBUS_DEBUG_PRIV_ASRC,                      
    0x0FFFFFFFF,                          // AND Mask
    0x000000000,                          // | Mask
       
    //-----------------------------------------------------
    //-----------------------------------------------------

    // 8/25/99
    // Bit 7 (PCIS_RETRY is SPARE0, and has changed from 1 to 0 here)
    //
    INIT_ZM_REG,                         // Write register
    NV_PBUS_DEBUG_1,
    // 
    //   ++++++++++++++++------------------- SPARES
    //   ||||||||||||||||+------------------ AGPFW_DWOD_DISABLED
    //   |||||||||||||||||+----------------- FBI_DIFFERENTIAL_DISABLED
    //   ||||||||||||||||||+---------------- DPSH_DECODE_NV4
    //   |||||||||||||||||||+--------------- PCIS_CPUQ_ENABLED
    //   ||||||||||||||||||||+-------------- UNDEFINED
    //   |||||||||||||||||||||+------------- PCIS_EARLY_RTY_ENABLED
    //   ||||||||||||||||||||||+------------ PCIS_WR_BURST_ENABLED
    //   |||||||||||||||||||||||+----------- PCIS_RD_BURST_ENABLED
    //   ||||||||||||||||||||||||+---------- SPARE0_ZERO
    //   |||||||||||||||||||||||||+--------- PCIS_2_1_ENABLED
    //   ||||||||||||||||||||||||||+-------- PCIS_WRITE_0_CYCLE
    //   |||||||||||||||||||||||||||++------ AGPM_CMD_LP_ONLY
    //   |||||||||||||||||||||||||||||+----- HASH_DECODE_1FF
    //   ||||||||||||||||||||||||||||||+---- PCIM_CMD_SIZE_BASED
    //   |||||||||||||||||||||||||||||||+--- PCIM_THROTTLE_DISABLED
    //   VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV    
    //   3322222222221111111111
    //   10987654321098765432109876543210
    //00000000000000000101011101001000b,   // Write Value
    0x00005748,   // Write Value
                                   
    INIT_ZM_REG,                         // Write register
    NV_PFB_DEBUG_0,
    0,

    // New "Configure Memory" token
    INIT_CONFIGURE_MEM,                  // Configure the memory type

    INIT_COMPUTE_MEM,                    // Size the memory

    INIT_INDEX_IO,
    SEQ_INDEX,
    0x001,0x0DF,0x000,           // FullCPU Access Off

    //-----------------------------------------------------
    // Program VCLOCK
    //         
    // 13,500,000 MHz - VCLK = M:12:0C, N:064:40, P:2:02 LOG2P:1 36.00 MHz
    // 14,318,180 MHz - VCLK = M:14:0E, N:141:8D, P:4:04 LOG2P:2 36.05 MHz
    //-----------------------------------------------------
    INIT_PLL,
    NV_PRAMDAC_VPLL_COEFF,               // Program default VCLOCK
    3600,                                // 36Mhz   

    //-----------------------------------------------------
    // Set to NV5 values f| now
    //-----------------------------------------------------
    INIT_ZM_REG,
    NV_PBUS_DEBUG_2,
    0x000011F0,

    //-----------------------------------------------------
    // Set to NV5 values f| now
    //-----------------------------------------------------
    INIT_ZM_REG,
    NV_PBUS_DEBUG_3,
    NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_120MHZ | NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES,

    //-----------------------------------------------------
    // Do CRTC IO default programming
    //-----------------------------------------------------
    //
    //-----------------------------------------------------
    // Force real mode window default state to off
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
	//NVRM_ACCESS,0x000,0x000,				// !! undefined
	NV_CIO_CRE_RMA__INDEX,0x000,0x000,

    //-----------------------------------------------------
    // Make sure hsync and vsync are on (we only set them in DPMS calls)
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x01A,0x000,0x03F,
                   
    //-----------------------------------------------------
    // Boot with TV off, and set f| NTSC if it was on.
    // Also set horizontal pixel adjustment
    // Sets pixel format to VGA
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x028,0x000,0x000,

    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x033,0x000,0x000,         // Clear slave registers

    //-----------------------------------------------------
    // Force Lock register to default state
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x021,0x000,0x0FA,         // Force Lock register to 0FAh

    //-----------------------------------------------------
    // Clear scratch registers - TV Selection
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x02B,0x000,0x000,         // Clear all scratch bits f| default
                                        
    //-----------------------------------------------------
    // Clear scratch registers to default state
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x02C,0x000,0x000,         // Clear all scratch bits f| default

    //-----------------------------------------------------
    // Clear scratch registers to default state
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x03A,0x000,0x000,         // Clear all scratch bits f| default
    
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x03B,0x000,0x000,         // Clear all scratch bits f| default

    //-----------------------------------------------------
    // End of the list
    //-----------------------------------------------------
    INIT_DONE
    
#else

    // This data was extracted directly from a GeForce reference card.
    // It differs from the translated source code above and is the only
    // version between the two that actually works.  If necessary, we
    // must either create a development path from the actual BIOS source
    // code or create a tool that extracts the tables from a BIOS binary.
    0x00000065, 0x00000200, 0x01000000, 0x01110110,
    0x0000006e, 0x00101000, 0xfffff7ff, 0x80000000,
    0x00000068, 0x00000078, 0x000003d4, 0x00000035,
    0x000000fe, 0x00000001, 0x00000078, 0x000003d4,
    0x0000003a, 0x00000000, 0x00000001, 0x0000007a,
    0x00000200, 0x01010111, 0x00000078, 0x000003c4,
    0x00000001, 0x000000ff, 0x00000020, 0x00000079,
    0x00680500, 0x00002710, 0x00000079, 0x00680504,

    0x0000206c, 0x0000007a, 0x000010b0, 0x03115223,
    0x0000006e, 0x000010b4, 0xffffffff, 0x00000000,
    0x0000007a, 0x000010b8, 0x00000000, 0x0000007a,
    0x000010bc, 0xff223003, 0x0000006e, 0x000010c8,
    0xffffffff, 0x00000000, 0x0000006e, 0x000010cc,
    0xffffffff, 0x00000000, 0x0000007a, 0x0068050c,
    0x00000500, 0x00000067, 0x0000007a, 0x00000200,
    0x01110111, 0x0000006e, 0x000010e0, 0xffffffff,

    0x00000000, 0x0000007a, 0x00001084, 0x00005748,
    0x0000007a, 0x00100080, 0x00000000, 0x00000066,
    0x00000063, 0x00000078, 0x000003c4, 0x00000001,
    0x000000df, 0x00000000, 0x00000079, 0x00680508,
    0x00000e10, 0x0000007a, 0x00001088, 0x000011f0,
    0x0000007a, 0x0000108c, 0x000000d1, 0x00000078,
    0x000003d4, 0x00000038, 0x00000000, 0x00000000,
    0x00000078, 0x000003d4, 0x0000001a, 0x00000000,

    0x0000003f, 0x00000078, 0x000003d4, 0x00000028,
    0x00000000, 0x00000000, 0x00000078, 0x000003d4,
    0x00000033, 0x00000000, 0x00000000, 0x00000078,
    0x000003d4, 0x00000021, 0x00000000, 0x000000fa,
    0x00000078, 0x000003d4, 0x0000002b, 0x00000000,
    0x00000000, 0x00000078, 0x000003d4, 0x0000002c,
    0x00000000, 0x00000000, 0x00000078, 0x000003d4,
    0x0000003b, 0x00000000, 0x00000000, 0x00000071

#endif

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\nv04mem.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*	Module: nv04mem.c
*
*	Description:
*		Device-specific memory sizing code, for NV4.
*
*	Revision History:
*		Original -- 5/99 Jeff Westerinen
*
**************************************************************************************************************/

#ifdef NV_PORTABLE

/* "portable" form for use outside resman and by external source customers */
/* look in devinit/portable/ for more details */
#include <nv_portable.h>
#include <nv_ref.h>
#include <nv4_ref.h>
#include <devinit.h>

#else	/* not NV_PORTABLE --> Nvidia internal */

#include <nvrm.h>
#include <nvhw.h>
#include <nv4_ref.h>
#include <os.h>
#include <devinit.h>

#endif

// TO DO: the actual memory detection and sizing is device dependent
extern char strDevNodeRM[];

RM_STATUS Nv04MemResizeMemory
(
	PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 memoryType;
    U008 sgram_mem[] = "SGRAM";
    U008 sdram_mem[] = "SDRAM";
    U032 offset;

    // check for registry override of memory type
    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "VideoMemoryTypeOverride", &memoryType) == RM_OK)
    {
        switch(memoryType)
        {
            case DEVINIT_SDRAM:
                rmStatus = Nv04MemResizeSdram(pDev);
                break;
                
            case DEVINIT_SGRAM:
                rmStatus = Nv04MemResizeSgram(pDev);
                break;
                
            default:
                rmStatus = RM_ERROR;
                break;
        }
    } else {
        rmStatus = BiosFindString(pDev, sgram_mem, &offset, sizeof(sgram_mem));
        if (rmStatus == RM_OK)
        {
            rmStatus = Nv04MemResizeSgram(pDev);
            goto done;
        }
 
        rmStatus = BiosFindString(pDev, sdram_mem, &offset, sizeof(sdram_mem));
        if (rmStatus == RM_OK)
        {
            rmStatus = Nv04MemResizeSdram(pDev);
            goto done;
        } 

        rmStatus = RM_ERROR;
    }

done:
    return rmStatus;
                
} // end of DevinitResizeMemory()

RM_STATUS Nv04MemResizeSdram
(
	PHWINFO pDev
)
{
	RM_STATUS rmStatus = RM_OK;
	U032 i;

	// TO DO: is this necessary?
    // turn on full CPU access
	//...
        
	// turn on refresh
    FLD_WR_DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED);

    // assume 16MB, 128-bit, 1024K 2-bank
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_16MB);
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_WIDTH_128,_ON);
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_TYPE,_1024K_2BANK);   
    Nv04MemLatchMemConfig(pDev);

    // write 128 bits of data for the test sequence
    for (i = 0; i < 4; i++)
    {
        FB_WR32(i * 4, 'NV4A');
    }    
                                                 
    // if the lower 16 bits of 128-bit word is invalid, change to 8M
    if (FB_RD16(0x0000000C) != '4A')
    {
        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_8MB);
        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_WIDTH_128,_OFF);
    }

    // insure the memory config gets set
    Nv04MemLatchMemConfig(pDev);

	// TO DO: is this necessary?
	// turn off full CPU access
	//...
    
    // output results
    switch (REG_RD_DRF(_PFB,_BOOT_0,_RAM_AMOUNT))
    {
        case NV_PFB_BOOT_0_RAM_AMOUNT_8MB:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM:   8MB SDRAM\n");
            break;
            
        case NV_PFB_BOOT_0_RAM_AMOUNT_16MB:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM:   16MB SDRAM\n");
            break;
            
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unknown Size SDRAM\n");
            break;
    }

	return rmStatus;

} // end of DevinitResizeSdram()

RM_STATUS Nv04MemResizeSgram
(
	PHWINFO pDev
)
{
	RM_STATUS rmStatus = RM_OK;
	U032 i, memDevSize;

	// TO DO: is this necessary?
    // turn on full CPU access
	//...
        
    // disable refresh for the entire routine 
    FLD_WR_DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_DISABLED);

    // assume 16MB, 128-bit, 512K 2-bank
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_16MB);
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_WIDTH_128,_ON);
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_TYPE,_512K_2BANK);    
    Nv04MemLatchMemConfig(pDev);

    // write 128-bit test data word at the beginning of FB
    for (i = 0; i < 4; i++)
    {
        FB_WR32(i * 4, 'NV4A');
    }    
    
    // determine the size of the memory devices, i.e. 8 or 16 Mbit
    memDevSize = (FB_RD32(0x00000000) == 'NV4A') ? 16 : 8;

    // determine the interface width
    if (FB_RD16(0x0e) == 'NV')
    {
        // 128-bit width detected
        
        // detect 8mbit or 16mbit @ 128-bits
        if (memDevSize == 16)
        {
            // 16mbit device, 128-bit width detected
            
            // detect 8MB or 16MB total RAM amount
            FB_WR32(0x00800000, 'A4VN');
            if (FB_RD32(0x00800000) != 'A4VN')
            {
                // 8MB detected, so change config
                FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_8MB);
            }
        }
        else
        {
            // 8mbit device, 128-bit width detected
            
            // detect 4MB or 8MB total RAM amount
            // Note: unclear about 4/8M test -- write at 4Meg or 8Meg??? -- !!!!! TEST THIS !!!!!
            FB_WR32(0x00800000, 'A4VN');
            if (FB_RD32(0x00800000) == 'A4VN')
            {
                // 8MB detected, so change config
                FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_8MB);
            }
            else
            {
                // 4MB detected, so change config
                FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_4MB);
            }
        }
    }
    else
    {
        // 64-bit width detected
        
        // since 8MBit device is not valid at 64-bit width, 4MB detected, so change config
        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_WIDTH_128,_OFF);
        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_4MB);
    }

    // insure the memory config gets set
    Nv04MemLatchMemConfig(pDev);

	// reenable refresh
    FLD_WR_DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED);

	// TO DO: is this necessary?
	// turn off full CPU access
	//...

    // output results
    switch (REG_RD_DRF(_PFB,_BOOT_0,_RAM_AMOUNT))
    {
        case NV_PFB_BOOT_0_RAM_AMOUNT_4MB:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM:   4MB SGRAM\n");
            break;
            
        case NV_PFB_BOOT_0_RAM_AMOUNT_8MB:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM:   8MB SGRAM\n");
            break;
            
        case NV_PFB_BOOT_0_RAM_AMOUNT_16MB:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM:   16MB SGRAM\n");
            break;
            
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unknown Size SGRAM\n");
            break;
    }

	return rmStatus;

} // end of DevinitResizeSgram()

VOID Nv04MemLatchMemConfig
(
    PHWINFO pDev
)
{
    // save the original CAS latency
    U032 latency = REG_RD_DRF(_PFB,_CONFIG_1,_CAS_LATENCY);
    
    // toggle the LSB 1-0-1
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3);
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_2);
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3);
    
    // restore original CAS latency
    FLD_WR_DRF_NUM(_PFB,_CONFIG_1,_CAS_LATENCY,latency);
    
} // end of Nv04MemLatchMemConfig()


// end of nv04mem.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dma\nv\event.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************************* DMA Manager *****************************\
*                                                                           *
* Module: EVENT.C                                                           *
*   Event notifications are handled in this module.  DMA report and OS      *
*   action are dealt with on a per-object basis.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <fifo.h>
#include <dma.h>   
#include <os.h>
#include <nv32.h>
#include "nvhw.h"


//---------------------------------------------------------------------------
//
//  Event Notification structure.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Event Object support.
//
//---------------------------------------------------------------------------

// Given the Parent Object, add the notify event.
RM_STATUS eventSetObjectEventNotify
(
   POBJECT ParentObject,
   U032    hObject,
   U032    NotifyIndex,
   U032    NotifyType,
   U064    Data
)
{
    PEVENTNOTIFICATION EventNotify;
    RM_STATUS          status;
    
    //
    // Create the event notification object
    //
    status = osAllocMem((VOID **)&EventNotify, sizeof(EVENTNOTIFICATION));
    if (status)
        return (status);

    //
    // Fill in the fields
    //
    EventNotify->Handle      = hObject;
    EventNotify->NotifyIndex = NotifyIndex;
    EventNotify->NotifyType  = NotifyType;
    EventNotify->Data        = Data;

    //
    // Now insert the event into the event chain of this object.  
    // Order doesn't really matter.
    //
    EventNotify->Next = ParentObject->NotifyEvent;
    ParentObject->NotifyEvent = EventNotify;
    
    return (RM_OK);        
}

//---------------------------------------------------------------------------
//
//  Event Notification support.
//
//---------------------------------------------------------------------------

//
// Given an object's name and fifo, insert a new event notifier into this object.
//
RM_STATUS eventSetEventNotify
(
    PHWINFO     pDev, 
    U032        ObjectName,
    U032        ChID,
    U032        NotifyIndex,
    U032        NotifyType,
    U064        Data
)
{
#ifdef LEGACY_ARCH
    POBJECT            Object;
    RM_STATUS          status;
    
    //
    // Find the parent object
    //
    if (fifoSearchObject(pDev, ObjectName, ChID, &Object) == RM_OK)
    {
        // Found the parent.
		status = eventSetObjectEventNotify(Object, 0/* object handle*/, 
		                                   NotifyIndex, NotifyType, Data);
    }
    else
		// Did not find the parent
        status = RM_ERROR;
        
    return status;        
#else
	// For the new architecture, this proc is not called.
    return RM_ERROR;
#endif
}    

RM_STATUS eventRemoveObjectEventNotify
(
   POBJECT ParentObject,
   U032    hObject
)
{
    PEVENTNOTIFICATION nextEvent, lastEvent;
    BOOL found = FALSE;
    
    // check for null list
    nextEvent = (void *) 0;
    if (ParentObject->NotifyEvent != NULL)
    {
        // check for head of list
        nextEvent = lastEvent = ParentObject->NotifyEvent;
        if ((nextEvent->Handle = hObject))
        {
            ParentObject->NotifyEvent = nextEvent->Next;
            found = TRUE;
        }
        else
        {
            // check for internal nodes
            nextEvent = nextEvent->Next;
            while (nextEvent)
            {
                if ((nextEvent->Handle = hObject))
                {
                    lastEvent->Next = nextEvent->Next;
                    found = TRUE;
                    break;
                }
                lastEvent = nextEvent;
                nextEvent = nextEvent->Next;
            }
        }
    }
    
    // delete the event if it was found
    if (found)
    {
        osFreeMem(nextEvent);
    }
    
    return (found) ? RM_OK : RM_ERROR;
        
} // end of eventRemoveObjectEventNotify()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\devinit\portable\nv_portable.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

 /***************************************************************************\
|*                                 Typedefs                                  *|
 \***************************************************************************/

typedef unsigned char      NvV8;  /* "void": enumerated or multiple fields   */
typedef unsigned short     NvV16; /* "void": enumerated or multiple fields   */
typedef unsigned long      NvV32; /* "void": enumerated or multiple fields   */
typedef unsigned char      NvU8;  /* 0 to 255                                */
typedef unsigned short     NvU16; /* 0 to 65535                              */
typedef unsigned long      NvU32; /* 0 to 4294967295                         */
typedef signed char        NvS8;  /* -128 to 127                             */
typedef signed short       NvS16; /* -32768 to 32767                         */
typedef signed long        NvS32; /* -2147483648 to 2147483647               */
typedef float              NvF32; /* IEEE Single Precision (S1E8M23)         */
typedef double             NvF64; /* IEEE Double Precision (S1E11M52)        */


typedef unsigned char   U008;
typedef unsigned short  U016;
typedef unsigned long   U032;

typedef unsigned char   V008;
typedef unsigned short  V016;
typedef unsigned long   V032;

typedef unsigned long   BOOL;
typedef long            S032;



#define NULL 0

#define FALSE 0
#define TRUE  1


//
// Internal codes.
//

typedef U032 RM_STATUS;
#define NUM_RM_ERRORS                   22
#define RM_OK                           0x00000000
#define RM_ERROR                        0xFFFFFFFF
#define RM_WARN_NULL_OBJECT             (0x10000000|RM_OK)
#define RM_WARN_AUDIO_DISABLED          (0x20000000|RM_OK)
#define RM_WARN_GRAPHICS_DISABLED       (0x30000000|RM_OK)
#define RM_ERR_NO_FREE_MEM              (0x01000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_MEM_NOT_FREED            (0x01010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_PAGE_TABLE_NOT_AVAIL     (0x01020000|NV_OUT_OF_RESOURCES)
#define RM_ERR_NO_FREE_FIFOS            (0x02000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_CANT_CREATE_CLASS_OBJS   (0x02010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_BAD_OBJECT               (0x03000000|NV_NO_SUCH_OBJECT)
#define RM_ERR_INSERT_DUPLICATE_NAME    (0x03010000|NV_NAME_IN_USE)
#define RM_ERR_OBJECT_NOT_FOUND         (0x03020000|NV_NO_SUCH_OBJECT)
#define RM_ERR_CREATE_BAD_CLASS         (0x04000000|NV_NO_SUCH_OBJECT)
#define RM_ERR_DELETE_BAD_CLASS         (0x04010000|NV_NO_SUCH_OBJECT)
#define RM_ERR_FIFO_RUNOUT_OVERFLOW     (0x05000000|NV_FIFO_OVERFLOW)
#define RM_ERR_FIFO_BAD_ACCESS          (0x05010000|NV_RESERVED_ADDRESS)
#define RM_ERR_FIFO_OVERFLOW            (0x05020000|NV_FIFO_OVERFLOW)
#define RM_ERR_METHOD_ORDER             (0x06000000|NV_INCOMPLETE_METHOD)
#define RM_ERR_METHOD_COUNT             (0x06010000|NV_INCOMPLETE_METHOD)
#define RM_ERR_ILLEGAL_OBJECT           (0x06020000|NV_TYPE_CONFLICT)
#define RM_ERR_DMA_IN_USE               (0x07000000|NV_BUFFER_BUSY)
#define RM_ERR_BAD_DMA_SPECIFIER        (0x07010000|NV_TRANSLATION_VIOLATION)
#define RM_ERR_INVALID_XLATE            (0x07020000|NV_TRANSLATION_VIOLATION)
#define RM_ERR_INVALID_START_LENGTH     (0x07030000|NV_PROTECTION_VIOLATION)
#define RM_ERR_DMA_MEM_NOT_LOCKED       (0x07040000|NV_OUT_OF_RESOURCES)
#define RM_ERR_DMA_MEM_NOT_UNLOCKED     (0x07050000|NV_OUT_OF_RESOURCES)
#define RM_ERR_NOTIFY_IN_USE            (0x07060000|NV_BUFFER_BUSY)
#define RM_ERR_ILLEGAL_ADDRESS          (0x08000000|NV_ILLEGAL_ACCESS)
#define RM_ERR_BAD_ADDRESS              (0x08010000|NV_PROTECTION_VIOLATION)
#define RM_ERR_INVALID_COLOR_FORMAT     (0x09000000|NV_BAD_COLOR_FORMAT)
#define RM_ERR_INVALID_MONO_FORMAT      (0x09010000|NV_BAD_MONOCHROME_FORMAT)
#define RM_ERR_INVALID_AUDIO_FORMAT     (0x09020000|NV_BAD_AUDIO_FORMAT)
#define RM_ERR_INVALID_GAMEPORT_FORMAT  (0x09030000|NV_BAD_AUDIO_FORMAT)
#define RM_ERR_OBJECT_TYPE_MISMATCH     (0x0A000000|NV_TYPE_CONFLICT)
#define RM_ERR_NO_FREE_AUDIO_INSTANCES  (0x0B000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_CODEC_INPUT_IN_USE       (0x0B010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_AUDIO_DISABLED           (0x0B020000|NV_OUT_OF_RESOURCES)
#define RM_ERR_INCOMPLETE_PATCH         (0x0C000000|NV_INCOMPLETE_PATCH)
#define RM_ERR_INVALID_PATCH            (0x0C010000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_PATCH_TOO_COMPLEX        (0x0C020000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_MAX_PATCH_FANOUT         (0x0C030000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_DEVICE_DISCONNECTED      (0x0C040000|NV_NO_CONNECTION)
#define RM_ERR_BUFFER_GAP               (0x0D000000|NV_BUFFER_GAP)
#define RM_ERR_INVALID_OS_NAME          (0x0E000000|NV_OS_NAME_ERROR)
#define RM_ERR_ILLEGAL_ACTION           (0x0E010000|NV_OS_NAME_ERROR)
// The DMA direction specified for the DMA object is not allowed in the
// specified address space.
#define RM_ERR_ILLEGAL_DIRECTION        (0x0E020000|NV_OS_NAME_ERROR)
#define RM_ERR_OUT_OF_TIMER_CALLBACKS   (0x0F000000|NV_OUT_OF_RESOURCES)

// Errors returned from the arch calls.
#define NV_ERROR_2                      0x0200
#define RM_ERR_OPERATING_SYSTEM         (0x00000001|NV_ERROR_2)
#define RM_ERR_BAD_OBJECT_PARENT        (0x00000002|NV_ERROR_2)
#define RM_ERR_BAD_OBJECT_HANDLE       	(0x00000003|NV_ERROR_2)
#define RM_ERR_OBJECT_IN_USE            (0x00000004|NV_ERROR_2)
#define RM_ERR_OBJECT_HAS_CHILDERN      (0x00000005|NV_ERROR_2)
#define RM_ERR_BAD_CLASS                (0x00000006|NV_ERROR_2)
#define RM_ERR_INSUFFICIENT_RESOURCES   (0x00000007|NV_ERROR_2)
#define RM_ERR_BAD_FLAGS                (0x00000008|NV_ERROR_2)
#define RM_ERR_BAD_BASE                 (0x00000009|NV_ERROR_2)
#define RM_ERR_BAD_LIMIT                (0x0000000A|NV_ERROR_2)
#define RM_ERR_PROTECTION_FAULT         (0x0000000B|NV_ERROR_2)
#define RM_ERR_MULTIPLE_MEMORY_TYPES    (0x0000000C|NV_ERROR_2)
#define RM_ERR_BAD_OBJECT_ERROR         (0x0000000D|NV_ERROR_2)
#define RM_ERR_BAD_OBJECT_BUFFER        (0x0000000E|NV_ERROR_2)
#define RM_ERR_BAD_OFFSET               (0x0000000F|NV_ERROR_2)


#define BIT(b)                  (1<<(b))
#define DEVICE_BASE(d)          (0?d)
#define DEVICE_EXTENT(d)        (1?d) - DEVICE_BASE(d) + 1
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))


// #include <nv_local.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dma\nv10\dmanv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** DMA Manager ********************************\
*                                                                           *
* Module: dmanv10.c                                                         *
*   The NV10 HAL DMA engine implementation is provided in this module.      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalDmaControl_NV10(VOID *);
RM_STATUS nvHalDmaAlloc_NV10(VOID *);
RM_STATUS nvHalDmaFree_NV10(VOID *);
RM_STATUS nvHalDmaGetInstSize_NV10(VOID *);

//
// nvHalDmaControl
//
// Nothing to do here.
//
RM_STATUS
nvHalDmaControl_NV10(VOID *arg)
{
    PDMACONTROLARG_000 pDmaControlArg = (PDMACONTROLARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDmaControlArg->id != DMA_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    switch (pDmaControlArg->cmd)
    {
        case DMA_CONTROL_UPDATE:
        case DMA_CONTROL_LOAD:
        case DMA_CONTROL_UNLOAD:
        case DMA_CONTROL_DESTROY:
        case DMA_CONTROL_INIT:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalDmaAlloc
//
// Initialize dma instance.
//
RM_STATUS
nvHalDmaAlloc_NV10(VOID *arg)
{
    PDMAALLOCARG_000 pDmaAllocArg = (PDMAALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALOBJINFO pDmaHalObjInfo;
    PDMAHALINFO pDmaHalInfo;
    PHWREG nvAddr;
    U032 adjust, i;

    //
    // Verify interface revision.
    //
    if (pDmaAllocArg->id != DMA_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pDmaHalObjInfo = pDmaAllocArg->pHalObjInfo;
    pHalHwInfo = pDmaAllocArg->pHalHwInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    adjust = 0;
    switch (pDmaHalObjInfo->classNum)
    {
        case NV1_CONTEXT_DMA_TO_MEMORY:     
        case NV_CONTEXT_DMA_TO_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_TO_MEMORY);
            break;
        case NV1_CONTEXT_DMA_FROM_MEMORY:     
        case NV_CONTEXT_DMA_FROM_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_FROM_MEMORY);
            break;
        case NV1_CONTEXT_DMA_IN_MEMORY:     
        case NV_CONTEXT_DMA_IN_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_IN_MEMORY);
            break;
    }
    adjust |= SF_NUM(_DMA, _ADJUST, pDmaHalObjInfo->PteAdjust);
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
        adjust |= SF_DEF(_DMA, _PAGE_ENTRY, _LINEAR);
    adjust |= SF_DEF(_DMA, _PAGE_TABLE, _PRESENT);
    switch (pDmaHalObjInfo->AddressSpace)
    {
        case ADDR_SYSMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _PCI);
            break;
        case ADDR_AGPMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _AGP);
            break;
        case ADDR_FBMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _NVM);
            break;
        default:
#ifdef DEBUG
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Invalid address space type\n\r");
            DBG_BREAKPOINT();
#endif
            return (RM_ERR_BAD_ARGUMENT);
    }
    //
    // Fill the page translation array.
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
    {    
        INST_WR32(pDmaHalObjInfo->Instance, 8, pDmaHalObjInfo->PteArray[0]);
        INST_WR32(pDmaHalObjInfo->Instance, 12, pDmaHalObjInfo->PteArray[0]); // better guard
    }        
    else 
    {   
        for (i = 0; i < pDmaHalObjInfo->PteCount; i++)
        {
            INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[i]);
        }
        //
        // Fill in the guard page with bogus data.  Only accessed by DMA engine,
        // not used in any transfer to system memory.
        //
        INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[0]);
    }
    //
    // Fill in rest of page table values.
    //
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_CLASS), adjust);
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_LIMIT), pDmaHalObjInfo->PteLimit);

    //
    // Add this dma context to the HAL table.
    //
    pDmaHalObjInfo->Next = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
    pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo;

    return (RM_OK);
}

//
// nvHalDmaFree
//
RM_STATUS
nvHalDmaFree_NV10(VOID *arg)
{
    PDMAFREEARG_000 pDmaFreeArg = (PDMAFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALINFO pDmaHalInfo;
    PDMAHALOBJINFO pDmaHalObjInfo, pDmaHalObjInfoDelete;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pDmaFreeArg->id != DMA_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaFreeArg->pHalHwInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;
    pDmaHalObjInfo = pDmaFreeArg->pHalObjInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Detach from DMA list.
    //
    if (pDmaHalInfo->pDmaHalObjInfos == (VOID_PTR)pDmaHalObjInfo)
        pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo->Next;
    else
    {
        pDmaHalObjInfoDelete = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
        while (pDmaHalObjInfoDelete->Next && pDmaHalObjInfoDelete->Next != pDmaHalObjInfo)
        {
            pDmaHalObjInfoDelete = pDmaHalObjInfoDelete->Next;
        }
        if (pDmaHalObjInfoDelete->Next)
            pDmaHalObjInfoDelete->Next = pDmaHalObjInfo->Next;
    }

    return (RM_OK);
}

//
// nvHalDmaGetInstSize
//
// Return number of *paragraphs* required for dma context in
// instance memory.
//
RM_STATUS
nvHalDmaGetInstSize_NV10(VOID *arg)
{
    PDMAGETINSTSIZEARG_000 pDmaGetInstSizeArg = (PDMAGETINSTSIZEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALOBJINFO pDmaHalObjInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pDmaGetInstSizeArg->id != DMA_GET_INSTSIZE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaGetInstSizeArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaGetInstSizeArg->pHalObjInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Factor in an extra PTE so when the DMA engine prefetches, it
    // won't fault on a last access to a page.
    //
    
    //
    // Local memory contexts require only 1 paragraph (they're linear).
    // So do single page contexts in other address spaces (i.e. system memory).
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || ((pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM)))
        pDmaHalObjInfo->NumUnits = 1;
    else
    {
        if (pDmaHalObjInfo->PteCount == 1)
            pDmaHalObjInfo->NumUnits = 1;
        else
            pDmaHalObjInfo->NumUnits = 2 + (pDmaHalObjInfo->PteCount - 1) / 4;
    }
    
    return (RM_OK);
}

//
// dmaHalInstanceToHalInfo
//
RM_STATUS
dmaHalInstanceToHalInfo_NV10(U032 chid, U032 instance, PDMAHALOBJINFO *ppDmaHalObjInfo, PHALHWINFO pHalHwInfo)
{
    PDMAHALOBJINFO pDmaHalObjInfo;

    pDmaHalObjInfo = (PDMAHALOBJINFO)pHalHwInfo->pDmaHalInfo->pDmaHalObjInfos;
    while (pDmaHalObjInfo)
    {
        if (pDmaHalObjInfo->Instance == instance)
        {
            //
            // Found it!
            //
    	    *ppDmaHalObjInfo = pDmaHalObjInfo;
            return RM_OK;
        }
        pDmaHalObjInfo = pDmaHalObjInfo->Next;
    }

    *ppDmaHalObjInfo = NULL;  
    return RM_ERR_BAD_ARGUMENT;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dma\nv\dmastate.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/
/******************************* DMA Manager *******************************\
*                                                                           *
* Module: DMASTATE.C                                                        *
*   The DMA state is managed in this module.                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"


//
// Initialize DMA hardware.
//
RM_STATUS stateDma
(
    PHWINFO pDev,
    U032    msg
)
{
#ifdef KJK
    PDMAOBJECT DmaObject;
#endif
#ifdef LEGACY_ARCH
    RM_STATUS  status;
#endif
    
    switch (msg)
    {
        case STATE_UPDATE:
            break;
        case STATE_LOAD:

#ifdef LEGACY_ARCH
            //
            // Fill class-specific NULL DMA instances with something invalid
            //
            if (!pDev->Dma.DmaInMemEmptyInstance)
            {            
                status = fbAllocInstMem(pDev, &(pDev->Dma.DmaInMemEmptyInstance), 1);
                if (status == RM_OK)
                {
//                    INST_WR32(pDev->Dma.DmaInMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV1_CONTEXT_DMA_IN_MEMORY);
//                    INST_WR32(pDev->Dma.DmaInMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT),  0);
                    INST_WR32(pDev->Dma.DmaInMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV01_NULL);
                    INST_WR32(pDev->Dma.DmaInMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT), 0xFFFFFFFF);
                }
            }                
            if (!pDev->Dma.DmaToMemEmptyInstance)
            {            
                status = fbAllocInstMem(pDev, &(pDev->Dma.DmaToMemEmptyInstance), 1);
                if (status == RM_OK)
                {
//                    INST_WR32(pDev->Dma.DmaToMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV1_CONTEXT_DMA_TO_MEMORY);
//                    INST_WR32(pDev->Dma.DmaToMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT),  0);
                    INST_WR32(pDev->Dma.DmaToMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV01_NULL);
                    INST_WR32(pDev->Dma.DmaToMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT), 0xFFFFFFFF);
                }
            }                
            if (!pDev->Dma.DmaFromMemEmptyInstance)
            {            
                status = fbAllocInstMem(pDev, &(pDev->Dma.DmaFromMemEmptyInstance), 1);
                if (status == RM_OK)
                {
//                    INST_WR32(pDev->Dma.DmaFromMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV1_CONTEXT_DMA_FROM_MEMORY);
//                    INST_WR32(pDev->Dma.DmaFromMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT),  0);
                    INST_WR32(pDev->Dma.DmaFromMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV01_NULL);
                    INST_WR32(pDev->Dma.DmaFromMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT), 0xFFFFFFFF);
                }
            }                
#endif // LEGACY_ARCH

#ifdef KJK            
            //
            // Reload any DMA instances.
            //
            DmaObject = pDev->DBDmaList;
            while (DmaObject)
            {
                DBG_VAL_PTR(DmaObject);
                //
                // Load instance.
                //    
                if (DmaObject->State & DMA_RELOAD)
                {
                    //
                    // Get DMA instance for page table mapping.
                    //
                    if (dmaAllocInstance(DmaObject))
                    {
                        DmaObject->Valid = FALSE;
                        osUnlockUserMem(DmaObject->Base.ChID,
                                        DmaObject->BufferBase,
                                        DmaObject->DescAddr,
                                        DmaObject->AddressSpace,
                                        DmaObject->DescLimit,
                                        DmaObject->PteCount,
                                        DmaObject->LockHandle,
                                        DmaObject->Base.Class->Type == NV1_CONTEXT_DMA_TO_MEMORY ? TRUE : FALSE);
                        osFreeMem(DmaObject->PteArray);
                        DmaObject->PteArray = NULL;
                    }
                    DmaObject->State &= ~DMA_RELOAD;
                }
                DmaObject = DmaObject->Next;
            }
#endif //KJK
            break;
        case STATE_UNLOAD:
            //
            // Unload all DMA instances.
            //
#ifdef KJK            
            DmaObject = pDev->DBDmaList;
            while (DmaObject)
            {
                //
                // Unload instance.
                //    
                DBG_VAL_PTR(DmaObject);
                if (DmaObject->PteArray)
                {
                    dmaFreeInstance(pDev, DmaObject);
                    DmaObject->State |= DMA_RELOAD;
                }
                DmaObject = DmaObject->Next;
            }

            pDev->Dma.DmaInMemEmptyInstance = 0;
            pDev->Dma.DmaToMemEmptyInstance = 0;
            pDev->Dma.DmaFromMemEmptyInstance = 0;
#endif //KJK
            break;
        case STATE_INIT:
            pDev->DBDmaList = NULL;

#ifdef LEGACY_ARCH    
            pDev->Dma.DmaInMemEmptyInstance = 0;
            pDev->Dma.DmaToMemEmptyInstance = 0;
            pDev->Dma.DmaFromMemEmptyInstance = 0;
#endif // LEGACY_ARCH
            
            break;
        case STATE_DESTROY:
            break;
    }    
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dma\nv4\dmanv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** DMA Manager ********************************\
*                                                                           *
* Module: dmanv04.c                                                         *
*   The NV04 HAL DMA engine implementation is provided in this module.      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalDmaControl_NV04(VOID *);
RM_STATUS nvHalDmaAlloc_NV04(VOID *);
RM_STATUS nvHalDmaFree_NV04(VOID *);
RM_STATUS nvHalDmaGetInstSize_NV04(VOID *);

//
// nvHalDmaControl
//
// Nothing to do here.
//
RM_STATUS
nvHalDmaControl_NV04(VOID *arg)
{
    PDMACONTROLARG_000 pDmaControlArg = (PDMACONTROLARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDmaControlArg->id != DMA_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    switch (pDmaControlArg->cmd)
    {
        case DMA_CONTROL_UPDATE:
        case DMA_CONTROL_LOAD:
        case DMA_CONTROL_UNLOAD:
        case DMA_CONTROL_DESTROY:
        case DMA_CONTROL_INIT:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalDmaAlloc
//
// Initialize dma instance.
//
RM_STATUS
nvHalDmaAlloc_NV04(VOID *arg)
{
    PDMAALLOCARG_000 pDmaAllocArg = (PDMAALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALOBJINFO pDmaHalObjInfo;
    PDMAHALINFO pDmaHalInfo;
    PHWREG nvAddr;
    U032 adjust, i;

    //
    // Verify interface revision.
    //
    if (pDmaAllocArg->id != DMA_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaAllocArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaAllocArg->pHalObjInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    adjust = 0;
    switch (pDmaHalObjInfo->classNum)
    {
        case NV1_CONTEXT_DMA_TO_MEMORY:     
        case NV_CONTEXT_DMA_TO_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_TO_MEMORY);
            break;
        case NV1_CONTEXT_DMA_FROM_MEMORY:     
        case NV_CONTEXT_DMA_FROM_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_FROM_MEMORY);
            break;
        case NV1_CONTEXT_DMA_IN_MEMORY:     
        case NV_CONTEXT_DMA_IN_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_IN_MEMORY);
            break;
    }
    adjust |= SF_NUM(_DMA, _ADJUST, pDmaHalObjInfo->PteAdjust);
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
        adjust |= SF_DEF(_DMA, _PAGE_ENTRY, _LINEAR);
    adjust |= SF_DEF(_DMA, _PAGE_TABLE, _PRESENT);
    switch (pDmaHalObjInfo->AddressSpace)
    {
        case ADDR_SYSMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _PCI);
            break;
        case ADDR_AGPMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _AGP);
            break;
        case ADDR_FBMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _NVM);
            break;
        default:
#ifdef DEBUG
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Invalid address space type\n\r");
            DBG_BREAKPOINT();
#endif
            return (RM_ERR_BAD_ARGUMENT);
    }
    //
    // Fill the page translation array.
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
    {    
        INST_WR32(pDmaHalObjInfo->Instance, 8, pDmaHalObjInfo->PteArray[0]);
        INST_WR32(pDmaHalObjInfo->Instance, 12, pDmaHalObjInfo->PteArray[0]); // better guard
    }        
    else 
    {   
        for (i = 0; i < pDmaHalObjInfo->PteCount; i++)
        {
            INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[i]);
        }
        //
        // Fill in the guard page with bogus data.  Only accessed by DMA engine,
        // not used in any transfer to system memory.
        //
        INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[0]);
    }
    //
    // Fill in rest of page table values.
    //
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_CLASS), adjust);
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_LIMIT), pDmaHalObjInfo->PteLimit);
    
    //
    // Add this dma context to the HAL table.
    //
    pDmaHalObjInfo->Next = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
    pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo;

    return (RM_OK);
}

//
// nvHalDmaFree
//
RM_STATUS
nvHalDmaFree_NV04(VOID *arg)
{
    PDMAFREEARG_000 pDmaFreeArg = (PDMAFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALINFO pDmaHalInfo;
    PDMAHALOBJINFO pDmaHalObjInfo, pDmaHalObjInfoDelete;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pDmaFreeArg->id != DMA_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaFreeArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaFreeArg->pHalObjInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Detach from DMA list.
    //
    if (pDmaHalInfo->pDmaHalObjInfos == (VOID_PTR)pDmaHalObjInfo)
        pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo->Next;
    else
    {
        pDmaHalObjInfoDelete = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
        while (pDmaHalObjInfoDelete->Next && pDmaHalObjInfoDelete->Next != pDmaHalObjInfo)
        {
            pDmaHalObjInfoDelete = pDmaHalObjInfoDelete->Next;
        }
        if (pDmaHalObjInfoDelete->Next)
            pDmaHalObjInfoDelete->Next = pDmaHalObjInfo->Next;
    }

    return (RM_OK);
}

//
// nvHalDmaGetInstSize
//
// Return number of *paragraphs* required for dma context in
// instance memory.
//
RM_STATUS
nvHalDmaGetInstSize_NV04(VOID *arg)
{
    PDMAGETINSTSIZEARG_000 pDmaGetInstSizeArg = (PDMAGETINSTSIZEARG_000)arg;
    PDMAHALOBJINFO pDmaHalObjInfo;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pDmaGetInstSizeArg->id != DMA_GET_INSTSIZE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaGetInstSizeArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaGetInstSizeArg->pHalObjInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Factor in an extra PTE so when the DMA engine prefetches, it
    // won't fault on a last access to a page.
    //
    
    //
    // Local memory contexts require only 1 paragraph (they're linear).
    // So do single page contexts in other address spaces (i.e. system memory).
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || ((pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM)))
        pDmaHalObjInfo->NumUnits = 1;
    else
    {
        if (pDmaHalObjInfo->PteCount == 1)
            pDmaHalObjInfo->NumUnits = 1;
        else
            pDmaHalObjInfo->NumUnits = 2 + (pDmaHalObjInfo->PteCount - 1) / 4;
    }
    
    return (RM_OK);
}

//
// dmaHalInstanceToHalInfo
//
RM_STATUS
dmaHalInstanceToHalInfo_NV04(U032 chid, U032 instance, PDMAHALOBJINFO *ppDmaHalObjInfo, PHALHWINFO pHalHwInfo)
{
    PDMAHALOBJINFO pDmaHalObjInfo;

    pDmaHalObjInfo = (PDMAHALOBJINFO)pHalHwInfo->pDmaHalInfo->pDmaHalObjInfos;
    while (pDmaHalObjInfo)
    {
        if (pDmaHalObjInfo->Instance == instance)
        {
            //
            // Found it!
            //
    	    *ppDmaHalObjInfo = pDmaHalObjInfo;
            return RM_OK;
        }
        pDmaHalObjInfo = pDmaHalObjInfo->Next;
    }

    *ppDmaHalObjInfo = NULL;  
    return RM_ERR_BAD_ARGUMENT;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dma\nv\dma.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************************* DMA Manager *****************************\
*                                                                           *
* Module: DMA.C                                                             *
*   The DMA engine is managed in this module.  All priviledged state and    *
*   object interaction is handled here.                                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <fifo.h>
#include <dma.h>
#include <gr.h>   
#include <fb.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "smp.h"

RM_STATUS dmaCreate
(
    VOID*               pDevHandle,
    PCLASSOBJECT        ClassObject,
    U032                UserName,
    POBJECT             *NewObject,
    VOID*               pCreateParms
)
{
    PHWINFO     pDev = (PHWINFO) pDevHandle;
    RM_STATUS   status = RM_OK;
    PDMAOBJECT  DmaObject;

    status = osAllocMem((VOID **)&DmaObject, sizeof(DMAOBJECT));
    if (status)
        return (status);
    DmaObject->State      = 0;
    DmaObject->Valid      = FALSE;
    DmaObject->LockHandle = 0;

    //
    // Initialize HAL info data.
    //
    DmaObject->HalInfo.PteArray     = NULL;
    DmaObject->HalInfo.Instance     = NULL;
    DmaObject->HalInfo.classNum     = ClassObject->Base.ThisClass->Type;
    DmaObject->HalInfo.MemoryClass  = 0;
    DmaObject->HalInfo.Flags        = 0;

    //
    // Add to dma context table.
    //
    DmaObject->Next       = pDev->DBDmaList;
    pDev->DBDmaList       = DmaObject;
    *NewObject            = (POBJECT)DmaObject;
    
#ifdef RM20
    //
    // Initialize the DMA object's client handle
    //
    CliGetClientHandle(&DmaObject->ClientHandle);
#endif    
    //
    // Get the address space associated with this DMA object
    //
    // Assume this is a system memory context first.  We may
    // reassign it later when we're looking at the physical
    // page locations.
    //
    DmaObject->HalInfo.AddressSpace = ADDR_SYSMEM;
    
#ifdef LEGACY_ARCH    
    //
    // Since we're about to put this new (unallocated) dma context
    // in the hash table, we need to point it at some PTE.  Point it
    // at an empty one so if anyone attempts to use this context
    // before its allocated, we'll get an error.  The PTE will be
    // exchanged with a valid entry once the dma context gets
    // allocated (locked).
    //
    // This step will disappear once we have the all-in-one
    // NvAllocDma() routine.
    //
    switch (ClassObject->Base.ThisClass->Type)  //KJK
    {
        case NV1_CONTEXT_DMA_TO_MEMORY:     
        case NV_CONTEXT_DMA_TO_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaToMemEmptyInstance;
            break;
        case NV1_CONTEXT_DMA_FROM_MEMORY:     
        case NV_CONTEXT_DMA_FROM_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaFromMemEmptyInstance;
            break;
        case NV1_CONTEXT_DMA_IN_MEMORY:     
        case NV_CONTEXT_DMA_IN_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaInMemEmptyInstance;
            break;
    }            
#endif // LEGACY_ARCH
        
    DmaObject->Base.Name  = UserName;
    DmaObject->Base.ChID  = ClassObject->Base.ChID;
    
#ifdef LEGACY_ARCH    
    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &DmaObject->Base, 
                                      DmaObject->Base.ChID, 
                                      DmaObject->HalInfo.Instance);

    if (status)
        return (status);                               
#endif
    
    return (status);
    
}
//
// Delete NV_CONTEXT_DMA_??_MEMORY object.
//
RM_STATUS dmaDelete
(
    VOID*   pDevHandle,
    POBJECT DelObject
)
{
    PHWINFO     pDev = (PHWINFO) pDevHandle;
    RM_STATUS   status;
    PDMAOBJECT  DmaObject;
    PDMAOBJECT  DmaDelete;
    
    DmaObject = (PDMAOBJECT)DelObject;
    status = RM_OK;
    
#ifdef LEGACY_ARCH
    //
    // If there are objects that are currently using this context, we are not allowed
    // to remove the dma context from the chip (hash).  We can unlock it (leaving it 
    // at a NULL PTE), but we can't just yank the whole thing.
    //
    // We probably need to scan all of instance memory and all on-chip context caches
    // and clear out any usage of this object.
    //
    // KJK How do we handle this correctly????  For now, just yank it.
    //
    status = fifoDeleteObjectInstance(pDev, DelObject, DelObject->ChID);
    if (status)
        return (status);
#endif        
    //
    // NOTE: In the new architecture, it is assumed that this object has 
    //       been removed from the hash table (if necessary).
    
    //
    // Are we locked somewhere?
    //
    if (DmaObject->Valid)
    {
        //
        // Free all memory allocated to this object.
        //
        if (DmaObject->HalInfo.PteArray)
        {
            //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: DMA buffer resoures still allocated at delete time!\n\r");
            //DBG_BREAKPOINT();
            dmaFreeInstance(pDev, DmaObject);
            osUnlockUserMem(
						    pDev,
						    DmaObject->Base.ChID,
                            (VOID*)DmaObject->HalInfo.BufferBase,
                            DmaObject->DescAddr,
                            DmaObject->HalInfo.AddressSpace,
                            DmaObject->DescLimit,
                            DmaObject->HalInfo.PteCount,
                            DmaObject->LockHandle,
                            (DmaObject->Base.Class->Type == NV1_CONTEXT_DMA_TO_MEMORY) ||
                            (DmaObject->Base.Class->Type == NV_CONTEXT_DMA_TO_MEMORY) ? TRUE : FALSE);
            osFreeMem(DmaObject->HalInfo.PteArray);
            DmaObject->HalInfo.PteArray = NULL;
        }
        if (pDev->DBDmaList == NULL)        
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: DMA list NULL in DMADELETE!\n\n");
            DBG_BREAKPOINT();
        }

        //
        // Detach from DMA list.
        //
        if (pDev->DBDmaList == DmaObject)
            pDev->DBDmaList = DmaObject->Next;
        else
        {
            DmaDelete = pDev->DBDmaList;
            while (DmaDelete->Next && DmaDelete->Next != DmaObject)
            {
                DBG_VAL_PTR(DmaDelete);
                DmaDelete = DmaDelete->Next;
            }
            if (DmaDelete->Next)
                DmaDelete->Next = DmaObject->Next;
        }    
        status = osFreeMem(DmaObject);
    }
    
    return (status);
}

//
// Find a specific DMA object based upon its instance
//
RM_STATUS dmaContextInstanceToObject
(
    PHWINFO  pDev,
    U032     ChID,
    U032     Instance,
    PDMAOBJECT *DmaObject
)
{
    PDMAOBJECT TempDmaList;
    U032 hClient;
    RM_STATUS status;
    
    //
    // Are there any dma objects available?
    //
    if (!pDev->DBDmaList)
    {    
        *DmaObject = NULL;    
        return (RM_ERR_BAD_OBJECT);
    }        
        
#ifdef RM20  
    // First we must establish a client via the Channel ID.
    status = CliGetClientHandleFromChID(pDev, ChID, &hClient);
    if (status)
    {
        *DmaObject = NULL;    
        return (status);
    }
      
    //
    // Walk the list looking for this object by matching the client and the instance
    //
    TempDmaList = pDev->DBDmaList;
    while (TempDmaList)        
    {
        if ((TempDmaList->ClientHandle == hClient) && (TempDmaList->HalInfo.Instance == Instance))
        {
            //
            // Found it!
            //
            *DmaObject = TempDmaList;
            return (RM_OK);
        }
        TempDmaList = TempDmaList->Next;
    }
#else
    //
    // Walk the list looking for this object by matching the channel and the instance
    //
    TempDmaList = pDev->DBDmaList;
    while (TempDmaList)        
    {
        if ((TempDmaList->Base.ChID == ChID) && (TempDmaList->HalInfo.Instance == Instance))
        {
            //
            // Found it!
            //
            *DmaObject = TempDmaList;
            return (RM_OK);
        }
        TempDmaList = TempDmaList->Next;
    }
#endif
    *DmaObject = NULL;    
    return (RM_ERR_BAD_OBJECT);        
}

//
// Validate DMA object name.
//
RM_STATUS dmaValidateObjectName
(
    PHWINFO     pDev,
    V032        ObjectName,
    U032        ChID,
    PDMAOBJECT *DmaObject
)
{
    U032 hClient;
    RM_STATUS status;

    //
    // Check for NULL object.
    //
    if (ObjectName == NV1_NULL_OBJECT)
    {
        *DmaObject = NULL;
        return (RM_WARN_NULL_OBJECT);
    }
    status = fifoSearchObject(pDev, ObjectName, ChID, (POBJECT *)DmaObject);
    if (status)
    {
#ifdef RM20
        // attempt to find the object in the global DMA list
        // the client handle is also needed for this lookup
        status = CliGetClientHandleFromChID(pDev, ChID, &hClient);
        if (status)
        {
            *DmaObject = NULL;
            return (status);
        }
        status = dmaFindContext(pDev, ObjectName, hClient, DmaObject);
        if (status)
        {
            *DmaObject = NULL;
            return (status);
        }
        
#ifdef LEGACY_ARCH
        // CWJ: DMA objects don't exist in the FIFO tree with the new arch.
        // add the DMA context to the FIFO's object tree if it is unused
        if ((*DmaObject)->Base.ChID == INVALID_CHID)
        {
            (*DmaObject)->Base.ChID = ChID;
            status = fifoAddObject(pDev, (POBJECT)*DmaObject);
            if (status)
            {
                return (status);
            }
        }
        else
        {
            // return RM_ERR_BAD_DMA_SPECIFIER;
        }
#endif
#else
        // not finding the object in the tree is an error
        *DmaObject = NULL;
        return (status);
#endif // RM20
    }
    if (((*DmaObject)->Base.Class->Type != NV1_CONTEXT_DMA_FROM_MEMORY)
    &&  ((*DmaObject)->Base.Class->Type != NV1_CONTEXT_DMA_TO_MEMORY)
    &&  ((*DmaObject)->Base.Class->Type != NV1_CONTEXT_DMA_IN_MEMORY)
    &&  ((*DmaObject)->Base.Class->Type != NV_CONTEXT_DMA_FROM_MEMORY)
    &&  ((*DmaObject)->Base.Class->Type != NV_CONTEXT_DMA_TO_MEMORY)
    &&  ((*DmaObject)->Base.Class->Type != NV_CONTEXT_DMA_IN_MEMORY))
        return (RM_ERR_OBJECT_TYPE_MISMATCH);
    return (RM_OK);
}

#ifdef RM20
// find a DMA context in the list
RM_STATUS dmaFindContext(PHWINFO pDev, U032 id, U032 hClient, PDMAOBJECT *ppDmaObject)
{
    for (*ppDmaObject = pDev->DBDmaList; *ppDmaObject; *ppDmaObject = (*ppDmaObject)->Next)
        if (((*ppDmaObject)->Base.Name == id) &&
                ((*ppDmaObject)->ClientHandle == hClient))
            break;

    return (*ppDmaObject) ? RM_OK : 1;

} // end of dmaFindContext()
#endif // RM20

RM_STATUS dmaValidateXlate
(
    PDMAOBJECT DmaObject,
    U032       Start,
    U032       Length
)
{
    if (DmaObject == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid DMA context in dmaValidateXlate\n\r");
        DBG_BREAKPOINT();
        return (RM_ERR_INVALID_XLATE);
    }
    DBG_VAL_PTR(DmaObject);
#if DEBUG
    if ((DmaObject->Base.Class->Type != NV1_CONTEXT_DMA_TO_MEMORY)
    &&  (DmaObject->Base.Class->Type != NV1_CONTEXT_DMA_FROM_MEMORY)
    &&  (DmaObject->Base.Class->Type != NV1_CONTEXT_DMA_IN_MEMORY)
    &&  (DmaObject->Base.Class->Type != NV_CONTEXT_DMA_TO_MEMORY)
    &&  (DmaObject->Base.Class->Type != NV_CONTEXT_DMA_FROM_MEMORY)
    &&  (DmaObject->Base.Class->Type != NV_CONTEXT_DMA_IN_MEMORY))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Bad type in dmaValidateXlate\n\r");
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }
#endif // DEBUG
    if (!DmaObject->Valid)
        return (RM_ERR_INVALID_XLATE);
    if ((Start + Length - 1) > DmaObject->DescLimit)
        return (RM_ERR_INVALID_START_LENGTH);
    return (RM_OK);
}

//
// Allocate and lock memory associated with this DMA object
//
RM_STATUS dmaAllocate
(
    PHWINFO    pDev,
    PDMAOBJECT DmaObject
)
{
    RM_STATUS status;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: DMA Allocate\n\r");

    DBG_VAL_PTR(DmaObject);
    //
    // Make sure its valid.
    //
    if (!DmaObject->Valid)
        return (RM_ERR_INVALID_XLATE);
    //
    // Get memory translation.
    //
    if (!DmaObject->HalInfo.PteArray)
    {
        //
        // Save off class of this dma context object.
        //
        DmaObject->HalInfo.classNum      = DmaObject->Base.ThisClass->Type;

        //
        // These members are for future use to make sure we pass
        // any hardware error checking involving new context dma
        // class parameters.
        // 
        DmaObject->HalInfo.Flags      = 0;
        DmaObject->HalInfo.MemoryClass = 0;

        //
        // Calculate page table values.
        //    
        DmaObject->HalInfo.BufferSize = DmaObject->DescLimit  + 1;
        osCalculatePteAdjust(pDev, DmaObject->HalInfo.AddressSpace, DmaObject->DescAddr, &DmaObject->HalInfo.PteAdjust);
        DmaObject->HalInfo.PteLimit   = DmaObject->DescLimit; //DmaObject->BufferSize + DmaObject->PteAdjust;
        DmaObject->HalInfo.PteCount   =
            (DmaObject->HalInfo.PteLimit + DmaObject->HalInfo.PteAdjust + RM_PAGE_SIZE - 1) >> RM_PAGE_SHIFT;
        status = osAllocMem((VOID **)&(DmaObject->HalInfo.PteArray), DmaObject->HalInfo.PteCount * 4);
        if (status)
        {
            DmaObject->HalInfo.BufferBase = NULL;
            DmaObject->HalInfo.PteArray   = NULL;
            return (RM_ERR_NO_FREE_MEM);
        }

        //
        // Lock and map DMA buffer.
        //    
        if (osLockUserMem(
						  pDev,
						  DmaObject->Base.ChID,
                          DmaObject->DescSelector,
                          DmaObject->DescOffset,
                          DmaObject->DescAddr,
                          &(DmaObject->HalInfo.AddressSpace),
                          DmaObject->DescLimit,
                          DmaObject->HalInfo.PteCount,
                          DmaObject->HalInfo.PteArray,
                          (VOID**)&(DmaObject->HalInfo.BufferBase),
                          &(DmaObject->LockHandle)) != RM_OK)
        {
            osFreeMem(DmaObject->HalInfo.PteArray);
            DmaObject->HalInfo.BufferBase = NULL;
            DmaObject->HalInfo.PteArray   = NULL;
            return (RM_ERR_DMA_MEM_NOT_LOCKED);
        }
        //
        // Get DMA instance for page table mapping.
        //
        status = dmaAllocInstance(pDev, DmaObject);
        if (status)
        {
            DmaObject->Valid = FALSE;
            osUnlockUserMem(
							pDev,
							DmaObject->Base.ChID,
                            (VOID*)DmaObject->HalInfo.BufferBase,
                            DmaObject->DescAddr,
                            DmaObject->HalInfo.AddressSpace,
                            DmaObject->DescLimit,
                            DmaObject->HalInfo.PteCount,
                            DmaObject->LockHandle,
                            (DmaObject->Base.Class->Type == NV1_CONTEXT_DMA_TO_MEMORY) ||
                            (DmaObject->Base.Class->Type == NV_CONTEXT_DMA_TO_MEMORY) ? TRUE : FALSE);
            osFreeMem(DmaObject->HalInfo.PteArray);
            DmaObject->HalInfo.BufferBase = NULL;
            DmaObject->HalInfo.PteArray   = NULL;
            return (status);
        }

        //
        // Call into HAL to handle h/w-dependent initialization.
        //
        status = nvHalDmaAlloc(pDev, &DmaObject->HalInfo);
        if (status)
        {
            DmaObject->Valid = FALSE;
            osUnlockUserMem(
							pDev,
							DmaObject->Base.ChID,
                            (VOID*)DmaObject->HalInfo.BufferBase,
                            DmaObject->DescAddr,
                            DmaObject->HalInfo.AddressSpace,
                            DmaObject->DescLimit,
                            DmaObject->HalInfo.PteCount,
                            DmaObject->LockHandle,
                            (DmaObject->Base.Class->Type == NV1_CONTEXT_DMA_TO_MEMORY) ||
                            (DmaObject->Base.Class->Type == NV_CONTEXT_DMA_TO_MEMORY) ? TRUE : FALSE);
            osFreeMem(DmaObject->HalInfo.PteArray);
            DmaObject->HalInfo.BufferBase = NULL;
            DmaObject->HalInfo.PteArray   = NULL;
            return (RM_ERR_BAD_DMA_SPECIFIER);      // ???
        }
    }

    return (RM_OK);
}

RM_STATUS dmaDeallocate
(
    PHWINFO    pDev,
    PDMAOBJECT DmaObject
)
{
    PNODE             node;
    U032              ChID;
    U032              Instance;
    U032              EngTag;

    //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Dma Dealloc\n\r");

    DBG_VAL_PTR(DmaObject);
    //
    // Check for resources to free up.
    //
    if (DmaObject->HalInfo.PteArray)
    {
        //
        // If there are objects that are currently using this context, we cannot allow any
        // modifications!!
        //
        for (ChID = 0 ; ChID < NUM_FIFOS ; ChID++)
        {
            if (pDev->DBfifoTable[ChID].InUse)
            {

                // 
                // Go find the minimum value (>0) and start there.  That way we're
                // sure to visit every node.
                //
                btreeEnumStart(0, &node, pDev->DBfifoTable[ChID].ObjectTree);

                while (node != NULL)
                {
                    //
                    // If this is a hardware object
                    //
                    EngTag = ENGDECL_FIELD(*((POBJECT)(node->Data))->Class->EngineDecl, _TAG);
                    if (EngTag == GR_ENGINE_TAG)
                    {
                        //
                        // Find the dma context field in this object's context instance
                        //
                        Instance = ((PCOMMONOBJECT)(node->Data))->Instance;
                        
                        //
                        // If it is currently being used by any object, don't allow
                        // any adjustments
                        //
                        if (Instance)
                        {
                            if (RAM_RD_ISF(Instance, _PRAMIN_CTX_1, _NOTIFY_INSTANCE) == DmaObject->HalInfo.Instance)
                                return(NVFFE_NOTIFICATION_STATUS_ERROR_STATE_IN_USE);
                            if (RAM_RD_ISF(Instance, _PRAMIN_CTX_2, _DMA_0_INSTANCE) == DmaObject->HalInfo.Instance)
                                return(NVFFE_NOTIFICATION_STATUS_ERROR_STATE_IN_USE);
                            if (RAM_RD_ISF(Instance, _PRAMIN_CTX_2, _DMA_1_INSTANCE) == DmaObject->HalInfo.Instance)
                                return(NVFFE_NOTIFICATION_STATUS_ERROR_STATE_IN_USE);
                        }                            

                    }

                    btreeEnumNext(&node, pDev->DBfifoTable[ChID].ObjectTree);
                }
            }
        }

        //
        // Now free the DMA object
        //
        dmaFreeInstance(pDev, DmaObject);
        osUnlockUserMem(
						pDev,
						DmaObject->Base.ChID,
                        (VOID*)DmaObject->HalInfo.BufferBase,
                        DmaObject->DescAddr,
                        DmaObject->HalInfo.AddressSpace,
                        DmaObject->DescLimit,
                        DmaObject->HalInfo.PteCount,
                        DmaObject->LockHandle,
                        (DmaObject->Base.Class->Type == NV1_CONTEXT_DMA_TO_MEMORY) ||
                        (DmaObject->Base.Class->Type == NV_CONTEXT_DMA_TO_MEMORY) ? TRUE : FALSE);
        osFreeMem(DmaObject->HalInfo.PteArray);
        DmaObject->HalInfo.BufferBase = NULL;
        DmaObject->HalInfo.PteArray   = NULL;
    }
    
#ifdef LEGACY_ARCH
    //
    // Point back to the NULL PTE
    //
    switch (DmaObject->Base.Class->Type)
    {
        case NV1_CONTEXT_DMA_TO_MEMORY:     
        case NV_CONTEXT_DMA_TO_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaToMemEmptyInstance;
            break;
        case NV1_CONTEXT_DMA_FROM_MEMORY:     
        case NV_CONTEXT_DMA_FROM_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaFromMemEmptyInstance;
            break;
        case NV1_CONTEXT_DMA_IN_MEMORY:     
        case NV_CONTEXT_DMA_IN_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaInMemEmptyInstance;
            break;
    }            
#endif LEGACY_ARCH
    

    return (RM_OK);
}

//
// Return the mapped address of a DMA buffer.
// We need to special case an ADDR_FBMEM mapping, since RmAllocContextDma converted
// the BufferBase field to an FB offset. So to return the correct mapping, we use our
// RM mapping to the FB memory.
//
RM_STATUS dmaGetMappedAddress
(
    PHWINFO    pDev,
    PDMAOBJECT DmaObject,
    U032       Start,
    U032       Length,
    VOID     **Address
)
{
    RM_STATUS status;

    if ((DmaObject == NULL) || (!DmaObject->Valid))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid DMA context in dmaGetMappedAddress\n\r");
        DBG_BREAKPOINT();
        return (RM_ERR_INVALID_XLATE);
    }
    DBG_VAL_PTR(DmaObject);
    status = dmaValidateXlate(DmaObject, Start, Length);
    if (status)
        return (status);
    if (!DmaObject->HalInfo.PteArray ||
        (!DmaObject->HalInfo.BufferBase && DmaObject->HalInfo.AddressSpace != ADDR_FBMEM))
        return (RM_ERR_DMA_MEM_NOT_LOCKED);
	if (DmaObject->HalInfo.AddressSpace == ADDR_FBMEM)
        *Address = (U008*)fbAddr + (SIZE_PTR)DmaObject->HalInfo.BufferBase + Start;      // BufferBase is an FB offset
    else
	    *Address = (U008*)DmaObject->HalInfo.BufferBase + Start;
    return (RM_OK);
}

//
// Allocate a DMA instance in offscreen memory.  This involves locking
// the physical pages in memory, getting the translation table, and
// adding the object to the instance list.
//
RM_STATUS dmaAllocInstance
(
    PHWINFO pDev,
    PDMAOBJECT DmaObject
)
{
    RM_STATUS    status;

    DBG_VAL_PTR(DmaObject);
    //
    // Only alloc valid buffers.
    //    
    if ((DmaObject == NULL) || (!DmaObject->Valid))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid DMA context in dmaAllocInstance\n\r");
        DBG_BREAKPOINT();
        return (RM_ERR_INVALID_XLATE);
    }
    //
    // Allocate some instance memory.  Allocate an extra PTE so when the 
    // DMA engine prefetches, it won't fault on a last access to a page.
    //
    //
    status = nvHalDmaGetInstSize(pDev, &DmaObject->HalInfo);
    if (status)
        return (RM_ERR_BAD_DMA_SPECIFIER);      // ???
    status = fbAllocInstMem(pDev, &(DmaObject->HalInfo.Instance), DmaObject->HalInfo.NumUnits);
    if (status)
        return (status);
    
    //
    // Is this supposed to be a real AGP context?  We need to verify the addresses
    // fall within the GART space that DirectDraw has already told us about.  If not,
    // we must assume this is normal PCI memory and treat it as such.
    //
    // This check is not for the NV-specific AGP implementation.  That approach
    // uses our own GART.
    //
    // NOTE: This isn't needed anymore now that osGetAddressInfo does its own internal
    // scan for AGP memory.  But keep it around in case we need it back in the future.
    //
    /*
    if ((DmaObject->AddressSpace == ADDR_AGPMEM) && !pDev->Chip.NVAGPEnabled)
    {
        if (!((DmaObject->DescOffset >= pDev->Mapping.AGPLinearStart) 
            && (DmaObject->DescOffset <= (pDev->Mapping.AGPLinearStart + pDev->Mapping.AGPLimit))))
                // not really AGP memory
                DmaObject->AddressSpace = ADDR_SYSMEM;
    }
    */

    return (RM_OK);
}
//
// Free DAM instance memory associated with a DMA context and unlock the pages.
//
RM_STATUS dmaFreeInstance
(
    PHWINFO    pDev,
    PDMAOBJECT DmaObject
)
{
    DBG_VAL_PTR(DmaObject);
    if (DmaObject == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NULL object in dmaFreeInstance!\n\r");
        return (RM_OK);
    }
    //
    // Free instance page table plus guard page.
    //
    fbFreeInstMem(pDev, DmaObject->HalInfo.Instance, DmaObject->HalInfo.NumUnits);
    DmaObject->HalInfo.Instance   = 0;

    return (RM_OK);    
}

RM_STATUS dmaRegisterToDevice
(
    PHWINFO pDev, 
    PCLI_DMA_INFO pDmaInfo, 
    PDMAOBJECT *ppDmaObject
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLASS      DmaClass;
    CLASSOBJECT DmaClassObject;
    PDMAOBJECT  pDmaObject;

    rmStatus = classGetClass(&pDev->classDB, pDmaInfo->Access, &DmaClass);
    if (rmStatus)
        return rmStatus;

    // initialize parts of DmaClassObject for use in dmaCreate
    DmaClassObject.Base.ChID = INVALID_CHID;
    DmaClassObject.Base.ThisClass = DmaClass;
    rmStatus = dmaCreate((VOID*)pDev, &DmaClassObject, 0, (POBJECT *)&pDmaObject, NULL);

    if (rmStatus)
        return rmStatus;
    pDmaObject->Base.Name               = pDmaInfo->Handle;
    pDmaObject->Base.ChID               = INVALID_CHID;
    pDmaObject->Base.Class              = DmaClass;
    pDmaObject->Base.Subchannel         = 0;
    pDmaObject->Base.Next               = 0;
    pDmaObject->Base.NotifyXlate        = 0;
    pDmaObject->Base.NotifyAction       = 0;
    pDmaObject->Base.NotifyTrigger      = 0;
    pDmaObject->DescSelector            = pDmaInfo->DescSelector;
    pDmaObject->DescOffset              = pDmaInfo->DescOffset;
    pDmaObject->DescLimit               = pDmaInfo->DescLimit;
    pDmaObject->DescAddr                = pDmaInfo->DescAddr;
    pDmaObject->LockCount               = 0;
    pDmaObject->LockHandle              = pDmaInfo->LockHandle;
    pDmaObject->Valid                   = TRUE;
    pDmaObject->NotifyActionHandle      = 0;
    pDmaObject->HalInfo.BufferBase      = (VOID_PTR)pDmaInfo->BufferBase;
    pDmaObject->HalInfo.BufferSize      = pDmaInfo->BufferSize;
    pDmaObject->HalInfo.PteCount        = pDmaInfo->PteCount;

    pDmaObject->HalInfo.PteAdjust       = pDmaInfo->PteAdjust;
    pDmaObject->HalInfo.PteLimit        = pDmaInfo->PteLimit;
    pDmaObject->HalInfo.PteArray        = pDmaInfo->PteArray;
    pDmaObject->HalInfo.AddressSpace    = pDmaInfo->AddressSpace;

    // get DMA instance for page table mapping in the given device
    rmStatus = dmaAllocInstance(pDev, pDmaObject);
    if (rmStatus != RM_OK)
    {
        dmaDelete((VOID*)pDev, (POBJECT)pDmaObject);
        return rmStatus;
    }

    //
    // Call into HAL to handle h/w-dependent initialization.
    //
    if (nvHalDmaAlloc(pDev, &pDmaObject->HalInfo) != RM_OK)
    {
        return (RM_ERR_BAD_DMA_SPECIFIER);      // ???
    }

    // Success.
    *ppDmaObject = pDmaObject;
    return RM_OK;
}

RM_STATUS dmaUnregisterFromDevice
(
   PHWINFO     pDev,
   PDMAOBJECT  pDmaObject
)
{
    RM_STATUS rmStatus;

    //
    // Call into HAL to release h/w-dependent resources.
    //
    if (nvHalDmaFree(pDev, &pDmaObject->HalInfo) != RM_OK)
    {
        return (RM_ERR_BAD_DMA_SPECIFIER);      // ???
    }
    
    rmStatus = dmaFreeInstance(pDev, pDmaObject);
    if (rmStatus)
    {
        return rmStatus;
    }

    // delete DMA object for the device in the context of the device
    rmStatus = dmaDelete((VOID*)pDev, (POBJECT)pDmaObject);
    return rmStatus;
}

RM_STATUS dmaBindToChannel
(
    PHWINFO    pDev, 
    PDMAOBJECT pDmaObject, 
    U032       ChID
)
{
    RM_STATUS rmStatus = RM_OK;
    
    //
    // CWJ: don't add the DMA object to the pDev->DBfifoTable[ChID] in NV4. We don't
    // use the pDev->DBfifoTable[] for look-ups in NV4 and since there's a single
    // Node field it's unable to exist on more than a one fifoTable, just
    // skip it.
    //
    // rmStatus = fifoAddDmaObject(pDev, (POBJECT)pDmaObject, pFifoInfo->ChID);
    // if (rmStatus != RM_OK)
    // {
    //  return rmStatus;
    // }

    // update the hash table
    rmStatus = fifoUpdateObjectInstance(pDev,
                                        &pDmaObject->Base,
                                        ChID,
                                        pDmaObject->HalInfo.Instance);

    return rmStatus;
}

RM_STATUS dmaUnbindFromChannel
(
   PHWINFO    pDev,
   PDMAOBJECT pDmaObject,
   U032       ChID
)
{
    RM_STATUS rmStatus;
    
    // Delete this dma context object for this ChID from the hash table.
    rmStatus = fifoDeleteObjectInstance(pDev, (POBJECT)pDmaObject, ChID);
    return rmStatus;
}

//---------------------------------------------------------------------------
//
//  DMA object methods.
//
//---------------------------------------------------------------------------

//
// Validate and calculate new specifier parameters.
//
RM_STATUS mthdSetDmaSpecifier
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PDMAOBJECT DmaObject;
    PCLASS pClass;
    RM_STATUS  status;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: mthdDmaSpecifier\n\r");

    DmaObject = (PDMAOBJECT)Object;
    pClass = Object->Class;

    //
    // Make sure the graphics engine is idle before we steal the DMA context
    //
    GR_IDLE();

    //
    // If already in use...
    //
    if (DmaObject->Valid)
    {
        //
        // Unallocate the previous lock
        //
        status = dmaDeallocate(pDev, DmaObject);
        if (status)
            return (status);
        //
        // And update the instance
        //
        status = fifoUpdateObjectInstance(pDev, 
                                          &DmaObject->Base, 
                                          DmaObject->Base.ChID, 
                                          DmaObject->HalInfo.Instance);
        if (status)
            return (status);                               
            
    }    
    //
    // Validate specifier.
    //
    DmaObject->Valid = FALSE;
    switch (Offset)
    {
        case 0x0300:
            DmaObject->State        = DMA_SET_DESC_0;
            // TO DO: this is a known truncation for IA64
            DmaObject->DescOffset   = (VOID*)Data;
            break;
        case 0x0304:
            if (DmaObject->State != DMA_SET_DESC_0)
                return (RM_ERR_METHOD_COUNT);
            DmaObject->State        = DMA_SET_DESC_1;
            DmaObject->DescSelector = Data;
            break;
        case 0x0308:
            if (DmaObject->State != DMA_SET_DESC_1)
                return (RM_ERR_METHOD_COUNT);
            DmaObject->State     = DMA_SET_DESC_2;
            DmaObject->DescLimit = Data;

            //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetDesc1 = ", Data);
            //
            // If the user sets a 0 limit on the DMA object, then
            // he is not using the buffer. Don't return an error
            // but also don't validate the buffer.
            //
            if (DmaObject->DescLimit != 0)
            {
               //
               // Validate DMA buffer address.
               //
               if (osGetAddressInfo(pDev,
                                    DmaObject->Base.ChID, 
                                    DmaObject->DescSelector,
                                    &(DmaObject->DescOffset),
                                    DmaObject->DescLimit,
                                    &(DmaObject->DescAddr), 
                                    &(DmaObject->HalInfo.AddressSpace)) != RM_OK)
                   return (RM_ERR_BAD_DMA_SPECIFIER);
                //
                // Now attempt to lock the context
                //                   
                DmaObject->Valid = TRUE;
                status = dmaAllocate(pDev, DmaObject);
                if (status)
                    return (status);
                //
                // And update the instance
                //
                status = fifoUpdateObjectInstance(pDev, 
                                                  &DmaObject->Base, 
                                                  DmaObject->Base.ChID, 
                                                  DmaObject->HalInfo.Instance);
                if (status)
                    return (status);                               
                                    
            }
    }
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  DMA buffer object methods.
//
//---------------------------------------------------------------------------

RM_STATUS mthdSetBufferCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(dmaSetBufferCtxDma(pDev, BuffObject, &BuffObject->Buffer[BuffNum], Offset, Data));
}

RM_STATUS dmaSetBufferCtxDma
(
    PHWINFO       pDev, 
    PBUFFEROBJECT BuffObject,
    PBUFFER       pBuffer,
    U032          Offset,
    V032          Data
)
{
    RM_STATUS     status;

    //
    // Check for busy buffer.
    //
/*    
    if (pBuffer->State != BUFFER_IDLE)
    {
        osError(&BuffObject->Base, Offset, Data, status);
        return (RM_ERR_DMA_IN_USE);
    }
*/    
    //
    // Check for a previous translation.
    //
    //if (pBuffer->Xlate)
    //    dmaDetach(pBuffer->Xlate);
    //
    // Check for NULL object.
    //
    if (Data == NV1_NULL_OBJECT)
    {
        pBuffer->Xlate = NULL;
        return (RM_OK);
    }
    //
    // Validate dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   BuffObject->Base.ChID,
                                   &pBuffer->Xlate);
    if (status)
    {
        osError(&BuffObject->Base, Offset, Data, status);
        return (status);
    }
    //
    // Set the method to be used for notification on this buffer
    //
    pBuffer->NotifyMethod = Offset;
    return (status);
}

RM_STATUS mthdSetBufferStart
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    U032          BuffNum;
    PBUFFEROBJECT BuffObject;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(dmaSetBufferStart(BuffObject, &BuffObject->Buffer[BuffNum], Offset, Data));
}

RM_STATUS dmaSetBufferStart
(
    PBUFFEROBJECT BuffObject,
    PBUFFER       pBuffer,
    U032          Offset,
    V032          Data
)
{
    //
    // Check for busy buffer.
    //
/*    
    if (pBuffer->State != BUFFER_IDLE)
    {
        osError(&BuffObject->Base, Offset, Data, RM_ERR_DMA_IN_USE);
        return (RM_ERR_DMA_IN_USE);
    }
*/    
    pBuffer->Start = Data;
    return (RM_OK);
}

RM_STATUS mthdSetBufferLength
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    U032 BuffNum;
    PBUFFEROBJECT BuffObject;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(dmaSetBufferLength(BuffObject, &BuffObject->Buffer[BuffNum], Offset, Data));
}

RM_STATUS dmaSetBufferLength
(
    PBUFFEROBJECT BuffObject,
    PBUFFER       pBuffer,
    U032          Offset,
    V032          Data
)
{
    //
    // Check for busy buffer.
    //
/*    
    if (pBuffer->State != BUFFER_IDLE)
    {
        osError(&BuffObject->Base, Offset, Data, RM_ERR_DMA_IN_USE);
        return (RM_ERR_DMA_IN_USE);
    }
*/    
    pBuffer->Length = Data;
    return (RM_OK);
}

RM_STATUS mthdSetBufferPitch
(
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    U032 BuffNum;
    PBUFFEROBJECT BuffObject;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(dmaSetBufferPitch(BuffObject, &BuffObject->Buffer[BuffNum], Offset, Data));
}

RM_STATUS dmaSetBufferPitch
(
    PBUFFEROBJECT BuffObject,
    PBUFFER       pBuffer,
    U032          Offset,
    V032          Data
)
{
    //
    // Check for busy buffer.
    //
/*    
    if (pBuffer->State != BUFFER_IDLE)
    {
        osError(&BuffObject->Base, Offset, Data, RM_ERR_DMA_IN_USE);
        return (RM_ERR_DMA_IN_USE);
    }
*/    
    pBuffer->Pitch = Data;
    return (RM_OK);
}

RM_STATUS mthdSetSampleRate
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    ((PBUFFEROBJECT)Object)->Sample.Rate = Data;
    ((PBUFFEROBJECT)Object)->Sample.RateUpdate((PBUFFEROBJECT)Object);
    return (RM_OK);
}
RM_STATUS mthdSetSampleRateAdjust
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    ((PBUFFEROBJECT)Object)->Sample.RateAdjust = Data;
    ((PBUFFEROBJECT)Object)->Sample.RateUpdate((PBUFFEROBJECT)Object);
    return (RM_OK);
}
RM_STATUS mthdSetNumberChannels
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    ((PBUFFEROBJECT)Object)->Sample.NumChannels = Data;
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  DMA service routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dma\nv\notify.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************************* DMA Manager *****************************\
*                                                                           *
* Module: NOTIFY.C                                                          *
*   Method notifications are handled in this module.  DMA report and OS     *
*   action are dealt with on a per-object basis.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <fifo.h>
#include <dma.h>   
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
//
// Method notifications.
//
RM_STATUS mthdSetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS status;
    
    if (Object->NotifyTrigger)
        return (RM_ERR_DMA_IN_USE);
    //
    // Check for previous dma buffer.
    //
	/* KJK
    if (Object->NotifyXlate)
    {
        dmaEndXfer(Object->NotifyXlate, NULL);
        dmaDetach(Object->NotifyXlate);
    }
	*/

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(Object->NotifyXlate));
    if (status)
    {
        osError(Object, Offset, Data, status);
        return (status);
    }
	/* KJK
    status = dmaAttach(Object->NotifyXlate);
    if (status)
    {
        osError(Object, Offset, Data, status);
        Object->NotifyXlate   = NULL;
        return (status);
    }
	*/
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(Object->NotifyXlate, 0, 0x000F);
    if (status)
    {
        Object->NotifyXlate   = NULL;
        osError(Object, Offset, Data, status);
        return (status);
    }
	/* KJK
    status = dmaBeginXfer(Object->NotifyXlate, NULL);
    if (status)
    {
        Object->NotifyXlate   = NULL;
        osError(Object, Offset, Data, status);
    }
	*/
    return (status);
}
RM_STATUS mthdSetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    Object->NotifyAction  = Data;
    Object->NotifyTrigger = TRUE;
    return (RM_OK);
}
//
// Dual buffer notifications.
//
RM_STATUS mthdSetBufferNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(notifySetBufferNotifyCtxDma(pDev, BuffObject, &BuffObject->Buffer[BuffNum], Offset, Data));
}
RM_STATUS notifySetBufferNotifyCtxDma
(
	PHWINFO       pDev,
    PBUFFEROBJECT BuffObject,
    PBUFFER       pBuffer,
    U032          Offset,
    U032          Data
)
{
    RM_STATUS status;

    //
    // Check for busy buffer.
    //
    if (pBuffer->State == BUFFER_BUSY)
    {
        osError(&BuffObject->Base, Offset, Data, RM_ERR_DMA_IN_USE);
        return (RM_ERR_DMA_IN_USE);
    }
    //
    // Check for previous dma buffer.
    //
	/* KJK
    if (pBuffer->NotifyXlate)
        dmaDetach(pBuffer->NotifyXlate);
	*/

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   BuffObject->Base.ChID,
                                   &(pBuffer->NotifyXlate));
    if (status)
    {
        pBuffer->NotifyXlate = NULL;
        return (status);
    }
	/* KJK
    status = dmaAttach(pBuffer->NotifyXlate);
    if (status)
    {
        pBuffer->NotifyXlate = NULL;
        return (status);
    }
	*/
    return (status);
}
RM_STATUS mthdSetBufferNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(notifySetBufferNotify(pDev, BuffObject, BuffNum, Offset, Data));
}
RM_STATUS notifySetBufferNotify
(
	PHWINFO       pDev,
    PBUFFEROBJECT BuffObject,
    U032          BuffNum,
    U032          Offset,
    U032          Data
)
{
    RM_STATUS status;
    PBUFFER   pBuffer = &BuffObject->Buffer[BuffNum];

    //
    // Check for busy buffer.
    //
    if (pBuffer->State == BUFFER_BUSY)
    {
        osError(&BuffObject->Base, Offset, Data, RM_ERR_DMA_IN_USE);
        return (RM_ERR_DMA_IN_USE);
    }
    pBuffer->NotifyAction = Data;
    //
    // Validate notification parameters.
    //    
    status = dmaValidateXlate(pBuffer->NotifyXlate, 0, 0x000F);
    if (status)
    {
        osError(&BuffObject->Base, Offset, Data, status);
        return (status);
    }
	/* KJK
    status = dmaBeginXfer(pBuffer->NotifyXlate, NULL);
    if (status)
    {
        osError(&BuffObject->Base, Offset, Data, status);
        return (status);
    }
	*/
    //
    // Validate buffer parameters.
    //    
    status = dmaValidateXlate(pBuffer->Xlate,
                              pBuffer->Start,
                              pBuffer->Length);
    if (status)
    {
        notifyFillNotifier(pDev, pBuffer->NotifyXlate, 0, 0, status);
        //KJK dmaEndXfer(pBuffer->NotifyXlate, NULL);
        if (pBuffer->NotifyAction)
        {
            osNotifyEvent(pDev,
                          (POBJECT)BuffObject,
            			  0,
                          Offset,
                          BuffObject->Base.Name,
                          status,
                          pBuffer->NotifyAction);
        }
        return (status);
    }
	/* KJK
    status = dmaBeginXfer(pBuffer->Xlate, NULL);
    if (status)
    {
        notifyFillNotifier(pDev, pBuffer->NotifyXlate, 0, 0, status);
        dmaEndXfer(pBuffer->NotifyXlate, NULL);
        if (pBuffer->NotifyAction)
        {
            osNotifyEvent((POBJECT)BuffObject,
            			  0,
                          Offset,
                          BuffObject->Base.Name,
                          status,
                          pBuffer->NotifyAction);
        }
        return (status);
    }
	*/
    //
    // Call the object specific routine to begin the transfer.
    //
    BuffObject->BufferComplete                     = notifyBufferComplete;
    pBuffer->State                                 = BUFFER_BUSY;
    pBuffer->NotifyCurrentCount                    = pBuffer->NotifyCount;
    if (pBuffer->Length == 0)
    {
        pBuffer->NotifyCurrentCount = 0;
        notifyBufferComplete(pDev, BuffObject, BuffNum, BuffObject->Base.Name, RM_OK);
    }
    else
    {
        status = BuffObject->BufferXfer(pDev, BuffObject, BuffNum);
        if (status)
            notifyBufferComplete(pDev, BuffObject, BuffNum, BuffObject->Base.Name, status);
    }
    return (status);
}
RM_STATUS mthdSetBufferNotifyCount
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;

    //
    // Update the count even if buffer is busy.
    //
    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    BuffObject->Buffer[BuffNum].NotifyCount        = Data;
    BuffObject->Buffer[BuffNum].NotifyCurrentCount = Data;
    return (RM_OK);
}
RM_STATUS mthdSetBufferPosNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    RM_STATUS     status;
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
    //
    // Check for previous dma buffer.
    //
	/* KJK
    if (BuffObject->Buffer[BuffNum].PosXlate)
    {
        dmaEndXfer(BuffObject->Buffer[BuffNum].PosXlate, NULL);
        dmaDetach(BuffObject->Buffer[BuffNum].PosXlate);
    }
	*/

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(BuffObject->Buffer[BuffNum].PosXlate));
    if (status)
    {
        BuffObject->Buffer[BuffNum].PosXlate = NULL;
        return (status);
    }
	/* KJK
    status = dmaAttach(BuffObject->Buffer[BuffNum].PosXlate);
    if (status)
    {
        BuffObject->Buffer[BuffNum].PosXlate = NULL;
        return (status);
    }
	*/
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(BuffObject->Buffer[BuffNum].PosXlate, 0, 0x000F);
    if (status)
    {
        BuffObject->Buffer[BuffNum].PosXlate = NULL;
        osError(Object, Offset, Data, status);
        return (status);
    }
	/* KJK
    status = dmaBeginXfer(BuffObject->Buffer[BuffNum].PosXlate, NULL);
    if (status)
    {
        BuffObject->Buffer[BuffNum].PosXlate = NULL;
        osError(Object, Offset, Data, status);
    }
	*/
    return (status);
}
RM_STATUS mthdSetBufferPosNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS     status;
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;
    U032          Position;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
    status     = BuffObject->BufferPos(pDev, BuffObject, BuffNum, &Position);
    if (status)
        return (status);
    notifyFillNotifier(pDev, BuffObject->Buffer[BuffNum].PosXlate, Position, 0, 0);
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Notification completion.
//
//---------------------------------------------------------------------------

RM_STATUS notifyDefaultError
(
	PHWINFO   pDev,
    POBJECT   Object,
    U032      Offset,
    V032      Data,
    U032      ChID,
    RM_STATUS CompletionStatus
)
{
    V032       ObjectName;
    PDMAOBJECT ErrNotifier;
    
    //
    // Check for error.
    //
    if (CompletionStatus & 0xFFFF)
    {
        //
        // Fill NV_ERROR_NOTIFIER if defined.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: method error ", CompletionStatus);
        if (Object)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "            object ", (U032)Object->Name);
            ObjectName = Object->Name;
        }
        else    
        {
            DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "            object NULL");
            ObjectName = 0;
        }
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "            offset ", Offset);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "              data ", Data);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "              chID ", ChID);
        if (fifoSearchObject(pDev, NV_CONTEXT_ERROR_TO_MEMORY, ChID, (POBJECT *)&ErrNotifier) == RM_OK)
        {
            if (ErrNotifier->Valid)
            {
                if (!dmaValidateXlate(ErrNotifier, 0, 0x000F))
                {
                    //KJK dmaAttach(ErrNotifier);
                    //KJK dmaBeginXfer(ErrNotifier, NULL);
                    notifyFillNotifier(pDev, ErrNotifier, ObjectName, (V016)Offset, CompletionStatus);
					/* KJK
                    dmaEndXfer(ErrNotifier, NULL);
                    dmaDetach(ErrNotifier);
					*/
                }
            }
        }
        //
        // Do any OS specific action.
        //
        if (Object)
            osError(Object, Offset, Data, CompletionStatus);
        else    
            osError(Object, Offset, ChID, CompletionStatus);
    }
    return (RM_OK);
}
RM_STATUS notifyMethodComplete
(
	PHWINFO	  pDev,
    POBJECT   Object,
    U032      Offset,
    V032      Data,
    RM_STATUS CompletionStatus
)
{
    if ((Offset == 0x100) || (Offset >= 0x0200))
    {
        if (Object->NotifyTrigger)
        {
            Object->NotifyTrigger = FALSE;
            if (Object->NotifyXlate)
                notifyFillNotifier(pDev, Object->NotifyXlate, Object->Name, (V016)Offset, CompletionStatus);
            //
            // Do any OS specified action related to this notification.
            //
            if (Object->NotifyAction)
                osNotifyEvent(pDev, Object, 0, Offset, Data, CompletionStatus, Object->NotifyAction);
        }
    }
    return (RM_OK);
}
RM_STATUS notifyBufferHWComplete
(
	PHWINFO	  pDev, 
    POBJECT   Object,
    U032      Offset,
    V032      Data,
    U032      Buffer,    
    RM_STATUS CompletionStatus
)
{
    if (Offset >= 0x0200)
    {
        if (Object->NotifyTrigger)
        {
            Object->NotifyTrigger = FALSE;
            if (Object->NotifyXlate)
                notifyFillNotifierArray(pDev, Object->NotifyXlate, Object->Name, (V016)Offset, CompletionStatus, Buffer);
            //
            // Do any OS specified action related to this notification.
            //
            if (Object->NotifyAction)
                osNotifyEvent(pDev, Object, Buffer, Offset, Data, CompletionStatus, Object->NotifyAction);
        }
    }
    return (RM_OK);
}
RM_STATUS notifyBufferComplete
(
	PHWINFO       pDev,
    PBUFFEROBJECT BuffObject,
    U032          BuffNum,
    V032          OtherInfo,
    RM_STATUS     CompletionStatus
)
{
    RM_STATUS status;
    PBUFFER   pBuffer = &BuffObject->Buffer[BuffNum];

    if ((OtherInfo == NOTIFY_INFO16_BUFFER_YANK)
    ||  (pBuffer->NotifyCurrentCount == 0))
    {
        //
        // Complete buffer with any notify action requested.
        //
        if (pBuffer->NotifyXlate)
            notifyFillNotifier(pDev, pBuffer->NotifyXlate, 0, (V016)OtherInfo, CompletionStatus);
        pBuffer->State = BUFFER_IDLE;
        //
        // Do any OS specified action related to this notification.
        //
        if (pBuffer->NotifyAction)
        {
            osNotifyEvent(pDev,
                          (POBJECT)BuffObject,
            			  0,
                          pBuffer->NotifyMethod,
                          BuffObject->Base.Name,
                          CompletionStatus,
                          pBuffer->NotifyAction);
        }
    }
    else
    {
        //
        // Auto notify buffer again.
        //
        if (pBuffer->NotifyXlate)
            notifyFillNotifier(pDev, pBuffer->NotifyXlate,
                               pBuffer->NotifyCurrentCount,
                               NOTIFY_INFO16_BUFFER_LOOP,
                               CompletionStatus);
        if (pBuffer->NotifyCount != 0xFFFFFFFF)
            pBuffer->NotifyCurrentCount--;
        status = BuffObject->BufferXfer(pDev, BuffObject, BuffNum);
        if (status)
        {
            //
            // Stop looping and return error.
            //
            pBuffer->NotifyCurrentCount = 0;
            notifyBufferComplete(pDev, BuffObject, BuffNum, OtherInfo, status);
        }
    }
    return (RM_OK);
}
RM_STATUS notifyFillNotifier
(
	PHWINFO	   pDev,
    PDMAOBJECT NotifyXlate,
    V032       Info32,
    V016       Info16,
    RM_STATUS  CompletionStatus
)
{
    RM_STATUS     status;
    PNOTIFICATION NotifyBuffer;

    //
    // Fill in the notification structure.
    //
    status = dmaGetMappedAddress(pDev, NotifyXlate, 0, 0x000F, (VOID **)&(NotifyBuffer));
    if (status)
        return (status);
    NotifyBuffer->OtherInfo32 = Info32;
    NotifyBuffer->OtherInfo16 = Info16;
    tmrGetCurrentTime(pDev, &NotifyBuffer->TimeHi, &NotifyBuffer->TimeLo);
    NotifyBuffer->Status = (V016)CompletionStatus;
    return (RM_OK);
}

RM_STATUS notifyFillNotifierArray
(
	PHWINFO	   pDev,
    PDMAOBJECT NotifyXlate,
    V032       Info32,
    V016       Info16,
    RM_STATUS  CompletionStatus,
    U032       Index
)
{
    RM_STATUS     status;
    PNOTIFICATION NotifyBuffer;

    //
    // Fill in the notification structure.
    //
    status = dmaGetMappedAddress(pDev, NotifyXlate, (Index*0x10), 0x000F, (VOID **)&(NotifyBuffer));
    if (status)
        return (status);
    NotifyBuffer->OtherInfo32 = Info32;
    NotifyBuffer->OtherInfo16 = Info16;
    tmrGetCurrentTime(pDev, &NotifyBuffer->TimeHi, &NotifyBuffer->TimeLo);
    NotifyBuffer->Status = (V016)CompletionStatus;
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\fb\nv\fb.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FB Manager *********************************\
*                                                                           *
* Module: FB.C                                                              *
*   The FB is managed in this module.                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <gr.h>
#include <fb.h>
#include <os.h>
#include <vga.h>
#include "nvhw.h"


//---------------------------------------------------------------------------
//
//  Instance allocation bitmap.
//
//---------------------------------------------------------------------------

RM_STATUS fbInitializeInstMemBitMap
(
    PHWINFO pDev
)
{
    RM_STATUS status;
    U008      *pbyte;
    U032      size;
    U032      entry;

    //
    // Initialize instance memory usage bitmap.  Each bit equals 1 paragraph (16 bytes)
    // of instance memory.
    //
    pDev->Pram.FreeInstMax = (pDev->Pram.FreeInstSize  / 16) & ~0x07;
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FB Free Size       = ", pDev->Pram.FreeInstSize);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FB Free Inst Base  = ", pDev->Pram.FreeInstBase);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FB Free Inst Max   = ", pDev->Pram.FreeInstMax + pDev->Pram.FreeInstBase);

    size = (pDev->Pram.FreeInstMax / 8 + 4);
    status = osAllocMem((VOID **)&pbyte, size);
    if (status)
        return (status);

    pDev->DBfbInstBitmap = pbyte;

    //
    // Reserve instance 0 as the NULL instance.
    //    
    *pbyte++ = 0xFE;    
    while (--size)
        *pbyte++ = 0xFF;

    //
    // Allocate Instance memory for the cursor image - must be aligned to 2k.
    //
    // KJK This should be removed once the new cursor interface is enabled in the display
    // driver.
    //
    status = fbAllocInstMemAlign(pDev, &pDev->Dac.CursorImageInstance, 0x800 / 16, 0x800 / 16);
    if (status)
    {
        osFreeMem((void *)pDev->DBfbInstBitmap);
        pDev->DBfbInstBitmap = 0;
        return (status);
    }


    //
    // Allocate the cached cursors and clear all current state
    // 
    for (entry=0; entry < MAX_CACHED_CURSORS; entry++)
    {   
        status = fbAllocInstMemAlign(pDev, &pDev->Dac.CursorImageCacheInstance[entry], 0x800 / 16, 0x800 / 16);
        if (status)
        {
            osFreeMem((void *)pDev->DBfbInstBitmap);
            pDev->DBfbInstBitmap = 0;
            return (status);
        }
        //
        // Since we're no longer maintaining the cache across mode changes, just
        // wipe the cache clean.
        //
        pDev->Dac.CursorMaskCRC[entry] = 0;                    
    }                    

    return RM_OK;
} // end of fbInitializeInstMemBitMap 

//---------------------------------------------------------------------------
//
//  PRAM allocation and de-allocation.
//
//---------------------------------------------------------------------------

/*	alloc instance mem with specified alignment
*/
RM_STATUS fbAllocInstMemAlign
(
    PHWINFO pDev,
    U032   *Instance,
    U032    Size,
    U032    Align		
)
{
    U032 i;
    U032 j;
	U032 mask;

    if (pDev->Power.State != 0)
    {
        return (RM_ERR_NO_FREE_MEM);
    }

    DBG_VAL_PTR(pDev->DBfbInstBitmap);
#if DEBUG
    if (Size == 0)    
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Zero size in fbAllocInstMem!\n\r");
        DBG_BREAKPOINT();
    }
#endif
    *Instance = 0;
	i = pDev->Pram.FreeInstBase;		// get base of inst memory
	mask = Align - 1;
	while (mask & i)		 			// align i
		i += 0x1;						// try next page
	i -= pDev->Pram.FreeInstBase;		// offset from base
    for ( ; i < pDev->Pram.FreeInstMax; i += Align)
    {
		U032 k = i;

        if (pDev->DBfbInstBitmap[k >> 3] & BIT(k & 7))		// available?
        {
            //
            // Search for string of 1's the length of the block.
            //
            j = 0;
            do
            {
                if ((++k >= pDev->Pram.FreeInstMax) || (++j >= Size))
                    break;
            }
            while (pDev->DBfbInstBitmap[k >> 3] & BIT(k & 7));
            if (j == Size)
            {
                //
                // Score, a block was found.
                //
                *Instance = k - j + pDev->Pram.FreeInstBase;
                while (j--)
                {
                    //
                    // Mark instance memory as allocated.
                    //
                    k--;
                    pDev->DBfbInstBitmap[k >> 3] &= ~BIT(k & 7);
                }
#if defined(NTRM) && defined(DBG)
				osLogInstMemAlloc(*Instance, Size, Align);
#endif
                return (RM_OK);
            }
        }
    }
    return (RM_ERR_NO_FREE_MEM);
}

RM_STATUS fbAllocInstMem
(
    PHWINFO pDev,
    U032   *Instance,
    U032    Size
)
{
    U032 i;
    U032 j;

    if (pDev->Power.State != 0)
    {
        return (RM_ERR_NO_FREE_MEM);
    }

    DBG_VAL_PTR(pDev->DBfbInstBitmap);
#if DEBUG
    if (Size == 0)    
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Zero size in fbAllocInstMem!\n\r");
        DBG_BREAKPOINT();
    }
#endif
    *Instance = 0;
    for (i = 0; i < pDev->Pram.FreeInstMax; i++)
    {
        if (!pDev->DBfbInstBitmap[i >> 3])
        {
            i += 7;
        }
        else if (pDev->DBfbInstBitmap[i >> 3] & BIT(i & 7))
        {
            //
            // Search for string of 1's the length of the block.
            //
            j = 0;
            do
            {
                if ((++i >= pDev->Pram.FreeInstMax) || (++j >= Size))
                    break;
            }
            while (pDev->DBfbInstBitmap[i >> 3] & BIT(i & 7));
            if (j == Size)
            {
                //
                // Score, a block was found.
                //
                *Instance = i - j + pDev->Pram.FreeInstBase;
                while (j--)
                {
                    //
                    // Mark instance memory as allocated.
                    //
                    i--;
                    pDev->DBfbInstBitmap[i >> 3] &= ~BIT(i & 7);
                }
#if defined(NTRM) && defined(DBG)
				osLogInstMemAlloc(*Instance, Size, 0);
#endif
                return (RM_OK);
            }
        }
    }
    return (RM_ERR_NO_FREE_MEM);
}
RM_STATUS fbFreeInstMem
(
    PHWINFO pDev,
    U032    Instance,
    U032    Size
)
{
#if defined(NTRM) && defined(DBG)
	U032 actualInstance = Instance;
	U032 actualSize = Size;
#endif // DEBUG && NTRM

    //
    // If instance is already set to 0, then it has already been freed.  This can
    // happen in some cases when a mode switch is happening while MIDI is playing
    // using the timer alarm notifies.  Ignoring this case can potentially cause a
    // protection fault, so be careful.
    //
    if (!Instance)
        return (RM_OK);
    Instance -= pDev->Pram.FreeInstBase;
#if DEBUG
    if (Instance > pDev->Pram.FreeInstMax)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ERROR - Freed instance out of range!\n\r");
        DBG_BREAKPOINT();
    }
#endif // DEBUG
    while (Size--)
    {
        //
        // Mark instance memory as free.
        //
        pDev->DBfbInstBitmap[Instance >> 3] |= BIT(Instance & 7);
        Instance++;
    }
#if defined(NTRM) && defined(DBG)
	osUnlogInstMemAlloc(actualInstance, actualSize);
#endif // DEBUG

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\fifo\nv\fifoinit.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FIFO Manager *******************************\
*                                                                           *
* Module: FIFOINIT.C                                                        *
*   The FIFO is initialized in this module.  This is a one time occurance   *
*   and then the module is unloaded.                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <fifo.h>
#include <os.h>
#include "nvhw.h"


//
// Initialize FIFO data structures and hardware.
//
RM_STATUS initFifo
(
    PHWINFO pDev
)
{
    U032 i;
    
    //
    // Initilialize all global FIFO variables.
    //
    pDev->Fifo.HalInfo.AllocateCount    = 0;
    pDev->Fifo.UpdateFlags              = 0;

    //
    // Allocate FIFO table.
    //
    if (osAllocMem((VOID **)&pDev->DBfifoTable, sizeof(FIFO) * NUM_FIFOS) != RM_OK)
        return (RM_ERR_NO_FREE_MEM);
    for (i = 0; i < NUM_FIFOS; i++)
    {
        pDev->DBfifoTable[i].InUse = FALSE;
        pDev->DBfifoTable[i].ChID  = i;
        pDev->DBfifoTable[i].CacheDepth = 512;
    }

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\dma\nv20\dmanv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** DMA Manager ********************************\
*                                                                           *
* Module: dmanv20.c                                                         *
*   The NV20 HAL DMA engine implementation is provided in this module.      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalDmaControl_NV20(VOID *);
RM_STATUS nvHalDmaAlloc_NV20(VOID *);
RM_STATUS nvHalDmaFree_NV20(VOID *);
RM_STATUS nvHalDmaGetInstSize_NV20(VOID *);

//
// nvHalDmaControl
//
// Nothing to do here.
//
RM_STATUS
nvHalDmaControl_NV20(VOID *arg)
{
    PDMACONTROLARG_000 pDmaControlArg = (PDMACONTROLARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDmaControlArg->id != DMA_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    switch (pDmaControlArg->cmd)
    {
        case DMA_CONTROL_UPDATE:
        case DMA_CONTROL_LOAD:
        case DMA_CONTROL_UNLOAD:
        case DMA_CONTROL_DESTROY:
        case DMA_CONTROL_INIT:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalDmaAlloc
//
// Initialize dma instance.
//
RM_STATUS
nvHalDmaAlloc_NV20(VOID *arg)
{
    PDMAALLOCARG_000 pDmaAllocArg = (PDMAALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALOBJINFO pDmaHalObjInfo;
    PDMAHALINFO pDmaHalInfo;
    PHWREG nvAddr;
    U032 adjust, i;

    //
    // Verify interface revision.
    //
    if (pDmaAllocArg->id != DMA_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaAllocArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaAllocArg->pHalObjInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    adjust = 0;
    switch (pDmaHalObjInfo->classNum)
    {
        case NV1_CONTEXT_DMA_TO_MEMORY:     
        case NV_CONTEXT_DMA_TO_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_TO_MEMORY);
            break;
        case NV1_CONTEXT_DMA_FROM_MEMORY:     
        case NV_CONTEXT_DMA_FROM_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_FROM_MEMORY);
            break;
        case NV1_CONTEXT_DMA_IN_MEMORY:     
        case NV_CONTEXT_DMA_IN_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_IN_MEMORY);
            break;
    }
    adjust |= SF_NUM(_DMA, _ADJUST, pDmaHalObjInfo->PteAdjust);
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
        adjust |= SF_DEF(_DMA, _PAGE_ENTRY, _LINEAR);
    adjust |= SF_DEF(_DMA, _PAGE_TABLE, _PRESENT);
    switch (pDmaHalObjInfo->AddressSpace)
    {
        case ADDR_SYSMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _PCI);
            break;
        case ADDR_AGPMEM:
#ifdef IKOS
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: AGP on IKOS!!!!\n");
            DBG_BREAKPOINT();
#endif
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _AGP);
            break;
        case ADDR_FBMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _NVM);
            break;
        default:
#ifdef DEBUG
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Invalid address space type\n\r");
            DBG_BREAKPOINT();
#endif
            return (RM_ERR_BAD_ARGUMENT);
    }

    //
    // Workaround a bug in the HOST's semaphore context dma checks.
    // It only accepts the SetContextDmaSemaphore method if the
    // ctxdma is marked COHERENCY_CACHED (even though the underlying
    // memory is NODE_NVM).  Since no other engine checks the
    // coherency flags (yet), this should be OK for now.
    //
    adjust |= SF_DEF(_DMA, _FLAGS_MAPPING_COHERENCY, _CACHED);

    //
    // Fill the page translation array.
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
    {    
        INST_WR32(pDmaHalObjInfo->Instance, 8, pDmaHalObjInfo->PteArray[0]);
        INST_WR32(pDmaHalObjInfo->Instance, 12, pDmaHalObjInfo->PteArray[0]); // better guard
    }        
    else 
    {   
        for (i = 0; i < pDmaHalObjInfo->PteCount; i++)
        {
            INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[i]);
        }
        //
        // Fill in the guard page with bogus data.  Only accessed by DMA engine,
        // not used in any transfer to system memory.
        //
        INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[0]);
    }
    //
    // Fill in rest of page table values.
    //
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_CLASS), adjust);
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_LIMIT), pDmaHalObjInfo->PteLimit);

    //
    // Add this dma context to the HAL table.
    //
    pDmaHalObjInfo->Next = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
    pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo;

    return (RM_OK);
}

//
// nvHalDmaFree
//
RM_STATUS
nvHalDmaFree_NV20(VOID *arg)
{
    PDMAFREEARG_000 pDmaFreeArg = (PDMAFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALINFO pDmaHalInfo;
    PDMAHALOBJINFO pDmaHalObjInfo, pDmaHalObjInfoDelete;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pDmaFreeArg->id != DMA_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaFreeArg->pHalHwInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;
    pDmaHalObjInfo = pDmaFreeArg->pHalObjInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Detach from DMA list.
    //
    if (pDmaHalInfo->pDmaHalObjInfos == (VOID_PTR)pDmaHalObjInfo)
        pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo->Next;
    else
    {
        pDmaHalObjInfoDelete = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
        while (pDmaHalObjInfoDelete->Next && pDmaHalObjInfoDelete->Next != pDmaHalObjInfo)
        {
            pDmaHalObjInfoDelete = pDmaHalObjInfoDelete->Next;
        }
        if (pDmaHalObjInfoDelete->Next)
            pDmaHalObjInfoDelete->Next = pDmaHalObjInfo->Next;
    }

    return (RM_OK);
}

//
// nvHalDmaGetInstSize
//
// Return number of *paragraphs* required for dma context in
// instance memory.
//
RM_STATUS
nvHalDmaGetInstSize_NV20(VOID *arg)
{
    PDMAGETINSTSIZEARG_000 pDmaGetInstSizeArg = (PDMAGETINSTSIZEARG_000)arg;
    PDMAHALOBJINFO pDmaHalObjInfo;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pDmaGetInstSizeArg->id != DMA_GET_INSTSIZE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaGetInstSizeArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaGetInstSizeArg->pHalObjInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Factor in an extra PTE so when the DMA engine prefetches, it
    // won't fault on a last access to a page.
    //
    
    //
    // Local memory contexts require only 1 paragraph (they're linear).
    // So do single page contexts in other address spaces (i.e. system memory).
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || ((pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM)))
        pDmaHalObjInfo->NumUnits = 1;
    else
    {
        if (pDmaHalObjInfo->PteCount == 1)
            pDmaHalObjInfo->NumUnits = 1;
        else
            pDmaHalObjInfo->NumUnits = 2 + (pDmaHalObjInfo->PteCount - 1) / 4;
    }
    
    return (RM_OK);
}

//
// dmaHalInstanceToHalInfo
//
RM_STATUS
dmaHalInstanceToHalInfo_NV20(U032 chid, U032 instance, PDMAHALOBJINFO *ppDmaHalObjInfo, PHALHWINFO pHalHwInfo)
{
    PDMAHALOBJINFO pDmaHalObjInfo;

    pDmaHalObjInfo = (PDMAHALOBJINFO)pHalHwInfo->pDmaHalInfo->pDmaHalObjInfos;
    while (pDmaHalObjInfo)
    {
        if (pDmaHalObjInfo->Instance == instance)
        {
            //
            // Found it!
            //
    	    *ppDmaHalObjInfo = pDmaHalObjInfo;
            return RM_OK;
        }
        pDmaHalObjInfo = pDmaHalObjInfo->Next;
    }

    *ppDmaHalObjInfo = NULL;  
    return RM_ERR_BAD_ARGUMENT;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\fifo\nv\fifostat.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FIFO Manager *******************************\
*                                                                           *
* Module: FIFOSTATE.C                                                       *
*   The FIFO state is changed in this module.                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <dac.h>
#include <gr.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"


//
// Change FIFO state in hardware.
//
RM_STATUS stateFifo
(
    PHWINFO pDev,
    U032    msg
)
{
    U032 i;

    switch (msg)
    {
        case STATE_UPDATE:
            nvHalFifoControl(pDev, FIFO_CONTROL_UPDATE);
            break;
        case STATE_LOAD:
            nvHalFifoControl(pDev, FIFO_CONTROL_LOAD);

            //
            // Re-disable cache reassignment if we're in a full-screen DOS session.  In case
            // some driver goes crazy and starts writing its dma pointers before
            // we're back into hires, we don't want to render on the DOS screen.
            // By disabling the reassign, we lock the fifo at the unused channel
            // until we're ready to process more data.  They're welcome to fill their
            // buffer up -- it just won't go anywhere.
            //
            if (pDev->Vga.Enabled)
            {
                FIFOLOG(3, 1, 1);
                REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            }

            //
            // Enable all PFIFO interrupt conditions using value
            // setup by HAL (see FIFO_CONTROL_INIT code for each chip).
            //
            REG_WR32(NV_PFIFO_INTR_0,     0xFFFFFFFF);
            REG_WR32(NV_PFIFO_INTR_EN_0,  pDev->Fifo.HalInfo.IntrEn0);

            break;
        case STATE_UNLOAD:
            nvHalFifoControl(pDev, FIFO_CONTROL_UNLOAD);
            break;
        case STATE_INIT:
            initFifo(pDev);
            initFifoEx(pDev);
            
            //
            // Allocate Hash Table structure.
            //
            if (osAllocMem((VOID **)&pDev->DBhashTable, HASH_DEPTH * sizeof(SW_HASH_TABLE_ENTRY)) != RM_OK)
                return (RM_ERR_NO_FREE_MEM);

            //
            // Initialize Hash Table.
            //    
            for (i = 0; i < HASH_DEPTH; i++)
            {
                pDev->DBhashTable[i].Object = NULL;
            }

            nvHalFifoControl(pDev, FIFO_CONTROL_INIT);
            break;
        case STATE_DESTROY:
            //
            // Free up allocated memory.
            //
            osFreeMem(pDev->DBfifoTable);
            osFreeMem(pDev->DBhashTable);
            break;
    }    
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\fb\nv10\fbnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Chip Specific HAL FB Routines ********************\
*                                                                           *
* Module: FBNV10.c                                                          *
*   The NV10 specific HAL FB routines reside in this file.                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include <heap.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalFbControl_NV10(VOID *);
RM_STATUS nvHalFbAlloc_NV10(VOID *);
RM_STATUS nvHalFbFree_NV10(VOID *);
RM_STATUS nvHalFbSetAllocParameters_NV10(VOID *);
RM_STATUS nvHalFbGetSurfacePitch_NV10(VOID *);
RM_STATUS nvHalFbGetSurfaceDimensions_NV10(VOID *);
RM_STATUS nvHalFbLoadOverride_NV10(VOID *);

// statics
static VOID nvHalFbRoundTiledPitchSize_NV10(U032 *, U032, U032 *);
static U032 nvHalFbRealMemSize(U032, PHWREG);
static U032 calcChkSum(PHWREG, U032);
static void restoreFbSave(U032 *, PHWREG, U032);

// NV10 expects a 1024 byte alignment
#define FC_MIN_ALIGN_SHIFT      10

//
// nvHalFbControl
//
RM_STATUS
nvHalFbControl_NV10(VOID *arg)
{
    PFBCONTROLARG_000 pFbControlArg = (PFBCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO pFbHalInfo;
    PPRAMHALINFO pPramHalInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    PHWREG nvAddr;
    U032 i;
    U032 test_mem;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbControlArg->id != FB_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbControlArg->pHalHwInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pFbControlArg->cmd)
    {
        case FB_CONTROL_INIT:
        {
            U032 extbank, intbank;

            // set ram size
            pFbHalInfo->RamSize = REG_RD32(NV_PFB_CSTATUS);
            pFbHalInfo->RamSizeMb = pFbHalInfo->RamSize / 0x100000;

            // set bank count
            extbank = REG_RD_DRF(_PFB, _CFG, _EXTBANK);
            intbank = REG_RD_DRF(_PFB, _CFG, _BANK);

            // record number of external banks
            if (extbank == NV_PFB_CFG_EXTBANK_1)
                pFbHalInfo->ExtBankCount = 2;
            else
                pFbHalInfo->ExtBankCount = 1;

            // set heap manager bank count
            if (extbank && intbank)
                pFbHalInfo->BankCount = 4;
            else if ((extbank && !intbank) || (!extbank && intbank))
                pFbHalInfo->BankCount = 2;
            else
                pFbHalInfo->BankCount = 1;

            // save off chip-dependent fb state
            pFbHalPvtInfo->fbSave[0] = REG_RD32(NV_PFB_CFG);

            // set ram type
            if (REG_RD_DRF(_PFB, _CFG, _TYPE) == NV_PFB_CFG_TYPE_SDR)
                pFbHalInfo->RamType = BUFFER_SDRAM;
            else
                pFbHalInfo->RamType = BUFFER_DDRAM;


            //CAH:Actually step through memory to verify we have as much there as the BIOS is 
            //telling us. On some "gray" market boards they may be strapped to report 
            //double the actual physical memory.This test will step through the framebuffer
            //to determine if it's actually there.
            test_mem = nvHalFbRealMemSize(pFbHalInfo->RamSizeMb, pHalHwInfo->fbBaseAddr);

            if (pFbHalInfo->RamSizeMb != test_mem) 
            {

                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: RamSize incorrectly read from BIOS\n\r");
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Resetting RamSize from Memory Test\n\r");
                return (RM_ERROR);
            }

            //
            // Set instance space size.  Add in whatever os-dependent
            // (i.e. BIOS) space is needed as well.
            //
            // For NV10, this is 128K allocatable.
            //
            pPramHalInfo->TotalInstSize = 0x20000 + pPramHalInfo->InstPadSize;

            //
            // Configure hash table.
            //
            pFbHalPvtInfo->hashTableSize = 0x4000;
            pPramHalInfo->HashDepth = pFbHalPvtInfo->hashTableSize / sizeof (HASH_TABLE_ENTRY);
            pPramHalInfo->HashSearch = 128;
            pFbHalPvtInfo->hashTableAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize;
            REG_WR32(NV_PFIFO_RAMHT, (DRF_DEF(_PFIFO, _RAMHT, _SIZE, _16K) |
                                      DRF_NUM(_PFIFO, _RAMHT, _BASE_ADDRESS, (pFbHalPvtInfo->hashTableAddr - DEVICE_BASE(NV_PRAMIN)) >> 12) |
                                      DRF_DEF(_PFIFO, _RAMHT, _SEARCH, _128)));

            //
            // Configure fifo context area.
            //
            pFbHalPvtInfo->fifoContextSize = NUM_FIFOS_NV10 * FC_SIZE_NV10;
            pFbHalPvtInfo->fifoContextAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize + pFbHalPvtInfo->hashTableSize;
            REG_WR_DRF_NUM(_PFIFO, _RAMFC, _BASE_ADDRESS, ((pFbHalPvtInfo->fifoContextAddr - DEVICE_BASE(NV_PRAMIN)) >> FC_MIN_ALIGN_SHIFT));

            //
            // Configure runout area.
            //
            pFbHalPvtInfo->fifoRunoutSize = 512;
            pFbHalPvtInfo->fifoRunoutAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize +
                pFbHalPvtInfo->hashTableSize + pFbHalPvtInfo->fifoContextSize;
            pFbHalPvtInfo->fifoRunoutMask = pFbHalPvtInfo->fifoRunoutSize - 1;
            REG_WR32(NV_PFIFO_RAMRO, (DRF_DEF(_PFIFO, _RAMRO, _SIZE, _512) |
                                      DRF_NUM(_PFIFO, _RAMRO, _BASE_ADDRESS, (pFbHalPvtInfo->fifoRunoutAddr - DEVICE_BASE(NV_PRAMIN)) >> 9)));

            //
            // Sum of all allocations plus a little slop
            //
            pPramHalInfo->CurrentSize  = pFbHalPvtInfo->hashTableSize + pFbHalPvtInfo->fifoContextSize + pFbHalPvtInfo->fifoRunoutSize + 512;

            break;
        }
        case FB_CONTROL_LOAD:
            break;
        case FB_CONTROL_UNLOAD:
            break;
        case FB_CONTROL_UPDATE:
            break;
        case FB_CONTROL_DESTROY:
            REG_WR32(NV_PFB_CFG, pFbHalPvtInfo->fbSave[0]);
            break;
        case FB_CONTROL_INSTWR_DISABLE:
            // disable writes by enabling  protection
            switch (pPramHalInfo->TotalInstSize)
            {
                case 0x30000:
                    FLD_WR_DRF_DEF(_PFB, _NVM, _LIMIT, _192K);
                    break;
                case 0x20000:
                default:
                    FLD_WR_DRF_DEF(_PFB, _NVM, _LIMIT, _128K);
                    break;
            }
            FLD_WR_DRF_DEF(_PFB, _NVM, _MODE, _ENABLE);
            break;
        case FB_CONTROL_INSTWR_ENABLE:
            // enable writes by disabling write protection
            FLD_WR_DRF_DEF(_PFB, _NVM, _MODE, _DISABLE);
            break;
        case FB_CONTROL_TILING_DISABLE:
            HAL_GR_IDLE(pHalHwInfo);
            for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
            {
                REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
                REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);
            }
            break;
        case FB_CONTROL_TILING_ENABLE:
            // this is treated as an error on nv10 (???)
            return (RM_ERR_BAD_ARGUMENT);
        case FB_CONTROL_TILING_CONFIGURE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalFbGetSurfacePitch
//
// Given a width and bits per pixel, return the surface pitch
//
RM_STATUS
nvHalFbGetSurfacePitch_NV10(VOID *arg)
{
    PFBGETSURFACEPITCHARG_000 pGetSurfacePitchArg = (PFBGETSURFACEPITCHARG_000)arg;
    
    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pGetSurfacePitchArg->id != FB_GET_SURFACE_PITCH_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (at least) 64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pGetSurfacePitchArg->pitch = ((pGetSurfacePitchArg->width * ((pGetSurfacePitchArg->bpp+1) >> 3)) + 0x3F) & ~0x3F;

    if (pGetSurfacePitchArg->flags & FB_GET_SURFACE_PITCH_NO_ADJUST)
        return RM_OK;

    nvHalFbRoundTiledPitchSize_NV10(&pGetSurfacePitchArg->pitch, NULL, NULL);
    return RM_OK;
}

//
// nvHalFbGetSurfaceDimensions
//
// Given a width/height and bits per pixel, return the surface pitch and size
//
RM_STATUS
nvHalFbGetSurfaceDimensions_NV10(VOID *arg)
{
    PFBGETSURFACEDIMENSIONSARG_000 pGetSurfaceDimensionsArg = (PFBGETSURFACEDIMENSIONSARG_000)arg;
    
    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pGetSurfaceDimensionsArg->id != FB_GET_SURFACE_DIMENSIONS_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (at least) 64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pGetSurfaceDimensionsArg->pitch = ((pGetSurfaceDimensionsArg->width * ((pGetSurfaceDimensionsArg->bpp+1) >> 3)) + 0x3F) & ~0x3F;
    pGetSurfaceDimensionsArg->size  = pGetSurfaceDimensionsArg->pitch * pGetSurfaceDimensionsArg->height;
        
    if (pGetSurfaceDimensionsArg->flags & FB_GET_SURFACE_PITCH_NO_ADJUST)
        return RM_OK;

    nvHalFbRoundTiledPitchSize_NV10(&pGetSurfaceDimensionsArg->pitch,
                                    pGetSurfaceDimensionsArg->height,
                                    &pGetSurfaceDimensionsArg->size);
    return RM_OK;
}

static VOID
nvHalFbRoundTiledPitchSize_NV10(U032 *pitch, U032 height, U032 *size)
{

    // adjust the pitch, if necessary
    if (*pitch <= 0x200)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0200);
    else if (*pitch <= 0x400)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0400);
    else if (*pitch <= 0x600)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0600);
    else if (*pitch <= 0x800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0800);
    else if (*pitch <= 0xA00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0A00);
    else if (*pitch <= 0xC00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0C00);
    else if (*pitch <= 0xE00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0E00);
    else if (*pitch <= 0x1000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1000);
    else if (*pitch <= 0x1400)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1400);
    else if (*pitch <= 0x1800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1800);
    else if (*pitch <= 0x1C00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1C00);
    else if (*pitch <= 0x2000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _2000);
    else if (*pitch <= 0x2800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _2800);
    else if (*pitch <= 0x3000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _3000);
    else if (*pitch <= 0x3800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _3800);
    else if (*pitch <= 0x4000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _4000);
    else if (*pitch <= 0x5000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _5000);
    else if (*pitch <= 0x6000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _6000);
    else if (*pitch <= 0x7000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _7000);
    else if (*pitch <= 0x8000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _8000);
    else if (*pitch <= 0xA000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _A000);
    else if (*pitch <= 0xC000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _C000);
    else
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _E000);

    if (size) {
        U032 hzmult;

        // set size given possibly adjusted pitch
        *size = *pitch * height;

        //
        // Round size to an even multiple of horizontal tiles. Remapping occurs
        // within addresses of length (pitch * tile_height * 2) in the vertical
        // direction (where the max TILE_HEIGHT is 16 lines).
        //
        hzmult = *pitch * (16 * 2);
        *size = ((*size + (hzmult - 1)) / hzmult) * hzmult;
    }
}

//
// Before updating the tiling registers (in particular, the PGRAPH version),
// idle graphics as best as possible.
//
// If we're not GR_IDLE during these writes to the PGRAPH registers, these
// writes can be dropped leaving the PFB and PGRAPH regs inconsistent. The
// idle/resume routines are called during FreeTiledRange/ProgramTiledRange.
//
static VOID
nvHalTilingUpdateIdle_NV10
(
    PHALHWINFO pHalHwInfo,
    U032       *pDmaPush
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    // Empty FIFO and runout.
    while ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
        || (REG_RD_DRF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK) != NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY)
        || (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY))
    {
        // Make sure we process any fifo interrupts
        HALRMSERVICEINTR(pHalHwInfo, FIFO_ENGINE_TAG);

        // Check if GE needs servicing.
        if (REG_RD32(NV_PGRAPH_INTR))
            HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);

        // Check if vblank needs servicing.
        if (REG_RD32(NV_PMC_INTR_0) & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
            HALRMSERVICEINTR(pHalHwInfo, DAC_ENGINE_TAG);
    }

    // Disable the dma pusher
    *pDmaPush = REG_RD32(NV_PFIFO_CACHE1_DMA_PUSH);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);

    // Wait until the DMA pusher is idle
    while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
	    ;
}

static VOID
nvHalTilingUpdateResume_NV10
(
    PHALHWINFO pHalHwInfo,
    U032       DmaPush
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    // Restore the dma pusher state
    REG_WR32(NV_PFIFO_CACHE1_DMA_PUSH, DmaPush);
}

//
// nvHalFbAlloc
//
// Update user alloc request parameter according to memory
// type and (possibly) reserve hw resources.
//
RM_STATUS
nvHalFbAlloc_NV10(VOID *arg)
{
    PFBALLOCARG_000 pFbAllocArg = (PFBALLOCARG_000)arg;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    PFBALLOCINFO pFbAllocInfo;
    U032 i, pitch, size;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbAllocArg->id != FB_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pFbHalPvtInfo = (PFBHALINFO_NV10)pFbAllocArg->pHalHwInfo->pFbHalPvtInfo;
    pFbAllocInfo = pFbAllocArg->pAllocInfo;
    
    // Set default alignment based on type.
    switch (pFbAllocInfo->type) {
    case MEM_TYPE_IMAGE:
    case MEM_TYPE_OVERLAY:
        pFbAllocInfo->align = 0x3f;         // 64 byte alignment
        break;
    case MEM_TYPE_TEXTURE:
        pFbAllocInfo->align = 0xff;         // 256 byte alignment
        break;
    case MEM_TYPE_FONT:
        pFbAllocInfo->align = 0x1f;         // 32 byte alignment
        break;
    case MEM_TYPE_CURSOR:
        pFbAllocInfo->align = 0x7ff;        // 2048 byte alignment
        break;
    case MEM_TYPE_DMA:
        pFbAllocInfo->align = 0x3;          // 4 byte alignment
        break;
    case MEM_TYPE_INSTANCE:
        pFbAllocInfo->align = 0xf;          // 16 byte alignment
        break;
    case MEM_TYPE_DEPTH:
    case MEM_TYPE_DEPTH_COMPR16:
    case MEM_TYPE_DEPTH_COMPR32:
    case MEM_TYPE_PRIMARY:
    case MEM_TYPE_IMAGE_TILED:
        pFbAllocInfo->align = 0xfff;        // 4096 byte alignment
        break;
    default:
        // should this be 0xffffffff
        pFbAllocInfo->align = 0;
        return (RM_ERR_BAD_ARGUMENT);
    }

    //
    // A non-zero pitch value indicates the user wants tiled memory
    // (if available).  If the pitch is 0, we're done.
    //
    if (pFbAllocInfo->pitch == 0)
    {
        return (RM_OK);
    }
        
    // Now allocate a TILE_RANGE
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
    {
        if ((pFbHalPvtInfo->usedTiles & MEM_TYPE_TILE_RANGE_SHIFT(i)) == 0)
        {
            pFbHalPvtInfo->usedTiles |= MEM_TYPE_TILE_RANGE_SHIFT(i);
            break;
        }
    }
    if (i == NV_PFB_TILE__SIZE_1)
    {
        return (RM_ERR_INSUFFICIENT_RESOURCES);
    }

    pitch = pFbAllocInfo->pitch;
    nvHalFbRoundTiledPitchSize_NV10(&pitch,
                                    pFbAllocInfo->height,
                                    &size);

    //
    // If we're not allowing the pitch to be adjusted, we can only tile the surface
    // if the pitch is already HW aligned.
    // 
    if ((pFbAllocArg->flags & FB_ALLOC_NO_PITCH_ADJUST) && (pitch != pFbAllocInfo->pitch))
    {
        // requires rounding, so give back the range and fail the alloc
        pFbHalPvtInfo->usedTiles &= ~MEM_TYPE_TILE_RANGE_SHIFT(i);
        pFbAllocInfo->hwResId = 0;
        return (RM_OK);
    }

    // tiles are 16K aligned.
    pFbAllocInfo->align = 0x4000 - 1;

    // return adjusted pitch and size
    pFbAllocInfo->pitch = pitch;
    pFbAllocInfo->size  = size;

    pFbAllocInfo->hwResId = MEM_TYPE_TILE_RANGE_SHIFT(i);
    return (RM_OK);
}

//
// nvHalFbFree
//
// Release tile back to the free pool.
//
RM_STATUS
nvHalFbFree_NV10(VOID *arg)
{
    PFBFREEARG_000 pFbFreeArg = (PFBFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    PHWREG nvAddr;
    U032 i, dmapush;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbFreeArg->id != FB_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbFreeArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pFbFreeArg->pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Bail out now if there's no resource id.
    if (!pFbFreeArg->hwResId)
        return (RM_OK);

    // convert range bits to a TILE index
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
        if (pFbFreeArg->hwResId & MEM_TYPE_TILE_RANGE_SHIFT(i))
                break;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Freeing TILE Range:   ", i);

    // idle graphics, so we can update the PGRAPH registers
    nvHalTilingUpdateIdle_NV10(pFbFreeArg->pHalHwInfo, &dmapush);

    do {
        // Now, wait until graphics is idle
        HAL_GR_IDLE(pFbFreeArg->pHalHwInfo);

        // invalidate the range
        REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
        REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    

    } while (REG_RD32(NV_PFB_TILE(i)) != REG_RD32(NV_PGRAPH_TILE(i)));

    // resume graphics, now that PFB/PGRAPH are consistent
    nvHalTilingUpdateResume_NV10(pHalHwInfo, dmapush);

    // mark it free
    pFbHalPvtInfo->usedTiles &= ~pFbFreeArg->hwResId;

    return (RM_OK);
}

//
// nvHalFbSetAllocParameters
//
// Associate memory block (base/limit) with hardware resources.
//
RM_STATUS
nvHalFbSetAllocParameters_NV10(VOID *arg)
{
    PFBSETALLOCPARAMSARG_000 pFbSetAllocParamsArg = (PFBSETALLOCPARAMSARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    PFBALLOCINFO pFbAllocInfo;
    PHWREG nvAddr;
    U032 i, dmapush;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbSetAllocParamsArg->id != FB_SET_ALLOC_PARAMS_000)
        return (RM_ERR_VERSION_MISMATCH);


    pHalHwInfo = pFbSetAllocParamsArg->pHalHwInfo;
    pFbAllocInfo = pFbSetAllocParamsArg->pAllocInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pFbSetAllocParamsArg->pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Bail out if this allocation didn't reserve any tiling regs.
    //
    if (pFbAllocInfo->hwResId == 0)
        return (RM_OK);

    //
    // Convert range bits to a TILE index.
    //
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
        if (pFbAllocInfo->hwResId == (U032)MEM_TYPE_TILE_RANGE_SHIFT(i))
            break;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Programming TILE Range:   ", i);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:          Base =   ", pFbAllocInfo->offset);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         Limit =   ", pFbAllocInfo->offset + (pFbAllocInfo->size - 1));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         Pitch =   ", pFbAllocInfo->pitch);

    if (pFbAllocInfo->offset & 0x3fff)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error: unaligned Base\n");
        // mark it free
        pFbHalPvtInfo->usedTiles &= ~pFbAllocInfo->hwResId;
        // invalidate the range
        REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
        REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    
        return (RM_OK);
    }
    if (pFbAllocInfo->size & 0x3fff)
    {
        // mark it free
        pFbHalPvtInfo->usedTiles &= ~pFbAllocInfo->hwResId;
        // invalidate the range
        REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
        REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error: unaligned Limit\n");
        return (RM_OK);
    }

    // idle graphics, so we can update the PGRAPH registers
    nvHalTilingUpdateIdle_NV10(pFbSetAllocParamsArg->pHalHwInfo, &dmapush);

    //
    // Note: due to a PFB_TLIMIT readback bug, only compare the upper bits
    // when checking for PFB_TLIMIT/PGRAPH_TLIMIT consistency.
    // 
    do {
        // Now, wait until graphics is idle
        HAL_GR_IDLE(pHalHwInfo);

        REG_WR32(NV_PFB_TLIMIT(i), pFbAllocInfo->offset + pFbAllocInfo->size - 1);
        REG_WR32(NV_PFB_TSIZE(i), pFbAllocInfo->pitch);
        REG_WR32(NV_PFB_TILE(i), pFbAllocInfo->offset | DRF_DEF(_PFB, _TILE, _REGION, _VALID));

        REG_WR32(NV_PGRAPH_TLIMIT(i), pFbAllocInfo->offset + pFbAllocInfo->size - 1);
        REG_WR32(NV_PGRAPH_TSIZE(i), pFbAllocInfo->pitch);
        REG_WR32(NV_PGRAPH_TILE(i), pFbAllocInfo->offset | DRF_DEF(_PFB, _TILE, _REGION, _VALID));

    } while ((REG_RD32(NV_PFB_TILE(i)) != REG_RD32(NV_PGRAPH_TILE(i))) ||
             (REG_RD32(NV_PFB_TSIZE(i)) != REG_RD32(NV_PGRAPH_TSIZE(i))) ||
             ((REG_RD32(NV_PFB_TLIMIT(i)) & ~0x3FFF) != (REG_RD32(NV_PGRAPH_TLIMIT(i)) & ~0x3FFF)));

    // resume graphics, now that PFB/PGRAPH are consistent
    nvHalTilingUpdateResume_NV10(pHalHwInfo, dmapush);

    return (RM_OK);
}

RM_STATUS
nvHalFbLoadOverride_NV10(VOID *arg)
{
    PFBLOADOVERRIDEARG_000 pFbLoadOverrideArg = (PFBLOADOVERRIDEARG_000)arg;
	PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pFbLoadOverrideArg->id != FB_LOAD_OVERRIDE_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFbLoadOverrideArg->pHalHwInfo;
    nvAddr = pFbLoadOverrideArg->pHalHwInfo->nvBaseAddr;

    switch (pFbLoadOverrideArg->cmd)
    {
        case FB_LOAD_OVERRIDE_MEMORY:
            REG_WR32(NV_PFB_CFG, pFbLoadOverrideArg->value);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}


//CAH: Setup to detect possible alliasing of memory to tell us we have double
//the memory that we actually do. This algorithm will detect the case where
//memory addresses lay on top of eachother so as to make it appear that there
//is twice the memory available than is physically present. 
static U032 nvHalFbRealMemSize(U032 RamSizeMb, PHWREG base)
{
    U032 i, wp, actual_ram_size = 0;
    U032 checksum1 = 0, checksum2 = 0;
    U032 fb_save[128]; 

    //Write 0,1,2,3,...N on each 1mb boundry in the FB
    for (i = 0, wp = 0; i < RamSizeMb; i++, wp += 0x00100000) 
    {
        fb_save[i] = base->Reg032[wp/4];
        base->Reg032[wp/4] = i;
        checksum1 += i;
        checksum2 = calcChkSum(base, i);
        if (checksum1 != checksum2)
        {
            restoreFbSave(fb_save, base, i);
            return i; 
        }
    }

    restoreFbSave(fb_save, base, --i);
    return RamSizeMb; //This means we made it all the way through memory.
}

static void restoreFbSave(U032 *save, PHWREG base, U032 index)
{
    U032 i, wp;

    for (i = 0, wp = 0; i <= index; i++, wp += 0x00100000)
    {
        base->Reg032[wp/4] = save[i];
    }
}

static U032 calcChkSum(PHWREG base, U032 index)
{
    U032 i, wp, checksum = 0;

    for (i = 0, wp = 0; i <= index; i++, wp += 0x00100000)
    {
        checksum += base->Reg032[wp/4];
    }

    return checksum;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\fb\nv4\fbnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Chip Specific HAL FB Routines ********************\
*                                                                           *
* Module: fbnv04.c                                                          *
*   The NV4 specific HAL FB routines reside in this file.                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include <heap.h>
#include "nvhw.h"
#include "os.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalFbControl_NV04(VOID *);
RM_STATUS nvHalFbSetAllocParameters_NV04(VOID *);
RM_STATUS nvHalFbAlloc_NV04(VOID *);
RM_STATUS nvHalFbFree_NV04(VOID *);
RM_STATUS nvHalFbGetSurfacePitch_NV04(VOID *);
RM_STATUS nvHalFbGetSurfaceDimensions_NV04(VOID *);
RM_STATUS nvHalFbLoadOverride_NV04(VOID *);
static U032 nvHalFbRealMemSize(U032, PHWREG);
static U032 calcChkSum(PHWREG, U032);
static void restoreFbSave(U032 *, PHWREG, U032);

// NV4 expects a 512byte alignment
#define FC_MIN_ALIGN_SHIFT      9

/*****************************************************************************
 * tetris tiling
 *****************************************************************************/
char tetris_tile_table_signature[] = "_TETRIS_TILE_TABLE_";
static U032 NvChipTetrisTileTable[] =
{
// width  depth input_width  shift                               mode
//   |    |     |            |                                   |
     320, 16 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/0, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     640, 16 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     800, 16 | (128 << 16),  0, 0,
    1024, 16 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/3,
    1280, 16 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,

     320, 32 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     640, 32 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     800, 32 | (128 << 16),  0, 0,
    1024, 32 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/3,
    1280, 32 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,

     320, 16 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/0, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     640, 16 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     800, 16 | ( 64 << 16),  0, 0,
    1024, 16 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/2,
    1280, 16 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,

     320, 32 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     640, 32 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     800, 32 | ( 64 << 16),  0, 0,
    1024, 32 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/2,
    1280, 32 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,

    /* all others are disabled */
};

static RM_STATUS
nvHalTetrisTileWrite_NV04(PHALHWINFO pHalHwInfo, U032 NewConfig0Value)
{
    PFBHALINFO pFbHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    PPRAMHALINFO pPramHalInfo;
    U032 OldConfig0Value;

    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo;

    /*
     * check if we need to reprogram tiling
     */
    OldConfig0Value = REG_RD32(NV_PFB_CONFIG_0);
    NewConfig0Value = (NewConfig0Value & 0x000fffff) | (OldConfig0Value & 0xfff00000);
    if (NewConfig0Value != OldConfig0Value)
    {
        U032      reg0140;
        U032      reg2500;
        U032      reg3200;
        U032      reg3250;
        U032      size    = pPramHalInfo->TotalInstSize;
        VOID*     fbBase  = pHalHwInfo->fbBaseAddr;
        U032      fbSize  = pFbHalInfo->RamSize;
        U032      i;
        U008      *src, *dest;

        /*
         * save instance and driver memory
         */
        src = (U008 *)fbBase + fbSize - size;
        dest = (U008 *)pFbHalPvtInfo->bufferBase;

        DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalTetrisTileWrite_NV04: src ", src);
        DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalTetrisTileWrite_NV04: dest ", dest);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalTetrisTileWrite_NV04: count ", size);
        for (i = 0; i < size; i++)
        {
            dest[i] = src[i];
        }

        /*
         * disable chip
         */
        HAL_GR_IDLE(pHalHwInfo);
        WriteIndexed(NV_PRMVIO_SRX, 0x0000);  // _outp (0x3c4,0); _outp (0x3c5,0);
        reg2500 = REG_RD32(NV_PFIFO_CACHES);       REG_WR32(NV_PFIFO_CACHES, 0);
        reg3200 = REG_RD32(NV_PFIFO_CACHE1_PUSH0); REG_WR32(NV_PFIFO_CACHE1_PUSH0, 0);
        reg3250 = REG_RD32(NV_PFIFO_CACHE1_PULL0); REG_WR32(NV_PFIFO_CACHE1_PULL0, 0);
        reg0140 = REG_RD32(NV_PMC_INTR_EN_0);      REG_WR32(NV_PMC_INTR_EN_0, 0);

        /*
         * program tiling
         */
        REG_WR32(NV_PFB_CONFIG_0, NewConfig0Value);

        /*
         * restore instance and driver memory
         */
        for (i = 0; i < size; i++)
        {
            src[i] = dest[i];
        }

        /*
         * re-enable chip
         */
        REG_WR32(NV_PMC_INTR_EN_0, reg0140);
        REG_WR32(NV_PFIFO_CACHE1_PULL0, reg3250);
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, reg3200);
        REG_WR32(NV_PFIFO_CACHES, reg2500);
        WriteIndexed(NV_PRMVIO_SRX, 0x0300); // _outp (0x3c4,0); _outp (0x3c5,3);
    }

    /*
     * done
     */
    return RM_OK;
}


static RM_STATUS
nvHalTetrisTile_NV04(PHALHWINFO pHalHwInfo)
{   
    PFBHALINFO pFbHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    PDACHALINFO pDacHalInfo;
    U032 width, depth;
    U032 i;

    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalTetrisTile_NV04: tiling mode ", pFbHalPvtInfo->tilingDisabled);

    if (!pFbHalPvtInfo->tilingDisabled)
    {
        /*
         * determine if we should setup special tiling for this mode
         */
        width = pFbHalInfo->HorizDisplayWidth;
        depth = pDacHalInfo->Depth | (pDacHalInfo->InputWidth << 16);

#if 0
        /* DO NOT REMOVE - used for tiling tests */
        *((U032*)0xb0050) = (U032)NvChipTetrisTileTable;
#endif

        for (i = 0; i < sizeof(NvChipTetrisTileTable) / sizeof(U032); i += 4)
        {
            if ((NvChipTetrisTileTable[i + 0] == width)
             && (NvChipTetrisTileTable[i + 1] == depth)
             &&  NvChipTetrisTileTable[i + 2]
             &&  NvChipTetrisTileTable[i + 3])
            {
                U032 NewConfig0Value;

                /*
                 * calculate new tiling info
                 */
                NewConfig0Value = NV_PFB_CONFIG_0_TYPE_TETRIS
                                | (NvChipTetrisTileTable[i + 2] << 18)
                                | (NvChipTetrisTileTable[i + 3] << 15);

                /*
                 * program the tiling
                 */
                nvHalTetrisTileWrite_NV04(pHalHwInfo, NewConfig0Value);

                /*
                 * done
                 */
                return RM_OK;
            }
        }
    }  // Tiling is not disabled

    /*
     * disable tiling
     */
    nvHalTetrisTileWrite_NV04(pHalHwInfo, NV_PFB_CONFIG_0_TYPE_NOTILING);

    /*
     * done
     */
    return RM_OK;
}

//
// nvHalFbControl
//
//
RM_STATUS
nvHalFbControl_NV04(VOID *arg)
{
    PFBCONTROLARG_000 pFbControlArg = (PFBCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO pFbHalInfo;
    PPRAMHALINFO pPramHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    U032 test_mem;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbControlArg->id != FB_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbControlArg->pHalHwInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;

    switch (pFbControlArg->cmd)
    {
        case FB_CONTROL_INIT:
            //
            // Save off chip-dependent fb state.
            //
            pFbHalPvtInfo->fbSave[0] = REG_RD32(NV_PFB_CONFIG_0);
            pFbHalPvtInfo->fbSave[1] = REG_RD32(NV_PFB_CONFIG_1);

            //
            // Since this is only called from initFb(), we'll do this here
            // KJK Verify a valid RTL setting
            //
            REG_WR32(NV_PFB_RTL, 0);

            //
            // Setup pointer to our tiling save area.  It's immediately
            // after the FBHALINFO_NV04 structure in our engine
            // private data area setup by the RM.
            //
            pFbHalPvtInfo->bufferBase = (U008*)pFbHalPvtInfo + sizeof (FBHALINFO_NV04);

            //
            //  Set RamType
            //
            switch (REG_RD_DRF(_PFB, _BOOT_0, _RAM_TYPE)) {
                //case NV_PFB_BOOT_0_RAM_TYPE_1024K_2BANK:
                case NV_PFB_BOOT_0_RAM_TYPE_SDRAM_16MBIT:
                case NV_PFB_BOOT_0_RAM_TYPE_SDRAM_64MBIT:
                case NV_PFB_BOOT_0_RAM_TYPE_SDRAM_64MBITX16:
                    pFbHalInfo->RamType = BUFFER_SDRAM;
                    break;
                default:
                    // Everything else is SGRAM
                    pFbHalInfo->RamType = BUFFER_SGRAM;
                    break;
            }

            if (REG_RD_DRF(_PFB, _BOOT_0, _UMA)){
                pFbHalInfo->RamType = BUFFER_CRUSH_UMA;
            }

            //
            // Set RamSize (in bytes)
            //
            switch (REG_RD_DRF(_PFB, _BOOT_0, _RAM_AMOUNT)) {
                case NV_PFB_BOOT_0_RAM_AMOUNT_16MB:
                    pFbHalInfo->RamSizeMb = 16;
                    pFbHalInfo->RamSize   = 0x01000000;
                    pFbHalInfo->BankCount = 4;
                    break;
                case NV_PFB_BOOT_0_RAM_AMOUNT_8MB:
                    pFbHalInfo->RamSizeMb = 8;
                    pFbHalInfo->RamSize   = 0x00800000;
                    pFbHalInfo->BankCount = 4;
                    break;
                case NV_PFB_BOOT_0_RAM_AMOUNT_4MB:
                    pFbHalInfo->RamSizeMb = 4;
                    pFbHalInfo->RamSize   = 0x00400000;
                    pFbHalInfo->BankCount = 2;
                    break;
                case NV_PFB_BOOT_0_RAM_AMOUNT_2MB:
                    //
                    // This is overloaded in NV4.5 to denote 32meg.  We'll never see a 2meg NV4.
                    //
                    pFbHalInfo->RamSizeMb = 32;
                    pFbHalInfo->RamSize = 0x02000000;
                    pFbHalInfo->BankCount = 2;
                    break;
                default:
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Illegal RAM size in NV_PFB_BOOT_0\n\r");
                    DBG_BREAKPOINT();
                    pFbHalInfo->RamSizeMb = 8;
                    pFbHalInfo->RamSize = 0x00800000;
                    pFbHalInfo->BankCount = 4;
                    break;
            }

            //
            // Load config 0 value.
            //
            if (pFbHalInfo->RamSize == 0x00200000)
                FLD_WR_DRF_DEF(_PFB, _CONFIG_0, _BANK_SWAP, _2M);
            else
                FLD_WR_DRF_DEF(_PFB, _CONFIG_0, _BANK_SWAP, _4M);
            
            //
            // Check for UMA usage
            //
            // Note that this is only valid for NV0A, but the other NV4 variants hardwire these
            // bit fields to zero.
            //
            if (REG_RD_DRF(_PFB, _BOOT_0, _UMA) == NV_PFB_BOOT_0_UMA_ENABLE)
                switch (REG_RD_DRF(_PFB, _BOOT_0, _UMA_SIZE)) {
                    case NV_PFB_BOOT_0_UMA_SIZE_2M:
                        pFbHalInfo->RamSizeMb = 2;
                        pFbHalInfo->RamSize   = 0x00200000;
                        break;                 
                    case NV_PFB_BOOT_0_UMA_SIZE_4M:
                        pFbHalInfo->RamSizeMb = 4;
                        pFbHalInfo->RamSize   = 0x00400000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_6M:
                        pFbHalInfo->RamSizeMb = 6;
                        pFbHalInfo->RamSize   = 0x00600000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_8M:
                        pFbHalInfo->RamSizeMb = 8;
                        pFbHalInfo->RamSize   = 0x00800000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_10M:
                        pFbHalInfo->RamSizeMb = 10;
                        pFbHalInfo->RamSize   = 0x00A00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_12M:
                        pFbHalInfo->RamSizeMb = 12;
                        pFbHalInfo->RamSize   = 0x00C00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_14M:
                        pFbHalInfo->RamSizeMb = 14;
                        pFbHalInfo->RamSize   = 0x00E00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_16M:
                        pFbHalInfo->RamSizeMb = 16;
                        pFbHalInfo->RamSize   = 0x01000000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_18M:
                        pFbHalInfo->RamSizeMb = 18;
                        pFbHalInfo->RamSize   = 0x01200000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_20M:
                        pFbHalInfo->RamSizeMb = 20;
                        pFbHalInfo->RamSize   = 0x01400000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_22M:
                        pFbHalInfo->RamSizeMb = 22;
                        pFbHalInfo->RamSize   = 0x01600000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_24M:
                        pFbHalInfo->RamSizeMb = 24;
                        pFbHalInfo->RamSize   = 0x01800000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_26M:
                        pFbHalInfo->RamSizeMb = 26;
                        pFbHalInfo->RamSize   = 0x01A00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_28M:
                        pFbHalInfo->RamSizeMb = 28;
                        pFbHalInfo->RamSize   = 0x01C00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_30M:
                        pFbHalInfo->RamSizeMb = 30;
                        pFbHalInfo->RamSize   = 0x01E00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_32M:
                        pFbHalInfo->RamSizeMb = 32;
                        pFbHalInfo->RamSize   = 0x02000000;
                        break;
                    default:
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Illegal UMA size in NV_PFB_BOOT_0\n\r");
                        DBG_BREAKPOINT();
                        pFbHalInfo->RamSizeMb = 8;
                        pFbHalInfo->RamSize   = 0x00800000;
                        break;
                }

            //CAH:Actually step through memory to verify we have as much there as the BIOS is 
            //telling us. On some "gray" market boards they may be strapped to report 
            //double the actual physical memory.This test will step through the framebuffer
            //to determine if it's actually there.
            test_mem = nvHalFbRealMemSize(pFbHalInfo->RamSizeMb, pHalHwInfo->fbBaseAddr);

            if (pFbHalInfo->RamSizeMb != test_mem) 
            {

                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: RamSize incorrectly read from BIOS\n\r");
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Resetting RamSize from Memory Test\n\r");
                return (RM_ERROR);
            }

            //
            // Set instance space size.  Add in whatever os-dependent
            // (i.e. BIOS) space is needed as well.
            //
            // For NV4, this is 128K allocatable.
            //
            pPramHalInfo->TotalInstSize = 0x20000 + pPramHalInfo->InstPadSize;

            //
            // Configure hash table.
            //
            pFbHalPvtInfo->hashTableSize = 0x4000;
            pPramHalInfo->HashDepth = pFbHalPvtInfo->hashTableSize / sizeof (HASH_TABLE_ENTRY);
            pPramHalInfo->HashSearch = 128;
            pFbHalPvtInfo->hashTableAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize;
            REG_WR32(NV_PFIFO_RAMHT, (DRF_DEF(_PFIFO, _RAMHT, _SIZE, _16K) |
                                      DRF_NUM(_PFIFO, _RAMHT, _BASE_ADDRESS, (pFbHalPvtInfo->hashTableAddr - DEVICE_BASE(NV_PRAMIN)) >> 12) |
                                      DRF_DEF(_PFIFO, _RAMHT, _SEARCH, _128)));

            //
            // Configure fifo context area.
            //
            pFbHalPvtInfo->fifoContextSize = NUM_FIFOS_NV04 * FC_SIZE_NV04;
            pFbHalPvtInfo->fifoContextAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize + pFbHalPvtInfo->hashTableSize;
            REG_WR_DRF_NUM(_PFIFO, _RAMFC, _BASE_ADDRESS, ((pFbHalPvtInfo->fifoContextAddr - DEVICE_BASE(NV_PRAMIN)) >> FC_MIN_ALIGN_SHIFT));

            //
            // Configure runout area.
            //
            pFbHalPvtInfo->fifoRunoutSize = 512;
            pFbHalPvtInfo->fifoRunoutAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize +
                pFbHalPvtInfo->hashTableSize + pFbHalPvtInfo->fifoContextSize;
            pFbHalPvtInfo->fifoRunoutMask = pFbHalPvtInfo->fifoRunoutSize - 1;
            REG_WR32(NV_PFIFO_RAMRO, (DRF_DEF(_PFIFO, _RAMRO, _SIZE, _512) |
                                      DRF_NUM(_PFIFO, _RAMRO, _BASE_ADDRESS, (pFbHalPvtInfo->fifoRunoutAddr - DEVICE_BASE(NV_PRAMIN)) >> 9)));

            //
            // Sum of all allocations plus a little slop
            //
            pPramHalInfo->CurrentSize  = pFbHalPvtInfo->hashTableSize + pFbHalPvtInfo->fifoContextSize + pFbHalPvtInfo->fifoRunoutSize + 512;

            break;
        case FB_CONTROL_LOAD:
            break;
        case FB_CONTROL_UNLOAD:
            break;
        case FB_CONTROL_UPDATE:
            break;
        case FB_CONTROL_DESTROY:
            // We now do everything tiled (mode switches and fullscreen DOS boxes), so reverting
            // to a boot time non-tiled PFB_CONFIG_0 will corrupt the shutdown splash screen since
            // it was written to a tiled FB. If we're tiled at this point, we'll just stay tiled.
            if (pFbHalPvtInfo->tilingDisabled == TRUE) {
                REG_WR32(NV_PFB_CONFIG_0, pFbHalPvtInfo->fbSave[0]);
                REG_WR32(NV_PFB_CONFIG_1, pFbHalPvtInfo->fbSave[1]);
            }            
            break;
        case FB_CONTROL_INSTWR_DISABLE:
#if 0
            // We have a bug in NV4 hardware which makes the write protection also a read protection.
            // We'll depend on the save above to protect instance memory. If we turn on write protect, it may
            // cause problems on a restart, because either the BIOS image won't be found or can't be copied.
            // 
            //
            // Disable access to instance memory while a full-screen DOS VGA session is active, as they
            // may accidently (intentionally?) clear the entire framebuffer through VGA.
            //
            FLD_WR_DRF_DEF(_PFB, _CONFIG_0, _PRAMIN_WR, _DISABLED);
            FLD_WR_DRF_NUM(_PFB, _CONFIG_0, _PRAMIN_WR_MASK, 0x0001);
#endif
            break;
        case FB_CONTROL_INSTWR_ENABLE:
            FLD_WR_DRF_DEF(_PFB, _CONFIG_0, _PRAMIN_WR, _INIT);
            break;
        case FB_CONTROL_TILING_DISABLE:
            pFbHalPvtInfo->tilingDisabled = TRUE;
            break;
        case FB_CONTROL_TILING_ENABLE:
            pFbHalPvtInfo->tilingDisabled = FALSE;
            break;
        case FB_CONTROL_TILING_CONFIGURE:
            nvHalTetrisTile_NV04(pFbControlArg->pHalHwInfo);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}


//
// nvHalFbGetSurfacePitch
//
// Given a width and bits per pixel, return the surface pitch
//

// I don't like this #ifdef ... this is just for the nightly build
#ifdef NTRM
#define NV4_PITCHALIGN  0x1F
#else
#define NV4_PITCHALIGN  0x3F
#endif

RM_STATUS
nvHalFbGetSurfacePitch_NV04(VOID *arg)
{
    PFBGETSURFACEPITCHARG_000 pFbGetSurfacePitchArg = (PFBGETSURFACEPITCHARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbGetSurfacePitchArg->id != FB_GET_SURFACE_PITCH_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (depending on who you talk to) 32byte/64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pFbGetSurfacePitchArg->pitch = ((pFbGetSurfacePitchArg->width * ((pFbGetSurfacePitchArg->bpp+1) >> 3)) + NV4_PITCHALIGN) & ~NV4_PITCHALIGN;

    return RM_OK;
}

//
// nvHalFbGetSurfaceDimensions
//
// Given a width, height and bits per pixel, return the surface pitch and size
//
RM_STATUS
nvHalFbGetSurfaceDimensions_NV04(VOID *arg)
{
    PFBGETSURFACEDIMENSIONSARG_000 pFbGetSurfaceDimensionsArg = (PFBGETSURFACEDIMENSIONSARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbGetSurfaceDimensionsArg->id != FB_GET_SURFACE_DIMENSIONS_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (depending on who you talk to) 32byte/64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pFbGetSurfaceDimensionsArg->pitch = ((pFbGetSurfaceDimensionsArg->width * ((pFbGetSurfaceDimensionsArg->bpp+1) >> 3)) + NV4_PITCHALIGN) & ~NV4_PITCHALIGN;
    pFbGetSurfaceDimensionsArg->size  = pFbGetSurfaceDimensionsArg->pitch * pFbGetSurfaceDimensionsArg->height;

    return RM_OK;
}

//
// nvHalFbAlloc
//
// Reserve a tile if one is available.
//
RM_STATUS
nvHalFbSetAllocParameters_NV04(VOID *arg)
{
    PFBSETALLOCPARAMSARG_000 pFbSetAllocParamsArg = (PFBSETALLOCPARAMSARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbSetAllocParamsArg->id != FB_SET_ALLOC_PARAMS_000)
        return (RM_ERR_VERSION_MISMATCH);

    return (RM_OK);
}

//
// nvHalFbAlloc
//
RM_STATUS
nvHalFbAlloc_NV04(VOID *arg)
{
    PFBALLOCARG_000 pFbAllocArg = (PFBALLOCARG_000)arg;
    PFBALLOCINFO pFbAllocInfo;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbAllocArg->id != FB_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pFbAllocInfo = pFbAllocArg->pAllocInfo;

    //
    // Set default alignment based on type.
    //
    switch (pFbAllocInfo->type) {
    case MEM_TYPE_IMAGE:
    case MEM_TYPE_OVERLAY:      
        pFbAllocInfo->align = 0x3f;     // 64 byte alignment
        break;
    case MEM_TYPE_TEXTURE:
        pFbAllocInfo->align = 0xff;     // 256 byte alignment
        break;
    case MEM_TYPE_FONT:
        pFbAllocInfo->align = 0x1f;     // 32 byte alignment
        break;
    case MEM_TYPE_CURSOR:
        pFbAllocInfo->align = 0x7ff;    // 2048 byte alignment
        break;
    case MEM_TYPE_DMA:
        pFbAllocInfo->align = 0x3;      // 4 byte alignment
        break;
    case MEM_TYPE_INSTANCE:
        pFbAllocInfo->align = 0xf;      // 16 byte alignment
        break;
    case MEM_TYPE_DEPTH:
    case MEM_TYPE_DEPTH_COMPR16:
    case MEM_TYPE_DEPTH_COMPR32:
    case MEM_TYPE_PRIMARY:
    case MEM_TYPE_IMAGE_TILED:
        pFbAllocInfo->align = 0xfff;    // 4096 byte alignment
        break;
    default:
        pFbAllocInfo->align = 0;
        return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalFbFree
//
RM_STATUS
nvHalFbFree_NV04(VOID *arg)
{
    PFBFREEARG_000 pFbFreeArg = (PFBFREEARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pFbFreeArg->id != FB_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    return (RM_OK);
}

RM_STATUS
nvHalFbLoadOverride_NV04(VOID *arg)
{
    PFBLOADOVERRIDEARG_000 pFbLoadOverrideArg = (PFBLOADOVERRIDEARG_000)arg;
    PHALHWINFO pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pFbLoadOverrideArg->id != FB_LOAD_OVERRIDE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbLoadOverrideArg->pHalHwInfo;

    switch (pFbLoadOverrideArg->cmd)
    {
        case FB_LOAD_OVERRIDE_MEMORY:
            REG_WR32(NV_PFB_CONFIG_1, pFbLoadOverrideArg->value);
            break;
        case FB_LOAD_OVERRIDE_RTL:
            REG_WR32(NV_PFB_RTL, pFbLoadOverrideArg->value);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//CAH: Setup to detect possible alliasing of memory to tell us we have double
//the memory that we actually do. This algorithm will detect the case where
//memory addresses lay on top of eachother so as to make it appear that there
//is twice the memory available than is physically present. 
static U032 nvHalFbRealMemSize(U032 RamSizeMb, PHWREG base)
{
    U032 i, wp, actual_ram_size = 0;
    U032 checksum1 = 0, checksum2 = 0;
    U032 fb_save[128]; 

    //Write 0,1,2,3,...N on each 1mb boundry in the FB
    for (i = 0, wp = 0; i < RamSizeMb; i++, wp += 0x00100000) 
    {
        fb_save[i] = base->Reg032[wp/4];
        base->Reg032[wp/4] = i;
        checksum1 += i;
        checksum2 = calcChkSum(base, i);
        if (checksum1 != checksum2)
        {
            restoreFbSave(fb_save, base, i);
            return i; 
        }
    }

    restoreFbSave(fb_save, base, --i);
    return RamSizeMb; //This means we made it all the way through memory.
}

static void restoreFbSave(U032 *save, PHWREG base, U032 index)
{
    U032 i, wp;

    for (i = 0, wp = 0; i <= index; i++, wp += 0x00100000)
    {
        base->Reg032[wp/4] = save[i];
    }
}

static U032 calcChkSum(PHWREG base, U032 index)
{
    U032 i, wp, checksum = 0;

    for (i = 0, wp = 0; i <= index; i++, wp += 0x00100000)
    {
        checksum += base->Reg032[wp/4];
    }

    return checksum;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\fifo\nv\fifo.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FIFO Manager *******************************\
*                                                                           *
* Module: FIFO.C                                                            *
*   The FIFO is managed in this module.  Allocating and controlling the     *
*   FIFO hardware and servicing FIFO exceptions belong here.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20\nv20_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <gr.h>
#include <os.h>
#include "control.h"
#include "nvhw.h"
#include "smp.h"

#ifdef WIN32
#include "nvwin32.h"   // XXX this shouldn't be needed
#else
#define NV_OS_WRITE_THEN_AWAKEN	   0x00000001
#endif


#ifdef DEBUG
U032 findex = 0;
U032 fifolog[MAX_FIFOLOG_LENGTH];
#endif

//---------------------------------------------------------------------------
//
//  FIFO assignment and deassignment to a client.
//
//---------------------------------------------------------------------------

//
// Allocate a User FIFO and return its channel ID.
//
RM_STATUS fifoAlloc
(
    PHWINFO pDev,
    U032    ClassNum,
    U032   *ChannelID
)
{
    U032       i;
    U032       ChID;
    U032       SemaState;
    PCLASS     pClass;
    U032       instSize, instAlign, instance;
    RM_STATUS  status;

    //
    // Make sure this channel class is supported on this chip.
    //
    if (classGetClass(&pDev->classDB, ClassNum, &pClass) == RM_ERROR)
        return RM_ERR_BAD_CLASS;

    //
    // If this class requires additional instance memory, get it now.
    //
    if (pClass->ClassInstMalloc)
    {
        instSize = CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _SIZE);
        instAlign = CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _ALIGN);

        if (instAlign)
            status = fbAllocInstMemAlign(pDev, &instance, instSize, instAlign);
        else
            status = fbAllocInstMem(pDev, &instance, instSize);
        if (status)
            return (status);
    }
    else
    {
        instance = 0; instSize = 0;
    }

    //
    // This is an API routine. Aquire semaphore.
    //
    osWaitSemaphore(&SemaState);
    //
    // Look for unused FIFO.
    //    
    for (ChID = 0; ChID < NUM_FIFOS; ChID++)
    {
        if (!pDev->DBfifoTable[ChID].InUse)
        {
            pDev->DBfifoTable[ChID].ObjectCount             = 0;
            pDev->DBfifoTable[ChID].ObjectTree              = NULL;
            pDev->DBfifoTable[ChID].InUse                   = TRUE;
            pDev->DBfifoTable[ChID].IsStalledPendingVblank  = FALSE;
            pDev->DBfifoTable[ChID].StallNotifier           = NULL;
            pDev->DBfifoTable[ChID].Put                     = 0;
            pDev->DBfifoTable[ChID].LastIllegalMthdObject   = NULL;
            pDev->DBfifoTable[ChID].Instance                = instance;
            pDev->DBfifoTable[ChID].InstanceSize            = instSize;
            for (i=0; i<NUM_SUBCHANNELS; i++)
                pDev->DBfifoTable[ChID].SubchannelContext[i] = NULL;
            
            break;
        }
    }
    if (ChID == NUM_FIFOS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No allocatable FIFO available.\n\r");
        osSignalSemaphore(&SemaState);
        if (instance) fbFreeInstMem(pDev, instance, instSize);
        return (RM_ERR_NO_FREE_FIFOS);
    }
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Allocate FIFO #", ChID);
    //
    // Install CLASS objects into object tree.
    //
    // KJK This goes away once NvAllocObject() is implemented.
    //
    if (classCreateWellKnownObjects(pDev, ChID) != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unable to create well-known names!\n");
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].InUse = FALSE;
        osSignalSemaphore(&SemaState);
        if (instance) fbFreeInstMem(pDev, instance, instSize);
        return (RM_ERR_CANT_CREATE_CLASS_OBJS);
    }

    osEnterCriticalCode(pDev);
    nvHalFifoAllocPio(pDev, ChID, instance);
    osExitCriticalCode(pDev);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: fifoAllocate - CACHE1 currently mapped to ChID ", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID));
    //
    // This is an API routine.  Release semaphore.
    //
    osSignalSemaphore(&SemaState);
    *ChannelID = ChID;
    return (RM_OK);
}
//
// Allocate a User DMA FIFO and return its channel ID.
//
RM_STATUS fifoAllocDma
(
    PHWINFO pDev,
    U032    ClassNum,
    U032   *ChannelID,
    PDMAOBJECT pDmaObject
)
{
    U032       i;
    U032       ChID;
    U032       SemaState;
    U032       fetchTrigger, fetchSize, fetchRequests;
    U032       instSize, instAlign, instance;
    PCLASS     pClass;
    RM_STATUS  status;

    //
    // Make sure this channel class is supported on this chip.
    //
    if (classGetClass(&pDev->classDB, ClassNum, &pClass) == RM_ERROR)
        return RM_ERR_BAD_CLASS;

    //
    // If this class requires additional instance memory, get it now.
    //
    if (pClass->ClassInstMalloc)
    {
        instSize = CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _SIZE);
        instAlign = CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _ALIGN);

        if (instAlign)
            status = fbAllocInstMemAlign(pDev, &instance, instSize, instAlign);
        else
            status = fbAllocInstMem(pDev, &instance, instSize);
        if (status)
            return (status);
    }
    else
    {
        instance = 0; instSize = 0;
    }

    //
    // Get default fetch parameters.
    //
    if (osSetFifoDmaParams(pDev, &fetchTrigger, &fetchSize, &fetchRequests))
        return RM_ERR_OPERATING_SYSTEM;

    //
    // This is an API routine. Aquire semaphore.
    //
    osWaitSemaphore(&SemaState);
    //
    // Look for unused FIFO.
    //    
    for (ChID = 0; ChID < NUM_FIFOS; ChID++)
    {
        if (!pDev->DBfifoTable[ChID].InUse)
        {
            pDev->DBfifoTable[ChID].ObjectCount             = 0;
            pDev->DBfifoTable[ChID].ObjectTree              = NULL;
            pDev->DBfifoTable[ChID].InUse                   = TRUE;
            pDev->DBfifoTable[ChID].IsStalledPendingVblank  = FALSE;
            pDev->DBfifoTable[ChID].StallNotifier           = NULL;
            pDev->DBfifoTable[ChID].Put                     = 0;
            pDev->DBfifoTable[ChID].LastIllegalMthdObject   = NULL;
            for (i=0; i<NUM_SUBCHANNELS; i++)
                pDev->DBfifoTable[ChID].SubchannelContext[i] = NULL;
            pDev->DBfifoTable[ChID].Instance                = instance;
            pDev->DBfifoTable[ChID].InstanceSize            = instSize;
            break;
        }
    }
    if (ChID == NUM_FIFOS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No allocatable FIFO available.\n\r");
        osSignalSemaphore(&SemaState);
        if (instance) fbFreeInstMem(pDev, instance, instSize);
        return (RM_ERR_NO_FREE_FIFOS);
    }
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Allocate FIFO #", ChID);
    //
    // Install CLASS objects into object tree.
    //
    // KJK This goes away once NvAllocObject() is implemented.
    //
    if (classCreateWellKnownObjects(pDev, ChID) != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unable to create well-known names!\n");
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].InUse = FALSE;
        osSignalSemaphore(&SemaState);
        if (instance) fbFreeInstMem(pDev, instance, instSize);
        return (RM_ERR_CANT_CREATE_CLASS_OBJS);
    }

    osEnterCriticalCode(pDev);
    status = nvHalFifoAllocDma(pDev, ChID, instance, pDmaObject->HalInfo.Instance, fetchTrigger, fetchSize, fetchRequests);
    osExitCriticalCode(pDev);
    if (status != RM_OK)
    {
        pDev->DBfifoTable[ChID].InUse = FALSE;
        osSignalSemaphore(&SemaState);
        if (instance) fbFreeInstMem(pDev, instance, instSize);
        return (status);
    }

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: fifoAllocateDma - CACHE1 currently mapped to ChID ", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID));

    //
    // This is an API routine.  Release semaphore.
    //
    osSignalSemaphore(&SemaState);
    *ChannelID = ChID;
    return (RM_OK);
}

//
// Free up a User FIFO to the available pool.
//
RM_STATUS fifoFree
(
    PHWINFO pDev,
    U032    ChID
)
{
    POBJECT           DeadObject;
    U032              SemaState;

    //
    // This is an API routine.  Aquire semaphore.
    //
    osWaitSemaphore(&SemaState);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Freeing FIFO on ChID: ", ChID);

    //
    // Reset the channel, so it's in an idle state and clear the hashTable
    // for this ChID.
    //
    fifoResetChannelState(pDev, ChID);

    //
    // Remove objects from object database.
    //
    while (pDev->DBfifoTable[ChID].ObjectTree)
    {
        //
        // Free up all remaining objects.
        //                            
        DeadObject = (POBJECT)pDev->DBfifoTable[ChID].ObjectTree->Data;
        fifoDelObject(pDev, DeadObject);
        //
        // Class specific delete procedure.
        //
        //DeadObject->Name = NV_ZOMBIE_OBJECT;
        classDestroy((VOID*)pDev, DeadObject);
    }

#ifdef DEBUG
    if (pDev->DBfifoTable[ChID].ObjectCount != 0)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Object count not zero after deleting object tree!\n\r");
        DBG_BREAKPOINT();
    }
#endif // DEBUG

    pDev->DBfifoTable[ChID].InUse = FALSE;

    //
    // Release any instance memory.  State in fifo object is
    // cleared when it's reallocated.
    //
    if (pDev->DBfifoTable[ChID].Instance != 0)
    {
        fbFreeInstMem(pDev, pDev->DBfifoTable[ChID].Instance, pDev->DBfifoTable[ChID].InstanceSize);
    }
    
    //
    // This is an API routine.  Release semaphore.
    //
    osSignalSemaphore(&SemaState);

    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  HASH table management.
//
//---------------------------------------------------------------------------

//
// Add entry into Hash Table.
//
RM_STATUS fifoAddHashEntry
(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID,
    U032    Instance
)
{
    U032 Hash, Entry, Limit;

    //
    // Query HAL for starting entry for this <handle,chid> pair.
    //
    nvHalFifoHashFunc(pDev, Object->Name, ChID, &Hash);

    //
    // Search table for free slot.
    //
    // We can't exceed the hardware's search limit and we also can't wrap
    // since there's a bug in current chips that prevents the hardware from
    // wrapping on a search.
    //
    Limit = Hash + pDev->Pram.HalInfo.HashSearch;
    if (Limit > pDev->Pram.HalInfo.HashDepth)
        Limit = pDev->Pram.HalInfo.HashDepth;
    for (Entry = Hash; Entry < Limit; Entry++)
    {
        //
        // Find first empty entry.
        //
        if (pDev->DBhashTable[Entry].Object == NULL)
            break;
    }

    if (pDev->DBhashTable[Entry].Object != NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: FIFO Hash table is FULL!!\n\r");
        return (RM_ERROR);
    }

    //
    // Add object to the Hash Table.
    //
    pDev->DBhashTable[Entry].Object = Object;
    pDev->DBhashTable[Entry].ChID   = ChID;

    nvHalFifoHashAdd(pDev, Entry, Object->Name, ChID, Instance,
                     ENGDECL_FIELD(*Object->Class->EngineDecl, _OBJRAMHT));

    return (RM_OK);
}
//
// Remove entry from Hash Table.
//
RM_STATUS fifoDelHashEntry
(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID    
)
{
    U032              Entry;
    
    //
    // Skip hashing since we scan the whole table.
    //
    for (Entry = 0; Entry < pDev->Pram.HalInfo.HashDepth; Entry++)
    {
        if (pDev->DBhashTable[Entry].Object == Object && pDev->DBhashTable[Entry].ChID == ChID)
        {
            pDev->DBhashTable[Entry].Object = NULL;
            nvHalFifoHashDelete(pDev, Entry);
            return (RM_OK);
        }
    }
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  FIFO exception handling.
//
//---------------------------------------------------------------------------

#define BENSWORK

V032 fifoService
(
    PHWINFO pDev
)
{
    RM_STATUS status;
    V032      intr;
    POBJECT   Object;
    FIFOEXCEPTIONDATA FifoExceptionData;
    U032 i;
#ifdef BENSWORK
    U032      isDebuggerPresent;
    U032      mustNotifyDebugger;

    isDebuggerPresent  = ((PRMINFO)pDev->pRmInfo)->Debugger.object != NULL;
    mustNotifyDebugger = 0;
#endif

    status = RM_OK;
    intr   = REG_RD32(NV_PFIFO_INTR_0);

    //
    // Get exception data from HAL.
    //
    nvHalFifoGetExceptionData(pDev, &FifoExceptionData);

    //
    // Here's where we'd bypass HAL fifo exception handling if needed.
    // 

    //
    // Give HAL chance to service selected exceptions.
    //
    nvHalFifoService(pDev, intr, &FifoExceptionData);

    //
    // HACK-O-RAMA: Work around a call/return bug where the call stack
    //  register does not get reset.
    //
    intr = REG_RD32(NV_PFIFO_INTR_0);

    if (intr & DRF_DEF(_PFIFO, _INTR_0, _DMA_PUSHER, _PENDING))
    {
        U032 State;

        State =  REG_RD32(NV_PFIFO_CACHE1_DMA_STATE);
 
        if (State == 0x2000D72C || State == 0x2000c054)
        {
            U032 GetPtr;
   
            // Clear condition.
            //
            REG_WR_DRF_DEF(_PFIFO, _INTR_0, _DMA_PUSHER, _RESET);
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);

            // Fix the bug.
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_SUBROUTINE, 0);

            // Wait until idle.
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY);

            // We've moved beyond the instruction that caused the failure.  Set the
            // get pointer back 4 bytes and try it again.
            //
            GetPtr = REG_RD32(NV_PFIFO_CACHE1_DMA_GET);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, GetPtr-4);

            // Turn the push buffer back on
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);

            intr = REG_RD32(NV_PFIFO_INTR_0);
        }
    }
    
    //
    // Refresh interrupt status value in case HAL cleared any exceptions.
    //
    if (intr & DRF_DEF(_PFIFO, _INTR_0, _CACHE_ERROR, _PENDING))
    {
        //
        // Cache error handler.  We got here due to one of two issues.
        //
        // 1) The current object that was just hashed/routed is configured
        //    as a SW_ENGINE object
        // 2) There is no hash entry available for the current object
        //
                
        //
        // Disable the fifo
        //
        // Don't explicitly disable the puller -- it should already
        // be off by the time we get here.  Verify with an assert().
        //
        REG_WR_DRF_DEF(_PFIFO, _CACHES,       _REASSIGN, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);

        FIFOLOG(1, 0, 0);

        //
        // Clear condition.
        //
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _CACHE_ERROR,  _RESET);

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FIFO Cache miss Channel:", FifoExceptionData.ChID);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                  sub channel:", FifoExceptionData.SubChannel);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                       method:", FifoExceptionData.Method);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                         data:", FifoExceptionData.Data);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                       reason:", FifoExceptionData.Reason);

        //
        // Timeout
        //
        i = 0xFFFF;
        while (i && (FifoExceptionData.Reason & DRF_DEF(_PFIFO, _CACHE1_PULL0, _HASH_STATE, _BUSY)))
        {
            i--;
            FifoExceptionData.Reason     = REG_RD32(NV_PFIFO_CACHE1_PULL0);
        }                

        if (FifoExceptionData.Reason & DRF_DEF(_PFIFO, _CACHE1_PULL0, _HASH, _FAILED))
        {
            U032 result;
            //
            // On IKOS, we sometimes see spurious hash errors (where looking manually we
            // find the hash entry). If so, clear FifoExceptionData.Reason and allow the HW
            // to retry.
            //
            nvHalFifoHashSearch(pDev, FifoExceptionData.Data, FifoExceptionData.ChID, &result);
            if (result) {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: HW missed valid hash entry:", FifoExceptionData.Data);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CACHE1 get ptr:", FifoExceptionData.GetPtr);
                FifoExceptionData.Reason = 0x0;
            } else {
                //
                // Hash failure.  This had better be a master class.
                //
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: FIFO Cache Error due to hash failure\n\r");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                     channel:", FifoExceptionData.ChID);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                 sub channel:", FifoExceptionData.SubChannel);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                      offset:", FifoExceptionData.Method);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                        data:", FifoExceptionData.Data);
            }
        }

#ifdef IKOS
        //
        // This captures any unexpected strangeness on IKOS. In particular make
        // sure the engine bits for objects in subchannels agree.
        // 
        if (FifoExceptionData.Reason & DRF_DEF(_PFIFO, _CACHE1_PULL0, _DEVICE, _SOFTWARE))
        {
            U032 pull1, engine1;

            // If we find a disagreement in the register engine bits, clear the reason and retry
            pull1   = REG_RD_DRF(_PFIFO, _CACHE1_PULL1, _ENGINE);
            engine1 = (REG_RD32(NV_PFIFO_CACHE1_ENGINE) >> (FifoExceptionData.SubChannel * 4)) & 0xF;

            if (pull1 ^ engine1)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: CACHE1 PULL1/ENGINE differ in engine bits\n\r");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CACHE1 get ptr:", FifoExceptionData.GetPtr);
                DBG_BREAKPOINT();
                FifoExceptionData.Reason = 0x0;
            } else {
                Object = pDev->DBfifoTable[FifoExceptionData.ChID].SubchannelContext[FifoExceptionData.SubChannel];
                if ((FifoExceptionData.Method >= 0x0100) && !Object)
                {
                    // Retry if this isn't a SetObject method and we never saw the SetObject
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: This should've been a HW method:", FifoExceptionData.Method);
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CACHE1 get ptr:", FifoExceptionData.GetPtr);
                    DBG_BREAKPOINT();
                    FifoExceptionData.Reason = 0x0;
                }
            }
        }
#endif

        if ((FifoExceptionData.Reason & DRF_DEF(_PFIFO, _CACHE1_PULL0, _DEVICE, _SOFTWARE))
            || (FifoExceptionData.Reason & DRF_DEF(_PFIFO, _CACHE1_PULL0, _HASH, _FAILED)))
        {
            //
            // Software method
            //
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: FIFO Cache miss due to software object\n\r");
      
            if ((FifoExceptionData.ChID < NUM_FIFOS) && pDev->DBfifoTable[FifoExceptionData.ChID].InUse)
            {
                if (FifoExceptionData.Method < 0x0100)
                {
                    status = fifoSoftwareMethod(pDev, &FifoExceptionData);
                } 
                else
                {                        
                    // 
                    // First we need to find the object to send this method.
                    //
                    // Do this brute force.  Search the whole fifo tree for the object.
                    // 
                    // Go find the minimum value (>0) and start there.  That way we're
                    // sure to visit every node.
                    //
                    Object = pDev->DBfifoTable[FifoExceptionData.ChID].SubchannelContext[FifoExceptionData.SubChannel];
                        
                    //
                    // If we found a valid object, route the method
                    //
                    if (Object)
                    {
                        status = classSoftwareMethod(pDev, Object, FifoExceptionData.Method, FifoExceptionData.Data);

                        //if (status != RM_OK)
                        //    notifyDefaultError(pDev, Object, Method, Data, ChID, status);
                    }
                    else
                    {
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: No valid object in subchannel:", FifoExceptionData.SubChannel);
                    }
                }                        
                        
            }    
            else
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Access to free channel:", FifoExceptionData.ChID);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                 sub channel:", FifoExceptionData.SubChannel);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                      offset:", FifoExceptionData.Method);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                        data:", FifoExceptionData.Data);
            }

            //
            // Advance the FIFO get pointer.
            //
            FifoExceptionData.GetPtr++;
            REG_WR_DRF_NUM(_PFIFO, _CACHE1_GET, _ADDRESS, FifoExceptionData.GetPtr);    // no more gray coding
        }

        //
        // Clear the fifo's hash result
        //
        REG_WR32(NV_PFIFO_CACHE1_HASH, 0);

        //
        // Re-enable cache draining.
        //
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHES,       _REASSIGN, _ENABLED);
    }

    if (intr & DRF_DEF(_PFIFO, _INTR_0, _RUNOUT_OVERFLOW, _PENDING))
    {
        //
        // Clear condition.
        //
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _RUNOUT_OVERFLOW, _RESET);
        //
        // RunOut overflow.  Bad news.
        //
        // KJK: Do we wish to attempt to recover from this error?  Maybe close this channel
        // and attempt to recover to other valid channels?
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: ERROR = FIFO runout overflow! Bad News!!!\n\r", intr);
        REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        status = RM_ERR_FIFO_RUNOUT_OVERFLOW;
    }

    if (intr & DRF_DEF(_PFIFO, _INTR_0, _DMA_PUSHER, _PENDING))
    {
        // create a write cycle to the FB (used as an analyzer trigger).
        fbAddr->Reg032[0] = 0xDEADCAFE;
    
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: DMA Pusher encountered a parse error.\n\r");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:     Push Error: ", REG_RD32(NV_PFIFO_CACHE1_DMA_STATE));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:        Get Ptr: ", REG_RD32(NV_PFIFO_CACHE1_DMA_GET));
//#ifdef MOVETOHAL
        if (IsNV5orBetter(pDev)) {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:  Dwords Xfered: ", REG_RD32(NV_PFIFO_CACHE1_DMA_DCOUNT));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:    Last jmp at: ", REG_RD32(NV_PFIFO_CACHE1_DMA_GET_JMP_SHADOW));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:       Last cmd: ", REG_RD32(NV_PFIFO_CACHE1_DMA_RSVD_SHADOW));
            //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:      Last data: ", REG_RD32(NV_PFIFO_CACHE1_DMA_DATA_SHADOW));
        }
//#endif
#ifdef BENSWORK // case 4
        // external debugger registered?
        if (isDebuggerPresent)
        {
            NvdeAppendEventForDebugger ((PNVDEOBJECT)(PNVDEOBJECT)((PRMINFO)pDev->pRmInfo)->Debugger.object,4,4,0,0,0,0,0,0);
            mustNotifyDebugger = 1;
        }
        else
        {
            DBG_BREAKPOINT();
        }
#else
        DBG_BREAKPOINT();
#endif
    
        //
        // Clear condition.
        //
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _DMA_PUSHER, _RESET);
        REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
        
        //
        // The dma pusher has faulted while processing the push buffer stream.  This is
        // probably due to an invalid jump or bad opcode.
        //
        // Move the get pointer forward if necessary to skip this bad data
        //
        if (REG_RD32(NV_PFIFO_CACHE1_DMA_PUT) != REG_RD32(NV_PFIFO_CACHE1_DMA_GET))
        {
            U032 GetPtr;

            GetPtr = REG_RD32(NV_PFIFO_CACHE1_DMA_GET);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, GetPtr+4);
            //
            // This somehow needs to account for rollover, but without parsing the data, I don't
            // know where to roll to.
            //
        }                
    }

    if (intr & DRF_DEF(_PFIFO, _INTR_0, _DMA_PT, _PENDING))
    {
#ifdef TRAP_HOST_FIFO_SWITCHES
        // 
        // We're now expect this intr as a way to know what
        // the host FIFO is doing.
        //
        extern U032 dma_inst[32];
        static U032 prev_chid;
        U032 FifoCtxtPtr, fc_data;

        // turnoff reassign
        FLD_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,      "Prev ChID: ", FifoExceptionData.ChID);

        // First, clear out prev_chid FIFO context inst addr, so he faults again
        FifoCtxtPtr = pDev->halHwInfo.pPramHalInfo->FifoContextAddr + (prev_chid * 32);
        fc_data = REG_RD32((U032)(FifoCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_INST)));
        fc_data &= 0xFFFF0000;    // mask off the inst addr
        REG_WR32((U032)(FifoCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_INST)), fc_data);

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,      "New  ChID: ", FifoExceptionData.ChID);

        // load into HW the inst addr
        REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, dma_inst[FifoExceptionData.ChID]);

        // Force a reread of the DMA pusher address
        REG_WR32(NV_PFIFO_CACHE1_DMA_CTL, 0);
        prev_chid = FifoExceptionData.ChID;

        // turn reassign back on
        FLD_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _ENABLED);
#endif

        //
        // Bad news if we get this -- the fifo engine must have attempted to fetch an invalid
        // dma page.  We could attempt to reconstruct what was meant to happen, or we can
        // just barf for now.  I vote for barfing...
        //
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _DMA_PT, _RESET);
        DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Invalid DMA pusher PTE fetch.\n\r");
#ifdef BENSWORK // case 5
        // external debugger registered?
        if (isDebuggerPresent)
        {
            NvdeAppendEventForDebugger ((PNVDEOBJECT)((PRMINFO)pDev->pRmInfo)->Debugger.object,5,4,0,0,0,0,0,0);
            mustNotifyDebugger = 1;
        }
        else
        {
            DBG_BREAKPOINT();
        }
#else
        DBG_BREAKPOINT();
#endif
    }
    
    //
    // If the dma pusher is currently suspended, wait until the CACHE1 is empty
    // and then set it running again.
    //
    if (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATUS) == NV_PFIFO_CACHE1_DMA_PUSH_STATUS_SUSPENDED)
    {
        while (REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
        {
            // If there's a pending FIFO intr, make this check after servicing it
            if (REG_RD32(NV_PFIFO_INTR_0))
                break;

            // Check if GE needs servicing
            if (REG_RD32(NV_PGRAPH_INTR))
                grService(pDev);

            // Check if vblank needs servicing (for NV15 HW flip)
            if (REG_RD32(NV_PMC_INTR_0) & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
                VBlank(pDev);
        }
        if (REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) == NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
        {
            while (REG_RD_DRF(_PFIFO, _CACHES, _DMA_SUSPEND) == NV_PFIFO_CACHES_DMA_SUSPEND_BUSY)
			    ;
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _STATUS, _RUNNING);
        }
    }

#if 0
    //
    // Re-enable the dma pusher if this was a pusher channel
    //
    if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
    {
        //
        // Wait til idle
        //
        while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY);

        //
        // Turn it back on (in the process will also clear DMA_PUSH_STATUS_SUSPENDED)
        //    
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);
    }
#endif
    
    //
    // Re-enable FIFO CACHE1 if all conditions cleared.
    //
    if (REG_RD32(NV_PFIFO_INTR_0) == 0x00000000)
    {
#ifdef BENSWORK
        if (mustNotifyDebugger)
        {
            osNotifyEvent(pDev, ((PRMINFO)pDev->pRmInfo)->Debugger.object, 0, 0, 0, RM_OK, NV_OS_WRITE_THEN_AWAKEN);
        }
        else
        {
#endif
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
#ifdef BENSWORK
        }
#endif
    }
    intr = REG_RD32(NV_PFIFO_INTR_0);
    //
    // See if there is yet another FIFO exception to be handled.
    // Just need to make sure that "intr" is non-zero in order to
    // get more servicing done.
    //
    intr |= REG_RD_DRF(_PFIFO, _DEBUG_0, _CACHE_ERROR0);
    return (intr);
}

//
// Emulate the device access in software.
//
RM_STATUS fifoSoftwareMethod
(
    PHWINFO pDev,
    PFIFOEXCEPTIONDATA pFifoExceptionData
)
{
    U032 i;
  
    // Dispatch the requested software method
    for (i = 0; i < NvControlClass.MethodMax; i++)
        {
            if ((pFifoExceptionData->Method >= NvControlClass.Method[i].Low)
            &&  (pFifoExceptionData->Method <  NvControlClass.Method[i].High))
            {
            
                return(NvControlClass.Method[i].Proc(pDev,
                                                     pFifoExceptionData->ChID,
                                                     pFifoExceptionData->SubChannel,
                                                     &(NvControlClass.Method[i]),
                                                     pFifoExceptionData->Method,
                                                     pFifoExceptionData->Data));
            }
        }
    //
    // Method not found
    //
    DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: invalid control access ");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "              offset ", pFifoExceptionData->Method);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "                data ", pFifoExceptionData->Data);
    return (RM_ERR_FIFO_BAD_ACCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\fb\nv\fbinit.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FB Manager *********************************\
*                                                                           *
* Module: FBINIT.C                                                          *
*   The FrameBuffer is initialized in this module.  This is a one time      *
* occurance and then the module is unloaded.                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include "nvhw.h"
#include <state.h>
#include <class.h>
#include <fb.h>
#include <vga.h>
#include <os.h>
#include <tv.h>
#include <vga.h>

//
// One time framebuffer initialization.
//
RM_STATUS initFb
(
    PHWINFO pDev
)
{
    U032 status;
    //
    // Turn off video.
    //
    // MUST BLANK MONITOR ... setting PFB_GREEN_0_VIDEO_DISABLED doesn't work.
    // The underlying routines (e.g. osSetVideoMode) need to do this before a
    // mode change.
    //
    // REG_WR_DRF_DEF(_PFB, _GREEN_0, _LEVEL, _VIDEO_DISABLED);

    //
    // Account for BIOS_IMAGE_PAD.  This could be made os-indepedendent
    // so we don't waste 64K on platforms that don't need the bios.
    //
    pDev->Pram.HalInfo.InstPadSize = BIOS_IMAGE_PAD;

    //
    // Let HAL establish FB parameters:
    //   - dram sizes/bank counts
    //   - fifo context/hash table/run out sizes
    //
    status = nvHalFbControl(pDev, FB_CONTROL_INIT);

    //Did we config the frame buffer correctly? 
    if (status != RM_OK)
    {
        return (RM_ERROR);
    }
    //
    // Locate and size the free instance area. This is the base where
    // allocations should start and size of the allocatable inst mem.
    //
    pDev->Pram.FreeInstSize = pDev->Pram.HalInfo.TotalInstSize - BIOS_IMAGE_PAD - pDev->Pram.HalInfo.CurrentSize;
    pDev->Pram.FreeInstBase = (pDev->Pram.HalInfo.CurrentSize + BIOS_IMAGE_PAD) >> 4;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FreeInstSize ", pDev->Pram.FreeInstSize);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FreeInstBase ", pDev->Pram.FreeInstBase);

    //
    // Default to 640X480X16X1 framebuffer w/ VGA timing.
    //
    pDev->Framebuffer.DpmLevel          = 0;
    pDev->Framebuffer.HalInfo.HorizDisplayWidth = 640;
    pDev->Framebuffer.HalInfo.VertDisplayWidth  = 480;
    pDev->Dac.HalInfo.Depth     = 16;
    pDev->Framebuffer.HalInfo.RefreshRate       = 60;
    pDev->Framebuffer.Count             = 1;
    pDev->Framebuffer.Current           = 0;
    pDev->Framebuffer.FlipUsageCount    = 0;
    pDev->Framebuffer.FlipTo            = 0;
    pDev->Framebuffer.FlipFrom          = 0;
    pDev->Framebuffer.UpdateFlags       = 0;
    pDev->Framebuffer.HorizFrontPorch   = 0;
    pDev->Framebuffer.HorizSyncWidth    = 0;
    pDev->Framebuffer.HorizBackPorch    = 0;
    pDev->Framebuffer.VertFrontPorch    = 0;
    pDev->Framebuffer.VertSyncWidth     = 0;
    pDev->Framebuffer.VertBackPorch     = 0;
    pDev->Framebuffer.HSyncPolarity     = 0;
    pDev->Framebuffer.VSyncPolarity     = 0;
    pDev->Framebuffer.CSync             = 0;

    pDev->Framebuffer.HalInfo.Start[0] = 0x00000000;
    pDev->Framebuffer.HalInfo.Limit[0] = pDev->Framebuffer.HalInfo.RamSize - pDev->Pram.HalInfo.TotalInstSize - 1;
    pDev->Framebuffer.HalInfo.Start[1] = 0x00000000;
    pDev->Framebuffer.HalInfo.Limit[1] = 0x00000000;

    //
    // Check for os-specific mode overrides.
    //
    initFbEx(pDev);

    //
    // Make sure our write protection is disabled for now
    //
    nvHalFbControl(pDev, FB_CONTROL_INSTWR_ENABLE);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RamSize ", pDev->Framebuffer.HalInfo.RamSize);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: TotalInstSize ", pDev->Pram.HalInfo.TotalInstSize);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Limit[0] ", pDev->Framebuffer.HalInfo.Limit[0]);

    return (fbCheckConfig(pDev));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\fb\nv\fbstate.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* Framebuffer Module ******************************\
*                                                                           *
* Module: FBSTATE.C                                                         *
*   The Framebuffer state is changed in this module.                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <os.h>
#include <nvhw.h>
#include <fb.h>
#include <heap.h>
#include <vga.h>


//
// Save registers for framebuffer.
//
// U032 fbSave[2];

//
// New routine to point to location of cursor in instance memory and enable it.
VOID fbEnableCursor(VOID);

// This should already be setup somewhere else
#define RM_GLOBAL_BASE_PATH    "SOFTWARE\\NVIDIA Corporation\\Global\\System"

//
// Here's a definition of how these globals are being used:
//
//        FreeInstSize  - size in bytes of allocatable inst memory.
//                        Based on BIOS_IMAGE_PAD and the allocations for RAMHT, RAMFC and RAMRO.
//
//
//        FreeInstMax   - size in paragraphs of allocatable inst memory.
//                        fbInstBitmap is sized from this value and scanning for free
//                        instance memory uses this as the max available. This value
//                        is FreeInstBase + FreeInstSize in paragraphs.
//
//        FreeInstBase  - base where instance memory allocations begin.
//                        The base has already skipped beyond the BIOS_IMAGE_PAD
//                        and the allocations for RAMHT, RAMFC and RAMRO.
//
//        TotalInstSize - size in bytes of all of instance memory.
//                        This includes:
//                              allocatable instance memory
//                              RAMHT + RAMFC + RAMRO
//                              BIOS_PAD_IMAGE
//

//
// Change Frambuffer hardware state.
//
RM_STATUS stateFb
(
    PHWINFO pDev,
    U032    msg
)
{
    RM_STATUS status;
    S032      size;
    U032      entry;
    int       i;

    status = RM_OK;

    //
    // Deal with state change.
    //
    switch (msg)
    {
        case STATE_UPDATE:
            if (pDev->Framebuffer.UpdateFlags & UPDATE_HWINFO_BUFFER_PARAMS)
            {
                //
                // Validate and calculate new framebuffer memory requirements.
                //
                fbCheckConfig(pDev);
            }
            if (pDev->Framebuffer.UpdateFlags & UPDATE_HWINFO_DISPLAY_PARAMS)
            {
                //
                // Validate and calculate new framebuffer memory requirements.
                //
                fbCheckConfig(pDev);

                //
                // This usage flag will be cleared by the dac state routine
                // after the display is updated
                //
                // pDev->Framebuffer.UpdateFlags &= ~UPDATE_HWINFO_DISPLAY_PARAMS;
            }
            break;
        case STATE_LOAD:

            //
            // Check for any os-specific fb overrides.  These overrides must be known now in case
            // we need to adjust how our framebuffer is aligned or tiled.
            //
			osStateFbEx(pDev);			// check for override on FilterEnable

            //
            // Verify framebuffer configuration.
            //
            fbCheckConfig(pDev);

            //
            // Call into HAL to finish setup of FB state.
            //
            nvHalFbControl(pDev, FB_CONTROL_LOAD);

            // Check if we need to create the heap
            if (pDev->Framebuffer.HeapHandle == NULL)
            {
                //
                // Allocate framebuffer heap.  All memory must be allocated from here to keep the world
                // consistent (N.B. the heap size has been reduced by the amount of instance memory).
                //
                if ((status = heapCreate(pDev,
                                         (U008 *)fbAddr,
                                         pDev->Framebuffer.HalInfo.RamSize - pDev->Pram.HalInfo.TotalInstSize,
                                         pDev->Framebuffer.HalInfo.BankCount,
                                         (PHEAP *)&(pDev->Framebuffer.HeapHandle))) != RM_OK)
                    return (status);
            }

            // Check if we need to allocate the primary surface
            // We don't need to if we are in 4 bpp (VGA.DRV is running).
            if ((pDev->Framebuffer.PrimarySurfaceAlloced == FALSE) && (pDev->Dac.HalInfo.Depth != 4))
            {
                U032 offset;

                // Allocate the primary surface
                nvHalFbGetSurfacePitch(pDev, pDev->Framebuffer.HalInfo.HorizDisplayWidth, pDev->Dac.HalInfo.Depth, &pDev->Dac.DisplayPitch);
                size = pDev->Dac.DisplayPitch * pDev->Framebuffer.HalInfo.VertDisplayWidth;

                // heapAlloc fills in pDev->Framebuffer.HalInfo.Start for MEM_TYPE_PRIMARY
                if ((status = heapAlloc(pDev,
                                        (PHEAP)pDev->Framebuffer.HeapHandle,
                                        'NVRM',
                                        (U032 *) &size,
                                        MEM_TYPE_PRIMARY,
                                        pDev->Framebuffer.HalInfo.VertDisplayWidth,
                                        &pDev->Dac.DisplayPitch,
                                        &offset)) != RM_OK)
                    return (status);
            }
            
            // 
            // For a tiled primary surface, we delay setting the tiled bit in the hardware
            // until after we've modeswitched out of VGA to prevent a garbled splash screen.
            // Just in case we haven't set it yet, do it now.
            //
            for (i=0; i<MAX_CRTCS; i++) {
                if (pDev->Framebuffer.HalInfo.PrimaryFbAllocInfo[i].hwResId != 0) {
                    heapFbSetAllocParameters(pDev, &pDev->Framebuffer.HalInfo.PrimaryFbAllocInfo[i]);
                }
            }

            //
            // Since we're no longer maintaining the cache across mode changes, just
            // wipe the cache clean.
            //
            for (entry=0; entry < MAX_CACHED_CURSORS; entry++)
            {
                pDev->Dac.CursorMaskCRC[entry] = 0;
            }
            pDev->Dac.CursorCached = 0;

            pDev->Framebuffer.UpdateFlags &= ~(UPDATE_HWINFO_BUFFER_PARAMS | UPDATE_HWINFO_DISPLAY_PARAMS);

            break;
        case STATE_UNLOAD:

            //
            // Turn off video.
            //
            // MUST BLANK MONITOR ... setting PFB_GREEN_0_VIDEO_DISABLED doesn't work.
            // The underlying routines (e.g. osSetVideoMode) need to do this before a
            // mode change.
            //
            // REG_WR_DRF_DEF(_PFB, _GREEN_0, _LEVEL, _VIDEO_DISABLED);
#if 0
            //
            // We're not calling heapDestroy as part of an state unload anymore.
            //           

#ifndef NTRM
            // Completely destroy the heap on mode switches. However, we don't want to destroy
            // the heap if we are going into or coming out of a full screen DOS box.
            if (!pDev->Vga.DOSBox)
#endif
            {
                // Free heap.
                heapDestroy(pDev, (PHEAP)pDev->Framebuffer.HeapHandle);
            }
#endif

            break;
        case STATE_INIT:
        {
            U032 data32, fb;

            //
            // Check the registry to see if we're not allowing pitch values to be rounded
            // up to what NV10 tiling requires (pitch must equal width for some old apps).
            // If so, we'll only tile a surface if the pitch is already aligned.
            //
            // We only want to not tile the lower resolutions with this flag, which means
            // just the 6x4 and 8x6 modes. But, we don't have width/height at all times
            // and checking against pitch has overlap with the other modes. So, we'll use
            // what we have at the time; width <= 800 or height <= 600 will be checked.
            //
            if (OS_READ_REGISTRY_DWORD(pDev, RM_GLOBAL_BASE_PATH, "NoAdjustedPitch", &data32) == RM_OK)
                pDev->Framebuffer.NoAdjustedPitch = 0x1;    // surface height check
            else
                pDev->Framebuffer.NoAdjustedPitch = 0x0;

            status = initFb(pDev);
            if (status != RM_OK)
            {
                return (RM_ERROR);
            }

            //
            // Reserve high block of fb mem as instance space.
            //
            for (fb = 0; fb < ((pDev->Pram.HalInfo.TotalInstSize - BIOS_IMAGE_PAD) / 4); fb++)
                REG_WR32(NV_PRAMIN_DATA032(fb) + BIOS_IMAGE_PAD, 0);

            //
            // Setup bitmap.
            //
            status = fbInitializeInstMemBitMap(pDev);
            if (status)
                return (status);

            //
            // Now that the instance bitmap is setup, we can safely
            // claim any instance memory required by the chip's engines.
            //
            status = allocHalEngineInstMem(pDev);
            if (status)
                return (status);
            break;
        }
        case STATE_DESTROY:
            //
            // Free up allocated memory.
            //
            osFreeMem(pDev->DBfbInstBitmap);

            //
            // Restore framebuffer registers.
            //
            nvHalFbControl(pDev, FB_CONTROL_DESTROY);
            break;
    }
    return (status);
}

//
// Verify that we have enough fbmem to support the requested
// video mode.
//
RM_STATUS fbCheckConfig
(
    PHWINFO pDev
)
{
    S032 size;
	U032 normalized_depth;

    //
    // Normalize our framebuffer depth
    //
    switch (pDev->Dac.HalInfo.Depth)
    {
        case 32:
        case 30:
        case 24:
            normalized_depth = 32;
            break;
        case 16:
        case 15:
            normalized_depth = 16;
            break;
        case 8:
        default:
            normalized_depth = 8;
            break;
    }

    //
    // Force video parameters to proper values.
    //
    // Calculate PRAM, Hash Table, and Instance memory sizes.
    //
    size = normalized_depth / 8
         * pDev->Framebuffer.HalInfo.HorizDisplayWidth * pDev->Framebuffer.HalInfo.VertDisplayWidth
         * pDev->Framebuffer.Count;

    //
    // Now calculate the available offscreen memory
    //
    if (size > (S032)pDev->Framebuffer.HalInfo.RamSize)
        size = 0;
    else
        size = pDev->Framebuffer.HalInfo.RamSize - size;

    if (size < (S032)pDev->Pram.HalInfo.TotalInstSize)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error - not enough PRAM!!!!!\n\r");
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\fb\nv20\fbnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Chip Specific HAL FB Routines ********************\
*                                                                           *
* Module: FBNV20.c                                                          *
*   The NV20 specific HAL FB routines reside in this file.                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include <heap.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalFbControl_NV20(VOID *);
RM_STATUS nvHalFbAlloc_NV20(VOID *);
RM_STATUS nvHalFbFree_NV20(VOID *);
RM_STATUS nvHalFbSetAllocParameters_NV20(VOID *);
RM_STATUS nvHalFbGetSurfacePitch_NV20(VOID *);
RM_STATUS nvHalFbGetSurfaceDimensions_NV20(VOID *);
RM_STATUS nvHalFbLoadOverride_NV20(VOID *);

// statics
static VOID _nvHalFbRoundTiledPitchSize(U032 *, U032, U032 *);
static RM_STATUS _nvHalFbAllocZtags(PHALHWINFO, U032 *, U032 *);
static RM_STATUS _nvHalFbFreeZtags(PHALHWINFO, U032, U032);

// NV20 expects a 1024byte alignment
#define FC_MIN_ALIGN_SHIFT      10

//
// Macro for mirroring PFB reg values into texture cache via RDI.
//
#define RDI_REG_WR32(select, addr, data)    \
    {                                       \
        REG_WR32(NV_PGRAPH_RDI_INDEX,       \
                 DRF_NUM(_PGRAPH, _RDI_INDEX, _SELECT, select) |    \
                 DRF_NUM(_PGRAPH, _RDI_INDEX, _ADDRESS, addr));     \
        REG_WR32(NV_PGRAPH_RDI_DATA, data);                         \
    }

#define RDI_REG_RD32(select, addr, data)    \
    {                                       \
        REG_WR32(NV_PGRAPH_RDI_INDEX,       \
                 DRF_NUM(_PGRAPH, _RDI_INDEX, _SELECT, select) |    \
                 DRF_NUM(_PGRAPH, _RDI_INDEX, _ADDRESS, addr));     \
        data = REG_RD32(NV_PGRAPH_RDI_DATA);                        \
    }

//
// nvHalFbControl
//
RM_STATUS
nvHalFbControl_NV20(VOID *arg)
{
    PFBCONTROLARG_000 pFbControlArg = (PFBCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO pFbHalInfo;
    PPRAMHALINFO pPramHalInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PHWREG nvAddr;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbControlArg->id != FB_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbControlArg->pHalHwInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pFbControlArg->cmd)
    {
        case FB_CONTROL_INIT:
        {
#if 0
            U032 cfg0, cfg1;
#endif
            U032 tmpAddr;

            //
            // Setup bank count.
            //
            pFbHalInfo->BankCount = REG_RD_DRF(_PFB, _CFG0, _PARTSENSE) + 1;

            //
            // Save off chip-dependent fb state.
            //
            pFbHalPvtInfo->fbSave[0] = REG_RD32(NV_PFB_CFG0);
            pFbHalPvtInfo->fbSave[1] = REG_RD32(NV_PFB_CFG1);

            //
            // Set ram type.
            //
            if (REG_RD_DRF(_PBUS, _FBIO_RAM, _TYPE) == NV_PBUS_FBIO_RAM_TYPE_SDR)
                pFbHalInfo->RamType = BUFFER_SDRAM;
            else
                pFbHalInfo->RamType = BUFFER_DDRAM;

            //
            // Set ram size.  Beginning with nv20, we need to
            // support external banks of possibly differing sizes.
            // Start by calculating size of primary bank and then
            // adding size of secondary bank if it exists.
            //
            // The formula (from James Van Dyke):
            //
            //  mem_in_bytes = (1 << (R + B + C + P)) * 4bytes, P=0,1,2
            //      R = row bits
            //      B = bank bits
            //      C = column bits
            //      P = partition count
            //

#if 0
            //
            // Set external bank count.
            //
            cfg0 = REG_RD32(NV_PFB_CFG0);
            cfg1 = REG_RD32(NV_PFB_CFG1);

            if (DRF_VAL(_PFB, _CFG0, _EXTBANK, cfg0) == NV_PFB_CFG0_EXTBANK_1)
                pFbHalInfo->ExtBankCount = 2;
            else
                pFbHalInfo->ExtBankCount = 1;

            //
            // Calculate primary external bank size.
            //
            size = (1 << (DRF_VAL(_PFB, _CFG1, _COL, cfg0) +
                          DRF_VAL(_PFB, _CFG1, _ROWA, cfg0) +
                          DRF_VAL(_PFB, _CFG1, _BANKA, cfg0) +
                          DRF_VAL(_PFB, _CFG0, _PART, cfg0))) * 4;
            pFbHalInfo->ExtBanks[0].size = size;
            pFbHalInfo->ExtBanks[0].intBanks = DRF_VAL(_PFB, _CFG1, _BANKA, cfg0) + 1;

            //
            // Check for secondary external bank.
            //
            if (DRF_VAL(_PFB, _CFG0, _EXTBANK, cfg0) == NV_PFB_CFG0_EXTBANK_1)
            {
                size = (1 << (DRF_DEF(_PFB, _CFG1, _COL, cfg1) +
                              DRF_DEF(_PFB, _CFG1, _ROWB, cfg1) +
                              DRF_DEF(_PFB, _CFG1, _BANKB, cfg1) +
                              DRF_DEF(_PFB, _CFG0, _PART, cfg0))) * 4;
                pFbHalInfo->ExtBanks[1].size = size;
                pFbHalInfo->ExtBanks[1].intBanks = DRF_VAL(_PFB, _CFG1, _BANKB, cfg0) + 1;
            }
#ifdef DEBUG
            //
            // Debug calculated size vs hard-wired value.
            //
            if (size != REG_RD_DRF(_PFB, _CSTATUS, _RAMAMOUNT_LS))
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: framebuffer size miscalculation ", size);
                DBG_BREAKPOINT();
            }

            //
            // Generate a debug message if the MS bit is actually set.
            //
            if (REG_RD_DRF(_PFB, _CSTATUS, _RAMAMOUNT_MS))
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: > 4G of framebuffer indicated!!");
                DBG_BREAKPOINT();
            }
#endif
#endif

            pFbHalInfo->RamSizeMb = REG_RD_DRF(_PFB, _CSTATUS, _RAMAMOUNT_LS);
            pFbHalInfo->RamSize = pFbHalInfo->RamSizeMb * 0x100000;

            //
            // Initialize ZTAG bitmap (0=allocated, 1=free).
            //
            for (i = 0; i < MAX_ZTAG_BITS/8; i++)
                pFbHalPvtInfo->zTagPool[i] = 0xff;

            for (i = 0; i < NV_PFB_ZCOMP__SIZE_1; i++)
            {
                pFbHalPvtInfo->zCompState[i].offset = MAX_ZTAG_BITS;
                pFbHalPvtInfo->zCompState[i].size = 0;
            }

            //
            // Set partition count.
            // 0=1partition, 1=2partitions, 3=4partitions (default).
            //
            pFbHalPvtInfo->partitions = REG_RD_DRF(_PFB, _CFG0, _PART) + 1;

            //
            // Set instance space size.  Add in whatever os-dependent
            // (i.e. BIOS) space is needed as well.
            //
            // For NV20, this is 576K allocatable.
            //
            pPramHalInfo->TotalInstSize = 0x90000 + pPramHalInfo->InstPadSize;

            //
            // The start of all of these space is after the BIOS
            // (denoted by InstPadSize).
            //
            tmpAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize;

            //
            // Configure hash table.
            //
            pFbHalPvtInfo->hashTableSize = 0x4000;
            pPramHalInfo->HashDepth = pFbHalPvtInfo->hashTableSize / sizeof (HASH_TABLE_ENTRY);
            pPramHalInfo->HashSearch = 128;

            pFbHalPvtInfo->hashTableAddr = tmpAddr;
            tmpAddr += pFbHalPvtInfo->hashTableSize;

            REG_WR32(NV_PFIFO_RAMHT, (DRF_DEF(_PFIFO, _RAMHT, _SIZE, _16K) |
                                      DRF_NUM(_PFIFO, _RAMHT, _BASE_ADDRESS, (pFbHalPvtInfo->hashTableAddr - DEVICE_BASE(NV_PRAMIN)) >> 12) |
                                      DRF_DEF(_PFIFO, _RAMHT, _SEARCH, _128)));
            
            //
            // Configure fifo context areas.
            // NV20 has two distinct context areas.
            //
            pFbHalPvtInfo->fifoContextSize1 = NUM_FIFOS_NV20 * FC1_SIZE_NV20;
            pFbHalPvtInfo->fifoContextSize2 = NUM_FIFOS_NV20 * FC2_SIZE_NV20;

            pFbHalPvtInfo->fifoContextAddr1 = tmpAddr;
            tmpAddr += pFbHalPvtInfo->fifoContextSize1;
            pFbHalPvtInfo->fifoContextAddr2 = tmpAddr;
            tmpAddr += pFbHalPvtInfo->fifoContextSize2;

            REG_WR32(NV_PFIFO_RAMFC,
                     (DRF_NUM(_PFIFO, _RAMFC, _BASE_ADDRESS, ((pFbHalPvtInfo->fifoContextAddr1 - DEVICE_BASE(NV_PRAMIN)) >> FC_MIN_ALIGN_SHIFT))) |
                     DRF_DEF(_PFIFO, _RAMFC, _SIZE, _2K) |
                     (DRF_NUM(_PFIFO, _RAMFC, _BASE_ADDRESS2, ((pFbHalPvtInfo->fifoContextAddr2 - DEVICE_BASE(NV_PRAMIN)) >> FC_MIN_ALIGN_SHIFT))));

            //
            // Configure runout area.
            //
            pFbHalPvtInfo->fifoRunoutSize = 512;
            pFbHalPvtInfo->fifoRunoutAddr = tmpAddr;
            tmpAddr += pFbHalPvtInfo->fifoRunoutSize;
            pFbHalPvtInfo->fifoRunoutMask = pFbHalPvtInfo->fifoRunoutSize - 1;
            REG_WR32(NV_PFIFO_RAMRO, (DRF_DEF(_PFIFO, _RAMRO, _SIZE, _512) |
                                      DRF_NUM(_PFIFO, _RAMRO, _BASE_ADDRESS, (pFbHalPvtInfo->fifoRunoutAddr - DEVICE_BASE(NV_PRAMIN)) >> 9)));

            //
            // Sum of all allocations plus a little slop
            //
            pPramHalInfo->CurrentSize  = (tmpAddr + 512) - (DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize);

            break;
        }
        case FB_CONTROL_LOAD:
            break;
        case FB_CONTROL_UNLOAD:
            break;
        case FB_CONTROL_UPDATE:
            break;
        case FB_CONTROL_DESTROY:
            REG_WR32(NV_PFB_CFG0, pFbHalPvtInfo->fbSave[0]);
            REG_WR32(NV_PFB_CFG1, pFbHalPvtInfo->fbSave[1]);
            break;
        case FB_CONTROL_INSTWR_DISABLE:
            // disable writes by enabling  protection
            switch (pPramHalInfo->TotalInstSize)
            {
                case 0xA0000:
                    FLD_WR_DRF_DEF(_PFB, _NVM, _LIMIT, _640K);
                    break;
                case 0x30000:
                    FLD_WR_DRF_DEF(_PFB, _NVM, _LIMIT, _192K);
                    break;
                case 0x20000:
                default:
                    FLD_WR_DRF_DEF(_PFB, _NVM, _LIMIT, _128K);
                    break;
            }
            FLD_WR_DRF_DEF(_PFB, _NVM, _MODE, _ENABLE);
            break;
        case FB_CONTROL_INSTWR_ENABLE:
            // enable writes by disabling write protection
            FLD_WR_DRF_DEF(_PFB, _NVM, _MODE, _DISABLE);
            break;
        case FB_CONTROL_TILING_DISABLE:
            HAL_GR_IDLE(pHalHwInfo);

            // TILE region registers
            for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
            {
                REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
                REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);
                RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                             NV_IGRAPH_TC_MINTFCDEBUG_TILE_ADDRESS(i),
                             NV_PFB_TILE_REGION_INVALID);
            }

            // ZCOMP_OFFSET register
            REG_WR32(NV_PGRAPH_ZCOMP_OFFSET, NV_PFB_ZCOMP_OFFSET_EN_FALSE);
            RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                         NV_IGRAPH_TC_MINTFCDEBUG_ZOFFSET_ADDRESS,
                         NV_PFB_ZCOMP_OFFSET_EN_FALSE);

            // ZCOMP region registers
            for (i = 0; i < NV_PFB_ZCOMP__SIZE_1; i++)
            {
                REG_WR32(NV_PFB_ZCOMP(i), NV_PFB_ZCOMP_EN_FALSE);
                REG_WR32(NV_PGRAPH_ZCOMP(i), NV_PFB_ZCOMP_EN_FALSE);
                RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                             NV_IGRAPH_TC_MINTFCDEBUG_ZCOMP_ADDRESS(i),
                             NV_PFB_ZCOMP_EN_FALSE);
            }
            break;
        case FB_CONTROL_TILING_ENABLE:
            // this is treated as an error on nv10 (???)
            return (RM_ERR_BAD_ARGUMENT);
        case FB_CONTROL_TILING_CONFIGURE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalFbGetSurfacePitch
//
// Given a width and bits per pixel, return the surface pitch
//
RM_STATUS
nvHalFbGetSurfacePitch_NV20(VOID *arg)
{
    PFBGETSURFACEPITCHARG_000 pGetSurfacePitchArg = (PFBGETSURFACEPITCHARG_000)arg;
    
    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pGetSurfacePitchArg->id != FB_GET_SURFACE_PITCH_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (at least) 64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pGetSurfacePitchArg->pitch = ((pGetSurfacePitchArg->width * ((pGetSurfacePitchArg->bpp+1) >> 3)) + 0x3F) & ~0x3F;

    if (pGetSurfacePitchArg->flags & FB_GET_SURFACE_PITCH_NO_ADJUST)
        return RM_OK;

    _nvHalFbRoundTiledPitchSize(&pGetSurfacePitchArg->pitch, NULL, NULL);
    return RM_OK;
}

//
// nvHalFbGetSurfaceDimensions
//
// Given a width/height and bits per pixel, return the surface pitch and size
//
RM_STATUS
nvHalFbGetSurfaceDimensions_NV20(VOID *arg)
{
    PFBGETSURFACEDIMENSIONSARG_000 pGetSurfaceDimensionsArg = (PFBGETSURFACEDIMENSIONSARG_000)arg;
    
    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pGetSurfaceDimensionsArg->id != FB_GET_SURFACE_DIMENSIONS_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (at least) 64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pGetSurfaceDimensionsArg->pitch = ((pGetSurfaceDimensionsArg->width * ((pGetSurfaceDimensionsArg->bpp+1) >> 3)) + 0x3F) & ~0x3F;
    pGetSurfaceDimensionsArg->size  = pGetSurfaceDimensionsArg->pitch * pGetSurfaceDimensionsArg->height;
        
    if (pGetSurfaceDimensionsArg->flags & FB_GET_SURFACE_PITCH_NO_ADJUST)
        return RM_OK;

    _nvHalFbRoundTiledPitchSize(&pGetSurfaceDimensionsArg->pitch,
                                pGetSurfaceDimensionsArg->height,
                                &pGetSurfaceDimensionsArg->size);
    return RM_OK;
}

static VOID
_nvHalFbRoundTiledPitchSize(U032 *pitch, U032 height, U032 *size)
{

    // adjust the pitch, if necessary
    if (*pitch <= 0x200)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0200);
    else if (*pitch <= 0x400)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0400);
    else if (*pitch <= 0x600)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0600);
    else if (*pitch <= 0x800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0800);
    else if (*pitch <= 0xA00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0A00);
    else if (*pitch <= 0xC00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0C00);
    else if (*pitch <= 0xE00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0E00);
    else if (*pitch <= 0x1000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1000);
    else if (*pitch <= 0x1400)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1400);
    else if (*pitch <= 0x1800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1800);
    else if (*pitch <= 0x1C00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1C00);
    else if (*pitch <= 0x2000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _2000);
    else if (*pitch <= 0x2800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _2800);
    else if (*pitch <= 0x3000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _3000);
    else if (*pitch <= 0x3800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _3800);
    else if (*pitch <= 0x4000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _4000);
    else if (*pitch <= 0x5000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _5000);
    else if (*pitch <= 0x6000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _6000);
    else if (*pitch <= 0x7000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _7000);
    else if (*pitch <= 0x8000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _8000);
    else if (*pitch <= 0xA000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _A000);
    else if (*pitch <= 0xC000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _C000);
    else
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _E000);

    if (size) {
        U032 hzmult;

        // set size given possibly adjusted pitch
        *size = *pitch * height;

        //
        // Round size to an even multiple of horizontal tiles. Remapping occurs
        // within addresses of length (pitch * tile_height * 2) in the vertical
        // direction (where the max TILE_HEIGHT is 16 lines).
        //
        hzmult = *pitch * (16 * 2);
        *size = ((*size + (hzmult - 1)) / hzmult) * hzmult;
    }
}

//
// Before updating the tiling registers (in particular, the PGRAPH version),
// idle graphics as best as possible.
//
// If we're not GR_IDLE during these writes to the PGRAPH registers, these
// writes can be dropped leaving the PFB and PGRAPH regs inconsistent. The
// idle/resume routines are called during FreeTiledRange/ProgramTiledRange.
//
static VOID
nvHalTilingUpdateIdle_NV20
(
    PHALHWINFO pHalHwInfo,
    U032       *pDmaPush
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    // Empty FIFO and runout.
    while ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
        || (REG_RD_DRF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK) != NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY)
        || (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY))
    {
        // Make sure we process any fifo interrupts
        HALRMSERVICEINTR(pHalHwInfo, FIFO_ENGINE_TAG);

        // Check if GE needs servicing.
        if (REG_RD32(NV_PGRAPH_INTR))
            HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);

        // Check if vblank needs servicing.
        if (REG_RD32(NV_PMC_INTR_0) & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
            HALRMSERVICEINTR(pHalHwInfo, DAC_ENGINE_TAG);
    }

    // Disable the dma pusher
    *pDmaPush = REG_RD32(NV_PFIFO_CACHE1_DMA_PUSH);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);

    // Wait until the DMA pusher is idle
    while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
	    ;
}

static VOID
nvHalTilingUpdateResume_NV20
(
    PHALHWINFO pHalHwInfo,
    U032       DmaPush
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    // Restore the dma pusher state
    REG_WR32(NV_PFIFO_CACHE1_DMA_PUSH, DmaPush);
}

//
// nvHalFbAlloc
//
// Update user alloc request parameter according to memory
// type and (possibly) reserve hw resources.
//
RM_STATUS
nvHalFbAlloc_NV20(VOID *arg)
{
    PFBALLOCARG_000 pFbAllocArg = (PFBALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PFBALLOCINFO pFbAllocInfo;
    U032 i, pitch, size;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbAllocArg->id != FB_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbAllocArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFbAllocInfo = pFbAllocArg->pAllocInfo;
    
    // Set default alignment based on type.
    switch (pFbAllocInfo->type) {
    case MEM_TYPE_IMAGE:
    case MEM_TYPE_OVERLAY:
        pFbAllocInfo->align = 0x3f;         // 64 byte alignment
        break;
    case MEM_TYPE_TEXTURE:
        pFbAllocInfo->align = 0xff;         // 256 byte alignment
        break;
    case MEM_TYPE_FONT:
        pFbAllocInfo->align = 0x1f;         // 32 byte alignment
        break;
    case MEM_TYPE_CURSOR:
        pFbAllocInfo->align = 0x7ff;        // 2048 byte alignment
        break;
    case MEM_TYPE_DMA:
        pFbAllocInfo->align = 0x3;          // 4 byte alignment
        break;
    case MEM_TYPE_INSTANCE:
        pFbAllocInfo->align = 0xf;          // 16 byte alignment
        break;
    case MEM_TYPE_DEPTH:
    case MEM_TYPE_DEPTH_COMPR16:
    case MEM_TYPE_DEPTH_COMPR32:
    case MEM_TYPE_PRIMARY:
    case MEM_TYPE_IMAGE_TILED:
        pFbAllocInfo->align = 0xfff;        // 4096 byte alignment
        break;
    default:
        // should this be 0xffffffff
        pFbAllocInfo->align = 0;
        return (RM_ERR_BAD_ARGUMENT);
    }

    //
    // A non-zero pitch value indicates the user wants tiled memory
    // (if available).  If the pitch is 0, we're done.
    //
    if (pFbAllocInfo->pitch == 0)
    {
        return (RM_OK);
    }
        
    // Now allocate a TILE_RANGE
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
    {
        if ((pFbHalPvtInfo->usedTiles & MEM_TYPE_TILE_RANGE_SHIFT(i)) == 0)
        {
            pFbHalPvtInfo->usedTiles |= MEM_TYPE_TILE_RANGE_SHIFT(i);
            break;
        }
    }
    if (i == NV_PFB_TILE__SIZE_1)
    {
        return (RM_ERR_INSUFFICIENT_RESOURCES);
    }

    pitch = pFbAllocInfo->pitch;

    _nvHalFbRoundTiledPitchSize(&pitch, pFbAllocInfo->height, &size);

    //
    // If we're not allowing the pitch to be adjusted, we can only tile the surface
    // if the pitch is already HW aligned.
    // 
    if ((pFbAllocArg->flags & FB_ALLOC_NO_PITCH_ADJUST) && (pitch != pFbAllocInfo->pitch))
    {
        // requires rounding, so give back the range and fail the alloc
        pFbHalPvtInfo->usedTiles &= ~MEM_TYPE_TILE_RANGE_SHIFT(i);
        pFbAllocInfo->hwResId = 0;
        return (RM_OK);
    }

    // tiles are 16K aligned.
    pFbAllocInfo->align = 0x4000 - 1;

    // return adjusted pitch and size
    pFbAllocInfo->pitch = pitch;
    pFbAllocInfo->size  = size;

    pFbAllocInfo->hwResId = MEM_TYPE_TILE_RANGE_SHIFT(i);
    return (RM_OK);
}

//
// nvHalFbFree
//
// Release tile back to the free pool.
//
RM_STATUS
nvHalFbFree_NV20(VOID *arg)
{
    PFBFREEARG_000 pFbFreeArg = (PFBFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PHWREG nvAddr;
    U032 i, dmapush;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbFreeArg->id != FB_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbFreeArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pFbFreeArg->pHalHwInfo->nvBaseAddr;

    //
    // Bail out now if there's no resource id.
    if (!pFbFreeArg->hwResId)
        return (RM_OK);

    // convert range bits to a TILE index
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
        if (pFbFreeArg->hwResId & MEM_TYPE_TILE_RANGE_SHIFT(i))
                break;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Freeing TILE Range:   ", i);

    // idle graphics, so we can update the PGRAPH registers
    nvHalTilingUpdateIdle_NV20(pFbFreeArg->pHalHwInfo, &dmapush);

    do {
        // Now, wait until graphics is idle
        HAL_GR_IDLE(pFbFreeArg->pHalHwInfo);

        // invalidate the range
        REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
        REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    
        RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                     NV_IGRAPH_TC_MINTFCDEBUG_TILE_ADDRESS(i),
                     NV_PFB_TILE_REGION_INVALID);
    } while (REG_RD32(NV_PFB_TILE(i)) != REG_RD32(NV_PGRAPH_TILE(i)));

    //
    // Free any z compression resources.
    //
    if (pFbHalPvtInfo->zCompState[i].offset != MAX_ZTAG_BITS && pFbHalPvtInfo->zCompState[i].size != 0)
    {
        _nvHalFbFreeZtags(pHalHwInfo, pFbHalPvtInfo->zCompState[i].offset, pFbHalPvtInfo->zCompState[i].size);
        pFbHalPvtInfo->zCompState[i].offset = MAX_ZTAG_BITS;
        pFbHalPvtInfo->zCompState[i].size = 0;
    }

    // resume graphics, now that PFB/PGRAPH are consistent
    nvHalTilingUpdateResume_NV20(pHalHwInfo, dmapush);

    // mark it free
    pFbHalPvtInfo->usedTiles &= ~pFbFreeArg->hwResId;

    return (RM_OK);
}

//
// nvHalFbSetAllocParameters
//
// Associate memory block (base/limit) with hardware resources.
//
RM_STATUS
nvHalFbSetAllocParameters_NV20(VOID *arg)
{
    PFBSETALLOCPARAMSARG_000 pFbSetAllocParamsArg = (PFBSETALLOCPARAMSARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PFBALLOCINFO pFbAllocInfo;
    PHWREG nvAddr;
    U032 i, dmapush;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbSetAllocParamsArg->id != FB_SET_ALLOC_PARAMS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbSetAllocParamsArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFbAllocInfo = pFbSetAllocParamsArg->pAllocInfo;
    nvAddr = pFbSetAllocParamsArg->pHalHwInfo->nvBaseAddr;

    //
    // Bail out if this allocation didn't reserve any tiling regs.
    //
    if (pFbAllocInfo->hwResId == 0)
        return (RM_OK);

    //
    // Convert range bits to a TILE index.
    //
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
        if (pFbAllocInfo->hwResId == (U032)MEM_TYPE_TILE_RANGE_SHIFT(i))
            break;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Programming TILE Range:   ", i);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:          Base =   ", pFbAllocInfo->offset);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         Limit =   ", pFbAllocInfo->offset + (pFbAllocInfo->size - 1));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         Pitch =   ", pFbAllocInfo->pitch);

    if (pFbAllocInfo->offset & 0x3fff)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error: unaligned Base\n");
        // mark it free
        pFbHalPvtInfo->usedTiles &= ~pFbAllocInfo->hwResId;
        // invalidate the range
        REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
        REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    
        return (RM_OK);
    }
    if (pFbAllocInfo->size & 0x3fff)
    {
        // mark it free
        pFbHalPvtInfo->usedTiles &= ~pFbAllocInfo->hwResId;
        // invalidate the range
        REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
        REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error: unaligned Limit\n");
        return (RM_OK);
    }

    // idle graphics, so we can update the PGRAPH registers
    nvHalTilingUpdateIdle_NV20(pFbSetAllocParamsArg->pHalHwInfo, &dmapush);

    //
    // Note: due to a PFB_TLIMIT readback bug, only compare the upper bits
    // when checking for PFB_TLIMIT/PGRAPH_TLIMIT consistency.
    // 
    do {
        // Now, wait until graphics is idle
        HAL_GR_IDLE(pHalHwInfo);

        REG_WR32(NV_PFB_TLIMIT(i), pFbAllocInfo->offset + pFbAllocInfo->size - 1);
        REG_WR32(NV_PFB_TSIZE(i), pFbAllocInfo->pitch);
        REG_WR32(NV_PFB_TILE(i), pFbAllocInfo->offset | DRF_DEF(_PFB, _TILE, _REGION, _VALID));

        REG_WR32(NV_PGRAPH_TLIMIT(i), pFbAllocInfo->offset + pFbAllocInfo->size - 1);
        REG_WR32(NV_PGRAPH_TSIZE(i), pFbAllocInfo->pitch);
        REG_WR32(NV_PGRAPH_TILE(i), pFbAllocInfo->offset | DRF_DEF(_PFB, _TILE, _REGION, _VALID));

        RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                     NV_IGRAPH_TC_MINTFCDEBUG_TLIMIT_ADDRESS(i),
                     pFbAllocInfo->offset + pFbAllocInfo->size - 1);
        RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                     NV_IGRAPH_TC_MINTFCDEBUG_TPITCH_ADDRESS(i),
                     pFbAllocInfo->pitch);
        RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                     NV_IGRAPH_TC_MINTFCDEBUG_TILE_ADDRESS(i),
                     pFbAllocInfo->offset | DRF_DEF(_PFB, _TILE, _REGION, _VALID));
    } while ((REG_RD32(NV_PFB_TILE(i)) != REG_RD32(NV_PGRAPH_TILE(i))) ||
             (REG_RD32(NV_PFB_TSIZE(i)) != REG_RD32(NV_PGRAPH_TSIZE(i))) ||
             ((REG_RD32(NV_PFB_TLIMIT(i)) & ~0x3FFF) != (REG_RD32(NV_PGRAPH_TLIMIT(i)) & ~0x3FFF)));

    //
    // Handle Z compression.
    //
    if (pFbAllocInfo->type == MEM_TYPE_DEPTH_COMPR16 || pFbAllocInfo->type == MEM_TYPE_DEPTH_COMPR32)
    {
        U032 offset, size, data;
       
        //
        // Find offset into ZTag table of range we'll associate with
        // this block of memory.
        //
        // Each Ztag maps to a single 64byte tile per partition.
        //
        size = pFbAllocInfo->size / (pFbHalPvtInfo->partitions * 64);
        if (_nvHalFbAllocZtags(pHalHwInfo, &size, &offset) == RM_OK)
        {
            // save off ztag region state
            pFbHalPvtInfo->zCompState[i].offset = offset;
            pFbHalPvtInfo->zCompState[i].size = size;

            // initialize offset into ztag pool
            data = DRF_NUM(_PFB, _ZCOMP, _BASE_TAG_ADR, offset) |
                DRF_DEF(_PFB, _ZCOMP, _EN, _TRUE);

            // mode (16 or 32bit)
            if (pFbAllocInfo->type == MEM_TYPE_DEPTH_COMPR32)
                data |= DRF_DEF(_PFB, _ZCOMP, _MODE, _32);

            // enable big endian mode if applicable
            if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
                data |= DRF_DEF(_PFB, _ZCOMP, _ENDIAN, _BIG);

            //
            // TODO: enable antialiasing...
            //

            do {
                // Now, wait until graphics is idle
                HAL_GR_IDLE(pHalHwInfo);

                REG_WR32(NV_PFB_ZCOMP(i), data);
                REG_WR32(NV_PGRAPH_ZCOMP(i), data);
                RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                             NV_IGRAPH_TC_MINTFCDEBUG_ZCOMP_ADDRESS(i),
                             data);
            } while (REG_RD32(NV_PFB_ZCOMP(i)) != REG_RD32(NV_PGRAPH_ZCOMP(i)));
        }
    }

    // resume graphics, now that PFB/PGRAPH are consistent
    nvHalTilingUpdateResume_NV20(pHalHwInfo, dmapush);

    return (RM_OK);
}

RM_STATUS
nvHalFbLoadOverride_NV20(VOID *arg)
{
    PFBLOADOVERRIDEARG_000 pFbLoadOverrideArg = (PFBLOADOVERRIDEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pFbLoadOverrideArg->id != FB_LOAD_OVERRIDE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbLoadOverrideArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    switch (pFbLoadOverrideArg->cmd)
    {
        case FB_LOAD_OVERRIDE_MEMORY:
            REG_WR32(NV_PFB_CFG0, pFbLoadOverrideArg->value);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// Z Compression management.
//
// Here's some details from the _HOW_TO_MAP_Z_COMPRESS_TAG_BITS_
// document in the NV20 Architecture database:
//
// (1) Z tag bits only live in compressed regions.
// (2) Only tiled regions can be compressed.
// (3) There is one Z tag bit per (64byte) packet.
// (4) One packet maps to one partition.
// (5) A ZCOMP_BASE_TAG_ADR exists for each region.  They define the tag
//     bit offset into each partition's tag RAM.  All RAMs in each partition
//     get the same address.
// (6) A region uses RAM tag bits starting at the ZCOMP_BASE_TAG_ADR.
//     RAM tag bits are allocated until the end of the memory region, or
//     until they run out, whichever is first.
// (7) ZCOMP_MAX_TAG_ADR specifies how many bits exist in each
//     partition tag RAM.
//
// There are two new memory types that the drivers can use to request
// compressed depth buffers:
//
//  MEM_TYPE_DEPTH_COMPR16 - 16bit compression
//  MEM_TYPE_DEPTH_COMPR32 - 32bit compression
//
// When the tiling parameters are programmed up for one of these
// memory types, we scan the Z tag pool (a bitmap) for any free
// bits.  Because of (6), we can partially compress a region, which
// we will do as a last resort.
//
static RM_STATUS
_nvHalFbAllocZtags(PHALHWINFO pHalHwInfo, U032 *size, U032 *offset)
{
    PFBHALINFO_NV20 pFbHalPvtInfo;
    U032 bestSize, bestOffset;
    U032 i, j;

    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;

    //
    // Error check incoming size parameter.
    //
    if (*size == 0)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: zero size to ztag allocator\n");
        *offset = MAX_ZTAG_BITS;                // out of range value
        DBG_BREAKPOINT();
    }

    bestSize = 0;
    bestOffset = MAX_ZTAG_BITS;
    for (i = 0; i < MAX_ZTAG_BITS; i++)
    {
        if (!pFbHalPvtInfo->zTagPool[i >> 3])
        {
            i += 7;
        }
        else if (pFbHalPvtInfo->zTagPool[i >> 3] & BIT(i & 7))
        {
            //
            // Search for string of 1's the length of the block.
            //
            j = 0;

            do
            {
                if ((++i >= MAX_ZTAG_BITS) || (++j >= *size))
                    break;
            }
            while (pFbHalPvtInfo->zTagPool[i >> 3] & BIT(i & 7));


            if (j == *size)
            {
                *offset = i - j;
                while (j--)
                {
                    i--;
                    pFbHalPvtInfo->zTagPool[i >> 3] &= ~BIT(i & 7);
                }
                return (RM_OK);
            }

            //
            // If this is the best range so far, save it off.
            //
            if (j != 0 && j > bestSize)
            {
                bestSize = j;
                bestOffset = i - j;
            }
        }
    }

    //
    // If we found _any_ ranges, use the biggest one...
    //
    if (bestSize != 0)
    {
        *offset = bestOffset;
        *size = bestSize;
        return (RM_OK);
    }

    *offset = MAX_ZTAG_BITS;
    *size = 0;

    return (RM_ERR_NO_FREE_MEM);
}


static RM_STATUS
_nvHalFbFreeZtags(PHALHWINFO pHalHwInfo, U032 offset, U032 size)
{
    PFBHALINFO_NV20 pFbHalPvtInfo;

    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;

    //
    // Validate range.
    //
    if (offset + size > MAX_ZTAG_BITS)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad ZTag pool parameters: offset ", offset);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: size ", size);
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }

    //
    // Mark range free.
    //
    while (size--)
    {
        pFbHalPvtInfo->zTagPool[offset >> 3] |= BIT(offset & 7);
        offset++;
    }

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\fifo\nv\fifoobj.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FIFO Manager *******************************\
*                                                                           *
* Module: FIFOOBJ.C                                                         *
*   The FIFO objects are managed in this module.  All modifications to the  *
*   object tree are handled here.  The object tree is a balanced tree       *
*   implementation.                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <btree.h>
#include <class.h>
#include <fifo.h>
#include <os.h>
#include "nvhw.h"

//
// Fifo object routines.
//

RM_STATUS fifoAddObject
(
	PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS status;
    PNODE     node;

    DBG_VAL_PTR(Object);
    status = btreeSearch(Object->Name, &node, pDev->DBfifoTable[Object->ChID].ObjectTree);
    if (status == RM_OK)
        return (RM_ERR_INSERT_DUPLICATE_NAME);
    Object->Node.Value = Object->Name;
    Object->Node.Data  = Object;
    status = btreeInsert(&(Object->Node), &(pDev->DBfifoTable[Object->ChID].ObjectTree));
    if (status == RM_OK)
    {
        //
        // Balance tree after every 16th object addition.
        //
        if ((++pDev->DBfifoTable[Object->ChID].ObjectCount & 0x0F) == 0x00)
            btreeBalance(&(pDev->DBfifoTable[Object->ChID].ObjectTree));
    }
    return (status);    
}

// jsw...
// 
// cwj: we don't add the DMA context object to the fifoTable
// in NV4 (not called from RmBindDmaContext).
//
//RM_STATUS fifoAddDmaObject
//(
//	PHWINFO pDev,
//    POBJECT Object,
//	U032 ChID
//)
//{
//    RM_STATUS status;
//    PNODE     node;
//
//    DBG_VAL_PTR(Object);
//    //status = btreeSearch(Object->Name, &node, pDev->DBfifoTable[Object->ChID].ObjectTree);
//    status = btreeSearch(Object->Name, &node, pDev->DBfifoTable[ChID].ObjectTree);
//    if (status == RM_OK)
//        return (RM_ERR_INSERT_DUPLICATE_NAME);
//    Object->Node.Value = Object->Name;
//    Object->Node.Data  = Object;
//    //status = btreeInsert(&(Object->Node), &(pDev->DBfifoTable[Object->ChID].ObjectTree));
//    status = btreeInsert(&(Object->Node), &(pDev->DBfifoTable[ChID].ObjectTree));
//    if (status == RM_OK)
//    {
//        //
//        // Balance tree after every 16th object addition.
//        //
//        //if ((++pDev->DBfifoTable[Object->ChID].ObjectCount & 0x0F) == 0x00)
//        if ((++pDev->DBfifoTable[ChID].ObjectCount & 0x0F) == 0x00)
//            //btreeBalance(&(pDev->DBfifoTable[Object->ChID].ObjectTree));
//            btreeBalance(&(pDev->DBfifoTable[ChID].ObjectTree));
//    }
//    return (status);    
//}

RM_STATUS fifoDelObject
(
	PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS status;

    DBG_VAL_PTR(Object);
    status = btreeDelete(Object->Node.Value, &(pDev->DBfifoTable[Object->ChID].ObjectTree));
    if (status == RM_OK)
        pDev->DBfifoTable[Object->ChID].ObjectCount--;

    if (pDev->DBfifoTable[Object->ChID].LastIllegalMthdObject == Object)
    {
        pDev->DBfifoTable[Object->ChID].LastIllegalMthdObject = NULL;
    }
    return (status);    
}

// jsw...
//
// cwj: wasn't added above, so no need to delete it.
//
//RM_STATUS fifoDelDmaObject
//(
//	PHWINFO pDev,
//    POBJECT Object,
//	U032 ChID
//)
//{
//    RM_STATUS status;
//
//    DBG_VAL_PTR(Object);
//    //status = btreeDelete(Object->Node.Value, &(pDev->DBfifoTable[Object->ChID].ObjectTree));
//    status = btreeDelete(Object->Node.Value, &(pDev->DBfifoTable[ChID].ObjectTree));
//    if (status == RM_OK)
//        //pDev->DBfifoTable[Object->ChID].ObjectCount--;
//        pDev->DBfifoTable[ChID].ObjectCount--;
//    return (status);    
//}

RM_STATUS fifoSearchObject
(
	PHWINFO  pDev,
    U032     Name,
    U032     ChID,
    POBJECT *Object
)
{
    RM_STATUS status;
    PNODE     node;
    
    status = btreeSearch(Name, &node, pDev->DBfifoTable[ChID].ObjectTree);
    if (status == RM_OK)
    {
        *Object = node->Data;
        DBG_VAL_PTR(*Object);
    }
    return (status);    
}

//
// Update an objects' context
//
RM_STATUS fifoUpdateObjectInstance
(
	PHWINFO     pDev,
    POBJECT     Object,
    U032        ChID,
    U032        Instance
)
{
    RM_STATUS status;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Updating FIFO context on object: ", Object->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                                 ChID: ", ChID);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                             instance: ", Instance);

    osEnterCriticalCode(pDev);
    //
    // Remove the object from the hash table.
    //
    fifoDelHashEntry(pDev, Object, ChID);
    //
    // Add it back.
    //
    status = fifoAddHashEntry(pDev, Object, ChID, Instance);
    osExitCriticalCode(pDev);
    return (status);
}

RM_STATUS fifoDeleteObjectInstance
(
	PHWINFO pDev,
	POBJECT Object,
	U032    ChID    
)
{
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Deleting FIFO context on object: ", Object->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                                 ChID: ", ChID);

    osEnterCriticalCode(pDev);
    //
    // Remove the object from the hash table.
    //
    fifoDelHashEntry(pDev, Object, ChID);
    osExitCriticalCode(pDev);
    return (RM_OK);
}

//
// Reset the channel, so it's in an idle state and clear the hash.
// This is called as part of fifoFree.
//
RM_STATUS fifoResetChannelState
(
    PHWINFO pDev,
    U032    ChID
)
{
    U032 Entry;

    //
    // Reset the channel, so it's in an idle state.
    //
    osEnterCriticalCode(pDev);
    nvHalFifoFree(pDev, ChID, pDev->DBfifoTable[ChID].Instance);

    //
    // Clear the hash table for this ChID.
    //
    for (Entry = 0; Entry < pDev->Pram.HalInfo.HashDepth; Entry++)
    {
        if (pDev->DBhashTable[Entry].Object && pDev->DBhashTable[Entry].ChID == ChID)
        {
            // clear software entry
            pDev->DBhashTable[Entry].Object = NULL;
            // clear hardware entry
            nvHalFifoHashDelete(pDev, Entry);
        }
    }
    osExitCriticalCode(pDev);

    return (RM_OK);
}

//
// Clear out the SubchannelContext
//
RM_STATUS fifoDeleteSubchannelContextEntry
(
    PHWINFO pDev,
    POBJECT Object
)
{
    U032 i;
    U032 ChID = Object->ChID;

    for (i = 0; i < NUM_SUBCHANNELS; i++)
    {
        if (pDev->DBfifoTable[ChID].SubchannelContext[i] == Object)
        {
            pDev->DBfifoTable[ChID].SubchannelContext[i] = NULL;
        }
    }

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\gr\nv\grstate.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRSTATE.C                                                         *
*   The graphics state is changed in this module.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <gr.h>
#include <os.h>
#include "nvhw.h"
//
// Externs.
//
extern char strDevNodeRM[];

//
// Change graphics hardware state.
//
RM_STATUS stateGr
(
    PHWINFO pDev,
    U032    msg
)
{
    U032    data32;

    switch (msg)
    {
        case STATE_UPDATE:
            break;
        case STATE_LOAD:
            //
            // Disable data from fifo.
            //
            REG_WR32(NV_PGRAPH_FIFO, 0x0);

            // Ignore return code.
            (void) nvHalGrControl(pDev, GR_CONTROL_LOAD);

            // save off this registry value (to be loaded later)
            if (IsNV15orBetter(pDev) &&
                (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "SwathMultWidth", &data32) == RM_OK))
                nvHalGrLoadOverride(pDev, GR_LOAD_OVERRIDE_SWATHCTL, data32 | SWATH_CONTROL_VALID_BIT);
            else
                nvHalGrLoadOverride(pDev, GR_LOAD_OVERRIDE_SWATHCTL, 0);

            //
            // Reset and enabled the interrupts.
            //
            REG_WR32(NV_PGRAPH_INTR,    0xFFFFFFFF);
            REG_WR32(NV_PGRAPH_INTR_EN, 0xFFFFFFFF);
            
            pDev->Graphics.Enabled = TRUE;
            
            break;
        case STATE_UNLOAD:
            if (pDev->Graphics.Enabled)
            {
                //
                // Set disabled flag.
                //
                pDev->Graphics.Enabled = FALSE;
                
                //
                // Idle the graphics engine.
                //
                // XXXscottl - Potential calls to any of the engine
                // interrupt service routines need to be mutexed.
                // We have a problem here because we can be called
                // as a result of a win9x class-driven modeset (in which
                // case the higher-level mcService routine will have
                // grabbed the spinlock) or because of a winnt-type
                // modeset (in which case no lock is held).
                //
                GR_IDLE();

                //
                // Pull out current graphics state.
                //
                (void) nvHalGrControl(pDev, GR_CONTROL_UNLOAD);
                
                //
                // Disable data access from fifo.
                //
                REG_WR32(NV_PGRAPH_FIFO,    0x00000000);
                REG_WR32(NV_PGRAPH_INTR_EN, 0x00000000);
            }
            break;
        case STATE_INIT:
        {
            U032 i;
            RM_STATUS status;

            //
            // Allocate/initialize the graphics engine class allocation
            // locks.
            //
            status = osAllocMem((VOID **)&pDev->Graphics.ClassLocks, sizeof (U032) * NUM_FIFOS);
            if (status)
                return (status);

            for (i = 0; i < NUM_FIFOS; i++)
            {
                ((U032 *)(pDev->Graphics.ClassLocks))[i] = 0;
            }

            pDev->Graphics.Enabled = FALSE;
            
            //
            // Handle any hardware dependent initialization now.
            //
            nvHalGrControl(pDev, GR_CONTROL_INIT);

            //
            // Clear VBlank list.
            //
            pDev->DBgrVBlankList[0] = NULL;
            pDev->DBgrVBlankList[1] = NULL;
            //
            // Load any overrides.
            //
            initGrEx(pDev);
            break;
        }
        case STATE_DESTROY:
            osFreeMem((VOID *)pDev->Graphics.ClassLocks);
            break;
    }    
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\fifo\nv10\fifonv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************* Chip Specific HAL FIFO Routines *********************\
*                                                                           *
* Module: FIFONV10.C                                                        *
*   The NV10 specific HAL FIFO routines reside in this file.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalFifoControl_NV10(VOID *);
RM_STATUS nvHalFifoAllocPio_NV10(VOID *);
RM_STATUS nvHalFifoAllocDma_NV10(VOID *);
RM_STATUS nvHalFifoFree_NV10(VOID *);
RM_STATUS nvHalFifoGetExceptionData_NV10(VOID *);
RM_STATUS nvHalFifoService_NV10(VOID *);
RM_STATUS nvHalFifoAccess_NV10(VOID *);
RM_STATUS nvHalFifoHashAdd_NV10(VOID *);
RM_STATUS nvHalFifoHashDelete_NV10(VOID *);
RM_STATUS nvHalFifoHashFunc_NV10(VOID *);

// The context switch interface is only used internally, but perhaps
// should be made available to the resource manager anyway.
static RM_STATUS nvHalFifoContextSwitch_NV10(PHALHWINFO, U032);

static U032 nvHalFifoCalcDmaFetch_NV10(U032, U032, U032);

#ifdef TRAP_HOST_FIFO_SWITCHES
U032 do_fifo_switch = 0;
U032 dma_inst[NUM_FIFOS_NV10];
#endif

RM_STATUS
nvHalFifoControl_NV10(VOID *arg)
{
    PFIFOCONTROLARG_000 pFifoControlArg = (PFIFOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV10 pFifoHalPvtInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    PHWREG nvAddr;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoControlArg->id != FIFO_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoControlArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pFifoControlArg->cmd) {
        case FIFO_CONTROL_INIT:
            //
            // Setup default parameters. 
            //
            pFifoHalInfo->RetryCount = 255;
            pFifoHalInfo->UserBase = DEVICE_BASE(NV_USER);
            pFifoHalPvtInfo->Mode = 0;
            pFifoHalPvtInfo->InUse = 0;

            //
            // Setup interrupt enable mask.
            //
            pFifoHalInfo->IntrEn0 =
                DRF_DEF(_PFIFO, _INTR_EN_0, _CACHE_ERROR, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT_OVERFLOW, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PUSHER, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PT, _ENABLED);

            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            //
            // Zero DMA FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            //
            // Zero FIFO hash valid.
            //
            REG_WR32(NV_PFIFO_CACHE0_HASH, 0);
            REG_WR32(NV_PFIFO_CACHE1_HASH, 0);
            //
            // Zero engine assignments
            //
            //REG_WR32(NV_PFIFO_CACHE0_ENGINE, 0);
            //REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
            //
            // Make all FIFO's default
            //
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
            REG_WR32(NV_PFIFO_DMA, 0);
            REG_WR32(NV_PFIFO_SIZE, 0);
            //
            // Clear all pusher state
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            //
            // Zero run-out pointers.
            //
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_PUT, _ADDRESS, 0);
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_GET, _ADDRESS, 0);
            break;
        case FIFO_CONTROL_LOAD:
            //
            // Update the dma fetch numbers using reasonable defaults.
            // We don't need to worry about the endianness bit here
            // because we're going to swap this channel out asap
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15));

            //
            // Enable default timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, 
                     DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _ENABLED)
                     | DRF_DEF(_PFIFO, _DMA_TIMESLICE, _SELECT, _128K));
            
            //
            // Set retry delay to match common hardware latency.
            //
            REG_WR_DRF_NUM(_PFIFO, _DELAY_0, _WAIT_RETRY, pFifoHalInfo->RetryCount);
            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Disable the pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV10(pHalHwInfo, (NUM_FIFOS_NV10 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);

            //
            // Enable pusher and puller access to cache1.
            //
            FIFOLOG(3, 1, 0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _ENABLED);
            //
            // Delay for slow CACHE1_PULL.
            //
            //temp = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _ENABLED);
            //
            // Enable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _ENABLED);
            break;
        case FIFO_CONTROL_UNLOAD:
            //
            // Disable dma timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _DISABLED));

            //
            // Empty FIFO and runout.
            //
            while ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK) != NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY))
            {
                //
                // Make sure we process any fifo interrupts
                //
                HALRMSERVICEINTR(pFifoControlArg->pHalHwInfo, FIFO_ENGINE_TAG);
                
                //
                // Check if GE needs servicing.
                //
                if (REG_RD32(NV_PGRAPH_INTR))
                    HALRMSERVICEINTR(pFifoControlArg->pHalHwInfo, GR_ENGINE_TAG);

                // Check if vblank needs servicing.
                if (REG_RD32(NV_PMC_INTR_0) & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
                    HALRMSERVICEINTR(pFifoControlArg->pHalHwInfo, DAC_ENGINE_TAG);
            }

            //
            // Disable the dma pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);

            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
			    ;
            
            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV10(pHalHwInfo, (NUM_FIFOS_NV10 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            
            //
            // Flush all FIFOs.
            //
            FifoReassign = REG_RD32(NV_PFIFO_CACHES);
            FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
            FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Update the FIFO context and its dirty bits.  By moving the get pointer to the current
            // put value, we are flushing any pending push data that hasn't been fetched yet.
            //
            for (i = 0; i < NUM_FIFOS_NV10; i++)
            {
                if (pFifoHalPvtInfo->InUse & (1 << i))
                {
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_GET)), 
                             REG_RD32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT))));

                    //
                    // Also, when setting the channels get pointer equal to its put, ensure the next
                    // DWORD is interpreted as a command (and not data) by clearing RAMFC_DMA_METHOD.
                    //
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), 0x0);
                }
            }

            //
            // Restore CACHE1 state.
            //
            FIFOLOG(1, FifoPull, FifoReassign);
            REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
            REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
            REG_WR32(NV_PFIFO_CACHES, FifoReassign);

            //
            // Flush all pending
            //
            REG_WR32(NV_PFIFO_DMA, 0);
            
            //
            // Disable all FIFO interrupts.
            //
            REG_WR32(NV_PFIFO_INTR_EN_0, 0);
            break;
        case FIFO_CONTROL_DESTROY:
            break;
        case FIFO_CONTROL_UPDATE:
            //
            // Update the dma fetch numbers using reasonable defaults.
            // Use FLD_WR_DRF_DEF so that we don't kill the endianness bit
			//
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES);
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES);
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15);
            break;

        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalFifoAllocPio
//
// Allocate PIO channel.
//
RM_STATUS
nvHalFifoAllocPio_NV10(VOID *arg)
{
    PFIFOALLOCPIOARG_000 pFifoAllocPioArg = (PFIFOALLOCPIOARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV10 pFifoHalPvtInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    U032 CacheData, InitCtxtPtr;
    PHWREG nvAddr;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoAllocPioArg->id != FIFO_ALLOC_PIO_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoAllocPioArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);

    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoAllocPioArg->chid * 32);
    for (i = 0; i < 8; i++)
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Set MODE to pio.
    //
    pFifoHalPvtInfo->Mode &= ~(1 << pFifoAllocPioArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocPioArg->chid))
    {
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,    pFifoAllocPioArg->chid);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT,   _ADDRESS, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_GET,   _ADDRESS, 0);
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        //
        // Enable cache1.
        //
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocPioArg->chid);

    return (RM_OK);
}

//
// nvHalFifoCalcDmaFetch
//
// Derive chip-dependent DMA fetch parameter register value
// from values specified at channel allocation time.
//
U032
nvHalFifoCalcDmaFetch_NV10(U032 fetchTrigger, U032 fetchSize, U032 fetchRequests)
{
    U032 dmaFetch;

    //
    // Input trigger value is in bytes.
    // Hardware value must be specified in increments of 8 between
    // 8 - 256 bytes.
    //
    if (fetchTrigger < 8) fetchTrigger = 8;
    if (fetchTrigger > 256) fetchTrigger = 256;
    fetchTrigger = (fetchTrigger / 8) - 1;

    //
    // Input size value is in bytes.
    // Hardware value must be specified in increments of 32
    // between 32 - 256 bytes.
    //
    if (fetchSize < 32) fetchSize = 32;
    if (fetchSize > 256) fetchSize = 256;
    fetchSize = (fetchSize / 32) - 1;

    //
    // Requests must be between 0 and 15.
    //
    if (fetchRequests > 15) fetchRequests = 15;

    //
    // Put it all together.
    //

    dmaFetch = DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, fetchTrigger) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, fetchSize) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, fetchRequests);

    return dmaFetch;
}

//
//
// nvHalFifoAllocDma
//
// Allocate DMA channel.
//
RM_STATUS
nvHalFifoAllocDma_NV10(VOID *arg)
{
    PFIFOALLOCDMAARG_000 pFifoAllocDmaArg = (PFIFOALLOCDMAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV10 pFifoHalPvtInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    U032 CacheData, InitCtxtPtr;
    U032 DefaultFetch;
    PHWREG nvAddr;
    U032 i;

    //
    // Verify interface revision.
    //
    if (pFifoAllocDmaArg->id != FIFO_ALLOC_DMA_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoAllocDmaArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);
    
    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoAllocDmaArg->chid * 32);
    for (i = 0 ; i < 8 ; i++ )
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Insert the instance (note that the rest of the context can start as zero)
    //
#ifdef TRAP_HOST_FIFO_SWITCHES
    if (do_fifo_switch)
        dma_inst[pFifoAllocDmaArg->chid] = pFifoAllocDmaArg->dmaInstance;
    else
#endif
    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_INST)), pFifoAllocDmaArg->dmaInstance);
    
    //
    // Calculate the endianness for the channel
    // Each channel can have its own endian-ness, but the api does not
    // yet support that.  So for now the channel endianness follows
    // from the rest of the system
    //
    if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
        DefaultFetch = DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _ENDIAN, _BIG);
    else
        DefaultFetch = DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _ENDIAN, _LITTLE);

    //
    // Adjust fetch max request (exception to the "all start as zero" rule)
    //
    DefaultFetch |= nvHalFifoCalcDmaFetch_NV10(pFifoAllocDmaArg->fetchTrigger, pFifoAllocDmaArg->fetchSize, pFifoAllocDmaArg->fetchRequests);

    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), DefaultFetch);
    
    //
    // Set channel mode to dma
    //
    pFifoHalPvtInfo->Mode |= (1 << pFifoAllocDmaArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocDmaArg->chid))
    {
        //
        // KJK Warning!!  We're getting in here if this is the first (0)
        // channel allocated in the system due to the checks above.
        // We really shouldn't be...
        //
        
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,   pFifoAllocDmaArg->chid);
        
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
        
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_PUT, _OFFSET, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_GET, _OFFSET, 0);
        
#ifdef TRAP_HOST_FIFO_SWITCHES
        if (!do_fifo_switch)
#endif
        REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, pFifoAllocDmaArg->dmaInstance);

        //
        // Force a reload of the PTE's
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_CTL, 0);
        
        //
        // Clear all pusher state
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // Set default watermarks
        //
        //REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0x000F6068);
        REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, DefaultFetch);
        
        //
        // Enable cache1.
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);
        
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocDmaArg->chid);

    return (RM_OK);
}

//
// nvHalFifoFree
//
// Free fifo resources.
//
RM_STATUS
nvHalFifoFree_NV10(VOID *arg)
{
    PFIFOFREEARG_000 pFifoFreeArg = (PFIFOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    PFIFOHALINFO_NV10 pFifoHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 InitCtxtPtr;
    PHWREG nvAddr;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoFreeArg->id != FIFO_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoFreeArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush     = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull     = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES,       _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
    FIFOLOG(4, 0, 0);

    //
    // Update the FIFO context and its dirty bits.
    //    
    if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoFreeArg->chid)
    {
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // If this is a dma channel, we need to shut him down and clear out
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Disable dma pusher activity
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUSH, 0);
            
            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
                ;
            
            //
            // Now zero everything out
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_TLB_PTE, 0);
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }        
    }
    else
    {
        //
        // Flush the context into the FIFO context RAM.
        //
        InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoFreeArg->chid * 32);
        for (i = 0; i < 8; i++)
        {
            REG_WR32(InitCtxtPtr+(4*i), 0);
        }
        
        //
        // If this is a dma channel, make sure we clear any pending pushing
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Clear any pending transfers
            //
            REG_WR32(NV_PFIFO_DMA, REG_RD32(NV_PFIFO_DMA) & (~(1 << pFifoFreeArg->chid)));
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }
    }

    //
    // Restore CACHE1 state.
    //
    FIFOLOG(4, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    //
    // Free up channel.
    //
    pFifoHalPvtInfo->InUse &= ~(1 << pFifoFreeArg->chid);

    pFifoHalInfo->AllocateCount--;

    return (RM_OK);
}

//
// nvHalFifoContextSwitch
//
// Context switch the fifo.
//
static RM_STATUS
nvHalFifoContextSwitch_NV10(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PFIFOHALINFO_NV10 pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 CurrentChID;
    U032 PushPending;
    U032 CtxtPtr = (U032)pFbHalPvtInfo->fifoContextAddr;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
    FIFOLOG(1, 0, 0);
    
    //
    // Make sure our local (rm) contexts are up to date for the outgoing channel
    //
    CurrentChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID); 

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Manually saving the FIFO context on ChID: ", CurrentChID);

    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT)), REG_RD32(NV_PFIFO_CACHE1_DMA_PUT));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_GET)), REG_RD32(NV_PFIFO_CACHE1_DMA_GET));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_REF_CNT)), REG_RD32(NV_PFIFO_CACHE1_REF));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_INST)), REG_RD32(NV_PFIFO_CACHE1_DMA_INSTANCE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), REG_RD32(NV_PFIFO_CACHE1_DMA_STATE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), REG_RD32(NV_PFIFO_CACHE1_DMA_FETCH));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0)), REG_RD32(NV_PFIFO_CACHE1_ENGINE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE)), REG_RD32(NV_PFIFO_CACHE1_PULL1));
    
    //
    // If this is a push channel and put != get, make sure to set the push pending flag
    //
    if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
    {    
        PushPending = REG_RD32(NV_PFIFO_DMA) & ~(1 << CurrentChID);
        if (REG_RD32(NV_PFIFO_CACHE1_DMA_PUT) != REG_RD32(NV_PFIFO_CACHE1_DMA_GET))
            PushPending |= (1 << CurrentChID);
        REG_WR32(NV_PFIFO_DMA, PushPending);
    }                    
    
    //
    // Bring in the context for the new channel from the fifo context ram.
    //
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Manually restoring the FIFO context on ChID: ", ChID);

    //
    // Update the channel and if it's DMA, set the mode
    //
    REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID, ChID);
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV10 - 1)))
        FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
    
    REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_GET, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_GET))));
    REG_WR32(NV_PFIFO_CACHE1_REF,REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_REF_CNT))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_INST))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG))));
    REG_WR32(NV_PFIFO_CACHE1_ENGINE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0))));
    REG_WR32(NV_PFIFO_CACHE1_PULL1, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE))));
         
    //
    // If DMA, enable the DMA Pusher
    //
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV10 - 1)))
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);

    //
    // In case there are dma pusher channels still pending, give this
    // new channel enough time to do something useful before it gets
    // yanked back out again.
    //
    REG_WR32(NV_PFIFO_TIMESLICE, 0x1fffff);     
           
    //
    // Restore CACHE1 state.
    //
    FIFOLOG(1, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    return (RM_OK);
}

//
// nvHalFifoGetExceptionData
//
RM_STATUS
nvHalFifoGetExceptionData_NV10(VOID *arg)
{
    PFIFOGETEXCEPTIONDATAARG_000 pFifoGetExceptionDataArg = (PFIFOGETEXCEPTIONDATAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    U032 GetPtr;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoGetExceptionDataArg->id != FIFO_GET_EXCEPTION_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);
    
    pHalHwInfo = pFifoGetExceptionDataArg->pHalHwInfo;
    pFifoExceptionData = pFifoGetExceptionDataArg->pExceptionData;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Fill in exception data.
    //
    pFifoExceptionData->Reason = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    pFifoExceptionData->ChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);
    GetPtr = REG_RD32(NV_PFIFO_CACHE1_GET) >> 2;
    pFifoExceptionData->GetPtr = GetPtr;
    pFifoExceptionData->SubChannel =
        (((REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr))) >> DRF_SHIFT(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL)) & 
         DRF_MASK(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL));
    pFifoExceptionData->Method = REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr)) & 0x1FFC;
    pFifoExceptionData->Data = REG_RD32(NV_PFIFO_CACHE1_DATA(GetPtr));

    return (RM_OK);
}

//
// nvHalFifoService
//
RM_STATUS
nvHalFifoService_NV10(VOID *arg)
{
    PFIFOSERVICEARG_000 pFifoServiceArg = (PFIFOSERVICEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV10 pFifoHalPvtInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoServiceArg->id != FIFO_SERVICE_000)
        return (RM_ERR_VERSION_MISMATCH);
    
    pHalHwInfo = pFifoServiceArg->pHalHwInfo;
    pFifoExceptionData = pFifoServiceArg->pExceptionData;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Handle Runout.
    //
    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _PENDING))
    {
        U032 ChID;
        U032 SubChannel;
        U032 Type;
        U032 Method;
        U032 Data;
        U032 GetPtr = 0;  // some compilers think its uninitialized otherwise
        U032 Reason;
        U032 FifoPush, wasDmaChannel = 0;

        //
        // Deal with data in runout.
        //
        DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Cache ranout.  Waiting for cache to drain.\n\r");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         CACHE1 ChID = ", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID));

        //
        // Don't allow another channel to switch in
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHES,       _REASSIGN, _DISABLED);

        //
        // Disable CACHE1_PUSH0, so we're able to safely resubmit the runout method/data
        // back into the CACHE1 below.
        // 
        FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        
        //
        // If this is a DMA channel, start to shut down the current pushing
        //
        if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
        {
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            wasDmaChannel = 1;      // started this interrupt as a DMA channel
        }
            
        //
        // First wait for cache to drain and the dma pusher to be idle
        //
        if ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) == NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY) &&
            (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_IDLE))
        {            
            //
            // Cache is empty.  Deal with data in runout.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Since the CACHE1 has been idled, let's move its PUT/GET to the top
            // of the FIFO avoiding any overflow issues during the resubmit.
            //
#ifdef DEBUG
            if (REG_RD32(NV_PFIFO_CACHE1_PUT) != REG_RD32(NV_PFIFO_CACHE1_GET))
                DBG_BREAKPOINT();
#endif // DEBUG

            REG_WR32(NV_PFIFO_CACHE1_PUT, 0x0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0x0);

            //
            // Because we've taken the trouble to idle everything, rather than dump
            // a single method/data into the CACHE1 and wait, we'll resubmit all the
            // outstanding runout method/data back into the CACHE1.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut_PUT        = ", REG_RD32(NV_PFIFO_RUNOUT_PUT));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut_GET        = ", REG_RD32(NV_PFIFO_RUNOUT_GET));

            while (REG_RD32(NV_PFIFO_RUNOUT_PUT) != REG_RD32(NV_PFIFO_RUNOUT_GET))
            {
                //
                // Read FIFO state.
                //
                GetPtr     = REG_RD32(NV_PFIFO_RUNOUT_GET);
                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       RunOut Method = ", Data);

                ChID       = SF_VAL(_RAMRO, _CHID, Data);
                Type       = SF_VAL(_RAMRO, _TYPE, Data);
                Reason     = SF_VAL(_RAMRO, _REASON, Data);
                Method     = SF_VAL(_RAMRO, _METHOD, Data) & 0x1FFF;
                SubChannel = SF_VAL(_RAMRO, _SUBCHANNEL, Data) & 0x7;

                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr + 4);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       RunOut Data   = ", Data);

                //
                // Set user cache state to look just as if the runout came
                // from the bottom on the FIFO.  This keeps the OBJECT_CHANGED
                // bits in order.
                //
                if ((Type == NV_RAMRO_TYPE_WRITE)
                    && (Reason != NV_RAMRO_REASON_ILLEGAL_ACCESS)
                    && (Reason != NV_RAMRO_REASON_RESERVED_ACCESS))
                {
                    if ((ChID < NUM_FIFOS_NV10) && pFifoHalPvtInfo->InUse)
                    {
                        U032 Cache1Put;

                        //
                        // Since the fifo engine/resmgr no longer tracks object context on a per-subchannel
                        // basis, the only thing we can do with runout methods is to send them back down
                        // the main user fifo.
                        //
                        // Do we need to force a channel change?
                        //
                    
                        if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) != ChID)
                        {
                            nvHalFifoContextSwitch_NV10(pHalHwInfo, ChID);

                            //
                            // If we started out the interrupt as a DMA channel and have switched into
                            // a PIO channel, make sure to clear the SUSPEND bit (but don't reenable). 
                            // The HW likes to see this bit cleared after an intr and since we now look
                            // like a PIO channel, we'll just clear it here.
                            // 
                            if (wasDmaChannel && (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _MODE) == 0))
                                FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _STATUS, _RUNNING);
                        }

                        //
                        // Resubmit
                        //
                        Cache1Put = REG_RD_DRF(_PFIFO, _CACHE1_PUT, _ADDRESS);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,
                                                   "NVRM: Cache runout resubmit to CACHE1 addr:", Cache1Put << 2);

                        REG_WR32(NV_PFIFO_CACHE1_METHOD(Cache1Put), 
                            Method | DRF_NUM(_PFIFO, _CACHE0_METHOD, _SUBCHANNEL, SubChannel));
                        REG_WR32(NV_PFIFO_CACHE1_DATA(Cache1Put), Data);

                        //
                        // Update the CACHE1 Put ptr.
                        // There are no overflow worries, since we started at the top of the CACHE1
                        //
                        Cache1Put++;
                        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT, _ADDRESS, Cache1Put);
                    }
                    else
                    {
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Access to free channel:", ChID);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                 sub channel:", SubChannel);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                      offset:", Method);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                        data:", Data);
                        DBG_BREAKPOINT();
                    }
                }
            
                //
                // Advance the RunOut get pointer.
                //
                GetPtr = (GetPtr + 8) & pFbHalPvtInfo->fifoRunoutMask;
                REG_WR32(NV_PFIFO_RUNOUT_GET, GetPtr);
                GetPtr = REG_RD32(NV_PFIFO_RUNOUT_GET);      // flush delay to update runout_status
            }

            //
            // Clear condition if no more data in runout.
            //
            if (REG_RD32(NV_PFIFO_RUNOUT_STATUS) & DRF_DEF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK, _EMPTY))
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut has CAUGHT UP:", GetPtr);
                REG_WR_DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _RESET);
            } else {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut should be CAUGHT UP:", GetPtr);
                DBG_BREAKPOINT();
            }
        }
        else
        {
            //
            // Enable the puller to empty the cache.
            //
            FIFOLOG(1, 1, 0);
            REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _ENABLED);
        }

        // restore CACHE1_PUSH0 state
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    }
    return (RM_OK);
}

//
// nvHalFifoAccess
//
RM_STATUS
nvHalFifoAccess_NV10(VOID *arg)
{
    PFIFOACCESSARG_000 pFifoAccessArg = (PFIFOACCESSARG_000)arg;
    PFIFOACCESSINFO pFifoAccessInfo;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoAccessArg->id != FIFO_ACCESS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoAccessArg->pHalHwInfo;
    pFifoAccessInfo = pFifoAccessArg->pAccessInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pFifoAccessArg->cmd) {
    case FIFO_ACCESS_DISABLE:
        //
        // This is the HW approved way of idling the FIFO, before changing its
        // context. After disabling reassign, wait for any pending channel changes
        // to complete. Also wait for the hash engine to idle then invalidate the
        // last lookup to avoid any miscompares (cleans up errors seen on IKOS).
        //
        pFifoAccessInfo->FifoReassign = REG_RD32(NV_PFIFO_CACHES);
        pFifoAccessInfo->FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        pFifoAccessInfo->FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);

        // disable reassign and wait for DMA_SUSPEND to go idle
        REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
        while (REG_RD_DRF(_PFIFO, _CACHES, _DMA_SUSPEND) == NV_PFIFO_CACHES_DMA_SUSPEND_BUSY)
			;

        // disable cache1 push access and the cache1 puller
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);

        // wait for the hash engine to idle and invalidate its previous lookup
        while (REG_RD_DRF(_PFIFO, _CACHE1_PULL0, _HASH_STATE) == NV_PFIFO_CACHE1_PULL0_HASH_STATE_BUSY)
			;
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_HASH, _VALID, 0x0);
        break;
    case FIFO_ACCESS_ENABLE:
        REG_WR32(NV_PFIFO_CACHE1_PULL0, pFifoAccessInfo->FifoPull);
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, pFifoAccessInfo->FifoPush);
        REG_WR32(NV_PFIFO_CACHES, pFifoAccessInfo->FifoReassign);
        break;
    default:
        // invalid cmd
        return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalFifoHashAdd
//
RM_STATUS
nvHalFifoHashAdd_NV10(VOID *arg)
{
    PFIFOHASHADDARG_000 pFifoHashAddArg = (PFIFOHASHADDARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    U032 ht_Context;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashAddArg->id != FIFO_HASH_ADD_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashAddArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    // set hash entry's object handle
    REG_WR32_DIRECT(&hwHashTable[pFifoHashAddArg->entry].ht_ObjectHandle, pFifoHashAddArg->handle);

    ht_Context = (pFifoHashAddArg->instance & SF_MASK(NV_RAMHT_INSTANCE)) |
                                            (pFifoHashAddArg->engine << SF_SHIFT(NV_RAMHT_ENGINE)) |
                                            (pFifoHashAddArg->chid << SF_SHIFT(NV_RAMHT_CHID)) |
                                            (NV_RAMHT_STATUS_VALID << SF_SHIFT(NV_RAMHT_STATUS));

    // set hash entry's inst addr and valid bit
    REG_WR32_DIRECT(&hwHashTable[pFifoHashAddArg->entry].ht_Context, ht_Context);
             
    while ((REG_RD32_DIRECT(&hwHashTable[pFifoHashAddArg->entry].ht_ObjectHandle) != pFifoHashAddArg->handle) ||
           (REG_RD32_DIRECT(&hwHashTable[pFifoHashAddArg->entry].ht_Context) != ht_Context))
        ;
    return (RM_OK);
}

//
// nvHalHashDelete
//
RM_STATUS
nvHalFifoHashDelete_NV10(VOID *arg)
{
    PFIFOHASHDELETEARG_000 pFifoHashDeleteArg = (PFIFOHASHDELETEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashDeleteArg->id != FIFO_HASH_DELETE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashDeleteArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    REG_WR32_DIRECT(&hwHashTable[pFifoHashDeleteArg->entry].ht_Context, 0);
    REG_WR32_DIRECT(&hwHashTable[pFifoHashDeleteArg->entry].ht_ObjectHandle, 0);

    return (RM_OK);
}

RM_STATUS
nvHalFifoHashFunc_NV10(VOID *arg)
{
    PFIFOHASHFUNCARG_000 pFifoHashFuncArg = (PFIFOHASHFUNCARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashFuncArg->id != FIFO_HASH_FUNC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pFifoHashFuncArg->result = FIFO_HASH(pFifoHashFuncArg->handle, pFifoHashFuncArg->chid);

    return (RM_OK);    
}

RM_STATUS
nvHalFifoHashSearch_NV10(VOID *arg)
{
    PFIFOHASHSEARCHARG_000 pFifoHashSearchArg = (PFIFOHASHSEARCHARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PPRAMHALINFO pPramHalInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    PHWREG nvAddr;
    U032 Entry;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashSearchArg->id != FIFO_HASH_SEARCH_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashSearchArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    pFifoHashSearchArg->result = 0x0;

    // Attempt to find a valid entry in the Hash (checking Name and ChID)
    for (Entry = 0; Entry < pPramHalInfo->HashDepth; Entry++)
    {
        if (REG_RD32_DIRECT(&hwHashTable[Entry].ht_ObjectHandle) == pFifoHashSearchArg->handle)
        {
            U032 chid, valid;
            U032 context = REG_RD32_DIRECT(&hwHashTable[Entry].ht_Context);
             
            chid  = context >> SF_SHIFT(NV_RAMHT_CHID) & SF_MASK(NV_RAMHT_CHID);
            valid = context >> SF_SHIFT(NV_RAMHT_STATUS) & SF_MASK(NV_RAMHT_STATUS);

            if ((valid == NV_RAMHT_STATUS_VALID) && (chid == pFifoHashSearchArg->chid))
            {
                pFifoHashSearchArg->result = context;
                break;
            }
        }
    }

    return (RM_OK);    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\fifo\nv4\fifonv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** Chip Specific HAL FIFO Routines **********************\
*                                                                           *
* Module: FIFONV04.C                                                        *
*   The NV4 specific HAL FIFO routines reside in this file.                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalFifoControl_NV04(VOID *);
RM_STATUS nvHalFifoAllocPio_NV04(VOID *);
RM_STATUS nvHalFifoAllocDma_NV04(VOID *);
RM_STATUS nvHalFifoFree_NV04(VOID *);
RM_STATUS nvHalFifoGetExceptionData_NV04(VOID *);
RM_STATUS nvHalFifoService_NV04(VOID *);
RM_STATUS nvHalFifoAccess_NV04(VOID *);
RM_STATUS nvHalFifoHashAdd_NV04(VOID *);
RM_STATUS nvHalFifoHashDelete_NV04(VOID *);
RM_STATUS nvHalFifoHashFunc_NV04(VOID *);

//
// The context switch interface is only used internally, but perhaps
// should be made available to the resource manager anyway.
//
static RM_STATUS nvHalFifoContextSwitch_NV04(PHALHWINFO, U032);

static U032 nvHalFifoCalcDmaFetch_NV04(U032, U032, U032);

RM_STATUS
nvHalFifoControl_NV04(VOID *arg)
{
    PFIFOCONTROLARG_000 pFifoControlArg = (PFIFOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV04 pFifoHalPvtInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoControlArg->id != FIFO_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoControlArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;

    switch (pFifoControlArg->cmd) {
        case FIFO_CONTROL_INIT:
            //
            // Setup default parameters. 
            //
            pFifoHalInfo->RetryCount = 255;
            pFifoHalInfo->UserBase = DEVICE_BASE(NV_USER);
            pFifoHalPvtInfo->Mode = 0;
            pFifoHalPvtInfo->InUse = 0;
            
            //
            // Setup interrupt enable mask.
            //
            pFifoHalInfo->IntrEn0 =
                DRF_DEF(_PFIFO, _INTR_EN_0, _CACHE_ERROR, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT_OVERFLOW, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PUSHER, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PT, _ENABLED);

            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            //
            // Zero DMA FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            //
            // Zero FIFO hash valid.
            //
            REG_WR32(NV_PFIFO_CACHE0_HASH, 0);
            REG_WR32(NV_PFIFO_CACHE1_HASH, 0);
            //
            // Zero engine assignments
            //
            //REG_WR32(NV_PFIFO_CACHE0_ENGINE, 0);
            //REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
            //
            // Make all FIFO's default
            //
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
            REG_WR32(NV_PFIFO_DMA, 0);
            REG_WR32(NV_PFIFO_SIZE, 0);
            //
            // Clear all pusher state
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            //
            // Zero run-out pointers.
            //
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_PUT, _ADDRESS, 0);
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_GET, _ADDRESS, 0);
            break;
        case FIFO_CONTROL_LOAD:
            //
            // Update the dma fetch numbers using reasonable defaults.
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15));
            
            //
            // Enable default timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, 
                     DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _ENABLED)
                     | DRF_DEF(_PFIFO, _DMA_TIMESLICE, _SELECT, _128K));
            
            //
            // Set retry delay to match common hardware latency.
            //
            REG_WR_DRF_NUM(_PFIFO, _DELAY_0, _WAIT_RETRY, pFifoHalInfo->RetryCount);
            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Disable the pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV04(pHalHwInfo, (NUM_FIFOS_NV04 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);

            //
            // Enable pusher and puller access to cache1.
            //
            FIFOLOG(3, 1, 0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _ENABLED);
            //
            // Delay for slow CACHE1_PULL.
            //
            //temp = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _ENABLED);
            //
            // Enable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _ENABLED);
            break;
        case FIFO_CONTROL_UNLOAD:
            //
            // Disable dma timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _DISABLED));

            //
            // Empty FIFO and runout.
            //
            while ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK) != NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY))
            {
                //
                // Make sure we process any fifo interrupts
                //
                HALRMSERVICEINTR(pHalHwInfo, FIFO_ENGINE_TAG);
                
                //
                // Check if GE needs servicing.
                //
                if (REG_RD32(NV_PGRAPH_INTR))
                    HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);
            }

            //
            // Disable the dma pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);

            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
			    ;

            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV04(pHalHwInfo, (NUM_FIFOS_NV04 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            
            //
            // Flush all FIFOs.
            //
            FifoReassign = REG_RD32(NV_PFIFO_CACHES);
            FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
            FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Update the FIFO context and its dirty bits.  By moving the get pointer to the current
            // put value, we are flushing any pending push data that hasn't been fetched yet.
            //
            for (i = 0; i < NUM_FIFOS_NV04; i++)
            {
                if (pFifoHalPvtInfo->InUse & (1 << i))
                {
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_GET)), 
                             REG_RD32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT))));

                    //
                    // Also, when setting the channels get pointer equal to its put, ensure the next
                    // DWORD is interpreted as a command (and not data) by clearing RAMFC_DMA_METHOD.
                    //
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), 0x0);
                }
            }

            //
            // Restore CACHE1 state.
            //
            FIFOLOG(1, FifoPull, FifoReassign);
            REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
            REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
            REG_WR32(NV_PFIFO_CACHES, FifoReassign);

            //
            // Flush all pending
            //
            REG_WR32(NV_PFIFO_DMA, 0);
            
            //
            // Disable all FIFO interrupts.
            //
            REG_WR32(NV_PFIFO_INTR_EN_0, 0);
            break;
        case FIFO_CONTROL_DESTROY:
            break;
        case FIFO_CONTROL_UPDATE:
            //
            // Update the dma fetch numbers
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15));
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

RM_STATUS
nvHalFifoAllocPio_NV04(VOID *arg)
{
    PFIFOALLOCPIOARG_000 pFifoAllocPioArg = (PFIFOALLOCPIOARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    PFIFOHALINFO_NV04 pFifoHalPvtInfo;
    U032 CacheData, InitCtxtPtr;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoAllocPioArg->id != FIFO_ALLOC_PIO_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
	pHalHwInfo = pFifoAllocPioArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);

    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoAllocPioArg->chid * 32);
    for (i = 0; i < 8; i++)
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Set MODE to pio.
    //
    pFifoHalPvtInfo->Mode &= ~(1 << pFifoAllocPioArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocPioArg->chid))
    {
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,    pFifoAllocPioArg->chid);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT,   _ADDRESS, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_GET,   _ADDRESS, 0);
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        //
        // Enable cache1.
        //
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocPioArg->chid);

    return (RM_OK);
}

//
// nvHalFifoCalcDmaFetch
//
// Derive chip-dependent DMA fetch parameter register value
// from values specified at channel allocation time.
//
U032
nvHalFifoCalcDmaFetch_NV04(U032 fetchTrigger, U032 fetchSize, U032 fetchRequests)
{
    U032 dmaFetch;

    //
    // Input trigger value is in bytes.
    // Hardware value must be specified in increments of 8 between
    // 8 - 256 bytes.
    //
    if (fetchTrigger < 8) fetchTrigger = 8;
    if (fetchTrigger > 256) fetchTrigger = 256;
    fetchTrigger = (fetchTrigger / 8) - 1;

    //
    // Input size value is in bytes.
    // Hardware value must be specified in increments of 32
    // between 32 - 256 bytes.
    //
    if (fetchSize < 32) fetchSize = 32;
    if (fetchSize > 256) fetchSize = 256;
    fetchSize = (fetchSize / 32) - 1;

    //
    // Requests must be between 0 and 15.
    //
    if (fetchRequests > 15) fetchRequests = 15;

    //
    // Put it all together.
    //
    dmaFetch = DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, fetchTrigger) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, fetchSize) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, fetchRequests);

    return dmaFetch;
}

RM_STATUS
nvHalFifoAllocDma_NV04(VOID *arg)
{
    PFIFOALLOCDMAARG_000 pFifoAllocDmaArg = (PFIFOALLOCDMAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    PFIFOHALINFO_NV04 pFifoHalPvtInfo;
    U032 CacheData, InitCtxtPtr;
    U032 DefaultFetch;
    U032 DmaContext;
    U032 i;

    //
    // Verify interface revision.
    //
    if (pFifoAllocDmaArg->id != FIFO_ALLOC_DMA_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
	pHalHwInfo = pFifoAllocDmaArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;

    //
    // Validate push buffer state.
    //
    DmaContext = INST_RD32(pFifoAllocDmaArg->dmaInstance, SF_OFFSET(NV_DMA_CLASS));
    if (SF_VAL(_DMA, _TARGET_NODE, DmaContext) == NV_DMA_TARGET_NODE_NVM)
        return (RM_ERR_BAD_OBJECT_BUFFER);

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);
    
    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoAllocDmaArg->chid * 32);
    for (i = 0 ; i < 8 ; i++ )
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Insert the instance (note that the rest of the context can start as zero)
    //
    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_INST)), pFifoAllocDmaArg->dmaInstance);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalFifoAllocateDma_NV04 - CACHE1 currently mapped to ChID ", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID));
    
    //
    // Adjust fetch max request (exception to the "all start as zero" rule)
    //
    DefaultFetch = nvHalFifoCalcDmaFetch_NV04(pFifoAllocDmaArg->fetchTrigger, pFifoAllocDmaArg->fetchSize, pFifoAllocDmaArg->fetchRequests);
    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), DefaultFetch);
    
    //
    // Set channel mode to dma
    //
    pFifoHalPvtInfo->Mode |= (1 << pFifoAllocDmaArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocDmaArg->chid))
    {
        //
        // KJK Warning!!  We're getting in here if this is the first (0)
        // channel allocated in the system due to the checks above.
        // We really shouldn't be...
        //
        
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,   pFifoAllocDmaArg->chid);
        
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
        
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_PUT, _OFFSET, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_GET, _OFFSET, 0);
        
        REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, pFifoAllocDmaArg->dmaInstance);

        //
        // Force a reload of the PTE's
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_CTL, 0);
        
        //
        // Clear all pusher state
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
        
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // Set default watermarks
        //
        //REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0x000F6068);
        REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, DefaultFetch);
        
        //
        // Enable cache1.
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);
        
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocDmaArg->chid);

    return (RM_OK);
}

RM_STATUS
nvHalFifoFree_NV04(VOID *arg)
{
    PFIFOFREEARG_000 pFifoFreeArg = (PFIFOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV04 pFifoHalPvtInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 InitCtxtPtr;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoFreeArg->id != FIFO_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of the argument structure.
    //
	pHalHwInfo = pFifoFreeArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush     = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull     = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES,       _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
    FIFOLOG(4, 0, 0);

    //
    // Update the FIFO context and its dirty bits.
    //    
    if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoFreeArg->chid)
    {
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // If this is a dma channel, we need to shut him down and clear out
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Disable dma pusher activity
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUSH, 0);
            
            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
			    ;
            
            //
            // Now zero everything out
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_TLB_PTE, 0);
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }        
    }
    else
    {
        //
        // Flush the context into the FIFO context RAM.
        //
        InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoFreeArg->chid * 32);
        for (i = 0; i < 8; i++)
        {
            REG_WR32(InitCtxtPtr+(4*i), 0);
        }
        
        //
        // If this is a dma channel, make sure we clear any pending pushing
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Clear any pending transfers
            //
            REG_WR32(NV_PFIFO_DMA, REG_RD32(NV_PFIFO_DMA) & (~(1 << pFifoFreeArg->chid)));
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }
    }

    //
    // Restore CACHE1 state.
    //
    FIFOLOG(4, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    //
    // Free up channel.
    //
    pFifoHalPvtInfo->InUse &= ~(1 << pFifoFreeArg->chid);

    pFifoHalInfo->AllocateCount--;

    return (RM_OK);
}

//
// nvHalFifoContextSwitch
//
// Context switch the fifo.
//
static RM_STATUS
nvHalFifoContextSwitch_NV04(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PFIFOHALINFO pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    PFIFOHALINFO_NV04 pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 CurrentChID;
    U032 PushPending;
    U032 CtxtPtr = (U032)pFbHalPvtInfo->fifoContextAddr;

    //if (id != FIFO_CONTEXT_SWITCH)
    //    return (HAL_ERROR);

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
    FIFOLOG(1, 0, 0);
    
    //
    // Make sure our local (rm) contexts are up to date for the outgoing channel
    //
    CurrentChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID); 

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Manually saving the FIFO context on ChID: ", CurrentChID);

    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT)), REG_RD32(NV_PFIFO_CACHE1_DMA_PUT));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_GET)), REG_RD32(NV_PFIFO_CACHE1_DMA_GET));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_INST)), REG_RD32(NV_PFIFO_CACHE1_DMA_INSTANCE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), REG_RD32(NV_PFIFO_CACHE1_DMA_STATE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), REG_RD32(NV_PFIFO_CACHE1_DMA_FETCH));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0)), REG_RD32(NV_PFIFO_CACHE1_ENGINE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE)), REG_RD32(NV_PFIFO_CACHE1_PULL1));
    
    //
    // If this is a push channel and put != get, make sure to set the push pending flag
    //
    if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
    {    
        PushPending = REG_RD32(NV_PFIFO_DMA) & ~(1 << CurrentChID);
        if (REG_RD32(NV_PFIFO_CACHE1_DMA_PUT) != REG_RD32(NV_PFIFO_CACHE1_DMA_GET))
            PushPending |= (1 << CurrentChID);
        REG_WR32(NV_PFIFO_DMA, PushPending);
    }                    
    
    //
    // Bring in the context for the new channel from the fifo context ram.
    //
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Manually restoring the FIFO context on ChID: ", ChID);

    //
    // Update the channel and if it's DMA, set the mode
    //
    REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID, ChID);
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV04 - 1)))
        FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
    
    REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_GET, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_GET))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_INST))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG))));
    REG_WR32(NV_PFIFO_CACHE1_ENGINE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0))));
    REG_WR32(NV_PFIFO_CACHE1_PULL1, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE))));
         
    //
    // If DMA, enable the DMA Pusher
    //
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV04 - 1)))
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);

    //
    // In case there are dma pusher channels still pending, give this
    // new channel enough time to do something useful before it gets
    // yanked back out again.
    //
    REG_WR32(NV_PFIFO_TIMESLICE, 0x1fffff);     
           
    //
    // Restore CACHE1 state.
    //
    FIFOLOG(1, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    return (RM_OK);
}

//
// nvHalFifoGetExceptionData
//
RM_STATUS
nvHalFifoGetExceptionData_NV04(VOID *arg)
{
    PFIFOGETEXCEPTIONDATAARG_000 pFifoGetExceptionDataArg = (PFIFOGETEXCEPTIONDATAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    U032 GetPtr;

    //
    // Verify interface revision.
    //
    if (pFifoGetExceptionDataArg->id != FIFO_GET_EXCEPTION_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoGetExceptionDataArg->pHalHwInfo;
    pFifoExceptionData = pFifoGetExceptionDataArg->pExceptionData;

    //
    // Fill in exception data.
    //
    pFifoExceptionData->Reason = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    pFifoExceptionData->ChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);
    GetPtr = REG_RD32(NV_PFIFO_CACHE1_GET) >> 2;
    pFifoExceptionData->GetPtr = GetPtr;
    pFifoExceptionData->SubChannel =
        (((REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr))) >> DRF_SHIFT(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL)) & 
         DRF_MASK(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL));
    pFifoExceptionData->Method = REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr)) & 0x1FFC;
    pFifoExceptionData->Data = REG_RD32(NV_PFIFO_CACHE1_DATA(GetPtr));

    return (RM_OK);
}

//
// nvHalFifoService
//
RM_STATUS
nvHalFifoService_NV04(VOID *arg)
{
    PFIFOSERVICEARG_000 pFifoServiceArg = (PFIFOSERVICEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV04 pFifoHalPvtInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pFifoServiceArg->id != FIFO_SERVICE_000)
        return (RM_ERR_VERSION_MISMATCH);
    
 	pHalHwInfo = pFifoServiceArg->pHalHwInfo;
    pFifoExceptionData = pFifoServiceArg->pExceptionData;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;

    //
    // Now service any exceptions that we'd like to handle w/i the HAL.
    //
    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _PENDING))
    {
        U032 GetPtr;
        U032 ChID;
        U032 SubChannel;
        U032 Type;
        U032 Reason;
        U032 Method;
        U032 Data;
        U032 FifoPush, wasDmaChannel = 0;

        //
        // Deal with data in runout.
        //
        DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Cache ranout.  Waiting for cache to drain.\n\r");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         CACHE1 ChID = ", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID));

        //
        // Don't allow another channel to switch in
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHES,       _REASSIGN, _DISABLED);

        //
        // Disable CACHE1_PUSH0, so we're able to safely resubmit the runout method/data
        // back into the CACHE1 below.
        // 
        FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        
        //
        // If this is a DMA channel, start to shut down the current pushing
        //
        if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
        {
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            wasDmaChannel = 1;      // started this interrupt as a DMA channel
        }
            
        //
        // First wait for cache to drain and the dma pusher to be idle
        //
        if ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) == NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY) &&
            (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_IDLE))
        {            
            //
            // Cache is empty.  Deal with data in runout.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Since the CACHE1 has been idled, let's move its PUT/GET to the top
            // of the FIFO avoiding any overflow issues during the resubmit.
            //
#ifdef DEBUG
            if (REG_RD32(NV_PFIFO_CACHE1_PUT) != REG_RD32(NV_PFIFO_CACHE1_GET))
                DBG_BREAKPOINT();
#endif // DEBUG

            REG_WR32(NV_PFIFO_CACHE1_PUT, 0x0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0x0);

            //
            // Because we've taken the trouble to idle everything, rather than dump
            // a single method/data into the CACHE1 and wait, we'll resubmit all the
            // outstanding runout method/data back into the CACHE1.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut_PUT        = ", REG_RD32(NV_PFIFO_RUNOUT_PUT));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut_GET        = ", REG_RD32(NV_PFIFO_RUNOUT_GET));

            while (REG_RD32(NV_PFIFO_RUNOUT_PUT) != REG_RD32(NV_PFIFO_RUNOUT_GET))
            {
                //
                // Read FIFO state.
                //
                GetPtr     = REG_RD32(NV_PFIFO_RUNOUT_GET);
                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       RunOut Method = ", Data);

                ChID       = SF_VAL(_RAMRO, _CHID, Data);
                Type       = SF_VAL(_RAMRO, _TYPE, Data);
                Reason     = SF_VAL(_RAMRO, _REASON, Data);
                Method     = SF_VAL(_RAMRO, _METHOD, Data) & 0x1FFF;
                SubChannel = SF_VAL(_RAMRO, _SUBCHANNEL, Data) & 0x7;

                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr + 4);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       RunOut Data   = ", Data);

                //
                // Set user cache state to look just as if the runout came
                // from the bottom on the FIFO.  This keeps the OBJECT_CHANGED
                // bits in order.
                //
                if ((Type   == NV_RAMRO_TYPE_WRITE)
                    && (Reason != NV_RAMRO_REASON_ILLEGAL_ACCESS)
                    && (Reason != NV_RAMRO_REASON_RESERVED_ACCESS))
                {
                    if ((ChID < NUM_FIFOS_NV04) && pFifoHalPvtInfo->InUse)
                    {
                        U032 Cache1Put;

                        //
                        // Since the fifo engine/resmgr no longer tracks object context on a per-subchannel
                        // basis, the only thing we can do with runout methods is to send them back down
                        // the main user fifo.
                        //
                        // Do we need to force a channel change?
                        //
                    
                        if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) != ChID)
                        {
                            nvHalFifoContextSwitch_NV04(pHalHwInfo, ChID);

                            //
                            // If we started out the interrupt as a DMA channel and have switched into
                            // a PIO channel, make sure to clear the SUSPEND bit (but don't reenable). 
                            // The HW likes to see this bit cleared after an intr and since we now look
                            // like a PIO channel, we'll just clear it here.
                            // 
                            if (wasDmaChannel && (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _MODE) == 0))
                                FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _STATUS, _RUNNING);
                        }

                        //
                        // Resubmit
                        //
                        Cache1Put = REG_RD_DRF(_PFIFO, _CACHE1_PUT, _ADDRESS);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,
                                                   "NVRM: Cache runout resubmit to CACHE1 addr:", Cache1Put << 2);

                        REG_WR32(NV_PFIFO_CACHE1_METHOD(Cache1Put), 
                            Method | DRF_NUM(_PFIFO, _CACHE0_METHOD, _SUBCHANNEL, SubChannel));
                        REG_WR32(NV_PFIFO_CACHE1_DATA(Cache1Put), Data);

                        //
                        // Update the CACHE1 Put ptr.
                        // There are no overflow worries, since we started at the top of the CACHE1
                        //
                        Cache1Put++;
                        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT, _ADDRESS, Cache1Put);
                    }
                    else
                    {
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Access to free channel:", ChID);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                 sub channel:", SubChannel);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                      offset:", Method);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                        data:", Data);
                        DBG_BREAKPOINT();
                    }
                }
            
                //
                // Advance the RunOut get pointer.
                //
                GetPtr = (GetPtr + 8) & pFbHalPvtInfo->fifoRunoutMask;
                REG_WR32(NV_PFIFO_RUNOUT_GET, GetPtr);
                GetPtr = REG_RD32(NV_PFIFO_RUNOUT_GET);      // flush delay to update runout_status
            }

            //
            // Clear condition if no more data in runout.
            //
            if (REG_RD32(NV_PFIFO_RUNOUT_STATUS) & DRF_DEF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK, _EMPTY))
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut has CAUGHT UP:", GetPtr);
                REG_WR_DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _RESET);
            } else {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut should be CAUGHT UP:", GetPtr);
                DBG_BREAKPOINT();
            }
        }
        else
        {
            //
            // Enable the puller to empty the cache.
            //
            FIFOLOG(1, 1, 0);
            REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _ENABLED);
        }

        // restore CACHE1_PUSH0 state
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    }
    return (RM_OK);
}

//
// nvHalFifoAccess
//
RM_STATUS
nvHalFifoAccess_NV04(VOID *arg)
{
    PFIFOACCESSARG_000 pFifoAccessArg = (PFIFOACCESSARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOACCESSINFO pFifoAccessInfo;

    //
    // Verify interface revision.
    //
    if (pFifoAccessArg->id != FIFO_ACCESS_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoAccessArg->pHalHwInfo;
    pFifoAccessInfo = pFifoAccessArg->pAccessInfo;

    switch (pFifoAccessArg->cmd) {
    case FIFO_ACCESS_DISABLE:
        pFifoAccessInfo->FifoReassign = REG_RD32(NV_PFIFO_CACHES);
        pFifoAccessInfo->FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        pFifoAccessInfo->FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
        REG_WR_DRF_DEF(_PFIFO, _CACHES,       _REASSIGN, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
        break;
    case FIFO_ACCESS_ENABLE:
        REG_WR32(NV_PFIFO_CACHE1_PULL0, pFifoAccessInfo->FifoPull);
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, pFifoAccessInfo->FifoPush);
        REG_WR32(NV_PFIFO_CACHES, pFifoAccessInfo->FifoReassign);
        break;
    default:
        return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalFifoHashAdd
//
RM_STATUS
nvHalFifoHashAdd_NV04(VOID *arg)
{
    PFIFOHASHADDARG_000 pFifoHashAddArg = (PFIFOHASHADDARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    PHWREG nvAddr;
    HASH_TABLE_ENTRY *hwHashTable;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashAddArg->id != FIFO_HASH_ADD_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoHashAddArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo; 
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    REG_WR32_DIRECT(&hwHashTable[pFifoHashAddArg->entry].ht_ObjectHandle, pFifoHashAddArg->handle);
    REG_WR32_DIRECT(&hwHashTable[pFifoHashAddArg->entry].ht_Context, (pFifoHashAddArg->instance & SF_MASK(NV_RAMHT_INSTANCE)) |
                                                   (pFifoHashAddArg->engine << SF_SHIFT(NV_RAMHT_ENGINE)) |
                                                   (pFifoHashAddArg->chid << SF_SHIFT(NV_RAMHT_CHID)) |
                                                   (NV_RAMHT_STATUS_VALID << SF_SHIFT(NV_RAMHT_STATUS)));
    
    return (RM_OK);
}

//
// nvHalHashDelete
//
RM_STATUS
nvHalFifoHashDelete_NV04(VOID *arg)
{
    PFIFOHASHDELETEARG_000 pFifoHashDeleteArg = (PFIFOHASHDELETEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashDeleteArg->id != FIFO_HASH_DELETE_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoHashDeleteArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    REG_WR32_DIRECT(&hwHashTable[pFifoHashDeleteArg->entry].ht_ObjectHandle, 0);
    REG_WR32_DIRECT(&hwHashTable[pFifoHashDeleteArg->entry].ht_Context, 0);

    return (RM_OK);
}

RM_STATUS
nvHalFifoHashFunc_NV04(VOID *arg)
{
    PFIFOHASHFUNCARG_000 pFifoHashFuncArg = (PFIFOHASHFUNCARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashFuncArg->id != FIFO_HASH_FUNC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pFifoHashFuncArg->result = FIFO_HASH(pFifoHashFuncArg->handle, pFifoHashFuncArg->chid);

    return (RM_OK);    
}

RM_STATUS
nvHalFifoHashSearch_NV04(VOID *arg)
{
    PFIFOHASHSEARCHARG_000 pFifoHashSearchArg = (PFIFOHASHSEARCHARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PPRAMHALINFO pPramHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    PHWREG nvAddr;
    U032 Entry;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashSearchArg->id != FIFO_HASH_SEARCH_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoHashSearchArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    pPramHalInfo = pHalHwInfo->pPramHalInfo; 
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    pFifoHashSearchArg->result = 0x0;

    // Attempt to find a valid entry in the Hash (checking Name and ChID)
    for (Entry = 0; Entry < pPramHalInfo->HashDepth; Entry++)
    {
        if (REG_RD32_DIRECT(&hwHashTable[Entry].ht_ObjectHandle) == pFifoHashSearchArg->handle)
        {
            U032 chid, valid;
            U032 context = REG_RD32_DIRECT(&hwHashTable[Entry].ht_Context);
             
            chid  = context >> SF_SHIFT(NV_RAMHT_CHID) & SF_MASK(NV_RAMHT_CHID);
            valid = context >> SF_SHIFT(NV_RAMHT_STATUS) & SF_MASK(NV_RAMHT_STATUS);

            if ((valid == NV_RAMHT_STATUS_VALID) && (chid == pFifoHashSearchArg->chid))
            {
                pFifoHashSearchArg->result = context;
                break;
            }
        }
    }

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\gr\nv\grmethd.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRMETHD.C                                                         *
*   The graphics engine is managed in this module.  All priviledged state   *
*   relating to the canvas and datapath is managed here.  Context switching *
*   is also contained here.                                                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <dac.h>
#include <gr.h>
#include <modular.h>   
#include <os.h>
#include <nv32.h>
#include "nvhw.h"


// extern PGRAPHICSCHANNEL grTable;


//---------------------------------------------------------------------------
//
//  Graphics video patchcord methods
//
//---------------------------------------------------------------------------

RM_STATUS mthdSetVideoInput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    return (RM_OK);

#ifdef KJK
    RM_STATUS       status;
    U032            InputIndex;
    U032            i;
    PVIDEOPATCHCORD *VideoInput;
    PVIDEOPATCHCORD VideoOutput;
    PVIDEOPATCHCORD VideoPatchcord;
    
    InputIndex = (Offset - Method->Low) / 4;

    /*
    KJK This is probably useless, since we wouldn't
        have been called if the method itself was
        out of range for this object.

    switch (Object->Class->Type)
    {
        case NV_VIDEO_SWITCH:
            if (InputIndex >= 2)
                return (RM_ERR_INVALID_PATCH);
            break;
        default:
            if (InputIndex >= MAX_GRPATCH_INPUT)
                return (RM_ERR_INVALID_PATCH);
            break;
    }
    */

    switch (Object->Class->Type)
    {
        case NV_VIDEO_SINK:
            VideoInput  = &(((PVIDEOSINKOBJECT)Object)->VideoInput[InputIndex]);
            VideoOutput = NULL;
            break;
        case NV_VIDEO_COLORMAP:
            VideoInput  = &(((PVIDEOCOLORMAPOBJECT)Object)->VideoInput);
            VideoOutput =   ((PVIDEOCOLORMAPOBJECT)Object)->VideoOutput;
            break;
        case NV_VIDEO_SCALER:
            VideoInput  = &(((PVIDEOSCALEROBJECT)Object)->VideoInput);
            VideoOutput =   ((PVIDEOSCALEROBJECT)Object)->VideoOutput;
            break;
        /*            
        case NV_VIDEO_CAPTURE_TO_MEMORY:
            VideoInput  = &(((PVIDEOTOMEMOBJECT)Object)->VideoInput);
            VideoOutput = NULL;
            break;
        */            
        default:
            VideoInput  = &(((PVIDEOOBJECT)Object)->VideoInput[InputIndex]);
            VideoOutput =   ((PVIDEOOBJECT)Object)->VideoOutput;
            break;
    }

    //
    // Disconnect old patchcord.  Break apart all patch information.
    //
    if (*VideoInput)
    {
        DBG_VAL_PTR(*VideoInput);
        for (i = 0; (*VideoInput)->Destination[i] != (PVIDEOOBJECT)Object; i++);
        (*VideoInput)->FanOut--;
        (*VideoInput)->Destination[i] = NULL;
        *VideoInput                   = NULL;
    }

    if (Data)
    {
        //
        // Validate patchcord and connect.
        //
        status = fifoSearchObject(pDev, Data, Object->ChID, (POBJECT *)&VideoPatchcord);
        if (status)
            return (status);
        if (VideoPatchcord->Base.Class->Type != NV_PATCHCORD_VIDEO)
            return (RM_ERR_OBJECT_TYPE_MISMATCH);
        if (VideoPatchcord->FanOut == MAX_GRPATCH_FANOUT)
            return (RM_ERR_MAX_PATCH_FANOUT);
        for (i = 0; (i < MAX_GRPATCH_FANOUT) && (VideoPatchcord->Destination[i] != (PVIDEOOBJECT)Object); i++);
        if (i == MAX_GRPATCH_FANOUT)
        {
            //
            // Insert this connection into the first available slot.
            //
            for (i = 0; VideoPatchcord->Destination[i]; i++);
            VideoPatchcord->FanOut++;
            VideoPatchcord->Destination[i] = (PVIDEOOBJECT)Object;
            *VideoInput                    = VideoPatchcord;
        }
    }

    return (RM_OK);
#endif // KJK    
}

RM_STATUS mthdSetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    return (RM_OK);

#ifdef KJK
    RM_STATUS        status;
    PVIDEOPATCHCORD *VideoOutput;
    PVIDEOPATCHCORD  VideoPatchcord;
    
    switch (Object->Class->Type)
    {
        /*
        case NV_IMAGE_TO_VIDEO:
            VideoOutput = &(((PIMAGEVIDEOOBJECT)Object)->VideoOutput);
            break;
        */            
        case NV_VIDEO_FROM_MEMORY:
            VideoOutput = &(((PVIDEOFROMMEMOBJECT)Object)->VideoOutput);
            break;
        /*            
        case NV_VIDEO_SOURCE:
            VideoOutput = &(((PVIDEOSOURCEOBJECT)Object)->VideoOutput);
            break;
        */            
        default:
            VideoOutput = &(((PVIDEOOBJECT)Object)->VideoOutput);
            break;
    }
    //
    // Disconnect old patchcord.  Break apart all patch information.
    //
    if (*VideoOutput)
    {
        DBG_VAL_PTR(*VideoOutput);
        grInvalidateVideoPatchcord(*VideoOutput);
        (*VideoOutput)->Source = NULL;
        *VideoOutput           = NULL;
    }
    if (Data)
    {
        //
        // Validate patchcord and connect.
        //
        status = fifoSearchObject(pDev, Data, Object->ChID, (POBJECT *)&VideoPatchcord);
        if (status)
            return (status);
        if (VideoPatchcord->Base.Class->Type != NV_PATCHCORD_VIDEO)
            return (RM_ERR_OBJECT_TYPE_MISMATCH);
        //
        // Unplug patchcord if already in use.
        //    
        if (VideoPatchcord->Source)
        {
            DBG_VAL_PTR(VideoPatchcord->Source);
            grInvalidateVideoPatchcord(VideoPatchcord);
            switch (VideoPatchcord->Source->Base.Class->Type)
            {
                /*
                case NV_IMAGE_TO_VIDEO:
                    ((PIMAGEVIDEOOBJECT)VideoPatchcord->Source)->VideoOutput = NULL;
                    break;
                */                    
                case NV_VIDEO_FROM_MEMORY:
                    ((PVIDEOFROMMEMOBJECT)VideoPatchcord->Source)->VideoOutput = NULL;
                    break;
                /*                    
                case NV_VIDEO_SOURCE:
                    ((PVIDEOSOURCEOBJECT)VideoPatchcord->Source)->VideoOutput = NULL;
                    break;
                */                    
                default:
                    VideoPatchcord->Source->VideoOutput = NULL;
                    break;
            }
        }
        //
        // Insert this connection into the first available slot.
        //
        VideoPatchcord->Source = (PVIDEOOBJECT)Object;
        *VideoOutput = VideoPatchcord;
    }
    return (RM_OK);
#endif // KJK
}

//---------------------------------------------------------------------------
//
//  Graphics class methods that map directly to hardware.
//
//---------------------------------------------------------------------------



//---------------------------------------------------------------------------
//
//  Colormap methods.
//
//---------------------------------------------------------------------------

RM_STATUS mthdSetColormapCtxDma
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    RM_STATUS            status;
    PVIDEOCOLORMAPOBJECT ColormapObject;
    
    ColormapObject = (PVIDEOCOLORMAPOBJECT)Object;
    //
    // Check for a previous translation.  Free its resource before overwriting.
    //
    if (Data == NV1_NULL_OBJECT)
    {
        ColormapObject->Xlate = NULL;
        return (RM_OK);
    }
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(ColormapObject->Xlate));
    if (status)
    {
        osError(Object, Offset, Data, status);
        return (status);
    }
    return (RM_OK);
}
RM_STATUS mthdSetColormapFormat
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    ((PVIDEOCOLORMAPOBJECT)Object)->ColorFormat = Data;
    return (RM_OK);
}
RM_STATUS mthdSetColormapStart
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    ((PVIDEOCOLORMAPOBJECT)Object)->Start = Data;
    return (RM_OK);
}
RM_STATUS mthdSetColormapLength
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    ((PVIDEOCOLORMAPOBJECT)Object)->Length = Data;
    return (RM_OK);
}
RM_STATUS mthdColormapDirtyStart
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    ((PVIDEOCOLORMAPOBJECT)Object)->DirtyStart = Data + ((PVIDEOCOLORMAPOBJECT)Object)->Start;
    return (RM_OK);
}
RM_STATUS mthdColormapDirtyLength
(
    PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    RM_STATUS       status;
    PVIDEOCOLORMAPOBJECT ColormapObject;
    U032           *ColormapBuffer, *ColormapBufferBase;
    U032            StartIndex;
    U032            StopIndex;
    
    ColormapObject = (PVIDEOCOLORMAPOBJECT)Object;
    //
    // Validate length.
    //
    if ((ColormapObject->DirtyStart + Data) > (ColormapObject->Start + ColormapObject->Length))
        return (RM_ERR_INVALID_START_LENGTH);
    ColormapObject->DirtyLength = Data;
    //
    // Validate enumeration parameters.
    //
    if (!ColormapObject->Xlate)
        return (RM_ERR_INVALID_XLATE);
	/* KJK
    status = dmaAttach(ColormapObject->Xlate);
    if (status)
        return (status);
	*/
    status = dmaValidateXlate(ColormapObject->Xlate,
                              ColormapObject->Start,
                              ColormapObject->Length);
    if (status)
        return (status);
	/* KJK
    status = dmaBeginXfer(ColormapObject->Xlate, NULL);
    if (status)
        return (status);
	*/
    //
    // Get buffer translation.
    //
    status = dmaGetMappedAddress(pDev, ColormapObject->Xlate,
                                 ColormapObject->DirtyStart,
                                 ColormapObject->DirtyLength,
                                 (VOID **)&ColormapBuffer);
    if (status)
        return (status);
        
    // save original ptr value    
	ColormapBufferBase = ColormapBuffer;
    
    //
    // Load new colormap into palette copy.
    //
    if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_COLORMAP)
        pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_COLORMAP;
    StartIndex = (ColormapObject->DirtyStart - ColormapObject->Start) >> 2;
    StopIndex  = StartIndex + ((ColormapObject->DirtyLength) >> 2);
    if (StopIndex > 255)
        StopIndex = 255;
    while (StartIndex <= StopIndex)
    {
        ColormapObject->ColorMap[StartIndex] = *ColormapBuffer;
        if (pDev->Dac.HalInfo.Depth == 8)
            pDev->Dac.Palette[StartIndex++]     = *ColormapBuffer++;
        else    
            pDev->Dac.Gamma[StartIndex++]       = *ColormapBuffer++;
    }
    pDev->colormapObjectToNotify = ColormapObject;
    pDev->Dac.UpdateFlags |= UPDATE_HWINFO_DAC_COLORMAP;
    //KJK dmaEndXfer(ColormapObject->Xlate, NULL);
    //dmaDetach(ColormapObject->Xlate);    
    return (RM_OK);
}

RM_STATUS mthdColormapDirtyNotify
(
    PHWINFO   pDev,
    RM_STATUS status
)
{
    RM_STATUS rmStatus;
    PVIDEOCOLORMAPOBJECT pColormapObj;
    
    pColormapObj = pDev->colormapObjectToNotify;
    
    if (pColormapObj == NULL)
        return RM_OK;
        
    rmStatus = notifyFillNotifierArray(pDev, pColormapObj->CBase.NotifyXlate,
                                       0 /* info32 */, 0 /* info16 */, 
                                       status,
                                       NVFF9_NOTIFIERS_COLORMAP_DIRTY_NOTIFY);
    //
    // Do any OS specified action related to this notification.
    //
    if (pColormapObj->CBase.NotifyAction)
    {
        osNotifyEvent(pDev,
                      (POBJECT)pColormapObj, 
                      NVFF9_NOTIFIERS_COLORMAP_DIRTY_NOTIFY,
                      0 /* Method */, 
                      0 /* Data */, 
                      status, 
                      pColormapObj->CBase.NotifyAction);
    }
                                       
    pDev->colormapObjectToNotify = NULL;
    return rmStatus;
}

//---------------------------------------------------------------------------
//
//  Graphics notification on completion of VBlank.
//
//---------------------------------------------------------------------------

RM_STATUS grVideoSwitchComplete
(
	PHWINFO   pDev,
    POBJECT   Object,
    U032      Method,
    V032      Data,
    RM_STATUS Status
)
{
    notifyFillNotifier(pDev, ((PVIDEOSWITCHOBJECT)Object)->VBlankNotify[Data].Xlate, 0, 0, Status);
    //KJK dmaEndXfer(((PVIDEOSWITCHOBJECT)Object)->VBlankNotify[Data].Xlate, NULL);
    //
    // Do any OS specified action related to this notification.
    //
    if (((PVIDEOSWITCHOBJECT)Object)->VBlankNotify[Data].Action)
    {
        osNotifyEvent(pDev,
                      Object,
        			  0,
                      0x0400 + (Data << 2),
                      Object->Name,
                      Status,
                      ((PVIDEOSWITCHOBJECT)Object)->VBlankNotify[Data].Action);
    }
    ((PVIDEOSWITCHOBJECT)Object)->VBlankNotify[Data].Pending = FALSE;
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Default HW method handler for graphics engine classes.
//
//---------------------------------------------------------------------------

RM_STATUS grHWMethod
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: grHWMethod class ", Object->Class->Type);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:            chid ", Object->ChID);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:            handle ", Object->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:            offset ", Offset);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:            data ", Data);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:            instance ", ((PCOMMONOBJECT)Object)->Instance);
    DBG_BREAKPOINT();

    //
    // THIS IS A HARDWARE METHOD...
    //
    // We'll only be here if we get an ILLEGAL_MTHD exception
    // from graphics.  We don't attempt any recovery, just drop
    // it on the floor and continue...
    //
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\fifo\nv20\fifonv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************* Chip Specific HAL FIFO Routines *********************\
*                                                                           *
* Module: FIFONV20.C                                                        *
*   The NV20 specific HAL FIFO routines reside in this file.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalFifoControl_NV20(VOID *);
RM_STATUS nvHalFifoAllocPio_NV20(VOID *);
RM_STATUS nvHalFifoAllocDma_NV20(VOID *);
RM_STATUS nvHalFifoFree_NV20(VOID *);
RM_STATUS nvHalFifoGetExceptionData_NV20(VOID *);
RM_STATUS nvHalFifoService_NV20(VOID *);
RM_STATUS nvHalFifoAccess_NV20(VOID *);
RM_STATUS nvHalFifoHashAdd_NV20(VOID *);
RM_STATUS nvHalFifoHashDelete_NV20(VOID *);
RM_STATUS nvHalFifoHashFunc_NV20(VOID *);

// The context switch interface is only used internally, but perhaps
// should be made available to the resource manager anyway.
static RM_STATUS nvHalFifoContextSwitch_NV20(PHALHWINFO, U032);

static U032 nvHalFifoCalcDmaFetch_NV20(U032, U032, U032);

RM_STATUS
nvHalFifoControl_NV20(VOID *arg)
{
    PFIFOCONTROLARG_000 pFifoControlArg = (PFIFOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV20 pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
	PHWREG nvAddr;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoControlArg->id != FIFO_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoControlArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pFifoControlArg->cmd) {
        case FIFO_CONTROL_INIT:
            //
            // Setup default parameters. 
            //
            pFifoHalInfo->RetryCount = 255;
            pFifoHalInfo->UserBase = DEVICE_BASE(NV_USER);
            pFifoHalPvtInfo->Mode = 0;
            pFifoHalPvtInfo->InUse = 0;

            //
            // Setup interrupt enable mask.
            //
            pFifoHalInfo->IntrEn0 =
                DRF_DEF(_PFIFO, _INTR_EN_0, _CACHE_ERROR, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT_OVERFLOW, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PUSHER, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PT, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _SEMAPHORE, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _ACQUIRE_TIMEOUT, _ENABLED);

            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            //
            // Zero DMA FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            //
            // Zero FIFO hash valid.
            //
            REG_WR32(NV_PFIFO_CACHE0_HASH, 0);
            REG_WR32(NV_PFIFO_CACHE1_HASH, 0);
            //
            // Zero engine assignments
            //
            //REG_WR32(NV_PFIFO_CACHE0_ENGINE, 0);
            //REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
            //
            // Make all FIFO's default
            //
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
            REG_WR32(NV_PFIFO_DMA, 0);
            REG_WR32(NV_PFIFO_SIZE, 0);
            //
            // Clear all pusher state
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            //
            // Zero run-out pointers.
            //
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_PUT, _ADDRESS, 0);
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_GET, _ADDRESS, 0);
            break;
        case FIFO_CONTROL_LOAD:
            //
            // Update the dma fetch numbers using reasonable defaults.
            // We don't need to worry about the endianness bit here
            // because we're going to swap this channel out asap
            //
            
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15));
            
            //
            // Enable default timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, 
                     DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _ENABLED)
                     | DRF_DEF(_PFIFO, _DMA_TIMESLICE, _SELECT, _128K));
            
            //
            // Set retry delay to match common hardware latency.
            //
            REG_WR_DRF_NUM(_PFIFO, _DELAY_0, _WAIT_RETRY, pFifoHalInfo->RetryCount);
            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Disable the pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV20(pHalHwInfo, (NUM_FIFOS_NV20 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);

            //
            // Enable pusher and puller access to cache1.
            //
            FIFOLOG(3, 1, 0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _ENABLED);
            //
            // Delay for slow CACHE1_PULL.
            //
            //temp = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _ENABLED);
            //
            // Enable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _ENABLED);
            break;
        case FIFO_CONTROL_UNLOAD:
            //
            // Disable dma timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _DISABLED));

            //
            // Empty FIFO and runout.
            //
            while ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK) != NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY))
            {
                //
                // Make sure we process any fifo interrupts
                //
                HALRMSERVICEINTR(pHalHwInfo, FIFO_ENGINE_TAG);
                
                //
                // Check if GE needs servicing.
                //
                if (REG_RD32(NV_PGRAPH_INTR))
                    HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);

                // Check if vblank needs servicing.
                if (REG_RD32(NV_PMC_INTR_0) & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
                    HALRMSERVICEINTR(pHalHwInfo, DAC_ENGINE_TAG);
            }

            //
            // Disable the dma pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);

            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
                ;
            
            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV20(pHalHwInfo, (NUM_FIFOS_NV20 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            
            //
            // Flush all FIFOs.
            //
            FifoReassign = REG_RD32(NV_PFIFO_CACHES);
            FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
            FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Update the FIFO context and its dirty bits.  By moving the get pointer to the current
            // put value, we are flushing any pending push data that hasn't been fetched yet.
            //
            for (i = 0; i < NUM_FIFOS_NV20; i++)
            {
                if (pFifoHalPvtInfo->InUse & (1 << i))
                {
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr1 + (i * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_GET)), 
                             REG_RD32((U032)(pFbHalPvtInfo->fifoContextAddr1 + (i * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_PUT))));

                    //
                    // Also, when setting the channels get pointer equal to its put, ensure the next
                    // DWORD is interpreted as a command (and not data) by clearing RAMFC_DMA_METHOD.
                    //
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr1 + (i * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), 0x0);
                }
            }

            //
            // Restore CACHE1 state.
            //
            FIFOLOG(1, FifoPull, FifoReassign);
            REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
            REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
            REG_WR32(NV_PFIFO_CACHES, FifoReassign);

            //
            // Flush all pending
            //
            REG_WR32(NV_PFIFO_DMA, 0);
            
            //
            // Disable all FIFO interrupts.
            //
            REG_WR32(NV_PFIFO_INTR_EN_0, 0);
            break;
        case FIFO_CONTROL_DESTROY:
            break;
        case FIFO_CONTROL_UPDATE:
            //
            // Update the dma fetch numbers using reasonable defaults.
            // Use FLD_WR_DRF_DEF so that we don't kill the endianness bit
			//
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES);
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES);
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15);
            break;

        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalFifoAllocPio
//
// Allocate PIO channel.
//
RM_STATUS
nvHalFifoAllocPio_NV20(VOID *arg)
{
    PFIFOALLOCPIOARG_000 pFifoAllocPioArg = (PFIFOALLOCPIOARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV20 pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PGRHALINFO_NV20 pGrHalPvtInfo;
	PHWREG nvAddr;
    U032 CacheData, InitCtxtPtr, grCtxTable;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoAllocPioArg->id != FIFO_ALLOC_PIO_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoAllocPioArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);

    //
    // Clear graphics context buffer.
    //
    for (i = 0; i < NV20_GR_CONTEXT_SIZE/4; i++)
        INST_WR32(pFifoAllocPioArg->instance, i*4, 0);

    //
    // Now load graphics channel context buffer address into both
    // the hardware table and our shadow copy.
    //
    grCtxTable = pGrHalPvtInfo->CtxTableBase;

#ifdef DEBUG
    if (INST_RD32(grCtxTable, pFifoAllocPioArg->chid * 4) != 0)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: pio channel has non-null context instance", pFifoAllocPioArg->chid);
        DBG_BREAKPOINT();
    }
    if (pGrHalPvtInfo->CtxTable[pFifoAllocPioArg->chid] != 0)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: pio channel has non-null shadow context instance", pFifoAllocPioArg->chid);
        DBG_BREAKPOINT();
    }
#endif

    INST_WR32(grCtxTable, pFifoAllocPioArg->chid * 4, pFifoAllocPioArg->instance);
    pGrHalPvtInfo->CtxTable[pFifoAllocPioArg->chid] = pFifoAllocPioArg->instance;

    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr1 + (pFifoAllocPioArg->chid * FC1_SIZE_NV20);
    for (i = 0; i < FC1_SIZE_NV20/4; i++)
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Set MODE to pio.
    //
    pFifoHalPvtInfo->Mode &= ~(1 << pFifoAllocPioArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocPioArg->chid))
    {
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,    pFifoAllocPioArg->chid);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT,   _ADDRESS, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_GET,   _ADDRESS, 0);
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        //
        // Enable cache1.
        //
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocPioArg->chid);

    return (RM_OK);
}

//
// nvHalFifoCalcDmaFetch
//
// Derive chip-dependent DMA fetch parameter register value
// from values specified at channel allocation time.
//
U032
nvHalFifoCalcDmaFetch_NV20(U032 fetchTrigger, U032 fetchSize, U032 fetchRequests)
{
    U032 dmaFetch;

    //
    // Input trigger value is in bytes.
    // Hardware value must be specified in increments of 8 between
    // 8 - 256 bytes.
    //
    if (fetchTrigger < 8) fetchTrigger = 8;
    if (fetchTrigger > 256) fetchTrigger = 256;
    fetchTrigger = (fetchTrigger / 8) - 1;

    //
    // Input size value is in bytes.
    // Hardware value must be specified in increments of 32
    // between 32 - 256 bytes.
    //
    if (fetchSize < 32) fetchSize = 32;
    if (fetchSize > 256) fetchSize = 256;
    fetchSize = (fetchSize / 32) - 1;

    //
    // Requests must be between 0 and 15.
    //
    if (fetchRequests > 15) fetchRequests = 15;

    //
    // Put it all together.
    //
    dmaFetch = DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, fetchTrigger) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, fetchSize) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, fetchRequests);

    return dmaFetch;
}

//
//
// nvHalFifoAllocDma
//
// Allocate DMA channel.
//
RM_STATUS
nvHalFifoAllocDma_NV20(VOID *arg)
{
    PFIFOALLOCDMAARG_000 pFifoAllocDmaArg = (PFIFOALLOCDMAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV20 pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PGRHALINFO_NV20 pGrHalPvtInfo;
	PHWREG nvAddr;
    U032 CacheData, InitCtxtPtr, grCtxTable;
    U032 DefaultFetch;
    U032 i;

    //
    // Verify interface revision.
    //
    if (pFifoAllocDmaArg->id != FIFO_ALLOC_DMA_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoAllocDmaArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);

    //
    // Clear graphics context buffer.
    //
    for (i = 0; i < NV20_GR_CONTEXT_SIZE/4; i++)
        INST_WR32(pFifoAllocDmaArg->instance, i*4, 0);

    //
    // Load graphics channel context pointer.
    //
    grCtxTable = pGrHalPvtInfo->CtxTableBase;

#ifdef DEBUG
    //
    // ASSERT that the entry for this channel is currently null.
    //
    if (INST_RD32(grCtxTable, pFifoAllocDmaArg->chid * 4) != 0)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: dma channel has non-null context instance", pFifoAllocDmaArg->chid);
        DBG_BREAKPOINT();
    }
    if (pGrHalPvtInfo->CtxTable[pFifoAllocDmaArg->chid] != 0)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: pio channel has non-null shadow context instance", pFifoAllocDmaArg->chid);
        DBG_BREAKPOINT();
    }
#endif

    INST_WR32(grCtxTable, pFifoAllocDmaArg->chid * 4, pFifoAllocDmaArg->instance);
    pGrHalPvtInfo->CtxTable[pFifoAllocDmaArg->chid] = pFifoAllocDmaArg->instance;
    
    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr1 + (pFifoAllocDmaArg->chid * FC1_SIZE_NV20);
    for (i = 0 ; i < FC1_SIZE_NV20/4; i++ )
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Insert the instance (note that the rest of the context can start as zero)
    //
    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_INST)), pFifoAllocDmaArg->dmaInstance);
    
    //
    // Calculate the endianness for the channel
    // Each channel can have its own endian-ness, but the api does not
    // yet support that.  So for now the channel endianness follows
    // from the rest of the system
    //
    if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
        DefaultFetch = DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _ENDIAN, _BIG);
    else
        DefaultFetch = DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _ENDIAN, _LITTLE);

    //
    // Adjust fetch max request (exception to the "all start as zero" rule)
    //
    DefaultFetch |= nvHalFifoCalcDmaFetch_NV20(pFifoAllocDmaArg->fetchTrigger, pFifoAllocDmaArg->fetchSize, pFifoAllocDmaArg->fetchRequests);

    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), DefaultFetch);
    
    //
    // Set channel mode to dma
    //
    pFifoHalPvtInfo->Mode |= (1 << pFifoAllocDmaArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocDmaArg->chid))
    {
        //
        // KJK Warning!!  We're getting in here if this is the first (0)
        // channel allocated in the system due to the checks above.
        // We really shouldn't be...
        //
        
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,   pFifoAllocDmaArg->chid);
        
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
        
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_PUT, _OFFSET, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_GET, _OFFSET, 0);
        
        REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, pFifoAllocDmaArg->dmaInstance);

        //
        // Force a reload of the PTE's
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_CTL, 0);
        
        //
        // Clear all pusher state
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // Set default watermarks
        //
        //REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0x000F6068);
        REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, DefaultFetch);
        
        //
        // Enable cache1.
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);
        
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocDmaArg->chid);

    return (RM_OK);
}

//
// nvHalFifoFree
//
// Free fifo resources.
//
RM_STATUS
nvHalFifoFree_NV20(VOID *arg)
{
    PFIFOFREEARG_000 pFifoFreeArg = (PFIFOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV20 pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PGRHALINFO_NV20 pGrHalPvtInfo;
	PHWREG nvAddr;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 InitCtxtPtr, grCtxTable;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoFreeArg->id != FIFO_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoFreeArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush     = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull     = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES,       _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
    FIFOLOG(4, 0, 0);

    //
    // Update the FIFO context and its dirty bits.
    //    
    if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoFreeArg->chid)
    {
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // If this is a dma channel, we need to shut him down and clear out
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Disable dma pusher activity
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUSH, 0);
            
            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
			    ;
            
            //
            // Now zero everything out
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_TLB_PTE, 0);
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }        
    }
    else
    {
        //
        // Flush the context into the FIFO context RAM.
        //
        InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr1 + (pFifoFreeArg->chid * FC1_SIZE_NV20);
        for (i = 0; i < FC1_SIZE_NV20/4; i++)
        {
            REG_WR32(InitCtxtPtr+(4*i), 0);
        }
        
        //
        // If this is a dma channel, make sure we clear any pending pushing
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Clear any pending transfers
            //
            REG_WR32(NV_PFIFO_DMA, REG_RD32(NV_PFIFO_DMA) & (~(1 << pFifoFreeArg->chid)));
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }
    }

    //
    // Clear graphics channel context pointer.
    //
    grCtxTable = pGrHalPvtInfo->CtxTableBase;
#ifdef DEBUG
    //
    // ASSERT that the entry for this channel is currently non-null.
    //
    if (INST_RD32(grCtxTable, pFifoFreeArg->chid * 4) == 0)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: freed channel has null context instance!", pFifoFreeArg->chid);
        DBG_BREAKPOINT();
    }
    if (pGrHalPvtInfo->CtxTable[pFifoFreeArg->chid] == 0)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: pio channel has null shadow context instance", pFifoFreeArg->chid);
        DBG_BREAKPOINT();
    }
#endif
    INST_WR32(grCtxTable, pFifoFreeArg->chid * 4, 0);
    pGrHalPvtInfo->CtxTable[pFifoFreeArg->chid] = 0;

    //
    // Restore CACHE1 state.
    //
    FIFOLOG(4, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    //
    // Free up channel.
    //
    pFifoHalPvtInfo->InUse &= ~(1 << pFifoFreeArg->chid);

    pFifoHalInfo->AllocateCount--;

    return (RM_OK);
}

//
// nvHalFifoContextSwitch
//
// Context switch the fifo.
//
static RM_STATUS
nvHalFifoContextSwitch_NV20(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PFIFOHALINFO_NV20 pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 CurrentChID;
    U032 PushPending;
    U032 CtxtPtr = (U032)pFbHalPvtInfo->fifoContextAddr1;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
    FIFOLOG(1, 0, 0);
    
    //
    // Make sure our local (rm) contexts are up to date for the outgoing channel
    //
    CurrentChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID); 

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Manually saving the FIFO context on ChID: ", CurrentChID);

    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_PUT)), REG_RD32(NV_PFIFO_CACHE1_DMA_PUT));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_GET)), REG_RD32(NV_PFIFO_CACHE1_DMA_GET));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_REF_CNT)), REG_RD32(NV_PFIFO_CACHE1_REF));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_INST)), REG_RD32(NV_PFIFO_CACHE1_DMA_INSTANCE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), REG_RD32(NV_PFIFO_CACHE1_DMA_STATE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), REG_RD32(NV_PFIFO_CACHE1_DMA_FETCH));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0)), REG_RD32(NV_PFIFO_CACHE1_ENGINE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE)), REG_RD32(NV_PFIFO_CACHE1_PULL1));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_VALUE)), REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_2));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_TIMESTAMP)), REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_1));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_TIMEOUT)), REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_0));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_SEMAPHORE_CTXDMA)), REG_RD32(NV_PFIFO_CACHE1_SEMAPHORE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_SUBROUTINE_STATE)), REG_RD32(NV_PFIFO_CACHE1_DMA_SUBROUTINE));
    
    //
    // If this is a push channel and put != get, make sure to set the push pending flag
    //
    if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
    {    
        PushPending = REG_RD32(NV_PFIFO_DMA) & ~(1 << CurrentChID);
        if (REG_RD32(NV_PFIFO_CACHE1_DMA_PUT) != REG_RD32(NV_PFIFO_CACHE1_DMA_GET))
            PushPending |= (1 << CurrentChID);
        REG_WR32(NV_PFIFO_DMA, PushPending);
    }                    
    
    //
    // Bring in the context for the new channel from the fifo context ram.
    //
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Manually restoring the FIFO context on ChID: ", ChID);

    //
    // Update the channel and if it's DMA, set the mode
    //
    REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID, ChID);
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV20 - 1)))
        FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
    
    REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_PUT))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_GET, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_GET))));
    REG_WR32(NV_PFIFO_CACHE1_REF,REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_REF_CNT))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_INST))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_METHOD))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG))));
    REG_WR32(NV_PFIFO_CACHE1_ENGINE, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0))));
    REG_WR32(NV_PFIFO_CACHE1_PULL1, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE))));
    REG_WR32(NV_PFIFO_CACHE1_ACQUIRE_2, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_VALUE))));
    REG_WR32(NV_PFIFO_CACHE1_ACQUIRE_1, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_TIMESTAMP))));
    REG_WR32(NV_PFIFO_CACHE1_ACQUIRE_0, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_TIMEOUT))));
    REG_WR32(NV_PFIFO_CACHE1_SEMAPHORE, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_SEMAPHORE_CTXDMA))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_SUBROUTINE, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_SUBROUTINE_STATE))));

         
    //
    // If DMA, enable the DMA Pusher
    //
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV20 - 1)))
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);

    //
    // In case there are dma pusher channels still pending, give this
    // new channel enough time to do something useful before it gets
    // yanked back out again.
    //
    REG_WR32(NV_PFIFO_TIMESLICE, 0x1fffff);     
           
    //
    // Restore CACHE1 state.
    //
    FIFOLOG(1, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    return (RM_OK);
}

//
// nvHalFifoGetExceptionData
//
RM_STATUS
nvHalFifoGetExceptionData_NV20(VOID *arg)
{
    PFIFOGETEXCEPTIONDATAARG_000 pFifoGetExceptionDataArg = (PFIFOGETEXCEPTIONDATAARG_000)arg;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 GetPtr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoGetExceptionDataArg->id != FIFO_GET_EXCEPTION_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);
    
    pHalHwInfo = pFifoGetExceptionDataArg->pHalHwInfo;
    pFifoExceptionData = pFifoGetExceptionDataArg->pExceptionData;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Fill in exception data.
    //
    pFifoExceptionData->Reason = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    pFifoExceptionData->ChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);
    GetPtr = REG_RD32(NV_PFIFO_CACHE1_GET) >> 2;
    pFifoExceptionData->GetPtr = GetPtr;
    pFifoExceptionData->SubChannel =
        (((REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr))) >> DRF_SHIFT(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL)) & 
         DRF_MASK(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL));
    pFifoExceptionData->Method = REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr)) & 0x1FFC;
    pFifoExceptionData->Data = REG_RD32(NV_PFIFO_CACHE1_DATA(GetPtr));

    return (RM_OK);
}

//
// nvHalFifoService
//
RM_STATUS
nvHalFifoService_NV20(VOID *arg)
{
    PFIFOSERVICEARG_000 pFifoServiceArg = (PFIFOSERVICEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV20 pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoServiceArg->id != FIFO_SERVICE_000)
        return (RM_ERR_VERSION_MISMATCH);
    
    pHalHwInfo = pFifoServiceArg->pHalHwInfo;
    pFifoExceptionData = pFifoServiceArg->pExceptionData;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Handle Runout.
    //
    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _PENDING))
    {
        U032 ChID;
        U032 SubChannel;
        U032 Type;
        U032 Method;
        U032 Data;
        U032 GetPtr = 0;  // some compilers think its uninitialized otherwise
        U032 Reason;
        U032 FifoPush, wasDmaChannel = 0;

        //
        // Deal with data in runout.
        //
        DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Cache ranout.  Waiting for cache to drain.\n\r");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         CACHE1 ChID = ", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID));

        //
        // Don't allow another channel to switch in
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHES,       _REASSIGN, _DISABLED);

        //
        // Disable CACHE1_PUSH0, so we're able to safely resubmit the runout method/data
        // back into the CACHE1 below.
        // 
        FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        
        //
        // If this is a DMA channel, start to shut down the current pushing
        //
        if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
        {
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            wasDmaChannel = 1;      // started this interrupt as a DMA channel
        }
            
        //
        // First wait for cache to drain and the dma pusher to be idle
        //
        if ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) == NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY) &&
            (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_IDLE))
        {            
            //
            // Cache is empty.  Deal with data in runout.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Since the CACHE1 has been idled, let's move its PUT/GET to the top
            // of the FIFO avoiding any overflow issues during the resubmit.
            //
#ifdef DEBUG
            if (REG_RD32(NV_PFIFO_CACHE1_PUT) != REG_RD32(NV_PFIFO_CACHE1_GET))
                DBG_BREAKPOINT();
#endif // DEBUG

            REG_WR32(NV_PFIFO_CACHE1_PUT, 0x0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0x0);

            //
            // Because we've taken the trouble to idle everything, rather than dump
            // a single method/data into the CACHE1 and wait, we'll resubmit all the
            // outstanding runout method/data back into the CACHE1.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut_PUT        = ", REG_RD32(NV_PFIFO_RUNOUT_PUT));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut_GET        = ", REG_RD32(NV_PFIFO_RUNOUT_GET));

            while (REG_RD32(NV_PFIFO_RUNOUT_PUT) != REG_RD32(NV_PFIFO_RUNOUT_GET))
            {
                //
                // Read FIFO state.
                //
                GetPtr     = REG_RD32(NV_PFIFO_RUNOUT_GET);
                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       RunOut Method = ", Data);

                ChID       = SF_VAL(_RAMRO, _CHID, Data);
                Type       = SF_VAL(_RAMRO, _TYPE, Data);
                Reason     = SF_VAL(_RAMRO, _REASON, Data);
                Method     = SF_VAL(_RAMRO, _METHOD, Data) & 0x1FFF;
                SubChannel = SF_VAL(_RAMRO, _SUBCHANNEL, Data) & 0x7;

                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr + 4);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       RunOut Data   = ", Data);

                //
                // Set user cache state to look just as if the runout came
                // from the bottom on the FIFO.  This keeps the OBJECT_CHANGED
                // bits in order.
                //
                if ((Type == NV_RAMRO_TYPE_WRITE)
                    && (Reason != NV_RAMRO_REASON_ILLEGAL_ACCESS)
                    && (Reason != NV_RAMRO_REASON_RESERVED_ACCESS))
                {
                    if ((ChID < NUM_FIFOS_NV20) && pFifoHalPvtInfo->InUse)
                    {
                        U032 Cache1Put;

                        //
                        // Since the fifo engine/resmgr no longer tracks object context on a per-subchannel
                        // basis, the only thing we can do with runout methods is to send them back down
                        // the main user fifo.
                        //
                        // Do we need to force a channel change?
                        //
                    
                        if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) != ChID)
                        {
                            nvHalFifoContextSwitch_NV20(pHalHwInfo, ChID);

                            //
                            // If we started out the interrupt as a DMA channel and have switched into
                            // a PIO channel, make sure to clear the SUSPEND bit (but don't reenable). 
                            // The HW likes to see this bit cleared after an intr and since we now look
                            // like a PIO channel, we'll just clear it here.
                            // 
                            if (wasDmaChannel && (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _MODE) == 0))
                                FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _STATUS, _RUNNING);
                        }

                        //
                        // Resubmit
                        //
                        Cache1Put = REG_RD_DRF(_PFIFO, _CACHE1_PUT, _ADDRESS);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,
                                                   "NVRM: Cache runout resubmit to CACHE1 addr:", Cache1Put << 2);

                        REG_WR32(NV_PFIFO_CACHE1_METHOD(Cache1Put), 
                            Method | DRF_NUM(_PFIFO, _CACHE0_METHOD, _SUBCHANNEL, SubChannel));
                        REG_WR32(NV_PFIFO_CACHE1_DATA(Cache1Put), Data);

                        //
                        // Update the CACHE1 Put ptr.
                        // There are no overflow worries, since we started at the top of the CACHE1
                        //
                        Cache1Put++;
                        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT, _ADDRESS, Cache1Put);
                    }
                    else
                    {
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Access to free channel:", ChID);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                 sub channel:", SubChannel);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                      offset:", Method);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                        data:", Data);
                        DBG_BREAKPOINT();
                    }
                }
            
                //
                // Advance the RunOut get pointer.
                //
                GetPtr = (GetPtr + 8) & pFbHalPvtInfo->fifoRunoutMask;
                REG_WR32(NV_PFIFO_RUNOUT_GET, GetPtr);
                GetPtr = REG_RD32(NV_PFIFO_RUNOUT_GET);      // flush delay to update runout_status
            }

            //
            // Clear condition if no more data in runout.
            //
            if (REG_RD32(NV_PFIFO_RUNOUT_STATUS) & DRF_DEF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK, _EMPTY))
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut has CAUGHT UP:", GetPtr);
                REG_WR_DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _RESET);
            } else {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut should be CAUGHT UP:", GetPtr);
                DBG_BREAKPOINT();
            }
        }
        else
        {
            //
            // Enable the puller to empty the cache.
            //
            FIFOLOG(1, 1, 0);
            REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _ENABLED);
        }

        // restore CACHE1_PUSH0 state
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    }

    //
    // Handle semaphore errors...
    //
    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _SEMAPHORE, _PENDING))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: DMA semaphore pending\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CACHE1_SEMAPHORE ", REG_RD32(NV_PFIFO_CACHE1_SEMAPHORE));
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _SEMAPHORE, _RESET);
        DBG_BREAKPOINT();
    }
    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _ACQUIRE_TIMEOUT, _PENDING))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: DMA acquire timeout pending\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CACHE1_ACQUIRE_0 ", REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_0));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CACHE1_ACQUIRE_1 ", REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_1));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CACHE1_ACQUIRE_2 ", REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_2));
        DBG_BREAKPOINT();
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _ACQUIRE_TIMEOUT, _RESET);

    }

    return (RM_OK);
}

//
// nvHalFifoAccess
//
RM_STATUS
nvHalFifoAccess_NV20(VOID *arg)
{
    PFIFOACCESSARG_000 pFifoAccessArg = (PFIFOACCESSARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOACCESSINFO pFifoAccessInfo;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoAccessArg->id != FIFO_ACCESS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoAccessArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    pFifoAccessInfo = pFifoAccessArg->pAccessInfo;

    switch (pFifoAccessArg->cmd) {
    case FIFO_ACCESS_DISABLE:
        //
        // This is the HW approved way of idling the FIFO, before changing its
        // context. After disabling reassign, wait for any pending channel changes
        // to complete. Also wait for the hash engine to idle then invalidate the
        // last lookup to avoid any miscompares (cleans up errors seen on IKOS).
        //
        pFifoAccessInfo->FifoReassign = REG_RD32(NV_PFIFO_CACHES);
        pFifoAccessInfo->FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        pFifoAccessInfo->FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);

        // disable reassign and wait for DMA_SUSPEND to go idle
        REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
        while (REG_RD_DRF(_PFIFO, _CACHES, _DMA_SUSPEND) == NV_PFIFO_CACHES_DMA_SUSPEND_BUSY)
            ;

        // disable cache1 push access and the cache1 puller
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);

        // wait for the hash engine to idle and invalidate its previous lookup
        while (REG_RD_DRF(_PFIFO, _CACHE1_PULL0, _HASH_STATE) == NV_PFIFO_CACHE1_PULL0_HASH_STATE_BUSY)
		    ;
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_HASH, _VALID, 0x0);
        break;
    case FIFO_ACCESS_ENABLE:
        REG_WR32(NV_PFIFO_CACHE1_PULL0, pFifoAccessInfo->FifoPull);
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, pFifoAccessInfo->FifoPush);
        REG_WR32(NV_PFIFO_CACHES, pFifoAccessInfo->FifoReassign);
        break;
    default:
        // invalid cmd
        return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalFifoHashAdd
//
RM_STATUS
nvHalFifoHashAdd_NV20(VOID *arg)
{
    PFIFOHASHADDARG_000 pFifoHashAddArg = (PFIFOHASHADDARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashAddArg->id != FIFO_HASH_ADD_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashAddArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    REG_WR32_DIRECT(&hwHashTable[pFifoHashAddArg->entry].ht_ObjectHandle, pFifoHashAddArg->handle);
    REG_WR32_DIRECT(&hwHashTable[pFifoHashAddArg->entry].ht_Context, (pFifoHashAddArg->instance & SF_MASK(NV_RAMHT_INSTANCE)) |
                                                   (pFifoHashAddArg->engine << SF_SHIFT(NV_RAMHT_ENGINE)) |
                                                   (pFifoHashAddArg->chid << SF_SHIFT(NV_RAMHT_CHID)) |
                                                   (NV_RAMHT_STATUS_VALID << SF_SHIFT(NV_RAMHT_STATUS)));
    
    return (RM_OK);
}

//
// nvHalHashDelete
//
RM_STATUS
nvHalFifoHashDelete_NV20(VOID *arg)
{
    PFIFOHASHDELETEARG_000 pFifoHashDeleteArg = (PFIFOHASHDELETEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashDeleteArg->id != FIFO_HASH_DELETE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashDeleteArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    REG_WR32_DIRECT(&hwHashTable[pFifoHashDeleteArg->entry].ht_ObjectHandle, 0);
    REG_WR32_DIRECT(&hwHashTable[pFifoHashDeleteArg->entry].ht_Context, 0);

    return (RM_OK);
}

RM_STATUS
nvHalFifoHashFunc_NV20(VOID *arg)
{
    PFIFOHASHFUNCARG_000 pFifoHashFuncArg = (PFIFOHASHFUNCARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashFuncArg->id != FIFO_HASH_FUNC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pFifoHashFuncArg->result = FIFO_HASH(pFifoHashFuncArg->handle, pFifoHashFuncArg->chid);

    return (RM_OK);    
}

RM_STATUS
nvHalFifoHashSearch_NV20(VOID *arg)
{
    PFIFOHASHSEARCHARG_000 pFifoHashSearchArg = (PFIFOHASHSEARCHARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PPRAMHALINFO pPramHalInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    PHWREG nvAddr;
    U032 Entry;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashSearchArg->id != FIFO_HASH_SEARCH_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashSearchArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo; 
    nvAddr = pHalHwInfo->nvBaseAddr;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    pFifoHashSearchArg->result = 0x0;

    // Attempt to find a valid entry in the Hash (checking Name and ChID)
    for (Entry = 0; Entry < pPramHalInfo->HashDepth; Entry++)
    {
        if (REG_RD32_DIRECT(&hwHashTable[Entry].ht_ObjectHandle) == pFifoHashSearchArg->handle)
        {
            U032 chid, valid;
            U032 context = REG_RD32_DIRECT(&hwHashTable[Entry].ht_Context);
             
            chid  = context >> SF_SHIFT(NV_RAMHT_CHID) & SF_MASK(NV_RAMHT_CHID);
            valid = context >> SF_SHIFT(NV_RAMHT_STATUS) & SF_MASK(NV_RAMHT_STATUS);

            if ((valid == NV_RAMHT_STATUS_VALID) && (chid == pFifoHashSearchArg->chid))
            {
                pFifoHashSearchArg->result = context;
                break;
            }
        }
    }

    return (RM_OK);    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\gr\nv\gr.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GR.C                                                              *
*   The graphics engine is managed in this module.  All priviledged state   *
*   relating to the canvas and datapath is managed here.  Context switching *
*   is also contained here.                                                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <gr.h>
#include <os.h>
#include "nvhw.h"
#ifdef WIN32
#include "nvwin32.h"   // XXX this shouldn't be needed
#else
#define NV_OS_WRITE_THEN_AWAKEN	   0x00000001
#endif

//
// Externs.
//
// extern PGRAPHICSCHANNEL grTable;
//
// Globals.
//
// PVBLANKNOTIFY grVBlankList[2];

//---------------------------------------------------------------------------
//
//  Graphics VBlank servicing.
//
//---------------------------------------------------------------------------

RM_STATUS grWaitVBlank
(
    PHWINFO pDev,
    PVBLANKNOTIFY VBlankNotify,
    U032          buffer
)
{   
    //
    // Check for in-use.
    //
    if (VBlankNotify->Next)
        return (RM_ERR_NOTIFY_IN_USE);
    //
    // Stick this object on the appropriate queue waiting for the next VBlank
    //
    VBlankNotify->Next   = pDev->DBgrVBlankList[buffer];
    pDev->DBgrVBlankList[buffer] = VBlankNotify;
    return (RM_OK);
}
RM_STATUS grVBlank
(
    PHWINFO pDev
)
{
    PVBLANKNOTIFY VBlankNotify;
    PVBLANKNOTIFY VBlankNext;

    //
    // Pull all notifies annd complete them.
    //
    VBlankNotify = pDev->DBgrVBlankList[pDev->Framebuffer.FlipFrom];
    while (VBlankNotify)
    {
        VBlankNext         = VBlankNotify->Next;
        VBlankNotify->Next = NULL;
        VBlankNotify->Proc(pDev, VBlankNotify->Object,
                           VBlankNotify->Param1,
                           VBlankNotify->Param2,
                           RM_OK);
        VBlankNotify = VBlankNext;
    }
    pDev->DBgrVBlankList[pDev->Framebuffer.FlipFrom] = NULL;
    pDev->Framebuffer.FinishFlags = 0;
    return (RM_OK);
}
RM_STATUS grCancelVBlank
(
    PHWINFO pDev,
    PVBLANKNOTIFY VBlankNotify
)
{
    U032          i;
    PVBLANKNOTIFY VBlankMatch;

    for (i = 0; i < 2; i++)
    {
        if (VBlankNotify == pDev->DBgrVBlankList[i])
        {
            pDev->DBgrVBlankList[i] = VBlankNotify->Next;
            VBlankNotify->Next = NULL;
            return (RM_OK);
        }
        else
        {
            VBlankMatch = pDev->DBgrVBlankList[i];
            while (VBlankMatch && VBlankMatch->Next != VBlankNotify)
                VBlankMatch = VBlankMatch->Next;
            if (VBlankMatch)
            {
                VBlankMatch->Next  = VBlankNotify->Next;
                VBlankNotify->Next = NULL;
                return (RM_OK);
            }
        }
    }
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Helper functions.
//
//---------------------------------------------------------------------------

static RM_STATUS grGetLastIllegalMthdObject
(
    PHWINFO pDev,
    U032    ChID,
    U032    Instance,
    POBJECT *cachedObject
)
{
    POBJECT lastObject = pDev->DBfifoTable[ChID].LastIllegalMthdObject;

    *cachedObject = (POBJECT)NULL;
    if (lastObject != (POBJECT)NULL)
    {
        if (ENGDECL_FIELD(*lastObject->Class->EngineDecl, _TAG) == GR_ENGINE_TAG)
        {
            if ((((PCOMMONOBJECT)(lastObject))->Instance & 0xFFFF) == (Instance & 0xFFFF))
            {
                // found it.
                *cachedObject = lastObject;
                return RM_OK;
            }
        }
    }

    // did not find a match.
    return RM_ERR_BAD_OBJECT; 
}

static VOID grSetLastIllegalMthdObject
(
    PHWINFO pDev,
    U032    ChID,
    POBJECT Object
)
{
    pDev->DBfifoTable[ChID].LastIllegalMthdObject = Object;
}
//---------------------------------------------------------------------------
//
//  Graphics engine service.
//
//---------------------------------------------------------------------------

#define BENSWORK

V032 grService
(
    PHWINFO pDev
)
{
    RM_STATUS   status = RM_OK;
    POBJECT     Object = NULL;
    POBJECT     Object2 = NULL;
    PDMAOBJECT  DmaObject;
    V032        Intr;
    U032        Instance, NotifyInstance;
    U032        ChID;
    U032        Class;
    U032        Offset;
    U032        Data;
    U032        NotifySource;
    GREXCEPTIONDATA ExceptionData;
#ifdef BENSWORK
    U032      isDebuggerPresent;
    U032      mustNotifyDebugger;

    isDebuggerPresent  = ((PRMINFO)pDev->pRmInfo)->Debugger.object != NULL;
    mustNotifyDebugger = 0;
#endif

    //
    // Disable FIFO from writing to GE and wait for GE idle.
    //
    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);

    //
    // Waiting for everything in the graphics engine to go idle is too restrictive.  Some
    // exceptions are raised while the offending function has stalled part of the engine,
    // therefore making it impossible to wait for idle.
    //
    // Only wait for idle in the specific interrupt handlers.
    //
    //GR_DONE();

    Intr = REG_RD32(NV_PGRAPH_INTR);

    if (Intr == 0)
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics empty interrupt!!\n\r");
    
    //
    // Query HAL for exception data.
    // any engine-based exceptions.
    //
    nvHalGrGetExceptionData(pDev, &ExceptionData);

    //
    // Here's where we'd bypass HAL gr exception handling if needed.
    // 

    //
    // Give HAL chance to service selected exceptions.
    //
    nvHalGrService(pDev, Intr, &ExceptionData);

    //
    // Refresh interrupt status since HAL may have resolved
    // some (or all) pending conditions.
    //
    if ((Intr = REG_RD32(NV_PGRAPH_INTR)) == 0)
    {
        //
        // Reset FIFO.
        //
        REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
        return (Intr);
    }

    //
    // Decode exception data.
    //
    Class = ExceptionData.classNum;
    NotifyInstance = ExceptionData.NotifyInstance;
    Instance = ExceptionData.Instance;
    Offset = ExceptionData.Offset;
    Data = ExceptionData.Data;
    ChID = ExceptionData.ChID;
    NotifySource = ExceptionData.Nsource;
    
    //
    // Reset interrupt registers before servicing them.
    //
    REG_WR32(NV_PGRAPH_INTR, Intr);

    //
    // If that was the only reason we're in here, let's leave now.  Most of the object
    // status updates that follow aren't valid when we just context switching.
    //
    if ((Intr == DRF_DEF(_PGRAPH, _INTR, _CONTEXT_SWITCH, _PENDING)) || 
        (Intr == DRF_DEF(_PGRAPH, _INTR, _SINGLE_STEP, _PENDING)))
    {    
        //
        // Reset FIFO.
        //
        REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
        return (REG_RD32(NV_PGRAPH_INTR));
    }
    
    //
    // The rest of the exceptions require that we know what object we're currently using.
    // Convert the object instance into the actual object pointer so we can route everything
    // appropriately.
    // 
    if (!Instance)
    {    
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics object instance is zero!!\n\r");
    }            
    else        
    {        
        status = grGetLastIllegalMthdObject(pDev, ChID, Instance, &Object);
        if (status != RM_OK)
        {
            status = grContextInstanceToObject(pDev, ChID, Instance, &Object);
            if (status)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics exception with NO valid object\n\r");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Status:", status);
            }
        }
        //
        // Let's take this opportunity to update this object's notify information (ctx and request).
        // This is important information if we (the resmgr) need to perform the notification that
        // wasn't completed by the hardware due to this error condition.
        //
        // We need to convert the instance into a dma object, then plug the dma object
        // into this graphics object.  Also see if a notify is currently pending.
        //
        if (Object && NotifyInstance)
        {        
            status = dmaContextInstanceToObject(pDev, ChID, NotifyInstance, &DmaObject);
            if (status)
                Object->NotifyXlate = NULL;
            else
                Object->NotifyXlate = DmaObject;            
        }                

        //
        // Is there a notify pending in the hardware?
        //
        if ((NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _NOTIFICATION, _PENDING)) && Object)
        {
            GRNOTIFYDATA grNotifyData;

            nvHalGrGetNotifyData(pDev, &grNotifyData);
            if (grNotifyData.trigger == TRUE)
            {
                Object->NotifyTrigger = TRUE;
                Object->NotifyAction = grNotifyData.action;
                if (Object->NotifyXlate == NULL)
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Pending notification with NO valid notifier\n\r");
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Object:", Object->Name);
                } else
                    status = notifyMethodComplete(pDev, Object, Offset, Data, RM_OK);

                // we've handled the notify here, so clear the PENDING bit
                NotifySource &= ~DRF_DEF(_PGRAPH, _NSOURCE, _NOTIFICATION, _PENDING);                
            }
        }
    }
    
    //
    // Missing hardware?  Must be a software method.  Route accordingly.
    //
    if ((Intr & DRF_DEF(_PGRAPH, _INTR, _MISSING_HW, _PENDING)) && Object)
    {
    
        //
        // Wait for idle
        //
        GR_DONE();
    
        //
        // Check per-class valid method.
        //
        status = classSoftwareMethod(pDev, Object, Offset, Data);
        if (status)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics software method.\n\r");
            if (Object)
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software Object:  ", Object->Name);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software ChID:    ", ChID);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software Class:   ", Class);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software Offset:  ", Offset);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software Data:    ", Data);
        }
    }

    //
    // Software assisted notification?
    //
    // Note: only NV10 has a PGRAPH_INTR_ERROR_PENDING bit which also flags
    // illegal method exceptions, but it should be safe to check this on NV4
    // since this'll read back as 0.
    //
    if (((Intr & DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _PENDING)) ||
        (Intr & DRF_DEF(_PGRAPH, _INTR, _ERROR, _PENDING))) && Object)
    {
        //
        // Notification.
        //
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Graphics exception handler.\n\r");
        
        // KJK!! Missing hardware as a protection fault!!
        //
        // Check per-class valid method.
        //
        if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _ILLEGAL_MTHD, _PENDING))
        {        
        
            //
            // Wait for idle
            //
            GR_DONE();
        
            //
            // Convert the incoming data into the object id so the method can handle it.  Remember
            // that the FIFO has done a hash on the incoming data and passed the actual instance
            // pointer to the graphics engine.  Since we need to process based on the original data,
            // we need to convert it back to the original user data.
            //
            if (Offset < 0x200)
            {
                if (!Data)
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics object context data is zero!!\n\r");
                status = grContextInstanceToObject(pDev, ChID, Data, &Object2);
                if (status)
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics exception with NO valid context\n\r");
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Status:", status);
                }
                if (status == RM_OK && Object2 != NULL)    
                {
                    Data = Object2->Name;
                }
            }                
        
            // Cache this object as the lastIllegalMthdObject.
            grSetLastIllegalMthdObject(pDev, ChID, Object);
            status = classSoftwareMethod(pDev, Object, Offset, Data);
            if (status)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics software method error!\n\r");
                if (Object)
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software Object:  ", Object->Name);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software ChID:    ", ChID);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software Class:   ", Class);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software Offset:  ", Offset);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software Data:    ", Data);

#ifdef BENSWORK // case 1
                // external debugger registered?
                if (isDebuggerPresent)
                {
                    NvdeAppendEventForDebugger ((PNVDEOBJECT)((PRMINFO)pDev->pRmInfo)->Debugger.object,1,3,Object ? Object->Name : ~0,ChID,Class,Offset,Data,0);
                    mustNotifyDebugger = 1;
                }
#endif
            }
        }
        else if (NotifySource)
        {
            // 
            // Determine the notification type.  The hardware will only track the cause, not the
            // type of notification the client has requested.  What is actually be done with this
            // notify (action) is determined by per-object data.
            // 
            //Object->NotifyAction = REG_RD_DRF(_PGRAPH, _NOTIFY, _TYPE);
            
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _NOTIFICATION, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics software notification pending!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _DATA_ERROR, _PENDING))
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics invalid data error!\n\r");
            }
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _PROTECTION_ERROR, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics surface protection error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _RANGE_EXCEPTION, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics range exception error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _LIMIT_COLOR, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics color buffer limit error!\n\r");
            //if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _LIMIT_ZETA, _PENDING))
            //    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics zeta buffer limit error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _DMA_R_PROTECTION, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics dma read protection error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _DMA_W_PROTECTION, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics dma write protection error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _FORMAT_EXCEPTION, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics format exception error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _PATCH_EXCEPTION, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics patch exception error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _STATE_INVALID, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics object state invalid error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _DOUBLE_NOTIFY, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics double notify error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _NOTIFY_IN_USE, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics notify in use error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _METHOD_CNT, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics method count error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _BFR_NOTIFICATION, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics buffer notification error!\n\r");
            
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:          ERROR:   ", NotifySource);
            if (Object)
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:         Object:   ", Object->Name);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:           ChID:   ", ChID);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:          Class:   ", Class);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:         Offset:   ", Offset);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:           Data:   ", Data);
            DBG_BREAKPOINT();
#ifdef BENSWORK // case 2
            // external debugger registered?
            if (isDebuggerPresent)
            {
                NvdeAppendEventForDebugger ((PNVDEOBJECT)((PRMINFO)pDev->pRmInfo)->Debugger.object,2,3,0,0,0,0,0,0);
                mustNotifyDebugger = 1;
            }
            else
            {
                DBG_BREAKPOINT();
            }
#else
            DBG_BREAKPOINT();
#endif
            status = notifyMethodComplete(pDev, Object, Offset, Data, RM_OK);
        }            
    }
    
    //
    // Software assisted buffer notification?
    //    
    if ((Intr & DRF_DEF(_PGRAPH, _INTR, _BUFFER_NOTIFY, _PENDING)) && Object)
    {
    
        //
        // Wait for idle
        //
        GR_DONE();
    
        //
        // Notification.
        //
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Graphics buffer software notification\n\r");
        Object->NotifyTrigger = TRUE;
        // 
        // Determine the notification type.  The hardware will only track the cause, not the
        // type of notification the client has requested.  What is actually be done with this
        // notify (action) is determined by per-object data.
        // 
        //Object->NotifyAction = REG_RD_DRF(_PGRAPH, _NOTIFY, _TYPE);
        //
        // If the notify status is zero (no error), then this must have occurred due to
        // a WRITE_THEN_AWAKEN request
        //
        //if (!REG_RD32(NV_PGRAPH_NSTATUS))
            Object->NotifyAction = NV_OS_WRITE_THEN_AWAKEN;
        status = notifyBufferHWComplete(pDev, Object, Offset, Data, 1, RM_OK);
    }

#ifdef BENSWORK // case 3
    // external debugger registered?
    if (isDebuggerPresent)
    {
        // check for DMA faults on channel A & B
        if ((Intr & DRF_DEF(_PGRAPH, _INTR, _TLB_PRESENT_A, _PENDING))
         || (Intr & DRF_DEF(_PGRAPH, _INTR, _TLB_PRESENT_B, _PENDING)))
        {
            NvdeAppendEventForDebugger ((PNVDEOBJECT)((PRMINFO)pDev->pRmInfo)->Debugger.object,3,3,0,0,0,0,0,0);
            mustNotifyDebugger = 1;
        }
    }
#endif
#ifdef DEBUG
    //
    // DMA Fault on channel A?
    //
    if (Intr & DRF_DEF(_PGRAPH, _INTR, _TLB_PRESENT_A, _PENDING))
    {
    
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics DMA TLB not present or valid (A)\n\r");
    
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_CONTROL    = ", REG_RD32(NV_PGRAPH_DMA_A_CONTROL));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_LIMIT      = ", REG_RD32(NV_PGRAPH_DMA_A_LIMIT));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_TLB_PTE    = ", REG_RD32(NV_PGRAPH_DMA_A_TLB_PTE));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_TLB_TAG    = ", REG_RD32(NV_PGRAPH_DMA_A_TLB_TAG));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_ADJ_OFFSET = ", REG_RD32(NV_PGRAPH_DMA_A_ADJ_OFFSET));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_OFFSET     = ", REG_RD32(NV_PGRAPH_DMA_A_OFFSET));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_SIZE       = ", REG_RD32(NV_PGRAPH_DMA_A_SIZE));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_Y_SIZE     = ", REG_RD32(NV_PGRAPH_DMA_A_Y_SIZE));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_INSTANCE   = ", REG_RD32(NV_PGRAPH_DMA_A_XLATE_INST));
    }

    //
    // DMA Fault on channel B?
    //
    if (Intr & DRF_DEF(_PGRAPH, _INTR, _TLB_PRESENT_B, _PENDING))
    {
    
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics DMA TLB not present or valid (B)\n\r");
    
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_CONTROL    = ", REG_RD32(NV_PGRAPH_DMA_B_CONTROL));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_LIMIT      = ", REG_RD32(NV_PGRAPH_DMA_B_LIMIT));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_TLB_PTE    = ", REG_RD32(NV_PGRAPH_DMA_B_TLB_PTE));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_TLB_TAG    = ", REG_RD32(NV_PGRAPH_DMA_B_TLB_TAG));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_ADJ_OFFSET = ", REG_RD32(NV_PGRAPH_DMA_B_ADJ_OFFSET));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_OFFSET     = ", REG_RD32(NV_PGRAPH_DMA_B_OFFSET));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_SIZE       = ", REG_RD32(NV_PGRAPH_DMA_B_SIZE));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_Y_SIZE     = ", REG_RD32(NV_PGRAPH_DMA_B_Y_SIZE));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_INSTANCE   = ", REG_RD32(NV_PGRAPH_DMA_B_XLATE_INST));
    }
    
    if (REG_RD32(NV_PGRAPH_INTR) != 0)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics interrupt not completely serviced = ", REG_RD32(NV_PGRAPH_INTR));
    }
#endif // DEBUG

    //
    // Reset FIFO.
    //
#ifdef BENSWORK
    if (mustNotifyDebugger)
    {
        osNotifyEvent(pDev, ((PRMINFO)pDev->pRmInfo)->Debugger.object, 0, 0, 0, RM_OK, NV_OS_WRITE_THEN_AWAKEN);
    }
    else
    {
#endif
    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
#ifdef BENSWORK
    }
#endif

    return (REG_RD32(NV_PGRAPH_INTR));
}

//
//  Search for the object matching a given context instance.
//
RM_STATUS grContextInstanceToObject
(
    PHWINFO  pDev,
    U032     ChID,
    U032     Instance,
    POBJECT *GrObject
)
{
    PNODE node;
    U032  engineTag;
    
    *GrObject = NULL;
    
    //
    // Do this brute force.  Search the whole fifo tree for the object.
    // 
    // Go find the minimum value (>0) and start there.  That way we're
    // sure to visit every node.
    //
    btreeEnumStart(0, &node, pDev->DBfifoTable[ChID].ObjectTree);

    while (node != NULL)
    {
        //
        // Get engine tag associated with this object (see nvhal.h for
        // list of valid tags).
        //
        engineTag = ENGDECL_FIELD(*(((POBJECT)(node->Data))->Class)->EngineDecl, _TAG);

        //
        // We only want graphics/software objects, so prune out
        // everything else.
        //
        if (engineTag != CLASS_PSEUDO_ENGINE_TAG && engineTag != NO_ENGINE)
        {
            //
            // Verify the instance
            //
            if ((((PCOMMONOBJECT)(node->Data))->Instance & 0xFFFF) == (Instance & 0xFFFF))
            {
                // FOUND IT!!
                *GrObject = (POBJECT)(node->Data);
                return (RM_OK);
            }
        }

        btreeEnumNext(&node, pDev->DBfifoTable[ChID].ObjectTree);
    }
    
    return (RM_ERR_BAD_OBJECT);
}

//
// Delete the graphics context instance for a given object
//
RM_STATUS grDeleteObjectInstance
(
    PHWINFO       pDev,
    PCOMMONOBJECT Object
)
{
    RM_STATUS status = RM_OK;

    //
    // Free the instance
    //
    if (Object->Instance) {
        status = fbFreeInstMem(pDev, Object->Instance, 1);    // one paragraph
        if (status)
            return(status);

        //
        // Zero the fields, just in case
        //
        INST_WR32(Object->Instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0), 0);
        INST_WR32(Object->Instance, SF_OFFSET(NV_PRAMIN_CONTEXT_1), 0);
        INST_WR32(Object->Instance, SF_OFFSET(NV_PRAMIN_CONTEXT_2), 0);
        
        Object->Instance = 0;
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\gr\nv\grval.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRVAL.C                                                           *
*   The graphics engine is managed in this module.  Graphics patches are    *
*   validated here.                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <dac.h>
#include <gr.h>
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
//
// Externs.
//
// extern PGRAPHICSCHANNEL grTable;

//---------------------------------------------------------------------------
//
//  Validate graphics patchcords.
//
//---------------------------------------------------------------------------

RM_STATUS grValidateVideoPatchcord
(
    // PHWINFO pDev,
    PVIDEOPATCHCORD   VideoPatchcord,
    PPATCHCONTEXT     PatchContext,
    U032              DestCount
)
{
    PVIDEOOBJECT VideoObject = (void *) 0;
    U032         i;
    
    //
    // Initialize context configuration.
    //
    PatchContext->VideoConfig  = BOTH_BUFFERS;
    PatchContext->ColorMap0    = NULL;
    PatchContext->ColorMap1    = NULL;
    PatchContext->VideoScaler  = NULL;
    PatchContext->VideoColorKey = NULL;

    //
    // Find output of patchcord.
    //
    if (VideoPatchcord && VideoPatchcord->FanOut)
    {
        //
        // Search for the first destination
        //
        DBG_VAL_PTR(VideoPatchcord);
        for (i = 0; (i < MAX_GRPATCH_FANOUT) && DestCount; i++)
        {
            if ((VideoObject = VideoPatchcord->Destination[i]))
            {
                DBG_VAL_PTR(VideoPatchcord->Destination[i]);
                DestCount--;
            }
        }
#if DEBUG
        if (DestCount)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid patchcord in VidPatchValidation!\n\r");
            DBG_BREAKPOINT();
            return (RM_ERROR);
        }
#endif // DEBUG
    }
    else
        return (RM_ERR_INCOMPLETE_PATCH);
    //
    // Accumulate video patch configuration.
    //
    while ( VideoObject && (VideoObject->Base.Class->Type != NV_VIDEO_SINK))
    {
        DBG_VAL_PTR(VideoObject);
        /* KJK
        if (VideoObject->Base.Class->Type == NV_VIDEO_SWITCH)
        {
            //
            // Check which buffers to read/write to.
            //
            if (PatchContext->VideoConfig != BOTH_BUFFERS)
                return (RM_ERR_INVALID_PATCH);
            //
            // Ordinal.
            //
            if (((PVIDEOSWITCHOBJECT)VideoObject)->Ordinal)
                PatchContext->VideoSwitch = (PVIDEOSWITCHOBJECT)VideoObject;
            else    
                return (RM_ERR_INCOMPLETE_PATCH);
            //
            // Initialize the buffer toggle for this patch if it hasn't
            //  already been done.
            //
            if (PatchContext->Canvas->BufferToggle == INVALID_BUFFER)
            {
                if (pDev->Framebuffer.ActiveCount == 1)
                    //
                    // If this is the only double buffered application, then buffer
                    // toggle is always 0 because the toggle does not actually
                    // toggle for single double bufferd clients.
                    //
                    PatchContext->Canvas->BufferToggle = 0;
                else
                    //
                    // When multiple double buffered sessions are active set it to be
                    // whatever the current buffer is.
                    //
                    PatchContext->Canvas->BufferToggle = pDev->Framebuffer.Current;
            }
            PatchContext->VideoConfig = 0;
            if (PatchContext->ColorMap0)
            {
                //
                // Video switch occurs after the colormap.
                //
                if (VideoObject->VideoInput[0] == PatchContext->ColorMap0->VideoOutput)
                    PatchContext->VideoConfig = 1;
                if (VideoObject->VideoInput[1] == PatchContext->ColorMap1->VideoOutput)
                    PatchContext->VideoConfig += 2;
            }
            else
            {
                //
                // Video switch occurs after imagevideo.
                //
                if (VideoObject->VideoInput[0] == ((PIMAGEVIDEOOBJECT)PatchContext->ImageObject)->VideoOutput)
                    PatchContext->VideoConfig = 1;
                if (VideoObject->VideoInput[1] == ((PIMAGEVIDEOOBJECT)PatchContext->ImageObject)->VideoOutput)
                    PatchContext->VideoConfig += 2;
            }
            if (PatchContext->VideoConfig == 1)
                PatchContext->ColorMap1 = NULL;
            else if (PatchContext->VideoConfig == 2)
                PatchContext->ColorMap0 = NULL;
            if (!VideoObject->VideoOutput)
                return (RM_ERR_INCOMPLETE_PATCH);
            //VideoObject = VideoObject->VideoOutput->Destination;
        }
        else*/
        if (VideoObject->Base.Class->Type == NV_VIDEO_COLORMAP)
        {
            //
            // Add the color map to the patch configuration.
            //
            PatchContext->ColorMap0 = (PVIDEOCOLORMAPOBJECT)VideoObject;
            PatchContext->ColorMap1 = (PVIDEOCOLORMAPOBJECT)VideoObject;
            if (!VideoObject->VideoOutput)
                return (RM_ERR_INCOMPLETE_PATCH);
            //VideoObject = VideoObject->VideoOutput->Destination;
        }
        else if (VideoObject->Base.Class->Type == NV_VIDEO_SCALER)
        {
            //
            // Add the scaler to the patch configuration.
            //
            PatchContext->VideoScaler = (PVIDEOSCALEROBJECT)VideoObject;
            if (!VideoObject->VideoOutput)
                return (RM_ERR_INCOMPLETE_PATCH);
        }
        else if (VideoObject->Base.Class->Type == NV_VIDEO_COLOR_KEY)
        {
            //
            // Add the color key to the patch configuration.
            //
            PatchContext->VideoColorKey = (PVIDEOCOLORKEYOBJECT)VideoObject;
            if (!VideoObject->VideoOutput)
                return (RM_ERR_INCOMPLETE_PATCH);
        }
        else
            return (RM_ERR_INVALID_PATCH);

        //
        // Follow patchcord to next video object.
        //
        VideoPatchcord = VideoObject->VideoOutput;
        if (VideoPatchcord && VideoPatchcord->FanOut)
        {
            DBG_VAL_PTR(VideoPatchcord);
            if (VideoPatchcord->FanOut > 1)
                return (RM_ERR_PATCH_TOO_COMPLEX);
            //
            // Search for the first destination.
            //    
            for (i = 0; !(VideoObject = VideoPatchcord->Destination[i]); i++)
			    ;
#if DEBUG
            if (!VideoObject)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid patchcord in VideoPatchcordValidation!\n\r");
                DBG_BREAKPOINT();
                return (RM_ERROR);
            }
#endif // DEBUG
        }
        else
            return (RM_ERR_INCOMPLETE_PATCH);

    }
    return (VideoObject ? RM_OK : RM_ERR_INCOMPLETE_PATCH);
}


//---------------------------------------------------------------------------
//
//  Invalidate graphics patchcords.
//
//---------------------------------------------------------------------------

RM_STATUS grInvalidateVideoPatchcord
(
    PVIDEOPATCHCORD VideoPatchcord
)
{
    U032            i;
    
    //
    // Find input of patchcord.
    //
    if (!VideoPatchcord || !VideoPatchcord->Source)
        return (RM_OK);
    DBG_VAL_PTR(VideoPatchcord);
    DBG_VAL_PTR(VideoPatchcord->Source);
    switch (VideoPatchcord->Source->Base.Class->Type)
    {
        case NV_VIDEO_COLORMAP:
            grInvalidateVideoPatchcord(((PVIDEOCOLORMAPOBJECT)VideoPatchcord->Source)->VideoInput);
            break;
        case NV_VIDEO_SINK:
            for (i = 0; i < MAX_GRPATCH_INPUT; i++)
                grInvalidateVideoPatchcord(((PVIDEOSINKOBJECT)VideoPatchcord->Source)->VideoInput[i]);
            break;
#ifdef DEBUG
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Invalid object type for InvalidateVideoPatchcord.\n\r");
            DBG_BREAKPOINT();
#endif
    }
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Validate object context.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\gr\nv\grobj.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GROBJ.C                                                           *
*   The graphics engine is managed in this module.  Graphics objects are    *
*   created and deleted here.  Graphics object methods are implemented      *
*   also contained here.                                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <btree.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <dac.h>
#include <gr.h>
#include <modular.h>   
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
//
// Degubbing macros.
//
#ifdef DEBUG
#define VALIDATE_GROBJ(go)  \
if (((POBJECT)go)->Name < 4096) \
{                           \
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid graphics object name!\n\r"); \
    DBG_BREAKPOINT();       \
}
#else
#define VALIDATE_GROBJ(go)
#endif //  DEBUG
//
// Externs.
//
// extern PGRAPHICSCHANNEL grTable;
//
// The canvas tree.
//
// PNODE grCanvasTree;

//
// Class lock macros.
//

#define GRCLASSLOCK_ISSET(pdev,chid,bit)    (((U032 *)(pDev->Graphics.ClassLocks))[chid] & (1 << bit))
#define GRCLASSLOCK_SET(pdev,chid,bit)      (((U032 *)(pDev->Graphics.ClassLocks))[chid] |= (1 << bit))
#define GRCLASSLOCK_CLEAR(pdev,chid,bit)    (((U032 *)(pDev->Graphics.ClassLocks))[chid] &= ~(1 << bit))

//---------------------------------------------------------------------------
//
//  Create/Delete graphics objects.
//
//---------------------------------------------------------------------------

//
// Ordinal to video switch.
//
RM_STATUS grCreateOrdinal
(
    PHWINFO      pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *GrObject
)
{
    RM_STATUS status;
    U032      i;
    
    status = osAllocMem((VOID **)GrObject, sizeof(ORDINALOBJECT));
    if (status)
        return (status);
    ((PORDINALOBJECT)*GrObject)->Value               = 0;
    ((PORDINALOBJECT)*GrObject)->FanOut              = 0;
    for (i = 0; i < MAX_GRPATCH_FANOUT; i++)
        ((PORDINALOBJECT)*GrObject)->Switch[i]       = 0;
    //
    // Increment the number of ordinals (and thus double buffered apps) in
    // the system.
    //
    pDev->Framebuffer.FlipUsageCount &= 0x7FFFFFFF;
    pDev->Framebuffer.FlipUsageCount++;
    return (RM_OK);
}
RM_STATUS grDeleteOrdinal
(
    POBJECT GrObject
)
{
    return osFreeMem(GrObject);
}

//---------------------------------------------------------------------------
//
//  Canvas routines.
//
//---------------------------------------------------------------------------

VOID grInitCommon(
    PCOMMONOBJECT pCommon,
	U032 Device
)
{
    //
    // Load up the default settings for a new common hardware object
    //
    pCommon->Valid         = FALSE;    
    pCommon->NotifyPending = FALSE;
    pCommon->Instance      = 0;
    pCommon->NotifyObject  = NULL;
    pCommon->Dma0Object    = NULL;
    pCommon->Dma1Object    = NULL;
    pCommon->Next          = NULL;
}

VOID grInitRenderCommon(
    PRENDERCOMMON pRenderCommon
)
{
    //
    // Load up the default settings for a new common render object
    //
    pRenderCommon->Xlate        = NULL;

    //
    // Default out the full patch context
    //
    pRenderCommon->PatchContext.ColorKey    = NULL;
    pRenderCommon->PatchContext.Pattern     = NULL;
    pRenderCommon->PatchContext.Clip        = NULL;
    pRenderCommon->PatchContext.Rop         = NULL;
    pRenderCommon->PatchContext.Beta1       = NULL;
    pRenderCommon->PatchContext.Beta4       = NULL;
    pRenderCommon->PatchContext.Surface     = NULL;
    pRenderCommon->PatchContext.SurfaceSource = NULL;
    pRenderCommon->PatchContext.Operation   = NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_SRCCOPY_AND;
    
}

//
// grIsRenderObject
//
// This routine returns TRUE if the given class is a rendering
// object, FALSE otherwise.
//
static BOOL
grIsRenderObject(U032 class)
{
    switch (class)
    {
        case NV1_BETA_SOLID:
        case NV1_IMAGE_SOLID:
        case NV1_IMAGE_PATTERN:
        case NV1_IMAGE_BLACK_RECTANGLE:
        case NV3_CONTEXT_ROP:
        case NV3_CONTEXT_SURFACE_0:
        case NV3_CONTEXT_SURFACE_1:
        case NV3_CONTEXT_SURFACE_2:
        case NV3_CONTEXT_SURFACE_3:
        case NV4_CONTEXT_SURFACES_2D:
        case NV4_CONTEXT_PATTERN:
        case NV4_CONTEXT_SURFACE_SWIZZLED:
        case NV4_CONTEXT_SURFACES_ARGB_ZS:
        case NV4_CONTEXT_BETA:
        case NV10_CONTEXT_SURFACES_2D:
        case NV10_CONTEXT_SURFACES_3D:
            return FALSE;
        //default:
            // default action is to fall thru
    }
    return TRUE;
}

//
// grCreateObj
//
// Generic graphics engine object creation routine.
//
RM_STATUS
grCreateObj(VOID* pDevHandle, PCLASSOBJECT ClassObject, U032 Name, POBJECT *Object, VOID* pCreateParms)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;
    RM_STATUS status = RM_OK;
    PCOMMONOBJECT pCommonObject;
    PCLASS pClass = ClassObject->Base.ThisClass;
    U032 lockBit;
    U032 instSize, instAlign, size;
    BOOL isRenderObj;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: grCreateObj class ", pClass->Type);

    //
    // Check per-channel allocation restrictions if applicable.
    //
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK) {
        if (GRCLASSLOCK_ISSET(pDev, ClassObject->Base.ChID, lockBit))
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: class already exists in channel ", ClassObject->Base.ChID);
            return (RM_ERR_ILLEGAL_OBJECT);
        }
        GRCLASSLOCK_SET(pDev, ClassObject->Base.ChID, lockBit);
    }

    //
    // Determine if this class is a rendering class (and therefore
    // represented by a RENDERCOMMONOBJECT structure).
    //
    isRenderObj = grIsRenderObject(pClass->Type);

    //
    // Allocate space for object.
    //
    size = (isRenderObj) ? sizeof (RENDERCOMMONOBJECT) : sizeof (COMMONOBJECT);
    status = osAllocMem((VOID **)Object, size);
    if (status)
    {
        GRCLASSLOCK_CLEAR(pDev, ClassObject->Base.ChID, lockBit);
        return (status);
    }

    //
    // A nice cast to make the code more readable.
    //
    pCommonObject = (PCOMMONOBJECT)*Object;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    //
    // Init render object data.
    //
    if (isRenderObj)
        grInitRenderCommon(&((PRENDERCOMMONOBJECT)pCommonObject)->RenderCommon);

    //
    // Allocate instance memory.  The amount allocated is based
    // on two values:  the default size from the engine declaration
    // entry plus any additional space that might be specified via
    // the class instance memory alloc entry.
    //
    // Note that graphics objects currently only use the default, but
    // on NV20 the Kelvin class is going to require more than a
    // single paragraph of instance memory.
    //
    // Also factor in any alignment requirements if necessary.
    //
    instSize = ENGDECL_FIELD(*pClass->EngineDecl, _OBJINSTSZ);
    instAlign = 0;
    if (pClass->ClassInstMalloc) {
        instSize += CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _SIZE);
        instAlign = CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _ALIGN);
    }

    if (instAlign)
        status = fbAllocInstMemAlign(pDev, &(pCommonObject->Instance), instSize, instAlign);
    else
        status = fbAllocInstMem(pDev, &(pCommonObject->Instance), instSize);

    if (status)
    {
        if (lockBit != NO_LOCK)
            GRCLASSLOCK_CLEAR(pDev, ClassObject->Base.ChID, lockBit);
        osFreeMem(*Object);
        return (status);
    }

    //
    // Let the HAL setup instance memory for the object.
    //
    status = nvHalGrAlloc(pDev, pCommonObject->Base.ChID, pCommonObject->Instance, pClass->Type);
    if (status == RM_OK)
    {
        //
        // Override any HAL initialization here.
        //

        //
        // Build a FIFO/Hash context for this object
        //
        status = fifoUpdateObjectInstance(pDev,
                                          &pCommonObject->Base, 
                                          pCommonObject->Base.ChID, 
                                          pCommonObject->Instance);
    }

    if (status != RM_OK)
    {
        fbFreeInstMem(pDev, pCommonObject->Instance, instSize);
        osFreeMem(*Object);
        GRCLASSLOCK_CLEAR(pDev, ClassObject->Base.ChID, lockBit);
        return (status);
    }
    
    //
    // Object allocation is a possible power mgmt trigger.  Let's go check.
    //
    status = mcPowerStateTrigger(pDev);     // no error recover required

    return (RM_OK);
}

RM_STATUS
grDestroyObj(VOID* pDevHandle, POBJECT Object)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;
    RM_STATUS               status = RM_OK;
    PCOMMONOBJECT           pCommonObject;
    PCLASS                  pClass;
    U032                    lockBit;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: grDestroyObj\r\n");

    //
    // Just in case...
    //
    if (Object == NULL)
        return (RM_OK);

    //
    // A nice cast to make the code more readable.
    //
    pCommonObject = (PCOMMONOBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    pClass = Object->ThisClass;
    nvHalGrFree(pDev, pCommonObject->Base.ChID, pCommonObject->Instance);

    //
    // Invalidate any objects attached to this context
    //
    // !!KJK Only need to do this if we link the contexts to the objects
    //
    // Delete the instance data structure for this object
    //
    status = fbFreeInstMem(pDev, pCommonObject->Instance, ENGDECL_FIELD(*pClass->EngineDecl, _OBJINSTSZ));
    if (status)
        return (status);
        
    pCommonObject->Instance = 0;

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pCommonObject->Base, pCommonObject->Base.ChID); 
    if (status)
        return (status);
  
    //
    // Clear per-channel allocation restrictions if applicable.
    //
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK) {
        //ASSERT(pDev->Graphics.ClassLocks[pCommonObject->Base.ChID] & (1 << lockBit))
        GRCLASSLOCK_CLEAR(pDev, pCommonObject->Base.ChID, lockBit);
    }
      
    //
    // Object deallocation is a possible power mgmt trigger.  Let's go check.
    //
    status = mcPowerStateTrigger(pDev);  // no error recovery required

    //
    // And finally delete the object itself.
    //    
    return (osFreeMem(Object));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\gr\nv10\grcxnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRCTXT.C                                                          *
*   The graphics engine is managed in this module.  Context switching is    *
*   contained here.                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include <heap.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalGrLoadChannelContext_NV10(PHALHWINFO, U032);
RM_STATUS nvHalGrUnloadChannelContext_NV10(PHALHWINFO, U032, PGRAPHICSCHANNEL_NV10);
VOID nvHalGrLoadHW(PHALHWINFO, U032, PGRAPHICSCHANNEL_NV10);
RM_STATUS nvHalGrGetState_NV10(PHALHWINFO, PGREXCEPTIONDATA, U032);
RM_STATUS nvHalGrPutState_NV10(PHALHWINFO, PGREXCEPTIONDATA, U032);
RM_STATUS nvHalGrSetMaterialEmission_NV10(PHALHWINFO, PGREXCEPTIONDATA);

// externs
extern RM_STATUS dmaHalInstanceToHalInfo_NV10(U032, U032, PDMAHALOBJINFO *, PHALHWINFO);

static RM_STATUS grDelay_NV10(PHALHWINFO, U032);

// values for enabling passthrough modes
static U032 Vertex_Passthr_Mode[] = {
    0x10000000,
    0x00000000
};
#define VERTEX_COUNT            (sizeof(Vertex_Passthr_Mode) / sizeof(U032))
static U032 ScaleOffset_Passthr_Mode[] = {
    0x3F800000,
    0x3F800000,
    0x3F800000,
    0x3F800000,
    0x0,
    0x0,
    0x0,
    0x0
};
#define SCALEOFFSET_COUNT       (sizeof(ScaleOffset_Passthr_Mode) / sizeof(U032))

static U032 Fog_Passthr_Mode[2][3] = {
    { 0x0,        0x0,        0x0 },           // passthrough mode values for A01
    { 0x3F800000, 0x3F800000, 0x3F800000 }     // passthrough mode values for >= A02
};
#define FOG_COUNT               (sizeof(Fog_Passthr_Mode[0]) / sizeof(U032))

static U032 Fog_EyeDist_Passthr_Mode[] = {
    0x0,
    0x0,
    0x0
};
#define FOG_EYEDIST_COUNT        (sizeof(Fog_EyeDist_Passthr_Mode) / sizeof(U032))

//
// Second Inverse ModelViewMatrix location in the XF engine needed for HW
// workaround both for RM related context switching and GetState context
// switching (see notes in grLoadChannelContext for details).
// 
#define INV2_MATRIX_OFFSET    0x653C

//
// Load Pipe Context
//
static RM_STATUS
grLoadPipeContext(
    PHALHWINFO pHalHwInfo,
    U032       Base,
    U032      *SaveAddr,
    U032       Count
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 i;

    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, Base);
    for (i = 0; i < Count; i++) {
	  REG_WR32(NV_PGRAPH_PIPE_DATA, SaveAddr[i]);
    }
    return (RM_OK);
}

//
// Unload Pipe Context
//
static RM_STATUS
grUnloadPipeContext(
    PHALHWINFO pHalHwInfo,
    U032       Base,
    U032      *SaveAddr,
    U032       Count
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 i;

    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, Base);
    for (i = 0; i < Count; i++) {
	  SaveAddr[i] = REG_RD32(NV_PGRAPH_PIPE_DATA);
    }
    return (RM_OK);
}

#define Z16_OVR_MASK (DRF_MASK(NV_PGRAPH_SURFACE_Z16_OVERRIDE) <<    \
                      DRF_SHIFT(NV_PGRAPH_SURFACE_Z16_OVERRIDE))

//
// We're in the midst of a context switch loading in a new 3D channel that
// needs a Celsius method resent to workaround a HW problem. We either need
// to resubmit a Vertex Buffer, or a NOP to setup a correct load of the
// Z16_OVERRIDE bit in PGRAPH_SURFACE.
//
//  1) switch to the Celsius subchannel for the new channel
//  2) save off the method in the stage 2 GR fifo
//  3) load the Celsius method in the stage 2 register
//  4) reenable enough of the GR fifo, so this method/data goes through
//  5) wait for the value to show-up, then disable the GR fifo again
//  6) reload the stage 2 register
//  7) switch back to the correct subchannel before the context switch
//
// Note: Eventhough we're checking for NV11_CELSIUS_PRIMITIVE, we'll never
//       match on that value, since the HW can only hold an 8 bit value and
//       a NV11's class number is 16 bits. But, because 0x1196 will look
//       like 0x96 (NV15's value), the class will match and should be ok.
//
static VOID
grResubmitCelsiusMethod(
    PHALHWINFO pHalHwInfo,
    U032       ChID,            // new ChID
    BOOL       resendDmaVtx
)
{
    PGRHALINFO_NV10 pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV10 pGrChan = &pGrHalPvtInfo->grChannels[ChID];    
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 grclass, celsius;
    U032 st2, datalo, datahi, z16_data=0;

    //
    // On the initial load of this channel, we don't have any saved context, so
    // applying one of these workarounds doesn't seem possible. But really, it's
    // unnecessary, since the HW's going to receive the state setting methods
    // anyways.
    //
    if (DRF_VAL(_PGRAPH, _CTX_USER, _CHID, pGrChan->ContextUser) != ChID)
        return;

    // mark this new channel as owning graphics
    REG_WR32(NV_PGRAPH_CTX_USER, pGrChan->ContextUser);

    if (resendDmaVtx) {
        //
        // Determine which is the Celsius subchan and make it current
        //
        for (celsius = 0; celsius < NUM_SUBCHANNELS; celsius++)
        {
            grclass = DRF_VAL(_PGRAPH, _CTX_CACHE1, _GRCLASS, pGrChan->ContextCache1[celsius]);
            if ((grclass == NV10_CELSIUS_PRIMITIVE) ||
                (grclass == NV15_CELSIUS_PRIMITIVE) ||
                (grclass == NV11_CELSIUS_PRIMITIVE))
                    break;
        }
        if (celsius == NUM_SUBCHANNELS)
            return;     // couldn't find the Celsius object loaded

    } else {
        // use the existing subchan (all classes can handle a NOP)
        celsius = REG_RD_DRF(_PGRAPH, _CTX_USER, _SUBCH);
    }

    //
    // Make the Celsius object current by copying the saved subchan
    // state for CTX_CACHE(celsius) into the CTX_SWITCH registers.
    //
    REG_WR32(NV_PGRAPH_CTX_SWITCH1, pGrChan->ContextCache1[celsius]);
    REG_WR32(NV_PGRAPH_CTX_SWITCH2, pGrChan->ContextCache2[celsius]);
    REG_WR32(NV_PGRAPH_CTX_SWITCH3, pGrChan->ContextCache3[celsius]);
    REG_WR32(NV_PGRAPH_CTX_SWITCH4, pGrChan->ContextCache4[celsius]);
    REG_WR32(NV_PGRAPH_CTX_SWITCH5, pGrChan->ContextCache5[celsius]);

    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _SUBCH, celsius);

    // save the stage2 values, which'll be reloaded after the method's been sent
    st2     = REG_RD32(NV_PGRAPH_FFINTFC_ST2);
    datalo  = REG_RD32(NV_PGRAPH_FFINTFC_ST2_DL);
    datahi  = REG_RD32(NV_PGRAPH_FFINTFC_ST2_DH);

    if (resendDmaVtx) {
        // Set an invalid instance address in GLOBALSTATE1
        FLD_WR_DRF_DEF(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_2, _INVALID);

        // Load the method/data into the stage2 register
        REG_WR32(NV_PGRAPH_FFINTFC_ST2,                         NV056_SET_CONTEXT_DMA_VERTEX    |
                 DRF_NUM(_PGRAPH, _FFINTFC_ST2, _SUBCH,         celsius)                        |
                 DRF_NUM(_PGRAPH, _FFINTFC_ST2, _CHID,          ChID)                           |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _DATAHIGH,      _INVALID)                       |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _STATUS,        _VALID)                         |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS,   _VALID)                         |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHSWITCH,      _SET)                           |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _FIFOHOLD,      _SET));

        REG_WR32(NV_PGRAPH_FFINTFC_ST2_DL,
                 DRF_VAL(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_2, pGrChan->CurrentPatch.GlobalState1));
    } else {    // resend Z16 override for NV11
        //        
        // Flip all the bits that are in trapped data currently, mask
        // off the bit we want and or in the bit we want to show up in
        // Z16 override
        //
        z16_data  =  (REG_RD32(NV_PGRAPH_TRAPPED_DATA_LOW) ^ 0xFFFFFFFF);
        z16_data  &= ~Z16_OVR_MASK;
        z16_data  |= (Z16_OVR_MASK & pGrChan->CurrentPatch.Surface);

        // Load the method/data into the stage2 register
        REG_WR32(NV_PGRAPH_FFINTFC_ST2,                         NV1196_NO_OPERATION             |
                 DRF_NUM(_PGRAPH, _FFINTFC_ST2, _SUBCH,         celsius)                        |
                 DRF_NUM(_PGRAPH, _FFINTFC_ST2, _CHID,          ChID)                           |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _DATAHIGH,      _INVALID)                       |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _STATUS,        _VALID)                         |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS,   _VALID)                         |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHSWITCH,      _SET)                           |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _FIFOHOLD,      _SET));

        // Method data is either 0x0 or 0x1, depending on desired value of Z16_OVERRIDE
        REG_WR32(NV_PGRAPH_FFINTFC_ST2_DL, z16_data);
    }

    // Briefly enable PGRAPH_FIFO_ACCESS (and mark the channel valid),
    // so our method can come through
    FLD_WR_DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID, _VALID);
    FLD_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);

    if (resendDmaVtx) {
        // spin until we see our instance address show up in the register
        while (REG_RD_DRF(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_2) !=
               DRF_VAL(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_2, pGrChan->CurrentPatch.GlobalState1))
            ;
    } else {
        // spin until we see the NOP method and data in the trapped registers
        while ((REG_RD_DRF(_PGRAPH, _TRAPPED_ADDR, _MTHD) !=
                DRF_VAL(_PGRAPH, _TRAPPED_ADDR, _MTHD, NV1196_NO_OPERATION)) ||
                (REG_RD32(NV_PGRAPH_TRAPPED_DATA_LOW) != z16_data))
                ;
    }

    // Disable PGRAPH_FIFO_ACCESS again
    FLD_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);

    // Now, restore the stage2 method/data
    REG_WR32(NV_PGRAPH_FFINTFC_ST2,    st2);
    REG_WR32(NV_PGRAPH_FFINTFC_ST2_DL, datalo);
    REG_WR32(NV_PGRAPH_FFINTFC_ST2_DH, datahi);
}

//
// nvHalGrLoadChannelContext
//
RM_STATUS
nvHalGrLoadChannelContext_NV10(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PGRHALINFO_NV10 pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 misc;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrLoadChannelContext_NV10\r\n");

    //
    // Service any outstanding graphics exceptions.
    //
    if (REG_RD32(NV_PGRAPH_INTR))
        HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);
        
    //
    // Save current graphics interface state.
    //
    GR_SAVE_STATE(misc);
    HAL_GR_IDLE(pHalHwInfo);
    
    //
    // Unload current context.
    //   
    if (pGrHalPvtInfo->currentChID != ChID) {
        nvHalGrUnloadChannelContext_NV10(pHalHwInfo,
                                         pGrHalPvtInfo->currentChID,
                                         &pGrHalPvtInfo->grChannels[pGrHalPvtInfo->currentChID]);
    }

    if ((pGrHalPvtInfo->currentChID = ChID) == INVALID_CHID)
    {
        //
        // Set current channel to an invalid one.
        //
        FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, (NUM_FIFOS_NV10 - 1));

        //
        // Update current channel.
        //    
        REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _NOT_EXPIRED)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
        REG_WR_DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS, _VALID);

        //
        // Restore graphics interface state.
        //
		misc |= DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
        GR_RESTORE_STATE(misc); // FIFO reenabled in here

        return (RM_OK);
        //
        // Is the channel ID valid?
        //
    }
    else if (ChID >= NUM_FIFOS_NV10)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid Channel on Graphics Context Switch:", ChID);
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }

    // Reload the HW for the new channel
    nvHalGrLoadHW(pHalHwInfo,
                  ChID,
                  &pGrHalPvtInfo->grChannels[ChID]);

    // Update current channel.
    REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _NOT_EXPIRED)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _VALID)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
                                  
    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, ChID);
    
    //
    // Clear the graphics fifo channel context.  This fixes a subtle hardware bug
    // when thrashing channel changes within the graphics fifo.  Ideally the fifo
    // would hold off pending data while a change is active, but it can actually
    // hold multiple changes.  In order to reduce hw confusion, they added a few
    // state bits within one stage fifo.  Clear those bits on channel changes.
    //
    // Since the bits are write only, they'll read as a zero.
    // Clear those bits on channel changes. Don't rely on these to read as zero
    // eventhough these bits are write only.
    //
    // XXX adding the comments from NV4/NV5 ... actually, we hit this on NV10
    // also (our FIFOHOLD bits were set, so we'll also mask these off on a read)
    // in case this explains the fifo hang we saw.
    //
    // We have to OR in the top bit to fool the Watcom compiler for the Win3.1 version
    // of the resmgr.
    //
    // REG_WR32(NV_PGRAPH_FFINTFC_ST2, REG_RD32(NV_PGRAPH_FFINTFC_ST2) | 0x80000000);
    REG_WR32(NV_PGRAPH_FFINTFC_ST2, REG_RD32(NV_PGRAPH_FFINTFC_ST2) & 0xCFFFFFFF);

    return (RM_OK);
}

U032 reset_delay = 0x0;

VOID
nvHalGrLoadHW(PHALHWINFO pHalHwInfo, U032 ChID, PGRAPHICSCHANNEL_NV10 pGrChan)
{
    PGRHALINFO_NV10 pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 i;

    //
    // Because unloading the previous channel may not have reset GR
    // state, after the unload we'll manually reset the engines. In
    // doing this, we'll also need to restore the GR tiling registers,
    // since they get lost on a reset.
    //
    REG_WR_DRF_DEF(_PGRAPH, _DEBUG_0, _STATE, _RESET);

    // delay for at least 10 nvclks
    if (reset_delay == 0) {
        reset_delay = (1000000000 / pHalHwInfo->pDacHalInfo->NVClk);   // nvclk cycle time, in ns
        reset_delay *= 10;
    }
    grDelay_NV10(pHalHwInfo, reset_delay);
    
    // jump back out of reset
    REG_WR_DRF_DEF(_PGRAPH, _DEBUG_0, _STATE, _NORMAL);

    HAL_GR_IDLE(pHalHwInfo);

    // restore PGRAPH_TILE regs after PGRAPH_DEBUG_0_STATE_RESET
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
    {
        REG_WR32(NV_PGRAPH_TLIMIT(i), REG_RD32(NV_PFB_TLIMIT(i)));
        REG_WR32(NV_PGRAPH_TSIZE(i),  REG_RD32(NV_PFB_TSIZE(i)));
        REG_WR32(NV_PGRAPH_TILE(i),   REG_RD32(NV_PFB_TILE(i)));
    }

    //
    // Apply context switch related workarounds after we've unloaded the
    // previous channels state, but before loading this new channels state.
    //
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0)
    {
        //
        // Eventhough we're about to reload GLOBALSTATE1 which holds the inst addr for
        // the vertex buffers context DMA, neither the channel switch nor the priv write
        // invalidates a shadowed copy kept in the hardware. The only thing that does
        // is a SetContextDmaVertex method, so we'll send that before the priv write.
        //
        if (DRF_VAL(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_2, pGrChan->CurrentPatch.GlobalState1))
        {
            grResubmitCelsiusMethod(pHalHwInfo, ChID, TRUE);
        }

        //
        // With NV11, on a priv write to PGRAPH_SURFACE, the Z16_OVERRIDE bit is taken
        // from the last user method not from the RBI bus. To work around this, we'll
        // send down a NOP with the correct data pattern for the bit (0x0 or 0x1), so
        // the correct thing happens on the priv write to PGRAPH_SURFACE.
        // 
        REG_WR32(NV_PGRAPH_SURFACE, pGrChan->CurrentPatch.Surface);        

        if (REG_RD32(NV_PGRAPH_SURFACE) != pGrChan->CurrentPatch.Surface)
        {
            grResubmitCelsiusMethod(pHalHwInfo, ChID, FALSE);

            // wait for the pipe to go idle 
            HAL_GR_IDLE(pHalHwInfo);

            // rewrite PGRAPH_SURFACE to the correct value (done again below).
            REG_WR32(NV_PGRAPH_SURFACE, pGrChan->CurrentPatch.Surface);        

#ifdef DEBUG
            // make sure we've got the expected NV_PGRAPH_SURFACE value
            if (DRF_VAL(_PGRAPH, _CTX_USER, _CHID, pGrChan->ContextUser) == ChID) {
                if (REG_RD32(NV_PGRAPH_SURFACE) != pGrChan->CurrentPatch.Surface) {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Incorrect Z16 override setting\r\n");
                    DBG_BREAKPOINT();
                }
            }
#endif
        }
    }

    //
    // Reload context state
    //
    REG_WR32(NV_PGRAPH_CTX_SWITCH1, pGrChan->ContextSwitch1);
    REG_WR32(NV_PGRAPH_CTX_SWITCH2, pGrChan->ContextSwitch2);
    REG_WR32(NV_PGRAPH_CTX_SWITCH3, pGrChan->ContextSwitch3);
    REG_WR32(NV_PGRAPH_CTX_SWITCH4, pGrChan->ContextSwitch4);
    REG_WR32(NV_PGRAPH_CTX_SWITCH5, pGrChan->ContextSwitch5);

    for (i = 0; i < 8; i++)
    {    
        REG_WR32(NV_PGRAPH_CTX_CACHE1(i), pGrChan->ContextCache1[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE2(i), pGrChan->ContextCache2[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE3(i), pGrChan->ContextCache3[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE4(i), pGrChan->ContextCache4[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE5(i), pGrChan->ContextCache5[i]);
    }
    
    REG_WR32(NV_PGRAPH_CTX_USER, pGrChan->ContextUser);
    
    //
    // Reload current dma registers
    //
    REG_WR32(NV_PGRAPH_DMA_START_0, pGrChan->DmaStart0);
    REG_WR32(NV_PGRAPH_DMA_START_1, pGrChan->DmaStart1);
    REG_WR32(NV_PGRAPH_DMA_LENGTH,  pGrChan->DmaLength);
    REG_WR32(NV_PGRAPH_DMA_MISC,    pGrChan->DmaMisc);
    REG_WR32(NV_PGRAPH_DMA_PITCH,   pGrChan->DmaPitch);
            
    //
    // Reload current graphics state
    //
    for (i = 0; i < 6; i++)
    {    
        REG_WR32(NV_PGRAPH_BOFFSET(i),  pGrChan->CurrentPatch.BufferOffset[i]);
        REG_WR32(NV_PGRAPH_BBASE(i),    pGrChan->CurrentPatch.BufferBase[i]);
        REG_WR32(NV_PGRAPH_BLIMIT(i),   pGrChan->CurrentPatch.BufferLimit[i]);
    }
    
    for (i = 0; i < 5; i++)
        REG_WR32(NV_PGRAPH_BPITCH(i),   pGrChan->CurrentPatch.BufferPitch[i]);
        
    REG_WR32(NV_PGRAPH_SURFACE,         pGrChan->CurrentPatch.Surface);        
    REG_WR32(NV_PGRAPH_STATE,           pGrChan->CurrentPatch.State);        
    REG_WR32(NV_PGRAPH_BSWIZZLE2,       pGrChan->CurrentPatch.BufferSwizzle[0]);        
    REG_WR32(NV_PGRAPH_BSWIZZLE5,       pGrChan->CurrentPatch.BufferSwizzle[1]);        
    REG_WR32(NV_PGRAPH_BPIXEL,          pGrChan->CurrentPatch.BufferPixel);

    REG_WR32(NV_PGRAPH_NOTIFY,          pGrChan->CurrentPatch.Notify);
    
    REG_WR32(NV_PGRAPH_PATT_COLOR0,     pGrChan->CurrentPatch.PatternColor0);    
    REG_WR32(NV_PGRAPH_PATT_COLOR1,     pGrChan->CurrentPatch.PatternColor1);
    
    // In NV10, we can access the pattern RAM anytime after the engine's been idled
    for (i = 0; i < 64; i++)
        REG_WR32(NV_PGRAPH_PATT_COLORRAM(i), pGrChan->CurrentPatch.PatternColorRam[i]);
        
    REG_WR32(NV_PGRAPH_PATTERN(0),      pGrChan->CurrentPatch.Pattern[0]);
    REG_WR32(NV_PGRAPH_PATTERN(1),      pGrChan->CurrentPatch.Pattern[1]);
    REG_WR32(NV_PGRAPH_PATTERN_SHAPE,   pGrChan->CurrentPatch.PatternShape);
    
    REG_WR32(NV_PGRAPH_MONO_COLOR0,     pGrChan->CurrentPatch.MonoColor0);
    REG_WR32(NV_PGRAPH_ROP3,            pGrChan->CurrentPatch.Rop3);
    REG_WR32(NV_PGRAPH_CHROMA,          pGrChan->CurrentPatch.Chroma);
    REG_WR32(NV_PGRAPH_BETA_AND,        pGrChan->CurrentPatch.BetaAnd);
    REG_WR32(NV_PGRAPH_BETA_PREMULT,    pGrChan->CurrentPatch.BetaPremult);
    
    REG_WR32(NV_PGRAPH_CONTROL0,        pGrChan->CurrentPatch.Control0);
    REG_WR32(NV_PGRAPH_CONTROL1,        pGrChan->CurrentPatch.Control1);
    REG_WR32(NV_PGRAPH_CONTROL2,        pGrChan->CurrentPatch.Control2);
    REG_WR32(NV_PGRAPH_CONTROL3,        pGrChan->CurrentPatch.Control3);
    
    REG_WR32(NV_PGRAPH_BLEND,           pGrChan->CurrentPatch.Blend);
    REG_WR32(NV_PGRAPH_BLENDCOLOR,      pGrChan->CurrentPatch.BlendColor);
    REG_WR32(NV_PGRAPH_SETUPRASTER,     pGrChan->CurrentPatch.SetupRaster);
    REG_WR32(NV_PGRAPH_FOGCOLOR,        pGrChan->CurrentPatch.FogColor);
    REG_WR32(NV_PGRAPH_COLORKEYCOLOR0,  pGrChan->CurrentPatch.ColorKeyColor0);
    REG_WR32(NV_PGRAPH_COLORKEYCOLOR1,  pGrChan->CurrentPatch.ColorKeyColor1);
    REG_WR32(NV_PGRAPH_POINTSIZE,       pGrChan->CurrentPatch.PointSize);

    REG_WR32(NV_PGRAPH_ZOFFSETFACTOR,   pGrChan->CurrentPatch.ZOffsetFactor);
    REG_WR32(NV_PGRAPH_ZOFFSETBIAS,     pGrChan->CurrentPatch.ZOffsetBias);
    REG_WR32(NV_PGRAPH_ZCLIPMIN,        pGrChan->CurrentPatch.ZClipMin);
    REG_WR32(NV_PGRAPH_ZCLIPMAX,        pGrChan->CurrentPatch.ZClipMax);

    for (i = 0; i < 8; i++)
    {
        REG_WR32(NV_PGRAPH_WINDOWCLIP_HORIZONTAL(i), pGrChan->CurrentPatch.WinClipHorz[i]);
        REG_WR32(NV_PGRAPH_WINDOWCLIP_VERTICAL(i),   pGrChan->CurrentPatch.WinClipVert[i]);
    }

    REG_WR32(NV_PGRAPH_XFMODE0,         pGrChan->CurrentPatch.XFMode[0]);
    REG_WR32(NV_PGRAPH_XFMODE1,         pGrChan->CurrentPatch.XFMode[1]);

    REG_WR32(NV_PGRAPH_GLOBALSTATE0,         pGrChan->CurrentPatch.GlobalState0);
    REG_WR32(NV_PGRAPH_GLOBALSTATE1,         pGrChan->CurrentPatch.GlobalState1);

    REG_WR32(NV_PGRAPH_STORED_FMT,      pGrChan->CurrentPatch.StoredFmt);
    REG_WR32(NV_PGRAPH_SOURCE_COLOR,    pGrChan->CurrentPatch.SourceColor);
    
    for (i = 0; i < 32; i++)
    {
        REG_WR32(NV_PGRAPH_ABS_X_RAM(i), pGrChan->CurrentPatch.AbsXRam[i]);
        REG_WR32(NV_PGRAPH_ABS_Y_RAM(i), pGrChan->CurrentPatch.AbsYRam[i]);
    }        
    
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMIN,  pGrChan->CurrentPatch.AbsUClipXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMAX,  pGrChan->CurrentPatch.AbsUClipXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMIN,  pGrChan->CurrentPatch.AbsUClipYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMAX,  pGrChan->CurrentPatch.AbsUClipYMax);

    REG_WR32(NV_PGRAPH_ABS_UCLIP3D_XMIN, pGrChan->CurrentPatch.AbsUClip3DXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP3D_XMAX, pGrChan->CurrentPatch.AbsUClip3DXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIP3D_YMIN, pGrChan->CurrentPatch.AbsUClip3DYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP3D_YMAX, pGrChan->CurrentPatch.AbsUClip3DYMax);

    REG_WR32(NV_PGRAPH_ABS_UCLIPA_XMIN, pGrChan->CurrentPatch.AbsUClipAXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_XMAX, pGrChan->CurrentPatch.AbsUClipAXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_YMIN, pGrChan->CurrentPatch.AbsUClipAYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_YMAX, pGrChan->CurrentPatch.AbsUClipAYMax);
    
    REG_WR32(NV_PGRAPH_ABS_ICLIP_XMAX,  pGrChan->CurrentPatch.AbsIClipXMax);
    REG_WR32(NV_PGRAPH_ABS_ICLIP_YMAX,  pGrChan->CurrentPatch.AbsIClipYMax);
    
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC0,  pGrChan->CurrentPatch.XYLogicMisc0);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC1,  pGrChan->CurrentPatch.XYLogicMisc1);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC2,  pGrChan->CurrentPatch.XYLogicMisc2);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC3,  pGrChan->CurrentPatch.XYLogicMisc3);

    REG_WR32(NV_PGRAPH_CLIPX_0,         pGrChan->CurrentPatch.ClipX0);
    REG_WR32(NV_PGRAPH_CLIPX_1,         pGrChan->CurrentPatch.ClipX1);
    REG_WR32(NV_PGRAPH_CLIPY_0,         pGrChan->CurrentPatch.ClipY0);
    REG_WR32(NV_PGRAPH_CLIPY_1,         pGrChan->CurrentPatch.ClipY1);
    
    REG_WR32(NV_PGRAPH_COMBINE0ALPHAICW,   pGrChan->CurrentPatch.Combine0AlphaICW);
    REG_WR32(NV_PGRAPH_COMBINE0COLORICW,   pGrChan->CurrentPatch.Combine0ColorICW);
    REG_WR32(NV_PGRAPH_COMBINE1ALPHAICW,   pGrChan->CurrentPatch.Combine1AlphaICW);
    REG_WR32(NV_PGRAPH_COMBINE1COLORICW,   pGrChan->CurrentPatch.Combine1ColorICW);
    
    REG_WR32(NV_PGRAPH_COMBINE0FACTOR,     pGrChan->CurrentPatch.Combine0Factor);
    REG_WR32(NV_PGRAPH_COMBINE1FACTOR,     pGrChan->CurrentPatch.Combine1Factor);

    REG_WR32(NV_PGRAPH_COMBINE0ALPHAOCW,   pGrChan->CurrentPatch.Combine0AlphaOCW);
    REG_WR32(NV_PGRAPH_COMBINE0COLOROCW,   pGrChan->CurrentPatch.Combine0ColorOCW);
    REG_WR32(NV_PGRAPH_COMBINE1ALPHAOCW,   pGrChan->CurrentPatch.Combine1AlphaOCW);
    REG_WR32(NV_PGRAPH_COMBINE1COLOROCW,   pGrChan->CurrentPatch.Combine1ColorOCW);

    REG_WR32(NV_PGRAPH_COMBINESPECFOGCW0,   pGrChan->CurrentPatch.CombineSpecFogCW0);
    REG_WR32(NV_PGRAPH_COMBINESPECFOGCW1,   pGrChan->CurrentPatch.CombineSpecFogCW1);

    REG_WR32(NV_PGRAPH_TEXTUREOFFSET0,      pGrChan->CurrentPatch.TextureOffset0);
    REG_WR32(NV_PGRAPH_TEXTUREOFFSET1,      pGrChan->CurrentPatch.TextureOffset1);
    REG_WR32(NV_PGRAPH_TEXTUREPALETTE0,     pGrChan->CurrentPatch.TexturePalette0);
    REG_WR32(NV_PGRAPH_TEXTUREPALETTE1,     pGrChan->CurrentPatch.TexturePalette1);

    REG_WR32(NV_PGRAPH_TEXFORMAT0,         pGrChan->CurrentPatch.TexFormat0);
    REG_WR32(NV_PGRAPH_TEXFORMAT1,         pGrChan->CurrentPatch.TexFormat1);

    REG_WR32(NV_PGRAPH_TEXCONTROL0_0,      pGrChan->CurrentPatch.TexControl0_0);
    REG_WR32(NV_PGRAPH_TEXCONTROL0_1,      pGrChan->CurrentPatch.TexControl0_1);
    REG_WR32(NV_PGRAPH_TEXCONTROL1_0,      pGrChan->CurrentPatch.TexControl1_0);
    REG_WR32(NV_PGRAPH_TEXCONTROL1_1,      pGrChan->CurrentPatch.TexControl1_1);
    REG_WR32(NV_PGRAPH_TEXCONTROL2_0,      pGrChan->CurrentPatch.TexControl2_0);
    REG_WR32(NV_PGRAPH_TEXCONTROL2_1,      pGrChan->CurrentPatch.TexControl2_1);

    REG_WR32(NV_PGRAPH_IMAGERECT0,      pGrChan->CurrentPatch.ImageRect0);
    REG_WR32(NV_PGRAPH_IMAGERECT1,      pGrChan->CurrentPatch.ImageRect1);

    REG_WR32(NV_PGRAPH_FILTER0,         pGrChan->CurrentPatch.Filter0);
    REG_WR32(NV_PGRAPH_FILTER1,         pGrChan->CurrentPatch.Filter1);
    
    REG_WR32(NV_PGRAPH_PASSTHRU_0,      pGrChan->CurrentPatch.Passthru0);    
    REG_WR32(NV_PGRAPH_PASSTHRU_1,      pGrChan->CurrentPatch.Passthru1);    
    REG_WR32(NV_PGRAPH_PASSTHRU_2,      pGrChan->CurrentPatch.Passthru2);    
    
    REG_WR32(NV_PGRAPH_DIMX_TEXTURE,    pGrChan->CurrentPatch.DimxTexture);
    REG_WR32(NV_PGRAPH_WDIMX_TEXTURE,   pGrChan->CurrentPatch.WdimxTexture);

    REG_WR32(NV_PGRAPH_DVD_COLORFMT,    pGrChan->CurrentPatch.DVDColorFormat);    
    REG_WR32(NV_PGRAPH_SCALED_FORMAT,   pGrChan->CurrentPatch.ScaledFormat);    
    
    REG_WR32(NV_PGRAPH_MISC24_0,        pGrChan->CurrentPatch.Misc24_0);
    REG_WR32(NV_PGRAPH_MISC24_1,        pGrChan->CurrentPatch.Misc24_1);
    REG_WR32(NV_PGRAPH_MISC24_2,        pGrChan->CurrentPatch.Misc24_2);
    REG_WR32(NV_PGRAPH_X_MISC,          pGrChan->CurrentPatch.XMisc);
    REG_WR32(NV_PGRAPH_Y_MISC,          pGrChan->CurrentPatch.YMisc);
    REG_WR32(NV_PGRAPH_VALID1,          pGrChan->CurrentPatch.Valid1);
    REG_WR32(NV_PGRAPH_VALID2,          pGrChan->CurrentPatch.Valid2);

    // wait for the pipe to go idle again after loading the pipeline context
    HAL_GR_IDLE(pHalHwInfo);

    // restore pipe context if a 3D object exists in the channel
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0)
    {
        U032 grclass = INST_RD32(pGrHalPvtInfo->currentObjects3d[ChID],
                                 SF_OFFSET(NV_PRAMIN_CONTEXT_0)) & DRF_MASK(NV_PGRAPH_CTX_SWITCH1_GRCLASS);

        // set vertex passthrough mode (pass data unchanged down the pipe)
        REG_WR32(NV_PGRAPH_XFMODE0,         Vertex_Passthr_Mode[0]);
        REG_WR32(NV_PGRAPH_XFMODE1,         Vertex_Passthr_Mode[1]);

        // set scale and offset constants in ModelViewMatrix1 for passthrough
        grLoadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE + (3*64), ScaleOffset_Passthr_Mode, SCALEOFFSET_COUNT);

        // set fog constants for passthrough (different between A01 and A02)
        if (IsNV10MaskRevA02orBetter_NV10(pHalHwInfo->pMcHalInfo))
        {
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), Fog_Passthr_Mode[1], FOG_COUNT);
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x28 << 4), Fog_EyeDist_Passthr_Mode, FOG_EYEDIST_COUNT);
        } else
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), Fog_Passthr_Mode[0], FOG_COUNT);


        if ((grclass == NV10_DX5_TEXTURED_TRIANGLE) || (grclass == NV10_DX6_MULTI_TEXTURE_TRIANGLE))
        {
            // set PrimType=NONE (0x0), which puts the following vertices into the vertex file
            i = 0x0;
            grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE, &i, 0x1);
            grLoadPipeContext(pHalHwInfo, PIPE_FILE_BASE, pGrChan->CurrentPatch.CurrentPipe.VertexFile, VERTEX_FILE_COUNT);
        }
        else
        {
            // set PrimType=QUAD (0x8), which puts the following vertices into primitive assembly
            i = 0x8;
            grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE, &i, 0x1);
            grLoadPipeContext(pHalHwInfo, PIPE_ASSM_BASE, pGrChan->CurrentPatch.CurrentPipe.PrimAssm, PRIM_ASSM_COUNT);
        }

        REG_WR32(NV_PGRAPH_XFMODE0,         pGrChan->CurrentPatch.XFMode[0]);
        REG_WR32(NV_PGRAPH_XFMODE1,         pGrChan->CurrentPatch.XFMode[1]);

        // load transform engine state
        grLoadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_CHEOPS, XF_CHEOPS_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER, XF_ZOSER_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_C0_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C0, XF_ZOSER_C0_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_C1_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C1, XF_ZOSER_C1_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_C2_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C2, XF_ZOSER_C2_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_C3_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C3, XF_ZOSER_C3_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_VAB_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_VAB, XF_VAB_COUNT);

        if (grclass == NV10_CELSIUS_PRIMITIVE)
        {
            U032 format, temp;

            //
            // The 8 FORMAT_SIZE values (bits 7:4) don't get saved correctly during an unload due
            // to a HW bug. To workaround this, the drivers shadow the values in the last DWORD of
            // the last row of the 2nd Inverse ModelViewMatrix (offset = 0x653C).
            // 
            // During a load of this ChID, we'll read the DWORD out of the matrix, unpack the bits
            // and put the correct values in grTable before they're restored into FORMAT_BASE.
            //
            format = pGrChan->CurrentPatch.CurrentPipe.XF_CHEOPS[(INV2_MATRIX_OFFSET - PIPE_CHEOPS_BASE)/4];
        
            for (i = 1; i < INDEX_DMA_FORMAT_COUNT; i += 2, format >>= 4)
            {
                temp = pGrChan->CurrentPatch.CurrentPipe.IndexDmaFormat[i];
                temp = (temp & 0xFFFFFF0F) | ((format & 0xF) << 4);
                pGrChan->CurrentPatch.CurrentPipe.IndexDmaFormat[i] = temp;
            }
        }

        // load index DMA pipe state
        grLoadPipeContext(pHalHwInfo, PIPE_FORMAT_BASE,	pGrChan->CurrentPatch.CurrentPipe.IndexDmaFormat, INDEX_DMA_FORMAT_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE, pGrChan->CurrentPatch.CurrentPipe.IndexDmaPrim, INDEX_DMA_PRIM_COUNT);

        // wait for the pipe to go idle 
        HAL_GR_IDLE(pHalHwInfo);

#ifdef NOTDEF
        //
        // Force an invalidate of the vertex cache. Since we force a
        // GR reset of the chip, this shouldn't be necessary anymore.
        //
        i = 0x0;
        grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE+0x80, &i, 0x1);
#endif
    }
}

RM_STATUS
nvHalGrUnloadChannelContext_NV10(PHALHWINFO pHalHwInfo, U032 ChID, PGRAPHICSCHANNEL_NV10 pGrChan)
{
    PGRHALINFO_NV10 pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrUnloadChannelContext_NV10\r\n");

    //
    // No need to unload an invalid channel
    //
    if (ChID  == INVALID_CHID)
        return (RM_OK);

    //
    // Unload current context registers.
    //
    pGrChan->ContextSwitch1    = REG_RD32(NV_PGRAPH_CTX_SWITCH1);
    pGrChan->ContextSwitch2    = REG_RD32(NV_PGRAPH_CTX_SWITCH2);
    pGrChan->ContextSwitch3    = REG_RD32(NV_PGRAPH_CTX_SWITCH3);        
    pGrChan->ContextSwitch4    = REG_RD32(NV_PGRAPH_CTX_SWITCH4);
    pGrChan->ContextSwitch5    = REG_RD32(NV_PGRAPH_CTX_SWITCH5);

    for (i = 0; i < 8; i++)
    {    
        pGrChan->ContextCache1[i] = REG_RD32(NV_PGRAPH_CTX_CACHE1(i));
        pGrChan->ContextCache2[i] = REG_RD32(NV_PGRAPH_CTX_CACHE2(i));
        pGrChan->ContextCache3[i] = REG_RD32(NV_PGRAPH_CTX_CACHE3(i));
        pGrChan->ContextCache4[i] = REG_RD32(NV_PGRAPH_CTX_CACHE4(i));
        pGrChan->ContextCache5[i] = REG_RD32(NV_PGRAPH_CTX_CACHE5(i));
    }
    
    pGrChan->ContextUser       = REG_RD32(NV_PGRAPH_CTX_USER);
    
    //
    // Unload current dma registers
    //
    pGrChan->DmaStart0         = REG_RD32(NV_PGRAPH_DMA_START_0);
    pGrChan->DmaStart1         = REG_RD32(NV_PGRAPH_DMA_START_1);
    pGrChan->DmaLength         = REG_RD32(NV_PGRAPH_DMA_LENGTH);
    pGrChan->DmaMisc           = REG_RD32(NV_PGRAPH_DMA_MISC);
    pGrChan->DmaPitch          = REG_RD32(NV_PGRAPH_DMA_PITCH);
            
    //
    // Unload current graphics state
    //
    for (i = 0; i < 6; i++)
    {    
        pGrChan->CurrentPatch.BufferOffset[i] = REG_RD32(NV_PGRAPH_BOFFSET(i));
        pGrChan->CurrentPatch.BufferBase[i]   = REG_RD32(NV_PGRAPH_BBASE(i));
        pGrChan->CurrentPatch.BufferLimit[i]  = REG_RD32(NV_PGRAPH_BLIMIT(i));
    }
    
    for (i = 0; i < 5; i++)
        pGrChan->CurrentPatch.BufferPitch[i]  = REG_RD32(NV_PGRAPH_BPITCH(i));
        
    pGrChan->CurrentPatch.Surface             = REG_RD32(NV_PGRAPH_SURFACE);        
    pGrChan->CurrentPatch.State               = REG_RD32(NV_PGRAPH_STATE);        
    pGrChan->CurrentPatch.BufferSwizzle[0]    = REG_RD32(NV_PGRAPH_BSWIZZLE2);        
    pGrChan->CurrentPatch.BufferSwizzle[1]    = REG_RD32(NV_PGRAPH_BSWIZZLE5);        
    pGrChan->CurrentPatch.BufferPixel         = REG_RD32(NV_PGRAPH_BPIXEL);
    
    pGrChan->CurrentPatch.Notify              = REG_RD32(NV_PGRAPH_NOTIFY);
    pGrChan->CurrentPatch.PatternColor0       = REG_RD32(NV_PGRAPH_PATT_COLOR0);    
    pGrChan->CurrentPatch.PatternColor1       = REG_RD32(NV_PGRAPH_PATT_COLOR1);
    
    // In NV10, we can access the pattern RAM anytime after the engine's been idled
    for (i = 0; i < 64; i++)
        pGrChan->CurrentPatch.PatternColorRam[i] = REG_RD32(NV_PGRAPH_PATT_COLORRAM(i));
    
    pGrChan->CurrentPatch.Pattern[0]          = REG_RD32(NV_PGRAPH_PATTERN(0));
    pGrChan->CurrentPatch.Pattern[1]          = REG_RD32(NV_PGRAPH_PATTERN(1));
    pGrChan->CurrentPatch.PatternShape        = REG_RD32(NV_PGRAPH_PATTERN_SHAPE);
    
    pGrChan->CurrentPatch.MonoColor0          = REG_RD32(NV_PGRAPH_MONO_COLOR0);
    pGrChan->CurrentPatch.Rop3                = REG_RD32(NV_PGRAPH_ROP3);
    pGrChan->CurrentPatch.Chroma              = REG_RD32(NV_PGRAPH_CHROMA);
    pGrChan->CurrentPatch.BetaAnd             = REG_RD32(NV_PGRAPH_BETA_AND);
    pGrChan->CurrentPatch.BetaPremult         = REG_RD32(NV_PGRAPH_BETA_PREMULT);
    
    pGrChan->CurrentPatch.Control0            = REG_RD32(NV_PGRAPH_CONTROL0);
    pGrChan->CurrentPatch.Control1            = REG_RD32(NV_PGRAPH_CONTROL1);
    pGrChan->CurrentPatch.Control2            = REG_RD32(NV_PGRAPH_CONTROL2);
    pGrChan->CurrentPatch.Control3            = REG_RD32(NV_PGRAPH_CONTROL3);
    
    pGrChan->CurrentPatch.Blend               = REG_RD32(NV_PGRAPH_BLEND);
    pGrChan->CurrentPatch.BlendColor          = REG_RD32(NV_PGRAPH_BLENDCOLOR);
    pGrChan->CurrentPatch.SetupRaster         = REG_RD32(NV_PGRAPH_SETUPRASTER);
    pGrChan->CurrentPatch.FogColor            = REG_RD32(NV_PGRAPH_FOGCOLOR);
    pGrChan->CurrentPatch.ColorKeyColor0      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR0);
    pGrChan->CurrentPatch.ColorKeyColor1      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR1);
    pGrChan->CurrentPatch.PointSize           = REG_RD32(NV_PGRAPH_POINTSIZE);

    pGrChan->CurrentPatch.ZOffsetFactor       = REG_RD32(NV_PGRAPH_ZOFFSETFACTOR);
    pGrChan->CurrentPatch.ZOffsetBias         = REG_RD32(NV_PGRAPH_ZOFFSETBIAS);
    pGrChan->CurrentPatch.ZClipMin            = REG_RD32(NV_PGRAPH_ZCLIPMIN);
    pGrChan->CurrentPatch.ZClipMax            = REG_RD32(NV_PGRAPH_ZCLIPMAX);
    
    for (i = 0; i < 8; i++)
    {
        pGrChan->CurrentPatch.WinClipHorz[i]    = REG_RD32(NV_PGRAPH_WINDOWCLIP_HORIZONTAL(i));
        pGrChan->CurrentPatch.WinClipVert[i]    = REG_RD32(NV_PGRAPH_WINDOWCLIP_VERTICAL(i));
    }

    pGrChan->CurrentPatch.XFMode[0]           = REG_RD32(NV_PGRAPH_XFMODE0);
    pGrChan->CurrentPatch.XFMode[1]           = REG_RD32(NV_PGRAPH_XFMODE1);

    pGrChan->CurrentPatch.GlobalState0        = REG_RD32(NV_PGRAPH_GLOBALSTATE0);
    pGrChan->CurrentPatch.GlobalState1        = REG_RD32(NV_PGRAPH_GLOBALSTATE1);

    pGrChan->CurrentPatch.StoredFmt           = REG_RD32(NV_PGRAPH_STORED_FMT);
    pGrChan->CurrentPatch.SourceColor         = REG_RD32(NV_PGRAPH_SOURCE_COLOR);
    
    for (i = 0; i < 32; i++)
    {
        pGrChan->CurrentPatch.AbsXRam[i]      = REG_RD32(NV_PGRAPH_ABS_X_RAM(i));
        pGrChan->CurrentPatch.AbsYRam[i]      = REG_RD32(NV_PGRAPH_ABS_Y_RAM(i));
    }        
    
    pGrChan->CurrentPatch.AbsUClipXMin        = REG_RD32(NV_PGRAPH_ABS_UCLIP_XMIN);
    pGrChan->CurrentPatch.AbsUClipXMax        = REG_RD32(NV_PGRAPH_ABS_UCLIP_XMAX);
    pGrChan->CurrentPatch.AbsUClipYMin        = REG_RD32(NV_PGRAPH_ABS_UCLIP_YMIN);
    pGrChan->CurrentPatch.AbsUClipYMax        = REG_RD32(NV_PGRAPH_ABS_UCLIP_YMAX);
    
    pGrChan->CurrentPatch.AbsUClip3DXMin      = REG_RD32(NV_PGRAPH_ABS_UCLIP3D_XMIN);
    pGrChan->CurrentPatch.AbsUClip3DXMax      = REG_RD32(NV_PGRAPH_ABS_UCLIP3D_XMAX);
    pGrChan->CurrentPatch.AbsUClip3DYMin      = REG_RD32(NV_PGRAPH_ABS_UCLIP3D_YMIN);
    pGrChan->CurrentPatch.AbsUClip3DYMax      = REG_RD32(NV_PGRAPH_ABS_UCLIP3D_YMAX);
    
    pGrChan->CurrentPatch.AbsUClipAXMin       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_XMIN);
    pGrChan->CurrentPatch.AbsUClipAXMax       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_XMAX);
    pGrChan->CurrentPatch.AbsUClipAYMin       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_YMIN);
    pGrChan->CurrentPatch.AbsUClipAYMax       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_YMAX);
    
    pGrChan->CurrentPatch.AbsIClipXMax        = REG_RD32(NV_PGRAPH_ABS_ICLIP_XMAX);
    pGrChan->CurrentPatch.AbsIClipYMax        = REG_RD32(NV_PGRAPH_ABS_ICLIP_YMAX);
    
    pGrChan->CurrentPatch.XYLogicMisc0        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC0);
    pGrChan->CurrentPatch.XYLogicMisc1        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC1);
    pGrChan->CurrentPatch.XYLogicMisc2        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC2);
    pGrChan->CurrentPatch.XYLogicMisc3        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC3);

    pGrChan->CurrentPatch.ClipX0              = REG_RD32(NV_PGRAPH_CLIPX_0);
    pGrChan->CurrentPatch.ClipX1              = REG_RD32(NV_PGRAPH_CLIPX_1);
    pGrChan->CurrentPatch.ClipY0              = REG_RD32(NV_PGRAPH_CLIPY_0);
    pGrChan->CurrentPatch.ClipY1              = REG_RD32(NV_PGRAPH_CLIPY_1);
    
    pGrChan->CurrentPatch.Combine0AlphaICW    = REG_RD32(NV_PGRAPH_COMBINE0ALPHAICW);
    pGrChan->CurrentPatch.Combine1AlphaICW    = REG_RD32(NV_PGRAPH_COMBINE1ALPHAICW);
    pGrChan->CurrentPatch.Combine0ColorICW    = REG_RD32(NV_PGRAPH_COMBINE0COLORICW);
    pGrChan->CurrentPatch.Combine1ColorICW    = REG_RD32(NV_PGRAPH_COMBINE1COLORICW);

    pGrChan->CurrentPatch.Combine0Factor      = REG_RD32(NV_PGRAPH_COMBINE0FACTOR);
    pGrChan->CurrentPatch.Combine1Factor      = REG_RD32(NV_PGRAPH_COMBINE1FACTOR);

    pGrChan->CurrentPatch.Combine0AlphaOCW    = REG_RD32(NV_PGRAPH_COMBINE0ALPHAOCW);
    pGrChan->CurrentPatch.Combine1AlphaOCW    = REG_RD32(NV_PGRAPH_COMBINE1ALPHAOCW);
    pGrChan->CurrentPatch.Combine0ColorOCW    = REG_RD32(NV_PGRAPH_COMBINE0COLOROCW);
    pGrChan->CurrentPatch.Combine1ColorOCW    = REG_RD32(NV_PGRAPH_COMBINE1COLOROCW);

    pGrChan->CurrentPatch.CombineSpecFogCW0   = REG_RD32(NV_PGRAPH_COMBINESPECFOGCW0);
    pGrChan->CurrentPatch.CombineSpecFogCW1   = REG_RD32(NV_PGRAPH_COMBINESPECFOGCW1);

    pGrChan->CurrentPatch.TextureOffset0      = REG_RD32(NV_PGRAPH_TEXTUREOFFSET0);
    pGrChan->CurrentPatch.TextureOffset1      = REG_RD32(NV_PGRAPH_TEXTUREOFFSET1);
    pGrChan->CurrentPatch.TexturePalette0     = REG_RD32(NV_PGRAPH_TEXTUREPALETTE0);
    pGrChan->CurrentPatch.TexturePalette1     = REG_RD32(NV_PGRAPH_TEXTUREPALETTE1);
    pGrChan->CurrentPatch.TexFormat0          = REG_RD32(NV_PGRAPH_TEXFORMAT0);
    pGrChan->CurrentPatch.TexFormat1          = REG_RD32(NV_PGRAPH_TEXFORMAT1);
    pGrChan->CurrentPatch.TexControl0_0       = REG_RD32(NV_PGRAPH_TEXCONTROL0_0);
    pGrChan->CurrentPatch.TexControl0_1       = REG_RD32(NV_PGRAPH_TEXCONTROL0_1);
    pGrChan->CurrentPatch.TexControl1_0       = REG_RD32(NV_PGRAPH_TEXCONTROL1_0);
    pGrChan->CurrentPatch.TexControl1_1       = REG_RD32(NV_PGRAPH_TEXCONTROL1_1);
    pGrChan->CurrentPatch.TexControl2_0       = REG_RD32(NV_PGRAPH_TEXCONTROL2_0);
    pGrChan->CurrentPatch.TexControl2_1       = REG_RD32(NV_PGRAPH_TEXCONTROL2_1);

    pGrChan->CurrentPatch.ImageRect0          = REG_RD32(NV_PGRAPH_IMAGERECT0);
    pGrChan->CurrentPatch.ImageRect1          = REG_RD32(NV_PGRAPH_IMAGERECT1);

    pGrChan->CurrentPatch.Filter0             = REG_RD32(NV_PGRAPH_FILTER0);
    pGrChan->CurrentPatch.Filter1             = REG_RD32(NV_PGRAPH_FILTER1);
    
    pGrChan->CurrentPatch.Passthru0           = REG_RD32(NV_PGRAPH_PASSTHRU_0);    
    pGrChan->CurrentPatch.Passthru1           = REG_RD32(NV_PGRAPH_PASSTHRU_1);    
    pGrChan->CurrentPatch.Passthru2           = REG_RD32(NV_PGRAPH_PASSTHRU_2);    
    
    pGrChan->CurrentPatch.DimxTexture         = REG_RD32(NV_PGRAPH_DIMX_TEXTURE);
    pGrChan->CurrentPatch.WdimxTexture        = REG_RD32(NV_PGRAPH_WDIMX_TEXTURE);

    pGrChan->CurrentPatch.DVDColorFormat      = REG_RD32(NV_PGRAPH_DVD_COLORFMT);    
    pGrChan->CurrentPatch.ScaledFormat        = REG_RD32(NV_PGRAPH_SCALED_FORMAT);    
    
    pGrChan->CurrentPatch.Misc24_0            = REG_RD32(NV_PGRAPH_MISC24_0);
    pGrChan->CurrentPatch.Misc24_1            = REG_RD32(NV_PGRAPH_MISC24_1);
    pGrChan->CurrentPatch.Misc24_2            = REG_RD32(NV_PGRAPH_MISC24_2);
    pGrChan->CurrentPatch.XMisc               = REG_RD32(NV_PGRAPH_X_MISC);
    pGrChan->CurrentPatch.YMisc               = REG_RD32(NV_PGRAPH_Y_MISC);
    pGrChan->CurrentPatch.Valid1              = REG_RD32(NV_PGRAPH_VALID1);
    pGrChan->CurrentPatch.Valid2              = REG_RD32(NV_PGRAPH_VALID2);

    // save pipe context if a 3D object exists in the channel
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0)
    {
        U032 grclass = INST_RD32(pGrHalPvtInfo->currentObjects3d[ChID],
                                 SF_OFFSET(NV_PRAMIN_CONTEXT_0)) & DRF_MASK(NV_PGRAPH_CTX_SWITCH1_GRCLASS);

        if ((grclass == NV10_DX5_TEXTURED_TRIANGLE) || (grclass == NV10_DX6_MULTI_TEXTURE_TRIANGLE))
        {
            grUnloadPipeContext(pHalHwInfo, PIPE_FILE_BASE, pGrChan->CurrentPatch.CurrentPipe.VertexFile, VERTEX_FILE_COUNT);
            grUnloadPipeContext(pHalHwInfo, PIPE_VAB_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_VAB, XF_VAB_COUNT);
        }
        else
        {
            grUnloadPipeContext(pHalHwInfo, PIPE_VAB_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_VAB, XF_VAB_COUNT);
            grUnloadPipeContext(pHalHwInfo, PIPE_ASSM_BASE,	pGrChan->CurrentPatch.CurrentPipe.PrimAssm, PRIM_ASSM_COUNT);
        }

        // unload transform engine state
        grUnloadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_CHEOPS, XF_CHEOPS_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER, XF_ZOSER_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_C0_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C0, XF_ZOSER_C0_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_C1_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C1, XF_ZOSER_C1_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_C2_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C2, XF_ZOSER_C2_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_C3_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C3, XF_ZOSER_C3_COUNT);

        // unload index DMA pipe state
        grUnloadPipeContext(pHalHwInfo, PIPE_PRIM_BASE, pGrChan->CurrentPatch.CurrentPipe.IndexDmaPrim, INDEX_DMA_PRIM_COUNT);

#ifdef CHECK_VTX_COUNT
{
        U032 InitCtxtPtr = pHalHwInfo->pPramHalInfo->FifoContextAddr + (ChID * 32);
        U032 vtxcount = pGrChan->CurrentPatch.CurrentPipe.IndexDmaPrim[0x3] & 0x1F00;

        if (vtxcount) {
            U032 method = REG_RD32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_METHOD))) & 0x1FFF;
            if ((method < NV056_INLINE_ARRAY(0)) || (method >= NV056_INLINE_ARRAY(0x200)))
                _asm int 3;
        }
}
#endif
        grUnloadPipeContext(pHalHwInfo, PIPE_FORMAT_BASE, pGrChan->CurrentPatch.CurrentPipe.IndexDmaFormat, INDEX_DMA_FORMAT_COUNT);

        // wait for the pipe to go idle again after unloading the pipeline context
        HAL_GR_IDLE(pHalHwInfo);
    }

    //
    // Invalidate hw's channel ID.
    //
    REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));

    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, (NUM_FIFOS_NV10 - 1));

    return (RM_OK);
}

RM_STATUS
nvHalGrGetState_NV10(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData, U032 useCtxDma)
{
    PGRHALINFO_NV10 pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV10 pGrChannel;
    U032 ChID;
    U032 access, instance;
    U032 i, format, temp;
    NvGraphicsState *stateptr;
    RM_STATUS status;
    PDMAHALOBJINFO pDmaHalInfo;
    PHWREG nvAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrGetState\r\n");

    pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    pGrChannel = &pGrHalPvtInfo->grChannels[pGrExceptionData->ChID];
    nvAddr = pHalHwInfo->nvBaseAddr;
    ChID = pGrExceptionData->ChID;

#ifdef DEBUG
    // we're from a GR exception, so we should be idled/disable already
    if (REG_RD_DRF(_PGRAPH, _FIFO, _ACCESS) || REG_RD32(NV_PGRAPH_STATUS))
        DBG_BREAKPOINT();
#endif

    access = REG_RD32(NV_PGRAPH_FIFO);
	REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
    GR_DONE();

    if (useCtxDma)
    {
        // determine where the ContextDmaState buffer resides (kept in GLOBALSTATE1)
        if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) == ChID)
            instance = REG_RD_DRF(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_3);
        else
            instance = DRF_VAL(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_3, pGrChannel[ChID].CurrentPatch.GlobalState1);

        if (!instance)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NULL ContextDmaState buffer\n\r");
            DBG_BREAKPOINT();
            return RM_ERR_INVALID_STATE;
        }

        // convert instance address to DmaHalInfo structure
        status = dmaHalInstanceToHalInfo_NV10(ChID, instance, &pDmaHalInfo, pHalHwInfo);
        if (status)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ContextDmaState invalid instance\n\r");
            DBG_BREAKPOINT();
            return RM_ERR_INVALID_STATE;
        }

        if (pDmaHalInfo->BufferSize < sizeof (NvGraphicsState))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ContextDmaState smaller than GetState data\n\r");
            DBG_BREAKPOINT();
            return status;
        }

        stateptr = (NvGraphicsState *)pDmaHalInfo->BufferBase;
    }
    else
    {
        // use the local NvGraphicsState for the Snapshot/Reload interface
        stateptr = &pGrHalPvtInfo->grSnapShots[ChID];
    }

    // copy out the data
    if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) == ChID)
    {
        // first 4 DWORDS of NvGraphicsState is the PerFragment state
        ((U032 *)stateptr)[0] = REG_RD32(NV_PGRAPH_CONTROL0);
        ((U032 *)stateptr)[1] = REG_RD32(NV_PGRAPH_CONTROL1);
        ((U032 *)stateptr)[2] = REG_RD32(NV_PGRAPH_CONTROL2);
        ((U032 *)stateptr)[3] = REG_RD32(NV_PGRAPH_BLEND);

        // read the
        //      PerVertexState from the VAB,
        //      PrimitiveAssembly from PIPE_ASSM_BASE
        //      PerVertextState.EdgeFlag from PRIM_BASE
        //      VertexArrayState from PIPE_FORMAT
        grUnloadPipeContext(pHalHwInfo, PIPE_VAB_BASE,    (U032 *)(&stateptr->PerVertexState), XF_VAB_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ASSM_BASE,   (U032 *)(&stateptr->PrimitiveAssmState), PRIM_ASSM_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_PRIM_BASE,   (U032 *)(&stateptr->PerVertexState.pad3), INDEX_DMA_PRIM_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_FORMAT_BASE, (U032 *)(&stateptr->VertexArrayState), INDEX_DMA_FORMAT_COUNT);
    } else {
        // first 4 DWORDS of NvGraphicsState is the PerFragment state
        ((U032 *)stateptr)[0] = pGrChannel->CurrentPatch.Control0;
        ((U032 *)stateptr)[1] = pGrChannel->CurrentPatch.Control1;
        ((U032 *)stateptr)[2] = pGrChannel->CurrentPatch.Control2;
        ((U032 *)stateptr)[3] = pGrChannel->CurrentPatch.Blend;
            
        // read the
        //      PerVertexState from the VAB,
        //      PrimitiveAssembly from PIPE_ASSM_BASE
        //      PerVertextState.EdgeFlag from PRIM_BASE
        //      VertexArrayState from PIPE_FORMAT
        for (i = 0; i < (XF_VAB_COUNT << 2); i++)
            *(((char *)(&stateptr->PerVertexState))+i) = *(((char *)pGrChannel->CurrentPatch.CurrentPipe.XF_VAB)+i);

        for (i = 0; i < (PRIM_ASSM_COUNT << 2); i++)
            *(((char *)(&stateptr->PrimitiveAssmState))+i) = *(((char *)pGrChannel->CurrentPatch.CurrentPipe.PrimAssm)+i);

        for (i = 0; i < (INDEX_DMA_PRIM_COUNT << 2); i++)
            *(((char *)(&stateptr->PerVertexState.pad3))+i) = *(((char *)pGrChannel->CurrentPatch.CurrentPipe.IndexDmaPrim)+i);

        for (i = 0; i < (INDEX_DMA_FORMAT_COUNT << 2); i++)
            *(((char *)(&stateptr->VertexArrayState))+i) = *(((char *)pGrChannel->CurrentPatch.CurrentPipe.IndexDmaFormat)+i);
    }

    // correct FORMAT_SIZE bits 7:4 for the HW context read bug (driver shadowed in INV2_MATRIX_OFFSET)
    grUnloadPipeContext(pHalHwInfo, INV2_MATRIX_OFFSET, &format, 0x1);

    for (i = 1; i < INDEX_DMA_FORMAT_COUNT; i += 2, format >>= 4)
    {
        temp = ((U032 *) &stateptr->VertexArrayState)[i];
        temp = (temp & 0xFFFFFF0F) | ((format & 0xF) << 4);
        ((U032 *) &stateptr->VertexArrayState)[i] = temp;
    }

    GR_DONE();
    REG_WR32(NV_PGRAPH_FIFO, access);

    return RM_OK;
}

RM_STATUS
nvHalGrPutState_NV10(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData, U032 useCtxDma)
{
    PGRHALINFO_NV10 pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV10 pGrChannel;
    U032 access, instance;
    U032 i;
    NvGraphicsState *stateptr;
    RM_STATUS   status;
    PDMAHALOBJINFO pDmaHalInfo;
    PHWREG nvAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrPutState\r\n");

    pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    pGrChannel = &pGrHalPvtInfo->grChannels[pGrExceptionData->ChID];
    nvAddr = pHalHwInfo->nvBaseAddr;

    access = REG_RD32(NV_PGRAPH_FIFO);
    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
    GR_DONE();

    if (useCtxDma) {
        // determine where the ContextDmaState buffer resides (kept in GLOBALSTATE1)
        if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) == pGrExceptionData->ChID)
            instance = REG_RD_DRF(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_3);
        else
            instance = DRF_VAL(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_3, pGrChannel[pGrExceptionData->ChID].CurrentPatch.GlobalState1);

        if (!instance)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NULL ContextDmaState buffer\n\r");
            DBG_BREAKPOINT();
            return RM_ERROR;
        }

        // convert instance address to DmaHalInfo structure
        status = dmaHalInstanceToHalInfo_NV10(pGrExceptionData->ChID, instance, &pDmaHalInfo, pHalHwInfo);
        if (status)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid ContextDmaState buffer\n\r");
            DBG_BREAKPOINT();
            return RM_ERR_INVALID_STATE;
        }

        // ensure DmaState buffer is large enough for the GetState data
        if (pDmaHalInfo->BufferSize < sizeof(NvGraphicsState))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ContextDmaState smaller than GetState data\n\r");
            DBG_BREAKPOINT();
            return status;
        }

        stateptr = (NvGraphicsState *)pDmaHalInfo->BufferBase;
    } else {
        // use the local NvGraphicsState for the Snapshot/Reload interface
        stateptr = &pGrHalPvtInfo->grSnapShots[pGrExceptionData->ChID];
    }

    // copy data to the HW
    if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) == pGrExceptionData->ChID)
    {
        U032 xfmode0, xfmode1;
        U032 scale[SCALEOFFSET_COUNT];
        U032 fog[FOG_COUNT];
        U032 fog_eyedist[FOG_EYEDIST_COUNT];

        // first 4 DWORDS of NvGraphicsState is the PerFragment state
        REG_WR32(NV_PGRAPH_CONTROL0, ((U032 *)stateptr)[0]);
        REG_WR32(NV_PGRAPH_CONTROL1, ((U032 *)stateptr)[1]);
        REG_WR32(NV_PGRAPH_CONTROL2, ((U032 *)stateptr)[2]);
        REG_WR32(NV_PGRAPH_BLEND,    ((U032 *)stateptr)[3]);

        // Because we'll need to change bits of the pipe state to put the engines
        // in passthrough mode, we'll need to keep the current values, so we can
        // restore them after we've reloaded PRIM_ASSM.

        // save current xfmode values (modified for passthrough)
        xfmode0 = REG_RD32(NV_PGRAPH_XFMODE0);
        xfmode1 = REG_RD32(NV_PGRAPH_XFMODE1);

        // save current scale/offset constants in ModelViewMatrix1 (modified for passthrough)
        grUnloadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE + (3*64), scale, SCALEOFFSET_COUNT);

        // save current fog constants (modified for passthrough)
        if (IsNV10MaskRevA02orBetter_NV10(pHalHwInfo->pMcHalInfo))
        {
            grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), fog, FOG_COUNT);
            grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x28 << 4), fog_eyedist, FOG_EYEDIST_COUNT);
        } else
            grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), fog, FOG_COUNT);

        // Now, change the pipe state so that the engines are in passthrough mode.

        // set vertex passthrough mode (pass data unchanged down the pipe)
        REG_WR32(NV_PGRAPH_XFMODE0,         Vertex_Passthr_Mode[0]);
        REG_WR32(NV_PGRAPH_XFMODE1,         Vertex_Passthr_Mode[1]);

        // set scale and offset constants in ModelViewMatrix1 for passthrough
        grLoadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE + (3*64), ScaleOffset_Passthr_Mode, SCALEOFFSET_COUNT);

        // set fog constants for passthrough (different between A01 and A02)
        if (IsNV10MaskRevA02orBetter_NV10(pHalHwInfo->pMcHalInfo))
        {
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), Fog_Passthr_Mode[1], FOG_COUNT);
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x28 << 4), Fog_EyeDist_Passthr_Mode, FOG_EYEDIST_COUNT);
        } else
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), Fog_Passthr_Mode[0], FOG_COUNT);

        // set PrimType=QUAD (0x8), which puts the following vertices into primitive assembly
        i = 0x8;
        grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE, &i, 0x1);

        // restore the PrimitiveAssembly
        grLoadPipeContext(pHalHwInfo, PIPE_ASSM_BASE,   (U032 *)(&stateptr->PrimitiveAssmState), PRIM_ASSM_COUNT);

        // After primitive assembly is restored, reload the original values we
        // modified to put the engines in passthrough mode.

        // restore current xfmode (modified for passthrough)
        REG_WR32(NV_PGRAPH_XFMODE0, xfmode0);
        REG_WR32(NV_PGRAPH_XFMODE1, xfmode1);

        // restore current scale/offset constants in ModelViewMatrix1 (modified for passthrough)
        grLoadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE + (3*64), scale, SCALEOFFSET_COUNT);
        
        // restore current fog constants (modified for passthrough)
        if (IsNV10MaskRevA02orBetter_NV10(pHalHwInfo->pMcHalInfo))
        {
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), fog, FOG_COUNT);
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x28 << 4), fog_eyedist, FOG_EYEDIST_COUNT);
        } else
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), fog, FOG_COUNT);

        // restore the
        //      PerVertexState to the VAB,
        //      VertexArrayState to PIPE_FORMAT
        //      PerVertextState.EdgeFlag to PRIM_BASE
        grLoadPipeContext(pHalHwInfo, PIPE_VAB_BASE,    (U032 *)(&stateptr->PerVertexState), XF_VAB_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_FORMAT_BASE, (U032 *)(&stateptr->VertexArrayState), INDEX_DMA_FORMAT_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE,   (U032 *)(&stateptr->PerVertexState.pad3), INDEX_DMA_PRIM_COUNT);

		// force an invalidate of the vertex cache 
        i = 0x0;
        grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE+0x80, &i, 0x1);
    } else {
        // first 4 DWORDS of NvGraphicsState is the PerFragment state
        pGrChannel->CurrentPatch.Control0 = ((U032 *)stateptr)[0];
        pGrChannel->CurrentPatch.Control1 = ((U032 *)stateptr)[1];
        pGrChannel->CurrentPatch.Control2 = ((U032 *)stateptr)[2];
        pGrChannel->CurrentPatch.Blend    = ((U032 *)stateptr)[3];

        // restore the
        //      PerVertexState to the VAB,
        //      PrimitiveAssembly to PIPE_ASSM_BASE
        //      PerVertextState.EdgeFlag to PRIM_BASE
        //      VertexArrayState to PIPE_FORMAT
        for (i = 0; i < (XF_VAB_COUNT << 2); i++)
            *(((char *)pGrChannel->CurrentPatch.CurrentPipe.XF_VAB)+i) = *(((char *)(&stateptr->PerVertexState))+i);

        for (i = 0; i < (PRIM_ASSM_COUNT << 2); i++)
            *(((char *)pGrChannel->CurrentPatch.CurrentPipe.PrimAssm)+i) = *(((char *)(&stateptr->PrimitiveAssmState))+i);

        for (i = 0; i < (INDEX_DMA_PRIM_COUNT << 2); i++)
            *(((char *)pGrChannel->CurrentPatch.CurrentPipe.IndexDmaPrim)+i) = *(((char *)(&stateptr->PerVertexState.pad3))+i);

        for (i = 0; i < (INDEX_DMA_FORMAT_COUNT << 2); i++)
            *(((char *)pGrChannel->CurrentPatch.CurrentPipe.IndexDmaFormat)+i) = *(((char *)(&stateptr->VertexArrayState))+i);
    }

    GR_DONE();
    REG_WR32(NV_PGRAPH_FIFO, access);

    return RM_OK;
}

#define ZOSER_MATERIAL_COLOR_BASE   0x6aa0

//
// Workaround a HW problem where a Celsius SetMaterialEmission will be ignored in
// between a Begin/End. This is a SW method OGL calls to have us plugin the value.
// 
RM_STATUS nvHalGrSetMaterialEmission_NV10(
    PHALHWINFO pHalHwInfo,
    PGREXCEPTIONDATA pGrExceptionData
)
{
    PHWREG nvAddr;
    U032    pipeAddr = ZOSER_MATERIAL_COLOR_BASE + (pGrExceptionData->Offset - NV056_SET_MATERIAL_EMISSION_SW(0));

    nvAddr = pHalHwInfo->nvBaseAddr;
    grLoadPipeContext(pHalHwInfo, pipeAddr, &pGrExceptionData->Data, 0x1);
    GR_DONE();

    return (RM_OK);
}

//
// This method gives D3D access to the eye direction state.
//

#define ZOSER_EYE_DIR_BASE      0x6a80

RM_STATUS nvHalGrSetEyeDirection_NV10(
    PHALHWINFO pHalHwInfo,
    PGREXCEPTIONDATA pGrExceptionData
)
{
    PHWREG nvAddr;
    U032    pipeAddr = ZOSER_EYE_DIR_BASE + (pGrExceptionData->Offset - NV056_SET_EYE_DIRECTION_SW(0));

    nvAddr = pHalHwInfo->nvBaseAddr;
    grLoadPipeContext(pHalHwInfo, pipeAddr, &pGrExceptionData->Data, 0x1);
    GR_DONE();

    return (RM_OK);
}

static RM_STATUS grDelay_NV10(
    PHALHWINFO pHalHwInfo,
    U032 nsec
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 TimeHi;
    U032 TimeLo;
    U032 TimeCheck;
    
    //
    // For small delays which can only wrap PTIMER_TIME_0 once, doing 2's
    // comp math on TIME_0 is enough and means we don't have to sync TIME_1
    //
#define MAX_SMALLNS_TMRDELAY (0xFFFFFFFF >> 2)

    if (nsec < MAX_SMALLNS_TMRDELAY)
    {
        U032 TimeStart = REG_RD32(NV_PTIMER_TIME_0);
        while (nsec > ((volatile U032)REG_RD32(NV_PTIMER_TIME_0) - TimeStart))
		    ;
        return (RM_OK);
    }

    //
    // Get current time.
    //
    do
    {
        TimeCheck = REG_RD32(NV_PTIMER_TIME_1);
        TimeLo    = REG_RD32(NV_PTIMER_TIME_0);
        TimeHi    = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != TimeHi);

    //
    // Add nanosecond delay.
    //
    TimeLo += nsec;
    if (TimeLo < nsec)
        TimeHi++;
    //
    // Wait until time catches up.
    //
    while (TimeHi > (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_1)))
        ;
    //
    // Try to avoid infinite delay.
    //
    while ((TimeLo > (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_0))) &&
           (TimeHi == (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_1))))
                 ;

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\gr\nv10\grmdnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRCHIP.C                                                          *
*   The graphics chip dependent routines are kept here.                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// First level method handler.
//
RM_STATUS nvHalGrClassSoftwareMethod_NV10(PHALHWINFO, PGREXCEPTIONDATA);

//
// Externs.
//
extern RM_STATUS nvHalGrGetState_NV10(PHALHWINFO, PGREXCEPTIONDATA, U032);
extern RM_STATUS nvHalGrPutState_NV10(PHALHWINFO, PGREXCEPTIONDATA, U032);
extern RM_STATUS nvHalGrSetMaterialEmission_NV10(PHALHWINFO, PGREXCEPTIONDATA);
extern RM_STATUS nvHalGrSetEyeDirection_NV10(PHALHWINFO, PGREXCEPTIONDATA);

//
// NV10_CELSIUS methods handled in the HAL.
//
static RM_STATUS _nvHalClass056GetState(PHALHWINFO, PGREXCEPTIONDATA);
static RM_STATUS _nvHalClass056SetMaterialEmission(PHALHWINFO, PGREXCEPTIONDATA);
static RM_STATUS _nvHalClass056SetEyeDirection(PHALHWINFO, PGREXCEPTIONDATA);

HALGRMETHOD Nv10CelsiusPrimitiveHalMethods[] =
{
    {_nvHalClass056GetState,             0x010c, 0x010f},
    {_nvHalClass056SetMaterialEmission,  0x1628, 0x1633},
    {_nvHalClass056SetEyeDirection,      0x072c, 0x0737},
};

//
// NV15_CELSIUS / NV11_CELSIUS methods handled in the HAL.
//
static RM_STATUS _nvHalClass096GetState(PHALHWINFO, PGREXCEPTIONDATA);
static RM_STATUS _nvHalClass096SetEyeDirection(PHALHWINFO, PGREXCEPTIONDATA);

HALGRMETHOD Nv15CelsiusPrimitiveHalMethods[] =
{
    {_nvHalClass096GetState,             0x010c, 0x010f},
    {_nvHalClass096SetEyeDirection,      0x072c, 0x0737},
};

//
// HAL graphics method table.
//
HALGRMETHODS nvHalGrMethods_NV10[] =
{
    { NV10_CELSIUS_PRIMITIVE,           Nv10CelsiusPrimitiveHalMethods,
                                        sizeof (Nv10CelsiusPrimitiveHalMethods) / sizeof(HALGRMETHOD)},

    { NV15_CELSIUS_PRIMITIVE,           Nv15CelsiusPrimitiveHalMethods,
                                        sizeof (Nv15CelsiusPrimitiveHalMethods) / sizeof(HALGRMETHOD)},

    // NV11 and NV15 Celsius share the same method struct.
    { NV11_CELSIUS_PRIMITIVE,           Nv15CelsiusPrimitiveHalMethods,
                                        sizeof (Nv15CelsiusPrimitiveHalMethods) / sizeof(HALGRMETHOD)}
};
#define NUM_HALGRMETHODS                sizeof (nvHalGrMethods_NV10) / sizeof (HALGRMETHODS)

RM_STATUS
nvHalGrClassSoftwareMethod_NV10(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    U032 i, j;
    PHWREG nvAddr;

    nvAddr = pHalHwInfo->nvBaseAddr;
    for (i = 0; i < NUM_HALGRMETHODS; i++)
    {
        //
        // Find out if this class has any HAL methods.
        //
        if (nvHalGrMethods_NV10[i].classNum == pGrExceptionData->classNum)
        {
            //
            // See if this particular method is a HAL method.
            //
            for (j = 0; j < nvHalGrMethods_NV10[i].methodMax; j++)
            {
                if ((pGrExceptionData->Offset >= nvHalGrMethods_NV10[i].pMethods[j].Low) &&
                    (pGrExceptionData->Offset < nvHalGrMethods_NV10[i].pMethods[j].High))
                {
                    //
                    // Idle graphics.
                    //
                    GR_DONE();

                    //
                    // Route the method.
                    //
                    pGrExceptionData->MethodStatus = nvHalGrMethods_NV10[i].pMethods[j].Proc(pHalHwInfo, pGrExceptionData);
                    return (RM_OK);
                }
            }
        }
    }

    //
    // HAL didn't service this method.
    // This isn't really an error, since the RM may still want
    // to do something.
    //
    return (RM_ERROR);
}


static RM_STATUS
_nvHalClass056GetState(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    RM_STATUS retval;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalClass056GetState\r\n");

    switch (pGrExceptionData->Data)
    {
        case NV056_GET_STATE_GETSTATE_ALL_STATE:
            retval = nvHalGrGetState_NV10(pHalHwInfo, pGrExceptionData, TRUE);
            break;

        case NV056_GET_STATE_PUTSTATE_ALL_STATE:
            retval = nvHalGrPutState_NV10(pHalHwInfo, pGrExceptionData, TRUE);
            break;

        case NV056_GET_STATE_GETSTATE_SNAPSHOT_PRIM_ASSM:
            retval = nvHalGrGetState_NV10(pHalHwInfo, pGrExceptionData, FALSE);
            break;

        case NV056_GET_STATE_GETSTATE_RELOAD_PRIM_ASSM:
            retval = nvHalGrPutState_NV10(pHalHwInfo, pGrExceptionData, FALSE);
            break;

        default:
            retval = RM_ERR_BAD_ARGUMENT;
    }    

    return retval;
}

static RM_STATUS
_nvHalClass056SetMaterialEmission(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    // workaround for an NV10 bug (fixed in NV15)
    nvHalGrSetMaterialEmission_NV10(pHalHwInfo, pGrExceptionData);
    return RM_OK;
}

static RM_STATUS
_nvHalClass056SetEyeDirection(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    nvHalGrSetEyeDirection_NV10(pHalHwInfo, pGrExceptionData);
    return RM_OK;
}

static RM_STATUS
_nvHalClass096GetState(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    RM_STATUS retval;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalClass056PutState\r\n");

    switch (pGrExceptionData->Data)
    {
        case NV096_GET_STATE_GETSTATE_ALL_STATE:
            retval = nvHalGrGetState_NV10(pHalHwInfo, pGrExceptionData, TRUE);
            break;

        case NV096_GET_STATE_PUTSTATE_ALL_STATE:
            retval = nvHalGrPutState_NV10(pHalHwInfo, pGrExceptionData, TRUE);
            break;

        case NV096_GET_STATE_GETSTATE_SNAPSHOT_PRIM_ASSM:
            retval = nvHalGrGetState_NV10(pHalHwInfo, pGrExceptionData, FALSE);
            break;

        case NV096_GET_STATE_GETSTATE_RELOAD_PRIM_ASSM:
            retval = nvHalGrPutState_NV10(pHalHwInfo, pGrExceptionData, FALSE);
            break;

        default:
            retval = RM_ERR_BAD_ARGUMENT;
    }    

    return retval;
}

static RM_STATUS
_nvHalClass096SetEyeDirection(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    nvHalGrSetEyeDirection_NV10(pHalHwInfo, pGrExceptionData);
    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\gr\nv20\grmdnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: grmdnv20.c                                                        *
*   The graphics chip dependent method routines are kept here.              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// First level method handler.
//
RM_STATUS nvHalGrClassSoftwareMethod_NV20(PHALHWINFO, PGREXCEPTIONDATA);

//
// Externs.
//
extern RM_STATUS nvHalGrGetState_NV20(PHALHWINFO, PGREXCEPTIONDATA, U032);
extern RM_STATUS nvHalGrPutState_NV20(PHALHWINFO, PGREXCEPTIONDATA, U032);
extern RM_STATUS nvHalGrSetEyeDirection_NV20(PHALHWINFO, PGREXCEPTIONDATA);

//
// NV10_CELSIUS methods handled in the HAL.
//
static RM_STATUS _nvHalClass056GetState(PHALHWINFO, PGREXCEPTIONDATA);
static RM_STATUS _nvHalClass056SetEyeDirection(PHALHWINFO, PGREXCEPTIONDATA);

static HALGRMETHOD Nv10CelsiusPrimitiveHalMethods[] =
{
    {_nvHalClass056GetState,             0x010c, 0x010f},
    {_nvHalClass056SetEyeDirection,      0x072c, 0x0737},
};

//
// NV15_CELSIUS / NV11_CELSIUS methods handled in the HAL.
//
static RM_STATUS _nvHalClass096GetState(PHALHWINFO, PGREXCEPTIONDATA);
static RM_STATUS _nvHalClass096SetEyeDirection(PHALHWINFO, PGREXCEPTIONDATA);

static HALGRMETHOD Nv15CelsiusPrimitiveHalMethods[] =
{
    {_nvHalClass096GetState,             0x010c, 0x010f},
    {_nvHalClass096SetEyeDirection,      0x072c, 0x0737},
};

//
// HAL graphics method table.
//
HALGRMETHODS nvHalGrMethods_NV20[] =
{
    { NV10_CELSIUS_PRIMITIVE,           Nv10CelsiusPrimitiveHalMethods,
                                        sizeof (Nv10CelsiusPrimitiveHalMethods) / sizeof(HALGRMETHOD)},

    { NV15_CELSIUS_PRIMITIVE,           Nv15CelsiusPrimitiveHalMethods,
                                        sizeof (Nv15CelsiusPrimitiveHalMethods) / sizeof(HALGRMETHOD)},

    // NV11 and NV15 Celsius share the same method struct.
    { NV11_CELSIUS_PRIMITIVE,           Nv15CelsiusPrimitiveHalMethods,
                                        sizeof (Nv15CelsiusPrimitiveHalMethods) / sizeof(HALGRMETHOD)}
};
#define NUM_HALGRMETHODS                sizeof (nvHalGrMethods_NV20) / sizeof (HALGRMETHODS)

RM_STATUS
nvHalGrClassSoftwareMethod_NV20(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    U032 i, j;
    PHWREG nvAddr;

    nvAddr = pHalHwInfo->nvBaseAddr;
    for (i = 0; i < NUM_HALGRMETHODS; i++)
    {
        //
        // Find out if this class has any HAL methods.
        //
        if (nvHalGrMethods_NV20[i].classNum == pGrExceptionData->classNum)
        {
            //
            // See if this particular method is a HAL method.
            //
            for (j = 0; j < nvHalGrMethods_NV20[i].methodMax; j++)
            {
                if ((pGrExceptionData->Offset >= nvHalGrMethods_NV20[i].pMethods[j].Low) &&
                    (pGrExceptionData->Offset < nvHalGrMethods_NV20[i].pMethods[j].High))
                {
                    //
                    // Idle graphics.
                    //
                    GR_DONE();

                    //
                    // Route the method.
                    //
                    pGrExceptionData->MethodStatus = nvHalGrMethods_NV20[i].pMethods[j].Proc(pHalHwInfo, pGrExceptionData);
                    return (RM_OK);
                }
            }
        }
    }

    //
    // HAL didn't service this method.
    // This isn't really an error, since the RM may still want
    // to do something.
    //
    return (RM_ERROR);
}

static RM_STATUS
_nvHalClass056GetState(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    RM_STATUS retval;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalClass056GetState\r\n");

    switch (pGrExceptionData->Data)
    {
        case NV056_GET_STATE_GETSTATE_ALL_STATE:
            retval = nvHalGrGetState_NV20(pHalHwInfo, pGrExceptionData, TRUE);
            break;

        case NV056_GET_STATE_PUTSTATE_ALL_STATE:
            retval = nvHalGrPutState_NV20(pHalHwInfo, pGrExceptionData, TRUE);
            break;

        case NV056_GET_STATE_GETSTATE_SNAPSHOT_PRIM_ASSM:
            retval = nvHalGrGetState_NV20(pHalHwInfo, pGrExceptionData, FALSE);
            break;

        case NV056_GET_STATE_GETSTATE_RELOAD_PRIM_ASSM:
            retval = nvHalGrPutState_NV20(pHalHwInfo, pGrExceptionData, FALSE);
            break;

        default:
            retval = RM_ERR_BAD_ARGUMENT;
    }    

    return retval;
}

static RM_STATUS
_nvHalClass096GetState(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    RM_STATUS retval;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalClass056PutState\r\n");

    switch (pGrExceptionData->Data)
    {
        case NV096_GET_STATE_GETSTATE_ALL_STATE:
            retval = nvHalGrGetState_NV20(pHalHwInfo, pGrExceptionData, TRUE);
            break;

        case NV096_GET_STATE_PUTSTATE_ALL_STATE:
            retval = nvHalGrPutState_NV20(pHalHwInfo, pGrExceptionData, TRUE);
            break;

        case NV096_GET_STATE_GETSTATE_SNAPSHOT_PRIM_ASSM:
            retval = nvHalGrGetState_NV20(pHalHwInfo, pGrExceptionData, FALSE);
            break;

        case NV096_GET_STATE_GETSTATE_RELOAD_PRIM_ASSM:
            retval = nvHalGrPutState_NV20(pHalHwInfo, pGrExceptionData, FALSE);
            break;

        default:
            retval = RM_ERR_BAD_ARGUMENT;
    }    

    return retval;
}

static RM_STATUS
_nvHalClass056SetEyeDirection(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    nvHalGrSetEyeDirection_NV20(pHalHwInfo, pGrExceptionData);
    return RM_OK;
}

static RM_STATUS
_nvHalClass096SetEyeDirection(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    nvHalGrSetEyeDirection_NV20(pHalHwInfo, pGrExceptionData);
    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\gr\nv20\grcxnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: grcxnv20.c                                                        *
*   The nv20 graphics engine context switching is managed in this module.   *
*   On nv20, context switching is handled in hardware, so all we really     *
*   have to do here is handle methods in the 3d classes that require        *
*   accessing internal pipe state.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include <heap.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
static VOID grUnloadRdiContext(PHALHWINFO, U032, U032, U032, U032 *);
static VOID grLoadRdiContext(PHALHWINFO, U032, U032, U032, U032 *);
RM_STATUS nvHalGrGetState_NV20(PHALHWINFO, PGREXCEPTIONDATA, U032);
RM_STATUS nvHalGrPutState_NV20(PHALHWINFO, PGREXCEPTIONDATA, U032);

RM_STATUS nvHalGrLoadChannelContext_NV20(PHALHWINFO, U032);
RM_STATUS nvHalGrUnloadChannelContext_NV20(PHALHWINFO, U032);

// externs
extern RM_STATUS dmaHalInstanceToHalInfo_NV20(U032, U032, PDMAHALOBJINFO *, PHALHWINFO);

//
// Load Pipe Context
//
#if 0  // static, but never called
static RM_STATUS
grLoadPipeContext(
    PHALHWINFO pHalHwInfo,
    U032       Base,
    U032      *SaveAddr,
    U032       Count
)
{
    U032 i;

    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, Base);
    for (i = 0; i < Count; i++) {
	  REG_WR32(NV_PGRAPH_PIPE_DATA, SaveAddr[i]);
    }
    return (RM_OK);
}

//
// Unload Pipe Context
//
static RM_STATUS
grUnloadPipeContext(
    PHALHWINFO pHalHwInfo,
    U032       Base,
    U032      *SaveAddr,
    U032       Count
)
{
    U032 i;

    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, Base);
    for (i = 0; i < Count; i++) {
	  SaveAddr[i] = REG_RD32(NV_PGRAPH_PIPE_DATA);
    }
    return (RM_OK);
}
#endif

//
// Unload Rdi Context
//
static VOID
grUnloadRdiContext(
    PHALHWINFO pHalHwInfo,
    U032       ramSel,
    U032       offset,
    U032       count,
    U032      *saveAddr
)
{
    U032 i;

    REG_WR32(NV_PGRAPH_RDI_INDEX, (ramSel<<16 | offset));
    for (i = 0; i < count; i++)
        saveAddr[i] = REG_RD32(NV_PGRAPH_RDI_DATA);
}

//
// Load RDI Context
//
static VOID
grLoadRdiContext(
    PHALHWINFO pHalHwInfo,
    U032       ramSel,
    U032       offset,
    U032       count,
    U032      *saveAddr
)
{
    U032 i;

    REG_WR32(NV_PGRAPH_RDI_INDEX, (ramSel<<16 | offset));
    for (i = 0; i < count; i++)
        REG_WR32(NV_PGRAPH_RDI_DATA, saveAddr[i]);
}

RM_STATUS
nvHalGrGetState_NV20(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData, U032 useCtxDma)
{
    PGRHALINFO_NV20 pGrHalPvtInfo;
    U032 ChID;
    U032 access, instance;
    U032 temp;
    NvGraphicsState *stateptr;
    RM_STATUS status;
    PDMAHALOBJINFO pDmaHalInfo;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrGetState\r\n");

    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;
    ChID = pGrExceptionData->ChID;

#ifdef DEBUG
    // we're from a GR exception, so we should be idled/disable already
    if (REG_RD_DRF(_PGRAPH, _FIFO, _ACCESS) || REG_RD32(NV_PGRAPH_STATUS))
        DBG_BREAKPOINT();
#endif

    access = REG_RD32(NV_PGRAPH_FIFO);
    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
    GR_DONE();

    // make sure we're the current channel
    if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) != ChID)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: GetState method issued on non-current channel ", ChID);
        DBG_BREAKPOINT();
        return RM_ERR_INVALID_STATE;
    }

    if (useCtxDma)
    {
        // determine where the ContextDmaState buffer resides
        instance = REG_RD_DRF(_PGRAPH, _GETSTATE, _DMA_INSTANCE);

        if (!instance)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NULL ContextDmaState buffer\n\r");
            DBG_BREAKPOINT();
            return RM_ERR_INVALID_STATE;
        }

        // convert instance address to DmaHalInfo structure
        status = dmaHalInstanceToHalInfo_NV20(ChID, instance, &pDmaHalInfo, pHalHwInfo);
        if (status)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ContextDmaState invalid instance\n\r");
            DBG_BREAKPOINT();
            return RM_ERR_INVALID_STATE;
        }

        if (pDmaHalInfo->BufferSize < sizeof (NvGraphicsState))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ContextDmaState smaller than GetState data\n\r");
            DBG_BREAKPOINT();
            return status;
        }

        stateptr = (NvGraphicsState *)pDmaHalInfo->BufferBase;
    }
    else
    {
        // use the local NvGraphicsState for the Snapshot/Reload interface
        stateptr = &pGrHalPvtInfo->grSnapShots[ChID];
    }

    // first 4 DWORDS of NvGraphicsState is the PerFragment state
    ((U032 *)stateptr)[0] = REG_RD32(NV_PGRAPH_CONTROL_0);
    ((U032 *)stateptr)[1] = REG_RD32(NV_PGRAPH_CONTROL_1);
    ((U032 *)stateptr)[2] = REG_RD32(NV_PGRAPH_CONTROL_2);
    ((U032 *)stateptr)[3] = REG_RD32(NV_PGRAPH_BLEND);

    //
    // Fetch PerVertexState from the VAB.
    //
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_DIFF<<4, 4, (U032 *)(&stateptr->PerVertexState.primaryColor[0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_SPEC<<4, 3, (U032 *)(&stateptr->PerVertexState.secondaryColor[0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_FOG<<4, 1, (U032 *)(&stateptr->PerVertexState.fogCoord));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_TXT0<<4, 4, (U032 *)(&stateptr->PerVertexState.texCoord[0][0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_TXT1<<4, 4, (U032 *)(&stateptr->PerVertexState.texCoord[1][0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_NRM<<4, 3, (U032 *)(&stateptr->PerVertexState.normal[0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_WGHT<<4, 1, (U032 *)(&stateptr->PerVertexState.vertexWeight));

    //
    // Fetch VertexArrayState from IDX_FMT.
    //
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_POS<<3, 2, (U032 *)(&stateptr->VertexArrayState.vertexOffset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_DIFF<<3, 2, (U032 *)(&stateptr->VertexArrayState.diffuseOffset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_SPEC<<3, 2, (U032 *)(&stateptr->VertexArrayState.specularOffset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_TXT0<<3, 2, (U032 *)(&stateptr->VertexArrayState.texCoord0Offset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_TXT1<<3, 2, (U032 *)(&stateptr->VertexArrayState.texCoord1Offset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_NRM<<3, 2, (U032 *)(&stateptr->VertexArrayState.normalOffset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_WGHT<<3, 2, (U032 *)(&stateptr->VertexArrayState.weightOffset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_FOG<<3, 2, (U032 *)(&stateptr->VertexArrayState.fogOffset));

    //
    // Fetch edgeFlag from IDX_FMT (word 48, bit 28).
    //
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, 48<<2, 1, &temp);
    stateptr->PerVertexState.edgeFlag = (temp >> 28) & 1;

    //
    // Fetch PrimitiveAssmState from Cas0/Cas1/Cas2.
    //
    // The nv10 layout (16 word values):
    //
    //  X   Y   Z   W
    //  D   S   F   ef,ptsize
    //  S   T   R   Q
    //  S   T   R   Q
    //
    // The nv20 layout (spread out over 32 word values):
    //
    //  D   S   Z   W
    //  -   -   F   -
    //  S   T   R   Q
    //  S   T   R   Q
    //  -   -   -   -
    //  -   -   -   -
    //  X   Y   ef,ptsize -
    //
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+4]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+5]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+2]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+3]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+6]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+8]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+12]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+7]));

    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+4]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+5]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+2]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+3]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+6]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+8]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+12]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+7]));

    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+4]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+5]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+2]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+3]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+6]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+8]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+12]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+7]));

    GR_DONE();
    REG_WR32(NV_PGRAPH_FIFO, access);

    return RM_OK;
}

RM_STATUS
nvHalGrPutState_NV20(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData, U032 useCtxDma)
{
    PGRHALINFO_NV20 pGrHalPvtInfo;
    U032 access, instance;
    U032 temp;
    NvGraphicsState *stateptr;
    RM_STATUS status;
    PDMAHALOBJINFO pDmaHalInfo;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrPutState\r\n");

    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;

    access = REG_RD32(NV_PGRAPH_FIFO);
    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
    GR_DONE();

    // make sure we're the current channel
    if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) != pGrExceptionData->ChID)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: PutState method issued on non-current channel ", pGrExceptionData->ChID);
        DBG_BREAKPOINT();
        return RM_ERR_INVALID_STATE;
    }

    if (useCtxDma) {
        // determine where the ContextDmaState buffer resides
        instance = REG_RD_DRF(_PGRAPH, _GETSTATE, _DMA_INSTANCE);
        if (!instance)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NULL ContextDmaState buffer\n\r");
            DBG_BREAKPOINT();
            return RM_ERROR;
        }

        // convert instance address to DmaHalInfo structure
        status = dmaHalInstanceToHalInfo_NV20(pGrExceptionData->ChID, instance, &pDmaHalInfo, pHalHwInfo);
        if (status)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid ContextDmaState buffer\n\r");
            DBG_BREAKPOINT();
            return RM_ERR_INVALID_STATE;
        }

        // ensure DmaState buffer is large enough for the GetState data
        if (pDmaHalInfo->BufferSize < sizeof (NvGraphicsState))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ContextDmaState smaller than GetState data\n\r");
            DBG_BREAKPOINT();
            return status;
        }

        stateptr = (NvGraphicsState *)pDmaHalInfo->BufferBase;
    } else {
        // use the local NvGraphicsState for the Snapshot/Reload interface
        stateptr = &pGrHalPvtInfo->grSnapShots[pGrExceptionData->ChID];
    }

    // first 4 DWORDS of NvGraphicsState is the PerFragment state
    REG_WR32(NV_PGRAPH_CONTROL_0, ((U032 *)stateptr)[0]);
    REG_WR32(NV_PGRAPH_CONTROL_1, ((U032 *)stateptr)[1]);
    REG_WR32(NV_PGRAPH_CONTROL_2, ((U032 *)stateptr)[2]);
    REG_WR32(NV_PGRAPH_BLEND,    ((U032 *)stateptr)[3]);

    //
    // Fetch PerVertexState from the VAB.
    //
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_DIFF<<4, 4, (U032 *)(&stateptr->PerVertexState.primaryColor[0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_SPEC<<4, 3, (U032 *)(&stateptr->PerVertexState.secondaryColor[0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_FOG<<4, 1, (U032 *)(&stateptr->PerVertexState.fogCoord));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_TXT0<<4, 4, (U032 *)(&stateptr->PerVertexState.texCoord[0][0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_TXT1<<4, 4, (U032 *)(&stateptr->PerVertexState.texCoord[1][0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_NRM<<4, 3, (U032 *)(&stateptr->PerVertexState.normal[0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_WGHT<<4, 1, (U032 *)(&stateptr->PerVertexState.vertexWeight));

    //
    // Fetch VertexArrayState from IDX_FMT.
    //
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_POS<<3, 2, (U032 *)(&stateptr->VertexArrayState.vertexOffset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_DIFF<<3, 2, (U032 *)(&stateptr->VertexArrayState.diffuseOffset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_SPEC<<3, 2, (U032 *)(&stateptr->VertexArrayState.specularOffset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_TXT0<<3, 2, (U032 *)(&stateptr->VertexArrayState.texCoord0Offset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_TXT1<<3, 2, (U032 *)(&stateptr->VertexArrayState.texCoord1Offset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_NRM<<3, 2, (U032 *)(&stateptr->VertexArrayState.normalOffset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_WGHT<<3, 2, (U032 *)(&stateptr->VertexArrayState.weightOffset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_FOG<<3, 2, (U032 *)(&stateptr->VertexArrayState.fogOffset));

    //
    // Fetch edgeFlag from IDX_FMT (word 48, bit 28).
    //
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, 48<<2, 1, &temp);
    temp &= ~0x10000000;
    temp |= ((stateptr->PerVertexState.edgeFlag & 1) << 28);
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, 48<<2, 1, &temp);

    //
    // Fetch PrimitiveAssmState from Cas0/Cas1/Cas2.
    //
    // The nv10 layout (16 word values):
    //
    //  X   Y   Z   W
    //  D   S   F   ef,ptsize
    //  S   T   R   Q
    //  S   T   R   Q
    //
    // The nv20 layout (spread out over 32 word values):
    //
    //  D   S   Z   W
    //  -   -   F   -
    //  S   T   R   Q
    //  S   T   R   Q
    //  -   -   -   -
    //  -   -   -   -
    //  X   Y   ef,ptsize -
    //
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+4]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+5]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+2]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+3]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+6]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+8]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+12]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+7]));

    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+4]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+5]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+2]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+3]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+6]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+8]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+12]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+7]));

    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+4]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+5]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+2]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+3]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+6]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+8]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+12]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+7]));

    GR_DONE();
    REG_WR32(NV_PGRAPH_FIFO, access);

    return RM_OK;
}

//
// This method gives D3D access to the eye direction state.
// It would be nice to go thru RDI for this, but it turned
// out to be too problematic so we use PIPE_ADDRESS/PIPE_DATA
// instead.
//
RM_STATUS nvHalGrSetEyeDirection_NV20
(
    PHALHWINFO pHalHwInfo,
    PGREXCEPTIONDATA pGrExceptionData
)
{
    U032 offset = (pGrExceptionData->Offset - NV056_SET_EYE_DIRECTION_SW(0))/4;

    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, NV_IGRAPH_XF2PIPE(NV_IGRAPH_XF_CMD_LTCTX,NV_IGRAPH_XF_LTCTX_EYED<<4) + (offset<<2));
    REG_WR32(NV_PGRAPH_PIPE_DATA, pGrExceptionData->Data);
    GR_DONE();

    return (RM_OK);
}

RM_STATUS
nvHalGrLoadChannelContext_NV20
(
    PHALHWINFO pHalHwInfo,
    U032 ChID
)
{
    PGRHALINFO_NV20 pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;
    U032 misc;

    //
    // Service any outstanding graphics exceptions.
    //
    if (REG_RD32(NV_PGRAPH_INTR))
        HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);
        
    //
    // Save current graphics interface state.
    //
    GR_SAVE_STATE(misc);
    HAL_GR_IDLE(pHalHwInfo);

    //
    // Unload current context.
    //   
    if (pGrHalPvtInfo->currentChID != ChID) {
        (void) nvHalGrUnloadChannelContext_NV20(pHalHwInfo, pGrHalPvtInfo->currentChID);
    }

    //
    // If the incoming channel is our "invalid" channel, then
    // invalidate and we're done.
    //
    if ((pGrHalPvtInfo->currentChID = ChID) == NUM_FIFOS_NV20)
    {
        REG_WR32(NV_PGRAPH_CTX_CONTROL,
                 DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US) |
                 DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME, _NOT_EXPIRED) |
                 DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID, _INVALID) |
                 DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING, _IDLE) |
                 DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE, _ENABLED));
        REG_WR_DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS, _VALID);

        //
        // Restore graphics interface state.
        //
		misc |= DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
        GR_RESTORE_STATE(misc); // FIFO reenabled in here

        return (RM_OK);
    }
    else if (ChID > NUM_FIFOS_NV20)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid Channel on Graphics Context Switch:", ChID);
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }

    //
    // If we have 3D state in this channel, then we need to
    // workaround a problem with FD state (see magnus' chsw3.c
    // diag in //hw/nv20/diag/tests/src for more info).
    //
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0)
    {
        U032 i;

        // Reset IDX/VTX/CAS state.
        REG_WR32(NV_PGRAPH_DEBUG_0,
                 DRF_DEF(_PGRAPH, _DEBUG_0, _IDX_STATE, _RESET) |
                 DRF_DEF(_PGRAPH, _DEBUG_0, _VTX_STATE, _RESET) |
                 DRF_DEF(_PGRAPH, _DEBUG_0, _CAS_STATE, _RESET));
        i = REG_RD32(NV_PGRAPH_DEBUG_0);
        REG_WR32(NV_PGRAPH_DEBUG_0, 0x0);
        i = REG_RD32(NV_PGRAPH_DEBUG_0);

        // Clear FD mode by writing 0 to all FD registers.
        REG_WR32(NV_PGRAPH_RDI_INDEX,
                 DRF_NUM(_PGRAPH, _RDI_INDEX, _SELECT, RDI_RAMSEL_FD_CTRL) |
                 DRF_NUM(_PGRAPH, _RDI_INDEX, _ADDRESS, 0));
        for (i = 0; i < 15; i++)
            REG_WR32(NV_PGRAPH_RDI_DATA, 0);
    }

    //
    // Invalidate tcache.
    //
    FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_1, _CACHE, _INVALIDATE);

    REG_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, ChID);

    //
    // Load new context.
    //
    REG_WR_DRF_NUM(_PGRAPH, _CHANNEL_CTX_POINTER, _INST, pGrHalPvtInfo->CtxTable[ChID]);
    REG_WR_DRF_DEF(_PGRAPH, _CHANNEL_CTX_TRIGGER, _READ_IN, _ACTIVATE);

    HAL_GR_IDLE(pHalHwInfo);

    //
    // Update hardware with new chid.
    // 
    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, ChID);
    REG_WR32(NV_PGRAPH_CTX_CONTROL,
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME, _NOT_EXPIRED) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID, _VALID) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING, _IDLE) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE, _ENABLED));

    REG_WR32(NV_PGRAPH_FFINTFC_ST2, REG_RD32(NV_PGRAPH_FFINTFC_ST2) & 0xCFFFFFFF);

    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
    return (RM_OK);
}

RM_STATUS
nvHalGrUnloadChannelContext_NV20
(
    PHALHWINFO pHalHwInfo,
    U032 ChID
)
{
    PGRHALINFO_NV20 pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;

    //
    // No need to unload an invalid channel
    //
    if (ChID == NUM_FIFOS_NV20)
        return (RM_OK);

    //
    // Unload context.
    //
    REG_WR_DRF_NUM(_PGRAPH, _CHANNEL_CTX_POINTER, _INST, pGrHalPvtInfo->CtxTable[ChID]);
    REG_WR_DRF_DEF(_PGRAPH, _CHANNEL_CTX_TRIGGER, _WRITE_OUT, _ACTIVATE);

    HAL_GR_IDLE(pHalHwInfo);

    //
    // Invalidate hw's channel ID.
    //
    REG_WR32(NV_PGRAPH_CTX_CONTROL,
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME, _EXPIRED) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID, _INVALID) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING, _IDLE) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE, _ENABLED));

    return (RM_OK);
}

#ifdef NV20_SW_CTX_SWITCH
RM_STATUS nvHalGrLoadChannelContext_NV20(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PGRHALINFO_NV20 pGrHalPvtInfo = (PGRHALINFO_NV20) pHalHwInfo->pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV20 pSwCtxTable = (PGRAPHICSCHANNEL_NV20) pGrHalPvtInfo->SwCtxTable;

    int i, status;
    U032 debug_1;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrLoadChannelContext_NV20\r\n");

    //
    // Service any outstanding graphics exceptions.
    //
    if (REG_RD32(NV_PGRAPH_INTR))
        HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);

    HAL_GR_IDLE(pHalHwInfo);

    //
    // Unload current context.
    //   
    if (pGrHalPvtInfo->currentChID != ChID)
    {
        nvHalGrUnloadChannelContext_NV20(pHalHwInfo,
                                         pGrHalPvtInfo->currentChID,
                                         &pGrHalPvtInfo->SwCtxTable[pGrHalPvtInfo->currentChID]);
    }

    debug_1 = REG_RD32(NV_PGRAPH_DEBUG_1);
    REG_WR32(NV_PGRAPH_DEBUG_1, debug_1 | DRF_DEF(_PGRAPH,_DEBUG_1,_CACHE,_INVALIDATE));
    
    REG_WR32(NV_PGRAPH_CTX_USER, pSwCtxTable[ChID].grCtxCmn.ContextUser);
    
    //
    // Reload context state
    //
    REG_WR32(NV_PGRAPH_CTX_SWITCH1,       pSwCtxTable[ChID].grCtxCmn.ContextSwitch1);
    REG_WR32(NV_PGRAPH_CTX_SWITCH2,       pSwCtxTable[ChID].grCtxCmn.ContextSwitch2);
    REG_WR32(NV_PGRAPH_CTX_SWITCH3,       pSwCtxTable[ChID].grCtxCmn.ContextSwitch3);
    REG_WR32(NV_PGRAPH_CTX_SWITCH4,       pSwCtxTable[ChID].grCtxCmn.ContextSwitch4);
    REG_WR32(NV_PGRAPH_CTX_SWITCH5,       pSwCtxTable[ChID].grCtxCmn.ContextSwitch5);
    
    for (i = 0; i < 8; i++)
      REG_WR32(NV_PGRAPH_CTX_CACHE1(i),   pSwCtxTable[ChID].grCtxCmn.ContextCache1[i]);
    
    for (i = 0; i < 8; i++)
      REG_WR32(NV_PGRAPH_CTX_CACHE2(i),   pSwCtxTable[ChID].grCtxCmn.ContextCache2[i]);
    
    for (i = 0; i < 8; i++)
      REG_WR32(NV_PGRAPH_CTX_CACHE3(i),   pSwCtxTable[ChID].grCtxCmn.ContextCache3[i]);
    
    for (i = 0; i < 8; i++)
      REG_WR32(NV_PGRAPH_CTX_CACHE4(i),   pSwCtxTable[ChID].grCtxCmn.ContextCache4[i]);
    
    for (i = 0; i < 8; i++)
      REG_WR32(NV_PGRAPH_CTX_CACHE5(i),   pSwCtxTable[ChID].grCtxCmn.ContextCache5[i]);
    
    
    REG_WR32(NV_PGRAPH_MONO_COLOR0,       pSwCtxTable[ChID].grCtxCmn.MonoColor0);
    REG_WR32(NV_PGRAPH_BSWIZZLE2,         pSwCtxTable[ChID].grCtxCmn.BufferSwizzle2);        
    REG_WR32(NV_PGRAPH_BSWIZZLE5,         pSwCtxTable[ChID].grCtxCmn.BufferSwizzle5);        
    
    for (i = 0; i < 6; i++)
      REG_WR32(NV_PGRAPH_BOFFSET(i),      pSwCtxTable[ChID].grCtxCmn.BufferOffset[i]);
    
    for (i = 0; i < 6; i++)
      REG_WR32(NV_PGRAPH_BBASE(i),        pSwCtxTable[ChID].grCtxCmn.BufferBase[i]);
    
    for (i = 0; i < 5; i++)
      REG_WR32(NV_PGRAPH_BPITCH(i),       pSwCtxTable[ChID].grCtxCmn.BufferPitch[i]);
    
    for (i = 0; i < 6; i++)
      REG_WR32(NV_PGRAPH_BLIMIT(i),       pSwCtxTable[ChID].grCtxCmn.BufferLimit[i]);
    
    REG_WR32(NV_PGRAPH_CHROMA,            pSwCtxTable[ChID].grCtxCmn.Chroma);
    REG_WR32(NV_PGRAPH_SURFACE,           pSwCtxTable[ChID].grCtxCmn.Surface);        
    REG_WR32(NV_PGRAPH_STATE,             pSwCtxTable[ChID].grCtxCmn.State);        
    REG_WR32(NV_PGRAPH_NOTIFY,            pSwCtxTable[ChID].grCtxCmn.Notify);
    
    REG_WR32(NV_PGRAPH_BPIXEL,            pSwCtxTable[ChID].grCtxCmn.BufferPixel);
    
    REG_WR32(NV_PGRAPH_DMA_PITCH,         pSwCtxTable[ChID].grCtxCmn.DmaPitch);
    
    REG_WR32(NV_PGRAPH_DVD_COLORFMT,      pSwCtxTable[ChID].grCtxCmn.DvdColorFmt);    
    REG_WR32(NV_PGRAPH_SCALED_FORMAT,     pSwCtxTable[ChID].grCtxCmn.ScaledFormat);    
    
    REG_WR32(NV_PGRAPH_PATT_COLOR0,       pSwCtxTable[ChID].grCtxCmn.PatternColor0);    
    REG_WR32(NV_PGRAPH_PATT_COLOR1,       pSwCtxTable[ChID].grCtxCmn.PatternColor1);
    
    REG_WR32(NV_PGRAPH_PATTERN(0),        pSwCtxTable[ChID].grCtxCmn.Pattern[0]);
    REG_WR32(NV_PGRAPH_PATTERN(1),        pSwCtxTable[ChID].grCtxCmn.Pattern[1]);
    REG_WR32(NV_PGRAPH_PATTERN_SHAPE,     pSwCtxTable[ChID].grCtxCmn.PatternShape);
    
    for (i = 0; i < 64; i++)
      REG_WR32(NV_PGRAPH_PATT_COLORRAM(i), pSwCtxTable[ChID].grCtxCmn.PattColorRam[i]);
    
    REG_WR32(NV_PGRAPH_ROP3,              pSwCtxTable[ChID].grCtxCmn.Rop3);
    REG_WR32(NV_PGRAPH_BETA_AND,          pSwCtxTable[ChID].grCtxCmn.BetaAnd);
    REG_WR32(NV_PGRAPH_BETA_PREMULT,      pSwCtxTable[ChID].grCtxCmn.BetaPreMult);
    
    REG_WR32(NV_PGRAPH_STORED_FMT,        pSwCtxTable[ChID].grCtxCmn.StoredFmt);
    
    for (i = 0; i < 10; i++)
      REG_WR32(NV_PGRAPH_ABS_X_RAM(i),    pSwCtxTable[ChID].grCtxCmn.AbsXRam[i]);
    
    for (i = 0; i < 10; i++)
      REG_WR32(NV_PGRAPH_ABS_Y_RAM(i),    pSwCtxTable[ChID].grCtxCmn.AbsYRam[i]);
    
    REG_WR32(NV_PGRAPH_ABS_ICLIP_XMAX,    pSwCtxTable[ChID].grCtxCmn.AbsIClipXMax);
    REG_WR32(NV_PGRAPH_ABS_ICLIP_YMAX,    pSwCtxTable[ChID].grCtxCmn.AbsIClipYMax);
    
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMIN,    pSwCtxTable[ChID].grCtxCmn.AbsUClipXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMAX,    pSwCtxTable[ChID].grCtxCmn.AbsUClipXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMIN,    pSwCtxTable[ChID].grCtxCmn.AbsUClipYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMAX,    pSwCtxTable[ChID].grCtxCmn.AbsUClipYMax);
    
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_XMIN,   pSwCtxTable[ChID].grCtxCmn.AbsUClipAXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_XMAX,   pSwCtxTable[ChID].grCtxCmn.AbsUClipAXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_YMIN,   pSwCtxTable[ChID].grCtxCmn.AbsUClipAYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_YMAX,   pSwCtxTable[ChID].grCtxCmn.AbsUClipAYMax);
    
    REG_WR32(NV_PGRAPH_SOURCE_COLOR,      pSwCtxTable[ChID].grCtxCmn.SourceColor);
    REG_WR32(NV_PGRAPH_MISC24_0,          pSwCtxTable[ChID].grCtxCmn.Misc24_0);
    
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC0,    pSwCtxTable[ChID].grCtxCmn.XYLogicMisc0);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC1,    pSwCtxTable[ChID].grCtxCmn.XYLogicMisc1);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC2,    pSwCtxTable[ChID].grCtxCmn.XYLogicMisc2);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC3,    pSwCtxTable[ChID].grCtxCmn.XYLogicMisc3);
    
    REG_WR32(NV_PGRAPH_CLIPX_0,           pSwCtxTable[ChID].grCtxCmn.ClipX0);
    REG_WR32(NV_PGRAPH_CLIPX_1,           pSwCtxTable[ChID].grCtxCmn.ClipX1);
    REG_WR32(NV_PGRAPH_CLIPY_0,           pSwCtxTable[ChID].grCtxCmn.ClipY0);
    REG_WR32(NV_PGRAPH_CLIPY_1,           pSwCtxTable[ChID].grCtxCmn.ClipY1);
    
    REG_WR32(NV_PGRAPH_PASSTHRU_0,        pSwCtxTable[ChID].grCtxCmn.Passthru0);    
    REG_WR32(NV_PGRAPH_PASSTHRU_1,        pSwCtxTable[ChID].grCtxCmn.Passthru1);    
    REG_WR32(NV_PGRAPH_PASSTHRU_2,        pSwCtxTable[ChID].grCtxCmn.Passthru2);    
    
    REG_WR32(NV_PGRAPH_DIMX_TEXTURE,      pSwCtxTable[ChID].grCtxCmn.DimxTexture);    
    REG_WR32(NV_PGRAPH_WDIMX_TEXTURE,     pSwCtxTable[ChID].grCtxCmn.WdimxTexture);    
    
    REG_WR32(NV_PGRAPH_DMA_START_0,       pSwCtxTable[ChID].grCtxCmn.DmaStart0);
    REG_WR32(NV_PGRAPH_DMA_START_1,       pSwCtxTable[ChID].grCtxCmn.DmaStart1);
    REG_WR32(NV_PGRAPH_DMA_LENGTH,        pSwCtxTable[ChID].grCtxCmn.DmaLength);
    REG_WR32(NV_PGRAPH_DMA_MISC,          pSwCtxTable[ChID].grCtxCmn.DmaMisc);
    
    REG_WR32(NV_PGRAPH_MISC24_1,          pSwCtxTable[ChID].grCtxCmn.Misc24_1);
    REG_WR32(NV_PGRAPH_MISC24_2,          pSwCtxTable[ChID].grCtxCmn.Misc24_2);
    REG_WR32(NV_PGRAPH_X_MISC,            pSwCtxTable[ChID].grCtxCmn.XMisc);
    REG_WR32(NV_PGRAPH_Y_MISC,            pSwCtxTable[ChID].grCtxCmn.YMisc);
    REG_WR32(NV_PGRAPH_VALID1,            pSwCtxTable[ChID].grCtxCmn.Valid1);
    
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0) {
        // 3D stuff
        REG_WR32(NV_PGRAPH_DEBUG_0, 0x0007000); //reset IDX, VTX and CAS
        REG_RD32(NV_PGRAPH_DEBUG_0);
        REG_WR32(NV_PGRAPH_DEBUG_0, 0x0);
        
        REG_WR32(NV_PGRAPH_ANTIALIASING,      pSwCtxTable[ChID].grCtx3d.AntiAliasing);
        REG_WR32(NV_PGRAPH_BLEND,             pSwCtxTable[ChID].grCtx3d.Blend);
        REG_WR32(NV_PGRAPH_BLENDCOLOR,        pSwCtxTable[ChID].grCtx3d.BlendColor);
        REG_WR32(NV_PGRAPH_BORDERCOLOR0,      pSwCtxTable[ChID].grCtx3d.BorderColor0);
        REG_WR32(NV_PGRAPH_BORDERCOLOR1,      pSwCtxTable[ChID].grCtx3d.BorderColor1);
        REG_WR32(NV_PGRAPH_BORDERCOLOR2,      pSwCtxTable[ChID].grCtx3d.BorderColor2);
        REG_WR32(NV_PGRAPH_BORDERCOLOR3,      pSwCtxTable[ChID].grCtx3d.BorderColor3);
        
        REG_WR32(NV_PGRAPH_BUMPMAT00_1,       pSwCtxTable[ChID].grCtx3d.BumpMat00_1);
        REG_WR32(NV_PGRAPH_BUMPMAT00_2,       pSwCtxTable[ChID].grCtx3d.BumpMat00_2);
        REG_WR32(NV_PGRAPH_BUMPMAT00_3,       pSwCtxTable[ChID].grCtx3d.BumpMat00_3);
        REG_WR32(NV_PGRAPH_BUMPMAT01_1,       pSwCtxTable[ChID].grCtx3d.BumpMat01_1);
        REG_WR32(NV_PGRAPH_BUMPMAT01_2,       pSwCtxTable[ChID].grCtx3d.BumpMat01_2);
        REG_WR32(NV_PGRAPH_BUMPMAT01_3,       pSwCtxTable[ChID].grCtx3d.BumpMat01_3);
        REG_WR32(NV_PGRAPH_BUMPMAT10_1,       pSwCtxTable[ChID].grCtx3d.BumpMat10_1);
        REG_WR32(NV_PGRAPH_BUMPMAT10_2,       pSwCtxTable[ChID].grCtx3d.BumpMat10_2);
        REG_WR32(NV_PGRAPH_BUMPMAT10_3,       pSwCtxTable[ChID].grCtx3d.BumpMat10_3);
        REG_WR32(NV_PGRAPH_BUMPMAT11_1,       pSwCtxTable[ChID].grCtx3d.BumpMat11_1);
        REG_WR32(NV_PGRAPH_BUMPMAT11_2,       pSwCtxTable[ChID].grCtx3d.BumpMat11_2);
        REG_WR32(NV_PGRAPH_BUMPMAT11_3,       pSwCtxTable[ChID].grCtx3d.BumpMat11_3);
        
        REG_WR32(NV_PGRAPH_BUMPOFFSET1,       pSwCtxTable[ChID].grCtx3d.BumpOffset1);
        REG_WR32(NV_PGRAPH_BUMPOFFSET2,       pSwCtxTable[ChID].grCtx3d.BumpOffset2);
        REG_WR32(NV_PGRAPH_BUMPOFFSET3,       pSwCtxTable[ChID].grCtx3d.BumpOffset3);
        
        REG_WR32(NV_PGRAPH_BUMPSCALE1,        pSwCtxTable[ChID].grCtx3d.BumpScale1);
        REG_WR32(NV_PGRAPH_BUMPSCALE2,        pSwCtxTable[ChID].grCtx3d.BumpScale2);
        REG_WR32(NV_PGRAPH_BUMPSCALE3,        pSwCtxTable[ChID].grCtx3d.BumpScale3);
        
        REG_WR32(NV_PGRAPH_CLEARRECTX,        pSwCtxTable[ChID].grCtx3d.ClearRectX);
        REG_WR32(NV_PGRAPH_CLEARRECTY,        pSwCtxTable[ChID].grCtx3d.ClearRectY);
        
        REG_WR32(NV_PGRAPH_COLORCLEARVALUE,   pSwCtxTable[ChID].grCtx3d.ColorClearValue);
        
        REG_WR32(NV_PGRAPH_COLORKEYCOLOR0,    pSwCtxTable[ChID].grCtx3d.ColorKeyColor0);
        REG_WR32(NV_PGRAPH_COLORKEYCOLOR1,    pSwCtxTable[ChID].grCtx3d.ColorKeyColor1);
        REG_WR32(NV_PGRAPH_COLORKEYCOLOR2,    pSwCtxTable[ChID].grCtx3d.ColorKeyColor2);
        REG_WR32(NV_PGRAPH_COLORKEYCOLOR3,    pSwCtxTable[ChID].grCtx3d.ColorKeyColor3);
        
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_0,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_0);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_1,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_1);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_2,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_2);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_3,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_3);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_4,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_4);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_5,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_5);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_6,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_6);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_7,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_7);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_0,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_0);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_1,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_1);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_2,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_2);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_3,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_3);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_4,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_4);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_5,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_5);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_6,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_6);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_7,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_7);
        
        REG_WR32(NV_PGRAPH_COMBINEALPHAI0,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI0);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI1,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI1);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI2,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI2);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI3,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI3);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI4,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI4);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI5,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI5);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI6,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI6);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI7,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI7);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO0,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO0);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO1,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO1);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO2,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO2);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO3,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO3);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO4,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO4);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO5,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO5);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO6,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO6);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO7,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO7);
        
        REG_WR32(NV_PGRAPH_COMBINECOLORI0,    pSwCtxTable[ChID].grCtx3d.CombineColorI0);
        REG_WR32(NV_PGRAPH_COMBINECOLORI1,    pSwCtxTable[ChID].grCtx3d.CombineColorI1);
        REG_WR32(NV_PGRAPH_COMBINECOLORI2,    pSwCtxTable[ChID].grCtx3d.CombineColorI2);
        REG_WR32(NV_PGRAPH_COMBINECOLORI3,    pSwCtxTable[ChID].grCtx3d.CombineColorI3);
        REG_WR32(NV_PGRAPH_COMBINECOLORI4,    pSwCtxTable[ChID].grCtx3d.CombineColorI4);
        REG_WR32(NV_PGRAPH_COMBINECOLORI5,    pSwCtxTable[ChID].grCtx3d.CombineColorI5);
        REG_WR32(NV_PGRAPH_COMBINECOLORI6,    pSwCtxTable[ChID].grCtx3d.CombineColorI6);
        REG_WR32(NV_PGRAPH_COMBINECOLORI7,    pSwCtxTable[ChID].grCtx3d.CombineColorI7);
        REG_WR32(NV_PGRAPH_COMBINECOLORO0,    pSwCtxTable[ChID].grCtx3d.CombineColorO0);
        REG_WR32(NV_PGRAPH_COMBINECOLORO1,    pSwCtxTable[ChID].grCtx3d.CombineColorO1);
        REG_WR32(NV_PGRAPH_COMBINECOLORO2,    pSwCtxTable[ChID].grCtx3d.CombineColorO2);
        REG_WR32(NV_PGRAPH_COMBINECOLORO3,    pSwCtxTable[ChID].grCtx3d.CombineColorO3);
        REG_WR32(NV_PGRAPH_COMBINECOLORO4,    pSwCtxTable[ChID].grCtx3d.CombineColorO4);
        REG_WR32(NV_PGRAPH_COMBINECOLORO5,    pSwCtxTable[ChID].grCtx3d.CombineColorO5);
        REG_WR32(NV_PGRAPH_COMBINECOLORO6,    pSwCtxTable[ChID].grCtx3d.CombineColorO6);
        REG_WR32(NV_PGRAPH_COMBINECOLORO7,    pSwCtxTable[ChID].grCtx3d.CombineColorO7);
        
        REG_WR32(NV_PGRAPH_COMBINECTL,        pSwCtxTable[ChID].grCtx3d.CombineCtl);
        
        REG_WR32(NV_PGRAPH_COMBINESPECFOG0,   pSwCtxTable[ChID].grCtx3d.CombineSpecFog0);
        REG_WR32(NV_PGRAPH_COMBINESPECFOG1,   pSwCtxTable[ChID].grCtx3d.CombineSpecFog1);
        
        REG_WR32(NV_PGRAPH_CONTROL_0,         pSwCtxTable[ChID].grCtx3d.Control0);
        REG_WR32(NV_PGRAPH_CONTROL_1,         pSwCtxTable[ChID].grCtx3d.Control1);
        REG_WR32(NV_PGRAPH_CONTROL_2,         pSwCtxTable[ChID].grCtx3d.Control2);
        REG_WR32(NV_PGRAPH_CONTROL_3,         pSwCtxTable[ChID].grCtx3d.Control3);
        
        REG_WR32(NV_PGRAPH_FOGCOLOR,          pSwCtxTable[ChID].grCtx3d.FogColor);
        REG_WR32(NV_PGRAPH_FOGPARAM0,         pSwCtxTable[ChID].grCtx3d.FogParam0);
        REG_WR32(NV_PGRAPH_FOGPARAM1,         pSwCtxTable[ChID].grCtx3d.FogParam1);
        REG_WR32(NV_PGRAPH_POINTSIZE,         pSwCtxTable[ChID].grCtx3d.PointSize);
        REG_WR32(NV_PGRAPH_SETUPRASTER,       pSwCtxTable[ChID].grCtx3d.SetupRaster);
        
        REG_WR32(NV_PGRAPH_SHADERCLIPMODE,    pSwCtxTable[ChID].grCtx3d.ShaderClipMode);
        REG_WR32(NV_PGRAPH_SHADERCTL,         pSwCtxTable[ChID].grCtx3d.ShaderCtl);
        REG_WR32(NV_PGRAPH_SHADERPROG,        pSwCtxTable[ChID].grCtx3d.ShaderProg);
        
        REG_WR32(NV_PGRAPH_SEMAPHOREOFFSET,   pSwCtxTable[ChID].grCtx3d.SemaphoreOffset);
        REG_WR32(NV_PGRAPH_SHADOWCTL,         pSwCtxTable[ChID].grCtx3d.ShadowCtl);
        REG_WR32(NV_PGRAPH_SHADOWZSLOPETHRESHOLD, pSwCtxTable[ChID].grCtx3d.ShadowZSlopeThreshold);
        
        REG_WR32(NV_PGRAPH_SPECFOGFACTOR0,    pSwCtxTable[ChID].grCtx3d.SpecFogFactor0);
        REG_WR32(NV_PGRAPH_SPECFOGFACTOR1,    pSwCtxTable[ChID].grCtx3d.SpecFogFactor1);
        
        REG_WR32(NV_PGRAPH_SURFACECLIPX,      pSwCtxTable[ChID].grCtx3d.SurfaceClipX);
        REG_WR32(NV_PGRAPH_SURFACECLIPY,      pSwCtxTable[ChID].grCtx3d.SurfaceClipY);
        
        REG_WR32(NV_PGRAPH_TEXADDRESS0,       pSwCtxTable[ChID].grCtx3d.TexAddress0);
        REG_WR32(NV_PGRAPH_TEXADDRESS1,       pSwCtxTable[ChID].grCtx3d.TexAddress1);
        REG_WR32(NV_PGRAPH_TEXADDRESS2,       pSwCtxTable[ChID].grCtx3d.TexAddress2);
        REG_WR32(NV_PGRAPH_TEXADDRESS3,       pSwCtxTable[ChID].grCtx3d.TexAddress3);
        
        REG_WR32(NV_PGRAPH_TEXCTL0_0,         pSwCtxTable[ChID].grCtx3d.TexCtl0_0);
        REG_WR32(NV_PGRAPH_TEXCTL0_1,         pSwCtxTable[ChID].grCtx3d.TexCtl0_1);
        REG_WR32(NV_PGRAPH_TEXCTL0_2,         pSwCtxTable[ChID].grCtx3d.TexCtl0_2);
        REG_WR32(NV_PGRAPH_TEXCTL0_3,         pSwCtxTable[ChID].grCtx3d.TexCtl0_3);
        
        REG_WR32(NV_PGRAPH_TEXCTL1_0,         pSwCtxTable[ChID].grCtx3d.TexCtl1_0);
        REG_WR32(NV_PGRAPH_TEXCTL1_1,         pSwCtxTable[ChID].grCtx3d.TexCtl1_1);
        REG_WR32(NV_PGRAPH_TEXCTL1_2,         pSwCtxTable[ChID].grCtx3d.TexCtl1_2);
        REG_WR32(NV_PGRAPH_TEXCTL1_3,         pSwCtxTable[ChID].grCtx3d.TexCtl1_3);
        
        REG_WR32(NV_PGRAPH_TEXCTL2_0,         pSwCtxTable[ChID].grCtx3d.TexCtl2_0);
        REG_WR32(NV_PGRAPH_TEXCTL2_1,         pSwCtxTable[ChID].grCtx3d.TexCtl2_1);
        
        REG_WR32(NV_PGRAPH_TEXFILTER0,        pSwCtxTable[ChID].grCtx3d.TexFilter0);
        REG_WR32(NV_PGRAPH_TEXFILTER1,        pSwCtxTable[ChID].grCtx3d.TexFilter1);
        REG_WR32(NV_PGRAPH_TEXFILTER2,        pSwCtxTable[ChID].grCtx3d.TexFilter2);
        REG_WR32(NV_PGRAPH_TEXFILTER3,        pSwCtxTable[ChID].grCtx3d.TexFilter3);
        
        REG_WR32(NV_PGRAPH_TEXFMT0,           pSwCtxTable[ChID].grCtx3d.TexFormat0);
        REG_WR32(NV_PGRAPH_TEXFMT1,           pSwCtxTable[ChID].grCtx3d.TexFormat1);
        REG_WR32(NV_PGRAPH_TEXFMT2,           pSwCtxTable[ChID].grCtx3d.TexFormat2);
        REG_WR32(NV_PGRAPH_TEXFMT3,           pSwCtxTable[ChID].grCtx3d.TexFormat3);
        
        REG_WR32(NV_PGRAPH_TEXIMAGERECT0,     pSwCtxTable[ChID].grCtx3d.TexImageRect0);
        REG_WR32(NV_PGRAPH_TEXIMAGERECT1,     pSwCtxTable[ChID].grCtx3d.TexImageRect1);
        REG_WR32(NV_PGRAPH_TEXIMAGERECT2,     pSwCtxTable[ChID].grCtx3d.TexImageRect2);
        REG_WR32(NV_PGRAPH_TEXIMAGERECT3,     pSwCtxTable[ChID].grCtx3d.TexImageRect3);
        
        REG_WR32(NV_PGRAPH_TEXOFFSET0,        pSwCtxTable[ChID].grCtx3d.TexOffset0);
        REG_WR32(NV_PGRAPH_TEXOFFSET1,        pSwCtxTable[ChID].grCtx3d.TexOffset1);
        REG_WR32(NV_PGRAPH_TEXOFFSET2,        pSwCtxTable[ChID].grCtx3d.TexOffset2);
        REG_WR32(NV_PGRAPH_TEXOFFSET3,        pSwCtxTable[ChID].grCtx3d.TexOffset3);
        
        REG_WR32(NV_PGRAPH_TEXPALETTE0,       pSwCtxTable[ChID].grCtx3d.TexPallete0);
        REG_WR32(NV_PGRAPH_TEXPALETTE1,       pSwCtxTable[ChID].grCtx3d.TexPallete1);
        REG_WR32(NV_PGRAPH_TEXPALETTE2,       pSwCtxTable[ChID].grCtx3d.TexPallete2);
        REG_WR32(NV_PGRAPH_TEXPALETTE3,       pSwCtxTable[ChID].grCtx3d.TexPallete3);
        
        REG_WR32(NV_PGRAPH_WINDOWCLIPX0,      pSwCtxTable[ChID].grCtx3d.WindowClipX[0]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX1,      pSwCtxTable[ChID].grCtx3d.WindowClipX[1]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX2,      pSwCtxTable[ChID].grCtx3d.WindowClipX[2]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX3,      pSwCtxTable[ChID].grCtx3d.WindowClipX[3]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX4,      pSwCtxTable[ChID].grCtx3d.WindowClipX[4]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX5,      pSwCtxTable[ChID].grCtx3d.WindowClipX[5]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX6,      pSwCtxTable[ChID].grCtx3d.WindowClipX[6]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX7,      pSwCtxTable[ChID].grCtx3d.WindowClipX[7]);
        
        REG_WR32(NV_PGRAPH_WINDOWCLIPY0,      pSwCtxTable[ChID].grCtx3d.WindowClipY[0]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY1,      pSwCtxTable[ChID].grCtx3d.WindowClipY[1]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY2,      pSwCtxTable[ChID].grCtx3d.WindowClipY[2]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY3,      pSwCtxTable[ChID].grCtx3d.WindowClipY[3]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY4,      pSwCtxTable[ChID].grCtx3d.WindowClipY[4]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY5,      pSwCtxTable[ChID].grCtx3d.WindowClipY[5]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY6,      pSwCtxTable[ChID].grCtx3d.WindowClipY[6]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY7,      pSwCtxTable[ChID].grCtx3d.WindowClipY[7]);
        
        REG_WR32(NV_PGRAPH_ZCOMPRESSOCCLUDE,  pSwCtxTable[ChID].grCtx3d.ZCompressOcclude);
        REG_WR32(NV_PGRAPH_ZSTENCILCLEARVALUE,pSwCtxTable[ChID].grCtx3d.ZStencilClearValue);
        
        REG_WR32(NV_PGRAPH_ZCLIPMAX,          pSwCtxTable[ChID].grCtx3d.ZClipMax);
        REG_WR32(NV_PGRAPH_ZCLIPMIN,          pSwCtxTable[ChID].grCtx3d.ZClipMin);
        
        REG_WR32(NV_PGRAPH_CONTEXTDMAA,       pSwCtxTable[ChID].grCtx3d.ContextDmaA);
        REG_WR32(NV_PGRAPH_CONTEXTDMAB,       pSwCtxTable[ChID].grCtx3d.ContextDmaB);
        REG_WR32(NV_PGRAPH_CONTEXTVTXA,       pSwCtxTable[ChID].grCtx3d.ContextDmaVtxA);
        REG_WR32(NV_PGRAPH_CONTEXTVTXB,       pSwCtxTable[ChID].grCtx3d.ContextDmaVtxB);
        
        REG_WR32(NV_PGRAPH_ZOFFSETBIAS,       pSwCtxTable[ChID].grCtx3d.ZOffsetBias);
        REG_WR32(NV_PGRAPH_ZOFFSETFACTOR,     pSwCtxTable[ChID].grCtx3d.ZOffsetFactor);
        
        REG_WR32(NV_PGRAPH_EYEVEC0,           pSwCtxTable[ChID].grCtx3d.Eyevec0);
        REG_WR32(NV_PGRAPH_EYEVEC1,           pSwCtxTable[ChID].grCtx3d.Eyevec1);
        REG_WR32(NV_PGRAPH_EYEVEC2,           pSwCtxTable[ChID].grCtx3d.Eyevec2);
        
        REG_WR32(NV_PGRAPH_SHADOW,            pSwCtxTable[ChID].grCtx3d.Shadow);
        REG_WR32(NV_PGRAPH_FD_DATA,           pSwCtxTable[ChID].grCtx3d.FdData);
        REG_WR32(NV_PGRAPH_FD_SWATCH,         pSwCtxTable[ChID].grCtx3d.FdSwatch);
        REG_WR32(NV_PGRAPH_FD_EXTRAS,         pSwCtxTable[ChID].grCtx3d.FdExtras);
        REG_WR32(NV_PGRAPH_EMISSION_BACKUP_0, pSwCtxTable[ChID].grCtx3d.Emission0);
        REG_WR32(NV_PGRAPH_EMISSION_BACKUP_1, pSwCtxTable[ChID].grCtx3d.Emission1);
        REG_WR32(NV_PGRAPH_EMISSION_BACKUP_2, pSwCtxTable[ChID].grCtx3d.Emission2);
        REG_WR32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_0, pSwCtxTable[ChID].grCtx3d.SceneAmb0);
        REG_WR32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_1, pSwCtxTable[ChID].grCtx3d.SceneAmb1);
        REG_WR32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_2, pSwCtxTable[ChID].grCtx3d.SceneAmb2);
        REG_WR32(NV_PGRAPH_GETSTATE,          pSwCtxTable[ChID].grCtx3d.ContextDmaGetState);
        REG_WR32(NV_PGRAPH_BEGINPATCH0,       pSwCtxTable[ChID].grCtx3d.BeginPatch0);
        REG_WR32(NV_PGRAPH_BEGINPATCH1,       pSwCtxTable[ChID].grCtx3d.BeginPatch1);
        REG_WR32(NV_PGRAPH_BEGINPATCH2,       pSwCtxTable[ChID].grCtx3d.BeginPatch2);
        REG_WR32(NV_PGRAPH_BEGINPATCH3,       pSwCtxTable[ChID].grCtx3d.BeginPatch3);
        REG_WR32(NV_PGRAPH_CURVE,             pSwCtxTable[ChID].grCtx3d.BeginCurve);
        REG_WR32(NV_PGRAPH_BEGINTRANS0,       pSwCtxTable[ChID].grCtx3d.BeginTrans0);
        REG_WR32(NV_PGRAPH_BEGINTRANS1,       pSwCtxTable[ChID].grCtx3d.BeginTrans1);
        REG_WR32(NV_PGRAPH_CSV0_D,            pSwCtxTable[ChID].grCtx3d.Csv0_D);
        REG_WR32(NV_PGRAPH_CSV0_C,            pSwCtxTable[ChID].grCtx3d.Csv0_C);
        REG_WR32(NV_PGRAPH_CSV1_B,            pSwCtxTable[ChID].grCtx3d.Csv1_B);
        REG_WR32(NV_PGRAPH_CSV1_A,            pSwCtxTable[ChID].grCtx3d.Csv1_A);
        REG_WR32(NV_PGRAPH_CHEOPS_OFFSET,     pSwCtxTable[ChID].grCtx3d.CheopsOffset);
        
        do {
          status = REG_RD32(NV_PGRAPH_STATUS);
        } while (status);
        
        // wait for the pipe to go idle 
        HAL_GR_IDLE(pHalHwInfo);

        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, RDI_ADDR_ZERO, IDX_FMT_COUNT, pSwCtxTable[ChID].grCtxPipe.IdxFmt);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, RDI_ADDR_ZERO, CAS0_COUNT, pSwCtxTable[ChID].grCtxPipe.Cas0);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, RDI_ADDR_ZERO, CAS1_COUNT, pSwCtxTable[ChID].grCtxPipe.Cas1);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, RDI_ADDR_ZERO, CAS2_COUNT, pSwCtxTable[ChID].grCtxPipe.Cas2);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_ASSM_STATE, RDI_ADDR_ZERO, ASSM_STATE_COUNT, pSwCtxTable[ChID].grCtxPipe.AssmState);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE0, RDI_ADDR_ZERO, IDX_CACHE0_COUNT, pSwCtxTable[ChID].grCtxPipe.IdxCache0);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE1, RDI_ADDR_ZERO, IDX_CACHE1_COUNT, pSwCtxTable[ChID].grCtxPipe.IdxCache1);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE2, RDI_ADDR_ZERO, IDX_CACHE2_COUNT, pSwCtxTable[ChID].grCtxPipe.IdxCache2);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE3, RDI_ADDR_ZERO, IDX_CACHE3_COUNT, pSwCtxTable[ChID].grCtxPipe.IdxCache3);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_VTX_FILE0, RDI_ADDR_ZERO, VTX_FILE0_COUNT, pSwCtxTable[ChID].grCtxPipe.VtxFile0);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_VTX_FILE1, RDI_ADDR_ZERO, VTX_FILE1_COUNT, pSwCtxTable[ChID].grCtxPipe.VtxFile1);
        
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_P, RDI_ADDR_ZERO, XL_P_COUNT, pSwCtxTable[ChID].grCtxPipe.XlP);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_XFCTX, RDI_ADDR_ZERO, XL_XFCTX_COUNT, pSwCtxTable[ChID].grCtxPipe.XlXfCtx);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_LTCTX, RDI_ADDR_ZERO, XL_LTCTX_COUNT, pSwCtxTable[ChID].grCtxPipe.XlLtCtx);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_LTC, RDI_ADDR_ZERO, XL_LTC_COUNT, pSwCtxTable[ChID].grCtxPipe.XlLtc);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, RDI_ADDR_ZERO, XL_VAB_COUNT, pSwCtxTable[ChID].grCtxPipe.XlVab);
        
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CRSTR_STIPP, RDI_ADDR_ZERO, CRSTR_STIPP_COUNT, pSwCtxTable[ChID].grCtxPipe.CrstrStipp);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_FD_CTRL, RDI_ADDR_ZERO, FD_CTRL_COUNT, pSwCtxTable[ChID].grCtxPipe.FdCtrl);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_ROP_REGS, RDI_ADDR_ZERO, ROP_REGS_COUNT, pSwCtxTable[ChID].grCtxPipe.RopRegs);
    }
    
    
    REG_WR32(NV_PGRAPH_CTX_CONTROL,
        DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME,   _33US)
        | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _NOT_EXPIRED)
        | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _VALID)
        | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
        | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
                      
    
    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, ChID);

    REG_WR32(NV_PGRAPH_FFINTFC_ST2, REG_RD32(NV_PGRAPH_FFINTFC_ST2) & 0xCFFFFFFF);
    
    REG_WR_DRF_DEF(_PGRAPH,_FIFO,_ACCESS,_ENABLED);

    return (RM_OK);
}

RM_STATUS nvHalGrUnloadChannelContext_NV20(PHALHWINFO pHalHwInfo, U032 ChID, PGRAPHICSCHANNEL_NV20 pSwCtxTable)
{
    PGRHALINFO_NV20 pGrHalPvtInfo = (PGRHALINFO_NV20) pHalHwInfo->pGrHalPvtInfo;

    U032 ctxControl;
    int i;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrUnloadChannelContext_NV20\r\n");

    HAL_GR_IDLE(pHalHwInfo);

    ctxControl = REG_RD32(NV_PGRAPH_CTX_CONTROL);
    
    if (DRF_VAL(_PGRAPH,_CTX_CONTROL,_CHID, ctxControl) == NV_PGRAPH_CTX_CONTROL_CHID_INVALID)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: grUnloadCurrentChannelContext() current chid is invalid\n");
        return (RM_OK);
    }
    
    pSwCtxTable->grCtxCmn.ContextUser       = REG_RD32(NV_PGRAPH_CTX_USER);
    
    //
    // Unload current context registers.
    //
    pSwCtxTable->grCtxCmn.ContextSwitch1    = REG_RD32(NV_PGRAPH_CTX_SWITCH1);
    pSwCtxTable->grCtxCmn.ContextSwitch2    = REG_RD32(NV_PGRAPH_CTX_SWITCH2);
    pSwCtxTable->grCtxCmn.ContextSwitch3    = REG_RD32(NV_PGRAPH_CTX_SWITCH3);        
    pSwCtxTable->grCtxCmn.ContextSwitch4    = REG_RD32(NV_PGRAPH_CTX_SWITCH4);
    pSwCtxTable->grCtxCmn.ContextSwitch5    = REG_RD32(NV_PGRAPH_CTX_SWITCH5);
    
    for (i = 0; i < 8; i++)
        pSwCtxTable->grCtxCmn.ContextCache1[i] = REG_RD32(NV_PGRAPH_CTX_CACHE1(i));
    
    for (i = 0; i < 8; i++)
        pSwCtxTable->grCtxCmn.ContextCache2[i] = REG_RD32(NV_PGRAPH_CTX_CACHE2(i));
    
    for (i = 0; i < 8; i++)
        pSwCtxTable->grCtxCmn.ContextCache3[i] = REG_RD32(NV_PGRAPH_CTX_CACHE3(i));
    
    for (i = 0; i < 8; i++)
        pSwCtxTable->grCtxCmn.ContextCache4[i] = REG_RD32(NV_PGRAPH_CTX_CACHE4(i));
    
    for (i = 0; i < 8; i++)
        pSwCtxTable->grCtxCmn.ContextCache5[i] = REG_RD32(NV_PGRAPH_CTX_CACHE5(i));
    
    pSwCtxTable->grCtxCmn.MonoColor0          = REG_RD32(NV_PGRAPH_MONO_COLOR0);
    pSwCtxTable->grCtxCmn.BufferSwizzle2      = REG_RD32(NV_PGRAPH_BSWIZZLE2);        
    pSwCtxTable->grCtxCmn.BufferSwizzle5      = REG_RD32(NV_PGRAPH_BSWIZZLE5);        
    
    for (i = 0; i < 6; i++)
        pSwCtxTable->grCtxCmn.BufferOffset[i] = REG_RD32(NV_PGRAPH_BOFFSET(i));
    
    for (i = 0; i < 6; i++)
        pSwCtxTable->grCtxCmn.BufferBase[i]   = REG_RD32(NV_PGRAPH_BBASE(i));
    
    for (i = 0; i < 5; i++)
        pSwCtxTable->grCtxCmn.BufferPitch[i]  = REG_RD32(NV_PGRAPH_BPITCH(i));
    
    for (i = 0; i < 6; i++)
        pSwCtxTable->grCtxCmn.BufferLimit[i]  = REG_RD32(NV_PGRAPH_BLIMIT(i));
    
    pSwCtxTable->grCtxCmn.Chroma              = REG_RD32(NV_PGRAPH_CHROMA);
    
    pSwCtxTable->grCtxCmn.Surface             = REG_RD32(NV_PGRAPH_SURFACE);        
    pSwCtxTable->grCtxCmn.State               = REG_RD32(NV_PGRAPH_STATE);        
    pSwCtxTable->grCtxCmn.Notify              = REG_RD32(NV_PGRAPH_NOTIFY);
    pSwCtxTable->grCtxCmn.BufferPixel         = REG_RD32(NV_PGRAPH_BPIXEL);
    
    pSwCtxTable->grCtxCmn.DmaPitch            = REG_RD32(NV_PGRAPH_DMA_PITCH);
    pSwCtxTable->grCtxCmn.DvdColorFmt         = REG_RD32(NV_PGRAPH_DVD_COLORFMT);    
    pSwCtxTable->grCtxCmn.ScaledFormat        = REG_RD32(NV_PGRAPH_SCALED_FORMAT);    
    
    pSwCtxTable->grCtxCmn.PatternColor0       = REG_RD32(NV_PGRAPH_PATT_COLOR0);    
    pSwCtxTable->grCtxCmn.PatternColor1       = REG_RD32(NV_PGRAPH_PATT_COLOR1);
    pSwCtxTable->grCtxCmn.Pattern[0]          = REG_RD32(NV_PGRAPH_PATTERN(0));
    pSwCtxTable->grCtxCmn.Pattern[1]          = REG_RD32(NV_PGRAPH_PATTERN(1));
    pSwCtxTable->grCtxCmn.PatternShape        = REG_RD32(NV_PGRAPH_PATTERN_SHAPE);
    
    for (i = 0; i < 64; i++)
        pSwCtxTable->grCtxCmn.PattColorRam[i] = REG_RD32(NV_PGRAPH_PATT_COLORRAM(i));
    
    
    pSwCtxTable->grCtxCmn.Rop3                = REG_RD32(NV_PGRAPH_ROP3);
    pSwCtxTable->grCtxCmn.BetaAnd             = REG_RD32(NV_PGRAPH_BETA_AND);
    pSwCtxTable->grCtxCmn.BetaPreMult         = REG_RD32(NV_PGRAPH_BETA_PREMULT);
    pSwCtxTable->grCtxCmn.StoredFmt           = REG_RD32(NV_PGRAPH_STORED_FMT);
      
    for (i = 0; i < 10; i++)
      pSwCtxTable->grCtxCmn.AbsXRam[i]        = REG_RD32(NV_PGRAPH_ABS_X_RAM(i));
    
    for (i = 0; i < 10; i++)
      pSwCtxTable->grCtxCmn.AbsYRam[i]        = REG_RD32(NV_PGRAPH_ABS_Y_RAM(i));
    
    pSwCtxTable->grCtxCmn.AbsIClipXMax        = REG_RD32(NV_PGRAPH_ABS_ICLIP_XMAX);
    pSwCtxTable->grCtxCmn.AbsIClipYMax        = REG_RD32(NV_PGRAPH_ABS_ICLIP_YMAX);
    
    pSwCtxTable->grCtxCmn.AbsUClipXMin        = REG_RD32(NV_PGRAPH_ABS_UCLIP_XMIN);
    pSwCtxTable->grCtxCmn.AbsUClipXMax        = REG_RD32(NV_PGRAPH_ABS_UCLIP_XMAX);
    pSwCtxTable->grCtxCmn.AbsUClipYMin        = REG_RD32(NV_PGRAPH_ABS_UCLIP_YMIN);
    pSwCtxTable->grCtxCmn.AbsUClipYMax        = REG_RD32(NV_PGRAPH_ABS_UCLIP_YMAX);
    
    pSwCtxTable->grCtxCmn.AbsUClipAXMin       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_XMIN);
    pSwCtxTable->grCtxCmn.AbsUClipAXMax       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_XMAX);
    pSwCtxTable->grCtxCmn.AbsUClipAYMin       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_YMIN);
    pSwCtxTable->grCtxCmn.AbsUClipAYMax       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_YMAX);
    
    pSwCtxTable->grCtxCmn.SourceColor         = REG_RD32(NV_PGRAPH_SOURCE_COLOR);
    
    pSwCtxTable->grCtxCmn.Misc24_0            = REG_RD32(NV_PGRAPH_MISC24_0);
    
    pSwCtxTable->grCtxCmn.XYLogicMisc0        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC0);
    pSwCtxTable->grCtxCmn.XYLogicMisc1        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC1);
    pSwCtxTable->grCtxCmn.XYLogicMisc2        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC2);
    pSwCtxTable->grCtxCmn.XYLogicMisc3        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC3);
    
    pSwCtxTable->grCtxCmn.ClipX0              = REG_RD32(NV_PGRAPH_CLIPX_0);
    pSwCtxTable->grCtxCmn.ClipX1              = REG_RD32(NV_PGRAPH_CLIPX_1);
    pSwCtxTable->grCtxCmn.ClipY0              = REG_RD32(NV_PGRAPH_CLIPY_0);
    pSwCtxTable->grCtxCmn.ClipY1              = REG_RD32(NV_PGRAPH_CLIPY_1);
    
    pSwCtxTable->grCtxCmn.Passthru0           = REG_RD32(NV_PGRAPH_PASSTHRU_0);    
    pSwCtxTable->grCtxCmn.Passthru1           = REG_RD32(NV_PGRAPH_PASSTHRU_1);    
    pSwCtxTable->grCtxCmn.Passthru2           = REG_RD32(NV_PGRAPH_PASSTHRU_2);    
    
    pSwCtxTable->grCtxCmn.DimxTexture         = REG_RD32(NV_PGRAPH_DIMX_TEXTURE);    
    pSwCtxTable->grCtxCmn.WdimxTexture        = REG_RD32(NV_PGRAPH_WDIMX_TEXTURE);    
    
    pSwCtxTable->grCtxCmn.DmaStart0           = REG_RD32(NV_PGRAPH_DMA_START_0);
    pSwCtxTable->grCtxCmn.DmaStart1           = REG_RD32(NV_PGRAPH_DMA_START_1);
    pSwCtxTable->grCtxCmn.DmaLength           = REG_RD32(NV_PGRAPH_DMA_LENGTH);
    pSwCtxTable->grCtxCmn.DmaMisc             = REG_RD32(NV_PGRAPH_DMA_MISC);
    
    pSwCtxTable->grCtxCmn.Misc24_1            = REG_RD32(NV_PGRAPH_MISC24_1);
    pSwCtxTable->grCtxCmn.Misc24_2            = REG_RD32(NV_PGRAPH_MISC24_2);
    pSwCtxTable->grCtxCmn.XMisc               = REG_RD32(NV_PGRAPH_X_MISC);
    pSwCtxTable->grCtxCmn.YMisc               = REG_RD32(NV_PGRAPH_Y_MISC);
    pSwCtxTable->grCtxCmn.Valid1              = REG_RD32(NV_PGRAPH_VALID1);
      
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0) {
        // 3D stuff
        pSwCtxTable->grCtx3d.AntiAliasing        = REG_RD32(NV_PGRAPH_ANTIALIASING);
        pSwCtxTable->grCtx3d.Blend               = REG_RD32(NV_PGRAPH_BLEND);
        pSwCtxTable->grCtx3d.BlendColor          = REG_RD32(NV_PGRAPH_BLENDCOLOR);
        pSwCtxTable->grCtx3d.BorderColor0        = REG_RD32(NV_PGRAPH_BORDERCOLOR0);
        pSwCtxTable->grCtx3d.BorderColor1        = REG_RD32(NV_PGRAPH_BORDERCOLOR1);
        pSwCtxTable->grCtx3d.BorderColor2        = REG_RD32(NV_PGRAPH_BORDERCOLOR2);
        pSwCtxTable->grCtx3d.BorderColor3        = REG_RD32(NV_PGRAPH_BORDERCOLOR3);
        
        pSwCtxTable->grCtx3d.BumpMat00_1         = REG_RD32(NV_PGRAPH_BUMPMAT00_1);
        pSwCtxTable->grCtx3d.BumpMat00_2         = REG_RD32(NV_PGRAPH_BUMPMAT00_2);
        pSwCtxTable->grCtx3d.BumpMat00_3         = REG_RD32(NV_PGRAPH_BUMPMAT00_3);
        pSwCtxTable->grCtx3d.BumpMat01_1         = REG_RD32(NV_PGRAPH_BUMPMAT01_1);
        pSwCtxTable->grCtx3d.BumpMat01_2         = REG_RD32(NV_PGRAPH_BUMPMAT01_2);
        pSwCtxTable->grCtx3d.BumpMat01_3         = REG_RD32(NV_PGRAPH_BUMPMAT01_3);
        pSwCtxTable->grCtx3d.BumpMat10_1         = REG_RD32(NV_PGRAPH_BUMPMAT10_1);
        pSwCtxTable->grCtx3d.BumpMat10_2         = REG_RD32(NV_PGRAPH_BUMPMAT10_2);
        pSwCtxTable->grCtx3d.BumpMat10_3         = REG_RD32(NV_PGRAPH_BUMPMAT10_3);
        pSwCtxTable->grCtx3d.BumpMat11_1         = REG_RD32(NV_PGRAPH_BUMPMAT11_1);
        pSwCtxTable->grCtx3d.BumpMat11_2         = REG_RD32(NV_PGRAPH_BUMPMAT11_2);
        pSwCtxTable->grCtx3d.BumpMat11_3         = REG_RD32(NV_PGRAPH_BUMPMAT11_3);
        
        pSwCtxTable->grCtx3d.BumpOffset1         = REG_RD32(NV_PGRAPH_BUMPOFFSET1);
        pSwCtxTable->grCtx3d.BumpOffset2         = REG_RD32(NV_PGRAPH_BUMPOFFSET2);
        pSwCtxTable->grCtx3d.BumpOffset3         = REG_RD32(NV_PGRAPH_BUMPOFFSET3);
        
        pSwCtxTable->grCtx3d.BumpScale1          = REG_RD32(NV_PGRAPH_BUMPSCALE1);
        pSwCtxTable->grCtx3d.BumpScale2          = REG_RD32(NV_PGRAPH_BUMPSCALE2);
        pSwCtxTable->grCtx3d.BumpScale3          = REG_RD32(NV_PGRAPH_BUMPSCALE3);
        
        pSwCtxTable->grCtx3d.ClearRectX          = REG_RD32(NV_PGRAPH_CLEARRECTX);
        pSwCtxTable->grCtx3d.ClearRectY          = REG_RD32(NV_PGRAPH_CLEARRECTY);
        
        pSwCtxTable->grCtx3d.ColorClearValue     = REG_RD32(NV_PGRAPH_COLORCLEARVALUE);
        
        pSwCtxTable->grCtx3d.ColorKeyColor0      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR0);
        pSwCtxTable->grCtx3d.ColorKeyColor1      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR1);
        pSwCtxTable->grCtx3d.ColorKeyColor2      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR2);
        pSwCtxTable->grCtx3d.ColorKeyColor3      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR3);
        
        pSwCtxTable->grCtx3d.CombineFactor0_0    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_0);
        pSwCtxTable->grCtx3d.CombineFactor0_1    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_1);
        pSwCtxTable->grCtx3d.CombineFactor0_2    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_2);
        pSwCtxTable->grCtx3d.CombineFactor0_3    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_3);
        pSwCtxTable->grCtx3d.CombineFactor0_4    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_4);
        pSwCtxTable->grCtx3d.CombineFactor0_5    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_5);
        pSwCtxTable->grCtx3d.CombineFactor0_6    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_6);
        pSwCtxTable->grCtx3d.CombineFactor0_7    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_7);
        pSwCtxTable->grCtx3d.CombineFactor1_0    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_0);
        pSwCtxTable->grCtx3d.CombineFactor1_1    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_1);
        pSwCtxTable->grCtx3d.CombineFactor1_2    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_2);
        pSwCtxTable->grCtx3d.CombineFactor1_3    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_3);
        pSwCtxTable->grCtx3d.CombineFactor1_4    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_4);
        pSwCtxTable->grCtx3d.CombineFactor1_5    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_5);
        pSwCtxTable->grCtx3d.CombineFactor1_6    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_6);
        pSwCtxTable->grCtx3d.CombineFactor1_7    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_7);
        
        pSwCtxTable->grCtx3d.CombineAlphaI0      = REG_RD32(NV_PGRAPH_COMBINEALPHAI0);
        pSwCtxTable->grCtx3d.CombineAlphaI1      = REG_RD32(NV_PGRAPH_COMBINEALPHAI1);
        pSwCtxTable->grCtx3d.CombineAlphaI2      = REG_RD32(NV_PGRAPH_COMBINEALPHAI2);
        pSwCtxTable->grCtx3d.CombineAlphaI3      = REG_RD32(NV_PGRAPH_COMBINEALPHAI3);
        pSwCtxTable->grCtx3d.CombineAlphaI4      = REG_RD32(NV_PGRAPH_COMBINEALPHAI4);
        pSwCtxTable->grCtx3d.CombineAlphaI5      = REG_RD32(NV_PGRAPH_COMBINEALPHAI5);
        pSwCtxTable->grCtx3d.CombineAlphaI6      = REG_RD32(NV_PGRAPH_COMBINEALPHAI6);
        pSwCtxTable->grCtx3d.CombineAlphaI7      = REG_RD32(NV_PGRAPH_COMBINEALPHAI7);
        pSwCtxTable->grCtx3d.CombineAlphaO0      = REG_RD32(NV_PGRAPH_COMBINEALPHAO0);
        pSwCtxTable->grCtx3d.CombineAlphaO1      = REG_RD32(NV_PGRAPH_COMBINEALPHAO1);
        pSwCtxTable->grCtx3d.CombineAlphaO2      = REG_RD32(NV_PGRAPH_COMBINEALPHAO2);
        pSwCtxTable->grCtx3d.CombineAlphaO3      = REG_RD32(NV_PGRAPH_COMBINEALPHAO3);
        pSwCtxTable->grCtx3d.CombineAlphaO4      = REG_RD32(NV_PGRAPH_COMBINEALPHAO4);
        pSwCtxTable->grCtx3d.CombineAlphaO5      = REG_RD32(NV_PGRAPH_COMBINEALPHAO5);
        pSwCtxTable->grCtx3d.CombineAlphaO6      = REG_RD32(NV_PGRAPH_COMBINEALPHAO6);
        pSwCtxTable->grCtx3d.CombineAlphaO7      = REG_RD32(NV_PGRAPH_COMBINEALPHAO7);
        
        pSwCtxTable->grCtx3d.CombineColorI0      = REG_RD32(NV_PGRAPH_COMBINECOLORI0);
        pSwCtxTable->grCtx3d.CombineColorI1      = REG_RD32(NV_PGRAPH_COMBINECOLORI1);
        pSwCtxTable->grCtx3d.CombineColorI2      = REG_RD32(NV_PGRAPH_COMBINECOLORI2);
        pSwCtxTable->grCtx3d.CombineColorI3      = REG_RD32(NV_PGRAPH_COMBINECOLORI3);
        pSwCtxTable->grCtx3d.CombineColorI4      = REG_RD32(NV_PGRAPH_COMBINECOLORI4);
        pSwCtxTable->grCtx3d.CombineColorI5      = REG_RD32(NV_PGRAPH_COMBINECOLORI5);
        pSwCtxTable->grCtx3d.CombineColorI6      = REG_RD32(NV_PGRAPH_COMBINECOLORI6);
        pSwCtxTable->grCtx3d.CombineColorI7      = REG_RD32(NV_PGRAPH_COMBINECOLORI7);
        pSwCtxTable->grCtx3d.CombineColorO0      = REG_RD32(NV_PGRAPH_COMBINECOLORO0);
        pSwCtxTable->grCtx3d.CombineColorO1      = REG_RD32(NV_PGRAPH_COMBINECOLORO1);
        pSwCtxTable->grCtx3d.CombineColorO2      = REG_RD32(NV_PGRAPH_COMBINECOLORO2);
        pSwCtxTable->grCtx3d.CombineColorO3      = REG_RD32(NV_PGRAPH_COMBINECOLORO3);
        pSwCtxTable->grCtx3d.CombineColorO4      = REG_RD32(NV_PGRAPH_COMBINECOLORO4);
        pSwCtxTable->grCtx3d.CombineColorO5      = REG_RD32(NV_PGRAPH_COMBINECOLORO5);
        pSwCtxTable->grCtx3d.CombineColorO6      = REG_RD32(NV_PGRAPH_COMBINECOLORO6);
        pSwCtxTable->grCtx3d.CombineColorO7      = REG_RD32(NV_PGRAPH_COMBINECOLORO7);
        
        pSwCtxTable->grCtx3d.CombineCtl          = REG_RD32(NV_PGRAPH_COMBINECTL);
        
        pSwCtxTable->grCtx3d.CombineSpecFog0     = REG_RD32(NV_PGRAPH_COMBINESPECFOG0);
        pSwCtxTable->grCtx3d.CombineSpecFog1     = REG_RD32(NV_PGRAPH_COMBINESPECFOG1);
        
        pSwCtxTable->grCtx3d.Control0            = REG_RD32(NV_PGRAPH_CONTROL_0);
        pSwCtxTable->grCtx3d.Control1            = REG_RD32(NV_PGRAPH_CONTROL_1);
        pSwCtxTable->grCtx3d.Control2            = REG_RD32(NV_PGRAPH_CONTROL_2);
        pSwCtxTable->grCtx3d.Control3            = REG_RD32(NV_PGRAPH_CONTROL_3);
        
        pSwCtxTable->grCtx3d.FogColor            = REG_RD32(NV_PGRAPH_FOGCOLOR);
        pSwCtxTable->grCtx3d.FogParam0           = REG_RD32(NV_PGRAPH_FOGPARAM0);
        pSwCtxTable->grCtx3d.FogParam1           = REG_RD32(NV_PGRAPH_FOGPARAM1);
        pSwCtxTable->grCtx3d.PointSize           = REG_RD32(NV_PGRAPH_POINTSIZE);
        pSwCtxTable->grCtx3d.SetupRaster         = REG_RD32(NV_PGRAPH_SETUPRASTER);
        
        pSwCtxTable->grCtx3d.ShaderClipMode      = REG_RD32(NV_PGRAPH_SHADERCLIPMODE);
        pSwCtxTable->grCtx3d.ShaderCtl           = REG_RD32(NV_PGRAPH_SHADERCTL);
        pSwCtxTable->grCtx3d.ShaderProg          = REG_RD32(NV_PGRAPH_SHADERPROG);
        
        pSwCtxTable->grCtx3d.SemaphoreOffset     = REG_RD32(NV_PGRAPH_SEMAPHOREOFFSET);
        pSwCtxTable->grCtx3d.ShadowCtl           = REG_RD32(NV_PGRAPH_SHADOWCTL);
        pSwCtxTable->grCtx3d.ShadowZSlopeThreshold = REG_RD32(NV_PGRAPH_SHADOWZSLOPETHRESHOLD);
        
        pSwCtxTable->grCtx3d.SpecFogFactor0      = REG_RD32(NV_PGRAPH_SPECFOGFACTOR0);
        pSwCtxTable->grCtx3d.SpecFogFactor1      = REG_RD32(NV_PGRAPH_SPECFOGFACTOR1);
        
        pSwCtxTable->grCtx3d.SurfaceClipX        = REG_RD32(NV_PGRAPH_SURFACECLIPX);
        pSwCtxTable->grCtx3d.SurfaceClipY        = REG_RD32(NV_PGRAPH_SURFACECLIPY);
        
        pSwCtxTable->grCtx3d.TexAddress0         = REG_RD32(NV_PGRAPH_TEXADDRESS0);
        pSwCtxTable->grCtx3d.TexAddress1         = REG_RD32(NV_PGRAPH_TEXADDRESS1);
        pSwCtxTable->grCtx3d.TexAddress2         = REG_RD32(NV_PGRAPH_TEXADDRESS2);
        pSwCtxTable->grCtx3d.TexAddress3         = REG_RD32(NV_PGRAPH_TEXADDRESS3);
        
        pSwCtxTable->grCtx3d.TexCtl0_0       = REG_RD32(NV_PGRAPH_TEXCTL0_0);
        pSwCtxTable->grCtx3d.TexCtl0_1       = REG_RD32(NV_PGRAPH_TEXCTL0_1);
        pSwCtxTable->grCtx3d.TexCtl0_2       = REG_RD32(NV_PGRAPH_TEXCTL0_2);
        pSwCtxTable->grCtx3d.TexCtl0_3       = REG_RD32(NV_PGRAPH_TEXCTL0_3);
        
        pSwCtxTable->grCtx3d.TexCtl1_0       = REG_RD32(NV_PGRAPH_TEXCTL1_0);
        pSwCtxTable->grCtx3d.TexCtl1_1       = REG_RD32(NV_PGRAPH_TEXCTL1_1);
        pSwCtxTable->grCtx3d.TexCtl1_2       = REG_RD32(NV_PGRAPH_TEXCTL1_2);
        pSwCtxTable->grCtx3d.TexCtl1_3       = REG_RD32(NV_PGRAPH_TEXCTL1_3);
        
        pSwCtxTable->grCtx3d.TexCtl2_0       = REG_RD32(NV_PGRAPH_TEXCTL2_0);
        pSwCtxTable->grCtx3d.TexCtl2_1       = REG_RD32(NV_PGRAPH_TEXCTL2_1);
        
        pSwCtxTable->grCtx3d.TexFilter0          = REG_RD32(NV_PGRAPH_TEXFILTER0);
        pSwCtxTable->grCtx3d.TexFilter1          = REG_RD32(NV_PGRAPH_TEXFILTER1);
        pSwCtxTable->grCtx3d.TexFilter2          = REG_RD32(NV_PGRAPH_TEXFILTER2);
        pSwCtxTable->grCtx3d.TexFilter3          = REG_RD32(NV_PGRAPH_TEXFILTER3);
        
        pSwCtxTable->grCtx3d.TexFormat0          = REG_RD32(NV_PGRAPH_TEXFMT0);
        pSwCtxTable->grCtx3d.TexFormat1          = REG_RD32(NV_PGRAPH_TEXFMT1);
        pSwCtxTable->grCtx3d.TexFormat2          = REG_RD32(NV_PGRAPH_TEXFMT2);
        pSwCtxTable->grCtx3d.TexFormat3          = REG_RD32(NV_PGRAPH_TEXFMT3);
        
        pSwCtxTable->grCtx3d.TexImageRect0       = REG_RD32(NV_PGRAPH_TEXIMAGERECT0);
        pSwCtxTable->grCtx3d.TexImageRect1       = REG_RD32(NV_PGRAPH_TEXIMAGERECT1);
        pSwCtxTable->grCtx3d.TexImageRect2       = REG_RD32(NV_PGRAPH_TEXIMAGERECT2);
        pSwCtxTable->grCtx3d.TexImageRect3       = REG_RD32(NV_PGRAPH_TEXIMAGERECT3);
        
        pSwCtxTable->grCtx3d.TexOffset0          = REG_RD32(NV_PGRAPH_TEXOFFSET0);
        pSwCtxTable->grCtx3d.TexOffset1          = REG_RD32(NV_PGRAPH_TEXOFFSET1);
        pSwCtxTable->grCtx3d.TexOffset2          = REG_RD32(NV_PGRAPH_TEXOFFSET2);
        pSwCtxTable->grCtx3d.TexOffset3          = REG_RD32(NV_PGRAPH_TEXOFFSET3);
        
        pSwCtxTable->grCtx3d.TexPallete0         = REG_RD32(NV_PGRAPH_TEXPALETTE0);
        pSwCtxTable->grCtx3d.TexPallete1         = REG_RD32(NV_PGRAPH_TEXPALETTE1);
        pSwCtxTable->grCtx3d.TexPallete2         = REG_RD32(NV_PGRAPH_TEXPALETTE2);
        pSwCtxTable->grCtx3d.TexPallete3         = REG_RD32(NV_PGRAPH_TEXPALETTE3);
        
        pSwCtxTable->grCtx3d.WindowClipX[0]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX0);
        pSwCtxTable->grCtx3d.WindowClipX[1]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX1);
        pSwCtxTable->grCtx3d.WindowClipX[2]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX2);
        pSwCtxTable->grCtx3d.WindowClipX[3]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX3);
        pSwCtxTable->grCtx3d.WindowClipX[4]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX4);
        pSwCtxTable->grCtx3d.WindowClipX[5]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX5);
        pSwCtxTable->grCtx3d.WindowClipX[6]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX6);
        pSwCtxTable->grCtx3d.WindowClipX[7]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX7);
        
        pSwCtxTable->grCtx3d.WindowClipY[0]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY0);
        pSwCtxTable->grCtx3d.WindowClipY[1]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY1);
        pSwCtxTable->grCtx3d.WindowClipY[2]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY2);
        pSwCtxTable->grCtx3d.WindowClipY[3]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY3);
        pSwCtxTable->grCtx3d.WindowClipY[4]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY4);
        pSwCtxTable->grCtx3d.WindowClipY[5]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY5);
        pSwCtxTable->grCtx3d.WindowClipY[6]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY6);
        pSwCtxTable->grCtx3d.WindowClipY[7]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY7);
        
        pSwCtxTable->grCtx3d.ZCompressOcclude    = REG_RD32(NV_PGRAPH_ZCOMPRESSOCCLUDE);
        pSwCtxTable->grCtx3d.ZStencilClearValue  = REG_RD32(NV_PGRAPH_ZSTENCILCLEARVALUE);
        
        pSwCtxTable->grCtx3d.ZClipMax            = REG_RD32(NV_PGRAPH_ZCLIPMAX);
        pSwCtxTable->grCtx3d.ZClipMin            = REG_RD32(NV_PGRAPH_ZCLIPMIN);
        
        pSwCtxTable->grCtx3d.ContextDmaA         = REG_RD32(NV_PGRAPH_CONTEXTDMAA);
        pSwCtxTable->grCtx3d.ContextDmaB         = REG_RD32(NV_PGRAPH_CONTEXTDMAB);
        pSwCtxTable->grCtx3d.ContextDmaVtxA      = REG_RD32(NV_PGRAPH_CONTEXTVTXA);
        pSwCtxTable->grCtx3d.ContextDmaVtxB      = REG_RD32(NV_PGRAPH_CONTEXTVTXB);
        
        pSwCtxTable->grCtx3d.ZOffsetBias         = REG_RD32(NV_PGRAPH_ZOFFSETBIAS);
        pSwCtxTable->grCtx3d.ZOffsetFactor       = REG_RD32(NV_PGRAPH_ZOFFSETFACTOR);
        
        pSwCtxTable->grCtx3d.Eyevec0             = REG_RD32(NV_PGRAPH_EYEVEC0);
        pSwCtxTable->grCtx3d.Eyevec1             = REG_RD32(NV_PGRAPH_EYEVEC1);
        pSwCtxTable->grCtx3d.Eyevec2             = REG_RD32(NV_PGRAPH_EYEVEC2);
        
        pSwCtxTable->grCtx3d.Shadow              = REG_RD32(NV_PGRAPH_SHADOW);
        pSwCtxTable->grCtx3d.FdData              = REG_RD32(NV_PGRAPH_FD_DATA);
        pSwCtxTable->grCtx3d.FdSwatch            = REG_RD32(NV_PGRAPH_FD_SWATCH);
        pSwCtxTable->grCtx3d.FdExtras            = REG_RD32(NV_PGRAPH_FD_EXTRAS);
        pSwCtxTable->grCtx3d.Emission0           = REG_RD32(NV_PGRAPH_EMISSION_BACKUP_0);
        pSwCtxTable->grCtx3d.Emission1           = REG_RD32(NV_PGRAPH_EMISSION_BACKUP_1);
        pSwCtxTable->grCtx3d.Emission2           = REG_RD32(NV_PGRAPH_EMISSION_BACKUP_2);
        pSwCtxTable->grCtx3d.SceneAmb0           = REG_RD32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_0);
        pSwCtxTable->grCtx3d.SceneAmb1           = REG_RD32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_1);
        pSwCtxTable->grCtx3d.SceneAmb2           = REG_RD32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_2);
        pSwCtxTable->grCtx3d.ContextDmaGetState  = REG_RD32(NV_PGRAPH_GETSTATE);
        pSwCtxTable->grCtx3d.BeginPatch0         = REG_RD32(NV_PGRAPH_BEGINPATCH0);
        pSwCtxTable->grCtx3d.BeginPatch1         = REG_RD32(NV_PGRAPH_BEGINPATCH1);
        pSwCtxTable->grCtx3d.BeginPatch2         = REG_RD32(NV_PGRAPH_BEGINPATCH2);
        pSwCtxTable->grCtx3d.BeginPatch3         = REG_RD32(NV_PGRAPH_BEGINPATCH3);
        pSwCtxTable->grCtx3d.BeginCurve          = REG_RD32(NV_PGRAPH_CURVE);
        pSwCtxTable->grCtx3d.BeginTrans0         = REG_RD32(NV_PGRAPH_BEGINTRANS0);
        pSwCtxTable->grCtx3d.BeginTrans1         = REG_RD32(NV_PGRAPH_BEGINTRANS1);
        pSwCtxTable->grCtx3d.Csv0_D              = REG_RD32(NV_PGRAPH_CSV0_D);
        pSwCtxTable->grCtx3d.Csv0_C              = REG_RD32(NV_PGRAPH_CSV0_C);
        pSwCtxTable->grCtx3d.Csv1_B              = REG_RD32(NV_PGRAPH_CSV1_B);
        pSwCtxTable->grCtx3d.Csv1_A              = REG_RD32(NV_PGRAPH_CSV1_A);
        pSwCtxTable->grCtx3d.CheopsOffset        = REG_RD32(NV_PGRAPH_CHEOPS_OFFSET);
        
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, RDI_ADDR_ZERO, IDX_FMT_COUNT, pSwCtxTable->grCtxPipe.IdxFmt);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, RDI_ADDR_ZERO, CAS0_COUNT, pSwCtxTable->grCtxPipe.Cas0);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, RDI_ADDR_ZERO, CAS1_COUNT, pSwCtxTable->grCtxPipe.Cas1);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, RDI_ADDR_ZERO, CAS2_COUNT, pSwCtxTable->grCtxPipe.Cas2);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_ASSM_STATE, RDI_ADDR_ZERO, ASSM_STATE_COUNT, pSwCtxTable->grCtxPipe.AssmState);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE0, RDI_ADDR_ZERO, IDX_CACHE0_COUNT, pSwCtxTable->grCtxPipe.IdxCache0);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE1, RDI_ADDR_ZERO, IDX_CACHE1_COUNT, pSwCtxTable->grCtxPipe.IdxCache1);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE2, RDI_ADDR_ZERO, IDX_CACHE2_COUNT, pSwCtxTable->grCtxPipe.IdxCache2);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE3, RDI_ADDR_ZERO, IDX_CACHE3_COUNT, pSwCtxTable->grCtxPipe.IdxCache3);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_VTX_FILE0, RDI_ADDR_ZERO, VTX_FILE0_COUNT, pSwCtxTable->grCtxPipe.VtxFile0);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_VTX_FILE1, RDI_ADDR_ZERO, VTX_FILE1_COUNT, pSwCtxTable->grCtxPipe.VtxFile1);
        
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_P, RDI_ADDR_ZERO, XL_P_COUNT, pSwCtxTable->grCtxPipe.XlP);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_XFCTX, RDI_ADDR_ZERO, XL_XFCTX_COUNT, pSwCtxTable->grCtxPipe.XlXfCtx);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_LTCTX, RDI_ADDR_ZERO, XL_LTCTX_COUNT, pSwCtxTable->grCtxPipe.XlLtCtx);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_LTC, RDI_ADDR_ZERO, XL_LTC_COUNT, pSwCtxTable->grCtxPipe.XlLtc);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, RDI_ADDR_ZERO, XL_VAB_COUNT, pSwCtxTable->grCtxPipe.XlVab);
        
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CRSTR_STIPP, RDI_ADDR_ZERO, CRSTR_STIPP_COUNT, pSwCtxTable->grCtxPipe.CrstrStipp);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_FD_CTRL, RDI_ADDR_ZERO, FD_CTRL_COUNT, pSwCtxTable->grCtxPipe.FdCtrl);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_ROP_REGS, RDI_ADDR_ZERO, ROP_REGS_COUNT, pSwCtxTable->grCtxPipe.RopRegs);
    }

    // wait for the pipe to go idle again after unloading the pipeline context
    HAL_GR_IDLE(pHalHwInfo);

    //
    // Invalidate hw's channel ID.
    //
    REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));

    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, (NUM_FIFOS_NV20 - 1));

    return (RM_OK);
}
#endif // #ifdef NV20_SW_CTX_SWITCH
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\gr\nv10\grnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRCHIP.C                                                          *
*   The graphics chip dependent routines are kept here.                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalGrControl_NV10(VOID *);
RM_STATUS nvHalGrAlloc_NV10(VOID *);
RM_STATUS nvHalGrFree_NV10(VOID *);
RM_STATUS nvHalGrGetExceptionData_NV10(VOID *);
RM_STATUS nvHalGrService_NV10(VOID *);
RM_STATUS nvHalGrGetNotifyData_NV10(VOID *);
RM_STATUS nvHalGrSetObjectContext_NV10(VOID *);
RM_STATUS nvHalGrLoadOverride_NV10(VOID *);

// statics
static RM_STATUS _nvHalGrInitObjectContext_NV10(PHALHWINFO, U032, U032);
static VOID _nvHalGrInitCelsius_NV10(PHALHWINFO, U032);
static VOID _nvHalGrInitDx5_NV10(PHALHWINFO, U032);

// externs
extern RM_STATUS nvHalGrClassSoftwareMethod_NV10(PHALHWINFO, PGREXCEPTIONDATA);
extern RM_STATUS nvHalGrLoadChannelContext_NV10(PHALHWINFO, U032);
extern RM_STATUS nvHalGrUnloadChannelContext_NV10(PHALHWINFO, U032);

//
// nvHalGrControl
//
RM_STATUS
nvHalGrControl_NV10(VOID *arg)
{
    PGRCONTROLARG_000 pGrControlArg = (PGRCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrControlArg->pHalHwInfo;
    PGRHALINFO pGrHalInfo;
    PGRHALINFO_NV10 pGrHalPvtInfo;
    PHWREG nvAddr;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrControl_NV10\r\n");

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pGrControlArg->id != GR_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrControlArg->pHalHwInfo;
    pGrHalInfo = pHalHwInfo->pGrHalInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    
    switch (pGrControlArg->cmd)
    {
        case GR_CONTROL_INIT:
            //
            // Initialize graphics debug values.
            //
            switch (REG_RD_DRF(_PMC, _BOOT_0, _MAJOR_REVISION))
            {
                case NV_PMC_BOOT_0_MAJOR_REVISION_A:
                default:
                    pGrHalPvtInfo->Debug0 = 0x0;        // all DEBUG0 bits are RESET bits in NV10
                    pGrHalPvtInfo->Debug1 = (U032)
                        DRF_DEF(_PGRAPH, _DEBUG_1, _VOLATILE_RESET,   _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _VTX_PTE,          _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _VTX_CACHE,        _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _VTX_FILE,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _DRAWDIR_AUTO,     _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _DRAWDIR_Y,        _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _INSTANCE,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _CTX,              _INIT);
                    pGrHalPvtInfo->Debug2 = (U032)
                        DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_LIMIT_CHECK,    _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_LIMIT_INT,      _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_OVRFLW_INT,     _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_COALESCE_3D,    _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_COALESCE_2D,    _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_TRIEND_FLUSH,   _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_DITHER_3D,      _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_DITHER_2D,      _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_TILE3D2HIGH,    _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_SWALLOW_REQS,   _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_ALPHA_ABORT,    _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_FIXED_ADRS,     _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_DITHER_RANGE,   _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_PITCH_CHECK_2D, _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_PITCH_CHECK_3D, _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_TILEVIOL,          _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_DITHER_3D,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_DITHER_2D,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_EARLY_ZABORT,      _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_BLIT_MULTILINE,    _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_BLIT_DST_LIMIT,    _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_SDR_FAST_BLEND,    _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_2D_FAST_CONV,      _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_HPREQ,             _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_BITBUCKET,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_FIXED_ADRS,        _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_FAST_KEEP_DST,     _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_FORCE_CREAD,       _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_FORCE_ZREAD,       _INIT);

                    pGrHalPvtInfo->Debug3 = (U032)
                        DRF_DEF(_PGRAPH, _DEBUG_3, _FAST_DATA_STRTCH,      _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _FAST_3D_SHADOW_DATA,   _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _FAST_DMA_READ,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _IDLE_FILTER,           _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _INHIBIT_IMCLASS_BLOCK, _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _SYNCHRONIZE,           _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _D3D_STATE3D,           _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _OBJECT_RELOAD,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _PM_TRIGGER,            _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _ALTARCH,               _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _SINGLE_CYCLE_LOAD,     _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _BILINEAR_3D,           _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _VOLATILE_RESET,        _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _DATA_CHECK,            _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _DATA_CHECK_FAIL,       _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _FORMAT_CHECK,          _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _DMA_CHECK,             _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _STATE_CHECK,           _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _IMAGE_64BIT,           _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _CELSIUS_64BIT,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _STATE3D_CHECK,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _XFMODE_COALESCE,       _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _CTX_METHODS,           _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _OP_METHODS,            _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _IGNORE_PATCHVALID,     _INIT);

                    //
                    // Turn this bit on for nv15/nv11 to avoid problems when class07c
                    // writes NV_PGRAPH_INCREMENT_READ_3D when gfx isn't idle. The gfx
                    // engine can't be idled because it's stalled waiting for the
                    // increment trigger.
                    //
                    if (IsNV15_NV10(pHalHwInfo->pMcHalInfo) ||
                        IsNV11_NV10(pHalHwInfo->pMcHalInfo))
                        pGrHalPvtInfo->Debug3 |= DRF_DEF(_PGRAPH, _DEBUG_3, _INHIBIT_IMCLASS_BLOCK, _ENABLED);

                    pGrHalPvtInfo->Debug4 = 0x0;       // all DEBUG4 bits are SPARES currently
                    break;
            }

            //
            // NV11 seems to be faster if we don't separate color/Z with SDR memory,
            // I still need to get confirmation from Jonah on this DEBUG bit though ...
            //
            if (IsNV11_NV10(pHalHwInfo->pMcHalInfo)) {
                pGrHalPvtInfo->Debug2 |= DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_SEP_ZC_READS, _DISABLED);
            } else {
                // Separate color and Z reads on SDR memory configurations
                if (REG_RD_DRF(_PFB, _CFG, _TYPE) == NV_PFB_CFG_TYPE_SDR)
                    pGrHalPvtInfo->Debug2 |= DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_SEP_ZC_READS, _ENABLED);
                else
                    pGrHalPvtInfo->Debug2 |= DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_SEP_ZC_READS, _DISABLED);
            }

            // Also set some NV11 specific DEBUG bits (e.g. enable Z/C mix)
            if (IsNV11_NV10(pHalHwInfo->pMcHalInfo)) {
                pGrHalPvtInfo->Debug2 |= (DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_NV11_OPTS,   _INIT)
                                      |   DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_ALLOW_ZCMIX, _INIT));
            }

            //
            // Set default channel to unused chid
            //
            pGrHalPvtInfo->currentChID = INVALID_CHID;
            break;
        case GR_CONTROL_LOAD:
            REG_WR_DRF_DEF(_PGRAPH, _DEBUG_1, _VOLATILE_RESET, _LAST);
            REG_WR_DRF_DEF(_PGRAPH, _DEBUG_0, _STATE, _RESET);
            FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_1, _DMA_ACTIVITY, _CANCEL);
            
            REG_WR32(NV_PGRAPH_DEBUG_0, pGrHalPvtInfo->Debug0);
            REG_WR32(NV_PGRAPH_DEBUG_1, pGrHalPvtInfo->Debug1);
            REG_WR32(NV_PGRAPH_DEBUG_2, pGrHalPvtInfo->Debug2);
            REG_WR32(NV_PGRAPH_DEBUG_3, pGrHalPvtInfo->Debug3);
            REG_WR32(NV_PGRAPH_DEBUG_4, pGrHalPvtInfo->Debug4);

            // FROM NV10_NvChipRestoreTiledRanges(pDev)

            // 
            // PGRAPH_TILE values will be reset after a PGRAPH_DEBUG_0_STATE_RESET.
            // Unfortunately, it may have had values we wanted (e.g. from stateFb),
            // so after a DEBUG_0_STATE_RESET, restore the PGRAPH values from PFB.
            //
            HAL_GR_IDLE(pHalHwInfo);

            for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
            {
                REG_WR32(NV_PGRAPH_TLIMIT(i), REG_RD32(NV_PFB_TLIMIT(i)));
                REG_WR32(NV_PGRAPH_TSIZE(i), REG_RD32(NV_PFB_TSIZE(i)));
                REG_WR32(NV_PGRAPH_TILE(i), REG_RD32(NV_PFB_TILE(i)));
            }

            // FROM NV10_grStateLoadContext

            //
            // Load debug overrides.
            //
            REG_WR32(NV_PGRAPH_CTX_SWITCH1,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_SWITCH2,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_SWITCH3,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_SWITCH4,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_CONTROL,
                     DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
            REG_WR_DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS, _VALID);

            //
            // Reload current graphics context.
            //
            (void) nvHalGrLoadChannelContext_NV10(pHalHwInfo, pGrHalPvtInfo->currentChID);
            break;
        case GR_CONTROL_UNLOAD:
            //
            // Pull out current graphics state.
            //
            (void) nvHalGrLoadChannelContext_NV10(pHalHwInfo, INVALID_CHID);

            // FROM NV10_grStateUnLoadContext
            REG_WR32(NV_PGRAPH_CTX_CONTROL,
                     DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
            break;
        case GR_CONTROL_DESTROY:
        case GR_CONTROL_UPDATE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalGrAlloc
//
RM_STATUS
nvHalGrAlloc_NV10(VOID *arg)
{
    PGRALLOCARG_000 pGrAllocArg = (PGRALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrAllocArg->pHalHwInfo;
    PGRHALINFO pGrHalInfo;
    PGRHALINFO_NV10 pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV10 pGrChannel;
    PHWREG nvAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrAlloc_NV10\r\n");

    //
    // Verify interface revision.
    //
    if (pGrAllocArg->id != GR_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrAllocArg->pHalHwInfo;
    pGrHalInfo = pHalHwInfo->pGrHalInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    pGrChannel = &pGrHalPvtInfo->grChannels[pGrAllocArg->chid];
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // If we've got a 3d object, keep note of it.
    //
    if ((pGrAllocArg->classNum == NV10_CELSIUS_PRIMITIVE) ||
        (pGrAllocArg->classNum == NV10_DX5_TEXTURED_TRIANGLE) ||
        (pGrAllocArg->classNum == NV10_DX6_MULTI_TEXTURE_TRIANGLE) ||
        (pGrAllocArg->classNum == NV15_CELSIUS_PRIMITIVE) ||
        (pGrAllocArg->classNum == NV11_CELSIUS_PRIMITIVE))
    {
        U032 currClass = 0;

        if (pGrHalPvtInfo->currentObjects3d[pGrAllocArg->chid] != 0)
            currClass = DRF_VAL(_PGRAPH, _CTX_SWITCH1, _GRCLASS, INST_RD32(pGrHalPvtInfo->currentObjects3d[pGrAllocArg->chid], SF_OFFSET(NV_PRAMIN_CONTEXT_0)));

        //
        // For DX5/DX6, we're not able to handle a Celsius object in the same channel,
        // since their init graphics routines are different. Check that a Celsius 3D
        // object hasn't already been created (multiple DX5/DX6 are OK).
        //
        if ((pGrAllocArg->classNum == NV10_DX6_MULTI_TEXTURE_TRIANGLE ||
             pGrAllocArg->classNum == NV10_DX5_TEXTURED_TRIANGLE) &&
            (currClass == NV10_CELSIUS_PRIMITIVE ||
             currClass == NV15_CELSIUS_PRIMITIVE ||
             currClass == NV11_CELSIUS_PRIMITIVE))
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: 3d state in use by celsius instance ", pGrHalPvtInfo->currentObjects3d[pGrAllocArg->chid]);
            return (RM_ERR_ILLEGAL_OBJECT);
        }

        //
        // For Celsius, we're not able to handle either DX5/DX6 or another Celsius
        // object in the same channel, since their init graphics routines (in gr\nv10 dir)
        // are different. Check that a current 3D object hasn't already been created.
        //
        if ((pGrAllocArg->classNum == NV10_CELSIUS_PRIMITIVE ||
             pGrAllocArg->classNum == NV15_CELSIUS_PRIMITIVE ||
             pGrAllocArg->classNum == NV11_CELSIUS_PRIMITIVE) &&
            (currClass == NV10_DX6_MULTI_TEXTURE_TRIANGLE ||
             currClass == NV10_DX5_TEXTURED_TRIANGLE))
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: 3d state in use by DX instance ", pGrHalPvtInfo->currentObjects3d[pGrAllocArg->chid]);
            return (RM_ERR_ILLEGAL_OBJECT);
        }

        pGrHalPvtInfo->currentObjects3d[pGrAllocArg->chid] = pGrAllocArg->instance;

        if ((pGrAllocArg->classNum == NV10_CELSIUS_PRIMITIVE) ||
            (pGrAllocArg->classNum == NV15_CELSIUS_PRIMITIVE) ||
            (pGrAllocArg->classNum == NV11_CELSIUS_PRIMITIVE))
            _nvHalGrInitCelsius_NV10(pHalHwInfo, pGrAllocArg->chid);
        else
            _nvHalGrInitDx5_NV10(pHalHwInfo, pGrAllocArg->chid);
    }

    //
    // Initialize context.
    //
    _nvHalGrInitObjectContext_NV10(pHalHwInfo, pGrAllocArg->instance, pGrAllocArg->classNum);

    return (RM_OK);
}

//
// nvHalGrFree
//
RM_STATUS
nvHalGrFree_NV10(VOID *arg)
{
    PGRFREEARG_000 pGrFreeArg = (PGRFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PGRHALINFO pGrHalInfo;
    PGRHALINFO_NV10 pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV10 pGrChannel;
    PHWREG nvAddr;
    U032 i;

    //
    // Verify interface revision.
    //
    if (pGrFreeArg->id != GR_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrFreeArg->pHalHwInfo;
    pGrHalInfo = pHalHwInfo->pGrHalInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    pGrChannel = &pGrHalPvtInfo->grChannels[pGrFreeArg->chid];
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Clear 3d current object pointer if necessary.
    //
    if (pGrFreeArg->instance == pGrHalPvtInfo->currentObjects3d[pGrFreeArg->chid])
    {
        // we could ASSERT that this is a 3d object here as well
        pGrHalPvtInfo->currentObjects3d[pGrFreeArg->chid] = 0;

        // clear the Celsius bit (either never had one or it was just freed)
        pGrHalInfo->has3dObject &= ~(0x1 << pGrFreeArg->chid);
    }

    //
    // Zero out the object context for good measure.
    //
    for (i = 0; i < 4; i++)
    {
        INST_WR32(pGrFreeArg->instance, i, 0);
    }

    return (RM_OK);
}

//
// nvHalGrGetExceptionData
//
// Retrieve graphics engine exception data.
//
RM_STATUS
nvHalGrGetExceptionData_NV10(VOID *arg)
{
    PGRGETEXCEPTIONDATAARG_000 pGrGetExceptionDataArg = (PGRGETEXCEPTIONDATAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PGREXCEPTIONDATA pGrExceptionData;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pGrGetExceptionDataArg->id != GR_GET_EXCEPTION_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrGetExceptionDataArg->pHalHwInfo;
    pGrExceptionData = pGrGetExceptionDataArg->pExceptionData;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Fill in exception data.
    //
    pGrExceptionData->Offset = REG_RD32(NV_PGRAPH_TRAPPED_ADDR);
    pGrExceptionData->ChID = DRF_VAL(_PGRAPH, _TRAPPED_ADDR, _CHID, pGrExceptionData->Offset);
    pGrExceptionData->NotifyInstance = REG_RD_DRF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE);
    pGrExceptionData->classNum = REG_RD_DRF(_PGRAPH, _CTX_SWITCH1, _GRCLASS);
    pGrExceptionData->Data = REG_RD32(NV_PGRAPH_TRAPPED_DATA_LOW); 
    pGrExceptionData->Instance = REG_RD32(NV_PGRAPH_CTX_SWITCH4);
    pGrExceptionData->Offset &= (DRF_MASK(NV_PGRAPH_TRAPPED_ADDR_MTHD) << DRF_SHIFT(NV_PGRAPH_TRAPPED_ADDR_MTHD));
    pGrExceptionData->Nsource = REG_RD32(NV_PGRAPH_NSOURCE);
    pGrExceptionData->MethodStatus = RM_OK;

    return (RM_OK);
}

//
// nvHalGrService
//
// Handle selected graphics object exceptions.
//
RM_STATUS
nvHalGrService_NV10(VOID *arg)
{
    PGRSERVICEARG_000 pGrServiceArg = (PGRSERVICEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PGRHALINFO_NV10 pGrHalPvtInfo;
    PGREXCEPTIONDATA pGrExceptionData;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pGrServiceArg->id != GR_SERVICE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrServiceArg->pHalHwInfo;
    pGrExceptionData = pGrServiceArg->pExceptionData;
    pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Make sure object is valid.
    //
    //if (pGrExceptionData->instance == 0)
    //    return (NV_HAL_ERROR_INVALID_STATE);

    //
    // Handle any exceptions...
    //
    if (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _SINGLE_STEP, _PENDING))
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "SingleStep method: ", REG_RD32(NV_PGRAPH_TRAPPED_ADDR));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "SingleStep data  : ", REG_RD32(NV_PGRAPH_TRAPPED_DATA_LOW));

        // turn on the single step bit for this channel
        REG_WR_DRF_DEF(_PGRAPH, _INTR, _SINGLE_STEP, _RESET);
        DBG_BREAKPOINT();
    }

    if (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _CONTEXT_SWITCH, _PENDING))
    {
        //
        // Reset condition.
        //
        REG_WR_DRF_DEF(_PGRAPH, _INTR, _CONTEXT_SWITCH, _RESET);

        //
        // Wait for idle
        //
        GR_DONE();
    
        //
        // Graphics channel switch.
        //
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Graphics context switch exception.\n\r");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Previous graphics channel:",pGrHalPvtInfo->currentChID);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: New graphics channel:", pGrExceptionData->ChID);

        (void) nvHalGrLoadChannelContext_NV10(pHalHwInfo, pGrExceptionData->ChID);
    }

    //
    // Handle methods in software.
    //
    if (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _MISSING_HW, _PENDING))
    {
        if (nvHalGrClassSoftwareMethod_NV10(pHalHwInfo, pGrExceptionData) == RM_OK)
        {
            // Reset condition.
            REG_WR_DRF_DEF(_PGRAPH, _INTR, _MISSING_HW, _RESET);
        }
    }

    if ((pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _PENDING)) ||
        (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _ERROR, _PENDING)))
    {
        if (pGrExceptionData->Nsource & DRF_DEF(_PGRAPH, _NSOURCE, _ILLEGAL_MTHD, _PENDING))
        {
            if (nvHalGrClassSoftwareMethod_NV10(pHalHwInfo, pGrExceptionData) == RM_OK)
            {
                // Reset condition.
                if (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _PENDING))
                    REG_WR_DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _RESET);
                else
                    REG_WR_DRF_DEF(_PGRAPH, _INTR, _ERROR, _RESET);
            }
        }
    }

    return (RM_OK);
}

//
// nvHalGrNotifyData
//
// Fill in notify data (trigger status and action).
//
RM_STATUS
nvHalGrGetNotifyData_NV10(VOID *arg)
{
    PGRGETNOTIFYDATAARG_000 pGrGetNotifyDataArg = (PGRGETNOTIFYDATAARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrGetNotifyDataArg->pHalHwInfo;
    PGRNOTIFYDATA pGrNotifyData;
    PHWREG nvAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrGetNotifyData_NV10\r\n");

    //
    // Verify interface revision.
    //
    if (pGrGetNotifyDataArg->id != GR_GET_NOTIFY_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrGetNotifyDataArg->pHalHwInfo;
    pGrNotifyData = pGrGetNotifyDataArg->pGrNotifyData;
    nvAddr = pHalHwInfo->nvBaseAddr;

    if (REG_RD32(NV_PGRAPH_NOTIFY) &
        (DRF_DEF(_PGRAPH, _NOTIFY, _REQ, _PENDING) |
         DRF_DEF(_PGRAPH, _NOTIFY, _STYLE, _WRITE_THEN_AWAKEN)))
    {
        pGrNotifyData->trigger = TRUE;
        pGrNotifyData->action =  REG_RD_DRF(_PGRAPH, _NOTIFY, _STYLE);
        // clear the notify condition
        FLD_WR_DRF_DEF(_PGRAPH, _NOTIFY, _REQ, _NOT_PENDING);
    } else {
        pGrNotifyData->trigger = FALSE;
        pGrNotifyData->action = 0;
    }

    return (RM_OK);
}

//
// nvHalGrSetObjectContext
//
// Update various graphics object context bits.
// On NV10, these bits are managed by hardware so this
// routine does some error checking and returns.
//
RM_STATUS
nvHalGrSetObjectContext_NV10(VOID *arg)
{
    PGRSETOBJECTCONTEXTARG_000 pGrSetObjectContextArg = (PGRSETOBJECTCONTEXTARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrSetObjectContextArg->pHalHwInfo;
    PHWREG nvAddr;
    U032 context, instance;
    U032 fifo;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrSetObjectContext_NV10\r\n");

    //
    // Verify interface revision.
    //
    if (pGrSetObjectContextArg->id != GR_SET_OBJECT_CONTEXT_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Verify chid.
    //
    if (pGrSetObjectContextArg->chid > NUM_FIFOS_NV10)
        return (RM_ERR_BAD_ARGUMENT);

    //
    // Verify instance (what else can we do here without
    // keeping track of all objects that pass through the
    // nvHalGrAlloc interface down in the HAL?).
    //
    if (pGrSetObjectContextArg->instance == 0)
        return (RM_ERR_BAD_ARGUMENT);

    pHalHwInfo = pGrSetObjectContextArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    instance = pGrSetObjectContextArg->instance;
    
    //
    // Fetch current context.
    //
    context = INST_RD32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0));

    //
    // Make necessary adjustments.
    //
    context &= pGrSetObjectContextArg->andMask;
    context |= pGrSetObjectContextArg->orMask;

    //
    // Write it back out                   
    //
    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0), context);
        
    //
    // Now we need to update the hardware context if appropriate.
    //
    if (pGrSetObjectContextArg->chid == REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID))
    {
        //
        // First disable the graphics fifo so we can get to the context rams
        //
        fifo = REG_RD32(NV_PGRAPH_FIFO);
        REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
            
        //
        // Walk to subchannels and see if we find a match; update when we do
        //
        for (i = 0 ; i < 8 ; i++)
        {            
            if (REG_RD32(NV_PGRAPH_CTX_CACHE4(i)) == instance)
            {   
                //
                // Get the current settings
                //
                context = REG_RD32(NV_PGRAPH_CTX_CACHE1(i));

                //
                // Make necessary adjustments.
                //
                context &= pGrSetObjectContextArg->andMask;
                context |= pGrSetObjectContextArg->orMask;

                //
                // Write it back out                   
                //
                REG_WR32(NV_PGRAPH_CTX_CACHE1(i), context);
            }
        }                                    
                             
        //
        // See if the currently active subchannel also needs updating
        //
        if (REG_RD_DRF(_PGRAPH, _CTX_SWITCH4, _USER_INSTANCE) == instance)
        {   
            //
            // Get the current settings
            //
            context = REG_RD32(NV_PGRAPH_CTX_SWITCH1);

            //
            // Make necessary adjustments.
            //
            context &= pGrSetObjectContextArg->andMask;
            context |= pGrSetObjectContextArg->orMask;

            //
            // Write it back out                   
            //
            REG_WR32(NV_PGRAPH_CTX_SWITCH1, context);
        }
            
        //
        // Restore the fifo state
        //
        REG_WR32(NV_PGRAPH_FIFO, fifo);
        
    }    
    return (RM_OK);
}

RM_STATUS
nvHalGrLoadOverride_NV10(VOID *arg)
{
    PGRLOADOVERRIDEARG_000 pGrLoadOverrideArg = (PGRLOADOVERRIDEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PGRHALINFO_NV10 pGrHalPvtInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pGrLoadOverrideArg->id != GR_LOAD_OVERRIDE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrLoadOverrideArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;

    switch (pGrLoadOverrideArg->cmd)
    {
        case GR_LOAD_OVERRIDE_DEBUG0:
            pGrHalPvtInfo->Debug0 = pGrLoadOverrideArg->value;
            break;
        case GR_LOAD_OVERRIDE_DEBUG1:
            pGrHalPvtInfo->Debug1 = pGrLoadOverrideArg->value;
            break;
        case GR_LOAD_OVERRIDE_DEBUG2:
            pGrHalPvtInfo->Debug2 = pGrLoadOverrideArg->value;
            break;
        case GR_LOAD_OVERRIDE_DEBUG3:
            pGrHalPvtInfo->Debug3 = pGrLoadOverrideArg->value;
            break;
        case GR_LOAD_OVERRIDE_SWATHCTL:
            pGrHalPvtInfo->SwathControl = pGrLoadOverrideArg->value;
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}



static RM_STATUS
_nvHalGrInitObjectContext_NV10(
    PHALHWINFO  pHalHwInfo,
    U032        instance,
    U032        classNum
)
{
    U032 ctx1, ctx2, ctx3;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    // default _CTX_SWITCH1 value
    ctx1 = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _GRCLASS, classNum)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, _SRCCOPY_AND)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _INVALID);    

    // turn on big endian for this class if supported and we're in big endian mode
    if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
        ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _ENDIAN_MODE, _BIG);

    // default _CTX_SWITCH2 value
    ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _INVALID)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);

    // default _CTX_SWITCH3 value
    ctx3 = DRF_DEF(_PGRAPH, _CTX_SWITCH3, _DMA_INSTANCE_0, _INVALID)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH3, _DMA_INSTANCE_1, _INVALID);

    switch (classNum)
    {
        case NV01_CONTEXT_BETA:
        case NV01_CONTEXT_CLIP_RECTANGLE:
        case NV01_IMAGE_BLIT:
        case NV03_CONTEXT_ROP:
        case NV04_CONTEXT_SURFACES_2D:
        case NV03_DX3_TEXTURED_TRIANGLE:
        case NV04_CONTEXT_SURFACE_SWIZZLED:
        case NV04_CONTEXT_SURFACES_3D:
        case NV03_CONTEXT_SURFACE_2D_DESTINATION:
        case NV03_CONTEXT_SURFACE_2D_SOURCE:
        case NV03_CONTEXT_SURFACE_3D_COLOR:
        case NV03_CONTEXT_SURFACE_3D_DEPTH:
        case NV04_IMAGE_BLIT:
        case NV04_CONTEXT_BETA:
        case NV10_CONTEXT_SURFACES_2D:
        case NV10_CONTEXT_SURFACES_3D:
        case NV15_IMAGE_BLIT:
            // defaults are fine
            break;
        case NV01_CONTEXT_COLOR_KEY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16A8Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV01_CONTEXT_PATTERN:
        case NV04_CONTEXT_PATTERN:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _CGA6_M1)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16A8Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV01_RENDER_SOLID_LIN:
        case NV01_RENDER_SOLID_TRIANGLE:
        case NV01_RENDER_SOLID_RECTANGLE:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X24Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV01_IMAGE_FROM_CPU:
        case NV03_STRETCHED_IMAGE_FROM_CPU:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV1_NULL:
            //
            // The NULL object is really a pseudo-dma object, so it needs a valid
            // limit value and should also have the PAGE_TABLE_PRESENT bit set.
            //
            ctx1 |= SF_DEF(_DMA, _PAGE_TABLE, _PRESENT);
            ctx2 = 0xffffffff;
            //INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_1), 0xFFFFFFFF);
            //FLD_WR_ISF_DEF(instance, _DMA, _PAGE_TABLE, _PRESENT);
            break;
        case NV03_SCALED_IMAGE_FROM_MEMORY:
        case NV04_SCALED_IMAGE_FROM_MEMORY:
        case NV10_SCALED_IMAGE_FROM_MEMORY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A1R5G5B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV11_SCALED_IMAGE_FROM_MEMORY:
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CLASS_TYPE, _PERFORMANCE);
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A1R5G5B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_DVD_SUBPICTURE:
        case NV10_DVD_SUBPICTURE:
            //
            // DVD class is patchless, so it is always considered valid.  HW doesn't
            // use this bit, but let's set it anyway to be consistent with other
            // objects
            //
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID);
            break;
        case NV03_MEMORY_TO_MEMORY_FORMAT:
            // Note that this object is always considered patch valid
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID);
            break;
        case NV04_GDI_RECTANGLE_TEXT:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _CGA6_M1)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV03_GDI_RECTANGLE_TEXT:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _CGA6_M1)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X24Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_DX5_TEXTURED_TRIANGLE:
        case NV10_DX5_TEXTURED_TRIANGLE:
            //
            // DX5 class is patchless, so it is always considered valid.  HW doesn't
            // use this bit, but let's set it anyway to be consistent with other
            // objects
            //
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID);
            break;
        case NV04_DX6_MULTI_TEXTURE_TRIANGLE:
        case NV10_DX6_MULTI_TEXTURE_TRIANGLE:
            //
            // DX6 class is patchless, so it is always considered valid.  HW doesn't
            // use this bit, but let's set it anyway to be consistent with other
            // objects
            //
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID);
            break;
        case NV04_CONTEXT_COLOR_KEY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A16R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_RENDER_SOLID_LIN:
        case NV04_RENDER_SOLID_TRIANGLE:
        case NV04_RENDER_SOLID_RECTANGLE:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_INDEXED_IMAGE_FROM_CPU:
        case NV04_IMAGE_FROM_CPU:
        case NV04_STRETCHED_IMAGE_FROM_CPU:
        case NV10_IMAGE_FROM_CPU:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV05_SCALED_IMAGE_FROM_MEMORY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A1R5G5B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV05_INDEXED_IMAGE_FROM_CPU:
        case NV05_IMAGE_FROM_CPU:
        case NV05_STRETCHED_IMAGE_FROM_CPU:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV11_CELSIUS_PRIMITIVE:
            //
            // The above DRF_NUM macro on GRCLASS has already masked this class
            // number to an 8bit value, we just need to set the PERFORMANCE bit.
            //
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CLASS_TYPE, _PERFORMANCE);
        case NV10_CELSIUS_PRIMITIVE:
        case NV15_CELSIUS_PRIMITIVE:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV10_TEXTURE_FROM_CPU:
            // TEXTURE_FROM_CPU is similar to the IMAGE_FROM_CPU classes, but with
            // only a subset of the methods, so we'll need to make sure things are
            // initialized in a way that makes sense for this class.
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, _SRCCOPY)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, _TRUNCATE);    
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        default:
            // assume defaults are cool
            break;
    }

    //
    // Write out the values.
    //
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: instance data for classNum ", classNum);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "      instance offset ", instance);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "      ctx1 ", ctx1);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "      ctx2 ", ctx2);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "      ctx3 ", ctx3);

    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0), ctx1);
    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_1), ctx2);
    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_2), ctx3);
    //
    // Be sure to clear this dword clear to keep the graphics method
    // trapped disabled.
    //
    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_3), 0);

    return (RM_OK);
}

//
// Given a pipe address and ChID return the corresponding pipe context save area in grTable.
// This way, pipe state can be preloaded in the grTable and put in the HW during the first
// grctxt switch.
//
static U032 *
grInitPipeContextAddr(
    PGRAPHICSCHANNEL_NV10 pGrChan,
    U032 base
)
{
    U032 index;

    if (base >= PIPE_FORMAT_BASE && base < (PIPE_FORMAT_BASE + (INDEX_DMA_FORMAT_COUNT*4)))
    {
        index = (base - PIPE_FORMAT_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.IndexDmaFormat[index];
    }
    if (base >= PIPE_PRIM_BASE && base < (PIPE_PRIM_BASE + (INDEX_DMA_PRIM_COUNT*4)))
    {
        index = (base - PIPE_PRIM_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.IndexDmaPrim[index];
    }
    if (base >= PIPE_ASSM_BASE && base < (PIPE_ASSM_BASE + (PRIM_ASSM_COUNT*4)))
    {
        index = (base - PIPE_ASSM_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.PrimAssm[index];
    }
    if (base >= PIPE_FILE_BASE && base < (PIPE_FILE_BASE + (VERTEX_FILE_COUNT*4)))
    {
        index = (base - PIPE_FILE_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.VertexFile[index];
    }
    if (base >= PIPE_VAB_BASE && base < (PIPE_VAB_BASE + (XF_VAB_COUNT*4)))
    {
        index = (base - PIPE_VAB_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.XF_VAB[index];
    }
    if (base >= PIPE_CHEOPS_BASE && base < (PIPE_CHEOPS_BASE + (XF_CHEOPS_COUNT*4)))
    {
        index = (base - PIPE_CHEOPS_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.XF_CHEOPS[index];
    }
    if (base >= PIPE_ZOSER_BASE && base < (PIPE_ZOSER_BASE + (XF_ZOSER_COUNT*4)))
    {
        index = (base - PIPE_ZOSER_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER[index];
    }
    if (base >= PIPE_ZOSER_C0_BASE && base < (PIPE_ZOSER_C0_BASE + (XF_ZOSER_C0_COUNT*4)))
    {
        index = (base - PIPE_ZOSER_C0_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C0[index];
    }
    if (base >= PIPE_ZOSER_C1_BASE && base < (PIPE_ZOSER_C1_BASE + (XF_ZOSER_C1_COUNT*4)))
    {
        index = (base - PIPE_ZOSER_C1_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C1[index];
    }
    if (base >= PIPE_ZOSER_C2_BASE && base < (PIPE_ZOSER_C2_BASE + (XF_ZOSER_C2_COUNT*4)))
    {
        index = (base - PIPE_ZOSER_C2_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C2[index];
    }
    if (base >= PIPE_ZOSER_C3_BASE && base < (PIPE_ZOSER_C3_BASE + (XF_ZOSER_C3_COUNT*4)))
    {
        index = (base - PIPE_ZOSER_C3_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C3[index];
    }

    return NULL;        // error
}

#define grInitPipeContextData(data)     *pipectx++ = data;

static VOID
_nvHalGrInitDx5_NV10(
    PHALHWINFO      pHalHwInfo,
    U032            ChID
)
{
    PGRHALINFO_NV10 pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV10 pGrChan;
    U032      i, *pipectx;
    U008      *ptr;

    pGrChan = &pGrHalPvtInfo->grChannels[ChID];
    
    //
    // Load the channel with the desired initial state.
    //
    for (i = 0, ptr = (U008 *)pGrChan; i < sizeof (GRAPHICSCHANNEL_NV10); i++)
        *ptr++ = 0x0;

    // Load the non-zero initial values for DX5 classes
    // Initialize the register state
    pGrChan->CurrentPatch.TexFormat0           = 0x1000;
    pGrChan->CurrentPatch.TexFormat1           = 0x1000;
    pGrChan->CurrentPatch.TexControl0_0        = 0x4003ff80;
    pGrChan->CurrentPatch.ImageRect0           = 0x80008;
    pGrChan->CurrentPatch.ImageRect1           = 0x80008;
    pGrChan->CurrentPatch.Combine1ColorOCW     = 0x10000000;
    pGrChan->CurrentPatch.ZClipMax             = 0x4b7fffff;
    pGrChan->CurrentPatch.WinClipVert[0]       = 0x7ff0800;
    pGrChan->CurrentPatch.WinClipHorz[0]       = 0x7ff0800;

    // Initialize the internal XF constants
    pipectx = grInitPipeContextAddr(pGrChan, 0x6740);   // CHEOP_CTX, eye pos
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x3f800000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6750);   // CHEOP_CTX_CONST0
    grInitPipeContextData(0x40000000);
    grInitPipeContextData(0x40000000);
    grInitPipeContextData(0x40000000);
    grInitPipeContextData(0x40000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6760);   // CHEOP_CTX_CONST1
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6770);   // CHEOP_CTX_CONST2
    grInitPipeContextData(0xc5000000);
    grInitPipeContextData(0xc5000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6780);   // CHEOP_CTX, fog plane
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x67a0);   // CHEOP_CTX_CONST3
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6ab0);   // FOG k0, k1, k2
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6ac0);   // CHEOP_CTX_ZERO
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6c10);   // ZOSER_C0
    grInitPipeContextData(0xbf800000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x7030);   // LIGHT0 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30

    pipectx = grInitPipeContextAddr(pGrChan, 0x7040);   // LIGHT1 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30

    pipectx = grInitPipeContextAddr(pGrChan, 0x7050);   // LIGHT2 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30

    pipectx = grInitPipeContextAddr(pGrChan, 0x7060);   // LIGHT3 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30

    pipectx = grInitPipeContextAddr(pGrChan, 0x7070);   // LIGHT4 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30

    pipectx = grInitPipeContextAddr(pGrChan, 0x7080);   // LIGHT5 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30

    pipectx = grInitPipeContextAddr(pGrChan, 0x7090);   // LIGHT6 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30

    pipectx = grInitPipeContextAddr(pGrChan, 0x70a0);   // LIGHT7 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30

    pipectx = grInitPipeContextAddr(pGrChan, 0x6a80);   // ZOSER_EYE_DIR
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x3f800000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6aa0);   // ZOSER_FRONT_AMBIENT2
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x0040);   // begin-end
    grInitPipeContextData(0x00000005);                  // triangles

    pipectx = grInitPipeContextAddr(pGrChan, 0x6400);   // model/view matrix
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x4b7fffff);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6410);   // model/view matrix
    grInitPipeContextData(0xc5000000);
    grInitPipeContextData(0xc5000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6420);   // model/view matrix
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6430);   // model/view matrix
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x64c0);   // model/view matrix
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x4b7fffff);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x64d0);   // model/view matrix
    grInitPipeContextData(0xc5000000);
    grInitPipeContextData(0xc5000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x64e0);   // model/view matrix
    grInitPipeContextData(0xc4fff000);
    grInitPipeContextData(0xc4fff000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x64f0);   // model/view matrix
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

}

static VOID
_nvHalGrInitCelsius_NV10(
    PHALHWINFO  pHalHwInfo,
    U032        ChID
)
{
    PGRHALINFO_NV10 pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV10 pGrChan;
    U032      i, *pipectx;
    U008      *ptr;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    pGrChan = &pGrHalPvtInfo->grChannels[ChID];
    pHalHwInfo->pGrHalInfo->has3dObject |= (0x1 << ChID);

    //
    // Load the channel with the desired initial state.
    //
    for (i = 0, ptr = (U008 *)pGrChan; i < sizeof (GRAPHICSCHANNEL_NV10); i++)
        *ptr++ = 0x0;

    // Load the non-zero initial values for Celsius classes
    // Initialize the register state
    pGrChan->CurrentPatch.TexFormat0           = 0x1000;
    pGrChan->CurrentPatch.TexFormat1           = 0x1000;
    pGrChan->CurrentPatch.ImageRect0           = 0x80008;
    pGrChan->CurrentPatch.ImageRect1           = 0x80008;
    pGrChan->CurrentPatch.ZClipMax             = 0x4b7fffff;
    pGrChan->CurrentPatch.SetupRaster          = DRF_DEF(_PGRAPH, _SETUPRASTER, _SWATHWIDTH, _32);

    // Check for an override for the swath width and width multiplier
    if (pGrHalPvtInfo->SwathControl & SWATH_CONTROL_VALID_BIT) {
        U032 data32 = pGrHalPvtInfo->SwathControl;

        // setup the swath width from the registry key
        pGrChan->CurrentPatch.SetupRaster      = DRF_NUM(_PGRAPH, _SETUPRASTER, _SWATHWIDTH, (data32 & 0xF));

        // setup the multiplier from the registry key
        pGrHalPvtInfo->Debug4 &= ~(DRF_MASK(NV_PGRAPH_DEBUG_4_SWATHCONTROL) << DRF_SHIFT(NV_PGRAPH_DEBUG_4_SWATHCONTROL));
        pGrHalPvtInfo->Debug4 |= DRF_NUM(_PGRAPH, _DEBUG_4, _SWATHCONTROL, (data32 >> 4));

        FLD_WR_DRF_NUM(_PGRAPH, _DEBUG_4, _SWATHCONTROL, (data32 >> 4));
    } else {
        // reset the width multiplier back to the default
        pGrHalPvtInfo->Debug4 &= ~(DRF_MASK(NV_PGRAPH_DEBUG_4_SWATHCONTROL) << DRF_SHIFT(NV_PGRAPH_DEBUG_4_SWATHCONTROL));
        pGrHalPvtInfo->Debug4 |= DRF_NUM(_PGRAPH, _DEBUG_4, _SWATHCONTROL, 0x0);

        if (IsNV15orBetter_NV10(pHalHwInfo->pMcHalInfo))
        {
            FLD_WR_DRF_NUM(_PGRAPH, _DEBUG_4, _SWATHCONTROL, 0x0);
        }
    }

    // Initialize internal XF constants, also has side effect of initializing
    // upper half of passthrough slot for bundles.

    pipectx = grInitPipeContextAddr(pGrChan, 0x6740);   // CHEOP_CTX, eye pos
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x3f800000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6750);   // CHEOP_CTX_CONST0
    grInitPipeContextData(0x40000000);
    grInitPipeContextData(0x40000000);
    grInitPipeContextData(0x40000000);
    grInitPipeContextData(0x40000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6760);   // CHEOP_CTX_CONST1
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6770);   // CHEOP_CTX_CONST2
    grInitPipeContextData(0x3f000000);
    grInitPipeContextData(0x3f000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6780);   // CHEOP_CTX (fog plane)
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x67a0);   // CHEOP_CTX_CONST3
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6ac0);   // CHEOP_CTX_ZERO
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6c10);   // ZOSER C0
    grInitPipeContextData(0xbf800000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x7030);   // LIGHT0 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30
          
    pipectx = grInitPipeContextAddr(pGrChan, 0x7040);   // LIGHT1 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30
          
    pipectx = grInitPipeContextAddr(pGrChan, 0x7050);   // LIGHT2 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30
          
    pipectx = grInitPipeContextAddr(pGrChan, 0x7060);   // LIGHT3 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30
          
    pipectx = grInitPipeContextAddr(pGrChan, 0x7070);   // LIGHT4 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30
          
    pipectx = grInitPipeContextAddr(pGrChan, 0x7080);   // LIGHT5 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30
          
    pipectx = grInitPipeContextAddr(pGrChan, 0x7090);   // LIGHT6 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30
          
    pipectx = grInitPipeContextAddr(pGrChan, 0x70a0);   // LIGHT7 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30
          
    pipectx = grInitPipeContextAddr(pGrChan, 0x6a80);   // ZOSER_EYE_DIR
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x3f800000);
         
    pipectx = grInitPipeContextAddr(pGrChan, 0x6aa0);   // ZOSER_FRONT_AMBIENT2 (MCOL)
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\gr\nv4\grcxnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRCXNV04.C                                                        *
*   The graphics engine is managed in this module.  Context switching is    *
*   contained here.                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

RM_STATUS nvHalGrLoadChannelContext_NV04(PHALHWINFO, U032);
RM_STATUS nvHalGrUnloadChannelContext_NV04(PHALHWINFO, U032);

//
// nvHalGrLoadChannelContext
//
RM_STATUS
nvHalGrLoadChannelContext_NV04(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PGRHALINFO_NV04 pGrHalPvtInfo = (PGRHALINFO_NV04)pHalHwInfo->pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV04 pGrChan;
    U032 i;
    U032 misc;
    U032 caches, fifo0, fifo1;

    //
    // Disable FIFO access.
    //
    // KJK Me thinks this shouldn't be necessary
    //
    caches = REG_RD32(NV_PFIFO_CACHES);
    fifo0  = REG_RD32(NV_PFIFO_CACHE0_PULL0);
    fifo1  = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO_, CACHES,       _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO_, CACHE0_PULL0, _ACCESS,   _DISABLED);
    REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _DISABLED);

    //
    // Service any outstanding graphics exceptions.
    //
    if (REG_RD32(NV_PGRAPH_INTR))
        HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);
        
    //
    // Save current graphics interface state.
    //
    GR_SAVE_STATE(misc);
    HAL_GR_IDLE(pHalHwInfo);
    
    //
    // Unload current context.
    //   
    if (pGrHalPvtInfo->currentChID != ChID)
        nvHalGrUnloadChannelContext_NV04(pHalHwInfo, pGrHalPvtInfo->currentChID);

    if ((pGrHalPvtInfo->currentChID = ChID) == INVALID_CHID)
    {
        //
        // Set current channel to an invalid one.
        //
        FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, 0x0F);
        //
        // Update current channel.
        //    
        REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _NOT_EXPIRED)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
        REG_WR_DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS, _VALID);

        //
        // Restore graphics interface state.
        //
        misc |= DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
        GR_RESTORE_STATE(misc); // FIFO reenabled in here
        //
        // Restore FIFO access.
        //
        /*
        REG_WR32(NV_PFIFO_CACHE0_PULL0, fifo0);
        REG_WR32(NV_PFIFO_CACHE1_PULL0, fifo1);
        REG_WR32(NV_PFIFO_CACHES,       caches);
        */
        return (RM_OK);
        //
        // Is the channel ID valid?
        //
    }
    else if (ChID >= NUM_FIFOS_NV04)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid Channel on Graphics Context Switch:", ChID);
        DBG_BREAKPOINT();
        return (RM_ERR_BAD_ARGUMENT);
    }

    //
    // Get pointer to correct channel context area.
    //
    pGrChan = &pGrHalPvtInfo->grChannels[ChID];

    //
    // Reload std user clip (NV4 dictates that this be restored before ctx switch)
    //
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMIN,  pGrChan->CurrentPatch.AbsUClipXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMAX,  pGrChan->CurrentPatch.AbsUClipXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMIN,  pGrChan->CurrentPatch.AbsUClipYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMAX,  pGrChan->CurrentPatch.AbsUClipYMax);

    //
    // Reload context state
    //
    REG_WR32(NV_PGRAPH_CTX_SWITCH1, pGrChan->ContextSwitch1);
    REG_WR32(NV_PGRAPH_CTX_SWITCH2, pGrChan->ContextSwitch2);
    REG_WR32(NV_PGRAPH_CTX_SWITCH3, pGrChan->ContextSwitch3);
    REG_WR32(NV_PGRAPH_CTX_SWITCH4, pGrChan->ContextSwitch4);

    for (i = 0; i < 8; i++)
    {    
        REG_WR32(NV_PGRAPH_CTX_CACHE1(i), pGrChan->ContextCache1[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE2(i), pGrChan->ContextCache2[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE3(i), pGrChan->ContextCache3[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE4(i), pGrChan->ContextCache4[i]);
    }
    
    REG_WR32(NV_PGRAPH_CTX_USER, pGrChan->ContextUser);
    
    //
    // Reload current dma registers
    //
    REG_WR32(NV_PGRAPH_DMA_START_0, pGrChan->DmaStart0);
    REG_WR32(NV_PGRAPH_DMA_START_1, pGrChan->DmaStart1);
    REG_WR32(NV_PGRAPH_DMA_LENGTH,  pGrChan->DmaLength);
    REG_WR32(NV_PGRAPH_DMA_MISC,    pGrChan->DmaMisc);
    REG_WR32(NV_PGRAPH_DMA_PITCH,   pGrChan->DmaPitch);
            
    //
    // Reload current graphics state
    //
    for (i = 0; i < 6; i++)
    {    
        REG_WR32(NV_PGRAPH_BOFFSET(i),  pGrChan->CurrentPatch.BufferOffset[i]);
        REG_WR32(NV_PGRAPH_BBASE(i),    pGrChan->CurrentPatch.BufferBase[i]);
        REG_WR32(NV_PGRAPH_BLIMIT(i),   pGrChan->CurrentPatch.BufferLimit[i]);
    }
    
    for (i = 0; i < 5; i++)
        REG_WR32(NV_PGRAPH_BPITCH(i),   pGrChan->CurrentPatch.BufferPitch[i]);
        
    REG_WR32(NV_PGRAPH_SURFACE,         pGrChan->CurrentPatch.Surface);        
    REG_WR32(NV_PGRAPH_STATE,           pGrChan->CurrentPatch.State);        
    REG_WR32(NV_PGRAPH_BSWIZZLE2,       pGrChan->CurrentPatch.BufferSwizzle[0]);        
    REG_WR32(NV_PGRAPH_BSWIZZLE5,       pGrChan->CurrentPatch.BufferSwizzle[1]);        
    REG_WR32(NV_PGRAPH_BPIXEL,          pGrChan->CurrentPatch.BufferPixel);
    
    REG_WR32(NV_PGRAPH_NOTIFY,          pGrChan->CurrentPatch.Notify);
    
    REG_WR32(NV_PGRAPH_PATT_COLOR0,     pGrChan->CurrentPatch.PatternColor0);    
    REG_WR32(NV_PGRAPH_PATT_COLOR1,     pGrChan->CurrentPatch.PatternColor1);
    
    FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_3, _RAMREADBACK, _ENABLED);
    for (i = 0; i < 64; i++)
        REG_WR32(NV_PGRAPH_PATT_COLORRAM(i), pGrChan->CurrentPatch.PatternColorRam[i]);
    FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_3, _RAMREADBACK, _DISABLED);
        
    REG_WR32(NV_PGRAPH_PATTERN(0),      pGrChan->CurrentPatch.Pattern[0]);
    REG_WR32(NV_PGRAPH_PATTERN(1),      pGrChan->CurrentPatch.Pattern[1]);
    REG_WR32(NV_PGRAPH_PATTERN_SHAPE,   pGrChan->CurrentPatch.PatternShape);
    
    REG_WR32(NV_PGRAPH_MONO_COLOR0,     pGrChan->CurrentPatch.MonoColor0);
    REG_WR32(NV_PGRAPH_ROP3,            pGrChan->CurrentPatch.Rop3);
    REG_WR32(NV_PGRAPH_CHROMA,          pGrChan->CurrentPatch.Chroma);
    REG_WR32(NV_PGRAPH_BETA_AND,        pGrChan->CurrentPatch.BetaAnd);
    REG_WR32(NV_PGRAPH_BETA_PREMULT,    pGrChan->CurrentPatch.BetaPremult);
    
    REG_WR32(NV_PGRAPH_CONTROL0,        pGrChan->CurrentPatch.Control0);
    REG_WR32(NV_PGRAPH_CONTROL1,        pGrChan->CurrentPatch.Control1);
    REG_WR32(NV_PGRAPH_CONTROL2,        pGrChan->CurrentPatch.Control2);
    
    REG_WR32(NV_PGRAPH_BLEND,           pGrChan->CurrentPatch.Blend);
    
    REG_WR32(NV_PGRAPH_STORED_FMT,      pGrChan->CurrentPatch.StoredFmt);
    REG_WR32(NV_PGRAPH_SOURCE_COLOR,    pGrChan->CurrentPatch.SourceColor);
    
    for (i = 0; i < 32; i++)
    {
        REG_WR32(NV_PGRAPH_ABS_X_RAM(i), pGrChan->CurrentPatch.AbsXRam[i]);
        REG_WR32(NV_PGRAPH_ABS_Y_RAM(i), pGrChan->CurrentPatch.AbsYRam[i]);
    }        
    
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_XMIN, pGrChan->CurrentPatch.AbsUClipAXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_XMAX, pGrChan->CurrentPatch.AbsUClipAXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_YMIN, pGrChan->CurrentPatch.AbsUClipAYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_YMAX, pGrChan->CurrentPatch.AbsUClipAYMax);
    
    REG_WR32(NV_PGRAPH_ABS_ICLIP_XMAX,  pGrChan->CurrentPatch.AbsIClipXMax);
    REG_WR32(NV_PGRAPH_ABS_ICLIP_YMAX,  pGrChan->CurrentPatch.AbsIClipYMax);
    
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC0,  pGrChan->CurrentPatch.XYLogicMisc0);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC1,  pGrChan->CurrentPatch.XYLogicMisc1);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC2,  pGrChan->CurrentPatch.XYLogicMisc2);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC3,  pGrChan->CurrentPatch.XYLogicMisc3);

    REG_WR32(NV_PGRAPH_CLIPX_0,         pGrChan->CurrentPatch.ClipX0);
    REG_WR32(NV_PGRAPH_CLIPX_1,         pGrChan->CurrentPatch.ClipX1);
    REG_WR32(NV_PGRAPH_CLIPY_0,         pGrChan->CurrentPatch.ClipY0);
    REG_WR32(NV_PGRAPH_CLIPY_1,         pGrChan->CurrentPatch.ClipY1);
    
    for (i = 0; i < 16; i++)
    {
        REG_WR32(NV_PGRAPH_U_RAM(i),    pGrChan->CurrentPatch.URam[i]);
        REG_WR32(NV_PGRAPH_V_RAM(i),    pGrChan->CurrentPatch.VRam[i]);
        REG_WR32(NV_PGRAPH_M_RAM(i),    pGrChan->CurrentPatch.MRam[i]);
    }
    
    REG_WR32(NV_PGRAPH_COMBINE0ALPHA,   pGrChan->CurrentPatch.Combine0Alpha);
    REG_WR32(NV_PGRAPH_COMBINE0COLOR,   pGrChan->CurrentPatch.Combine0Color);
    REG_WR32(NV_PGRAPH_COMBINE1ALPHA,   pGrChan->CurrentPatch.Combine1Alpha);
    REG_WR32(NV_PGRAPH_COMBINE1COLOR,   pGrChan->CurrentPatch.Combine1Color);
    
    REG_WR32(NV_PGRAPH_FORMAT0,         pGrChan->CurrentPatch.Format0);
    REG_WR32(NV_PGRAPH_FORMAT1,         pGrChan->CurrentPatch.Format1);
    REG_WR32(NV_PGRAPH_FILTER0,         pGrChan->CurrentPatch.Filter0);
    REG_WR32(NV_PGRAPH_FILTER1,         pGrChan->CurrentPatch.Filter1);
    
    REG_WR32(NV_PGRAPH_D3D_XY,          pGrChan->CurrentPatch.D3D_XY);
    REG_WR32(NV_PGRAPH_D3D_U0,          pGrChan->CurrentPatch.D3D_U0);
    REG_WR32(NV_PGRAPH_D3D_V0,          pGrChan->CurrentPatch.D3D_V0);
    REG_WR32(NV_PGRAPH_D3D_U1,          pGrChan->CurrentPatch.D3D_U1);
    REG_WR32(NV_PGRAPH_D3D_V1,          pGrChan->CurrentPatch.D3D_V1);
    REG_WR32(NV_PGRAPH_D3D_ZETA,        pGrChan->CurrentPatch.D3D_ZETA);
    REG_WR32(NV_PGRAPH_D3D_RGB,         pGrChan->CurrentPatch.D3D_RGB);
    REG_WR32(NV_PGRAPH_D3D_S,           pGrChan->CurrentPatch.D3D_S);
    REG_WR32(NV_PGRAPH_D3D_M,           pGrChan->CurrentPatch.D3D_M);

    REG_WR32(NV_PGRAPH_PASSTHRU_0,      pGrChan->CurrentPatch.Passthru0);    
    REG_WR32(NV_PGRAPH_PASSTHRU_1,      pGrChan->CurrentPatch.Passthru1);    
    REG_WR32(NV_PGRAPH_PASSTHRU_2,      pGrChan->CurrentPatch.Passthru2);
    REG_WR32(NV_PGRAPH_DVD_COLORFMT,    pGrChan->CurrentPatch.DVDColorFormat);
    REG_WR32(NV_PGRAPH_SCALED_FORMAT,   pGrChan->CurrentPatch.ScaledFormat);
    REG_WR32(NV_PGRAPH_MISC24_0,        pGrChan->CurrentPatch.Misc24_0);
    REG_WR32(NV_PGRAPH_MISC24_1,        pGrChan->CurrentPatch.Misc24_1);
    REG_WR32(NV_PGRAPH_MISC24_2,        pGrChan->CurrentPatch.Misc24_2);
    REG_WR32(NV_PGRAPH_X_MISC,          pGrChan->CurrentPatch.XMisc);
    REG_WR32(NV_PGRAPH_Y_MISC,          pGrChan->CurrentPatch.YMisc);
    REG_WR32(NV_PGRAPH_VALID1,          pGrChan->CurrentPatch.Valid1);
    REG_WR32(NV_PGRAPH_VALID2,          pGrChan->CurrentPatch.Valid2);

    // restore the PGRAPH_DEBUG_3_POSTDITHER_2D setting
    REG_WR32(NV_PGRAPH_DEBUG_3,  pGrChan->Debug3);

    //
    // Update current channel.
    //    
    REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _NOT_EXPIRED)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _VALID)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
                                  
    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, ChID);
    
    //
    // Clear the graphics fifo channel context.  This fixes a subtle hardware bug
    // when thrashing channel changes within the graphics fifo.  Ideally the fifo
    // would hold off pending data while a change is active, but it can actually
    // hold multiple changes.  In order to reduce hw confusion, they added a few
    // state bits within one stage fifo (bits 20 and 21).  
    // Clear those bits on channel changes. Don't rely on these to read as zero
    // eventhough these bits are write only.
    //
    // We have to OR in the top bit to fool the Watcom compiler for the Win3.1 version
    // of the resmgr.
    //
    REG_WR32(NV_PGRAPH_FFINTFC_ST2, REG_RD32(NV_PGRAPH_FFINTFC_ST2) & 0xffCfffff);

    // Restore graphics interface state.
    //
    GR_RESTORE_STATE(misc);
    
    //
    // Restore FIFO access.
    //
    REG_WR32(NV_PFIFO_CACHE0_PULL0, fifo0);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, fifo1);
    REG_WR32(NV_PFIFO_CACHES, caches);

    return (RM_OK);
}


RM_STATUS
nvHalGrUnloadChannelContext_NV04(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PGRHALINFO_NV04 pGrHalPvtInfo = (PGRHALINFO_NV04)pHalHwInfo->pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV04 pGrChan;
    U032 i;

    //
    // No need to unload an invalid channel
    //
    if (ChID  == INVALID_CHID)
        return (RM_OK);

    pGrChan = &pGrHalPvtInfo->grChannels[ChID];

    //
    // Unload current context registers.
    //
    pGrChan->ContextSwitch1    = REG_RD32(NV_PGRAPH_CTX_SWITCH1);
    pGrChan->ContextSwitch2    = REG_RD32(NV_PGRAPH_CTX_SWITCH2);
    pGrChan->ContextSwitch3    = REG_RD32(NV_PGRAPH_CTX_SWITCH3);        
    pGrChan->ContextSwitch4    = REG_RD32(NV_PGRAPH_CTX_SWITCH4);

    for (i = 0; i < 8; i++)
    {    
        pGrChan->ContextCache1[i] = REG_RD32(NV_PGRAPH_CTX_CACHE1(i));
        pGrChan->ContextCache2[i] = REG_RD32(NV_PGRAPH_CTX_CACHE2(i));
        pGrChan->ContextCache3[i] = REG_RD32(NV_PGRAPH_CTX_CACHE3(i));
        pGrChan->ContextCache4[i] = REG_RD32(NV_PGRAPH_CTX_CACHE4(i));
    }
    
    pGrChan->ContextUser       = REG_RD32(NV_PGRAPH_CTX_USER);
    
    //
    // Unload current dma registers
    //
    pGrChan->DmaStart0         = REG_RD32(NV_PGRAPH_DMA_START_0);
    pGrChan->DmaStart1         = REG_RD32(NV_PGRAPH_DMA_START_1);
    pGrChan->DmaLength         = REG_RD32(NV_PGRAPH_DMA_LENGTH);
    pGrChan->DmaMisc           = REG_RD32(NV_PGRAPH_DMA_MISC);
    pGrChan->DmaPitch          = REG_RD32(NV_PGRAPH_DMA_PITCH);
            
    //
    // Unload current graphics state
    //
    for (i = 0; i < 6; i++)
    {    
        pGrChan->CurrentPatch.BufferOffset[i] = REG_RD32(NV_PGRAPH_BOFFSET(i));
        pGrChan->CurrentPatch.BufferBase[i]   = REG_RD32(NV_PGRAPH_BBASE(i));
        pGrChan->CurrentPatch.BufferLimit[i]  = REG_RD32(NV_PGRAPH_BLIMIT(i));
    }
    
    for (i = 0; i < 5; i++)
        pGrChan->CurrentPatch.BufferPitch[i]  = REG_RD32(NV_PGRAPH_BPITCH(i));
        
    pGrChan->CurrentPatch.Surface             = REG_RD32(NV_PGRAPH_SURFACE);
    pGrChan->CurrentPatch.State               = REG_RD32(NV_PGRAPH_STATE);
    pGrChan->CurrentPatch.BufferSwizzle[0]    = REG_RD32(NV_PGRAPH_BSWIZZLE2);
    pGrChan->CurrentPatch.BufferSwizzle[1]    = REG_RD32(NV_PGRAPH_BSWIZZLE5);
    pGrChan->CurrentPatch.BufferPixel         = REG_RD32(NV_PGRAPH_BPIXEL);
    pGrChan->CurrentPatch.Notify              = REG_RD32(NV_PGRAPH_NOTIFY);
        pGrChan->CurrentPatch.PatternColor0       = REG_RD32(NV_PGRAPH_PATT_COLOR0);    
    pGrChan->CurrentPatch.PatternColor1       = REG_RD32(NV_PGRAPH_PATT_COLOR1);
    
    FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_3, _RAMREADBACK, _ENABLED);
    for (i = 0; i < 64; i++)
        pGrChan->CurrentPatch.PatternColorRam[i] = REG_RD32(NV_PGRAPH_PATT_COLORRAM(i));
    FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_3, _RAMREADBACK, _DISABLED);
    
    pGrChan->CurrentPatch.Pattern[0]          = REG_RD32(NV_PGRAPH_PATTERN(0));
    pGrChan->CurrentPatch.Pattern[1]          = REG_RD32(NV_PGRAPH_PATTERN(1));
    pGrChan->CurrentPatch.PatternShape        = REG_RD32(NV_PGRAPH_PATTERN_SHAPE);
    
    pGrChan->CurrentPatch.MonoColor0          = REG_RD32(NV_PGRAPH_MONO_COLOR0);
    pGrChan->CurrentPatch.Rop3                = REG_RD32(NV_PGRAPH_ROP3);
    pGrChan->CurrentPatch.Chroma              = REG_RD32(NV_PGRAPH_CHROMA);
    pGrChan->CurrentPatch.BetaAnd             = REG_RD32(NV_PGRAPH_BETA_AND);
    pGrChan->CurrentPatch.BetaPremult         = REG_RD32(NV_PGRAPH_BETA_PREMULT);
    
    pGrChan->CurrentPatch.Control0            = REG_RD32(NV_PGRAPH_CONTROL0);
    pGrChan->CurrentPatch.Control1            = REG_RD32(NV_PGRAPH_CONTROL1);
    pGrChan->CurrentPatch.Control2            = REG_RD32(NV_PGRAPH_CONTROL2);
    
    pGrChan->CurrentPatch.Blend               = REG_RD32(NV_PGRAPH_BLEND);
    
    pGrChan->CurrentPatch.StoredFmt           = REG_RD32(NV_PGRAPH_STORED_FMT);
    pGrChan->CurrentPatch.SourceColor         = REG_RD32(NV_PGRAPH_SOURCE_COLOR);
    
    for (i = 0; i < 32; i++)
    {
        pGrChan->CurrentPatch.AbsXRam[i]      = REG_RD32(NV_PGRAPH_ABS_X_RAM(i));
        pGrChan->CurrentPatch.AbsYRam[i]      = REG_RD32(NV_PGRAPH_ABS_Y_RAM(i));
    }        
    
    pGrChan->CurrentPatch.AbsUClipXMin        = REG_RD32(NV_PGRAPH_ABS_UCLIP_XMIN);
    pGrChan->CurrentPatch.AbsUClipXMax        = REG_RD32(NV_PGRAPH_ABS_UCLIP_XMAX);
    pGrChan->CurrentPatch.AbsUClipYMin        = REG_RD32(NV_PGRAPH_ABS_UCLIP_YMIN);
    pGrChan->CurrentPatch.AbsUClipYMax        = REG_RD32(NV_PGRAPH_ABS_UCLIP_YMAX);
    
    pGrChan->CurrentPatch.AbsUClipAXMin       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_XMIN);
    pGrChan->CurrentPatch.AbsUClipAXMax       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_XMAX);
    pGrChan->CurrentPatch.AbsUClipAYMin       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_YMIN);
    pGrChan->CurrentPatch.AbsUClipAYMax       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_YMAX);
    
    pGrChan->CurrentPatch.AbsIClipXMax        = REG_RD32(NV_PGRAPH_ABS_ICLIP_XMAX);
    pGrChan->CurrentPatch.AbsIClipYMax        = REG_RD32(NV_PGRAPH_ABS_ICLIP_YMAX);
    
    pGrChan->CurrentPatch.XYLogicMisc0        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC0);
    pGrChan->CurrentPatch.XYLogicMisc1        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC1);
    pGrChan->CurrentPatch.XYLogicMisc2        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC2);
    pGrChan->CurrentPatch.XYLogicMisc3        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC3);

    pGrChan->CurrentPatch.ClipX0              = REG_RD32(NV_PGRAPH_CLIPX_0);
    pGrChan->CurrentPatch.ClipX1              = REG_RD32(NV_PGRAPH_CLIPX_1);
    pGrChan->CurrentPatch.ClipY0              = REG_RD32(NV_PGRAPH_CLIPY_0);
    pGrChan->CurrentPatch.ClipY1              = REG_RD32(NV_PGRAPH_CLIPY_1);
    
    for (i = 0; i < 16; i++)
    {
        pGrChan->CurrentPatch.URam[i]         = REG_RD32(NV_PGRAPH_U_RAM(i));
        pGrChan->CurrentPatch.VRam[i]         = REG_RD32(NV_PGRAPH_V_RAM(i));
        pGrChan->CurrentPatch.MRam[i]         = REG_RD32(NV_PGRAPH_M_RAM(i));
    }
    
    pGrChan->CurrentPatch.Combine0Alpha       = REG_RD32(NV_PGRAPH_COMBINE0ALPHA);
    pGrChan->CurrentPatch.Combine0Color       = REG_RD32(NV_PGRAPH_COMBINE0COLOR);
    pGrChan->CurrentPatch.Combine1Alpha       = REG_RD32(NV_PGRAPH_COMBINE1ALPHA);
    pGrChan->CurrentPatch.Combine1Color       = REG_RD32(NV_PGRAPH_COMBINE1COLOR);
    
    pGrChan->CurrentPatch.Format0             = REG_RD32(NV_PGRAPH_FORMAT0);
    pGrChan->CurrentPatch.Format1             = REG_RD32(NV_PGRAPH_FORMAT1);
    pGrChan->CurrentPatch.Filter0             = REG_RD32(NV_PGRAPH_FILTER0);
    pGrChan->CurrentPatch.Filter1             = REG_RD32(NV_PGRAPH_FILTER1);
    
    pGrChan->CurrentPatch.D3D_XY              = REG_RD32(NV_PGRAPH_D3D_XY);
    pGrChan->CurrentPatch.D3D_U0              = REG_RD32(NV_PGRAPH_D3D_U0);
    pGrChan->CurrentPatch.D3D_V0              = REG_RD32(NV_PGRAPH_D3D_V0);
    pGrChan->CurrentPatch.D3D_U1              = REG_RD32(NV_PGRAPH_D3D_U1);
    pGrChan->CurrentPatch.D3D_V1              = REG_RD32(NV_PGRAPH_D3D_V1);
    pGrChan->CurrentPatch.D3D_ZETA            = REG_RD32(NV_PGRAPH_D3D_ZETA);
    pGrChan->CurrentPatch.D3D_RGB             = REG_RD32(NV_PGRAPH_D3D_RGB);
    pGrChan->CurrentPatch.D3D_S               = REG_RD32(NV_PGRAPH_D3D_S);
    pGrChan->CurrentPatch.D3D_M               = REG_RD32(NV_PGRAPH_D3D_M);

    pGrChan->CurrentPatch.Passthru0           = REG_RD32(NV_PGRAPH_PASSTHRU_0);    
    pGrChan->CurrentPatch.Passthru1           = REG_RD32(NV_PGRAPH_PASSTHRU_1);    
    pGrChan->CurrentPatch.Passthru2           = REG_RD32(NV_PGRAPH_PASSTHRU_2);    
    
    pGrChan->CurrentPatch.DVDColorFormat      = REG_RD32(NV_PGRAPH_DVD_COLORFMT);    
    pGrChan->CurrentPatch.ScaledFormat        = REG_RD32(NV_PGRAPH_SCALED_FORMAT);    
    
    pGrChan->CurrentPatch.Misc24_0            = REG_RD32(NV_PGRAPH_MISC24_0);
    pGrChan->CurrentPatch.Misc24_1            = REG_RD32(NV_PGRAPH_MISC24_1);
    pGrChan->CurrentPatch.Misc24_2            = REG_RD32(NV_PGRAPH_MISC24_2);
    pGrChan->CurrentPatch.XMisc               = REG_RD32(NV_PGRAPH_X_MISC);
    pGrChan->CurrentPatch.YMisc               = REG_RD32(NV_PGRAPH_Y_MISC);
    pGrChan->CurrentPatch.Valid1              = REG_RD32(NV_PGRAPH_VALID1);
    pGrChan->CurrentPatch.Valid2              = REG_RD32(NV_PGRAPH_VALID2);
    
    // save the PGRAPH_DEBUG_3_POSTDITHER_2D setting
    pGrChan->Debug3              = REG_RD32(NV_PGRAPH_DEBUG_3);

    //
    // Invalidate hw's channel ID.
    //
    REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, 0x0F);

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nvx\drivers\resman\kernel\gr\nv20\grnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics 