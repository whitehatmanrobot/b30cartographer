, 0, 0, 0, 0 }
		   	 }
			},

            {
			 {
		      // Filter lengths
        // Generated by HRTFConv V5.90d on Fri Mar 12 11:23:29 1999
          { 0, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 },
          { 0, 10, 10, 10, 5, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 10, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 10, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 10, 10, 10, 10, 5, 10, 10, 10, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 10, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 10, 15, 15, 15, 15, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 15, 15, 20, 20, 20, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 20, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
  
			 }
			},
			// 44100 Hz sample rate
			{        
			 {
		           // Filter lengths
        // Generated by HRTFConv V5.90d on Fri Mar 12 11:26:10 1999
          { 0, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 },
          { 0, 10, 10, 10, 5, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 10, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 10, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 10, 10, 10, 10, 5, 10, 10, 10, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 10, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 10, 15, 15, 15, 15, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 15, 15, 20, 20, 20, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 20, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
		     }
			},
			// 48000 Hz sample rate
			{        
			 {
		// Filter lengths
        // Generated by HRTFConv V5.90d on Fri Mar 12 11:28:42 1999
          { 0, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 },
          { 0, 10, 10, 10, 5, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 10, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 10, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 10, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 10, 10, 10, 10, 5, 10, 10, 10, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 15, 15, 15, 15, 10, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 10, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 10, 15, 15, 15, 15, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 15, 15, 20, 20, 20, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 15, 15, 15, 20, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
 		   	 }
			}
		},
		// Headphones
		{
		    // 8000 Hz sample rate
			{
   			 {
   			          // Filter lengths
        // Generated by HRTFConv V5.90d on Wed Feb 10 10:36:27 1999
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 5, 10, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 10, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 5, 5, 5, 5, 5, 5, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 },
          { 5, 10, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 10, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 5, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 10, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 10, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 10, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
   			 }
			},	
			// 11025 Hz sample rate
			{
   			 {
   			 // Filter lengths
        // Generated by HRTFConv V5.90d on Fri Mar 12 11:38:51 1999
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }

   			 }
			},
		    // 16000 Hz sample rate
			{
   			 {
   		    // Filter lengths
        // Generated by HRTFConv V5.90d on Fri Mar 12 11:40:57 1999
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 5, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 5, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 },
          { 5, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 5, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 10, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }

   			 }
			},	
			// 22050 Hz sample rate
			{
   			 {
   			         // Filter lengths
        // Generated by HRTFConv V5.90d on Fri Mar 12 11:42:29 1999
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
   			 }
			},
            // 32000 Hz sample rate
			{
   			 {
   			      // Filter lengths
        // Generated by HRTFConv V5.90d on Fri Mar 12 11:44:06 1999
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }

   			 }
			},	
			// 44100 Hz sample rate
			{
   			 {
   		           // Filter lengths
        // Generated by HRTFConv V5.90d on Fri Mar 12 11:46:25 1999
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }

   			 }
			},
			// 48000 Hz sample rate
			{
   			 {
			 // Filter lengths
        // Generated by HRTFConv V5.90d on Fri Mar 12 11:48:33 1999
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 20 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 20, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }

   			 }
			}
		}
	},
	// Lite coefficients
	{
        // 10 degrees loudspeakers

		{

           // 8000 Hz sample rate
			{
   			{
   		     { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
			   			}
			},
			
			// 11025 Hz sample rate
			{
   			{
   		     { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
			   			}
			},

             // 16000 Hz sample rate
			{
   			{
   		     { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
			   			}
			},
			
			// 22050 Hz sample rate
			{
   			{
   		     { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
			   			}
			},


	    	// 32000 Hz sample rate
			{
   			{
   		     { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
			   			}
			},
	
			// 44100 Hz sample rate
			{
   			{
   		     { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
			   			}
			},
			// 48000 Hz sample rate
			{
   			{
		    { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
			
   			}
			}
		},


		// 20 degrees loudspeakers
		{
			// 8000 Hz sample rate
			{
        // Generated by HRTFConv V5.90d on Mon Feb 08 11:07:39 1999
				{
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
				}
			},

			// 11025 Hz sample rate
			{
  
				{
           // Generated by HRTFConv V5.90d on Wed Mar 03 18:25:02 1999
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
		}
			},

    	// 16000 Hz sample rate
			{
        // Generated by HRTFConv V5.90d on Mon Feb 08 11:07:39 1999
				{
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
				}
			},

			// 22050 Hz sample rate
			{
            // Generated by HRTFConv V5.90d on Wed Mar 03 18:32:45 1999
 				{
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
		}
			},

		 	// 32000 Hz sample rate
		{
        // Generated by HRTFConv V5.90d on Mon Feb 08 11:07:39 1999
			{
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
		}
			},
			// 44100 Hz sample rate
			{
        
				{
          // Generated by HRTFConv V5.90d on Wed Mar 03 18:42:26 1999
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
		}
			},
			// 48000 Hz sample rate
			{
       
				{
        // Generated by HRTFConv V5.90d on Wed Mar 03 18:45:39 1999
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
		}
			}
		},
		// Headphones
		{
		 // 8000 Hz sample rate
			{
        // Generated by HRTFConv V5.90d on Mon Feb 08 11:07:39 1999
				{
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
				}
			},


			// 11025 Hz sample rate
			{
        // Generated by HRTFConv V5.90d on Mon Feb 08 11:07:39 1999
				{
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
				}
			},

	       //16000 Hz sample rate
		 	{
        // Generated by HRTFConv V5.90d on Mon Feb 08 11:11:49 1999
				{
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
				}
			},      
		 // 22050 Hz sample rate
			{
        // Generated by HRTFConv V5.90d on Mon Feb 08 11:11:49 1999
				{
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
				}
			},

	   // 32000 Hz sample rate
			{
        // Generated by HRTFConv V5.90d on Mon Feb 08 11:13:18 1999
				{
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
				}
			},
				// 44100 Hz sample rate
			{
        // Generated by HRTFConv V5.90d on Mon Feb 08 11:13:18 1999
				{
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
				}
			},
			// 48000 Hz sample rate
			{
        // Generated by HRTFConv V5.90d on Mon Feb 08 11:13:30 1999
				{
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
          { 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
				}
			}
		}
	}
};

// Filter coefficient change overlap buffer length
const size_t CaastFilterOverlapLength[KSDS3D_FILTER_QUALITY_COUNT][esamplerateCount] = {
	// Full coefficients
	{
        // 8000  Hz
     	20,

		// 11025 kHz
		25,
        
        // 16000 Hz
		37,

		// 22050 kHz
		50,

		// 32000 KHz
		75,

		// 44100 kHz
		100,

		// 48000 kHz
		109
	},
	// Lite coefficients
	{

        // 8000 Hz
		12,

		// 11025 kHz
		13,

        // 16000 Hz
		19,
        
		// 22050 kHz
		25,

        // 32000  Hz
		37,

		// 44100 kHz
		50,

		// 48000 kHz
		55
	}
};

// Filter coefficient change mute buffer length
const size_t CaastFilterMuteLength[KSDS3D_FILTER_QUALITY_COUNT][esamplerateCount] = {
	// Full coefficients
	{

        // 8000 Hz
	    12,
     
		// 11025 kHz
		13,

        // 16000 Hz
		19,

		// 22050 kHz
		25,

        // 32000 Hz
		37,

		// 44100 kHz
		50,

		// 48000 kHz
		55
	},
	// Lite coefficients
	{
		// 8000 Hz
		6,

		// 11025 kHz
		7,

        // 16000 Hz
		10,

		// 22050 kHz
		13,

        // 32000 Hz
        19,

		// 44100 kHz
		25,

		// 48000 kHz
		27
	}
};

// Zero azimuth transition (left/right hemisphere transition) cross-fade buffer length
const size_t CastOutputOverlapLength[esamplerateCount] = {
	// 8000 Hz
    20,

	// 11025 kHz
	25,

    // 16000 Hz
    37,
   
	// 22050 kHz
	50,

    // 32000 Hz
	75,

	// 44100 kHz
	100,

	// 48000 kHz
	110
};

// Number of azimuth bins
const UINT CauiNumAzimuthBins[CuiNumElevationBins] = {
  // Generated by HRTFConv V5.90a on Tue Jan 05 14:24:04 1999
  28,
  30,
  36,
  36,
  36,
  36,
  36,
  30,
  28,
  23,
  18,
  12,
  6
};
// Number of elevation bins: 13
// Maximum number of azimuth bins: 36
// Minimum elevation: -40
// Maximum elevation: 80
// Minimum azimuth: 0
// Maximum azimuth: 180

// ---------------------------------------------------------------------------
// Global helper functions

// Convert number of biquad coefficients to corresponding number of canonical coefficients
UINT NumBiquadCoeffsToNumCanonicalCoeffs(const UINT CuiNumBiquadCoeffs)
{
	if (CuiNumBiquadCoeffs == 0)
		return 0;
	else
		return NumBiquadsToNumCanonicalCoeffs(NumBiquadCoeffsToNumBiquads(CuiNumBiquadCoeffs));
}

// ---------------------------------------------------------------------------
// Include inline definitions out-of-line in debug version

#if defined(DEBUG)
#include "vmaxcoef.inl"
#endif

// End of VMAXCOEF.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\win9x\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsmgr\dsmgr.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsmgr.cpp
 *  Content:    Main application source file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/15/97    dereks  Created.
 *
 ***************************************************************************/

// We'll ask for what we need, thank you.
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN

// I need GUIDs, dammit
#ifndef INITGUID
#define INITGUID
#endif // INITGUID

// Public includes
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include <dsprv.h>
#include <commctrl.h>
#include <commdlg.h>
#include <cguid.h>

// Private includes
#include "resource.h"
#include "dsprvobj.h"

// Debug helpers
#if defined(DEBUG) || defined(_DEBUG)
#define DPF dprintf
#else // defined(DEBUG) || defined(_DEBUG)
#pragma warning(disable:4002)
#define DPF()
#endif // defined(DEBUG) || defined(_DEBUG)

// Generic helper macros
#define MAKEBOOL(a) (!!(a))

// Image list icon array
const UINT g_auDriverIcons[] = { IDI_DSMGR, IDI_PLAYBACK, IDI_RECORD };

// Device properties
typedef struct tagDIRECTSOUNDDEVICE_SHAREDDATA
{
    DIRECTSOUNDMIXER_SRCQUALITY SrcQuality;
    DWORD                       Acceleration;
} DIRECTSOUNDDEVICE_SHAREDDATA, *LPDIRECTSOUNDDEVICE_SHAREDDATA;

typedef struct tagDIRECTSOUNDDEVICEDESCRIPTION
{
    GUID                        DeviceId;
    DIRECTSOUNDDEVICE_TYPE      Type;
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;
    CHAR                        Description[0x100];
    CHAR                        Module[MAX_PATH];
    CHAR                        Interface[MAX_PATH];
    ULONG                       WaveDeviceId;
} DIRECTSOUNDDEVICEDESCRIPTION, *PDIRECTSOUNDDEVICEDESCRIPTION;

typedef struct tagDIRECTSOUNDDEVICE
{
    DIRECTSOUNDDEVICEDESCRIPTION    Description;
    BOOL                            Presence;
    DIRECTSOUNDDEVICE_SHAREDDATA    SharedData;
    LPDIRECTSOUNDDEVICE_SHAREDDATA  pSharedData;
} DIRECTSOUNDDEVICE, *LPDIRECTSOUNDDEVICE;

typedef const DIRECTSOUNDDEVICE *LPCDIRECTSOUNDDEVICE;

// GUID string
#define MAX_GUID_STRING_LEN (8+1+4+1+4+1+2+2+2+2+2+2+2+2+1)

// Main window class declaration
class CDsMgrWindow
{
private:
    HINSTANCE                                       m_hInst;            // Application instance handle
    WNDCLASSEX                                      m_wcex;             // Application window class
    HWND                                            m_hWnd;             // Window handle
    LPKSPROPERTYSET                                 m_pDsPrivate;       // IKsPropertySet interface to the DirectSoundPrivate object
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA        m_DpfInfo;          // DirectSound DPF info

public:
    CDsMgrWindow(void);
    virtual ~CDsMgrWindow(void);

public:
    // Initialization
    virtual BOOL Initialize(HINSTANCE, INT);

    // General message processing
    virtual INT PumpMessages(void);
    static LPARAM CALLBACK WindowProc(HWND, UINT, WPARAM, LPARAM);

    // Specific message processing
    virtual void OnInit(void);
    virtual void OnSize(WORD, WORD, WORD);
    virtual void OnCommand(UINT, UINT);
    virtual void OnNotify(LPNMHDR);
    virtual BOOL OnClose(void);
    virtual void OnDestroy(void);

    // Even more granular message processing
    virtual void OnCommandApply(void);
    virtual void OnCommandResetDevice(void);
    virtual void OnCommandResetAll(void);
    virtual void OnCommandBrowse(void);
    virtual void OnListViewItemChanged(NM_LISTVIEW *);

private:
    // UI helpers
    virtual void RefreshDriverList(void);
    virtual void FreeDriverList(void);
    virtual void UpdateUiFromDevice(LPCDIRECTSOUNDDEVICE);
    virtual void UpdateDeviceFromUi(LPDIRECTSOUNDDEVICE);
    virtual void UpdateUiFromDebug(const DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA *);
    virtual void UpdateDebugFromUi(PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA);
    virtual LPDIRECTSOUNDDEVICE GetSelectedDevice(INT = -1);

    // DirectSound helpers
    virtual BOOL DirectSoundEnumerateCallback(PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA);
    static BOOL CALLBACK DirectSoundEnumerateCallbackStatic(PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA, LPVOID);
    virtual BOOL GetDeviceProperties(LPDIRECTSOUNDDEVICE);
    virtual BOOL SetDeviceProperties(LPCDIRECTSOUNDDEVICE);
    virtual BOOL GetDebugProperties(PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA);
    virtual BOOL SetDebugProperties(const DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA *);

    // Misc
    static void GuidToString(REFGUID, LPSTR);
    static void StringToGuid(LPCSTR, LPGUID);
    static INT atoi(LPCSTR);
};


/***************************************************************************
 *
 *  dprintf
 *
 *  Description:
 *      Writes a string to the debugger.
 *
 *  Arguments:
 *      LPCSTR [in]: string.
 *      ... [in]: optional string modifiers.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
dprintf
(
    LPCSTR                  pszFormat, 
    ...
)
{
    static CHAR             szFinal[0x400];
    va_list                 va;

    // Add the library name
    lstrcpyA(szFinal, "DSMGR: ");

    // Format the string
    va_start(va, pszFormat);
    wvsprintfA(szFinal + lstrlen(szFinal), pszFormat, va);
    va_end(va);

    // Add a carriage-return since OuputDebugString doesn't
    lstrcatA(szFinal, "\r\n");

    // Output to the debugger
    OutputDebugStringA(szFinal);
}


/***************************************************************************
 *
 *  ForceDsLink
 *
 *  Description:
 *      Forces a static link to dsound.dll.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
ForceDsLink
(
    void
)
{
    DirectSoundCreate(NULL, NULL, NULL);
}


/***************************************************************************
 *
 *  WinMain
 *
 *  Description:
 *      Application entry point.
 *
 *  Arguments:
 *      HINSTANCE [in]: application instance handle.
 *      HINSTANCE [in]: previous application instance handle.  Unused in
 *                      Win32.
 *      LPSTR [in]: application command line.
 *      INT [in]: application show command.
 *
 *  Returns:  
 *      INT: 0 on success.
 *
 ***************************************************************************/

INT 
WINAPI 
WinMain
(
    HINSTANCE               hInst, 
    HINSTANCE               hPrevInst, 
    LPSTR                   pszCommandLine, 
    INT                     nShowCmd
)
{
    BOOL                    fSuccess    = TRUE;
    CDsMgrWindow *          pWindow;
    INT                     nReturn;

    // Force a link to comctl32.dll
    InitCommonControls();
    
    // Create the main window
    pWindow = new CDsMgrWindow;

    if(!pWindow)
    {
        DPF("Out of memory allocating main window object");
        fSuccess = FALSE;
    }

    if(fSuccess)
    {
        fSuccess = pWindow->Initialize(hInst, nShowCmd);
    }

    // Pump messages
    if(fSuccess)
    {
        nReturn = pWindow->PumpMessages();
    }
    else
    {
        nReturn = -1;
    }

    // Free memory
    if(pWindow)
    {
        delete pWindow;
    }

    return nReturn;
}


/***************************************************************************
 *
 *  CDsMgrWindow
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

CDsMgrWindow::CDsMgrWindow
(
    void
)
{
    // Initialize defaults
    m_hInst = NULL;
    m_hWnd = NULL;
    m_pDsPrivate = NULL;

    memset(&m_wcex, 0, sizeof(m_wcex));
}


/***************************************************************************
 *
 *  ~CDsMgrWindow
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

CDsMgrWindow::~CDsMgrWindow
(
    void
)
{
    // Make sure the main window is closed
    if(m_hWnd)
    {
        FreeDriverList();
        DestroyWindow(m_hWnd);
    }

    // Unregister the window class
    if(m_wcex.cbSize)
    {
        UnregisterClass(m_wcex.lpszClassName, m_hInst);
    }

    // Release the DirectSoundPrivate object
    if(m_pDsPrivate)
    {
        m_pDsPrivate->Release();
    }
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Object initializer.
 *
 *  Arguments:
 *      HINSTANCE [in]: application instance handle.
 *      INT [in]: window show command.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

BOOL 
CDsMgrWindow::Initialize
(
    HINSTANCE               hInst, 
    INT                     nShowCmd
)
{
    BOOL                    fSuccess    = TRUE;
    HWND                    hWnd;
    
    // Save the instance handle
    m_hInst = hInst;

    // Register the window class
    m_wcex.cbSize = sizeof(m_wcex);
    m_wcex.style = 0;
    m_wcex.lpfnWndProc = WindowProc;
    m_wcex.cbClsExtra = 0;
    m_wcex.cbWndExtra = DLGWINDOWEXTRA;
    m_wcex.hInstance = m_hInst;
    m_wcex.hIcon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(IDI_DSMGR), IMAGE_ICON, 32, 32, 0);
    m_wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
    m_wcex.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    m_wcex.lpszMenuName = NULL;
    m_wcex.lpszClassName = TEXT("dsmgr");
    m_wcex.hIconSm = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(IDI_DSMGR), IMAGE_ICON, 16, 16, 0);

    if(!RegisterClassEx(&m_wcex))
    {
        DPF("Unable to register window class");
        fSuccess = FALSE;
    }

    // Create the main window
    if(fSuccess)
    {
        hWnd = CreateDialogParam(m_hInst, MAKEINTRESOURCE(IDD_DSMGR), NULL, (DLGPROC)WindowProc, (LPARAM)this);
        fSuccess = hWnd ? TRUE : FALSE;
    }

    return fSuccess;
}


/***************************************************************************
 *
 *  PumpMessages
 *
 *  Description:
 *      Main message pump.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      INT: application return code.
 *
 ***************************************************************************/

INT 
CDsMgrWindow::PumpMessages
(
    void
)
{
    MSG                     msg;

    while(GetMessage(&msg, NULL, 0, 0) > 0)
    {
        if(!IsDialogMessage(m_hWnd, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return msg.wParam;
}


/***************************************************************************
 *
 *  WindowProc
 *
 *  Description:
 *      Main message handler.
 *
 *  Arguments:
 *      HWND [in]: window handle.
 *      UINT [in]: message identifier.
 *      WPARAM [in]: message 16-bit parameter.
 *      LPARAM [in]: message 32-bit parameter.
 *
 *  Returns:  
 *      LPARAM [in]: return from DefWindowProc.
 *
 ***************************************************************************/

LPARAM 
CALLBACK 
CDsMgrWindow::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDsMgrWindow *          pThis;
    
    if(WM_INITDIALOG == uMsg)
    {
        // Pack the this pointer into the window's 32-bit user space
        pThis = (CDsMgrWindow *)lParam;
        SetWindowLong(hWnd, DWL_USER, lParam);

        // The window handle isn't saved to a data member yet
        pThis->m_hWnd = hWnd;
    }
    else
    {
        // Get the this pointer from the window's 32-bit user space
        pThis = (CDsMgrWindow *)GetWindowLong(hWnd, DWL_USER);
    }

    // Dispatch the message
    if(pThis)
    {
        switch(uMsg)
        {
            case WM_INITDIALOG:
                pThis->OnInit();
                break;

            case WM_SIZE:
                pThis->OnSize(wParam, LOWORD(lParam), HIWORD(lParam));
                break;
        
            case WM_COMMAND:
                pThis->OnCommand(LOWORD(wParam), HIWORD(wParam));
                break;
     
            case WM_NOTIFY:
                pThis->OnNotify((LPNMHDR)lParam);
                break;

            case WM_CLOSE:
            case WM_QUERYENDSESSION:
                if(!pThis->OnClose())
                {
                    return 0;
                }

                break;
        
            case WM_DESTROY:
                pThis->OnDestroy();
                break;
        }
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}


/***************************************************************************
 *
 *  OnInit
 *
 *  Description:
 *      Initialization handler.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::OnInit
(
    void
)
{
    HWND                    hWndLv      = GetDlgItem(m_hWnd, IDC_DEVICELIST);
    HWND                    hWndSrc     = GetDlgItem(m_hWnd, IDC_MIXER_SRCQUALITY);
    HWND                    hWndDpf     = GetDlgItem(m_hWnd, IDC_DEBUG_DPFLEVEL_SPIN);
    HWND                    hWndBreak   = GetDlgItem(m_hWnd, IDC_DEBUG_BREAKLEVEL_SPIN);
    HIMAGELIST              himl;
    HICON                   hicon;
    HRESULT                 hr;
    LV_COLUMN               lvc;
    UINT                    i;

    // Create the DirectSoundPrivate object
    hr = DirectSoundPrivateCreate(&m_pDsPrivate);

    if(FAILED(hr))
    {
        DPF("Unable to create DirectSoundPrivate object");
        return;
    }

    // Initialize the device list view
    himl = ImageList_Create(16, 16, ILC_COLOR, 3, 1);

    ListView_SetImageList(hWndLv, himl, LVSIL_SMALL);
    
    for(i = 0; i < sizeof(g_auDriverIcons) / sizeof(g_auDriverIcons[0]); i++)
    {
        hicon = (HICON)LoadImage(m_hInst, MAKEINTRESOURCE(g_auDriverIcons[i]), IMAGE_ICON, 16, 16, 0);

        ImageList_AddIcon(himl, hicon);
    }

    ImageList_SetBkColor(himl, COLOR_WINDOW);
    
    lvc.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = 200;
    lvc.pszText = "Description";
    lvc.iSubItem = 0;

    ListView_InsertColumn(hWndLv, lvc.iSubItem, &lvc);

    lvc.cx = 100;
    lvc.pszText = "Module";

    ListView_InsertColumn(hWndLv, ++lvc.iSubItem, &lvc);

    lvc.cx = 50;
    lvc.pszText = "Type";

    ListView_InsertColumn(hWndLv, ++lvc.iSubItem, &lvc);

    lvc.pszText = "Wave Device";

    ListView_InsertColumn(hWndLv, ++lvc.iSubItem, &lvc);

    lvc.cx = 250;
    lvc.pszText = "GUID";

    ListView_InsertColumn(hWndLv, ++lvc.iSubItem, &lvc);

    lvc.cx = 250;
    lvc.pszText = "Interface";

    ListView_InsertColumn(hWndLv, ++lvc.iSubItem, &lvc);

    // Initialize SRC quality combo-box items
    ComboBox_AddString(hWndSrc, "Worst");
    ComboBox_AddString(hWndSrc, "PC");
    ComboBox_AddString(hWndSrc, "Basic");
    ComboBox_AddString(hWndSrc, "Advanced");

    // Initialize spinner ranges
    SendMessage(hWndDpf, UDM_SETRANGE, 0, MAKELONG(9, 0));
    SendMessage(hWndBreak, UDM_SETRANGE, 0, MAKELONG(9, 0));

    // Get debug settings
    GetDebugProperties(&m_DpfInfo);
    UpdateUiFromDebug(&m_DpfInfo);

    // Refresh the device list
    RefreshDriverList();
}


/***************************************************************************
 *
 *  OnSize
 *
 *  Description:
 *      Handles size and state changes.
 *
 *  Arguments:
 *      WORD [in]: resize type.
 *      WORD [in]: new width.
 *      WORD [in]: new height.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::OnSize
(
    WORD                    wType, 
    WORD                    wWidth, 
    WORD                    wHeight
)
{
    const HMENU             hMenu   = GetSystemMenu(m_hWnd, FALSE);
    
    // Work around a bug in the windows dialog handler
    if(SIZE_RESTORED == wType || SIZE_MINIMIZED == wType)
    {
        // Disable the maximize and size items
        EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND | MF_GRAYED);

        // En/disable the minimize and restore items based on the window state
        EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND | (SIZE_RESTORED == wType) ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND | (SIZE_MINIMIZED == wType) ? MF_ENABLED : MF_GRAYED);
    }
}


/***************************************************************************
 *
 *  OnCommand
 *
 *  Description:
 *      Handles command messages.
 *
 *  Arguments:
 *      UINT [in]: resource identifier.
 *      UINT [in]: command.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::OnCommand(UINT uId, UINT uCmd)
{
    LPDIRECTSOUNDDEVICE     pDevice;
    
    switch(uId)
    {
        case IDC_APPLY:
            OnCommandApply();
            break;

        case IDC_RESETDEVICE:
            OnCommandResetDevice();
            break;

        case IDC_RESETALL:
            OnCommandResetAll();
            break;

        case IDC_ACCELERATION_HARDWAREBUFFERS:
        case IDC_ACCELERATION_HARDWARE3D:
        case IDC_ACCELERATION_RING0MIX:
        case IDC_ACCELERATION_HARDWAREPROPERTYSETS:
        case IDC_MIXER_SRCQUALITY:
        case IDC_DEVICEPRESENCE:
            if(pDevice = GetSelectedDevice())
            {
                UpdateDeviceFromUi(pDevice);
            }

            break;

        case IDC_DEBUG_LOGFILE_BROWSE:
            OnCommandBrowse();
            break;
    }
}


/***************************************************************************
 *
 *  OnCommandResetDevice
 *
 *  Description:
 *      Resets the currently selected device.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::OnCommandResetDevice
(
    void
)
{
    LPDIRECTSOUNDDEVICE     pDevice;
    
    // Reload and update the device's settings
    if(pDevice = GetSelectedDevice())
    {
        GetDeviceProperties(pDevice);
        UpdateUiFromDevice(pDevice);
    }
}


/***************************************************************************
 *
 *  OnCommandResetAll
 *
 *  Description:
 *      Resets all settings.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::OnCommandResetAll
(
    void
)
{
    HWND                    hWndLv  = GetDlgItem(m_hWnd, IDC_DEVICELIST);
    LPDIRECTSOUNDDEVICE     pDevice;
    LV_ITEM                 lvi;
    BOOL                    f;
    
    // Reload and update all device properties
    for(ZeroMemory(&lvi, sizeof(lvi)), lvi.mask = LVIF_PARAM; lvi.iItem < ListView_GetItemCount(hWndLv); lvi.iItem++)
    {
        pDevice = NULL;
        
        f = ListView_GetItem(hWndLv, &lvi);

        if(f)
        {
            pDevice = (LPDIRECTSOUNDDEVICE)lvi.lParam;
        }

        if(pDevice)
        {
            GetDeviceProperties(pDevice);
        }
    }
    
    if(pDevice = GetSelectedDevice())
    {
        UpdateUiFromDevice(pDevice);
    }

    // Reload and update debug properties
    GetDebugProperties(&m_DpfInfo);
    UpdateUiFromDebug(&m_DpfInfo);
}


/***************************************************************************
 *
 *  OnCommandApply
 *
 *  Description:
 *      Handles command messages.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::OnCommandApply
(
    void
)
{
    HWND                    hWndLv  = GetDlgItem(m_hWnd, IDC_DEVICELIST);
    LPDIRECTSOUNDDEVICE     pDevice;
    LV_ITEM                 lvi;
    BOOL                    f;
    
    // Apply all device properties
    for(ZeroMemory(&lvi, sizeof(lvi)), lvi.mask = LVIF_PARAM; lvi.iItem < ListView_GetItemCount(hWndLv); lvi.iItem++)
    {
        pDevice = NULL;
        
        f = ListView_GetItem(hWndLv, &lvi);

        if(f)
        {
            pDevice = (LPDIRECTSOUNDDEVICE)lvi.lParam;
        }

        if(pDevice)
        {
            SetDeviceProperties(pDevice);
        }
    }
    
    // Set debug properties
    UpdateDebugFromUi(&m_DpfInfo);
    SetDebugProperties(&m_DpfInfo);
}


/***************************************************************************
 *
 *  OnCommandBrowse
 *
 *  Description:
 *      Handles command messages.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::OnCommandBrowse
(   
    void
)
{
    TCHAR                   szFile[MAX_PATH];
    OPENFILENAME            ofn;
    BOOL                    f;
    
    GetDlgItemText(m_hWnd, IDC_DEBUG_LOGFILE, szFile, sizeof(szFile));

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hWnd;
    ofn.lpstrFilter = TEXT("Text Files (*.txt)\0*.txt\0All Files (*.*)\0*.*\0");
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile);
    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;

    f = GetOpenFileName(&ofn);

    if(f)
    {
        SetDlgItemText(m_hWnd, IDC_DEBUG_LOGFILE, szFile);
    }
}


/***************************************************************************
 *
 *  OnNotify
 *
 *  Description:
 *      Handles notifications.
 *
 *  Arguments:
 *      LPNMHDR [in]: notification header.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::OnNotify
(
    LPNMHDR                 pnmh
)
{
    switch(pnmh->code)
    {
        case LVN_ITEMCHANGED:
            OnListViewItemChanged((NM_LISTVIEW *)pnmh);
            break;
    }
}


/***************************************************************************
 *
 *  OnListViewItemChanged
 *
 *  Description:
 *      Handles notifications.
 *
 *  Arguments:
 *      NM_LISTVIEW * [in]: notification header.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::OnListViewItemChanged
(
    NM_LISTVIEW *           pListView
)
{
    LPDIRECTSOUNDDEVICE     pDevice     = NULL;
    
    if(MAKEBOOL(pListView->uNewState & LVIS_SELECTED) != MAKEBOOL(pListView->uOldState & LVIS_SELECTED))
    {
        if(pListView->uNewState & LVIS_SELECTED)
        {
            pDevice = GetSelectedDevice(pListView->iItem);
        }

        UpdateUiFromDevice(pDevice);
    }
}


/***************************************************************************
 *
 *  OnClose
 *
 *  Description:
 *      Handles close requests.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE to allow the close.
 *
 ***************************************************************************/

BOOL 
CDsMgrWindow::OnClose
(
    void
)
{
    return TRUE;
}


/***************************************************************************
 *
 *  OnDestroy
 *
 *  Description:
 *      Handles window destroy notifications.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::OnDestroy
(
    void
)
{
    // Post the thread quit message
    PostQuitMessage(0);
}


/***************************************************************************
 *
 *  RefreshDriverList
 *
 *  Description:
 *      Refreshes the driver list window.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::RefreshDriverList
(
    void
)
{
    HWND                    hWndLv      = GetDlgItem(m_hWnd, IDC_DEVICELIST);
    INT                     nIndex;
    
    // Free any current items
    FreeDriverList();

    // Enumerate all DirectSound devices
    PrvEnumerateDevices(m_pDsPrivate, DirectSoundEnumerateCallbackStatic, this);

    // Resize the list view columns
    for(nIndex = 0; nIndex < 7; nIndex++)
    {
        ListView_SetColumnWidth(hWndLv, nIndex, LVSCW_AUTOSIZE);
    }

    // No device is selected
    UpdateUiFromDevice(NULL);
}


/***************************************************************************
 *
 *  FreeDriverList
 *
 *  Description:
 *      Frees the driver list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::FreeDriverList
(
    void
)
{
    HWND                    hWndLv      = GetDlgItem(m_hWnd, IDC_DEVICELIST);
    INT                     nIndex;
    LV_ITEM                 lvi;
    LPDIRECTSOUNDDEVICE     pDevice;
    
    // Enumerate all items, freeing the lParam member
    lvi.mask = LVIF_PARAM;
    
    for(nIndex = 0; nIndex < ListView_GetItemCount(hWndLv); nIndex++)
    {
        ListView_GetItem(hWndLv, &lvi);

        if(pDevice = (LPDIRECTSOUNDDEVICE)lvi.lParam)
        {
            delete pDevice;
        }
    }

    // Free any current items
    ListView_DeleteAllItems(hWndLv);
}


/***************************************************************************
 *
 *  DirectSoundEnumerateCallback
 *
 *  Description:
 *      DirectSoundEnumerate callback function.
 *
 *  Arguments:
 *      PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA [in]: description.
 *
 *  Returns:  
 *      BOOL: TRUE to continue enumerating.
 *
 ***************************************************************************/

BOOL 
CDsMgrWindow::DirectSoundEnumerateCallback
(
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA  pDesc
)
{
    HWND                                            hWndLv      = GetDlgItem(m_hWnd, IDC_DEVICELIST);
    LPDIRECTSOUNDDEVICE                             pDevice;
    LPDIRECTSOUNDDEVICE                             pDevice2;
    TCHAR                                           sz[64];
    LV_ITEM                                         lvi;
    BOOL                                            f;
    
    // Create the new data structure
    pDevice = new DIRECTSOUNDDEVICE;

    if(pDevice)
    {
        pDevice->pSharedData = &pDevice->SharedData;
    }
        
    // Get device data
    if(pDevice)
    {
        pDevice->Description.DeviceId = pDesc->DeviceId;
        
        f = GetDeviceProperties(pDevice);

        if(!f)
        {
            delete pDevice;
            pDevice = NULL;
        }
    }

    // Initialize shared device settings
    if(pDevice)
    {
        lvi.mask = LVIF_PARAM;
        lvi.iItem = 0;

        while(TRUE)
        {
            f = ListView_GetItem(hWndLv, &lvi);

            if(!f)
            {
                break;
            }

            pDevice2 = (LPDIRECTSOUNDDEVICE)lvi.lParam;

            if(!lstrcmpi(pDevice->Description.Interface, pDevice2->Description.Interface))
            {
                if(pDevice->Description.DataFlow == pDevice2->Description.DataFlow)
                {
                    pDevice->pSharedData = pDevice2->pSharedData;
                    break;
                }
            }

            lvi.iItem++;
        }
    }
    
    // Add the device to the list
    if(pDevice)
    {
        // Device description
        lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        lvi.iItem = 0x7FFFFFFF;
        lvi.iSubItem = 0;
        lvi.pszText = pDesc->Description;
    
        if(DIRECTSOUNDDEVICE_DATAFLOW_RENDER == pDesc->DataFlow)
        {
            lvi.iImage = 1;
        }
        else
        {
            lvi.iImage = 2;
        }

        lvi.lParam = (LPARAM)pDevice;
        lvi.iItem = ListView_InsertItem(hWndLv, &lvi);

        // Module name
        lvi.mask = LVIF_TEXT;
        lvi.pszText = pDesc->Module;

        lvi.iSubItem++;

        ListView_SetItem(hWndLv, &lvi);

        // Device type
        if(DIRECTSOUNDDEVICE_TYPE_EMULATED == pDesc->Type)
        {
            lvi.pszText = "Emulated";
        }
        else if(DIRECTSOUNDDEVICE_TYPE_VXD == pDesc->Type)
        {
            lvi.pszText = "VxD";
        }
        else
        {
            lvi.pszText = "WDM";
        }

        lvi.iSubItem++;

        ListView_SetItem(hWndLv, &lvi);

        // Wave device id
        wsprintf(sz, TEXT("%u"), pDesc->WaveDeviceId);
        lvi.pszText = sz;

        lvi.iSubItem++;

        ListView_SetItem(hWndLv, &lvi);

        // GUID
        wsprintf(sz, TEXT("%8.8lX-%4.4X-%4.4X-%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X"), pDesc->DeviceId.Data1, pDesc->DeviceId.Data2, pDesc->DeviceId.Data3, pDesc->DeviceId.Data4[0], pDesc->DeviceId.Data4[1], pDesc->DeviceId.Data4[2], pDesc->DeviceId.Data4[3], pDesc->DeviceId.Data4[4], pDesc->DeviceId.Data4[5], pDesc->DeviceId.Data4[6], pDesc->DeviceId.Data4[7]);
        lvi.pszText = sz;

        lvi.iSubItem++;

        ListView_SetItem(hWndLv, &lvi);

        // Interface
        lvi.pszText = pDesc->Interface;

        lvi.iSubItem++;

        ListView_SetItem(hWndLv, &lvi);
    }

    return TRUE;
}


/***************************************************************************
 *
 *  DirectSoundEnumerateCallbackStatic
 *
 *  Description:
 *      DirectSoundEnumerate callback function.
 *
 *  Arguments:
 *      PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA [in]: description.
 *      LPVOID [in]: context argument.
 *
 *  Returns:  
 *      BOOL: TRUE to continue enumerating.
 *
 ***************************************************************************/

BOOL 
CALLBACK 
CDsMgrWindow::DirectSoundEnumerateCallbackStatic
(
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA  pDesc,
    LPVOID                                          pvContext
)
{
    return ((CDsMgrWindow *)pvContext)->DirectSoundEnumerateCallback(pDesc);
}


/***************************************************************************
 *
 *  GetSelectedDevice
 *
 *  Description:
 *      Gets the currently selected device.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      LPDIRECTSOUNDDEVICE: selected device, or NULL.
 *
 ***************************************************************************/

LPDIRECTSOUNDDEVICE 
CDsMgrWindow::GetSelectedDevice(INT iItem)
{
    HWND                    hWndLv  = GetDlgItem(m_hWnd, IDC_DEVICELIST);
    LPDIRECTSOUNDDEVICE     pDevice;
    LV_ITEM                 lvi;
    BOOL                    f;

    if(-1 == iItem)
    {
        iItem = ListView_GetNextItem(hWndLv, iItem, LVNI_SELECTED);
    }
    
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;
    
    f = ListView_GetItem(hWndLv, &lvi);

    if(f)
    {
        pDevice = (LPDIRECTSOUNDDEVICE)lvi.lParam;
    }

    return pDevice;
}


/***************************************************************************
 *
 *  GetDeviceProperties
 *
 *  Description:
 *      Gets properties for a given DirectSound device.
 *
 *  Arguments:
 *      LPDIRECTSOUNDDEVICE [in/out]: pointer to device properties.  The
 *                                    DeviceId member of the description 
 *                                    must be filled in.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

BOOL
CDsMgrWindow::GetDeviceProperties
(
    LPDIRECTSOUNDDEVICE                             pDevice
)
{
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA  pDescription    = NULL;
    HRESULT                                         hr;

    // Get device description
    hr = PrvGetDeviceDescription(m_pDsPrivate, pDevice->Description.DeviceId, &pDescription);

    if(FAILED(hr))
    {
        DPF("Unable to get device description");
    }

    if(SUCCEEDED(hr))
    {
        pDevice->Description.Type = pDescription->Type;
        pDevice->Description.DataFlow = pDescription->DataFlow;
        
        lstrcpyn(pDevice->Description.Description, pDescription->Description, sizeof(pDevice->Description.Description));
        lstrcpyn(pDevice->Description.Module, pDescription->Module, sizeof(pDevice->Description.Module));
        lstrcpyn(pDevice->Description.Interface, pDescription->Interface, sizeof(pDevice->Description.Interface));

        pDevice->Description.WaveDeviceId = pDescription->WaveDeviceId;

        delete pDescription;
    }

    // Get mixer SRC quality
    if(SUCCEEDED(hr))
    {
        hr = PrvGetMixerSrcQuality(m_pDsPrivate, pDevice->Description.DeviceId, &pDevice->pSharedData->SrcQuality);
        
        if(FAILED(hr))
        {
            DPF("Can't get mixer SRC quality");
        }
    }

    // Get mixer acceleration
    if(SUCCEEDED(hr))
    {
        hr = PrvGetMixerAcceleration(m_pDsPrivate, pDevice->Description.DeviceId, &pDevice->pSharedData->Acceleration);

        if(FAILED(hr))
        {
            DPF("Can't get mixer acceleration");
        }
    }

    // Get device presence
    if(SUCCEEDED(hr))
    {
        hr = PrvGetDevicePresence(m_pDsPrivate, pDevice->Description.DeviceId, &pDevice->Presence);

        if(FAILED(hr))
        {
            DPF("Can't get device presence");
        }
    }

    return SUCCEEDED(hr);
}


/***************************************************************************
 *
 *  SetDeviceProperties
 *
 *  Description:
 *      Sets properties for a given DirectSound device.
 *
 *  Arguments:
 *      LPDIRECTSOUNDDEVICE [in]: pointer to device properties.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

BOOL
CDsMgrWindow::SetDeviceProperties
(
    LPCDIRECTSOUNDDEVICE    pDevice
)
{
    HRESULT                 hr;

    // Set mixer SRC quality
    hr = PrvSetMixerSrcQuality(m_pDsPrivate, pDevice->Description.DeviceId, pDevice->pSharedData->SrcQuality);
    
    if(FAILED(hr))
    {
        DPF("Can't set mixer SRC quality");
    }

    // Set mixer acceleration
    if(SUCCEEDED(hr))
    {
        hr = PrvSetMixerAcceleration(m_pDsPrivate, pDevice->Description.DeviceId, pDevice->pSharedData->Acceleration);

        if(FAILED(hr))
        {
            DPF("Can't set mixer acceleration");
        }
    }

    // Set device presence
    if(SUCCEEDED(hr))
    {
        hr = PrvSetDevicePresence(m_pDsPrivate, pDevice->Description.DeviceId, pDevice->Presence);

        if(FAILED(hr))
        {
            DPF("Can't set device presence");
        }
    }

    return SUCCEEDED(hr);
}


/***************************************************************************
 *
 *  UpdateUiFromDevice
 *
 *  Description:
 *      Updates the UI from the current device settings.
 *
 *  Arguments:
 *      LPCDIRECTSOUNDDEVICE [in]: currently selected device, or NULL.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::UpdateUiFromDevice
(
    LPCDIRECTSOUNDDEVICE    pDevice
)
{
    const BOOL              fEnable = MAKEBOOL(pDevice);
    UINT                    i;
    
    static const UINT auCtrls[] = 
    { 
        IDC_MIXER_SRCQUALITY, 
        IDC_ACCELERATION_HARDWAREBUFFERS, 
        IDC_ACCELERATION_HARDWARE3D, 
        IDC_ACCELERATION_RING0MIX, 
        IDC_ACCELERATION_HARDWAREPROPERTYSETS, 
        IDC_DEVICEPRESENCE, 
        IDC_RESETDEVICE,
    };

    // Enable/disable controls
    for(i = 0; i < sizeof(auCtrls) / sizeof(auCtrls[0]); i++)
    {
        EnableWindow(GetDlgItem(m_hWnd, auCtrls[i]), fEnable);
    }

    // Set control values
    if(pDevice)
    {
        ComboBox_SetCurSel(GetDlgItem(m_hWnd, IDC_MIXER_SRCQUALITY), pDevice->pSharedData->SrcQuality);
        Button_SetCheck(GetDlgItem(m_hWnd, IDC_ACCELERATION_HARDWAREBUFFERS), !(pDevice->pSharedData->Acceleration & DIRECTSOUNDMIXER_ACCELERATIONF_NOHWBUFFERS));
        Button_SetCheck(GetDlgItem(m_hWnd, IDC_ACCELERATION_HARDWARE3D), !(pDevice->pSharedData->Acceleration & DIRECTSOUNDMIXER_ACCELERATIONF_NOHW3D));
        Button_SetCheck(GetDlgItem(m_hWnd, IDC_ACCELERATION_RING0MIX), !(pDevice->pSharedData->Acceleration & DIRECTSOUNDMIXER_ACCELERATIONF_NORING0MIX));
        Button_SetCheck(GetDlgItem(m_hWnd, IDC_ACCELERATION_HARDWAREPROPERTYSETS), !(pDevice->pSharedData->Acceleration & DIRECTSOUNDMIXER_ACCELERATIONF_NOHWPROPSETS));
        Button_SetCheck(GetDlgItem(m_hWnd, IDC_DEVICEPRESENCE), pDevice->Presence);
    }
}


/***************************************************************************
 *
 *  UpdateDeviceFromUi
 *
 *  Description:
 *      Updates a device's properties from the current UI settings.
 *
 *  Arguments:
 *      LPDIRECTSOUNDDEVICE [out]: currently selected device.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::UpdateDeviceFromUi
(
    LPDIRECTSOUNDDEVICE     pDevice
)
{
    BOOL                    f;
    
    // Get control values
    pDevice->pSharedData->SrcQuality = (DIRECTSOUNDMIXER_SRCQUALITY)ComboBox_GetCurSel(GetDlgItem(m_hWnd, IDC_MIXER_SRCQUALITY));
    pDevice->pSharedData->Acceleration = 0;

    f = Button_GetCheck(GetDlgItem(m_hWnd, IDC_ACCELERATION_HARDWAREBUFFERS));

    if(!f)
    {
        pDevice->pSharedData->Acceleration |= DIRECTSOUNDMIXER_ACCELERATIONF_NOHWBUFFERS;
    }

    f = Button_GetCheck(GetDlgItem(m_hWnd, IDC_ACCELERATION_HARDWARE3D));

    if(!f)
    {
        pDevice->pSharedData->Acceleration |= DIRECTSOUNDMIXER_ACCELERATIONF_NOHW3D;
    }

    f = Button_GetCheck(GetDlgItem(m_hWnd, IDC_ACCELERATION_RING0MIX));

    if(!f)
    {
        pDevice->pSharedData->Acceleration |= DIRECTSOUNDMIXER_ACCELERATIONF_NORING0MIX;
    }

    f = Button_GetCheck(GetDlgItem(m_hWnd, IDC_ACCELERATION_HARDWAREPROPERTYSETS));

    if(!f)
    {
        pDevice->pSharedData->Acceleration |= DIRECTSOUNDMIXER_ACCELERATIONF_NOHWPROPSETS;
    }

    pDevice->Presence = Button_GetCheck(GetDlgItem(m_hWnd, IDC_DEVICEPRESENCE));
}


/***************************************************************************
 *
 *  GetDebugProperties
 *
 *  Description:
 *      Gets debug propertes for DirectSound.
 *
 *  Arguments:
 *      PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA [out]: receives debug
 *                                                       settings.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

BOOL
CDsMgrWindow::GetDebugProperties
(
    PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA   pDebug
)
{
    HRESULT                                     hr;

    hr = PrvGetDebugInformation(m_pDsPrivate, &pDebug->Flags, &pDebug->DpfLevel, &pDebug->BreakLevel, pDebug->LogFile);

    if(FAILED(hr))
    {
        DPF("Can't get debug settings");
    }

    return SUCCEEDED(hr);
}


/***************************************************************************
 *
 *  SetDebugProperties
 *
 *  Description:
 *      Sets debug properties for DirectSound.
 *
 *  Arguments:
 *      const DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA * [in]: debug 
 *                                                             settings.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

BOOL
CDsMgrWindow::SetDebugProperties
(
    const DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA *    pDebug
)
{
    HRESULT                                     hr;

    hr = PrvSetDebugInformation(m_pDsPrivate, pDebug->Flags, pDebug->DpfLevel, pDebug->BreakLevel, pDebug->LogFile);

    if(FAILED(hr))
    {
        DPF("Can't set debug settings");
    }

    return SUCCEEDED(hr);
}


/***************************************************************************
 *
 *  UpdateUiFromDebug
 *
 *  Description:
 *      Updates the UI from the current debug settings.
 *
 *  Arguments:
 *      const DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA * [in]: current
 *                                                             debug 
 *                                                             settings.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::UpdateUiFromDebug
(
    const DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA *    pDebug
)
{
    Button_SetCheck(GetDlgItem(m_hWnd, IDC_DEBUG_PRINTFUNCTIONNAME), MAKEBOOL(pDebug->Flags & DIRECTSOUNDDEBUG_DPFINFOF_PRINTFUNCTIONNAME));
    Button_SetCheck(GetDlgItem(m_hWnd, IDC_DEBUG_PRINTPROCESSTHREADID), MAKEBOOL(pDebug->Flags & DIRECTSOUNDDEBUG_DPFINFOF_PRINTPROCESSTHREADID));
    Button_SetCheck(GetDlgItem(m_hWnd, IDC_DEBUG_PRINTFILELINE), MAKEBOOL(pDebug->Flags & DIRECTSOUNDDEBUG_DPFINFOF_PRINTFILELINE));

    SendMessage(GetDlgItem(m_hWnd, IDC_DEBUG_DPFLEVEL_SPIN), UDM_SETPOS, 0, MAKELONG(pDebug->DpfLevel, 0));
    SendMessage(GetDlgItem(m_hWnd, IDC_DEBUG_BREAKLEVEL_SPIN), UDM_SETPOS, 0, MAKELONG(pDebug->BreakLevel, 0));

    Edit_SetText(GetDlgItem(m_hWnd, IDC_DEBUG_LOGFILE), pDebug->LogFile);
}


/***************************************************************************
 *
 *  UpdateDebugFromUi
 *
 *  Description:
 *      Updates debug properties from the current UI settings.
 *
 *  Arguments:
 *      PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA [out]: receives debug
 *                                                       settings.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::UpdateDebugFromUi
(
    PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA   pDebug
)
{
    BOOL                                        f;

    pDebug->Flags = 0;
    
    f = Button_GetCheck(GetDlgItem(m_hWnd, IDC_DEBUG_PRINTFUNCTIONNAME));

    if(f)
    {
        pDebug->Flags |= DIRECTSOUNDDEBUG_DPFINFOF_PRINTFUNCTIONNAME;
    }

    f = Button_GetCheck(GetDlgItem(m_hWnd, IDC_DEBUG_PRINTPROCESSTHREADID));

    if(f)
    {
        pDebug->Flags |= DIRECTSOUNDDEBUG_DPFINFOF_PRINTPROCESSTHREADID;
    }

    f = Button_GetCheck(GetDlgItem(m_hWnd, IDC_DEBUG_PRINTFILELINE));

    if(f)
    {
        pDebug->Flags |= DIRECTSOUNDDEBUG_DPFINFOF_PRINTFILELINE;
    }

    pDebug->DpfLevel = SendDlgItemMessage(m_hWnd, IDC_DEBUG_DPFLEVEL_SPIN, UDM_GETPOS, 0, 0);
    pDebug->BreakLevel = SendDlgItemMessage(m_hWnd, IDC_DEBUG_BREAKLEVEL_SPIN, UDM_GETPOS, 0, 0);

    Edit_GetText(GetDlgItem(m_hWnd, IDC_DEBUG_LOGFILE), pDebug->LogFile, sizeof(pDebug->LogFile));
}


/***************************************************************************
 *
 *  GuidToString
 *
 *  Description:
 *      Converts a GUID to a string.
 *
 *  Arguments:
 *      REFGUID [in]: GUID.
 *      LPSTR [out]: receives string.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::GuidToString
(
    REFGUID                 guid,
    LPSTR                   pszString
)
{
    const LPCSTR            pszTemplate = "%8.8lX-%4.4X-%4.4X-%2.2X%2.2X-%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X";

    wsprintf(pszString, pszTemplate, guid.Data1, guid.Data2, guid.Data3, guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);
}


/***************************************************************************
 *
 *  StringToGuid
 *
 *  Description:
 *      Converts a string to a GUID.
 *
 *  Arguments:
 *      LPCSTR [in]: string.
 *      LPGUID [out]: receives GUID.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void 
CDsMgrWindow::StringToGuid
(
    LPCSTR                  pszString,
    LPGUID                  pguid
)
{
    CHAR                    aszGuid[4][9];
    DWORD                   dwValues[4];

    CopyMemory(&aszGuid[0][0], pszString, 8);
    pszString += 9;

    CopyMemory(&aszGuid[1][0], pszString, 4);
    pszString += 5;

    CopyMemory(&aszGuid[1][4], pszString, 4);
    pszString += 5;

    CopyMemory(&aszGuid[2][0], pszString, 4);
    pszString += 5;

    CopyMemory(&aszGuid[2][4], pszString, 4);
    pszString += 4;

    CopyMemory(&aszGuid[3][0], pszString, 8);

    aszGuid[0][8] = 0;
    aszGuid[1][8] = 0;
    aszGuid[2][8] = 0;
    aszGuid[3][8] = 0;

    dwValues[0] = atoi(aszGuid[0]);
    dwValues[1] = atoi(aszGuid[1]);
    dwValues[2] = atoi(aszGuid[2]);
    dwValues[3] = atoi(aszGuid[3]);

    CopyMemory(pguid, dwValues, sizeof(GUID));
}


/***************************************************************************
 *
 *  atoi
 *
 *  Description:
 *      Converts a string to an integer.
 *
 *  Arguments:
 *      LPCSTR [in]: string.
 *
 *  Returns:  
 *      INT: integer value.
 *
 ***************************************************************************/

INT
CDsMgrWindow::atoi
(
    LPCSTR                  pszString
)
{
    INT                     nResult = 0;
    INT                     nValue;

    while(TRUE)
    {
        if(*pszString >= '0' && *pszString <= '9')
        {
            nValue = *pszString - '0';
        }
        else if(*pszString >= 'a' && *pszString <= 'f')
        {
            nValue = *pszString - 'a' + 10;
        }
        else if(*pszString >= 'A' && *pszString <= 'F')
        {
            nValue = *pszString - 'A' + 10;
        }
        else
        {
            break;
        }
        
        nResult <<= 4;
        nResult += nValue;

        pszString++;
    }

    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsmgr\dsprvobj.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995,1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsprvobj.h
 *  Content:    DirectSound Private Object wrapper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/12/98    dereks  Created.
 *
 ***************************************************************************/

#ifndef __DSPRVOBJ_H__
#define __DSPRVOBJ_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

HRESULT DirectSoundPrivateCreate
(
    LPKSPROPERTYSET *   ppKsPropertySet
);

HRESULT PrvGetMixerSrcQuality
(
    LPKSPROPERTYSET                 pKsPropertySet,
    REFGUID                         guidDeviceId,
    DIRECTSOUNDMIXER_SRCQUALITY *   pSrcQuality
);

HRESULT PrvSetMixerSrcQuality
(
    LPKSPROPERTYSET             pKsPropertySet,
    REFGUID                     guidDeviceId,
    DIRECTSOUNDMIXER_SRCQUALITY SrcQuality
);

HRESULT PrvGetMixerAcceleration
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    LPDWORD         pdwAcceleration
);

HRESULT PrvSetMixerAcceleration
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    DWORD           dwAcceleration
);

HRESULT PrvGetDevicePresence
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    LPBOOL          pfEnabled
);

HRESULT PrvSetDevicePresence
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    BOOL            fEnabled
);

HRESULT PrvGetWaveDeviceMapping
(
    LPKSPROPERTYSET pKsPropertySet,
    LPCTSTR         pszWaveDevice,
    BOOL            fCapture,
    LPGUID          pguidDeviceId
);

HRESULT PrvGetDeviceDescription
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA *ppData
);

HRESULT PrvEnumerateDevices
(
    LPKSPROPERTYSET                         pKsPropertySet,
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK  pfnCallback,
    LPVOID                                  pvContext
);

HRESULT PrvGetBasicAcceleration
(
    LPKSPROPERTYSET                         pKsPropertySet,
    REFGUID                                 guidDeviceId,
    DIRECTSOUNDBASICACCELERATION_LEVEL *    pLevel
);

HRESULT PrvSetBasicAcceleration
(
    LPKSPROPERTYSET                     pKsPropertySet,
    REFGUID                             guidDeviceId,
    DIRECTSOUNDBASICACCELERATION_LEVEL  Level
);

HRESULT PrvGetDebugInformation
(
    LPKSPROPERTYSET pKsPropertySet,
    LPDWORD         pdwFlags,
    PULONG          pulDpfLevel,
    PULONG          pulBreakLevel,
    LPTSTR          pszLogFile
);

HRESULT PrvSetDebugInformation
(
    LPKSPROPERTYSET pKsPropertySet,
    DWORD           dwFlags,
    ULONG           ulDpfLevel,
    ULONG           ulBreakLevel,
    LPCTSTR         pszLogFile
);

HRESULT PrvGetPersistentData
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    LPCTSTR         pszSubkey,
    LPCTSTR         pszValue,
    LPDWORD         pdwRegType,
    LPVOID          pvData,
    LPDWORD         pcbData
);

HRESULT PrvSetPersistentData
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    LPCTSTR         pszSubkey,
    LPCTSTR         pszValue,
    DWORD           dwRegType,
    LPVOID          pvData,
    DWORD           cbData
);

HRESULT PrvTranslateResultCode
(
    LPKSPROPERTYSET                                         pKsPropertySet,
    HRESULT                                                 hrResult,
    PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA * ppData
);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DSPRVOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsmgr\dsmgr.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsmgr.h
 *  Content:    Main application header.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/15/97    dereks  Created.
 *
 ***************************************************************************/

#ifndef __DSMGR_H__
#define __DSMGR_H__

// We'll ask for what we need, thank you.
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN

// Public includes
#include <windows.h>
#include <mmsystem.h>
#include <dsoundp.h>

// Private includes
#include "resource.h"

#endif // __DSMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DsMgr.rc
//
#define IDD_DSMGR                       101
#define IDI_DSMGR                       102
#define IDI_PLAYBACK                    103
#define IDI_RECORD                      104
#define IDC_DEVICELIST                  1005
#define IDC_MIXER_SRCQUALITY            1006
#define IDC_ACCELERATION_HARDWAREBUFFERS 1007
#define IDC_ACCELERATION_HARDWARE3D     1008
#define IDC_ACCELERATION_RING0MIX       1009
#define IDC_ACCELERATION_HARDWAREPROPERTYSETS 1010
#define IDC_DEVICEPRESENCE              1011
#define IDC_MIXER_DEFAULT3DALGORITHM    1012
#define IDC_DEBUG_PRINTFUNCTIONNAME     1014
#define IDC_DEBUG_PRINTPROCESSTHREADID  1015
#define IDC_DEBUG_PRINTFILELINE         1016
#define IDC_DEBUG_DPFLEVEL              1018
#define IDC_DEBUG_BREAKLEVEL            1019
#define IDC_DEBUG_LOGFILE               1020
#define IDC_DEBUG_LOGFILE_BROWSE        1021
#define IDC_DEBUG_DPFLEVEL_SPIN         1023
#define IDC_DEBUG_BREAKLEVEL_SPIN       1024
#define IDC_APPLY                       1028
#define IDC_RESETDEVICE                 1029
#define IDC_RESETALL                    1030

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1031
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsmgr\dsprvobj.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995,1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsprvobj.c
 *  Content:    DirectSound Private Object wrapper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/12/98    dereks  Created.
 *
 ***************************************************************************/

// We'll ask for what we need, thank you.
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN

// Public includes
#include <windows.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include <dsprv.h>

// Private includes
#include "dsprvobj.h"


/***************************************************************************
 *
 *  DirectSoundPrivateCreate
 *
 *  Description:
 *      Creates and initializes a DirectSoundPrivate object.
 *
 *  Arguments:
 *      LPKSPROPERTYSET * [out]: receives IKsPropertySet interface to the
 *                               object.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT DirectSoundPrivateCreate
(
    LPKSPROPERTYSET *       ppKsPropertySet
)
{
    typedef HRESULT (STDAPICALLTYPE *LPFNDLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID *);

    HINSTANCE               hLibDsound              = NULL;
    LPFNGETCLASSOBJECT      pfnDllGetClassObject    = NULL;
    LPCLASSFACTORY          pClassFactory           = NULL;
    LPKSPROPERTYSET         pKsPropertySet          = NULL;
    HRESULT                 hr                      = DS_OK;

    // Get dsound.dll's instance handle.  The dll must already be loaded at this
    // point.
    hLibDsound = 
        GetModuleHandle
        (
            TEXT("dsound.dll")
        );

    if(!hLibDsound)
    {
        hr = DSERR_GENERIC;
    }

    // Find DllGetClassObject
    if(SUCCEEDED(hr))
    {
        pfnDllGetClassObject = (LPFNDLLGETCLASSOBJECT)
            GetProcAddress
            (
                hLibDsound, 
                "DllGetClassObject"
            );

        if(!pfnDllGetClassObject)
        {
            hr = DSERR_GENERIC;
        }
    }

    // Create a class factory object    
    if(SUCCEEDED(hr))
    {
        hr = 
            pfnDllGetClassObject
            (
                CLSID_DirectSoundPrivate, 
                IID_IClassFactory, 
                (LPVOID *)&pClassFactory
            );
    }

    // Create the DirectSoundPrivate object and query for an IKsPropertySet
    // interface
    if(SUCCEEDED(hr))
    {
        hr = 
            pClassFactory->CreateInstance
            (
                NULL, 
                IID_IKsPropertySet, 
                (LPVOID *)&pKsPropertySet
            );
    }

    // Release the class factory
    if(pClassFactory)
    {
        pClassFactory->Release();
    }

    // Success
    if(SUCCEEDED(hr))
    {
        *ppKsPropertySet = pKsPropertySet;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvGetMixerSrcQuality
 *
 *  Description:
 *      Gets the mixer SRC quality for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      DIRECTSOUNDMIXER_SRCQUALITY * [out]: receives mixer SRC quality.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetMixerSrcQuality
(
    LPKSPROPERTYSET                             pKsPropertySet,
    REFGUID                                     guidDeviceId,
    DIRECTSOUNDMIXER_SRCQUALITY *               pSrcQuality
)
{
    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA Data;
    HRESULT                                     hr;

    Data.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundMixer,
            DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pSrcQuality = Data.Quality;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvSetMixerSrcQuality
 *
 *  Description:
 *      Sets the mixer SRC quality for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      DIRECTSOUNDMIXER_SRCQUALITY [in]: mixer SRC quality.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetMixerSrcQuality
(
    LPKSPROPERTYSET                             pKsPropertySet,
    REFGUID                                     guidDeviceId,
    DIRECTSOUNDMIXER_SRCQUALITY                 SrcQuality
)
{
    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA Data;
    HRESULT                                     hr;

    Data.DeviceId = guidDeviceId;
    Data.Quality = SrcQuality;

    hr =
        pKsPropertySet->Set
        (
            DSPROPSETID_DirectSoundMixer,
            DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY,
            NULL,
            0,
            &Data,
            sizeof(Data)
        );

    return hr;
}


/***************************************************************************
 *
 *  PrvGetMixerAcceleration
 *
 *  Description:
 *      Gets the mixer acceleration flags for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      LPDWORD [out]: receives acceleration flags.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetMixerAcceleration
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    LPDWORD                                         pdwAcceleration
)
{
    DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA   Data;
    HRESULT                                         hr;

    Data.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundMixer,
            DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pdwAcceleration = Data.Flags;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvSetMixerAcceleration
 *
 *  Description:
 *      Sets the mixer acceleration flags for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      DWORD [in]: acceleration flags.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetMixerAcceleration
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    DWORD                                           dwAcceleration
)
{
    DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA   Data;
    HRESULT                                         hr;

    Data.DeviceId = guidDeviceId;
    Data.Flags = dwAcceleration;

    hr =
        pKsPropertySet->Set
        (
            DSPROPSETID_DirectSoundMixer,
            DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION,
            NULL,
            0,
            &Data,
            sizeof(Data)
        );

    return hr;
}


/***************************************************************************
 *
 *  PrvGetDevicePresence
 *
 *  Description:
 *      Determines whether a device is enabled.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      LPBOOL [out]: receives TRUE if the device is enabled.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetDevicePresence
(
    LPKSPROPERTYSET                             pKsPropertySet,
    REFGUID                                     guidDeviceId,
    LPBOOL                                      pfEnabled
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA  Data;
    HRESULT                                     hr;

    Data.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pfEnabled = Data.Present;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvSetDevicePresence
 *
 *  Description:
 *      Sets whether a device is enabled.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      BOOL [in]: TRUE if the device is enabled.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetDevicePresence
(
    LPKSPROPERTYSET                             pKsPropertySet,
    REFGUID                                     guidDeviceId,
    BOOL                                        fEnabled
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA  Data;
    HRESULT                                     hr;

    Data.DeviceId = guidDeviceId;
    Data.Present = fEnabled;

    hr =
        pKsPropertySet->Set
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE,
            NULL,
            0,
            &Data,
            sizeof(Data)
        );

    return hr;
}


/***************************************************************************
 *
 *  PrvGetWaveDeviceMapping
 *
 *  Description:
 *      Gets the DirectSound device id (if any) for a given waveIn or
 *      waveOut device description.  This is the description given by
 *      waveIn/OutGetDevCaps (szPname).
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      LPCSTR [in]: wave device description.
 *      BOOL [in]: TRUE if the device description refers to a waveIn device.
 *      LPGUID [out]: receives DirectSound device GUID.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetWaveDeviceMapping
(
    LPKSPROPERTYSET                                     pKsPropertySet,
    LPCTSTR                                             pszWaveDevice,
    BOOL                                                fCapture,
    LPGUID                                              pguidDeviceId
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA Data;
    HRESULT                                             hr;

    Data.DeviceName = (LPTSTR)pszWaveDevice;
    Data.DataFlow = fCapture ? DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE : DIRECTSOUNDDEVICE_DATAFLOW_RENDER;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pguidDeviceId = Data.DeviceId;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvGetDeviceDescription
 *
 *  Description:
 *      Gets the extended description for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device id.
 *      PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA [out]: receives
 *                                                            description.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetDeviceDescription
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA *ppData
)
{
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA  pData   = NULL;
    ULONG                                           cbData;
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA   Basic;
    HRESULT                                         hr;

    Basic.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
            NULL,
            0,
            &Basic,
            sizeof(Basic),
            &cbData
        );

    if(SUCCEEDED(hr))
    {
        pData = (PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA)new BYTE [cbData];

        if(!pData)
        {
            hr = DSERR_OUTOFMEMORY;
        }
    }

    if(SUCCEEDED(hr))
    {
        pData->DeviceId = guidDeviceId;
        
        hr =
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundDevice,
                DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
                NULL,
                0,
                pData,
                cbData,
                NULL
            );
    }

    if(SUCCEEDED(hr))
    {
        *ppData = pData;
    }
    else if(pData)
    {
        delete pData;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvEnumerateDevices
 *
 *  Description:
 *      Enumerates all DirectSound devices.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK [in]: pointer to the callback
 *                                                   function.
 *      LPVOID [in]: context argument to pass to the callback function.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvEnumerateDevices
(
    LPKSPROPERTYSET                             pKsPropertySet,
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK      pfnCallback,
    LPVOID                                      pvContext
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA Data;
    HRESULT                                     hr;

    Data.Callback = pfnCallback;
    Data.Context = pvContext;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    return hr;
}


/***************************************************************************
 *
 *  PrvGetBasicAcceleration
 *
 *  Description:
 *      Gets basic acceleration flags for a given DirectSound device.  This
 *      is the accleration level that the multimedia control panel uses.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      DIRECTSOUNDBASICACCELERATION_LEVEL * [out]: receives basic 
 *                                                  acceleration level.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetBasicAcceleration
(
    LPKSPROPERTYSET                                             pKsPropertySet,
    REFGUID                                                     guidDeviceId,
    DIRECTSOUNDBASICACCELERATION_LEVEL *                        pLevel
)
{
    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA   Data;
    HRESULT                                                     hr;

    Data.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundBasicAcceleration,
            DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pLevel = Data.Level;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvSetBasicAcceleration
 *
 *  Description:
 *      Sets basic acceleration flags for a given DirectSound device.  This
 *      is the accleration level that the multimedia control panel uses.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      DIRECTSOUNDBASICACCELERATION_LEVEL [in]: basic acceleration level.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetBasicAcceleration
(
    LPKSPROPERTYSET                                             pKsPropertySet,
    REFGUID                                                     guidDeviceId,
    DIRECTSOUNDBASICACCELERATION_LEVEL                          Level
)
{
    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA   Data;
    HRESULT                                                     hr;

    Data.DeviceId = guidDeviceId;
    Data.Level = Level;

    hr =
        pKsPropertySet->Set
        (
            DSPROPSETID_DirectSoundBasicAcceleration,
            DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION,
            NULL,
            0,
            &Data,
            sizeof(Data)
        );

    return hr;
}


/***************************************************************************
 *
 *  PrvGetDebugInformation
 *
 *  Description:
 *      Gets the current DirectSound debug settings.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      LPDWORD [in]: receives DPF flags.
 *      PULONG [out]: receives DPF level.
 *      PULONG [out]: receives break level.
 *      LPSTR [out]: receives log file name.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetDebugInformation
(
    LPKSPROPERTYSET                             pKsPropertySet,
    LPDWORD                                     pdwFlags,
    PULONG                                      pulDpfLevel,
    PULONG                                      pulBreakLevel,
    LPTSTR                                      pszLogFile
)
{
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA    Data;
    HRESULT                                     hr;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDebug,
            DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr) && pdwFlags)
    {
        *pdwFlags = Data.Flags;
    }

    if(SUCCEEDED(hr) && pulDpfLevel)
    {
        *pulDpfLevel = Data.DpfLevel;
    }

    if(SUCCEEDED(hr) && pulBreakLevel)
    {
        *pulBreakLevel = Data.BreakLevel;
    }

    if(SUCCEEDED(hr) && pszLogFile)
    {
        lstrcpy
        (
            pszLogFile,
            Data.LogFile
        );
    }
    
    return hr;
}


/***************************************************************************
 *
 *  PrvSetDebugInformation
 *
 *  Description:
 *      Sets the current DirectSound debug settings.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      DWORD [in]: DPF flags.
 *      ULONG [in]: DPF level.
 *      ULONG [in]: break level.
 *      LPCSTR [in]: log file name.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetDebugInformation
(
    LPKSPROPERTYSET                             pKsPropertySet,
    DWORD                                       dwFlags,
    ULONG                                       ulDpfLevel,
    ULONG                                       ulBreakLevel,
    LPCTSTR                                     pszLogFile
)
{
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA    Data;
    HRESULT                                     hr;

    Data.Flags = dwFlags;
    Data.DpfLevel = ulDpfLevel;
    Data.BreakLevel = ulBreakLevel;

    lstrcpy
    (
        Data.LogFile,
        pszLogFile
    );
    
    hr =
        pKsPropertySet->Set
        (
            DSPROPSETID_DirectSoundDebug,
            DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO,
            NULL,
            0,
            &Data,
            sizeof(Data)
        );

    return hr;
}


/***************************************************************************
 *
 *  PrvGetPersistentData
 *
 *  Description:
 *      Gets a registry value stored under the DirectSound subkey of a 
 *      specific hardware device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device id.
 *      LPCSTR [in]: subkey path.
 *      LPCSTR [in]: value name.
 *      LPDWORD [in/out]: receives registry data type.
 *      LPVOID [out]: data buffer.
 *      LPDWORD [in/out]: size of above buffer.  On entry, this argument is
 *                        filled with the maximum size of the data buffer.
 *                        On exit, this argument is filled with the required
 *                        size.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetPersistentData
(
    LPKSPROPERTYSET                                         pKsPropertySet,
    REFGUID                                                 guidDeviceId,
    LPCTSTR                                                 pszSubkey,
    LPCTSTR                                                 pszValue,
    LPDWORD                                                 pdwRegType,
    LPVOID                                                  pvData,
    LPDWORD                                                 pcbData
)
{
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA  pPersist;
    ULONG                                                   cbPersist;
    HRESULT                                                 hr;

    cbPersist = sizeof(*pPersist) + *pcbData;
    
    pPersist = (PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA)
        LocalAlloc
        (
            LPTR,
            cbPersist
        );

    if(pPersist)
    {
        pPersist->DeviceId = guidDeviceId;
        pPersist->SubKeyName = (LPTSTR)pszSubkey;
        pPersist->ValueName = (LPTSTR)pszValue;

        if(pdwRegType)
        {
            pPersist->RegistryDataType = *pdwRegType;
        }

        hr =
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundPersistentData,
                DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA,
                NULL,
                0,
                pPersist,
                cbPersist,
                &cbPersist
            );
    }
    else
    {
        hr = DSERR_OUTOFMEMORY;
    }

    if(SUCCEEDED(hr))
    {
        CopyMemory
        (
            pvData,
            pPersist + 1,
            *pcbData
        );
    }
    
    *pcbData = cbPersist - sizeof(*pPersist);

    if(pPersist && pdwRegType)
    {
        *pdwRegType = pPersist->RegistryDataType;
    }

    if(pPersist)
    {
        LocalFree(pPersist);
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvSetPersistentData
 *
 *  Description:
 *      Sets a registry value stored under the DirectSound subkey of a 
 *      specific hardware device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device id.
 *      LPCSTR [in]: subkey path.
 *      LPCSTR [in]: value name.
 *      DWORD [in]: registry data type.
 *      LPVOID [out]: data buffer.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetPersistentData
(
    LPKSPROPERTYSET                                         pKsPropertySet,
    REFGUID                                                 guidDeviceId,
    LPCTSTR                                                 pszSubkey,
    LPCTSTR                                                 pszValue,
    DWORD                                                   dwRegType,
    LPVOID                                                  pvData,
    DWORD                                                   cbData
)
{
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA  pPersist;
    ULONG                                                   cbPersist;
    HRESULT                                                 hr;

    cbPersist = sizeof(*pPersist) + cbData;
    
    pPersist = (PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA)
        LocalAlloc
        (
            LPTR,
            cbPersist
        );

    if(pPersist)
    {
        pPersist->DeviceId = guidDeviceId;
        pPersist->SubKeyName = (LPTSTR)pszSubkey;
        pPersist->ValueName = (LPTSTR)pszValue;
        pPersist->RegistryDataType = dwRegType;

        CopyMemory
        (
            pPersist + 1,
            pvData,
            cbData
        );

        hr =
            pKsPropertySet->Set
            (
                DSPROPSETID_DirectSoundPersistentData,
                DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA,
                NULL,
                0,
                pPersist,
                cbPersist
            );
    }
    else
    {
        hr = DSERR_OUTOFMEMORY;
    }

    if(pPersist)
    {
        LocalFree(pPersist);
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvTranslateErrorCode
 *
 *  Description:
 *      Translates an error code to a string representation.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      HRESULT [in]: result code.
 *      PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATEERRORCODE_DATA * [out]:
 *          receives error code data.  The caller is responsible for freeing
 *          this buffer.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvTranslateResultCode
(
    LPKSPROPERTYSET                                         pKsPropertySet,
    HRESULT                                                 hrResult,
    PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA * ppData
)
{
    PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA   pData   = NULL;
    DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA    Basic;
    ULONG                                                   cbData;
    HRESULT                                                 hr;

    Basic.ResultCode = hrResult;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDebug,
            DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE,
            NULL,
            0,
            &Basic,
            sizeof(Basic),
            &cbData
        );

    if(SUCCEEDED(hr))
    {
        pData = (PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA)
            LocalAlloc
            (
                LPTR,
                cbData
            );

        if(!pData)
        {
            hr = DSERR_OUTOFMEMORY;
        }
    }

    if(SUCCEEDED(hr))
    {
        pData->ResultCode = hrResult;
        
        hr =
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundDebug,
                DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE,
                NULL,
                0,
                pData,
                cbData,
                NULL
            );
    }

    if(SUCCEEDED(hr))
    {
        *ppData = pData;
    }
    else if(pData)
    {
        LocalFree
        (
            pData
        );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound3d\sources.inc ===
#############################################################################
# Copyright (C) Microsoft Corporation 2000
#############################################################################

!include ..\..\dsound\sources.inc

!ifndef DSROOT
DSROOT=$(DXROOT)\dsound
!endif

TARGETNAME = dsound3d

C_DEFINES = $(C_DEFINES) -DBUILD_LUT -DNOKS

USER_C_FLAGS = $(USER_C_FLAGS) /Zm800

INCLUDES = $(INCLUDES);$(DSROOT)\dsound

SOURCES = dsound3d.rc vmaxcoef.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsvxd\dsvxd.h ===
#define DSVXD_IOCTL_INITIALIZE			1
#define DSVXD_IOCTL_SHUTDOWN			2

#define DSVXD_IOCTL_DRVGETNEXTDRIVERDESC	3
#define DSVXD_IOCTL_DRVGETDESC			4
#define DSVXD_IOCTL_DRVQUERYINTERFACE		5
#define DSVXD_IOCTL_DRVOPEN			6

#define DSVXD_IOCTL_DRVCLOSE			7
#define DSVXD_IOCTL_DRVGETCAPS			8
#define DSVXD_IOCTL_DRVCREATESOUNDBUFFER	9
#define DSVXD_IOCTL_DRVDUPLICATESOUNDBUFFER	10

#define DSVXD_IOCTL_BUFFERRELEASE		11
#define DSVXD_IOCTL_BUFFERLOCK			12
#define DSVXD_IOCTL_BUFFERUNLOCK		13
#define DSVXD_IOCTL_BUFFERSETFORMAT		14
#define DSVXD_IOCTL_BUFFERSETRATE		15
#define DSVXD_IOCTL_BUFFERSETVOLUMEPAN		16
#define DSVXD_IOCTL_BUFFERSETPOSITION		17
#define DSVXD_IOCTL_BUFFERGETPOSITION		18
#define DSVXD_IOCTL_BUFFERPLAY			19 
#define DSVXD_IOCTL_BUFFERSTOP			20

#define DSVXD_IOCTL_EVENTSCHEDULEWIN32EVENT	21
#define DSVXD_IOCTL_EVENTCLOSEVXDHANDLE		22

#define DSVXD_IOCTL_MEMRESERVEALIAS		23
#define DSVXD_IOCTL_MEMCOMMITALIAS		24
#define DSVXD_IOCTL_MEMREDIRECTALIAS		25
#define DSVXD_IOCTL_MEMDECOMMITALIAS		26
#define DSVXD_IOCTL_MEMFREEALIAS		27

#define DSVXD_IOCTL_MEMPAGELOCK			28
#define DSVXD_IOCTL_MEMPAGEUNLOCK		29

#define DSVXD_IOCTL_PageFile_Get_Version	30
#define DSVXD_IOCTL_VMM_Test_Debug_Installed	31
#define DSVXD_IOCTL_VMCPD_Get_Version		32

#define DSVXD_IOCTL_GetMixerMutexPtr		33

#define DSVXD_IOCTL_Mixer_Run			34
#define DSVXD_IOCTL_Mixer_Stop			35
#define DSVXD_IOCTL_Mixer_PlayWhenIdle		36
#define DSVXD_IOCTL_Mixer_StopWhenIdle		37
#define DSVXD_IOCTL_Mixer_MixListAdd		38
#define DSVXD_IOCTL_Mixer_MixListRemove		39
#define DSVXD_IOCTL_Mixer_FilterOn		40
#define DSVXD_IOCTL_Mixer_FilterOff		41
#define DSVXD_IOCTL_Mixer_GetBytePosition	42
#define DSVXD_IOCTL_Mixer_SignalRemix		43 

#define DSVXD_IOCTL_KeDest_New			44
#define DSVXD_IOCTL_MixDest_Delete		45
#define DSVXD_IOCTL_MixDest_Initialize		46
#define DSVXD_IOCTL_MixDest_Terminate		47
#define DSVXD_IOCTL_MixDest_SetFormat		48
#define DSVXD_IOCTL_MixDest_SetFormatInfo	49
#define DSVXD_IOCTL_MixDest_AllocMixer		50
#define DSVXD_IOCTL_MixDest_FreeMixer		51
#define DSVXD_IOCTL_MixDest_Play		52
#define DSVXD_IOCTL_MixDest_Stop		53
#define DSVXD_IOCTL_MixDest_GetFrequency	54

#define DSVXD_IOCTL_MEMCOMMITPHYSALIAS          55
#define DSVXD_IOCTL_MEMREDIRECTPHYSALIAS        56


#define DSVXD_IOCTL_IUnknown_QueryInterface			57
#define DSVXD_IOCTL_IUnknown_AddRef				58
#define DSVXD_IOCTL_IUnknown_Release				59

#define DSVXD_IOCTL_IDirectSoundPropertySet_GetProperty		60
#define DSVXD_IOCTL_IDirectSoundPropertySet_SetProperty		61
#define DSVXD_IOCTL_IDirectSoundPropertySet_QuerySupport	62

#define DSVXD_IOCTL_GetInternalVersionNumber   63
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound3d\win9x\makefile.inc ===
misc: ..\vmaxcoef.cpp

..\vmaxcoef.cpp: ..\..\dsound\vmaxcoef.cpp
                 copy ..\..\dsound\vmaxcoef.cpp ..\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound3d\daytona\makefile.inc ===
misc: ..\vmaxcoef.cpp

..\vmaxcoef.cpp: ..\..\dsound\vmaxcoef.cpp
                 copy ..\..\dsound\vmaxcoef.cpp ..\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsvxd\dev.cpp ===
//--------------------------------------------------------------------------;
//
//  File: dev.cpp
//
//  Copyright (c) 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//  Contains program related to managing the direct sound drivers and
//  driver list.
//
//  Contents:
//
//  History:
//      06/15/95    FrankYe
//
//--------------------------------------------------------------------------;
#define WANTVXDWRAPS

#include <windows.h>

extern "C"
{
    #include <vmm.h>
    #include <vxdldr.h>
    #include <vwin32.h>
    #include <vxdwraps.h>
    #include <configmg.h>
}

#define NODSOUNDWRAPS
#include <mmsystem.h>
#include <dsound.h>
#include <dsdrvi.h>
#include "dsvxd.h"
#include "dsvxdi.h"

#pragma warning(disable:4355) // 'this' : used in base member initializer list

#pragma VxD_PAGEABLE_CODE_SEG
#pragma VxD_PAGEABLE_DATA_SEG

VMMLIST gvmmlistDrivers = 0;

//==========================================================================;
//
//  guid functions
//  guidAlloc: gets guid from guid pool and returns pointer to it
//  guidFree: returns guid to guid pool
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//
//--------------------------------------------------------------------------;
// TODO need more static guids.  this is enough for now
GUID guidList[] = {
  { /* 3d0b92c0-abfc-11ce-a3b3-00aa004a9f0c */
    0x3d0b92c0,
    0xabfc,
    0x11ce,
    {0xa3, 0xb3, 0x00, 0xaa, 0x00, 0x4a, 0x9f, 0x0c}
  },
  { /* 3d0b92c1-abfc-11ce-a3b3-00aa004a9f0c */
    0x3d0b92c1,
    0xabfc,
    0x11ce,
    {0xa3, 0xb3, 0x00, 0xaa, 0x00, 0x4a, 0x9f, 0x0c}
  },
  { /* 3d0b92c2-abfc-11ce-a3b3-00aa004a9f0c */
    0x3d0b92c2,
    0xabfc,
    0x11ce,
    {0xa3, 0xb3, 0x00, 0xaa, 0x00, 0x4a, 0x9f, 0x0c}
  },
  { /* 3d0b92c3-abfc-11ce-a3b3-00aa004a9f0c */
    0x3d0b92c3,
    0xabfc,
    0x11ce,
    {0xa3, 0xb3, 0x00, 0xaa, 0x00, 0x4a, 0x9f, 0x0c}
  },
  { /* 3d0b92c4-abfc-11ce-a3b3-00aa004a9f0c */
    0x3d0b92c4,
    0xabfc,
    0x11ce,
    {0xa3, 0xb3, 0x00, 0xaa, 0x00, 0x4a, 0x9f, 0x0c}
  },
  { /* 3d0b92c5-abfc-11ce-a3b3-00aa004a9f0c */
    0x3d0b92c5,
    0xabfc,
    0x11ce,
    {0xa3, 0xb3, 0x00, 0xaa, 0x00, 0x4a, 0x9f, 0x0c}
  },
  { /* 3d0b92c6-abfc-11ce-a3b3-00aa004a9f0c */
    0x3d0b92c6,
    0xabfc,
    0x11ce,
    {0xa3, 0xb3, 0x00, 0xaa, 0x00, 0x4a, 0x9f, 0x0c}
  },
  { /* 3d0b92c7-abfc-11ce-a3b3-00aa004a9f0c */
    0x3d0b92c7,
    0xabfc,
    0x11ce,
    {0xa3, 0xb3, 0x00, 0xaa, 0x00, 0x4a, 0x9f, 0x0c}
  },
  { /* 3d0b92c8-abfc-11ce-a3b3-00aa004a9f0c */
    0x3d0b92c8,
    0xabfc,
    0x11ce,
    {0xa3, 0xb3, 0x00, 0xaa, 0x00, 0x4a, 0x9f, 0x0c}
  },
  { /* 3d0b92c9-abfc-11ce-a3b3-00aa004a9f0c */
    0x3d0b92c9,
    0xabfc,
    0x11ce,
    {0xa3, 0xb3, 0x00, 0xaa, 0x00, 0x4a, 0x9f, 0x0c}
  }
};

#define NUMGUIDS (sizeof(guidList) / sizeof(guidList[0]))
typedef struct tGUIDRECORD {
    LPCGUID pGuid;
    BOOL    fAlloc;
    UINT    uAge;
} GUIDRECORD, *PGUIDRECORD;

PGUIDRECORD gpaGuidRec;

REFGUID GuidAlloc()
{
    PGUIDRECORD pGuidRec;
    PGUIDRECORD pGuidRecOldest;
    UINT uAgeOldest;
    int i;

    pGuidRecOldest = NULL;
    uAgeOldest = 0;

    for (i=0; i<NUMGUIDS; i++) {
        pGuidRec = &gpaGuidRec[i];

        if (pGuidRec->fAlloc) continue;

        if (pGuidRec->uAge++ >= uAgeOldest) {
            pGuidRecOldest = pGuidRec;
            uAgeOldest = pGuidRec->uAge;
        }
    }

    if (NULL == pGuidRecOldest) {
        BREAK(("Ran out of guids"));
        return GUID_NULL;
    } else {
        pGuidRecOldest->fAlloc = TRUE;
        return *(pGuidRecOldest->pGuid);
    }
}

void GuidFree(REFGUID rGuid)
{
    PGUIDRECORD pGuidRecMatch;
    int i;

    pGuidRecMatch = NULL;
    for (i=0; i<NUMGUIDS; i++) {
        if (IsEqualGUID(*gpaGuidRec[i].pGuid, rGuid)) {
            //
            // For debug, we go thru all guid records and assert if
            // we match on more than just one.  For retail, we break
            // the loop as soon as we match one.
            //
#ifdef DEBUG
            if (pGuidRecMatch != NULL) ASSERT(FALSE);
            pGuidRecMatch = &gpaGuidRec[i];
#else
            pGuidRecMatch = &gpaGuidRec[i];
            break;
#endif
        }
    }

    ASSERT(NULL != pGuidRecMatch);
    if (NULL == pGuidRecMatch) return;  // defensive

    pGuidRecMatch->fAlloc = FALSE;
    pGuidRecMatch->uAge = 0;

    return;
}

//==========================================================================;
//==========================================================================;
//
//  CBuf_IDsDriverPropertySet class implementation
//
//==========================================================================;
//==========================================================================;

//--------------------------------------------------------------------------;
//
// Constructor
//
//--------------------------------------------------------------------------;
CBuf_IDsDriverPropertySet::CBuf_IDsDriverPropertySet(CBuf *pBuf)
{
    m_cRef = 0;
    m_pBuf = pBuf;
    return;
}

//--------------------------------------------------------------------------;
//
// QueryInterface - delegates to CBuf
//
//--------------------------------------------------------------------------;
STDMETHODIMP CBuf_IDsDriverPropertySet::QueryInterface(REFIID riid, PVOID *ppv)
{
    return m_pBuf->QueryInterface(riid, ppv);
}

//--------------------------------------------------------------------------;
//
// AddRef
//  Maintains interface ref count, and delegates to CBuf to maintain
// total object ref count.
//
//--------------------------------------------------------------------------;
STDMETHODIMP_(ULONG) CBuf_IDsDriverPropertySet::AddRef(void)
{
    ASSERT(m_cRef >= 0);
    m_cRef++;
    m_pBuf->AddRef();
    return m_cRef;
}

//--------------------------------------------------------------------------;
//
// Release
//  Maintains interface ref count.  When interface ref count goes to 0
// then release the real driver's IDsDriverPropertySet interface.  Also,
// delegate to CBuf in order to maintain total object ref count
//
//--------------------------------------------------------------------------;
STDMETHODIMP_(ULONG) CBuf_IDsDriverPropertySet::Release(void)
{
    ASSERT(m_cRef > 0);

    if (--m_cRef > 0) {
        m_pBuf->Release();
        return m_cRef;
    }

    m_pBuf->m_pIDsDriverPropertySet_Real->Release();
    m_pBuf->m_pIDsDriverPropertySet_Real = NULL;
    m_pBuf->Release();
    return 0;
}

//--------------------------------------------------------------------------;
//
// Get, Set, QuerySupport
//  If CBuf hasn't been deregistered, call real driver's
// IDsDriverPropertySet interface
//
//--------------------------------------------------------------------------;
STDMETHODIMP CBuf_IDsDriverPropertySet::Get(PDSPROPERTY pDsProperty,
                                            PVOID pPropertyParams,
                                            ULONG cbPropertyParams,
                                            PVOID pPropertyData,
                                            ULONG cbPropertyData,
                                            PULONG pcbReturnedData)
{
    if (m_pBuf->m_fDeregistered) return DSERR_NODRIVER;
    return m_pBuf->m_pIDsDriverPropertySet_Real->Get(pDsProperty, pPropertyParams,
        cbPropertyParams, pPropertyData, cbPropertyData, pcbReturnedData);
}

STDMETHODIMP CBuf_IDsDriverPropertySet::Set(PDSPROPERTY pDsProperty,
                                            PVOID pPropertyParams,
                                            ULONG cbPropertyParams,
                                            PVOID pPropertyData,
                                            ULONG cbPropertyData)
{
    if (m_pBuf->m_fDeregistered) return DSERR_NODRIVER;
    return m_pBuf->m_pIDsDriverPropertySet_Real->Set(pDsProperty, pPropertyParams, cbPropertyParams, pPropertyData, cbPropertyData);
}

STDMETHODIMP CBuf_IDsDriverPropertySet::QuerySupport(REFGUID PropertySetId,
                                                     ULONG PropertyId,
                                                     PULONG pSupport)
{
    if (m_pBuf->m_fDeregistered) return DSERR_NODRIVER;
    return m_pBuf->m_pIDsDriverPropertySet_Real->QuerySupport(PropertySetId, PropertyId, pSupport);
}

//==========================================================================;
//==========================================================================;
//
//  CBuf class implementation
//
//==========================================================================;
//==========================================================================;

//--------------------------------------------------------------------------;
//
// CBuf new and delete operators
//
//  We allocate these objects as nodes on a VMMLIST.  New takes a VMMLIST
// as a parameter.  We bump the size of the allocation enough to store the
// VMMLIST handle at the end of the object.  The Delete operator gets the
// VMMLIST handle from the end of the storage that was allocated for the
// object, and uses that hande to deallocate the list node.  The objects
// are also attached to and removed from the list as they are created and
// deleted.
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
void* CBuf::operator new(size_t size, VMMLIST list)
{
    PVOID pv;

    pv = List_Allocate(list);
    if (pv) {
        memset(pv, 0x00, size);
        *(VMMLIST*)((PBYTE)pv + size) = list;
        List_Attach_Tail(list, pv);
    }
    return pv;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
void CBuf::operator delete(void * pv, size_t size)
{
    VMMLIST list;

    list = *(VMMLIST*)((PBYTE)pv + size);
    ASSERT(list);
    List_Remove(list, pv);
    List_Deallocate(list, pv);
}

//--------------------------------------------------------------------------;
//
// Constructor
//  Initializes its contained CBuf_IDsDriverPropertySet interface
// implementation.
//
//--------------------------------------------------------------------------;
CBuf::CBuf(void)
 : m_IDsDriverPropertySet(this)
{
    return;
}

//--------------------------------------------------------------------------;
//
// CreateList
//  Static class method.  It simpley creates a VMMLIST
// to be used to create/delete CBuf objects.
//
//--------------------------------------------------------------------------;
VMMLIST CBuf::CreateList(void)
{
    return List_Create(LF_ALLOC_ERROR, sizeof(CBuf) + sizeof(VMMLIST));
}

//--------------------------------------------------------------------------;
//
// DeleteList
//  Static class method.  Destroys a VMMLIST that was used to
// create/destroy CBuf objects.
//
//--------------------------------------------------------------------------;
void CBuf::DestroyList(VMMLIST list)
{
    ASSERT(!List_Get_First(list));
    List_Destroy(list);
}

//--------------------------------------------------------------------------;
//
// CreateBuf
//  Static class method.  Creates a CBuf object given the creating CDrv
// object, the VMMLIST to be used to create the CBuf, and a pointer to the
// IDsDriverBuffer interface on the real driver buffer to be contained by
// the CBuf object.
//
//--------------------------------------------------------------------------;

HRESULT CBuf::CreateBuf(CDrv *pDrv, VMMLIST list, IDsDriverBuffer *pIDsDriverBuffer_Real, IDsDriverBuffer **ppIDsDriverBuffer)
{
    CBuf *pBuf;

    *ppIDsDriverBuffer = NULL;

    pBuf = new(list) CBuf;
    if (!pBuf) return E_OUTOFMEMORY;

    pBuf->m_pDrv = pDrv;
    pBuf->m_pIDsDriverBuffer_Real = pIDsDriverBuffer_Real;
    pBuf->AddRef();

    *ppIDsDriverBuffer = (IDsDriverBuffer*)pBuf;

    return S_OK;
}

//--------------------------------------------------------------------------;
//
// DeregisterBuffers
//  Static class method.  Given a VMMLIST containing CBuf objects, this method
// walks the list marking each of the CBuf objects as deregistered.
//
//--------------------------------------------------------------------------;
void CBuf::DeregisterBuffers(VMMLIST list)
{
    CBuf *pBuf;

    for ( pBuf = (CBuf*)List_Get_First(list);
          pBuf;
          pBuf = (CBuf*)List_Get_Next(list, pBuf) )
    {
        pBuf->m_fDeregistered = TRUE;
    }

    return;
}

//--------------------------------------------------------------------------;
//
// QueryInterface
//  When querying for IUnknown or IDsDriverBuffer, just return this
// object.  If querying for IDsDriverPropertySet, then we need to query
// the real driver buffer for this interface, if we haven't already.
//
//--------------------------------------------------------------------------;
STDMETHODIMP CBuf::QueryInterface(REFIID riid, LPVOID *ppv)
{
    HRESULT hr;
    *ppv = NULL;

    if (IID_IUnknown == riid || IID_IDsDriverBuffer == riid) {

        *ppv = (IDsDriverBuffer*)this;

    } else if (IID_IDsDriverPropertySet == riid) {

        if (!m_pIDsDriverPropertySet_Real) {
            // don't have the interface from the driver so try to get it
            hr = m_pIDsDriverBuffer_Real->QueryInterface(riid, (PVOID*)&m_pIDsDriverPropertySet_Real);
            if (FAILED(hr) && m_pIDsDriverPropertySet_Real) {
                // TODO: RPF(Driver is stupic cuz it failed QI but set *ppv)
                m_pIDsDriverPropertySet_Real = NULL;
            }
        }
        if (m_pIDsDriverPropertySet_Real) {
            *ppv = &m_IDsDriverPropertySet;
        }
    }

    if (NULL == *ppv) return E_NOINTERFACE;
    ((LPUNKNOWN)*ppv)->AddRef();
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// AddRef
//
//--------------------------------------------------------------------------;
STDMETHODIMP_(ULONG) CBuf::AddRef(void)
{
    m_cRef++;
    m_pDrv->AddRef();
    return m_cRef;
}

//--------------------------------------------------------------------------;
//
// Release
//  When the ref count goes to zero, then we release the real driver
// buffer's IDsDriverBuffer interface.  We always release the CDrv object
// that created this CBuf, too, since we the CDrv lifetime brackets the
// CBuf lifetime.
//
//--------------------------------------------------------------------------;
STDMETHODIMP_(ULONG) CBuf::Release(void)
{
    CDrv *pDrv;

    pDrv = m_pDrv;

    m_cRef--;
    if (0 == m_cRef) {
        DRVCALL(("IDsDriverBuffer(%008X)->Release()", m_pIDsDriverBuffer_Real));
        m_pIDsDriverBuffer_Real->Release();
        delete this;
        pDrv->Release();
        return 0;
    }

    pDrv->Release();
    return m_cRef;
}

//--------------------------------------------------------------------------;
//
// IDsDriverBuffer methods
//  Return error if the real driver has deregistered, otherwise
// call the real driver's buffer's interface
//
//--------------------------------------------------------------------------;
STDMETHODIMP CBuf::GetPosition(PDWORD pdwPlay, PDWORD pdwWrite)
{
    if (m_fDeregistered) return DSERR_NODRIVER;

    DRVCALL(("IDsDriverBuffer(%08Xh)->GetPosition(%08Xh, %08Xh)", m_pIDsDriverBuffer_Real, pdwPlay, pdwWrite));
    return m_pIDsDriverBuffer_Real->GetPosition(pdwPlay, pdwWrite);
}

STDMETHODIMP CBuf::Lock(LPVOID *ppvAudio1,
                   LPDWORD pdwLen1, LPVOID *ppvAudio2,
                   LPDWORD pdwLen2, DWORD dwWritePosition,
                   DWORD dwWriteLen, DWORD dwFlags)
{
    if (m_fDeregistered) return DSERR_NODRIVER;

    DRVCALL(("IDsDriverBuffer(%08Xh)->Lock(%08Xh, %08Xh, %08Xh, %08Xh, %08Xh, %08Xh, %08Xh)",
             m_pIDsDriverBuffer_Real, ppvAudio1, pdwLen1, ppvAudio2,
             pdwLen2,dwWritePosition, dwWriteLen, dwFlags));
    return m_pIDsDriverBuffer_Real->Lock(ppvAudio1, pdwLen1, ppvAudio2, pdwLen2,
                                         dwWritePosition, dwWriteLen, dwFlags);
}

STDMETHODIMP CBuf::Play(DWORD dw1, DWORD dw2, DWORD dwFlags)
{
    if (m_fDeregistered) return DSERR_NODRIVER;

    DRVCALL(("IDsDriverBuffer(%08Xh)->Play(%08Xh, %08Xh, %08Xh)", dw1, dw2, dwFlags));
    return m_pIDsDriverBuffer_Real->Play(dw1, dw2, dwFlags);
}

STDMETHODIMP CBuf::SetFormat(LPWAVEFORMATEX pwfx)
{
    if (m_fDeregistered) return DSERR_NODRIVER;

    DRVCALL(("IDsDriverBuffer(%08Xh)->SetFormat(%08Xh)", m_pIDsDriverBuffer_Real, pwfx));
    return m_pIDsDriverBuffer_Real->SetFormat(pwfx);
}

STDMETHODIMP CBuf::SetFrequency(DWORD dwFrequency)
{
    if (m_fDeregistered) return DSERR_NODRIVER;

    DRVCALL(("IDsDriverBuffer(%08Xh)->SetFrequency(%08Xh)", m_pIDsDriverBuffer_Real, dwFrequency));
    return m_pIDsDriverBuffer_Real->SetFrequency(dwFrequency);
}

STDMETHODIMP CBuf::SetPosition(DWORD dwPosition)
{
    if (m_fDeregistered) return DSERR_NODRIVER;

    DRVCALL(("IDsDriverBuffer(%08Xh)->SetPosition(%08Xh)", m_pIDsDriverBuffer_Real, dwPosition));
    return m_pIDsDriverBuffer_Real->SetPosition(dwPosition);
}

STDMETHODIMP CBuf::SetVolumePan(PDSVOLUMEPAN pDsVolumePan)
{
    if (m_fDeregistered) return DSERR_NODRIVER;

    DRVCALL(("IDsDriverBuffer(%08Xh)->SetVolumePan(%08Xh)", m_pIDsDriverBuffer_Real, pDsVolumePan));
    return m_pIDsDriverBuffer_Real->SetVolumePan(pDsVolumePan);
}

STDMETHODIMP CBuf::Stop(void)
{
    if (m_fDeregistered) return DSERR_NODRIVER;

    DRVCALL(("IDsDriverBuffer(%08Xh)->Stop()", m_pIDsDriverBuffer_Real));
    return m_pIDsDriverBuffer_Real->Stop();
}

STDMETHODIMP CBuf::Unlock(LPVOID pvAudio1,
                          DWORD dwLen1, LPVOID pvAudio2,
                          DWORD dwLen2)
{
    if (m_fDeregistered) return DSERR_NODRIVER;

    DRVCALL(("IDsDriverBuffer(%08Xh)->Unlock(%08Xh, %08Xh, %08Xh, %08Xh)",
             m_pIDsDriverBuffer_Real, pvAudio1, dwLen1, pvAudio2, dwLen2));
    return m_pIDsDriverBuffer_Real->Unlock(pvAudio1, dwLen1, pvAudio2, dwLen2);
}

STDMETHODIMP_(BOOL) CBuf::IsDeregistered(void)
{
    return m_fDeregistered;
}

STDMETHODIMP_(IDsDriverBuffer*) CBuf::GetRealDsDriverBuffer(void)
{
    return m_pIDsDriverBuffer_Real;
}

//==========================================================================;
//==========================================================================;
//
//  CDrv class implementation
//
//==========================================================================;
//==========================================================================;

//--------------------------------------------------------------------------;
//
// CDrv new and delete operators
//  These allocate the CDrv objects on a VMMLIST whose handle
// has gobal scope (thus we don't need to same VMMLIST handle trickery
// as we use the new/delete operators for the CBuf class).
//
//--------------------------------------------------------------------------;
void* CDrv::operator new(size_t size)
{
    PVOID pv;

    ASSERT(0 != gvmmlistDrivers);

    pv = List_Allocate(gvmmlistDrivers);
    if (NULL != pv) memset(pv, 0x00, size);
    return pv;
}

void CDrv::operator delete(void * pv)
{
    List_Deallocate(gvmmlistDrivers, pv);
}

//==========================================================================;
//
// CDrv class methods
//
//==========================================================================;

HRESULT CDrv::CreateAndRegisterDriver(IDsDriver *pIDsDriver)
{
    CDrv *pDrv;
    HRESULT hr;

    pDrv = new CDrv;
    if (pDrv) {

        pDrv->m_cRef=0;
        pDrv->m_cOpen = 0;
        pDrv->m_fDeregistered = FALSE;
        pDrv->m_pIDsDriver_Real = pIDsDriver;

        pDrv->m_listBuffers = CBuf::CreateList();
        if (pDrv->m_listBuffers) {

            pDrv->m_guidDriver = GuidAlloc();
            if (!IsEqualGUID(GUID_NULL, pDrv->m_guidDriver)) {
                List_Attach_Tail(gvmmlistDrivers, pDrv);
                pDrv->AddRef();
                hr = S_OK;
            } else {
                hr = DSERR_GENERIC;
            }

            if (FAILED(hr)) {
                CBuf::DestroyList(pDrv->m_listBuffers);
            }

        } else {
            hr = E_OUTOFMEMORY;
        }

        if (FAILED(hr)) {
            delete pDrv;
        }

    } else {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CDrv::DeregisterDriver(IDsDriver *pIDsDriver)
{
    CDrv *pDrv;

    ASSERT(0 != gvmmlistDrivers);

    pDrv = FindFromIDsDriver(pIDsDriver);
    if (NULL == pDrv) {
        BREAK(("Tried to deregister a driver that's not registered"));
        return DSERR_INVALIDPARAM;
    }

    if (0 != pDrv->m_cOpen) {
        DPF(("warning: driver deregistered while it was open"));
    }

    CBuf::DeregisterBuffers(pDrv->m_listBuffers);

    pDrv->m_fDeregistered = TRUE;
    pDrv->Release();
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// CDrv::GetNextDescFromGuid
//
//  Gets the driver description of the next driver after the one having
//  the specified GUID
//
// Entry:
//
// Returns (HRESULT):
//
// Notes:
//
//--------------------------------------------------------------------------;
HRESULT CDrv::GetNextDescFromGuid(LPCGUID pGuidLast, LPGUID pGuid, PDSDRIVERDESC pDrvDesc)
{
    CDrv *pDrv;
    DSVAL dsv;

    ASSERT(gvmmlistDrivers);

    if ((NULL == pGuidLast) || IsEqualGUID(GUID_NULL, *pGuidLast)) {
        pDrv = (CDrv*)List_Get_First(gvmmlistDrivers);
    } else {
        pDrv = FindFromGuid(*pGuidLast);
        if (NULL != pDrv) {
            pDrv = (CDrv*)List_Get_Next(gvmmlistDrivers, pDrv);
        }
    }

    if (NULL == pDrv) return DSERR_NODRIVER;

    *pGuid = pDrv->m_guidDriver;

    dsv = pDrv->GetDriverDesc(pDrvDesc);
    return dsv;
}

HRESULT CDrv::GetDescFromGuid(REFGUID rguidDriver, PDSDRIVERDESC pDrvDesc)
{
    CDrv *pDrv;
    DSVAL dsv;

    ASSERT(gvmmlistDrivers);

    pDrv = FindFromGuid(rguidDriver);
    if (NULL == pDrv) return DSERR_NODRIVER;
    dsv = pDrv->GetDriverDesc(pDrvDesc);
    return dsv;
}

HRESULT CDrv::OpenFromGuid(REFGUID refGuid, IDsDriver **ppIDsDriver)
{
    CDrv *pDrv;
    HRESULT hr;

    *ppIDsDriver = NULL;

    pDrv = FindFromGuid(refGuid);

    if (pDrv) {
        hr = pDrv->Open();
        if (SUCCEEDED(hr)) {
            *ppIDsDriver = pDrv;
        }
    } else {
        hr = DSERR_NODRIVER;
    }

    return hr;
}

CDrv* CDrv::FindFromIDsDriver(IDsDriver *pIDsDriver)
{
    CDrv *pDrv;

    ASSERT(gvmmlistDrivers);

    pDrv = (CDrv*)List_Get_First(gvmmlistDrivers);
    while ((NULL != pDrv) && (pDrv->m_pIDsDriver_Real != pIDsDriver)) {
        pDrv = (CDrv*)List_Get_Next(gvmmlistDrivers, pDrv);
    }
    return pDrv;
}

CDrv* CDrv::FindFromGuid(REFGUID riid)
{
    CDrv *pDrv;

    ASSERT(gvmmlistDrivers);

    pDrv = (CDrv*)List_Get_First(gvmmlistDrivers);
    while ((NULL != pDrv) && (!IsEqualGUID(riid, pDrv->m_guidDriver))) {
        pDrv = (CDrv*)List_Get_Next(gvmmlistDrivers, pDrv);
    }
    return pDrv;
}

//==========================================================================;
//
// COM interface implementations
//
//==========================================================================;

STDMETHODIMP CDrv::QueryInterface(REFIID riid, PVOID* ppv)
{
    *ppv = NULL;
    if ((IID_IUnknown == riid) || (IID_IDsDriver == riid))
        *ppv = this;

    if (NULL == *ppv)
        return E_NOINTERFACE;

    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CDrv::AddRef(void)
{
    ASSERT(m_cRef >= 0);
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CDrv::Release(void)
{
    ASSERT(m_cRef > 0);
    if (0 >= --m_cRef) {

        ASSERT(gvmmlistDrivers);
        List_Remove(gvmmlistDrivers, this);
        GuidFree(m_guidDriver);
        ASSERT(m_listBuffers);
        ASSERT(!List_Get_First(m_listBuffers));
        CBuf::DestroyList(m_listBuffers);
        m_listBuffers = NULL;
        delete this;
        return 0;

    } else {
        return m_cRef;
    }
}

STDMETHODIMP CDrv::GetDriverDesc(PDSDRIVERDESC pDsDriverDesc)
{
    if (m_fDeregistered) return DSERR_NODRIVER;

    DRVCALL(("IDsDriver(%08Xh)->GetDriverDesc(%08Xh)", m_pIDsDriver_Real, pDsDriverDesc));
    return m_pIDsDriver_Real->GetDriverDesc(pDsDriverDesc);
}

STDMETHODIMP CDrv::Open(void)
{
    HRESULT hr;

    ASSERT(0 == m_cOpen);

    if (m_fDeregistered) return DSERR_NODRIVER;

    DRVCALL(("IDsDriver(%08Xh)->Open()", m_pIDsDriver_Real));
    hr = m_pIDsDriver_Real->Open();
    if (SUCCEEDED(hr)) {
        m_cOpen++;
        AddRef();
    }

    return hr;
}

STDMETHODIMP CDrv::Close(void)
{
    HRESULT hr;

    ASSERT(m_cOpen > 0);

    m_cOpen--;

    if (m_fDeregistered) {
        DPF(("driver must have deregistered while open"));
        Release();
        return NOERROR;
    }

    DRVCALL(("IDsDriver(%08Xh)->Close()", m_pIDsDriver_Real));
    hr = m_pIDsDriver_Real->Close();
    if (SUCCEEDED(hr)) Release();

    // Warning: _this_ object may have been destroyed by
    // the above calls to Release();

    return hr;
}

STDMETHODIMP CDrv::GetCaps(PDSDRIVERCAPS pDsDriverCaps)
{
    if (m_fDeregistered) {
        return DSERR_NODRIVER;
    } else {
        DRVCALL(("IDsDriver(%08Xh)->GetCaps(%08Xh)", m_pIDsDriver_Real, pDsDriverCaps));
        return m_pIDsDriver_Real->GetCaps(pDsDriverCaps);
    }
}

STDMETHODIMP CDrv::CreateSoundBuffer(LPWAVEFORMATEX pwfx,
                                     DWORD dwFlags,
                                     DWORD dwCardAddress,
                                     LPDWORD pdwcbBufferSize,
                                     LPBYTE *ppbBuffer,
                                     LPVOID *ppv)
{
    LPWAVEFORMATEX pwfxKernel;
    int cbwfx;
    IDsDriverBuffer *pIDsDriverBuffer_Real;
    HRESULT hr;

    *ppv = NULL;

    if (m_fDeregistered) {
        return DSERR_NODRIVER;
    }

    //
    // Note that some drivers (mwave) appear to access the WAVEFORMATEX
    // structure from another thread.  So, we must guarantee that the
    // this structure is in the global heap before passing it to the
    // driver.  As a side effect, this code also ensures that a full
    // WAVEFORMATEX structure is passed to the driver, not just a
    // PCMWAVEFORMAT.  I seem to recall some drivers always expecting
    // a full WAVEFORMATEX structure, but I'm not sure.
    //
    if (WAVE_FORMAT_PCM == pwfx->wFormatTag) {
        cbwfx = sizeof(PCMWAVEFORMAT);
    } else {
        cbwfx = sizeof(WAVEFORMATEX) + pwfx->cbSize;
    }

    pwfxKernel = (LPWAVEFORMATEX)_HeapAllocate(max(cbwfx, sizeof(WAVEFORMATEX)), HEAPZEROINIT | HEAPSWAP);
    if (pwfxKernel) {

        memcpy(pwfxKernel, pwfx, cbwfx);

        DRVCALL(("IDsDriver(%08Xh)->CreateSoundBuffer(%08X, %08X, %08X, %08X, %08X, %08X)",
                m_pIDsDriver_Real, pwfx, dwFlags, dwCardAddress, pdwcbBufferSize, ppbBuffer, &pIDsDriverBuffer_Real));
        hr = m_pIDsDriver_Real->CreateSoundBuffer(pwfxKernel, dwFlags, dwCardAddress, pdwcbBufferSize,
                                                  ppbBuffer, (PVOID*)&pIDsDriverBuffer_Real);

        if (SUCCEEDED(hr)) {
            hr = CBuf::CreateBuf(this, m_listBuffers, pIDsDriverBuffer_Real, (IDsDriverBuffer**)ppv);
            if (FAILED(hr)) {
                pIDsDriverBuffer_Real->Release();
                ASSERT(NULL == *ppv);
            }
        }

        _HeapFree(pwfxKernel, 0);

    } else {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

STDMETHODIMP CDrv::DuplicateSoundBuffer(PIDSDRIVERBUFFER pIDsDriverBuffer, LPVOID *ppv)
{
    IDsDriverBuffer *pIDsDriverBufferDup_Real;
    HRESULT hr;

    *ppv = NULL;

    if (m_fDeregistered) {
        return DSERR_NODRIVER;
    }

    DRVCALL(("IDsDriver(%08Xh)->DuplicateSoundBuffer(...)", m_pIDsDriver_Real));
    hr = m_pIDsDriver_Real->DuplicateSoundBuffer(((CBuf*)pIDsDriverBuffer)->GetRealDsDriverBuffer(), (PVOID*)&pIDsDriverBufferDup_Real);
    if (SUCCEEDED(hr)) {
        hr = CBuf::CreateBuf(this, m_listBuffers, pIDsDriverBufferDup_Real, (IDsDriverBuffer**)ppv);
        if (FAILED(hr)) {
            DRVCALL(("IDsDriver(%08Xh)->Release()", m_pIDsDriver_Real));
            pIDsDriverBufferDup_Real->Release();
            ASSERT(NULL == *ppv);
        }
    }

    return hr;
}

//==========================================================================;
//
// DSOUND_RegisterDeviceDriver
// DSOUND_DeregisterDeviceDriver
//
// These services are called by a direct sound driver when the driver
// initializes or terminates to register/deregister itself as a direct
// sound driver.  Typcially, these would be called from
// within the driver's PnP CONFIG_START and CONFIG_STOP handlers.
//
// Entry:
//  PIDSDRIVER pIDsDriver: pointer to the driver's interface
//
//  DWORD dwFlags: reserved, caller should set to 0
//
// Returns (DSVAL):
//
// Notes:
//  We maintain a list of drivers using the VMM List_* services.  Each node
//  of the list is a DSDRV structure.  During registration, a list node is
//  created and insterted into the list.  The pIDsDriver member is initialized
//  with a pointer to the driver's interface.  When deregistering, the node
//  is marked as deregistered.  If there are no open instances on the driver,
//  then the node is removed from the list.
//
//==========================================================================;

HRESULT SERVICE DSOUND_RegisterDeviceDriver(PIDSDRIVER pIDsDriver, DWORD dwFlags)
{
    DPF(("DSOUND_RegisterDeviceDriver(%08Xh, %08Xh)", pIDsDriver, dwFlags));
    return CDrv::CreateAndRegisterDriver(pIDsDriver);
}

HRESULT SERVICE DSOUND_DeregisterDeviceDriver(PIDSDRIVER pIDsDriver, DWORD dwFlags)
{
    DPF(("DSOUND_DeregisterDeviceDriver(%08Xh, %08Xh)", pIDsDriver, dwFlags));
    return CDrv::DeregisterDriver(pIDsDriver);
}

//==========================================================================;
//
// VxD CONTROL routines for drv
//
//==========================================================================;

int ctrlDrvInit()
{
    int i;

    gvmmlistDrivers = List_Create(LF_ALLOC_ERROR, sizeof(CDrv));
    if (0 == gvmmlistDrivers) return 0;

    gpaGuidRec = (PGUIDRECORD)_HeapAllocate( NUMGUIDS*sizeof(gpaGuidRec[0]), HEAPZEROINIT );
    if (NULL == gpaGuidRec) {
        List_Destroy(gvmmlistDrivers);
        gvmmlistDrivers = 0;
        return 0;
    }

    for (i=0; i<NUMGUIDS; i++)
        gpaGuidRec[i].pGuid = &guidList[i];

    return 1;
}

int ctrlDrvExit()
{
    if (NULL != gpaGuidRec) {
        _HeapFree(gpaGuidRec, 0);
        gpaGuidRec = NULL;
    }

    if (0 != gvmmlistDrivers) {
        List_Destroy(gvmmlistDrivers);
        gvmmlistDrivers = 0;
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsvxd\kegrace.cpp ===
//--------------------------------------------------------------------------;
//
//  File: kegrace.cpp
//
//  Copyright (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  Contents:
//
//  History:
//      06/29/96    FrankYe     Created
//
//--------------------------------------------------------------------------;

#define NODSOUNDSERVICETABLE
#include "dsoundi.h"

// never premix less than this
#define MIN_PREMIX        45

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

extern "C" void KeGrace_GlobalTimeOutProcAsm();

LONG lMixerMutex;

LONG glNum;
DWORDLONG gdwlTotalWasted;
DWORDLONG gdwlTotal;
DWORDLONG _inline GetPentiumCounter(void)
{
   _asm  _emit 0x0F
   _asm  _emit 0x31
}

ULONG VXDINLINE VMM_Get_System_Time(void)
{
    ULONG Time;

    Touch_Register(eax);
    VMMCall(Get_System_Time);
    _asm mov Time, eax;
    return Time;
}

VOID _VMCPD_Get_Thread_State(PTCB Thread, PVOID pCPState)
{
    _asm mov esi, pCPState;
    _asm mov edi, Thread;
    VxDCall(VMCPD_Get_Thread_State);
}

VOID _VMCPD_Set_Thread_State(PTCB Thread, PVOID pCPState)
{
    _asm mov esi, pCPState;
    _asm mov edi, Thread;
    VxDCall(VMCPD_Set_Thread_State);
}

LONG _InterlockedExchange(PLONG pTarget, LONG Value)
{
    LONG OldTarget;
    _asm push edi;
    _asm mov eax, Value;
    _asm mov edi, pTarget;
    _asm xchg [edi], eax;
    _asm mov OldTarget, eax;
    _asm pop edi;
    return OldTarget;
}

// Must be in locked code
LONG _InterlockedExchangeAdd(PLONG pAddend, LONG Increment)
{
    LONG OldAddend;
    _asm mov esi, pAddend;
    _asm mov ecx, Increment;
    _asm mov eax, [esi];        // Read it (possibly causing a fault in)
    _asm add ecx, eax;
    _asm mov [esi], ecx;
    _asm mov OldAddend, eax;
    return OldAddend;
}

VOID _ZeroMemory(PVOID pDestination, DWORD cbLength)
{
    _asm mov edi, pDestination ;
    _asm mov esi, cbLength ;
    _asm xor eax, eax ;
    _asm mov ecx, esi ;
    _asm shr ecx, 2 ;
    _asm rep stosd ;
    _asm mov ecx, esi ;
    _asm and ecx, 3 ;
    _asm rep stosb ;
}
    
// Override the global new and delete operators
void * ::operator new(size_t size)
{ 
    return MemAlloc(size); 
}

void ::operator delete(void * pv) 
{ 
    MemFree(pv); 
}

// Implement our own purecall
int __cdecl _purecall(void)
{
    ASSERT(FALSE);
    return 0;
}

typedef struct tEVENTPARAMS {
    HTIMEOUT                hEvent;
    class CKeGrace          *pThis;
} EVENTPARAMS, *PEVENTPARAMS;

class CKeGrace : public CGrace {
    public:
        HRESULT             Initialize(CGrDest *pGrDest);
        void                Terminate(void);
        void                SignalRemix(void);
        int                 GetMaxRemix(void);
        void                GlobalTimeOutProc(int dtimeTardiness);

    private:
        static const int    MIXER_MINPREMIX;
        static const int    MIXER_MAXPREMIX;
        LONG                m_dtimePremix;
        LONG                m_ddtimePremix;
        EVENTPARAMS         m_EventParams;
        LONG                m_timeBusyWaitForMutex;
};

const int CKeGrace::MIXER_MINPREMIX = 45;
const int CKeGrace::MIXER_MAXPREMIX = 200;

extern "C" void KeGrace_GlobalTimeOutProc(PVOID pKeGrace, int dtimeTardiness)
{
    ((CKeGrace*)pKeGrace)->GlobalTimeOutProc(dtimeTardiness);
}

void CKeGrace::SignalRemix()
{
    HTIMEOUT hEvent;

#if 0
    // If you wanna run without remixing, just enable this bit of code.  You
    // might want to lower the MIXER_MAXPREMIX constant as well.
    m_fdwMixerSignal &= DSMIXERSIGNAL_REMIX;
    return;
#endif
    
    if (!(m_fdwMixerSignal & DSMIXERSIGNAL_REMIX))
    {
        m_fdwMixerSignal |= DSMIXERSIGNAL_REMIX;

        // Set a new time out for 2ms, and then cancel any prior pending timeout.
        //
        //  Note that "2ms" is somewhat arbitrary.  It just needs to be
        //  enough time to hopefully let this thread release the mixer
        //  mutex before the event executes.

        hEvent = Set_Global_Time_Out(KeGrace_GlobalTimeOutProcAsm, 2, (ULONG)&m_EventParams);
        hEvent = _InterlockedExchange((PLONG)&m_EventParams.hEvent, hEvent);
        Cancel_Time_Out(hEvent);
    }
}

void CKeGrace::GlobalTimeOutProc(int dtimeTardiness)
{
    char        CPState[108];        // Size of fp state per Intel prog. ref.
    LONG        dtime;
    LONG        dtimeSleep;
    LONG        dtimeInvalid;
    LONG        dtimeNextNotify;
    int         cSamplesPremixMax;
    int         cSamplesPremixed;

    // DPF(("CKeGrace::GlobalTimeOutProc"));

    if (m_dtimePremix/2 < dtimeTardiness) {
        DPF(("CKeGrace_GlobalTimeOutProc : warning: %dms late", dtimeTardiness));
    }

    //
    // We busy wait on the mutex, each iteration of the wait is longer
    // than the previous.
    //
    if (_InterlockedExchange(&lMixerMutex, TRUE)) {
        HTIMEOUT hEvent;
        LONG timeOut;
        // DPF(("CKeGrace::GlobalTimeOutProc : note: mutex already owned"));
        timeOut = _InterlockedExchangeAdd(&m_timeBusyWaitForMutex, 1);
        hEvent = Set_Global_Time_Out(KeGrace_GlobalTimeOutProcAsm, timeOut,
                                     (ULONG)&m_EventParams);
        hEvent = _InterlockedExchange((PLONG)&m_EventParams.hEvent, hEvent);
        Cancel_Time_Out(hEvent);
        return;
    }
    m_timeBusyWaitForMutex = 1;
    
    // Three cases:
    //   1) mixer is stopped
    //   2) mixer running and a remix is pending
    //   3) mixer running and no remix is pending
    //
    // Around each call to Refresh we need to save and restore the thread's
    // floating point state using the VMCPD Get/Set_Thread_State services.
    //

    if (MIXERSTATE_STOPPED == m_kMixerState) {
            
        dtimeSleep = 1000;        // arbitrarily set for 1 second

    } else {

        // DWORDLONG dwlStartCycle;
        // DWORDLONG dwlT;
        // dwlStartCycle = dwlT = GetPentiumCounter();

        dtime = VMM_Get_System_Time();

        _ZeroMemory(&CPState, sizeof(CPState));
        _VMCPD_Get_Thread_State(Get_Cur_Thread_Handle(), &CPState);

        // gdwlTotalWasted += GetPentiumCounter() - dwlT;
        // glNum++;

        if (m_fdwMixerSignal & DSMIXERSIGNAL_REMIX) {

            m_dtimePremix = MIXER_MINPREMIX;        // Initial premix length
            m_ddtimePremix = 2;                     // increment

            cSamplesPremixMax = MulDivRD(m_dtimePremix, m_pDest->m_nFrequency, 1000);
            Refresh(TRUE, cSamplesPremixMax, &cSamplesPremixed, &dtimeNextNotify);
        } else {

            m_dtimePremix += m_ddtimePremix;
            if (m_dtimePremix > MIXER_MAXPREMIX) {
                m_dtimePremix = MIXER_MAXPREMIX;
            } else {
                m_ddtimePremix += 2;
            }

            cSamplesPremixMax = MulDivRD(m_dtimePremix, m_pDest->m_nFrequency, 1000);
            Refresh(FALSE, cSamplesPremixMax, &cSamplesPremixed, &dtimeNextNotify);
        }

        // dwlT = GetPentiumCounter();
        
        _VMCPD_Set_Thread_State(Get_Cur_Thread_Handle(), &CPState);

        dtimeInvalid = MulDivRD(cSamplesPremixed, 1000, m_pDest->m_nFrequency);
        dtime = VMM_Get_System_Time() - dtime;
        dtimeInvalid -= 2 * dtime;

        dtimeSleep = min(dtimeNextNotify, dtimeInvalid/2);
        dtimeSleep = max(dtimeSleep, MIXER_MINPREMIX/2);

        // gdwlTotalWasted += GetPentiumCounter() - dwlT;
        // gdwlTotal += GetPentiumCounter() - dwlStartCycle;

    }

    // DPF(("CKeGrace::GlobalTimeOutProc : note: dtimeSleep=%dms", dtimeSleep));
    ASSERT(!m_EventParams.hEvent);
    m_EventParams.hEvent = Set_Global_Time_Out(KeGrace_GlobalTimeOutProcAsm, dtimeSleep, (ULONG)&m_EventParams);
    
    _InterlockedExchange(&lMixerMutex, FALSE);
}

HRESULT CKeGrace::Initialize(CGrDest *pDest)
{
    HRESULT hr;

    hr = CGrace::Initialize(pDest);
    if (S_OK != hr) return hr;
    
    DPF(("CKeGrace::Initialize : note: Setting up first GlobalTimeOut"));

    // If we want to run the timer really fast, do this.  So far I haven't seen
    // any empirical evidence of this helping.
    VTD_Begin_Min_Int_Period(5);

    m_dtimePremix = MIXER_MINPREMIX;        // Initial premix length
    m_ddtimePremix = 2;                     // increment

    // REMIND do error check
    m_timeBusyWaitForMutex = 1;
    m_EventParams.pThis = this;
    m_EventParams.hEvent = Set_Global_Time_Out(KeGrace_GlobalTimeOutProcAsm, 1, (ULONG)&m_EventParams);

    gdwlTotal = 0;
    gdwlTotalWasted = 0;
    glNum = 0;
    
    return hr;
}

//--------------------------------------------------------------------------;
//
// Terminate
//
// This function is called to terminate the grace mixer thread for the
// specified ds object.  It returns the handle to the thread that is being
// terminated.  After releasing any critical sections that the grace mixer
// thread may be waiting on, the caller should wait for the thread handle
// to become signaled.  For Win32 beginners: the thread handle is signalled
// after the thread terminates.
//
//--------------------------------------------------------------------------;

void CKeGrace::Terminate()
{
    HTIMEOUT        hEvent;

    hEvent = _InterlockedExchange((PLONG)&m_EventParams.hEvent, 0);
    Cancel_Time_Out(hEvent);

    CGrace::Terminate();

    if (0 != glNum) {
        DPF(("Wasted time = %d cycles", (int)(gdwlTotalWasted / glNum)));
        DPF(("Total  time = %d cycles", (int)(gdwlTotal       / glNum)));
    }
}

int CKeGrace::GetMaxRemix(void)
{
    // return max number of samples we might remix
    return (MulDivRU(MIXER_MAXPREMIX, m_pDest->m_nFrequency, 1000));
}


#pragma VxD_PAGEABLE_CODE_SEG
#pragma VxD_PAGEABLE_DATA_SEG

class CKeGrDest : public CGrDest {
public:
        CKeGrDest(LPNAGRDESTDATA);
        HRESULT Initialize(void);
        void Terminate(void);
        HRESULT SetFormat(LPWAVEFORMATEX pwfx);
        HRESULT AllocMixer(CMixer **ppMixer);
        void FreeMixer(void);
        HRESULT GetSamplePosition(int *pposPlay, int *pposWrite);
        HRESULT GetSamplePositionNoWin16(int *pposPlay, int *pposWrite);
        HRESULT Lock(PVOID *ppBuffer1, int *pcbBuffer1, PVOID *ppBuffer2, int *pcbBuffer2, int ibWrite, int cbWrite);
        HRESULT Unlock(PVOID pBuffer1, int cbBuffer1, PVOID pBuffer2, int cbBuffer2);
        void Play();
        void Stop();

    private:
        CKeGrace*   m_pKeGrace;
        DWORD       m_fdwDriverDesc;
        CBuf*       m_pDrvBuf;
        // Let's only send a stop if we are currently playing
        BOOL        m_fStopped;
};

CKeGrDest::CKeGrDest(LPNAGRDESTDATA pData)
{
    m_cbBuffer = pData->cbBuffer;
    m_pBuffer = pData->pBuffer;
    m_pDrvBuf = ((CBuf*)((PIDSDRIVERBUFFER)pData->hBuffer));
    m_fdwDriverDesc = pData->fdwDriverDesc;
    m_fStopped = TRUE;
}

HRESULT CKeGrDest::Initialize(void)
{
    m_cSamples = m_cbBuffer >> m_nBlockAlignShift;
    return DS_OK;
}

void CKeGrDest::Terminate(void)
{
    return;
}

HRESULT CKeGrDest::AllocMixer(CMixer **ppMixer)
{
    HRESULT hr;
    
    ASSERT(m_pBuffer);
    
    *ppMixer = NULL;
    
    m_pKeGrace = new CKeGrace;
    if (m_pKeGrace) {
        hr = m_pKeGrace->Initialize(this);
        if (S_OK != hr) {
            delete m_pKeGrace;
            m_pKeGrace = NULL;
        }
    } else {
        hr = DSERR_OUTOFMEMORY;
    }

    if (S_OK == hr) *ppMixer = m_pKeGrace;
    return hr;
}

void CKeGrDest::FreeMixer()
{
    ASSERT(m_pKeGrace);

    m_pKeGrace->Terminate();
    delete m_pKeGrace;
    m_pKeGrace = NULL;
}

HRESULT CKeGrDest::SetFormat(LPWAVEFORMATEX pwfx)
{
    HRESULT hr;

    SetFormatInfo(pwfx);
    hr = m_pDrvBuf->SetFormat(pwfx);
    return hr;
}

void CKeGrDest::Play()
{
    HRESULT hr;
    // REMIND we're not propagating errors here!
    hr = m_pDrvBuf->Play(0, 0, DSBPLAY_LOOPING);
    if (SUCCEEDED(hr)) m_fStopped = FALSE;
}

void CKeGrDest::Stop()
{
    HRESULT hr;
    if (m_fStopped == FALSE)
    {
        hr = m_pDrvBuf->Stop();
        if (SUCCEEDED(hr)) m_fStopped = TRUE;
    }
}
    
HRESULT CKeGrDest::Lock(PVOID *ppBuffer1, int *pcbBuffer1, PVOID *ppBuffer2, int *pcbBuffer2, int ibWrite, int cbWrite)
{
    LOCKCIRCULARBUFFER lcb;
    HRESULT            hr;
    
    lcb.pHwBuffer = m_pDrvBuf;
    lcb.pvBuffer = m_pBuffer;
    lcb.cbBuffer = m_cbBuffer;
    lcb.fPrimary = TRUE;
    lcb.fdwDriverDesc = m_fdwDriverDesc;
    lcb.ibRegion = ibWrite;
    lcb.cbRegion = cbWrite;

    hr = LockCircularBuffer(&lcb);

    if(SUCCEEDED(hr))
    {
        *ppBuffer1 = lcb.pvLock[0];
        *pcbBuffer1 = lcb.cbLock[0];

        if(ppBuffer2)
        {
            *ppBuffer2 = lcb.pvLock[1];
        }
        else
        {
            ASSERT(!lcb.pvLock[1]);
        }

        if(pcbBuffer2)
        {
            *pcbBuffer2 = lcb.cbLock[1];
        }
        else
        {
            ASSERT(!lcb.cbLock[1]);
        }
    }

    return hr;
}

HRESULT CKeGrDest::Unlock(PVOID pBuffer1, int cbBuffer1, PVOID pBuffer2, int cbBuffer2)
{
    LOCKCIRCULARBUFFER lcb;

    lcb.pHwBuffer = m_pDrvBuf;
    lcb.pvBuffer = m_pBuffer;
    lcb.cbBuffer = m_cbBuffer;
    lcb.fPrimary = TRUE;
    lcb.fdwDriverDesc = m_fdwDriverDesc;
    lcb.pvLock[0] = pBuffer1;
    lcb.cbLock[0] = cbBuffer1;
    lcb.pvLock[1] = pBuffer2;
    lcb.cbLock[1] = cbBuffer2;

    return UnlockCircularBuffer(&lcb);
}

HRESULT CKeGrDest::GetSamplePosition(int *pposPlay, int *pposWrite)
{
    HRESULT hr;
    DWORD dwPlay, dwWrite;

    ASSERT(pposPlay && pposWrite);
    
    hr = m_pDrvBuf->GetPosition(&dwPlay, &dwWrite);
    if (S_OK == hr) {

        *pposPlay = dwPlay >> m_nBlockAlignShift;
        *pposWrite = dwWrite >> m_nBlockAlignShift;

        // Until we write code to actually profile the performance, we'll just
        // pad the write position with a hard coded amount
        *pposWrite += m_nFrequency * HW_WRITE_CURSOR_MSEC_PAD / 1024;
        if (*pposWrite >= m_cSamples) *pposWrite -= m_cSamples;
        ASSERT(*pposWrite < m_cSamples);

    } else {
        *pposPlay = *pposWrite = 0;
    }

    return hr;
}

inline HRESULT CKeGrDest::GetSamplePositionNoWin16(int *pposPlay, int *pposWrite)
{
    return GetSamplePosition(pposPlay, pposWrite);
}

int ioctlMixer_Run(PDIOCPARAMETERS pdiocp)
{
    CMixer *pMixer;
    HRESULT hr;

    IOSTART(1*4);

    IOINPUT(pMixer, CMixer*);

    hr = pMixer->Run();

    IOOUTPUT(hr, HRESULT);
    IORETURN;
    return 0;
}

int ioctlMixer_Stop(PDIOCPARAMETERS pdiocp)
{
    BOOL f;
    CMixer *pMixer;

    IOSTART(1*4);

    IOINPUT(pMixer, CMixer*);

    f = pMixer->Stop();

    IOOUTPUT(f, BOOL);
    IORETURN;
    return 0;
}

int ioctlMixer_PlayWhenIdle(PDIOCPARAMETERS pdiocp)
{
    CMixer *pMixer;

    IOSTART(1*4);

    IOINPUT(pMixer, CMixer*);

    pMixer->PlayWhenIdle();

    IORETURN;
    return 0;
}

int ioctlMixer_StopWhenIdle(PDIOCPARAMETERS pdiocp)
{
    CMixer *pMixer;

    IOSTART(1*4);

    IOINPUT(pMixer, CMixer*);

    pMixer->StopWhenIdle();

    IORETURN;
    return 0;
}

int ioctlMixer_MixListAdd(PDIOCPARAMETERS pdiocp)
{
    CMixer *pMixer;
    CMixSource *pSource;

    IOSTART(2*4);

    IOINPUT(pMixer, CMixer*);
    IOINPUT(pSource, CMixSource*);

    pMixer->MixListAdd(pSource);

    IORETURN;
    return 0;
}

int ioctlMixer_MixListRemove(PDIOCPARAMETERS pdiocp)
{
    CMixer *pMixer;
    CMixSource *pSource;

    IOSTART(2*4);

    IOINPUT(pMixer, CMixer*);
    IOINPUT(pSource, CMixSource*);

    pMixer->MixListRemove(pSource);

    IORETURN;
    return 0;
}

int ioctlMixer_FilterOn(PDIOCPARAMETERS pdiocp)
{
    CMixer *pMixer;
    CMixSource *pSource;

    IOSTART(2*4);

    IOINPUT(pMixer, CMixer*);
    IOINPUT(pSource, CMixSource*);

    pMixer->FilterOn(pSource);

    IORETURN;
    return 0;
}

int ioctlMixer_FilterOff(PDIOCPARAMETERS pdiocp)
{
    CMixer *pMixer;
    CMixSource *pSource;

    IOSTART(2*4);

    IOINPUT(pMixer, CMixer*);
    IOINPUT(pSource, CMixSource*);

    pMixer->FilterOff(pSource);

    IORETURN;
    return 0;
}

int ioctlMixer_GetBytePosition(PDIOCPARAMETERS pdiocp)
{
    CMixer *pMixer;
    CMixSource *pSource;
    int *pibPlay;
    int *pibWrite;

    IOSTART(4*4);

    IOINPUT(pMixer, CMixer*);
    IOINPUT(pSource, CMixSource*);
    IOINPUT(pibPlay, int*);
    IOINPUT(pibWrite, int*);

    pMixer->GetBytePosition(pSource, pibPlay, pibWrite);

    IORETURN;
    return 0;
}

int ioctlMixer_SignalRemix(PDIOCPARAMETERS pdiocp)
{
    CMixer *pMixer;

    IOSTART(1*4);

    IOINPUT(pMixer, CMixer*);

    pMixer->SignalRemix();

    IORETURN;
    return 0;
}


int ioctlKeDest_New(PDIOCPARAMETERS pdiocp)
{
    LPNAGRDESTDATA pData;
    CKeGrDest *pKeGrDest;

    IOSTART(1*4);

    IOINPUT(pData, LPNAGRDESTDATA);
    
    pKeGrDest = new CKeGrDest(pData);

    IOOUTPUT(pKeGrDest, CKeGrDest*);
    IORETURN;
    return 0;
}

int ioctlMixDest_Delete(PDIOCPARAMETERS pdiocp)
{
    CMixDest *pMixDest;

    IOSTART(1*4);

    IOINPUT(pMixDest, CMixDest*);

    delete pMixDest;

    IORETURN;
    return 0;
}

int ioctlMixDest_Initialize(PDIOCPARAMETERS pdiocp)
{
    CMixDest *pMixDest;
    HRESULT hr;

    IOSTART(1*4);

    IOINPUT(pMixDest, CMixDest*);

    hr = pMixDest->Initialize();

    IOOUTPUT(hr, HRESULT);

    IORETURN;
    return 0;
}
    
int ioctlMixDest_Terminate(PDIOCPARAMETERS pdiocp)
{
    CMixDest *pMixDest;

    IOSTART(1*4);

    IOINPUT(pMixDest, CMixDest*);

    pMixDest->Terminate();

    IORETURN;
    return 0;
}
    
int ioctlMixDest_SetFormat(PDIOCPARAMETERS pdiocp)
{
    CMixDest *pMixDest;
    LPWAVEFORMATEX pwfx;
    HRESULT hr;

    IOSTART(2*4);

    IOINPUT(pMixDest, CMixDest*);
    IOINPUT(pwfx, LPWAVEFORMATEX);

    hr = pMixDest->SetFormat(pwfx);

    IOOUTPUT(hr, HRESULT);
    
    IORETURN;
    return 0;
}

int ioctlMixDest_SetFormatInfo(PDIOCPARAMETERS pdiocp)
{
    CMixDest *pMixDest;
    LPWAVEFORMATEX pwfx;

    IOSTART(2*4);

    IOINPUT(pMixDest, CMixDest*);
    IOINPUT(pwfx, LPWAVEFORMATEX);

    pMixDest->SetFormatInfo(pwfx);

    IORETURN;
    return 0;
}

int ioctlMixDest_AllocMixer(PDIOCPARAMETERS pdiocp)
{
    CMixDest *pMixDest;
    CMixer **ppMixer;
    HRESULT hr;

    IOSTART(2*4);

    IOINPUT(pMixDest, CMixDest*);
    IOINPUT(ppMixer, CMixer**);

    hr = pMixDest->AllocMixer(ppMixer);

    IOOUTPUT(hr, HRESULT);
    IORETURN;
    return 0;
}

int ioctlMixDest_FreeMixer(PDIOCPARAMETERS pdiocp)
{
    CMixDest *pMixDest;

    IOSTART(1*4);

    IOINPUT(pMixDest, CMixDest*);

    pMixDest->FreeMixer();

    IORETURN;
    return 0;
}

int ioctlMixDest_Play(PDIOCPARAMETERS pdiocp)
{
    CMixDest *pMixDest;

    IOSTART(1*4);

    IOINPUT(pMixDest, CMixDest*);

    pMixDest->Play();

    IORETURN;
    return 0;
}

int ioctlMixDest_Stop(PDIOCPARAMETERS pdiocp)
{
    CMixDest *pMixDest;

    IOSTART(1*4);

    IOINPUT(pMixDest, CMixDest*);

    pMixDest->Stop();

    IORETURN;
    return 0;
}

int ioctlMixDest_GetFrequency(PDIOCPARAMETERS pdiocp)
{
    CMixDest *pMixDest;
    int nFrequency;

    IOSTART(1*4);

    IOINPUT(pMixDest, CMixDest*);

    nFrequency = pMixDest->GetFrequency();

    IOOUTPUT(nFrequency, int);
    IORETURN;
    return 0;
}

int ioctlDsvxd_GetMixerMutexPtr(PDIOCPARAMETERS pdiocp)
{
    IOSTART(0*4);
    IOOUTPUT(&lMixerMutex, PLONG);
    IORETURN;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsvxd\dsvxd.cpp ===
//--------------------------------------------------------------------------;
//
//  File: dsvxd.c
//
//  Copyright (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  Contents:
//
//  History:
//      06/15/95	FrankYe
//
//--------------------------------------------------------------------------;
#define WANTVXDWRAPS

#define INITGUID
#include <windows.h>

extern "C" {
#include <vmm.h>
#include <vxdldr.h>
#include <vwin32.h>
#include <vxdwraps.h>
#include <configmg.h>
#include <verinfo.h>
}

#define NODSOUNDWRAPS
#include <mmsystem.h>
#include <dsound.h>
#include <dsdrvi.h>
#include "dsvxd.h"
#include "dsvxdi.h"

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

//--------------------------------------------------------------------------;
//
//  Why is there no wrapper for VMM's _lstrcmpi???  I'll make my own...
//
//--------------------------------------------------------------------------;

int VXDINLINE VMM_lstrcmpi(char *pString1, char *pString2)
{
    int iReturn;
    Touch_Register(eax);
    Touch_Register(ecx);
    Touch_Register(edx);
    _asm push pString1;
    _asm push pString2;
    VMMCall(_lstrcmpi);
    _asm add esp, 2*4;
    _asm mov iReturn, eax;
    return iReturn;
}

LPVOID VXDINLINE VMM_GetCurrentContext()
{
    LPVOID pCD;
    Touch_Register(eax);
    VMMCall(_GetCurrentContext);
    _asm mov pCD, eax;
    return pCD;
}

BOOL VXDINLINE VMM_PageAttach(ULONG pagesrc, LPVOID hcontextsrc, ULONG pagedst, ULONG cpages)
{
    int iReturn;
    Touch_Register(eax);
    Touch_Register(ecx);
    Touch_Register(edx);
    _asm push cpages;
    _asm push pagedst;
    _asm push hcontextsrc;
    _asm push pagesrc;
    VMMCall(_PageAttach);
    _asm add esp, 4*4;
    _asm mov iReturn, eax;
    return (0 != iReturn);
}

BOOL VXDINLINE VMM_PageFree(PVOID pPage, ULONG flags)
{
    return _PageFree(pPage, flags);
}

void VXDINLINE VMM_EnterMustComplete()
{
    Touch_Register(eax);
    Touch_Register(ecx);
    Touch_Register(edx);
    VMMCall(_EnterMustComplete);
    return;
}

void VXDINLINE VMM_LeaveMustComplete()
{
    Touch_Register(eax);
    Touch_Register(ecx);
    Touch_Register(edx);
    VMMCall(_LeaveMustComplete);
    return;
}

BOOL VXDINLINE VWIN32_CloseVxDHandle(DWORD vxdh)
{
    int iReturn;
    Touch_Register(ecx);
    Touch_Register(edx);
    _asm mov eax, vxdh;
    VxDCall(_VWIN32_CloseVxDHandle);
    _asm mov iReturn, eax;
    return (0 != iReturn);
}

/*
BOOL VXDINLINE VMM_PageLock(ULONG pagestrt, ULONG cpages, ULONG dwflags)
{
    int iReturn;
    Touch_Register(eax);
    Touch_Register(ecx);
    Touch_Register(edx);
    _asm push dwflags;
    _asm push cpages;
    _asm push pagestrt;
    VMMCall(_LinPageLock);
    _asm add esp, 3*4;
    _asm mov iReturn, eax;
    return (0 != iReturn);
}

BOOL VXDINLINE VMM_PageUnlock(ULONG pagestrt, ULONG cpages, ULONG dwflags)
{
    int iReturn;
    Touch_Register(eax);
    Touch_Register(ecx);
    Touch_Register(edx);
    _asm push dwflags;
    _asm push cpages;
    _asm push pagestrt;
    VMMCall(_LinPageUnlock);
    _asm add esp, 3*4;
    _asm mov iReturn, eax;
    return (0 != iReturn);
}
*/

//--------------------------------------------------------------------------;
//
//  Filescope data
//
//--------------------------------------------------------------------------;
static LPVOID gpGarbagePage = NULL;

//--------------------------------------------------------------------------;
//
// VxD Device control functions
//
//--------------------------------------------------------------------------;

int ctrlDynamicDeviceInit(void)
{
    DPF(("ctrlDynamicDeviceInit"));
    return ctrlDrvInit();
}

int ctrlDynamicDeviceExit(void)
{
    DPF(("ctrlDynamicDeviceExit"));
    return ctrlDrvExit();
}



#pragma VxD_PAGEABLE_CODE_SEG
#pragma VxD_PAGEABLE_DATA_SEG

//--------------------------------------------------------------------------;
//
// IOCTL handlers
//
//--------------------------------------------------------------------------;

int ioctlDsvxdInitialize(PDIOCPARAMETERS pdiocp)
{
    DSVAL dsv;
    
    IOSTART(0*4);

    //
    // The only thing we need to do is allocate one page of fixed
    // memory to which we will commit alias buffer pointers when
    // we don't want them to point at the real buffer anymore.
    //
    gpGarbagePage = _PageAllocate(1, PG_VM, Get_Sys_VM_Handle(), 0, 0, 0, 0, PAGEFIXED);
    if (NULL != gpGarbagePage) {
	dsv = DS_OK;
    } else {
	dsv = DSERR_OUTOFMEMORY;
    }

    IOOUTPUT(dsv, DSVAL);
    IORETURN;
    return 0;
}

int ioctlDsvxdShutdown(PDIOCPARAMETERS pdiocp)
{
    DSVAL dsv;
    
    IOSTART(0*4);

    if (NULL != gpGarbagePage) _PageFree(gpGarbagePage, 0);
    dsv = DS_OK;
    
    IOOUTPUT(dsv, DSVAL);
    IORETURN;
    return 0;
}


int ioctlDsvxd_PageFile_Get_Version(PDIOCPARAMETERS pdiocp)
{
    PDWORD pVersion;
    PDWORD pMaxSize;
    PDWORD pPagerType;

    IOSTART(3*4);

    IOINPUT(pVersion, PDWORD);
    IOINPUT(pMaxSize, PDWORD);
    IOINPUT(pPagerType, PDWORD);

    Dsvxd_PageFile_Get_Version(pVersion, pMaxSize, pPagerType);
    
    IORETURN;
    return 0;
}

int ioctlDsvxd_VMM_Test_Debug_Installed(PDIOCPARAMETERS pdiocp)
{
    BOOL fInstalled;

    IOSTART(0*4);

    fInstalled = Dsvxd_VMM_Test_Debug_Installed();

    IOOUTPUT(fInstalled, BOOL);
    
    IORETURN;
    return 0;
}

int ioctlDsvxd_VMCPD_Get_Version(PDIOCPARAMETERS pdiocp)
{
    PLONG pMajorVersion;
    PLONG pMinorVersion;
    PLONG pLevel;
    
    IOSTART(3*4);
    IOINPUT(pMajorVersion, PLONG);
    IOINPUT(pMinorVersion, PLONG);
    IOINPUT(pLevel, PLONG);

    Dsvxd_VMCPD_Get_Version(pMajorVersion, pMinorVersion, pLevel);

    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;

int ioctlDrvGetNextDescFromGuid(PDIOCPARAMETERS pdiocp)
{
    LPCGUID pGuidLast;
    LPGUID pGuid;
    PDSDRIVERDESC pDrvDesc;
    HRESULT hr;

    IOSTART(3*4);

    IOINPUT(pGuidLast, LPCGUID);
    IOINPUT(pGuid, LPGUID);
    IOINPUT(pDrvDesc, PDSDRIVERDESC);

    hr = CDrv::GetNextDescFromGuid(pGuidLast, pGuid, pDrvDesc);

    IOOUTPUT(hr, HRESULT);
    IORETURN;
    return 0;
}

int ioctlDrvGetDescFromGuid(PDIOCPARAMETERS pdiocp)
{
    LPCGUID pGuid;
    PDSDRIVERDESC pDrvDesc;
    DSVAL dsv;

    IOSTART(2*4);

    IOINPUT(pGuid, LPCGUID);
    IOINPUT(pDrvDesc, PDSDRIVERDESC);

    dsv = CDrv::GetDescFromGuid(*pGuid, pDrvDesc);

    IOOUTPUT(dsv, DSVAL);
    IORETURN;
    return 0;
}

int ioctlDrvOpenFromGuid(PDIOCPARAMETERS pdiocp)
{
    LPCGUID pGuid;
    IDsDriver **ppIDsDriver;
    HRESULT hr;

    IOSTART(2*4);

    IOINPUT(pGuid, LPCGUID);
    IOINPUT(ppIDsDriver, IDsDriver**);

    hr = CDrv::OpenFromGuid(*pGuid, ppIDsDriver);

    IOOUTPUT(hr, HRESULT);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
int ioctlIUnknown_QueryInterface(PDIOCPARAMETERS pdiocp)
{
    LPUNKNOWN pIUnknown;
    LPIID riid;
    PVOID *ppv;

    HRESULT hr;

    IOSTART(3*4);

    IOINPUT(pIUnknown, LPUNKNOWN);
    IOINPUT(riid, LPIID);
    IOINPUT(ppv, PVOID*);

    hr = pIUnknown->QueryInterface((REFIID)(*riid), ppv);

    IOOUTPUT(hr, HRESULT);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
int ioctlIUnknown_AddRef(PDIOCPARAMETERS pdiocp)
{
    LPUNKNOWN pIUnknown;
    ULONG result;

    IOSTART(1*4);

    IOINPUT(pIUnknown, LPUNKNOWN);

    result = pIUnknown->AddRef();

    IOOUTPUT(result, ULONG);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
int ioctlIUnknown_Release(PDIOCPARAMETERS pdiocp)
{
    LPUNKNOWN pIUnknown;
    ULONG result;

    IOSTART(1*4);

    IOINPUT(pIUnknown, LPUNKNOWN);

    result = pIUnknown->Release();

    IOOUTPUT(result, ULONG);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
//
// This should really be ioctlIUnknown_QueryInterface, if I would take the time
// to fix up the IOCTLs to DSVXD
//
int ioctlIDsDriver_QueryInterface(PDIOCPARAMETERS pdiocp)
{
    IDsDriver *pIDsDriver;
    const IID *piid;
    PVOID *ppv;
    HRESULT hr;

    IOSTART(3*4);

    IOINPUT(pIDsDriver, IDsDriver*);
    IOINPUT(piid, const IID *);
    IOINPUT(ppv,  PVOID*);

    hr = pIDsDriver->QueryInterface((REFIID)(*piid), ppv);

    IOOUTPUT(hr, HRESULT);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;

int ioctlIDsDriver_Close(PDIOCPARAMETERS pdiocp)
{
    IDsDriver *pIDsDriver;
    HRESULT hr;
	   
    IOSTART(1*4);
    
    IOINPUT(pIDsDriver, IDsDriver*);

    hr = pIDsDriver->Close();
    
    IOOUTPUT(hr, HRESULT);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;

int ioctlIDsDriver_GetCaps(PDIOCPARAMETERS pdiocp)
{
    IDsDriver *pIDsDriver;
    PDSDRIVERCAPS pDrvCaps;
    HRESULT hr;
    
    IOSTART(2*4);

    IOINPUT(pIDsDriver, IDsDriver*);
    IOINPUT(pDrvCaps, PDSDRIVERCAPS);

    hr = pIDsDriver->GetCaps(pDrvCaps);

    IOOUTPUT(hr, HRESULT);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;

int ioctlIDsDriver_CreateSoundBuffer(PDIOCPARAMETERS pdiocp)
{
    IDsDriver *pIDsDriver;
    LPWAVEFORMATEX pwfx;
    DWORD dwFlags;
    DWORD dwCardAddress;
    LPDWORD pdwcbBufferSize;
    LPBYTE *ppBuffer;
    PVOID *ppvObj;
    HRESULT hr;
    
    IOSTART(7*4);

    IOINPUT(pIDsDriver, IDsDriver*);
    IOINPUT(pwfx, LPWAVEFORMATEX);
    IOINPUT(dwFlags, DWORD);
    IOINPUT(dwCardAddress, DWORD);
    IOINPUT(pdwcbBufferSize, LPDWORD);
    IOINPUT(ppBuffer, LPBYTE*);
    IOINPUT(ppvObj, PVOID*);

    hr = pIDsDriver->CreateSoundBuffer(pwfx, dwFlags, dwCardAddress,
				       pdwcbBufferSize, ppBuffer, ppvObj);

    IOOUTPUT(hr, HRESULT);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;

int ioctlIDsDriver_DuplicateSoundBuffer(PDIOCPARAMETERS pdiocp)
{
    IDsDriver *pIDsDriver;
    IDsDriverBuffer *pIDsDriverBuffer;
    PVOID *ppv;
    HRESULT hr;
    
    IOSTART(3*4);

    IOINPUT(pIDsDriver, IDsDriver*);
    IOINPUT(pIDsDriverBuffer, IDsDriverBuffer*);
    IOINPUT(ppv, PVOID*);

    hr = pIDsDriver->DuplicateSoundBuffer(pIDsDriverBuffer, ppv);

    IOOUTPUT(hr, HRESULT);
    IORETURN;
    return 0;
}





//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;


//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;

int ioctlBufferRelease(PDIOCPARAMETERS pdiocp)
{
    PIDSDRIVERBUFFER pBuf;
    DSVAL dsv;
    
    IOSTART(1*4);

    IOINPUT(pBuf, PIDSDRIVERBUFFER);

    dsv = pBuf->Release();

    IOOUTPUT(dsv, DSVAL);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;

int ioctlBufferLock(PDIOCPARAMETERS pdiocp)
{
    PIDSDRIVERBUFFER pBuf;
    LPVOID * ppvAudio1;
    LPDWORD pdwLen1;
    LPVOID * ppvAudio2;
    LPDWORD pdwLen2;
    DWORD dwWritePosition;
    DWORD dwWriteBytes;
    DWORD dwFlags;
    DSVAL dsv;
    
    IOSTART(8*4);

    IOINPUT(pBuf, PIDSDRIVERBUFFER);
    IOINPUT(ppvAudio1, LPVOID *);
    IOINPUT(pdwLen1, LPDWORD);
    IOINPUT(ppvAudio2, LPVOID *);
    IOINPUT(pdwLen2, LPDWORD);
    IOINPUT(dwWritePosition, DWORD);
    IOINPUT(dwWriteBytes, DWORD);
    IOINPUT(dwFlags, DWORD);

    dsv = pBuf->Lock( ppvAudio1,
		      pdwLen1,
		      ppvAudio2,
		      pdwLen2,
		      dwWritePosition,
		      dwWriteBytes,
		      dwFlags );

    IOOUTPUT(dsv, DSVAL);
    IORETURN;
    return 0;
}

int ioctlBufferUnlock(PDIOCPARAMETERS pdiocp)
{
    PIDSDRIVERBUFFER pBuf;
    PVOID pvAudio1;
    DWORD dwLen1;
    PVOID pvAudio2;
    DWORD dwLen2;
    DSVAL dsv;
    
    IOSTART(5*4);

    IOINPUT(pBuf, PIDSDRIVERBUFFER);
    IOINPUT(pvAudio1, PVOID);
    IOINPUT(dwLen1, DWORD);
    IOINPUT(pvAudio2, PVOID);
    IOINPUT(dwLen2, DWORD);

    dsv = pBuf->Unlock( pvAudio1,
			dwLen1,
			pvAudio2,
			dwLen2 );

    IOOUTPUT(dsv, DSVAL);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;

int ioctlBufferSetFormat(PDIOCPARAMETERS pdiocp)
{
    PIDSDRIVERBUFFER pBuf;
    LPWAVEFORMATEX pwfxToSet;
    DSVAL dsv;
    
    IOSTART(2*4);

    IOINPUT(pBuf, PIDSDRIVERBUFFER);
    IOINPUT(pwfxToSet, LPWAVEFORMATEX);

    dsv = pBuf->SetFormat(pwfxToSet);

    IOOUTPUT(dsv, DSVAL);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;

int ioctlBufferSetFrequency(PDIOCPARAMETERS pdiocp)
{
    PIDSDRIVERBUFFER pBuf;
    DWORD dwFrequency;
    DSVAL dsv;
    
    IOSTART(2*4);

    IOINPUT(pBuf, PIDSDRIVERBUFFER);
    IOINPUT(dwFrequency, DWORD);

    dsv = pBuf->SetFrequency(dwFrequency);

    IOOUTPUT(dsv, DSVAL);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;

int ioctlBufferSetVolumePan(PDIOCPARAMETERS pdiocp)
{
    PIDSDRIVERBUFFER pBuf;
    PDSVOLUMEPAN pVolPan;
    DSVAL dsv;
    
    IOSTART(2*4);

    IOINPUT(pBuf, PIDSDRIVERBUFFER);
    IOINPUT(pVolPan, PDSVOLUMEPAN);

    dsv = pBuf->SetVolumePan(pVolPan);

    IOOUTPUT(dsv, DSVAL);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;

int ioctlBufferSetPosition(PDIOCPARAMETERS pdiocp)
{
    PIDSDRIVERBUFFER pBuf;
    DWORD dwNewPosition;
    DSVAL dsv;
    
    IOSTART(2*4);

    IOINPUT(pBuf, PIDSDRIVERBUFFER);
    IOINPUT(dwNewPosition, DWORD);

    dsv = pBuf->SetPosition(dwNewPosition);

    IOOUTPUT(dsv, DSVAL);
    IORETURN;
    return 0;
}

int ioctlBufferGetPosition(PDIOCPARAMETERS pdiocp)
{
    PIDSDRIVERBUFFER pBuf;
    LPDWORD lpdwCurrentPlayCursor;
    LPDWORD lpdwCurrentWriteCursor;
    DSVAL dsv;
    
    IOSTART(3*4);

    IOINPUT(pBuf, PIDSDRIVERBUFFER);
    IOINPUT(lpdwCurrentPlayCursor, LPDWORD);
    IOINPUT(lpdwCurrentWriteCursor, LPDWORD);

    dsv = pBuf->GetPosition( lpdwCurrentPlayCursor,
			     lpdwCurrentWriteCursor );

    IOOUTPUT(dsv, DSVAL);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;

int ioctlBufferPlay(PDIOCPARAMETERS pdiocp)
{
    PIDSDRIVERBUFFER pBuf;
    DWORD dwReserved1;
    DWORD dwReserved2;
    DWORD dwFlags;
    DSVAL dsv;
    
    IOSTART(4*4);

    IOINPUT(pBuf, PIDSDRIVERBUFFER);
    IOINPUT(dwReserved1, DWORD);
    IOINPUT(dwReserved2, DWORD);
    IOINPUT(dwFlags, DWORD);

    dsv = pBuf->Play(dwReserved1, dwReserved2, dwFlags);

    IOOUTPUT(dsv, DSVAL);
    IORETURN;
    return 0;
}

int ioctlBufferStop(PDIOCPARAMETERS pdiocp)
{
    PIDSDRIVERBUFFER pBuf;
    DSVAL dsv;
    
    IOSTART(1*4);

    IOINPUT(pBuf, PIDSDRIVERBUFFER);

    dsv = pBuf->Stop();

    IOOUTPUT(dsv, DSVAL);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
int ioctlIDirectSoundPropertySet_GetProperty(PDIOCPARAMETERS pdiocp)
{
    PIDSDRIVERPROPERTYSET pIDsPropertySet;
    PDSPROPERTY pProperty;
    PVOID pParams;
    ULONG cbParams;
    PVOID pData;
    ULONG cbData;
    PULONG pcbReturnedData;
    HRESULT hr;

    IOSTART(7*4);

    IOINPUT(pIDsPropertySet, PIDSDRIVERPROPERTYSET);
    IOINPUT(pProperty, PDSPROPERTY);
    IOINPUT(pParams, PVOID);
    IOINPUT(cbParams, ULONG);
    IOINPUT(pData, PVOID);
    IOINPUT(cbData, ULONG);
    IOINPUT(pcbReturnedData, PULONG);

    hr = pIDsPropertySet->Get(pProperty, pParams, cbParams, pData, cbData, pcbReturnedData);

    IOOUTPUT(hr, HRESULT);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
int ioctlIDirectSoundPropertySet_SetProperty(PDIOCPARAMETERS pdiocp)
{
    PIDSDRIVERPROPERTYSET pIDsPropertySet;
    PDSPROPERTY pProperty;
    PVOID pParams;
    ULONG cbParams;
    PVOID pData;
    ULONG cbData;
    HRESULT hr;

    IOSTART(6*4);

    IOINPUT(pIDsPropertySet, PIDSDRIVERPROPERTYSET);
    IOINPUT(pProperty, PDSPROPERTY);
    IOINPUT(pParams, PVOID);
    IOINPUT(cbParams, ULONG);
    IOINPUT(pData, PVOID);
    IOINPUT(cbData, ULONG);

    hr = pIDsPropertySet->Set(pProperty, pParams, cbParams, pData, cbData);

    IOOUTPUT(hr, HRESULT);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
int ioctlIDirectSoundPropertySet_QuerySupport(PDIOCPARAMETERS pdiocp)
{
    PIDSDRIVERPROPERTYSET pIDsPropertySet;
    LPGUID rPropSetId;
    ULONG ulPropertyId;
    PULONG pulSupport;
    HRESULT hr;

    IOSTART(4*4);

    IOINPUT(pIDsPropertySet, PIDSDRIVERPROPERTYSET);
    IOINPUT(rPropSetId, LPGUID);
    IOINPUT(ulPropertyId, ULONG);
    IOINPUT(pulSupport, PULONG);

    hr = pIDsPropertySet->QuerySupport((REFGUID)(*rPropSetId), ulPropertyId, pulSupport);

    IOOUTPUT(hr, HRESULT);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
int ioctlEventScheduleWin32Event(PDIOCPARAMETERS pdiocp)
{
    DWORD vxdhEvent;
    DWORD dwDelay;
    BOOL fReturn;
    
    IOSTART(2*4);

    IOINPUT(vxdhEvent, DWORD);
    IOINPUT(dwDelay, DWORD);

    fReturn = eventScheduleWin32Event(vxdhEvent, dwDelay);
    // REMIND should implement something to cancel outstanding timeouts
    // and events when we shutdown.

    IOOUTPUT(fReturn, BOOL);
    IORETURN;
    return 0;
}

int ioctlEventCloseVxDHandle(PDIOCPARAMETERS pdiocp)
{
    DWORD vxdh;
    BOOL fReturn;
    
    IOSTART(1*4);

    IOINPUT(vxdh, DWORD);

    fReturn = VWIN32_CloseVxDHandle(vxdh);

    IOOUTPUT(fReturn, BOOL);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
// ioctlMemReserveAlias
//
//	Given a ptr to a buffer and length, this function will reserve linear
// address space to be used as an alias ptr to the same buffer.  The reserved
// linear space does not have the buffer memory committed to it.  That is done
// by ioctlMemCommitAlias.
//
//--------------------------------------------------------------------------;
int ioctlMemReserveAlias(PDIOCPARAMETERS pdiocp)
{
    LPBYTE	pBuffer;
    DWORD	cbBuffer;
    LPBYTE	pAlias;

    LPBYTE	pBufferAligned;
    DWORD	cbBufferAligned;
    int		cPages;
    LPBYTE	pAliasAligned;
    
    IOSTART(2*4);

    IOINPUT(pBuffer, LPBYTE);
    IOINPUT(cbBuffer, DWORD);

    DPF(("ioctlMemReserveAlias pBuffer=%08Xh cbBuffer=%d", pBuffer, cbBuffer));

    pBufferAligned = (LPBYTE)(((DWORD)pBuffer) & ~(P_SIZE-1));
    cPages = (pBuffer+cbBuffer - pBufferAligned+ P_SIZE-1) / P_SIZE;
    cbBufferAligned = cPages * P_SIZE;

    DPF((" pBufferAligned=%08Xh cPages=%d cbBufferAligned=%d",
	 pBufferAligned, cPages, cbBufferAligned));
    
    //
    // Reserve linear address space
    //
    pAliasAligned = (LPBYTE)_PageReserve(PR_SHARED, cPages, PR_FIXED);

    if (((LPBYTE)(-1) == pAliasAligned) || (NULL == pAliasAligned)) {
	pAlias = NULL;
    } else {
	pAlias = pAliasAligned + (pBuffer - pBufferAligned);
    }

    DPF((" pAliasAligned=%08Xh pAlias=%08Xh", pAliasAligned, pAlias));
    
    IOOUTPUT(pAlias, LPBYTE);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
int ioctlMemCommitAlias(PDIOCPARAMETERS pdiocp)
{
    LPBYTE	pAlias;
    LPBYTE	pBuffer;
    DWORD	cbBuffer;
    BOOL	fSuccess;

    LPBYTE	pBufferAligned;
    LPBYTE	pAliasAligned;
    ULONG	nPageBuffer;
    ULONG	nPageAlias;
    int		cPages;
    
    IOSTART(3*4);

    IOINPUT(pAlias, LPBYTE);
    IOINPUT(pBuffer, LPBYTE);
    IOINPUT(cbBuffer, DWORD);

    // DPF(("ioctlMemCommitAlias pBuffer=%08Xh cbBuffer=%d pAlias=%08Xh",
    //      pBuffer, cbBuffer, pAlias));
    
    pBufferAligned = (LPBYTE)(((DWORD)pBuffer) & ~(P_SIZE-1));
    pAliasAligned  = (LPBYTE)(((DWORD)pAlias) & ~(P_SIZE-1));
    cPages = (pBuffer+cbBuffer - pBufferAligned+ P_SIZE-1) / P_SIZE;

    nPageBuffer = ((ULONG)pBufferAligned) / P_SIZE;
    nPageAlias = ((ULONG)pAliasAligned) / P_SIZE;

    // DPF((" pBufferAligned=%08Xh pAliasAligned=%08Xh cPages=%d",
    //      pBufferAligned, pAliasAligned, cPages));

    fSuccess = VMM_PageAttach(nPageBuffer, VMM_GetCurrentContext(),
			      nPageAlias, cPages);
    
    IOOUTPUT(fSuccess, BOOL);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
int ioctlMemDecommitAlias(PDIOCPARAMETERS pdiocp)
{
    LPBYTE	pAlias;
    DWORD	cbBuffer;
    BOOL	fSuccess;

    int		cPages;
    LPBYTE	pAliasAligned;
    
    LPBYTE	pPageAlias;
    ULONG	nPageAlias;
    
    IOSTART(2*4);

    IOINPUT(pAlias, LPBYTE);
    IOINPUT(cbBuffer, DWORD);

    // DPF(("iocltMemDecommitAlias pAlias=%08Xh", pAlias));
    
    pAliasAligned  = (LPBYTE)(((DWORD)pAlias) & ~(P_SIZE-1));
    cPages = (pAlias + cbBuffer - pAliasAligned+ P_SIZE-1) / P_SIZE;

    pPageAlias = pAliasAligned;
    nPageAlias = ((ULONG)pPageAlias) / P_SIZE;

    // DPF((" nPageAlias=%08Xh nPages=%d", nPageAlias, cPages));
    
    fSuccess = (0 != _PageDecommit(nPageAlias, cPages, 0));
    ASSERT(fSuccess);
    
    IOOUTPUT(fSuccess, BOOL);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
int ioctlMemRedirectAlias(PDIOCPARAMETERS pdiocp)
{
    LPBYTE	pAlias;
    DWORD	cbBuffer;
    BOOL	fSuccess;

    LPBYTE	pAliasAligned;
    ULONG	nPageAlias;
    ULONG       nPageGarbage;
    int		cPages;
    
    IOSTART(2*4);

    IOINPUT(pAlias, LPBYTE);
    IOINPUT(cbBuffer, DWORD);

    DPF(("ioctlMemRedirectAlias pAlias=%08Xh cbBuffer=%d", pAlias, cbBuffer));
    
    pAliasAligned  = (LPBYTE)(((DWORD)pAlias) & ~(P_SIZE-1));
    cPages = (pAlias+cbBuffer - pAliasAligned + P_SIZE-1) / P_SIZE;

    nPageAlias = ((ULONG)pAliasAligned) / P_SIZE;
    nPageGarbage = ((ULONG)gpGarbagePage) / P_SIZE;

    // DPF((" pAliasAligned=%08Xh cPages=%d pGarbagePage=%08Xh",
    //      pAliasAligned, cPages, gpGarbagePage));

    // We point every alias page at the same garbage page.  This is
    // MustComplete since the app's thread that is using the alias
    // pointer might not be this current thread and may be writing
    // thru the alias pointer.  We wouldn't want the app's thread to
    // run while the alias pages are decommitted.
    VMM_EnterMustComplete();
    fSuccess = (0 != _PageDecommit(nPageAlias, cPages, 0));
    while (fSuccess && cPages--) {
	fSuccess = VMM_PageAttach(nPageGarbage, VMM_GetCurrentContext(),
				  nPageAlias++, 1);
    }
    VMM_LeaveMustComplete();

    IOOUTPUT(fSuccess, BOOL);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
int ioctlMemFreeAlias(PDIOCPARAMETERS pdiocp)
{
    LPBYTE	pAlias;
    DWORD	cbBuffer;
    BOOL	fSuccess;

    LPBYTE	pAliasAligned;
    LPBYTE	pPageAlias;
    
    IOSTART(2*4);

    IOINPUT(pAlias, LPBYTE);
    IOINPUT(cbBuffer, DWORD);

    DPF(("iocltMemFreeAlias pAlias=%08Xh", pAlias));
    
    pAliasAligned  = (LPBYTE)(((DWORD)pAlias) & ~(P_SIZE-1));

    pPageAlias = pAliasAligned;

    DPF((" pPageAlias=%08Xh", pPageAlias));
    
    fSuccess = VMM_PageFree(pPageAlias, 0);
    ASSERT(fSuccess);
    
    IOOUTPUT(fSuccess, BOOL);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
int ioctlMemPageLock(PDIOCPARAMETERS pdiocp)
{
    LPBYTE	pMem;
    DWORD	cbBuffer;
    DWORD	dwFlags;
    BOOL	fSuccess;

    LPBYTE	pMemAligned;
    ULONG	nPageMem;
    int		cPages;
    LPDWORD	pdwTable;
    LPVOID	*ppTable;
    DWORD	cPagesTable;

    IOSTART(5*4);

    IOINPUT(pMem, LPBYTE);
    IOINPUT(cbBuffer, DWORD);
    IOINPUT(dwFlags, DWORD);
    IOINPUT(pdwTable, LPDWORD);
    IOINPUT(ppTable, LPVOID*);

    pMemAligned = (LPBYTE)(((DWORD)pMem) & ~(P_SIZE-1));
    cPages = (pMem+cbBuffer - pMemAligned+ P_SIZE-1) / P_SIZE;

    nPageMem = ((ULONG)pMemAligned) / P_SIZE;

    // Allocate the physical table
    cPagesTable = (cPages-1)/1024 + 1;
    *pdwTable = 0;

    // Make sure that it is contiguous (requires FIXED & USEALIGN)
    *ppTable = _PageAllocate(cPagesTable, PG_SYS, 
	    Get_Sys_VM_Handle(), 0, 0, 0xffffff, (LPVOID *) pdwTable, 
            dwFlags | PAGEUSEALIGN | PAGEFIXED | PAGECONTIG);

    if (*pdwTable == 0)
	fSuccess = 0;
    else
	fSuccess = 1;

    if (fSuccess)
    {
        /*
         * Mask off the stuff that Intel gives us in the page table's physical address
         */
        *pdwTable = (*pdwTable) & 0xfffff000;

	fSuccess = _LinPageLock(nPageMem, cPages, dwFlags);
	if (!fSuccess)
	{
	    _PageFree((LPVOID)*ppTable, 0);
	    *ppTable = 0;
	    *pdwTable = 0;
	}
    }
    
    if (fSuccess)
    {
	fSuccess = _CopyPageTable(nPageMem, cPages, (LPDWORD)*ppTable, 0);
	if (!fSuccess)
	{
	    _LinPageUnLock(nPageMem, cPages, dwFlags);
	    _PageFree((LPVOID)*ppTable, 0);
	    *ppTable = 0;
	    *pdwTable = 0;
	}
    }
    
    IOOUTPUT(fSuccess, BOOL);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
int ioctlMemPageUnlock(PDIOCPARAMETERS pdiocp)
{
    LPBYTE	pMem;
    DWORD	cbBuffer;
    DWORD	dwFlags;
    BOOL	fSuccess;

    LPBYTE	pMemAligned;
    ULONG	nPageMem;
    int		cPages;
    LPDWORD	pTable;
    
    IOSTART(4*4);

    IOINPUT(pMem, LPBYTE);
    IOINPUT(cbBuffer, DWORD);
    IOINPUT(dwFlags, DWORD);
    IOINPUT(pTable, LPDWORD);

    pMemAligned = (LPBYTE)(((DWORD)pMem) & ~(P_SIZE-1));
    cPages = (pMem + cbBuffer - pMemAligned + P_SIZE-1) / P_SIZE;

    nPageMem = ((ULONG)pMemAligned) / P_SIZE;

    fSuccess = _LinPageUnLock(nPageMem, cPages, dwFlags);

    if (fSuccess)
    {
	_PageFree((LPVOID)pTable, 0);
    }
    IOOUTPUT(fSuccess, BOOL);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
int ioctlMemCommitPhysAlias(PDIOCPARAMETERS pdiocp)
{
    LPBYTE	pAlias;
    LPBYTE	pBuffer;
    DWORD	cbBuffer;
    BOOL	fSuccess;

    LPBYTE	pBufferAligned;
    LPBYTE	pAliasAligned;
    LPBYTE      pEndOfBuffer;
    ULONG	nPageBuffer;
    ULONG	nPageAlias;
    ULONG       nPhysPage;
    int		cPages;
    DWORD       dwPTE;
    
    IOSTART(3*4);

    IOINPUT(pAlias, LPBYTE);
    IOINPUT(pBuffer, LPBYTE);
    IOINPUT(cbBuffer, DWORD);

    DPF(("ioctlMemCommitAlias pBuffer=%08Xh cbBuffer=%d pAlias=%08Xh",
         pBuffer, cbBuffer, pAlias));
    
    pEndOfBuffer = pBuffer + cbBuffer;
    pBufferAligned = (LPBYTE)(((DWORD)pBuffer) & ~(P_SIZE-1));
    pAliasAligned  = (LPBYTE)(((DWORD)pAlias) & ~(P_SIZE-1));
    cPages = (pEndOfBuffer - pBufferAligned + P_SIZE-1) / P_SIZE;

    nPageBuffer = ((ULONG)pBufferAligned) / P_SIZE;
    nPageAlias = ((ULONG)pAliasAligned) / P_SIZE;

    DPF((" pBufferAligned=%08Xh pAliasAligned=%08Xh cPages=%d",
         pBufferAligned, pAliasAligned, cPages));


    // ALERT: A really very nasty hack. We DO NOT want to commit the alias
    // to the given memory if the memory really is system rather than video
    // memory (the pages could change the physical pages and we will be left
    // pointing at garbage). Therefore, we need to make sure this is physical
    // memory outside the memory managers control and not system memory. The
    // problem is how to do this. Well, we really want to test the internal
    // memory manage PT_PHYS bit but this is undocumented so instead I try
    // to simply use VMM_PageAttach() as we know this will fail if you give it
    // physical pages. Hence if the PageAttach() works we have system memory
    // and we do NOT want to commit the alias. However, if it fails all should
    // be well and we can commit the memory.
    //
    // Told you it was ugly (CMcC)
    fSuccess = VMM_PageAttach(nPageBuffer, VMM_GetCurrentContext(),
			      nPageAlias, cPages);
    if (fSuccess)
    {
	DPF((" Heap memory is system memory. Not commiting the alias" ));
	_PageDecommit(nPageAlias, cPages, 0);
	IOOUTPUT(FALSE, BOOL);
	IORETURN;
	return 0;
    }

    VMM_EnterMustComplete();
    fSuccess = TRUE;
    while (fSuccess && cPages--) {
	fSuccess = _CopyPageTable(nPageBuffer++, 1UL, &dwPTE, 0UL);
	if (fSuccess) {
	    nPhysPage = (dwPTE >> 12UL) & 0x000FFFFF;
	    fSuccess = _PageCommitPhys(nPageAlias++, 1, nPhysPage, PC_USER | PC_WRITEABLE);
	}
    }
    VMM_LeaveMustComplete();
    
    IOOUTPUT(fSuccess, BOOL);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
int ioctlMemRedirectPhysAlias(PDIOCPARAMETERS pdiocp)
{
    LPBYTE	pAlias;
    DWORD	cbBuffer;
    BOOL	fSuccess;

    LPBYTE	pAliasAligned;
    ULONG	nPageAlias;
    ULONG       nPageGarbage;
    int		cPages;
    
    IOSTART(2*4);

    IOINPUT(pAlias, LPBYTE);
    IOINPUT(cbBuffer, DWORD);

    DPF(("ioctlMemRedirectPhysAlias pAlias=%08Xh cbBuffer=%d", pAlias, cbBuffer));
    
    pAliasAligned  = (LPBYTE)(((DWORD)pAlias) & ~(P_SIZE-1));
    cPages = (pAlias+cbBuffer - pAliasAligned + P_SIZE-1) / P_SIZE;

    nPageAlias = ((ULONG)pAliasAligned) / P_SIZE;
    nPageGarbage = (ULONG)_GetNulPageHandle();

    // DPF((" pAliasAligned=%08Xh cPages=%d pGarbagePage=%08Xh",
    //      pAliasAligned, cPages, gpGarbagePage));

    // We point every alias page at the same garbage page.  This is
    // MustComplete since the app's thread that is using the alias
    // pointer might not be this current thread and may be writing
    // thru the alias pointer.  We wouldn't want the app's thread to
    // run while the alias pages are decommitted.
    VMM_EnterMustComplete();
    fSuccess = (0 != _PageDecommit(nPageAlias, cPages, 0));
    if (fSuccess)
	fSuccess = _PageCommitPhys(nPageAlias, cPages, nPageGarbage, PC_USER | PC_WRITEABLE);
    VMM_LeaveMustComplete();

    IOOUTPUT(fSuccess, BOOL);
    IORETURN;
    return 0;
}

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;
int ioctlGetInternalVersionNumber(PDIOCPARAMETERS pdiocp)
{

#ifndef VER_PRODUCTVERSION_DW
#define VER_PRODUCTVERSION_DW MAKELONG(MAKEWORD(MANVERSION, MANREVISION), MAKEWORD(MANMINORREV, BUILD_NUMBER))
#endif // VER_PRODUCTVERSION_DW

    IOSTART(0*4);
    IOOUTPUT(VER_PRODUCTVERSION_DW, DWORD);
    IORETURN;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsvxd\dsvxdi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsvxdi.h
 *  Content:    dsound.vxd private include file
 *
 **************************************************************************/

#ifndef __DSVXDI_INCLUDED__
#define __DSVXDI_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

extern VMMLIST gvmmlistDrivers;

//
//
//
typedef const GUID* LPCGUID;
typedef HRESULT DSVAL;

#ifdef __cplusplus

//
//
//
class CBuf_IDsDriverPropertySet : public IDsDriverPropertySet
{
    private:
    int                     m_cRef;
    class CBuf              *m_pBuf;

    public:
    // constructor
    CBuf_IDsDriverPropertySet(class CBuf* pBuf);

    // IUnknown members
    STDMETHODIMP            QueryInterface(REFIID, PVOID*);
    STDMETHODIMP_(ULONG)    AddRef(void);
    STDMETHODIMP_(ULONG)    Release(void);

    // IDsDriverPropertySet members
    STDMETHODIMP Get(PDSPROPERTY pDsProperty,
                     PVOID pPropertyParams, ULONG cbPropertyParams,
                     PVOID pPropertyData, ULONG cbPropertyData,
                     PULONG pcbReturnedData);
    STDMETHODIMP Set(PDSPROPERTY pDsProperty,
                     PVOID pPropertyParams, ULONG cbPropertyParams,
                     PVOID pPropertyData, ULONG cbPropertyData);
    STDMETHODIMP QuerySupport(REFGUID PropertySetId, ULONG PropertyId,
                              PULONG pSupport);
};

//
//
//
class CBuf : public IDsDriverBuffer
{
    private:
    int                     m_cRef;
    class CDrv              *m_pDrv;
    BOOL                    m_fDeregistered;

    IDsDriverBuffer         *m_pIDsDriverBuffer_Real;
    IDsDriverPropertySet    *m_pIDsDriverPropertySet_Real;

    // contained interface implementations
    CBuf_IDsDriverPropertySet m_IDsDriverPropertySet;

    friend CBuf_IDsDriverPropertySet;

    public:
    // new/delete operators
    void* operator new(size_t size, VMMLIST list);
    void operator delete(void * pv, size_t size);

    // constructor
    CBuf(void);

    // class methods
    static VMMLIST          CreateList(void);
    static void             DestroyList(VMMLIST list);
    static HRESULT          CreateBuf(CDrv *pDrv, VMMLIST list, IDsDriverBuffer *pIDsDriverBuffer_Real, IDsDriverBuffer **ppIDsDriverBuffer);
    static void             DeregisterBuffers(VMMLIST list);

    // IUnknown members
    STDMETHODIMP            QueryInterface(REFIID, PVOID*);
    STDMETHODIMP_(ULONG)    AddRef(void);
    STDMETHODIMP_(ULONG)    Release(void);

    // IDsDriverBuffer members
    STDMETHODIMP        Lock(LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD, DWORD, DWORD);
    STDMETHODIMP        Unlock(LPVOID, DWORD, LPVOID, DWORD);
    STDMETHODIMP        SetFormat(LPWAVEFORMATEX);
    STDMETHODIMP        SetFrequency(DWORD);
    STDMETHODIMP        SetVolumePan(PDSVOLUMEPAN);
    STDMETHODIMP        SetPosition(DWORD);
    STDMETHODIMP        GetPosition(LPDWORD, LPDWORD);
    STDMETHODIMP        Play(DWORD, DWORD, DWORD);
    STDMETHODIMP        Stop(void);

    // Other members
    STDMETHODIMP_(BOOL)    IsDeregistered(void);
    STDMETHODIMP_(IDsDriverBuffer*) GetRealDsDriverBuffer(void);
};

//
//
//
class CDrv : public IDsDriver
{
    private:
    int                 m_cRef;
    int                 m_cOpen;
    BOOL                m_fDeregistered;
    IDsDriver           *m_pIDsDriver_Real;
    GUID                m_guidDriver;
    VMMLIST             m_listBuffers;

    static CDrv*        FindFromIDsDriver(IDsDriver *pIDsDriver);
    static CDrv*        FindFromGuid(REFGUID riid);

    public:
    // Class methods
    static HRESULT      CreateAndRegisterDriver(IDsDriver *pIDsDriver);
    static HRESULT      DeregisterDriver(IDsDriver *pIDsDriver);
    static HRESULT      GetDescFromGuid(REFGUID rguidDriver, PDSDRIVERDESC pDrvDesc);
    static HRESULT      GetNextDescFromGuid(LPCGUID pguidLast, LPGUID pGuid, PDSDRIVERDESC pDrvDesc);
    static HRESULT      OpenFromGuid(REFGUID rguidDriver, IDsDriver **ppIDsDriver);

    // new/delete operators
    void* operator new(size_t size);
    void operator delete(void * pv);

    // IUnknown members
    STDMETHODIMP        QueryInterface(REFIID, PVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);


    // IDsDriver members
    STDMETHODIMP        GetDriverDesc(PDSDRIVERDESC);
    STDMETHODIMP        Open(void);
    STDMETHODIMP        Close(void);
    STDMETHODIMP        GetCaps(PDSDRIVERCAPS);
    STDMETHODIMP        CreateSoundBuffer(LPWAVEFORMATEX, DWORD, DWORD, LPDWORD, LPBYTE *, LPVOID *);
    STDMETHODIMP        DuplicateSoundBuffer(PIDSDRIVERBUFFER, LPVOID *);
};
#endif

//
//
//
int ctrlDrvInit();
int ctrlDrvExit();

int eventScheduleWin32Event(DWORD vxdh, DWORD dwDelay);

int ioctlDsvxd_GetMixerMutexPtr(PDIOCPARAMETERS pdiocp);

int ioctlMixer_Run(PDIOCPARAMETERS pdiocp);
int ioctlMixer_Stop(PDIOCPARAMETERS pdiocp);
int ioctlMixer_PlayWhenIdle(PDIOCPARAMETERS pdiocp);
int ioctlMixer_StopWhenIdle(PDIOCPARAMETERS pdiocp);
int ioctlMixer_MixListAdd(PDIOCPARAMETERS pdiocp);
int ioctlMixer_MixListRemove(PDIOCPARAMETERS pdiocp);
int ioctlMixer_FilterOn(PDIOCPARAMETERS pdiocp);
int ioctlMixer_FilterOff(PDIOCPARAMETERS pdiocp);
int ioctlMixer_GetBytePosition(PDIOCPARAMETERS pdiocp);
int ioctlMixer_SignalRemix(PDIOCPARAMETERS pdiocp);

int ioctlKeDest_New(PDIOCPARAMETERS pdiocp);
int ioctlMixDest_Delete(PDIOCPARAMETERS pdiocp);
int ioctlMixDest_Initialize(PDIOCPARAMETERS pdiocp);
int ioctlMixDest_Terminate(PDIOCPARAMETERS pdiocp);
int ioctlMixDest_SetFormat(PDIOCPARAMETERS pdiocp);
int ioctlMixDest_SetFormatInfo(PDIOCPARAMETERS pdiocp);
int ioctlMixDest_AllocMixer(PDIOCPARAMETERS pdiocp);
int ioctlMixDest_FreeMixer(PDIOCPARAMETERS pdiocp);
int ioctlMixDest_Play(PDIOCPARAMETERS pdiocp);
int ioctlMixDest_Stop(PDIOCPARAMETERS pdiocp);
int ioctlMixDest_GetFrequency(PDIOCPARAMETERS pdiocp);
int ioctlMixDest_Lock(PDIOCPARAMETERS pdiocp);
int ioctlMixDest_Unlock(PDIOCPARAMETERS pdiocp);

VOID _ZeroMemory(PVOID pDestination, DWORD cbLength);

int VXDINLINE VMM_lstrcmpi(char *pString1, char *pString2);
LPVOID VXDINLINE VMM_GetCurrentContext();
BOOL VXDINLINE VMM_PageAttach(ULONG pagesrc, LPVOID hcontextsrc, ULONG pagedst, ULONG cpages);
BOOL VXDINLINE VMM_PageFree(PVOID pPage, ULONG flags);
void VXDINLINE VMM_EnterMustComplete();
void VXDINLINE VMM_LeaveMustComplete();
BOOL VXDINLINE VWIN32_CloseVxDHandle(DWORD vxdh);

int ctrlDynamicDeviceInit(void);
int ctrlDynamicDeviceExit(void);

int ioctlDsvxdInitialize(PDIOCPARAMETERS pdiocp);
int ioctlDsvxdShutdown(PDIOCPARAMETERS pdiocp);
int ioctlDsvxd_PageFile_Get_Version(PDIOCPARAMETERS pdiocp);
int ioctlDsvxd_VMM_Test_Debug_Installed(PDIOCPARAMETERS pdiocp);
int ioctlDsvxd_VMCPD_Get_Version(PDIOCPARAMETERS pdiocp);
int ioctlDrvGetNextDescFromGuid(PDIOCPARAMETERS pdiocp);
int ioctlDrvGetDescFromGuid(PDIOCPARAMETERS pdiocp);
int ioctlDrvOpenFromGuid(PDIOCPARAMETERS pdiocp);
int ioctlIUnknown_QueryInterface(PDIOCPARAMETERS pdiocp);
int ioctlIUnknown_AddRef(PDIOCPARAMETERS pdiocp);
int ioctlIUnknown_Release(PDIOCPARAMETERS pdiocp);
int ioctlIDsDriver_QueryInterface(PDIOCPARAMETERS pdiocp);
int ioctlIDsDriver_Close(PDIOCPARAMETERS pdiocp);
int ioctlIDsDriver_GetCaps(PDIOCPARAMETERS pdiocp);
int ioctlIDsDriver_CreateSoundBuffer(PDIOCPARAMETERS pdiocp);
int ioctlIDsDriver_DuplicateSoundBuffer(PDIOCPARAMETERS pdiocp);
int ioctlBufferRelease(PDIOCPARAMETERS pdiocp);
int ioctlBufferLock(PDIOCPARAMETERS pdiocp);
int ioctlBufferUnlock(PDIOCPARAMETERS pdiocp);
int ioctlBufferSetFormat(PDIOCPARAMETERS pdiocp);
int ioctlBufferSetFrequency(PDIOCPARAMETERS pdiocp);
int ioctlBufferSetVolumePan(PDIOCPARAMETERS pdiocp);
int ioctlBufferSetPosition(PDIOCPARAMETERS pdiocp);
int ioctlBufferGetPosition(PDIOCPARAMETERS pdiocp);
int ioctlBufferPlay(PDIOCPARAMETERS pdiocp);
int ioctlBufferStop(PDIOCPARAMETERS pdiocp);
int ioctlIDirectSoundPropertySet_GetProperty(PDIOCPARAMETERS pdiocp);
int ioctlIDirectSoundPropertySet_SetProperty(PDIOCPARAMETERS pdiocp);
int ioctlIDirectSoundPropertySet_QuerySupport(PDIOCPARAMETERS pdiocp);
int ioctlEventScheduleWin32Event(PDIOCPARAMETERS pdiocp);
int ioctlEventCloseVxDHandle(PDIOCPARAMETERS pdiocp);
int ioctlMemReserveAlias(PDIOCPARAMETERS pdiocp);
int ioctlMemCommitAlias(PDIOCPARAMETERS pdiocp);
int ioctlMemDecommitAlias(PDIOCPARAMETERS pdiocp);
int ioctlMemRedirectAlias(PDIOCPARAMETERS pdiocp);
int ioctlMemFreeAlias(PDIOCPARAMETERS pdiocp);
int ioctlMemPageLock(PDIOCPARAMETERS pdiocp);
int ioctlMemPageUnlock(PDIOCPARAMETERS pdiocp);
int ioctlMemCommitPhysAlias(PDIOCPARAMETERS pdiocp);
int ioctlMemRedirectPhysAlias(PDIOCPARAMETERS pdiocp);
int ioctlGetInternalVersionNumber(PDIOCPARAMETERS pdiocp);

void Dsvxd_PageFile_Get_Version(PDWORD pVersion, PDWORD pMaxSize, PDWORD pPagerType);
BOOL Dsvxd_VMM_Test_Debug_Installed(void);
void Dsvxd_VMCPD_Get_Version(PLONG pMajorVersion, PLONG pMinorVersion, PLONG pCoprocessorLevel);

HRESULT SERVICE DSOUND_RegisterDeviceDriver(PIDSDRIVER pIDsDriver, DWORD dwFlags);
HRESULT SERVICE DSOUND_DeregisterDeviceDriver(PIDSDRIVER pIDsDriver, DWORD dwFlags);


//--------------------------------------------------------------------------;
//
//  Some useful IOCTL macros
//
//--------------------------------------------------------------------------;

// the ASSERT in IOSTART confirms that the count of
// input bytes is what we expect
#define IOSTART(cbInExpected) LPDWORD pdiocIn  = (LPDWORD)pdiocp->lpvInBuffer; \
                              LPDWORD pdiocOut = (LPDWORD)pdiocp->lpvOutBuffer; \
                              ASSERT( pdiocp->cbInBuffer == (cbInExpected) );

#define IOINPUT(x, t) x = ( *(t*)(pdiocIn++) );

#define IOOUTPUT(x, t) ( *(t*)((pdiocOut++)) ) = x;

// the ASSERT in IORETURN confirms that we read all
// of the bytes out of the input buffer
#define IORETURN (*(DWORD*)pdiocp->lpcbBytesReturned) = ((LPBYTE)pdiocOut) - ((LPBYTE)pdiocp->lpvOutBuffer); \
         ASSERT( (DWORD)(((LPBYTE)pdiocIn) - ((LPBYTE)pdiocp->lpvInBuffer)) == pdiocp->cbInBuffer );

#ifdef DEBUG
#ifndef USEASSERT
#define USEASSERT
#endif
#endif

// ASSERT macro
#undef HOLYCOW
#undef CRLF
#undef ASSERT

#define HOLYCOW "******************************************************************************"
#define CRLF "\n"

#ifdef USEASSERT
#define ASSERT(exp) if(!(exp)) _Trace_Out_Service("DSVXD: "), _Debug_Printf_Service(CRLF HOLYCOW CRLF "Assertion failed in %s, line %u: %s" CRLF HOLYCOW CRLF, __FILE__, __LINE__, #exp), _Debug_Out_Service("")
#else
// Disable empty controlled statement warning for ASSERT macro
#pragma warning(disable:4390)
#define ASSERT(exp)
#endif

// BREAK and DPF macros
#undef DPF
#undef BREAK

#define DPF_GUID_STRING             "{%8.8lX-%4.4X-%4.4X-%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X}"
#define DPF_GUID_VAL(guid)          (guid).Data1, (guid).Data2, (guid).Data3, (guid).Data4[0], (guid).Data4[1], (guid).Data4[2], (guid).Data4[3], (guid).Data4[4], (guid).Data4[5], (guid).Data4[6], (guid).Data4[7]

// #define DEBUG_VXDDRIVERCALLS
#ifdef DEBUG_VXDDRIVERCALLS
#define DRVCALL(arg) _Trace_Out_Service("DSVXD: "), _Debug_Printf_Service##arg, _Trace_Out_Service(CRLF)
#else
#define DRVCALL(arg)
#endif

#ifdef DEBUG
#define DPF(arg) _Trace_Out_Service("DSVXD: "), _Debug_Printf_Service##arg, _Trace_Out_Service(CRLF)
#define BREAK(arg) DPF(arg), _Debug_Out_Service("")
#else
#define DPF(arg)
#define BREAK(arg)
#endif

#ifdef __cplusplus
};
#endif

#endif // __DSVXDI_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxcrt\i386\fyl2x.asm ===
title	fylog2x	 - Danny's cheapo y*log2(x)
;*** 
;fylog2x.asm - compute y * log2(x)
;
;	Copyright (c) 1996 Microsoft Corporation
;
;Purpose:
;
;*******************************************************************************


.xlist
	include cruntime.inc
.list

	CODESEG

fylog2x	proto stdcall, y:qword, x:qword

	public	fylog2x
fylog2x	proc stdcall, y:qword, x:qword

	fld	y
	fld	x
	fyl2x
	ret
fylog2x	endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxcrt\i386\llmul.asm ===
title   llmul - long multiply routine
;***
;llmul.asm - long multiply routine
;
;       Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Defines long multiply routine
;       Both signed and unsigned routines are the same, since multiply's
;       work out the same in 2's complement
;       creates the following routine:
;           __allmul
;
;*******************************************************************************


.xlist
include cruntime.inc
include mm.inc
.list

;***
;llmul - long multiply routine
;
;Purpose:
;       Does a long multiply (same for signed/unsigned)
;       Parameters are not changed.
;
;Entry:
;       Parameters are passed on the stack:
;               1st pushed: multiplier (QWORD)
;               2nd pushed: multiplicand (QWORD)
;
;Exit:
;       EDX:EAX - product of multiplier and multiplicand
;       NOTE: parameters are removed from the stack
;
;Uses:
;       ECX
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

_allmul PROC NEAR

A       EQU     [esp + 4]       ; stack address of a
B       EQU     [esp + 12]      ; stack address of b

;
;       AHI, BHI : upper 32 bits of A and B
;       ALO, BLO : lower 32 bits of A and B
;
;             ALO * BLO
;       ALO * BHI
; +     BLO * AHI
; ---------------------
;

        mov     eax,HIWORD(A)
        mov     ecx,HIWORD(B)
        or      ecx,eax         ;test for both hiwords zero.
        mov     ecx,LOWORD(B)
        jnz     short hard      ;both are zero, just mult ALO and BLO

        mov     eax,LOWORD(A)
        mul     ecx

        ret     16              ; callee restores the stack

hard:
        push    ebx

; must redefine A and B since esp has been altered

A2      EQU     [esp + 8]       ; stack address of a
B2      EQU     [esp + 16]      ; stack address of b

        mul     ecx             ;eax has AHI, ecx has BLO, so AHI * BLO
        mov     ebx,eax         ;save result

        mov     eax,LOWORD(A2)
        mul     dword ptr HIWORD(B2) ;ALO * BHI
        add     ebx,eax         ;ebx = ((ALO * BHI) + (AHI * BLO))

        mov     eax,LOWORD(A2)  ;ecx = BLO
        mul     ecx             ;so edx:eax = ALO*BLO
        add     edx,ebx         ;now edx has all the LO*HI stuff

        pop     ebx

        ret     16              ; callee restores the stack

_allmul ENDP

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxcrt\i386\ftol.asm ===
page	,132
	title	87ftol	 - truncate TOS to 32-bit integer
;*** 
;87ftol.asm - truncate TOS to 32-bit integer
;
;	Copyright (c) 1985-88, Microsoft Corporation
;
;Purpose:
;
;*******************************************************************************


.xlist
	include cruntime.inc
.list

	CODESEG

	public	_ftol
_ftol	proc

	local	oldcw:word
	local	newcw:word
	local	intval:qword

	fstcw	[oldcw] 		; get control word
	fwait				; synchronize

	mov	ax, [oldcw]		; round mode saved
	or	ah, 0ch 		; set chop rounding mode
	mov	[newcw], ax		; back to memory

	fldcw	[newcw] 		; reset rounding
	fistp	qword ptr [intval]	; store chopped integer
	fldcw	[oldcw] 		; restore rounding

	mov	eax, dword ptr [intval]
	mov	edx, dword ptr [intval+4]

	ret
_ftol	endp

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsvxd\i386\dshel.asm ===
;****************************************************************************
;**									   **
;**									   **
;**									   **
;**									   **
;**									   **
;**									   **
;**									   **
;**									   **
;****************************************************************************

	.386



	.xlist
	include vmm.inc
	include vtd.inc
	include debug.inc
;       include mmdevldr.inc
	include vwin32.inc
	include pagefile.inc
	include vmcpd.inc
;	include shell.inc
;       include debugsys.inc
	.list

Create_DSOUND_Service_Table equ 1
	include dsdriver.inc


	OPTION SCOPED

;****************************************************************************
;**									   **
;**  VxD declaration							   **
;**									   **
;****************************************************************************

DSOUND_VERSION_MAJOR  equ 4	; Version 4.02
DSOUND_VERSION_MINOR  equ 2	;

Declare_Virtual_Device DSOUND,					\
	       DSOUND_VERSION_MAJOR, DSOUND_VERSION_MINOR,	\
	       DSOUND_Control,					\
	       DSOUND_Device_ID,					\
	       UNDEFINED_INIT_ORDER,				\
	       DSOUND_API_Handler,				\
	       DSOUND_API_Handler

;****************************************************************************
;**									   **
;**  Macro, equate, and type declarations				   **
;**									   **
;****************************************************************************

LONG_MAX	   equ 7fffffffh    ;Maximum 32-bit signed value

RESAMPLING_TOLERANCE   equ 0	    ;E.g., 655=1% resampling tolerance


;****************************************************************************
;**									   **
;**  Locked data							   **
;**									   **
;****************************************************************************

VxD_LOCKED_DATA_SEG

;****************************************************************************
;**									   **
;** Primitive vectors generated at beginning of data segment		   **
;**									   **
;** 1st 32 entries:  MAKE_DC procedures for AILSSA_DMA_copy()		   **
;** 2nd 128 entries: MAKE_MERGE procedures for AILSSA_merge()		   **
;**									   **
;****************************************************************************

	;
	;First device code is duplicated since IOCTL calls with
	;function 0 always fail in Win95 for some reason
	;
	;---
        ;
        ; Read the documentation, silly.  Function 0 is DIOC_OPEN.
        ; It is the VxD version of PROCESS_ATTACH.

DSVXD_IOCTL_Table LABEL DWORD

	dd OFFSET32 _ioctlDsvxdGetVersion
	dd OFFSET32 _ioctlDsvxdInitialize
	dd OFFSET32 _ioctlDsvxdShutdown

	dd OFFSET32 _ioctlDrvGetNextDescFromGuid
	dd OFFSET32 _ioctlDrvGetDescFromGuid
	dd OFFSET32 _ioctlIDsDriver_QueryInterface
	dd OFFSET32 _ioctlDrvOpenFromGuid

	dd OFFSET32 _ioctlIDsDriver_Close
	dd OFFSET32 _ioctlIDsDriver_GetCaps
	dd OFFSET32 _ioctlIDsDriver_CreateSoundBuffer
	dd OFFSET32 _ioctlIDsDriver_DuplicateSoundBuffer

	dd OFFSET32 _ioctlBufferRelease
	dd OFFSET32 _ioctlBufferLock
	dd OFFSET32 _ioctlBufferUnlock
	dd OFFSET32 _ioctlBufferSetFormat
	dd OFFSET32 _ioctlBufferSetFrequency
	dd OFFSET32 _ioctlBufferSetVolumePan
	dd OFFSET32 _ioctlBufferSetPosition
	dd OFFSET32 _ioctlBufferGetPosition
	dd OFFSET32 _ioctlBufferPlay
	dd OFFSET32 _ioctlBufferStop

	dd OFFSET32 _ioctlEventScheduleWin32Event
	dd OFFSET32 _ioctlEventCloseVxDHandle

	dd OFFSET32 _ioctlMemReserveAlias
	dd OFFSET32 _ioctlMemCommitAlias
        dd OFFSET32 _ioctlMemRedirectAlias
	dd OFFSET32 _ioctlMemDecommitAlias
	dd OFFSET32 _ioctlMemFreeAlias
	dd OFFSET32 _ioctlMemPageLock
	dd OFFSET32 _ioctlMemPageUnlock

	dd OFFSET32 _ioctlDsvxd_PageFile_Get_Version
	dd OFFSET32 _ioctlDsvxd_VMM_Test_Debug_Installed
	dd OFFSET32 _ioctlDsvxd_VMCPD_Get_Version

	dd OFFSET32 _ioctlDsvxd_GetMixerMutexPtr

	dd OFFSET32 _ioctlMixer_Run
	dd OFFSET32 _ioctlMixer_Stop
	dd OFFSET32 _ioctlMixer_PlayWhenIdle
	dd OFFSET32 _ioctlMixer_StopWhenIdle
	dd OFFSET32 _ioctlMixer_MixListAdd
	dd OFFSET32 _ioctlMixer_MixListRemove
	dd OFFSET32 _ioctlMixer_FilterOn
	dd OFFSET32 _ioctlMixer_FilterOff
	dd OFFSET32 _ioctlMixer_GetBytePosition
	dd OFFSET32 _ioctlMixer_SignalRemix

	dd OFFSET32 _ioctlKeDest_New
	dd OFFSET32 _ioctlMixDest_Delete
	dd OFFSET32 _ioctlMixDest_Initialize
	dd OFFSET32 _ioctlMixDest_Terminate
	dd OFFSET32 _ioctlMixDest_SetFormat
	dd OFFSET32 _ioctlMixDest_SetFormatInfo
	dd OFFSET32 _ioctlMixDest_AllocMixer
	dd OFFSET32 _ioctlMixDest_FreeMixer
	dd OFFSET32 _ioctlMixDest_Play
	dd OFFSET32 _ioctlMixDest_Stop
	dd OFFSET32 _ioctlMixDest_GetFrequency

	dd OFFSET32 _ioctlMemCommitPhysAlias
	dd OFFSET32 _ioctlMemRedirectPhysAlias

	dd OFFSET32 _ioctlIUnknown_QueryInterface
	dd OFFSET32 _ioctlIUnknown_AddRef
	dd OFFSET32 _ioctlIUnknown_Release

	dd OFFSET32 _ioctlIDirectSoundPropertySet_GetProperty
	dd OFFSET32 _ioctlIDirectSoundPropertySet_SetProperty
	dd OFFSET32 _ioctlIDirectSoundPropertySet_QuerySupport

        dd OFFSET32 _ioctlGetInternalVersionNumber


DSOUND_N_IOCTLS	  EQU ($-DSVXD_IOCTL_Table) / SIZE DWORD

	;
	;Pointer to input/output parms
	;

IOCTL_parms dd ?

VxD_LOCKED_DATA_ENDS

;****************************************************************************
;**									   **
;**  Locked code							   **
;**									   **
;****************************************************************************

VxD_LOCKED_CODE_SEG

extrn _ioctlDsvxdInitialize:NEAR
extrn _ioctlDsvxdShutdown:NEAR

extrn _ioctlDrvGetNextDescFromGuid:NEAR
extrn _ioctlDrvGetDescFromGuid:NEAR
extrn _ioctlDrvOpenFromGuid:NEAR

extrn _ioctlIDsDriver_QueryInterface:NEAR
extrn _ioctlIDsDriver_Close:NEAR
extrn _ioctlIDsDriver_GetCaps:NEAR
extrn _ioctlIDsDriver_CreateSoundBuffer:NEAR
extrn _ioctlIDsDriver_DuplicateSoundBuffer:NEAR

extrn _ioctlBufferRelease:NEAR
extrn _ioctlBufferLock:NEAR
extrn _ioctlBufferUnlock:NEAR
extrn _ioctlBufferSetFormat:NEAR
extrn _ioctlBufferSetFrequency:NEAR
extrn _ioctlBufferSetVolumePan:NEAR
extrn _ioctlBufferSetPosition:NEAR
extrn _ioctlBufferGetPosition:NEAR
extrn _ioctlBufferPlay:NEAR
extrn _ioctlBufferStop:NEAR

extrn _ioctlEventScheduleWin32Event:NEAR
extrn _ioctlEventCloseVxDHandle:NEAR

extrn _ioctlMemReserveAlias:NEAR
extrn _ioctlMemCommitAlias:NEAR
extrn _ioctlMemRedirectAlias:NEAR
extrn _ioctlMemDecommitAlias:NEAR
extrn _ioctlMemFreeAlias:NEAR
extrn _ioctlMemPageLock:NEAR
extrn _ioctlMemPageUnlock:NEAR

extrn _ioctlDsvxd_PageFile_Get_Version:NEAR
extrn _ioctlDsvxd_VMM_Test_Debug_Installed:NEAR
extrn _ioctlDsvxd_VMCPD_Get_Version:NEAR

extrn _ioctlDsvxd_GetMixerMutexPtr:NEAR

extrn _ioctlMixer_Run:NEAR
extrn _ioctlMixer_Stop:NEAR
extrn _ioctlMixer_PlayWhenIdle:NEAR
extrn _ioctlMixer_StopWhenIdle:NEAR
extrn _ioctlMixer_MixListAdd:NEAR
extrn _ioctlMixer_MixListRemove:NEAR
extrn _ioctlMixer_FilterOn:NEAR
extrn _ioctlMixer_FilterOff:NEAR
extrn _ioctlMixer_GetBytePosition:NEAR
extrn _ioctlMixer_SignalRemix:NEAR

extrn _ioctlKeDest_New:NEAR
extrn _ioctlMixDest_Delete:NEAR
extrn _ioctlMixDest_Initialize:NEAR
extrn _ioctlMixDest_Terminate:NEAR
extrn _ioctlMixDest_SetFormat:NEAR
extrn _ioctlMixDest_SetFormatInfo:NEAR
extrn _ioctlMixDest_AllocMixer:NEAR
extrn _ioctlMixDest_FreeMixer:NEAR
extrn _ioctlMixDest_Play:NEAR
extrn _ioctlMixDest_Stop:NEAR
extrn _ioctlMixDest_GetFrequency:NEAR

extrn _ioctlMemCommitPhysAlias:NEAR
extrn _ioctlMemRedirectPhysAlias:NEAR

extrn _ioctlIUnknown_QueryInterface:NEAR
extrn _ioctlIUnknown_AddRef:NEAR
extrn _ioctlIUnknown_Release:NEAR

extrn _ioctlIDirectSoundPropertySet_QuerySupport:NEAR
extrn _ioctlIDirectSoundPropertySet_SetProperty:NEAR
extrn _ioctlIDirectSoundPropertySet_GetProperty:NEAR

extrn _ioctlGetInternalVersionNumber:NEAR

;****************************************************************************
;**									   **
;**  IOCTL dispatcher for VxD						   **
;**									   **
;**  Dispatch control messages to the correct handlers. Must be in	   **
;**  locked code segment. (All VxD segments are locked in 3.0/3.1)	   **
;**									   **
;**  ENTRY:								   **
;**									   **
;**  EXIT:								   **
;**  Carry clear success; Carry Set if fail.				   **
;**									   **
;****************************************************************************

BeginProc   DSOUND_Control

	Control_Dispatch Sys_Dynamic_Device_Init, ctrlDynamicDeviceInitA
	Control_Dispatch Sys_Dynamic_Device_Exit, ctrlDynamicDeviceExitA
	Control_Dispatch W32_DEVICEIOCONTROL, ctrlDeviceIOControl

;	Trace_Out "DSOUND_Control "

	clc
	ret

EndProc	    DSOUND_Control

;****************************************************************************
;**									   **
;**  API dispatcher for VxD						   **
;**									   **
;**  Dispatch control messages to the correct handlers.			   **
;**									   **
;**  ENTRY:								   **
;**									   **
;**  EXIT:								   **
;**  Carry clear success; Carry Set if fail.				   **
;**									   **
;****************************************************************************

BeginProc   DSOUND_API_Handler

	Trace_Out "DSOUND_API_Handler "
	clc
	ret

EndProc	    DSOUND_API_Handler

;---------------------------------------------------------------------------;
;
; ctrlDynamicDeviceInit and Exit
;
;---------------------------------------------------------------------------;


BeginProc ctrlDynamicDeviceInitA
	Ccall   _ctrlDynamicDeviceInit
	sub	eax, 1
	ret
EndProc ctrlDynamicDeviceInitA

BeginProc ctrlDynamicDeviceExitA
	Ccall _ctrlDynamicDeviceExit
	sub	eax, 1
	ret
EndProc ctrlDynamicDeviceExitA

;------------------------------------------------------------------------------
; FUNC	DSOUND_GetVersion	- Locked Code
;
; ENTRY
;	None
;
; EXIT
;	AH = Major version number
;	AL = Minor version number
;	Carry flag clear
;
; USES
;	EAX, Flags
;
;------------------------------------------------------------------------------
BeginProc _DSOUND_GetVersion, SERVICE
	mov eax, DSOUND_VERSION_MAJOR * 100h + DSOUND_VERSION_MINOR
	clc
	ret
EndProc _DSOUND_GetVersion

;****************************************************************************
;**									   **
;**   ctrlDeviceIOControl						   **
;**									   **
;**   DESCRIPTION: This function is called to perform Device IO		   **
;**	for a 32 bit process which has opened this device with		   **
;**	<f CreateFile>, and is performing IO using			   **
;**	<f DeviceIOControl>. Preserves the C32	calling registers	   **
;**	ESI, EDI, and EBX.						   **
;**									   **
;**   ENTRY:	   EBX	DDB						   **
;**	   ECX	dwIoControlCode						   **
;**	   ESI	ptr to DIOCParams					   **
;**									   **
;**   EXIT:  As determined by function, or 1 if invalid IOCTL		   **
;**									   **
;**   -----                                                                **
;**									   **
;**   Note: Function 0 is documented in vmm.h                              **
;**   as DIOC_OPEN.  It is your VxD's PROCESS_ATTACH call.                 **
;**									   **
;****************************************************************************

BeginProc   ctrlDeviceIOControl

	cmp ecx, DSOUND_N_IOCTLS
        jae     cDIOC_InvalidCode

	push edi
	push esi
	push ebx

	mov IOCTL_parms,esi

	push esi
	call DSVXD_IOCTL_Table[ecx*4]
	add esp, 4

	pop ebx
	pop esi
	pop edi
	ret

cDIOC_InvalidCode:
IFDEF   DEBUG
        cmp     ecx, DIOC_CLOSEHANDLE
        Debug_OutNZ "DSVXD: Invalid dwIoControlCode #ECX"
ENDIF
        mov     eax, 1                  ; ERROR_INVALID_FUNCTION
        ret

EndProc	    ctrlDeviceIOControl

;****************************************************************************
;**									   **
;**   _ioctlDsvxdGetVersion						   **
;**									   **
;**   DESCRIPTION: Get the version of DSVXD				   **
;**									   **
;**   ENTRY:								   **
;**									   **
;**   EXIT:                                                                **
;**									   **
;****************************************************************************

BeginProc _ioctlDsvxdGetVersion

	Trace_Out "DSVXD: ioctlDsvxdGetVersion"

	xor eax, eax
	mov ecx, DSOUND_VERSION_MAJOR * 100h + DSOUND_VERSION_MINOR
	ret

EndProc	_ioctlDsvxdGetVersion

;****************************************************************************
;**									   **
;**									   **
;**									   **
;****************************************************************************

;--------------------------------------------------------------------------;
;
; _Dsvxd_VMM_Test_Debug_Installed
;
; Out:
;
; Notes:
;
;--------------------------------------------------------------------------;

BeginProc _Dsvxd_VMM_Test_Debug_Installed
	EnterProc
	VMMcall Test_Debug_Installed
	mov	eax, 0
	jz	@F
	inc	eax
@@:
	LeaveProc
	Return
EndProc _Dsvxd_VMM_Test_Debug_Installed

;--------------------------------------------------------------------------;
;
; _Dsvxd_PageFile_Get_Version
;
; Out:
;
; Notes:
;
;--------------------------------------------------------------------------;

BeginProc _Dsvxd_PageFile_Get_Version
	ArgVar p_version, DWORD
	ArgVar p_maxsize, DWORD
	ArgVar p_pager_type, DWORD

	EnterProc
	pushad
	VxDcall PageFile_Get_Version
	mov	edi, p_version
	mov	[edi], eax
	mov	edi, p_maxsize
	mov	[edi], ecx
	xor	eax, eax
	mov	al, bl
	mov	edi, p_pager_type
	mov	[edi], eax
	popad
	LeaveProc
	Return
EndProc _Dsvxd_PageFile_Get_Version

;--------------------------------------------------------------------------;
;
; _Dsvxd_VMCPD_Get_Version
;
; Out:
;
; Notes:
;
;--------------------------------------------------------------------------;

BeginProc _Dsvxd_VMCPD_Get_Version
	ArgVar pMajorVersion, DWORD
	ArgVar pMinorVersion, DWORD
	ArgVar pLevel, DWORD

	EnterProc
	pushad

	VxDcall VMCPD_Get_Version
	xor	ebx, ebx

	mov	edi, pMajorVersion
	mov	bl, ah
	mov	[edi], ebx

	mov	bl, al
	mov	edi, pMinorVersion
	mov	[edi], ebx

	mov	edi, pLevel
	mov	[edi], ecx

	popad
	LeaveProc
	Return
EndProc _Dsvxd_VMCPD_Get_Version

;--------------------------------------------------------------------------;
;
; _KeGrace_GlobalTimeOutProcAsm
;
; This is the entry point for the global time out set by the
; KeGrace object.  This is just an ASM thunk to KeGrace_GlobalTimeOutProc
; "C" function.
;
; This function is called from the VMM as follows:
;
;	mov     ebx, VMHandle      ; current VM handle
;	mov     ecx, Tardiness     ; number of milliseconds since time-out
;	mov     edx, RefData       ; reference data
;	mov     ebp, OFFSET32 crs  ; points to Client_Reg_Struc
;	call    [TimeOutCallback]
;
; Out:
;
; Notes:
;
;--------------------------------------------------------------------------;

extrn _KeGrace_GlobalTimeOutProc:NEAR

BeginProc _KeGrace_GlobalTimeOutProcAsm
	; The reference data is a pointer to and EVENTPARAMS structure whose
	; first member is the event handle and second member is the "this" pointer
	; to the KeGrace object

	xor	eax, eax
	xchg	[edx], eax		; Clear the event handle

	Debug_OutEAXz "DSVXD: executing KeGrace_GlobalTimeOutProcAsm after cancelled!"
	or	eax, eax
	jz	@F

	pushad
	push	ecx			; Pass tardiness
	push	[edx + 4]		; Pass "this" to the "C" function
	Ccall	_KeGrace_GlobalTimeOutProc
	add	esp, 8
	popad

@@:
	ret

EndProc _KeGrace_GlobalTimeOutProcAsm

;--------------------------------------------------------------------------;
;
; _VMEvent_SetWin32Event
;
;	This is a VM EventCallback scheduled by _AsyncTimeOut_SetWin32Event.
;	This calls VWin32 to set a Win32 event.
;
; In:
;	ebx = vm handle
;	edi = thread handle
;	edx = refdata = vxd handle to win32 event
;	ebp = offset32 client reg struc
;
; Out:
;
; Notes:
;	See _eventScheduleWin32Event
;
;--------------------------------------------------------------------------;

BeginProc _VMEvent_SetWin32Event

	mov	eax, edx
	VxDcall	_VWIN32_SetWin32Event

	ret

EndProc _VMEvent_SetWin32Event

;--------------------------------------------------------------------------;
;
; _AsyncTimeOut_SetWin32Event
;
;	This is an async timeout callback set by _Set_SetWin32Event_TimeOut.
;	This schedules _VMEvent_SetWin32Event as a sys vm event callback.
;
; In:
;	ecx = tardiness
;	edx = reference data = vxd handle to win32 event
;
; Out:
;
; Notes:
;	See _eventScheduleWin32Event
;
;--------------------------------------------------------------------------;

BeginProc _AsyncTimeOut_SetWin32Event

	push	ebx
	push	esi

	VMMcall	Get_Sys_VM_Handle
	mov	esi, _VMEvent_SetWin32Event
	VMMcall	Schedule_VM_Event

	pop	esi
	pop	ebx
	ret

EndProc _AsyncTimeOut_SetWin32Event


;--------------------------------------------------------------------------;
;
; _EventScheduleWin32Event
;
;	This signals a win32 event after a specified delay.
;
; In:
;	vxdhEvent - vxd handle to win32 event
;	dwDelay - milliseconds delay
;
; Out(int):
;	0 if failure, non-0 otherwise
;
; Notes:
;	Use 'C' calling convention.  Sets an async timeout which in
;	turn schedules a vm event to actually signal the win32 event.
;
;--------------------------------------------------------------------------;

BeginProc _eventScheduleWin32Event

ArgVar vxdhEvent,DWORD
ArgVar dwDelay,DWORD

	EnterProc
	push	ebx
	push	esi

	mov	eax, dwDelay

	test	eax, eax
	jnz	_ESW32E_delayed

	VMMcall Get_Sys_VM_Handle
	mov	esi, _VMEvent_SetWin32Event
	mov	edx, vxdhEvent
	Vmmcall Call_VM_Event
	mov	eax, -1

	jmp	_ESW32E_exit

_ESW32E_delayed:
	Debug_Out "DSVXD: Tried to set a defered win32 event???"
	mov	edx, vxdhEvent
	mov	esi, _AsyncTimeOut_SetWin32Event
	VMMcall	Set_Async_Time_Out
	mov	eax, esi

_ESW32E_exit:
	pop	esi
	pop	ebx
	LeaveProc
	Return

EndProc _eventScheduleWin32Event

VXD_LOCKED_CODE_ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsvxd\win9x\makefile.inc ===
#############################################################################
# Copyright (C) Microsoft Corporation 2000
#############################################################################

!include ..\..\buildmode.inc

C_DEFINES =

!if "$(NTDEBUG)" == "ntsd"

C_DEFINES = -DDBG=1

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG
!endif

!endif


..\dsbnotes.cpp: ..\..\dsound\dsbnotes.cpp
    -copy $** $@

..\grace.cpp:    ..\..\dsound\grace.cpp
    -copy $** $@

..\grsource.cpp: ..\..\dsound\grsource.cpp
    -copy $** $@

..\mix.cpp:      ..\..\dsound\mix.cpp
    -copy $** $@

..\filter.c:     ..\..\dsound\filter.c
    -copy $** $@

..\dxcrt.c:      ..\..\dsound\dxcrt.c
    -copy $** $@


# Don't change the relative paths in INCLUDE below to paths based on BASEDIR
# or DXROOT. The 16-bit resource compiler doesn't handle non-8.3 names in
# the path (i.e. \nt\multimedia).
#
# set INCLUDE=..\..\..;..\..\..\public\ddk\inc;..\..\..\public\sdk\inc16;..\..\..\inc;..\..\dsound

# Note: we include ver.h below with the full pathname because the 16-bit RC
# also needs command lines under 128 bytes - and we're dangerously close.

dsound.res: ..\..\..\inc\verinfo.h
	..\..\..\public\tools\win9x\common\rc -I.. -I..\..\..\inc -I..\..\..\public\ddk\inc -I..\..\dsound -fodsound.res $(C_DEFINES) -r <<dsound.rc
#include "..\..\..\public\sdk\inc16\ver.h"
#include "verinfo.h"
#define Not_VxD
#include <vmm.h>
#include "dsdriver.h"

#define VERSIONTYPE		VFT_VXD
#define VERSIONSUBTYPE 		DSOUND_DEVICE_ID
#define VERSIONNAME		"dsound.vxd"

!if "$(NTDEBUG)" == "ntsd"
!if "$(BuildMode)" == "internal"
    #define VERSIONDESCRIPTION "DirectSound VxD (internal)"
!else
    #define VERSIONDESCRIPTION "DirectSound VxD (debug)"
!endif
!else
    #define VERSIONDESCRIPTION "DirectSound VxD"
!endif

#include "verinfo.ver"
<<NOKEEP
    
$(O)\dsound.vxd $(O)\dsvxd.sym: 

#
# VxD version stamp
#
adrc2vxd: dsound.res $(O)\dsound.vxd
    $(DXROOT)\public\tools\win9x\common\adrc2vxd $(O)\dsound.vxd dsound.res
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxcrt\i386\mm.inc ===
;***
;mm.inc - macros to write memory model dependent code
;
;       Copyright (c) 1987-1994, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;       This file contains definitions of a number of macros which
;       make the writing of memory model dependent code for the
;       386 a little easier and more portable.
;
;*******************************************************************************

; general code & data size constants & macros

DAT_ADDR_SZ =   4
BDAT_ADDR_SZ =  2

TXT_ADDR_SZ =   4

; Big/Little Endian Definitions for Long Integers

ifdef   bigend                  ; Big Endian (hi word at low address)
LOWORD  equ     [4]
HIWORD  equ     [0]
else                            ; Little Endian (low word at low address)
LOWORD  equ     [0]
HIWORD  equ     [4]
endif


; All Model Definitions

BPARGBAS equ    TXT_ADDR_SZ+4   ; offset from BP to first argument
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxcrt\i386\cruntime.inc ===
;***
;cruntime.inc - multi-model assembly macros for interfacing to HLLs
;
;       Copyright (c) 1988-1995, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;       This file defines the current memory model being used.
;
;*******************************************************************************

;==============================================================================
;
;Use the following defines to control processor/segment model
;
;   -DI86               8086/8088 processor
;   -DI286              80286 processor
;   -DI386              80386 processor with 32-bit code/data segment
;
;   -Dmem_S             Small memory model   (near code, near data)
;   -Dmem_M             Medium memory model  (far code, near data)
;   -Dmem_C             Compact memory model (near code, fat data)
;   -Dmem_L             Large memory model   (far code, far data)
;
;   -DSS_NEQ_DGROUP     SS and DS point to different segments
;
;   default is -DI86 -Dmem_S
;
;==============================================================================
;
;The following variables are defined by this file:
;   cpu                         86, 286, or 386
;   sizeC                       code distance; 1 = far code, 0 = near code
;   sizeD                       data distance; 1 = far data, 0 = near data
;   mmodel                      english name of the memory model, i.e. "Medium"
;   ISIZE, LSIZE, NSIZE         size of ints, longs, shorts
;   FLTSIZE, DBLSIZE, LDBLSIZE  size of float, double, long double
;   NPSIZE, FPSIZE              size of near/far pointers
;   CPSIZE, DPSIZE              size of code/data pointers
;   ISHIFT, LSHIFT              bits to shift to convert byte to int/long
;
;The following macros allow easy writing of combined 16/32 bit code:
;
; 16/32 bit registers:
;   rax, rbx, rcx, rdx,         expand to native registers (rax = eax or ax)
;   rsi, rdi, rsp, rbp
; 16/32 bit register instructions:
;   JRCXZ                       jump when rcx is zero
;   CBI                         convert byte to int (al to rax)
;   CAXDX                       convert rax to rax:rdx
;   ZXAL, ZXBL, ZXCL, ZXDL      zero extend al,bl,cl,dl to rax,rbx,rcx,rdx
; Pointer instructions:
;   LPDS, LPES                  load data pointer with ES or DS
;   PDS, PES                    segment overrides when pointer loaded as above
;   PCS, PSS                    segment override to get at code/stack segment
;   LFPDS, LFPES                load far pointer with ES or DS
;   FPDS, FPES                  segment overrides when pointer loaded as above
;   CPTR                        data type of code pointer
;   CPDIST                      distance of code (near/far)
;   DNPTR, DFPTR                define near/far pointer
;   DCPTR, DDPTR                define code/data pointer
;   DCPTR?, DDPTR?              define uninitialized code/data pointer
;   CPWORD, DPWORD              data type of code or data pointer
; Numeric type instructions:
;   IWORD, LWORD, SWORD         data type of int, long, short
;   DINT, DLONG, DSHORT         define int, long, short
;   DFLOAT, DDOUBLE, DLDOUBLE   define float, double, long double
; Offsets:
;   codeoffset, dataoffset      offsets from code and data segments
; API calls:
;   APIDIST                     distance of API calls (near/far)
;   APIEXT ApiName              extrn declaration for an API function
;
;The following utility macros are provided:
;   codeseg                     define/declare code segment
;   error <msg>                 stop assembly with message
;   display <msg>               display a message, unless QUIET defined
;   savelist [<reg> ...]        init list of regs to be save by 'proc uses'
;   _if cond <instruction>      assemble instruction only if cond is TRUE
;   _ife cond <instruction>     assemble instruction only if cond is FALSE
;   _ifd symbol <instruction>   assemble instruction only if symbol defined
;   _ifnd symbol <instruction>  assemble instruction only if symbol not defined
;
;   lab  LabelName              assembles to "LabelName:" If DEBUG is defined
;                               LabelName is made public
;
;   JS* (ex. JSE,JSZ,JSB ...)   assemble to "je short","jz short","jb short"
;
;   Cmacro look alikes
;   static* Name, InitialValue, Repeat   defines a static variable of type *
;   global* Name, InitialValue, Repeat   defines a global variable of type *
;   label*  Name, {PUBLIC,PASCAL,C}      defines a label of type *
;
;   PUSH16  SegmentReg          pushes 16 bits in a use32 segment
;   JMPFAR16  label             will do a far 16:16 jmp from a use32 segment
;
;==============================================================================

; error <msg>   -    Output message and generate error

error   MACRO   msg
if2                     ;; only on pass 2 can we generate errors
        %out    **********************************************************
        %out    *** E r r o r  --  msg
        %out    **********************************************************
        .err
endif
        ENDM

; display msg   -    Output message unless QUIET defined

display MACRO   msg
ifndef QUIET            ;; only when quiet flag not set
if1                     ;; and on pass 1, then display message
        %out msg
endif
endif
        ENDM

; One line conditionals:
;   here we create the capability of writing code lines like
;
; _if sizeD   <push ds>   as opposed to    if sizeD
;                                              push  ds
;                                          endif

_if     MACRO   cond,text
    if  cond
        text
    endif
        ENDM

_ife    MACRO   cond,text
    ife cond
        text
    endif
        ENDM

_ifd    MACRO   cond,text
    ifdef   cond
        text
    endif
        ENDM

_ifnd   MACRO   cond,text
    ifndef  cond
        text
    endif
        ENDM

; set windows flag to 0

        ?WIN    equ     0       ; disable windows-specific code

; check for _MT, requires 286 or greater processor

ifdef _MT
ifndef I386
ifndef I286
; _MT implies 286 processor
display <Multi-thread specified - assuming 80286 processor>
I286 equ <>
endif
endif
endif

; Process memory-model arguments

ifdef  mem_M
        ; Medium model
        sizeC   equ     1
        sizeD   equ     0
        mmodel  equ     <Medium>
elseifdef  mem_C
        ; Compact model
        sizeC   equ     0
        sizeD   equ     1
        mmodel  equ     <Compact>
elseifdef  mem_L
        ; Large model
        sizeC   equ     1
        sizeD   equ     1
        mmodel  equ     <Large>
else
        ; Small model - default
        sizeC   equ     0
        sizeD   equ     0
        mmodel  equ     <Small>
endif

; Process processor arguments

ifdef   _WIN32
        display <Processor:             486/586>
        cpu equ 586
        .586
elseifdef   I286
        display <Processor:             80286>
        cpu equ 286
        .286
elseifdef   I386
        display <Processor:             80386>
        cpu equ 386
        .386
else
        display <Processor:             8086/8088>
        cpu equ 86
        .8086
endif

;  386 32-bit checking.  Currently we are only expecting small model
;  32 bit segments, so we make a few checks to be sure nothing is
;  incorrectly being defined.

ifdef I386
    if sizeC or sizeD
        error <Must use Small memory model for 386 version.>
    endif

    ifdef _LOAD_DGROUP
        error <No loading DGROUP in 386 version.>
    endif

    ifdef SS_NEQ_DGROUP
        error <SS always equals DGROUP in 386 version.>
    endif
endif

;  Set memory model

%       display <Memory model:          mmodel>
%       .model  mmodel, C

;
; *** Temporary Workaround ***
; Currently, MASM will not recognize the 'FLAT' keyword unless it previously
; appears in an 'assume' statement.  Presumably, when the '.model FLAT' feature
; is implemented, this will go away.  [Use 'gs:' since we never use that
; segment register.
;

ifdef   I386
        ; ensure that MASM recognizes 'FLAT'
        assume  gs:FLAT
endif


; Define registers:
; Instead of using the "word" registers directly, we will use a set of
; text equates.  This will allow you to use the native word size instead of
; hard coded to 16 bit words.  We also have some instruction equates for
; instruction with the register type hard coded in.

ifdef I386

    rax equ <eax>
    rbx equ <ebx>
    rcx equ <ecx>
    rdx equ <edx>
    rdi equ <edi>
    rsi equ <esi>
    rbp equ <ebp>
    rsp equ <esp>

    JRCXZ equ <jecxz>
    CBI   equ <movsx eax, al>    ; convert byte to int (al to rax)
    CAXDX equ <cdq>              ; convert rax to rdx:rax
    ZXAL  equ <movzx eax, al>    ; zero extend al
    ZXBL  equ <movzx ebx, bl>    ; zero extend bl
    ZXCL  equ <movzx ecx, cl>    ; zero extend cl
    ZXDL  equ <movzx edx, dl>    ; zero extend dl

else

    rax equ <ax>
    rbx equ <bx>
    rcx equ <cx>
    rdx equ <dx>
    rdi equ <di>
    rsi equ <si>
    rbp equ <bp>
    rsp equ <sp>

    JRCXZ equ <jcxz>
    CBI   equ <cbw>              ; convert byte to int (al to rax)
    CAXDX equ <cwd>              ; convert rax to rdx:rax
    ZXAL  equ <xor ah, ah>       ; zero extend al
    ZXBL  equ <xor bh, bh>       ; zero extend bl
    ZXCL  equ <xor ch, ch>       ; zero extend cl
    ZXDL  equ <xor dh, dh>       ; zero extend dl

endif

; The following equates deal with the differences in near versus
; far data pointers, and segment overrides.
;
; Use LPES and PES when loading a default size pointer -- it loads
; a 16-bit pointer register in 286 Small/Medium model,
; a 16-bit pointer register and 16-bit segment register in 8086/286
; Compact/Large model, and a 32-bit pointer register in 386 mode.
;
; Use LFPES and FPES when loading an always far pointer -- it loads a
; 16-bit pointer register and 16-bit segment register in 8086/286,
; all models; a 32-bit pointer register in 386 mode.

if sizeD
    LPES equ <les>
    LPDS equ <lds>
    PDS  equ <ds:>
    PES  equ <es:>
else
    LPES equ <mov>
    LPDS equ <mov>
    PDS  equ <>
    PES  equ <>
endif

ifdef I386
    LFPES equ <mov>
    LFPDS equ <mov>
    FPES equ <>
    FPDS equ <>
else
    LFPES equ <les>
    LFPDS equ <lds>
    FPES equ <es:>
    FPDS equ <ds:>
endif

if sizeC or @WordSize eq 2
    PCS  equ <cs:>              ; large code model or non-386
else
 IF 1   ;*** TEMP 16/32 TESTBED ***
    PCS  equ <cs:>
 ELSE
    PCS  equ <>                 ; 386 small code model
 ENDIF  ;*** END TEMP CODE
endif

ifdef SS_NEQ_DGROUP
    PSS   equ <ss:>             ; SS != DS
else
    PSS   equ <>                ; SS == DS
endif

; Define offset macros:
;   The 32-bit segments will not have 'groups'

ifdef I386
    codeoffset  equ <offset FLAT:>
    dataoffset  equ <offset FLAT:>
else
    codeoffset  equ <offset @code:>
    dataoffset  equ <offset DGROUP:>
endif

; The next set of equates deals with the size of SHORTS, INTS, LONGS, and
; pointers in the 16 and 32 bit versions.

ifdef I386       ;--- 32 bit segment ---

    ; parameters and locals
    IWORD   equ <dword>
    LWORD   equ <dword>

    ; static storage
    DINT    equ <dd>
    DLONG   equ <dd>
    DSHORT  equ <dw>

    ; sizes for fixing SP, stepping through tables, etc.
    ISIZE   equ 4
    LSIZE   equ 4
    SSIZE   equ 2
    NPSIZE  equ 4
    FPSIZE  equ 4

    ; bit shift count to convert byte cnt/ptr to int/long cnt/ptr
    ISHIFT  equ 2               ; byte-to-int shift count
    LSHIFT  equ 2               ; byte-to-long shift count

    ; sizes dependent upon memory model.  dq -vs- df is not yet clear
    DNPTR equ <dd>              ; near pointer
    DFPTR equ <dd>              ; far pointer

    DCPTR   equ <dd offset FLAT:>; 32 bit offset only
    DCPTR?  equ <dd>            ; No seg override for uninitialized values
    CPSIZE  equ 4
    CPDIST  equ <near>          ; code pointers are near
    CPTR    equ <near ptr>

    DDPTR   equ <dd offset FLAT:>
    DDPTR?  equ <dd>
    DPSIZE  equ 4

    CPWORD  equ <dword>         ; code pointers are dwords
    DPWORD  equ <dword>         ; data pointers are dwords

    APIDIST equ <near>          ; all API calls are NEAR in the 32 bit model

; macro to declare API functions
EXTAPI  macro   apiname
        extrn pascal apiname:near
endm

else    ;--- 16-bit segment ---

    ; parameters and locals
    IWORD   equ <word>
    LWORD   equ <dword>

    ; static storage
    DINT    equ <dw>
    DLONG   equ <dd>
    DSHORT  equ <dw>

    ; sizes for fixing SP, stepping through tables, etc
    ISIZE   equ 2
    LSIZE   equ 4
    SSIZE   equ 2
    NPSIZE  equ 2
    FPSIZE  equ 4

    ; bit shift count to convert byte cnt/ptr to int/long cnt/ptr
    ISHIFT  equ 1               ; byte-to-int shift count
    LSHIFT  equ 2               ; byte-to-long shift count

    ; sizes dependent upon memory model
    DNPTR equ <dw>              ; near pointer
    DFPTR equ <dd>              ; far pointer

    if sizeC
        DCPTR   equ <dd>       ; 16 bit segment and 16 bit offset
        DCPTR?  equ <dd>
        CPSIZE  equ 4
        CPDIST  equ <far>      ; code pointers are far
        CPTR    equ <far ptr>
        CPWORD  equ <dword>    ; code pointers are dwords
    else
        DCPTR   equ <dw>       ; 16 bit offset only
        DCPTR?  equ <dw>
        CPSIZE  equ 2
        CPDIST  equ <near>     ; code pointers are near
        CPTR    equ <near ptr>
        CPWORD  equ <word>     ; code pointers are words
    endif

    if sizeD
        DDPTR   equ <dd>
        DDPTR?  equ <dd>
        DPSIZE  equ 4
        DPWORD  equ <dword>    ; data pointers are dwords
    else
        DDPTR   equ <dw>
        DDPTR?  equ <dw>
        DPSIZE  equ 2
        DPWORD  equ <word>     ; data pointers are words
    endif

    APIDIST equ <far>           ; API calls are FAR in 16 bit model

; macro to declare API functions
EXTAPI  macro   apiname
        extrn pascal apiname:far
endm

endif   ; --- 16/32 segment ---

; Float/double definitions
; (currently the same for 16- and 32-bit segments)

FLTSIZE  equ    4       ; float
DBLSIZE  equ    8       ; double
LDBLSIZE equ    10      ; long double

DFLOAT   equ    <dd>
DDOUBLE  equ    <dq>
DLDOUBLE equ    <dt>

;
; savelist - Generate a list of regs to be saved by the proc 'uses' option.
;
; Input:
;       reg1, reg2, reg3, reg4 = registers to be saved across function
; Output:
;       reglist = text string of registers that can be passed to the 'uses'
;       option on the 'proc' command.
;

savelist  MACRO   reg1, reg2, reg3, reg4
        local   ws, listsize
        ws      catstr  < >             ; whitespace char

        IFNDEF  I386
         rbx equ <>                     ; 8086/286 don't save rbx
        ENDIF

        IFNB        <reg4>
         reglist     catstr  reg1, ws, reg2, ws, reg3, ws, reg4
        ELSEIFNB    <reg3>
         reglist     catstr  reg1, ws, reg2, ws, reg3, ws
        ELSEIFNB    <reg2>
         reglist     catstr  reg1, ws, reg2, ws,       ws
        ELSEIFNB    <reg1>
         reglist     catstr  reg1, ws,       ws,       ws
        ELSE
         reglist     catstr  <>
        ENDIF

        listsize sizestr reglist        ; size of register list

        IF      listsize LE 3           ; if list is only the 3 ws chars...
         reglist catstr  <>
        ENDIF

        IFNDEF  I386
         rbx equ <bx>                   ; restore rbx
        ENDIF

        ENDM    ; savelist

;
; codeseg - Define/declare the standard code segment. Maps to the proper
; form of the .code directive.
;
; Input:
;
; Output:
;       .code _TEXT     ; for large code models
;       .code           ; for small code models
;       assume  cs:FLAT ; for 386
;       assume  ds:FLAT ; for 386
;       assume  es:FLAT ; for 386
;       assume  ss:FLAT ; for 386
;

codeseg MACRO

if      sizeC
        .code _TEXT
else
        .code
endif

ifdef   I386
        assume  ds:FLAT
        assume  es:FLAT
        assume  ss:FLAT
endif

        ENDM

;*========
;*
;*  Debug lab macro
;*
;*========

lab     macro name
ifdef   DEBUG
    public  pascal name     ;; define label public for Symdeb
endif
name:
        endm


;*========
;*
;*  Conditional jump short macros
;*
;*========


        irp     x,<Z,NZ,E,NE,S,NS,C,NC,P,NP,PE,PO,A,AE,B,BE,NB,G,GE,L,LE>
JS&x    equ   <j&x short>
        endm


;*========
;*
;*  Global data definition macros
;*
;*  Usage:
;*      globalI   Name, InitialValue, Repeat
;*
;*========


MakeGlobal  macro   suffix, DataType        ;; makes all of the global* macros

global&suffix  macro   name, data, rep
public  name
ifb     <rep>
    _repeat = 1
else
    _repeat = (rep)
endif

name    &DataType  _repeat dup( data )
        endm

        endm


    MakeGlobal  T, dt                   ; globalT
    MakeGlobal  Q, dq                   ; globalQ
    MakeGlobal  D, dd                   ; globalD
    MakeGlobal  W, dw                   ; globalW
    MakeGlobal  B, db                   ; globalB

%   MakeGlobal  I, <DINT>               ; globalI

%   MakeGlobal  DP, <DDPTR>             ; globalDP
%   MakeGlobal  CP, <DCPTR>             ; globalCP
%   MakeGlobal  FP, <DFPTR>             ; globalFP
%   MakeGlobal  NP, <DNPTR>             ; globalNP



;*========
;*
;*  Static data definition macros
;*
;*  Usage:
;*      staticI   Name, InitialValue, Repeat
;*
;*========


MakeStatic  macro   suffix, DataType        ;; makes all of the static* macros

static&suffix  macro   name, data, rep

ifdef  DEBUG
    public  pascal name                     ;; make statics public if DEBUG
endif

ifb     <rep>
    _repeat = 1
else
    _repeat = (rep)
endif

name    &DataType  _repeat dup( data )
        endm

        endm


    MakeStatic  T, dt                   ; staticT
    MakeStatic  Q, dq                   ; staticQ
    MakeStatic  D, dd                   ; staticD
    MakeStatic  W, dw                   ; staticW
    MakeStatic  B, db                   ; staticB

%   MakeStatic  I, <DINT>               ; staticI

%   MakeStatic  DP, <DDPTR>             ; staticDP
%   MakeStatic  CP, <DCPTR>             ; staticCP
%   MakeStatic  FP, <DFPTR>             ; staticFP
%   MakeStatic  NP, <DNPTR>             ; staticNP

;*========
;*
;*  Label definition macros
;*
;*========
;*
;*  Label definition macros
;*
;*  Usage:
;*      labelI   Name, {PUBLIC, PASCAL, C}
;*
;*========

__MakePublic    macro   name, option    ;; decides if a label should be
ifidni  <option>, <PUBLIC>              ;; made public
    public  name
elseifidni  <option>, <PASCAL>
    public  pascal name
elseifidni  <option>, <C>
    public  C name
elseifb  <option>
    ifdef  DEBUG
        public  pascal name     ;; make public if DEBUG
    endif
endif
                endm


MakeLabel   macro suffix, LabelType     ;; makes all of the label* macros

%@CatStr(<label>,<suffix>)      macro   name, option
        __MakePublic    <name>,<option>
name    label   &LabelType
        endm

        endm


        MakeLabel   T, tbyte    ; make labelT
        MakeLabel   Q, qword    ; make labelQ
        MakeLabel   D, dword    ; make labelD
        MakeLabel   W, word     ; make labelW
        MakeLabel   B, byte     ; make labelB

        MakeLabel   P, proc     ; make labelP
        MakeLabel   FP, far     ; make labelFP
        MakeLabel   NP, near    ; make labelNP

%       MakeLabel   I, IWORD    ; make labelI


labelDP macro   name, option                ;; labelDP
        __MakePublic    <name>,<option>
ifdef  I386
    if sizeD
        name    label   fword
    else
        name    label   dword
    endif
else    ;not I386
    if sizeD
        name    label   dword
    else
        name    label   word
    endif
endif   ;not I386
        endm

labelCP macro   name, option                ;; labelCP
        __MakePublic    <name>,<option>
ifdef  I386
    if sizeC
        name    label   fword
    else
        name    label   dword
    endif
else    ;not I386
    if sizeC
        name    label   dword
    else
        name    label   word
    endif
endif   ;not I386
        endm


;*
;*  PUSH16 SegReg   - pushes 16 bits in a use32 segment
;*

PUSH16  macro   SegReg

ifdef I386
        nop
        db      66h         ; operand size over-ride
endif   ; I386

        push    SegReg
        endm


;*
;*  JMPFAR16  label - jmps far from a use32 to a use16 segment
;*

JMPFAR16 macro  label

ifndef I386
        error  <JMPFAR16 can only be used in a use32 code segment>
endif   ;I386

        nop
        db      66h         ;; operand size over-ride
        db      0eah        ;; jmp far immediate op code
        dw      offset label
        dw      seg label
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxcrt\i386\lldiv.asm ===
title   lldiv - signed long divide routine
;***
;lldiv.asm - signed long divide routine
;
;       Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines the signed long divide routine
;           __alldiv
;
;*******************************************************************************


.xlist
include cruntime.inc
include mm.inc
.list

;***
;lldiv - signed long divide
;
;Purpose:
;       Does a signed long divide of the arguments.  Arguments are
;       not changed.
;
;Entry:
;       Arguments are passed on the stack:
;               1st pushed: divisor (QWORD)
;               2nd pushed: dividend (QWORD)
;
;Exit:
;       EDX:EAX contains the quotient (dividend/divisor)
;       NOTE: this routine removes the parameters from the stack.
;
;Uses:
;       ECX
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

_alldiv PROC NEAR

        push    edi
        push    esi
        push    ebx

; Set up the local stack and save the index registers.  When this is done
; the stack frame will look as follows (assuming that the expression a/b will
; generate a call to lldiv(a, b)):
;
;               -----------------
;               |               |
;               |---------------|
;               |               |
;               |--divisor (b)--|
;               |               |
;               |---------------|
;               |               |
;               |--dividend (a)-|
;               |               |
;               |---------------|
;               | return addr** |
;               |---------------|
;               |      EDI      |
;               |---------------|
;               |      ESI      |
;               |---------------|
;       ESP---->|      EBX      |
;               -----------------
;

DVND    equ     [esp + 16]      ; stack address of dividend (a)
DVSR    equ     [esp + 24]      ; stack address of divisor (b)


; Determine sign of the result (edi = 0 if result is positive, non-zero
; otherwise) and make operands positive.

        xor     edi,edi         ; result sign assumed positive

        mov     eax,HIWORD(DVND) ; hi word of a
        or      eax,eax         ; test to see if signed
        jge     short L1        ; skip rest if a is already positive
        inc     edi             ; complement result sign flag
        mov     edx,LOWORD(DVND) ; lo word of a
        neg     eax             ; make a positive
        neg     edx
        sbb     eax,0
        mov     HIWORD(DVND),eax ; save positive value
        mov     LOWORD(DVND),edx
L1:
        mov     eax,HIWORD(DVSR) ; hi word of b
        or      eax,eax         ; test to see if signed
        jge     short L2        ; skip rest if b is already positive
        inc     edi             ; complement the result sign flag
        mov     edx,LOWORD(DVSR) ; lo word of a
        neg     eax             ; make b positive
        neg     edx
        sbb     eax,0
        mov     HIWORD(DVSR),eax ; save positive value
        mov     LOWORD(DVSR),edx
L2:

;
; Now do the divide.  First look to see if the divisor is less than 4194304K.
; If so, then we can use a simple algorithm with word divides, otherwise
; things get a little more complex.
;
; NOTE - eax currently contains the high order word of DVSR
;

        or      eax,eax         ; check to see if divisor < 4194304K
        jnz     short L3        ; nope, gotta do this the hard way
        mov     ecx,LOWORD(DVSR) ; load divisor
        mov     eax,HIWORD(DVND) ; load high word of dividend
        xor     edx,edx
        div     ecx             ; eax <- high order bits of quotient
        mov     ebx,eax         ; save high bits of quotient
        mov     eax,LOWORD(DVND) ; edx:eax <- remainder:lo word of dividend
        div     ecx             ; eax <- low order bits of quotient
        mov     edx,ebx         ; edx:eax <- quotient
        jmp     short L4        ; set sign, restore stack and return

;
; Here we do it the hard way.  Remember, eax contains the high word of DVSR
;

L3:
        mov     ebx,eax         ; ebx:ecx <- divisor
        mov     ecx,LOWORD(DVSR)
        mov     edx,HIWORD(DVND) ; edx:eax <- dividend
        mov     eax,LOWORD(DVND)
L5:
        shr     ebx,1           ; shift divisor right one bit
        rcr     ecx,1
        shr     edx,1           ; shift dividend right one bit
        rcr     eax,1
        or      ebx,ebx
        jnz     short L5        ; loop until divisor < 4194304K
        div     ecx             ; now divide, ignore remainder
        mov     esi,eax         ; save quotient

;
; We may be off by one, so to check, we will multiply the quotient
; by the divisor and check the result against the orignal dividend
; Note that we must also check for overflow, which can occur if the
; dividend is close to 2**64 and the quotient is off by 1.
;

        mul     dword ptr HIWORD(DVSR) ; QUOT * HIWORD(DVSR)
        mov     ecx,eax
        mov     eax,LOWORD(DVSR)
        mul     esi             ; QUOT * LOWORD(DVSR)
        add     edx,ecx         ; EDX:EAX = QUOT * DVSR
        jc      short L6        ; carry means Quotient is off by 1

;
; do long compare here between original dividend and the result of the
; multiply in edx:eax.  If original is larger or equal, we are ok, otherwise
; subtract one (1) from the quotient.
;

        cmp     edx,HIWORD(DVND) ; compare hi words of result and original
        ja      short L6        ; if result > original, do subtract
        jb      short L7        ; if result < original, we are ok
        cmp     eax,LOWORD(DVND) ; hi words are equal, compare lo words
        jbe     short L7        ; if less or equal we are ok, else subtract
L6:
        dec     esi             ; subtract 1 from quotient
L7:
        xor     edx,edx         ; edx:eax <- quotient
        mov     eax,esi

;
; Just the cleanup left to do.  edx:eax contains the quotient.  Set the sign
; according to the save value, cleanup the stack, and return.
;

L4:
        dec     edi             ; check to see if result is negative
        jnz     short L8        ; if EDI == 0, result should be negative
        neg     edx             ; otherwise, negate the result
        neg     eax
        sbb     edx,0

;
; Restore the saved registers and return.
;

L8:
        pop     ebx
        pop     esi
        pop     edi

        ret     16

_alldiv ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxcrt\i386\pow2.asm ===
title	pow2	 - Danny's cheapo pow function
;*** 
;pow2.asm - compute 2 to the power of something
;
;	Copyright (c) 1985-88, Microsoft Corporation
;
;Purpose:
;
;*******************************************************************************


.xlist
	include cruntime.inc
.list

	CODESEG

pow2	proto stdcall, orig:qword

	public	pow2
pow2	proc stdcall, orig:qword

	fld	orig
	fst 	st(1)			; duplicate orig
	frndint				; I don't care how it rounds
	fstp	st(2)			; st=orig st(1)=round
	fsub	st, st(1)		; st=orig-round
	f2xm1				; st=2^(orig-round)-1
	fld1
	faddp	st(1), st		; st=2^(orig-round)
	fscale				; st=2^(orig-round)*2^round=2^orig
	fstp	st(1)			; clean stack of st(1)
	ret
pow2	endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxcrt\i386\ulldiv.asm ===
title   ulldiv - unsigned long divide routine
;***
;ulldiv.asm - unsigned long divide routine
;
;       Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines the unsigned long divide routine
;           __aulldiv
;
;*******************************************************************************


.xlist
include cruntime.inc
include mm.inc
.list

;***
;ulldiv - unsigned long divide
;
;Purpose:
;       Does a unsigned long divide of the arguments.  Arguments are
;       not changed.
;
;Entry:
;       Arguments are passed on the stack:
;               1st pushed: divisor (QWORD)
;               2nd pushed: dividend (QWORD)
;
;Exit:
;       EDX:EAX contains the quotient (dividend/divisor)
;       NOTE: this routine removes the parameters from the stack.
;
;Uses:
;       ECX
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

_aulldiv        PROC NEAR

        push    ebx
        push    esi

; Set up the local stack and save the index registers.  When this is done
; the stack frame will look as follows (assuming that the expression a/b will
; generate a call to uldiv(a, b)):
;
;               -----------------
;               |               |
;               |---------------|
;               |               |
;               |--divisor (b)--|
;               |               |
;               |---------------|
;               |               |
;               |--dividend (a)-|
;               |               |
;               |---------------|
;               | return addr** |
;               |---------------|
;               |      EBX      |
;               |---------------|
;       ESP---->|      ESI      |
;               -----------------
;

DVND    equ     [esp + 12]      ; stack address of dividend (a)
DVSR    equ     [esp + 20]      ; stack address of divisor (b)

;
; Now do the divide.  First look to see if the divisor is less than 4194304K.
; If so, then we can use a simple algorithm with word divides, otherwise
; things get a little more complex.
;

        mov     eax,HIWORD(DVSR) ; check to see if divisor < 4194304K
        or      eax,eax
        jnz     short L1        ; nope, gotta do this the hard way
        mov     ecx,LOWORD(DVSR) ; load divisor
        mov     eax,HIWORD(DVND) ; load high word of dividend
        xor     edx,edx
        div     ecx             ; get high order bits of quotient
        mov     ebx,eax         ; save high bits of quotient
        mov     eax,LOWORD(DVND) ; edx:eax <- remainder:lo word of dividend
        div     ecx             ; get low order bits of quotient
        mov     edx,ebx         ; edx:eax <- quotient hi:quotient lo
        jmp     short L2        ; restore stack and return

;
; Here we do it the hard way.  Remember, eax contains DVSRHI
;

L1:
        mov     ecx,eax         ; ecx:ebx <- divisor
        mov     ebx,LOWORD(DVSR)
        mov     edx,HIWORD(DVND) ; edx:eax <- dividend
        mov     eax,LOWORD(DVND)
L3:
        shr     ecx,1           ; shift divisor right one bit; hi bit <- 0
        rcr     ebx,1
        shr     edx,1           ; shift dividend right one bit; hi bit <- 0
        rcr     eax,1
        or      ecx,ecx
        jnz     short L3        ; loop until divisor < 4194304K
        div     ebx             ; now divide, ignore remainder
        mov     esi,eax         ; save quotient

;
; We may be off by one, so to check, we will multiply the quotient
; by the divisor and check the result against the orignal dividend
; Note that we must also check for overflow, which can occur if the
; dividend is close to 2**64 and the quotient is off by 1.
;

        mul     dword ptr HIWORD(DVSR) ; QUOT * HIWORD(DVSR)
        mov     ecx,eax
        mov     eax,LOWORD(DVSR)
        mul     esi             ; QUOT * LOWORD(DVSR)
        add     edx,ecx         ; EDX:EAX = QUOT * DVSR
        jc      short L4        ; carry means Quotient is off by 1

;
; do long compare here between original dividend and the result of the
; multiply in edx:eax.  If original is larger or equal, we are ok, otherwise
; subtract one (1) from the quotient.
;

        cmp     edx,HIWORD(DVND) ; compare hi words of result and original
        ja      short L4        ; if result > original, do subtract
        jb      short L5        ; if result < original, we are ok
        cmp     eax,LOWORD(DVND) ; hi words are equal, compare lo words
        jbe     short L5        ; if less or equal we are ok, else subtract
L4:
        dec     esi             ; subtract 1 from quotient
L5:
        xor     edx,edx         ; edx:eax <- quotient
        mov     eax,esi

;
; Just the cleanup left to do.  edx:eax contains the quotient.
; Restore the saved registers and return.
;

L2:

        pop     esi
        pop     ebx

        ret     16

_aulldiv        ENDP

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\dispinfo.h ===
/****************************************************************************
 *
 *    File: dispinfo.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about the display(s) on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef DISPINFO_H
#define DISPINFO_H

// DXD_IN_DD_VALUE is the name of a value stored under the registry key 
// HKLM\DXD_IN_DD_KEY that indicates that DxDiag is using
// DirectDraw.  If DxDiag starts up and this value exists, DxDiag 
// probably crashed in DirectDraw and DxDiag should offer to run without
// using DirectDraw.
#define DXD_IN_DD_KEY TEXT("Software\\Microsoft\\DirectX Diagnostic Tool")
#define DXD_IN_DD_VALUE TEXT("DxDiag In DirectDraw")

struct TestResult
{
    BOOL m_bStarted; // has user tried to run test yet?
    BOOL m_bCancelled;
    LONG m_iStepThatFailed;
    HRESULT m_hr;
    TCHAR m_szDescription[300]; // description of test result
    TCHAR m_szDescriptionEnglish[300]; // description of test result, non-localized
};

struct DisplayInfo
{
    GUID m_guid;
    GUID m_guidDeviceIdentifier;
    TCHAR m_szKeyDeviceID[200];
    TCHAR m_szKeyDeviceKey[200];

    TCHAR m_szDeviceName[100];
    TCHAR m_szDescription[200];
    TCHAR m_szManufacturer[200];
    TCHAR m_szChipType[100];
    TCHAR m_szDACType[100];
    TCHAR m_szRevision[100];
    TCHAR m_szDisplayMemory[100];
    TCHAR m_szDisplayMemoryEnglish[100];
    TCHAR m_szDisplayMode[100];
    TCHAR m_szDisplayModeEnglish[100];
    DWORD m_dwWidth;
    DWORD m_dwHeight;
    DWORD m_dwBpp;
    DWORD m_dwRefreshRate;

    TCHAR m_szMonitorName[100];
    TCHAR m_szMonitorKey[200];
    TCHAR m_szMonitorMaxRes[100];
    HMONITOR m_hMonitor;

    TCHAR m_szDriverName[100];
    TCHAR m_szDriverVersion[100];
    TCHAR m_szDriverAttributes[100];
    TCHAR m_szDriverLanguage[100];
    TCHAR m_szDriverLanguageLocal[100];
    TCHAR m_szDriverDate[100];
    TCHAR m_szDriverDateLocal[100];
    LONG m_cbDriver;
    TCHAR m_szDrv[100];
    TCHAR m_szDrv2[100];
    TCHAR m_szMiniVdd[100];
    TCHAR m_szMiniVddDate[100];
    LONG  m_cbMiniVdd;
    TCHAR m_szVdd[100];

    BOOL m_bCanRenderWindow;
    BOOL m_bDriverBeta;
    BOOL m_bDriverDebug;
    BOOL m_bDriverSigned;
    BOOL m_bDriverSignedValid;
    DWORD m_dwDDIVersion;
    TCHAR m_szDDIVersion[100];

    DWORD m_iAdapter;
    TCHAR m_szDX8VendorId[50];
    TCHAR m_szDX8DeviceId[50];
    TCHAR m_szDX8SubSysId[50];
    TCHAR m_szDX8Revision[50];
    GUID  m_guidDX8DeviceIdentifier;
    DWORD m_dwDX8WHQLLevel;
    BOOL  m_bDX8DriverSigned;
    BOOL  m_bDX8DriverSignedValid;
    TCHAR m_szDX8DeviceIdentifier[100];
    TCHAR m_szDX8DriverSignDate[50]; // Valid only if m_bDriverSigned is TRUE

    BOOL m_bNoHardware;
    BOOL m_bDDAccelerationEnabled;
    BOOL m_b3DAccelerationExists;
    BOOL m_b3DAccelerationEnabled;
    BOOL m_bAGPEnabled;
    BOOL m_bAGPExists;
    BOOL m_bAGPExistenceValid; // TRUE if m_bAGPExists can be trusted

    TCHAR m_szDDStatus[100]; 
    TCHAR m_szDDStatusEnglish[100]; 
    TCHAR m_szD3DStatus[100]; 
    TCHAR m_szD3DStatusEnglish[100]; 
    TCHAR m_szAGPStatus[100]; 
    TCHAR m_szAGPStatusEnglish[100]; 

    RegError* m_pRegErrorFirst;
    TCHAR m_szNotes[3000]; 
    TCHAR m_szNotesEnglish[3000]; 

    TestResult m_testResultDD;  // This is filled in by testdd.cpp
    TestResult m_testResultD3D7; // This is filled in by main.cpp (testd3d.cpp)
    TestResult m_testResultD3D8; // This is filled in by main.cpp (testd3d8.cpp)
    DWORD      m_dwTestToDisplayD3D;

    DisplayInfo* m_pDisplayInfoNext;
};

HRESULT GetBasicDisplayInfo(DisplayInfo** ppDisplayInfoFirst);
HRESULT GetExtraDisplayInfo(DisplayInfo* pDisplayInfoFirst);
HRESULT GetDDrawDisplayInfo(DisplayInfo* pDisplayInfoFirst);
VOID DestroyDisplayInfo(DisplayInfo* pDisplayInfoFirst);
BOOL IsDDHWAccelEnabled(VOID);
BOOL IsD3DHWAccelEnabled(VOID);
BOOL IsAGPEnabled(VOID);
VOID DiagnoseDisplay(SysInfo* pSysInfo, DisplayInfo* pDisplayInfoFirst);

#endif // DISPINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\dispinfo8.cpp ===
/****************************************************************************
 *
 *    File: dispinfo8.cpp 
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Jason Sandlin (jasonsa@microsoft.com)
 * Purpose: Gather D3D8 information 
 *
 * (C) Copyright 2000 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <tchar.h>
#include <Windows.h>
#define DIRECT3D_VERSION 0x0800 // file uses DX8 
#include <d3d8.h>
#include <stdio.h>
#include "sysinfo.h" 
#include "reginfo.h"
#include "dispinfo.h"


typedef IDirect3D8* (WINAPI* LPDIRECT3DCREATE8)(UINT SDKVersion);

static BOOL IsMatchWithDisplayDevice( DisplayInfo* pDisplayInfo, HMONITOR hMonitor, BOOL bCanRenderWindow );

static HINSTANCE            s_hInstD3D8               = NULL;
static IDirect3D8*          s_pD3D8                   = NULL;
static BOOL                 s_bD3D8WrongHeaders       = FALSE;


/****************************************************************************
 *
 *  InitD3D8
 *
 ****************************************************************************/
HRESULT InitD3D8()
{
    LPDIRECT3DCREATE8 pD3DCreate8 = NULL;
    TCHAR szPath[MAX_PATH];

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\d3d8.dll"));

    // This may fail if DX8 isn't on the system
    s_hInstD3D8 = LoadLibrary(szPath);
    if (s_hInstD3D8 == NULL)
        return E_FAIL;

    pD3DCreate8 = (LPDIRECT3DCREATE8)GetProcAddress(s_hInstD3D8, "Direct3DCreate8");
    if (pD3DCreate8 == NULL)
    {
        FreeLibrary(s_hInstD3D8);
        s_hInstD3D8 = NULL;

        return E_FAIL;
    }

    s_pD3D8 = pD3DCreate8(D3D_SDK_VERSION);
    if( s_pD3D8 == NULL )
    {
        // We have the wrong headers since d3d8.dll loaded but D3DCreate8() failed.
        s_bD3D8WrongHeaders = TRUE;
    }

    return S_OK;
}


/****************************************************************************
 *
 *  CleanupD3D8
 *
 ****************************************************************************/
VOID CleanupD3D8()
{
    if( s_pD3D8 )
    {
        s_pD3D8->Release();
        s_pD3D8 = NULL;
    }

    if( s_hInstD3D8 )
    {
        FreeLibrary(s_hInstD3D8);
        s_hInstD3D8 = NULL;
    }
}


/****************************************************************************
 *
 *  IsD3D8Working
 *
 ****************************************************************************/
BOOL IsD3D8Working()
{
    if( s_pD3D8 )
        return TRUE;
    else
        return FALSE;
}


/****************************************************************************
 *
 *  GetDX8AdapterInfo
 *
 ****************************************************************************/
HRESULT GetDX8AdapterInfo(DisplayInfo* pDisplayInfo)
{
    UINT                        nAdapterCount;
    D3DADAPTER_IDENTIFIER8      d3d8Id;
    D3DCAPS8                    d3d8Caps;
    UINT                        iAdapter;
    HMONITOR                    hMonitor;
    BOOL                        bCanRenderWindow;
    BOOL                        bIsDDI8;

    // D3D8 may not exist on this system
    if( s_pD3D8 == NULL )
    {
        _tcscpy( pDisplayInfo->m_szDX8DriverSignDate, TEXT("n/a") );
        _tcscpy( pDisplayInfo->m_szDX8VendorId, TEXT("n/a") );
        _tcscpy( pDisplayInfo->m_szDX8DeviceId, TEXT("n/a") );
        _tcscpy( pDisplayInfo->m_szDX8SubSysId, TEXT("n/a") );
        _tcscpy( pDisplayInfo->m_szDX8Revision, TEXT("n/a") );

        if( s_bD3D8WrongHeaders ) 
        {
            _tcscpy( pDisplayInfo->m_szDX8DeviceIdentifier, 
                     TEXT("Could not initialize Direct3D v8. ")
                     TEXT("This program was compiled with header ")
                     TEXT("files that do not match the installed ")
                     TEXT("DirectX DLLs") );
        }
        else
        {
            _tcscpy( pDisplayInfo->m_szDX8DeviceIdentifier, TEXT("n/a") );
        }

        return S_OK;
    }

    // Get the # of adapters on the system
    nAdapterCount = s_pD3D8->GetAdapterCount();

    // For each adapter try to match it to the pDisplayInfo using the HMONTIOR
    for( iAdapter=0; iAdapter<nAdapterCount; iAdapter++ )
    {
        bCanRenderWindow = TRUE;
        bIsDDI8          = FALSE;
       
        // Get the HMONITOR for this adapter
        hMonitor = s_pD3D8->GetAdapterMonitor( iAdapter );

        // Get the caps for this adapter
        ZeroMemory( &d3d8Caps, sizeof(D3DCAPS8) );
        if( SUCCEEDED( s_pD3D8->GetDeviceCaps( iAdapter, D3DDEVTYPE_HAL, &d3d8Caps ) ) )
        {
            // Record if its a non-GDI (Voodoo1/2) card
            bCanRenderWindow = ( (d3d8Caps.Caps2 & D3DCAPS2_CANRENDERWINDOWED) != 0 );

            // Check if its a DDI v8 driver
            bIsDDI8 = ( d3d8Caps.MaxStreams > 0 );   
        }

        // Check to see if the pDisplayInfo matchs with this adapter, 
        // and if not, then keep looking
        if( !IsMatchWithDisplayDevice( pDisplayInfo, hMonitor, bCanRenderWindow ) )
            continue;

        // Record the DDI version if the caps told us 
        if( bIsDDI8 )
            pDisplayInfo->m_dwDDIVersion = 8;

        // Link this iAdapter to this pDisplayInfo
        pDisplayInfo->m_iAdapter = iAdapter;
    
        // Get the D3DADAPTER_IDENTIFIER8 for this adapter 
        ZeroMemory( &d3d8Id, sizeof(D3DADAPTER_IDENTIFIER8) );
        if( SUCCEEDED( s_pD3D8->GetAdapterIdentifier( iAdapter, 0, &d3d8Id ) ) )
        {
            // Copy various IDs
            wsprintf( pDisplayInfo->m_szDX8VendorId, TEXT("0x%04.4X"), d3d8Id.VendorId );
            wsprintf( pDisplayInfo->m_szDX8DeviceId, TEXT("0x%04.4X"), d3d8Id.DeviceId );
            wsprintf( pDisplayInfo->m_szDX8SubSysId, TEXT("0x%08.8X"), d3d8Id.SubSysId );
            wsprintf( pDisplayInfo->m_szDX8Revision, TEXT("0x%04.4X"), d3d8Id.Revision );

            // Copy device GUID
            pDisplayInfo->m_guidDX8DeviceIdentifier = d3d8Id.DeviceIdentifier;
			_stprintf( pDisplayInfo->m_szDX8DeviceIdentifier, TEXT("{%08.8X-%04.4X-%04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}"),
    		       d3d8Id.DeviceIdentifier.Data1, d3d8Id.DeviceIdentifier.Data2, d3d8Id.DeviceIdentifier.Data3,
    		       d3d8Id.DeviceIdentifier.Data4[0], d3d8Id.DeviceIdentifier.Data4[1],
    		       d3d8Id.DeviceIdentifier.Data4[2], d3d8Id.DeviceIdentifier.Data4[3],
		           d3d8Id.DeviceIdentifier.Data4[4], d3d8Id.DeviceIdentifier.Data4[5],
		           d3d8Id.DeviceIdentifier.Data4[6], d3d8Id.DeviceIdentifier.Data4[7] );			
		           
            // Copy and parse the WHQLLevel 
            // 0 == Not signed. 
            // 1 == WHQL signed, but no date information is available. 
            // >1   means signed, date bit packed
            pDisplayInfo->m_dwDX8WHQLLevel  = d3d8Id.WHQLLevel;
            if( d3d8Id.WHQLLevel == 0 )
            {
                pDisplayInfo->m_bDX8DriverSigned = FALSE;
                pDisplayInfo->m_bDX8DriverSignedValid = TRUE;
            }
            else
            {
                pDisplayInfo->m_bDX8DriverSigned = TRUE;
                pDisplayInfo->m_bDX8DriverSignedValid = TRUE;

                pDisplayInfo->m_bDriverSigned = TRUE;
                pDisplayInfo->m_bDriverSignedValid = TRUE;

                if( d3d8Id.WHQLLevel == 1 )
                {
                    lstrcpy( pDisplayInfo->m_szDX8DriverSignDate, TEXT("n/a") );
                }
                else
                {
                    // Bits encoded as:
                    // 31-16:    The year, a decimal number from 1999 upwards.
                    // 15-8:     The month, a decimal number from 1 to 12.
                    // 7-0:      The day, a decimal number from 1 to 31.

                    DWORD dwMonth, dwDay, dwYear;
                    dwYear  = (d3d8Id.WHQLLevel >> 16);
                    dwMonth = (d3d8Id.WHQLLevel >>  8) & 0x000F;
                    dwDay   = (d3d8Id.WHQLLevel >>  0) & 0x000F;

                    wsprintf( pDisplayInfo->m_szDX8DriverSignDate, 
                              TEXT("%d/%d/%d"), dwMonth, dwDay, dwYear );
                }
            }
        }

        return S_OK;
    }

    // Hmm.  This shouldn't happen since we should have found a match...        
    return E_FAIL;
}


/****************************************************************************
 *
 *  IsMatchWithDisplayDevice
 *
 ****************************************************************************/
BOOL IsMatchWithDisplayDevice( DisplayInfo* pDisplayInfo, HMONITOR hMonitor, 
                               BOOL bCanRenderWindow )
{
    // If the HMONITORs and the bCanRenderWindow match, then its good
    if( pDisplayInfo->m_hMonitor == hMonitor && 
        pDisplayInfo->m_bCanRenderWindow == bCanRenderWindow )
        return TRUE;
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\dispinfo8.h ===
/****************************************************************************
 *
 *    File: dispinfo8.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Jason Sandlin (jasonsa@microsoft.com)
 * Purpose: Gather D3D8 information 
 *
 * (C) Copyright 2000 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef DISPINFO8_H
#define DISPINFO8_H

HRESULT InitD3D8();
VOID    CleanupD3D8();
HRESULT GetDX8AdapterInfo(DisplayInfo* pDisplayInfo);
BOOL    IsD3D8Working();

#endif // DISPINFO8_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\dispinfo.cpp ===
/****************************************************************************
 *
 *    File: dispinfo.cpp 
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about the display(s) on this machine
 *
 * (C) Copyright 1998-1999 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <tchar.h>
#include <Windows.h>
#define COMPILE_MULTIMON_STUBS // for multimon.h
#include <multimon.h>
#define DIRECTDRAW_VERSION 5 // run on DX5 and later versions
#include <ddraw.h>
#include <d3d.h>
#include <stdio.h>
#include "sysinfo.h" // for BIsPlatformNT
#include "reginfo.h"
#include "dispinfo.h"
#include "dispinfo8.h"
#include "fileinfo.h" // for GetFileVersion
#include "sysinfo.h"
#include "resource.h"


// Taken from DirectDraw's ddcreate.c
// This is the first GUID of secondary display devices
static const GUID DisplayGUID =
    {0x67685559,0x3106,0x11d0,{0xb9,0x71,0x0,0xaa,0x0,0x34,0x2f,0x9f}};

typedef HRESULT (WINAPI* LPDIRECTDRAWCREATE)(GUID FAR *lpGUID,
    LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter);

static VOID GetRegDisplayInfo9x(DisplayInfo* pDisplayInfo);
static VOID GetRegDisplayInfoNT(DisplayInfo* pDisplayInfo);
static HRESULT GetDirectDrawInfo(LPDIRECTDRAWCREATE pDDCreate, DisplayInfo* pDisplayInfo);
static HRESULT CALLBACK EnumDevicesCallback(GUID* pGuid, LPSTR pszDesc, LPSTR pszName, 
    D3DDEVICEDESC* pd3ddevdesc1, D3DDEVICEDESC* pd3ddevdesc2, VOID* pvContext);
static BOOL FindDevice(INT iDevice, TCHAR* pszDeviceClass, TCHAR* pszDeviceClassNot, TCHAR* pszHardwareKey);
static BOOL GetDeviceValue(TCHAR* pszHardwareKey, TCHAR* pszKey, TCHAR* pszValue, BYTE *buf, DWORD cbbuf);
static HRESULT CheckRegistry(RegError** ppRegErrorFirst);
static BOOL CALLBACK MonitorEnumProc( HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData );
static VOID GetRegDisplayInfoWhistler(DisplayInfo* pDisplayInfo, TCHAR* szKeyVideo, TCHAR* szKeyImage );
static VOID GetRegDisplayInfoWin2k(DisplayInfo* pDisplayInfo, TCHAR* szKeyVideo, TCHAR* szKeyImage );



/****************************************************************************
 *
 *  GetBasicDisplayInfo - Get minimal info on each display
 *
 ****************************************************************************/
HRESULT GetBasicDisplayInfo(DisplayInfo** ppDisplayInfoFirst)
{
    DisplayInfo* pDisplayInfo;
    DisplayInfo* pDisplayInfoNew;

    TCHAR szHardwareKey[MAX_PATH];
    TCHAR szDriver[MAX_PATH];
    
    // Check OS version.  Win95 cannot use EnumDisplayDevices; Win98/NT5 can:
    if( BIsWinNT() || BIsWin3x() )
        return S_OK; // NT4 and earlier and pre-Win95 not supported

    if( BIsWin95() )
    {
        // Win95:
        if (!FindDevice(0, TEXT("Display"), NULL, szHardwareKey))
            return E_FAIL;
        pDisplayInfoNew = new DisplayInfo;
        if (pDisplayInfoNew == NULL)
            return E_OUTOFMEMORY;
        ZeroMemory(pDisplayInfoNew, sizeof(DisplayInfo));
        *ppDisplayInfoFirst = pDisplayInfoNew;
        pDisplayInfoNew->m_bCanRenderWindow = TRUE;
        pDisplayInfoNew->m_hMonitor         = NULL; // Win95 doesn't like multimon
        lstrcpy(pDisplayInfoNew->m_szKeyDeviceID, szHardwareKey);
        if (GetDeviceValue(szHardwareKey, NULL, TEXT("Driver"), (LPBYTE)szDriver, sizeof(szDriver)))
        {
            lstrcpy(pDisplayInfoNew->m_szKeyDeviceKey, TEXT("System\\CurrentControlSet\\Services\\Class\\"));
            lstrcat(pDisplayInfoNew->m_szKeyDeviceKey, szDriver);
        }
        GetDeviceValue(szHardwareKey, NULL, TEXT("DeviceDesc"), (LPBYTE)pDisplayInfoNew->m_szDescription, sizeof(pDisplayInfoNew->m_szDescription));

        HDC hdc;
        hdc = GetDC(NULL);
        if (hdc != NULL)
        {
            wsprintf(pDisplayInfoNew->m_szDisplayMode, TEXT("%d x %d (%d bit)"),
                GetDeviceCaps(hdc, HORZRES), GetDeviceCaps(hdc, VERTRES), GetDeviceCaps(hdc, BITSPIXEL));
            lstrcpy( pDisplayInfoNew->m_szDisplayModeEnglish, pDisplayInfoNew->m_szDisplayMode );
            ReleaseDC(NULL, hdc);
            pDisplayInfoNew->m_dwWidth = GetDeviceCaps(hdc, HORZRES);
            pDisplayInfoNew->m_dwHeight = GetDeviceCaps(hdc, VERTRES);
            pDisplayInfoNew->m_dwBpp = GetDeviceCaps(hdc, BITSPIXEL);
        }

        // On Win98 and NT, we get the monitor key through a call to EnumDisplayDevices.
        // On Win95, we have to use the registry to get the monitor key.
        HKEY hKey = NULL;
        DWORD cbData;
        TCHAR szKey[200];
        ULONG ulType;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Enum\\MONITOR\\DEFAULT_MONITOR\\0001"), 0, KEY_READ, &hKey))
        {
            cbData = sizeof szKey;
            
            if (ERROR_SUCCESS == RegQueryValueEx(hKey, TEXT("Driver"), 0, &ulType, (LPBYTE)szKey, &cbData)
                && szKey[0])
            {
                lstrcpy(pDisplayInfoNew->m_szMonitorKey, TEXT("System\\CurrentControlSet\\Services\\Class\\"));
                lstrcat(pDisplayInfoNew->m_szMonitorKey, szKey);
            }
            RegCloseKey(hKey);
        }
    }
    else
    {
        // Win98 / NT5: 
        LONG iDevice = 0;
        DISPLAY_DEVICE dispdev;
        DISPLAY_DEVICE dispdev2;

        ZeroMemory(&dispdev, sizeof(dispdev));
        dispdev.cb = sizeof(dispdev);

        ZeroMemory(&dispdev2, sizeof(dispdev2));
        dispdev2.cb = sizeof(dispdev2);

        while (EnumDisplayDevices(NULL, iDevice, (DISPLAY_DEVICE*)&dispdev, 0))
        {
            // Mirroring drivers are for monitors that echo another display, so
            // they should be ignored.  NT5 seems to create a mirroring driver called
            // "NetMeeting driver", and we definitely don't want that.
            if (dispdev.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)
            {
                iDevice++;
                continue;
            }

            // Skip devices that aren't attached since they cause problems 
            if ( (dispdev.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) == 0 )
            {
                iDevice++;
                continue;
            }

            pDisplayInfoNew = new DisplayInfo;
            if (pDisplayInfoNew == NULL)
                return E_OUTOFMEMORY;
            ZeroMemory(pDisplayInfoNew, sizeof(DisplayInfo));
            if (*ppDisplayInfoFirst == NULL)
            {
                *ppDisplayInfoFirst = pDisplayInfoNew;
            }
            else
            {
                for (pDisplayInfo = *ppDisplayInfoFirst; 
                    pDisplayInfo->m_pDisplayInfoNext != NULL; 
                    pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext)
                    {
                    }
                pDisplayInfo->m_pDisplayInfoNext = pDisplayInfoNew;
            }
            pDisplayInfoNew->m_bCanRenderWindow = TRUE;
            pDisplayInfoNew->m_guid = DisplayGUID;
            pDisplayInfoNew->m_guid.Data1 += iDevice;
            lstrcpy(pDisplayInfoNew->m_szDeviceName, dispdev.DeviceName);
            lstrcpy(pDisplayInfoNew->m_szDescription, dispdev.DeviceString);
            lstrcpy(pDisplayInfoNew->m_szKeyDeviceID, TEXT("Enum\\"));
            lstrcat(pDisplayInfoNew->m_szKeyDeviceID, dispdev.DeviceID);
            lstrcpy(pDisplayInfoNew->m_szKeyDeviceKey, dispdev.DeviceKey);

            DEVMODE devmode;
            ZeroMemory(&devmode, sizeof(devmode));
            devmode.dmSize = sizeof(devmode);

            if (EnumDisplaySettings(dispdev.DeviceName, ENUM_CURRENT_SETTINGS, &devmode))
            {
                pDisplayInfoNew->m_dwWidth = devmode.dmPelsWidth;
                pDisplayInfoNew->m_dwHeight = devmode.dmPelsHeight;
                pDisplayInfoNew->m_dwBpp = devmode.dmBitsPerPel;
                wsprintf(pDisplayInfoNew->m_szDisplayMode, TEXT("%d x %d (%d bit)"),
                    devmode.dmPelsWidth, devmode.dmPelsHeight, devmode.dmBitsPerPel);
                lstrcpy( pDisplayInfoNew->m_szDisplayModeEnglish, pDisplayInfoNew->m_szDisplayMode );
                if (devmode.dmDisplayFrequency > 0)
                {
                    TCHAR sz[10];
                    wsprintf(sz, TEXT(" (%dHz)"), devmode.dmDisplayFrequency);
                    lstrcat(pDisplayInfoNew->m_szDisplayMode, sz);
                    lstrcat(pDisplayInfoNew->m_szDisplayModeEnglish, sz);
                    pDisplayInfoNew->m_dwRefreshRate = devmode.dmDisplayFrequency;
                }
            }

            // Call EnumDisplayDevices a second time to get monitor name and monitor key
            if (EnumDisplayDevices(dispdev.DeviceName, 0, &dispdev2, 0))
            {
                lstrcpy(pDisplayInfoNew->m_szMonitorName, dispdev2.DeviceString);
                lstrcpy(pDisplayInfoNew->m_szMonitorKey, dispdev2.DeviceKey);
            }

            // Try to figure out the m_hMonitor
            pDisplayInfoNew->m_hMonitor = NULL; 
            EnumDisplayMonitors( NULL, NULL, MonitorEnumProc, (LPARAM) pDisplayInfoNew );

            iDevice++;
        }
    }

    // Now look for non-display devices (like 3dfx Voodoo):
    HKEY hkey;
    HKEY hkey2;
    DWORD dwIndex;
    TCHAR szName[MAX_PATH+1];
    DWORD cb;
    DWORD dwType;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("Hardware\\DirectDrawDrivers"), &hkey))
    {
        dwIndex = 0;
        while (ERROR_SUCCESS == RegEnumKey(hkey, dwIndex, szName, MAX_PATH+1))
        {
            BOOL bGoodDevice = FALSE;
            TCHAR szDriverName[200];
            HDC hdc;

            if (lstrcmp(szName, TEXT("3a0cfd01-9320-11cf-ac-a1-00-a0-24-13-c2-e2")) == 0 ||
                lstrcmp(szName, TEXT("aba52f41-f744-11cf-b4-52-00-00-1d-1b-41-26")) == 0)
            {
                // 24940: It's a Voodoo1, which will succeed GetDC (and crash later) if
                // no Voodoo1 is present but a Voodoo2 is.  So instead of the GetDC test,
                // see if a V1 is present in registry's CurrentConfig.
                INT i;
                for (i=0 ; ; i++)
                {
                    TCHAR szDevice[MAX_DDDEVICEID_STRING];
                    if (FindDevice(i, NULL, TEXT("Display"), szDevice))
                    {
                        if (_tcsstr(szDevice, TEXT("VEN_121A&DEV_0001")) != NULL)
                        {
                            bGoodDevice = TRUE;
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                }
            }
            else
            {
                // To confirm that this is a real active DD device, create a DC with it
                if (ERROR_SUCCESS == RegOpenKey(hkey, szName, &hkey2))
                {
                    cb = 200;
                    if (ERROR_SUCCESS == RegQueryValueEx(hkey2, TEXT("DriverName"), NULL, &dwType,
                        (CONST LPBYTE)szDriverName, &cb) && cb > 0)
                    {
                        // I think the following "if" will always fail, but we're about to ship so
                        // I'm being paranoid and doing everything that DDraw does:
                        if (szDriverName[0] == '\\' && szDriverName[1] == '\\' && szDriverName[2] == '.')
                            hdc = CreateDC( NULL, szDriverName, NULL, NULL);
                        else
                            hdc = CreateDC( szDriverName, NULL, NULL, NULL);
                        if (hdc != NULL)
                        {
                            bGoodDevice = TRUE;
                            DeleteDC(hdc);
                        }
                    }
                    RegCloseKey(hkey2);
                }
            }

            if (!bGoodDevice)
            {
                dwIndex++;
                continue;
            }

            pDisplayInfoNew = new DisplayInfo;
            if (pDisplayInfoNew == NULL)
                return E_OUTOFMEMORY;
            ZeroMemory(pDisplayInfoNew, sizeof(DisplayInfo));
            if (*ppDisplayInfoFirst == NULL)
            {
                *ppDisplayInfoFirst = pDisplayInfoNew;
            }
            else
            {
                for (pDisplayInfo = *ppDisplayInfoFirst; 
                    pDisplayInfo->m_pDisplayInfoNext != NULL; 
                    pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext)
                    {
                    }
                pDisplayInfo->m_pDisplayInfoNext = pDisplayInfoNew;
            }
            pDisplayInfoNew->m_bCanRenderWindow = FALSE;
            pDisplayInfoNew->m_hMonitor         = NULL;
            _stscanf(szName, TEXT("%08x-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x"),
                &pDisplayInfoNew->m_guid.Data1,
                &pDisplayInfoNew->m_guid.Data2,
                &pDisplayInfoNew->m_guid.Data3,
                &pDisplayInfoNew->m_guid.Data4[0],
                &pDisplayInfoNew->m_guid.Data4[1],
                &pDisplayInfoNew->m_guid.Data4[2],
                &pDisplayInfoNew->m_guid.Data4[3],
                &pDisplayInfoNew->m_guid.Data4[4],
                &pDisplayInfoNew->m_guid.Data4[5],
                &pDisplayInfoNew->m_guid.Data4[6],
                &pDisplayInfoNew->m_guid.Data4[7]);
            if (ERROR_SUCCESS == RegOpenKey(hkey, szName, &hkey2))
            {
                cb = sizeof(pDisplayInfoNew->m_szDescription);
                RegQueryValueEx(hkey2, TEXT("Description"), NULL, &dwType, (LPBYTE)pDisplayInfoNew->m_szDescription, &cb);

                cb = sizeof(pDisplayInfoNew->m_szDriverName);
                RegQueryValueEx(hkey2, TEXT("DriverName"), NULL, &dwType, (LPBYTE)pDisplayInfoNew->m_szDriverName, &cb);

                RegCloseKey(hkey2);
            }
            dwIndex++;
        }
        RegCloseKey(hkey);
    }

    return S_OK;
}


/****************************************************************************
 *
 *  MonitorEnumProc
 *
 ****************************************************************************/
BOOL CALLBACK MonitorEnumProc( HMONITOR hMonitor, HDC hdcMonitor, 
                               LPRECT lprcMonitor, LPARAM dwData )
{
    DisplayInfo* pDisplayInfoNew = (DisplayInfo*) dwData;    

    // Get the MONITORINFOEX for this HMONITOR
    MONITORINFOEX monInfo;
    ZeroMemory( &monInfo, sizeof(MONITORINFOEX) );
    monInfo.cbSize = sizeof(MONITORINFOEX);
    GetMonitorInfo( hMonitor, &monInfo );

    // Compare the display device for this HMONITOR and the one 
    // we just enumed with EnumDisplayDevices
    if( lstrcmp( monInfo.szDevice, pDisplayInfoNew->m_szDeviceName ) == 0 )
    {
        // If they match, then record the HMONITOR 
        pDisplayInfoNew->m_hMonitor = hMonitor;
        return FALSE;
    }

    // Keep looking...
    return TRUE;
}


/****************************************************************************
 *
 *  GetExtraDisplayInfo
 *
 ****************************************************************************/
HRESULT GetExtraDisplayInfo(DisplayInfo* pDisplayInfoFirst)
{
    HRESULT hr;
    DisplayInfo* pDisplayInfo;
    BOOL bDDAccelEnabled;
    BOOL bD3DAccelEnabled;
    BOOL bAGPEnabled;
    BOOL bNT = BIsPlatformNT();

    bDDAccelEnabled = IsDDHWAccelEnabled();
    bD3DAccelEnabled = IsD3DHWAccelEnabled();
    bAGPEnabled = IsAGPEnabled();

    for (pDisplayInfo = pDisplayInfoFirst; pDisplayInfo != NULL; 
        pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext)
    {
        if (bNT)
            GetRegDisplayInfoNT(pDisplayInfo);
        else
            GetRegDisplayInfo9x(pDisplayInfo);
        pDisplayInfo->m_bDDAccelerationEnabled = bDDAccelEnabled;
        pDisplayInfo->m_b3DAccelerationEnabled = bD3DAccelEnabled;
        pDisplayInfo->m_bAGPEnabled = bAGPEnabled;

        if (FAILED(hr = CheckRegistry(&pDisplayInfo->m_pRegErrorFirst)))
            return hr;
    }

    return S_OK;
}


/****************************************************************************
 *
 *  GetDDrawDisplayInfo
 *
 ****************************************************************************/
HRESULT GetDDrawDisplayInfo(DisplayInfo* pDisplayInfoFirst)
{
    HRESULT hr;
    HRESULT hrRet = S_OK;
    DisplayInfo* pDisplayInfo;
    TCHAR szPath[MAX_PATH];
    HINSTANCE hInstDDraw;
    LPDIRECTDRAWCREATE pDDCreate;

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\ddraw.dll"));
    hInstDDraw = LoadLibrary(szPath);
    if (hInstDDraw == NULL)
        return E_FAIL;
    pDDCreate = (LPDIRECTDRAWCREATE)GetProcAddress(hInstDDraw, "DirectDrawCreate");
    if (pDDCreate == NULL)
    {
        FreeLibrary(hInstDDraw);
        return E_FAIL;
    }
    
    // Init D3D8 so we can use GetDX8AdapterInfo()
    InitD3D8();

    for (pDisplayInfo = pDisplayInfoFirst; pDisplayInfo != NULL; 
        pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext)
    {
        pDisplayInfo->m_b3DAccelerationExists = FALSE; // until proven otherwise
        if (FAILED(hr = GetDirectDrawInfo(pDDCreate, pDisplayInfo)))
            hrRet = hr; // but keep going
    }

    // Cleanup the D3D8 library
    CleanupD3D8();

    FreeLibrary(hInstDDraw);

    return hrRet;
}


/****************************************************************************
 *
 *  DestroyDisplayInfo
 *
 ****************************************************************************/
VOID DestroyDisplayInfo(DisplayInfo* pDisplayInfoFirst)
{
    DisplayInfo* pDisplayInfo;
    DisplayInfo* pDisplayInfoNext;

    for (pDisplayInfo = pDisplayInfoFirst; pDisplayInfo != NULL; 
        pDisplayInfo = pDisplayInfoNext)
    {
        DestroyReg( &pDisplayInfo->m_pRegErrorFirst );

        pDisplayInfoNext = pDisplayInfo->m_pDisplayInfoNext;
        delete pDisplayInfo;
    }
}



/****************************************************************************
 *
 *  GetRegDisplayInfo9x - Uses the registry keys to get more info about a 
 *      display adapter.
 *
 ****************************************************************************/
VOID GetRegDisplayInfo9x(DisplayInfo* pDisplayInfo)
{
    TCHAR szFullKey[200];
    HKEY hkey;
    DWORD cbData;
    DWORD dwType;

    // set to n/a by default
    _tcscpy( pDisplayInfo->m_szMiniVddDate, TEXT("n/a") );

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, pDisplayInfo->m_szKeyDeviceID, 0, KEY_READ, &hkey))
    {
        cbData = sizeof(pDisplayInfo->m_szManufacturer);
        RegQueryValueEx(hkey, TEXT("Mfg"), 0, &dwType, (LPBYTE)pDisplayInfo->m_szManufacturer, &cbData);
    
        RegCloseKey(hkey);
    }

    if (pDisplayInfo->m_dwRefreshRate == 0)
    {
        wsprintf(szFullKey, TEXT("%s\\Modes\\%d\\%d,%d"), pDisplayInfo->m_szKeyDeviceKey,
            pDisplayInfo->m_dwBpp, pDisplayInfo->m_dwWidth, pDisplayInfo->m_dwHeight);
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szFullKey, 0, KEY_READ, &hkey))
        {
            TCHAR szRefresh[100];
            TCHAR szRefresh2[100];
            TCHAR szRefreshEnglish2[100];
            cbData = sizeof(szRefresh);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("RefreshRate"), 0, &dwType, (LPBYTE)szRefresh, &cbData))
            {
                _stscanf(szRefresh, TEXT("%d"), &pDisplayInfo->m_dwRefreshRate);
                if (lstrcmp(szRefresh, TEXT("0")) == 0)
                    LoadString(NULL, IDS_DEFAULTREFRESH, szRefresh2, 100);
                else if (lstrcmp(szRefresh, TEXT("-1")) == 0)
                    LoadString(NULL, IDS_OPTIMALREFRESH, szRefresh2, 100);
                else
                    wsprintf(szRefresh2, TEXT("(%sHz)"), szRefresh);
                lstrcat(pDisplayInfo->m_szDisplayMode, TEXT(" "));
                lstrcat(pDisplayInfo->m_szDisplayMode, szRefresh2);

                if (lstrcmp(szRefresh, TEXT("0")) == 0)
                    LoadString(NULL, IDS_DEFAULTREFRESH_ENGLISH, szRefreshEnglish2, 100);
                else if (lstrcmp(szRefresh, TEXT("-1")) == 0)
                    LoadString(NULL, IDS_OPTIMALREFRESH_ENGLISH, szRefreshEnglish2, 100);
                else
                    wsprintf(szRefreshEnglish2, TEXT("(%sHz)"), szRefresh);
                lstrcat(pDisplayInfo->m_szDisplayModeEnglish, szRefreshEnglish2);
                lstrcat(pDisplayInfo->m_szDisplayModeEnglish, TEXT(" "));

                if (pDisplayInfo->m_dwRefreshRate == 0)
                    pDisplayInfo->m_dwRefreshRate = 1; // 23399: so it doesn't check again
            }
            RegCloseKey(hkey);
        }
    }
    lstrcpy(szFullKey, pDisplayInfo->m_szKeyDeviceKey);
    lstrcat(szFullKey, TEXT("\\DEFAULT"));
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szFullKey, 0, KEY_READ, &hkey))
    {
        // If no specific refresh rate was listed for the current mode, report the
        // default rate.
        if (pDisplayInfo->m_dwRefreshRate == 0)
        {
            TCHAR szRefresh[100];
            TCHAR szRefresh2[100];
            TCHAR szRefreshEnglish2[100];
            cbData = sizeof(szRefresh);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("RefreshRate"), 0, &dwType, (LPBYTE)szRefresh, &cbData))
            {
                if (lstrcmp(szRefresh, TEXT("0")) == 0)
                    LoadString(NULL, IDS_DEFAULTREFRESH, szRefresh2, 100);
                else if (lstrcmp(szRefresh, TEXT("-1")) == 0)
                    LoadString(NULL, IDS_OPTIMALREFRESH, szRefresh2, 100);
                else
                    wsprintf(szRefresh2, TEXT("(%sHz)"), szRefresh);
                lstrcat(pDisplayInfo->m_szDisplayMode, TEXT(" "));
                lstrcat(pDisplayInfo->m_szDisplayMode, szRefresh2);

                if (lstrcmp(szRefresh, TEXT("0")) == 0)
                    LoadString(NULL, IDS_DEFAULTREFRESH_ENGLISH, szRefreshEnglish2, 100);
                else if (lstrcmp(szRefresh, TEXT("-1")) == 0)
                    LoadString(NULL, IDS_OPTIMALREFRESH_ENGLISH, szRefreshEnglish2, 100);
                else
                    wsprintf(szRefreshEnglish2, TEXT("(%sHz)"), szRefresh);
                lstrcat(pDisplayInfo->m_szDisplayModeEnglish, szRefreshEnglish2);
                lstrcat(pDisplayInfo->m_szDisplayModeEnglish, TEXT(" "));

                if (pDisplayInfo->m_dwRefreshRate == 0)
                    pDisplayInfo->m_dwRefreshRate = 1; // 23399: so it doesn't check again
            }
        }

        cbData = sizeof(pDisplayInfo->m_szDriverName);
        RegQueryValueEx(hkey, TEXT("drv"), 0, &dwType, (LPBYTE)pDisplayInfo->m_szDriverName, &cbData);
        if (lstrlen(pDisplayInfo->m_szDriverName) > 0)
        {
            TCHAR szPath[MAX_PATH];
            GetSystemDirectory(szPath, MAX_PATH);
            lstrcat(szPath, TEXT("\\"));
            lstrcat(szPath, pDisplayInfo->m_szDriverName);
            GetFileVersion(szPath, pDisplayInfo->m_szDriverVersion, 
                pDisplayInfo->m_szDriverAttributes, pDisplayInfo->m_szDriverLanguageLocal, pDisplayInfo->m_szDriverLanguage,
                &pDisplayInfo->m_bDriverBeta, &pDisplayInfo->m_bDriverDebug);
            FileIsSigned(szPath, &pDisplayInfo->m_bDriverSigned, &pDisplayInfo->m_bDriverSignedValid);
            GetFileDateAndSize(szPath, pDisplayInfo->m_szDriverDateLocal, pDisplayInfo->m_szDriverDate, &pDisplayInfo->m_cbDriver);
        }
    
        cbData = sizeof(pDisplayInfo->m_szVdd);
        RegQueryValueEx(hkey, TEXT("vdd"), 0, &dwType, (LPBYTE)pDisplayInfo->m_szVdd, &cbData);
    
        cbData = sizeof(pDisplayInfo->m_szMiniVdd);
        RegQueryValueEx(hkey, TEXT("minivdd"), 0, &dwType, (LPBYTE)pDisplayInfo->m_szMiniVdd, &cbData);
        if (lstrlen(pDisplayInfo->m_szMiniVdd) > 0)
        {
            TCHAR szPath[MAX_PATH];
            GetSystemDirectory(szPath, MAX_PATH);
            lstrcat(szPath, TEXT("\\drivers\\"));
            lstrcat(szPath, pDisplayInfo->m_szMiniVdd);
            TCHAR szDateLocal[100];
            GetFileDateAndSize( szPath, szDateLocal, pDisplayInfo->m_szMiniVddDate, 
                                &pDisplayInfo->m_cbMiniVdd );
        }
   
        RegCloseKey(hkey);
    }
    lstrcpy(szFullKey, pDisplayInfo->m_szKeyDeviceKey);
    lstrcat(szFullKey, TEXT("\\INFO"));
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szFullKey, 0, KEY_READ, &hkey))
    {
        cbData = sizeof pDisplayInfo->m_szChipType;
        RegQueryValueEx(hkey, TEXT("ChipType"), 0, &dwType, (LPBYTE)pDisplayInfo->m_szChipType, &cbData);

        cbData = sizeof pDisplayInfo->m_szDACType;
        RegQueryValueEx(hkey, TEXT("DACType"), 0, &dwType, (LPBYTE)pDisplayInfo->m_szDACType, &cbData);

        cbData = sizeof pDisplayInfo->m_szRevision;
        RegQueryValueEx(hkey, TEXT("Revision"), 0, &dwType, (LPBYTE)pDisplayInfo->m_szRevision, &cbData);
        if (cbData > 0)
        {
            lstrcat(pDisplayInfo->m_szChipType, TEXT(" Rev "));
            lstrcat(pDisplayInfo->m_szChipType, pDisplayInfo->m_szRevision);
        }

        RegCloseKey(hkey);
    }

    if (lstrlen(pDisplayInfo->m_szDriverVersion) == 0)
    {
        TCHAR szPath[MAX_PATH];
        GetSystemDirectory(szPath, MAX_PATH);
        lstrcat(szPath, TEXT("\\"));
        lstrcat(szPath, pDisplayInfo->m_szDriverName);
        lstrcat(szPath, TEXT(".drv"));
        GetFileVersion(szPath, pDisplayInfo->m_szDriverVersion, 
            pDisplayInfo->m_szDriverAttributes, pDisplayInfo->m_szDriverLanguageLocal, pDisplayInfo->m_szDriverLanguage);
        FileIsSigned(szPath, &pDisplayInfo->m_bDriverSigned, &pDisplayInfo->m_bDriverSignedValid);
        GetFileDateAndSize(szPath, pDisplayInfo->m_szDriverDateLocal, pDisplayInfo->m_szDriverDate, &pDisplayInfo->m_cbDriver);
        if (lstrlen(pDisplayInfo->m_szDriverVersion) != 0)
        {
            lstrcat(pDisplayInfo->m_szDriverName, TEXT(".drv"));
        }
        else
        {
            GetSystemDirectory(szPath, MAX_PATH);
            lstrcat(szPath, TEXT("\\"));
            lstrcat(szPath, pDisplayInfo->m_szDriverName);
            lstrcat(szPath, TEXT("32.dll"));
            GetFileVersion(szPath, pDisplayInfo->m_szDriverVersion, 
                pDisplayInfo->m_szDriverAttributes, pDisplayInfo->m_szDriverLanguageLocal, pDisplayInfo->m_szDriverLanguage);
            FileIsSigned(szPath, &pDisplayInfo->m_bDriverSigned, &pDisplayInfo->m_bDriverSignedValid);
            GetFileDateAndSize(szPath, pDisplayInfo->m_szDriverDateLocal, pDisplayInfo->m_szDriverDate, &pDisplayInfo->m_cbDriver);
            if (lstrlen(pDisplayInfo->m_szDriverVersion) != 0)
            {
                lstrcat(pDisplayInfo->m_szDriverName, TEXT("32.dll"));
            }
            else
            {
                GetSystemDirectory(szPath, MAX_PATH);
                lstrcat(szPath, TEXT("\\"));
                lstrcat(szPath, pDisplayInfo->m_szDriverName);
                lstrcat(szPath, TEXT(".dll"));
                GetFileVersion(szPath, pDisplayInfo->m_szDriverVersion, 
                    pDisplayInfo->m_szDriverAttributes, pDisplayInfo->m_szDriverLanguageLocal, pDisplayInfo->m_szDriverLanguage);
                FileIsSigned(szPath, &pDisplayInfo->m_bDriverSigned, &pDisplayInfo->m_bDriverSignedValid);
                GetFileDateAndSize(szPath, pDisplayInfo->m_szDriverDateLocal, pDisplayInfo->m_szDriverDate, &pDisplayInfo->m_cbDriver);
                if (lstrlen(pDisplayInfo->m_szDriverVersion) != 0)
                {
                    lstrcat(pDisplayInfo->m_szDriverName, TEXT(".dll"));
                }
            }

        }
    }

    // Use monitor key to get monitor max resolution (and monitor name, if we don't have it yet)
    if (lstrlen(pDisplayInfo->m_szMonitorKey) > 0)
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, pDisplayInfo->m_szMonitorKey, 0, KEY_READ, &hkey))
        {
            cbData = sizeof(pDisplayInfo->m_szMonitorMaxRes);
            RegQueryValueEx(hkey, TEXT("MaxResolution"), 0, &dwType, (LPBYTE)pDisplayInfo->m_szMonitorMaxRes, &cbData);
            if (lstrlen(pDisplayInfo->m_szMonitorName) == 0)
            {
                cbData = sizeof(pDisplayInfo->m_szMonitorName);
                RegQueryValueEx(hkey, TEXT("DriverDesc"), 0, &dwType, (LPBYTE)pDisplayInfo->m_szMonitorName, &cbData);
            }
            RegCloseKey(hkey);
        }
    }
}




/****************************************************************************
 *
 *  GetRegDisplayInfoNT - Uses the registry keys to get more info about a 
 *      display adapter.
 *
 ****************************************************************************/
VOID GetRegDisplayInfoNT(DisplayInfo* pDisplayInfo)
{
    TCHAR* pch;
    DWORD dwType;
    DWORD cbData;
    TCHAR szKeyVideo[MAX_PATH+1];
    TCHAR szKeyImage[MAX_PATH+1];
    TCHAR szKey[MAX_PATH+1];
    TCHAR szName[MAX_PATH+1];
    HKEY hkey;
    HKEY hkeyInfo;

    // set to n/a by default
    _tcscpy( pDisplayInfo->m_szMiniVddDate, TEXT("n/a") );

    // On NT, m_szKeyDeviceID isn't quite as specific as we need--must go 
    // one level further in the registry.
    lstrcpy(szKey, TEXT("System\\CurrentControlSet\\"));
    lstrcat(szKey, pDisplayInfo->m_szKeyDeviceID);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hkey))
    {
        if (ERROR_SUCCESS == RegEnumKey(hkey, 0, szName, MAX_PATH+1))
        {
            if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szName, 0, KEY_READ, &hkeyInfo))
            {
                cbData = sizeof(pDisplayInfo->m_szManufacturer);
                RegQueryValueEx(hkeyInfo, TEXT("Mfg"), 0, &dwType, (LPBYTE)pDisplayInfo->m_szManufacturer, &cbData);
            
                RegCloseKey(hkeyInfo);
            }
        }
        RegCloseKey(hkey);
    }

    // Forked path due to bug 182866: dispinfo.cpp makes an invalid assumption 
    // about the structure of video key.  

    // szKey will be filled with where the video info is.  
    // either "\System\ControlSet001\Services\[Service]\Device0",
    // or "\System\ControlSet001\Video\[GUID]\0000" depending on
    // pDisplayInfo->m_szKeyDeviceKey
    if( _tcsstr( pDisplayInfo->m_szKeyDeviceKey, TEXT("\\Services\\") ) != NULL )
        GetRegDisplayInfoWin2k( pDisplayInfo, szKeyVideo, szKeyImage );
    else
        GetRegDisplayInfoWhistler( pDisplayInfo, szKeyVideo, szKeyImage );

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKeyVideo, 0, KEY_READ, &hkeyInfo))
    {
        WCHAR wszChipType[200];
        WCHAR wszDACType[200];
        TCHAR szDriver[200];

        cbData = 200 * sizeof(WCHAR);
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyInfo, TEXT("HardwareInformation.ChipType"), 0, &dwType, (LPBYTE)wszChipType, &cbData))
        {
#ifdef UNICODE
            lstrcpy(pDisplayInfo->m_szChipType, wszChipType);
#else
            WideCharToMultiByte(CP_ACP, 0, wszChipType, -1, pDisplayInfo->m_szChipType, 200, NULL, NULL);
#endif
        }

        cbData = 200 * sizeof(WCHAR);
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyInfo, TEXT("HardwareInformation.DacType"), 0, &dwType, (LPBYTE)wszDACType, &cbData))
        {
#ifdef UNICODE
            lstrcpy(pDisplayInfo->m_szDACType, wszDACType);
#else
            WideCharToMultiByte(CP_ACP, 0, wszDACType, -1, pDisplayInfo->m_szDACType, 200, NULL, NULL);
#endif
        }

        DWORD dwDisplayMemory;
        cbData = sizeof(dwDisplayMemory);
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyInfo, TEXT("HardwareInformation.MemorySize"), 0, &dwType, (LPBYTE)&dwDisplayMemory, &cbData))
        {
            // Round to nearest 512K:
            dwDisplayMemory = ((dwDisplayMemory + (256 * 1024)) / (512 * 1024));
            // So dwDisplayMemory is (number of bytes / 512K), which makes the
            // following line easier.
            wsprintf(pDisplayInfo->m_szDisplayMemory, TEXT("%d.%d MB"), dwDisplayMemory / 2, 
                (dwDisplayMemory % 2) * 5);
            wsprintf(pDisplayInfo->m_szDisplayMemoryEnglish, pDisplayInfo->m_szDisplayMemory );
        }

        cbData = 200;
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyInfo, TEXT("InstalledDisplayDrivers"), 0, &dwType, (LPBYTE)szDriver, &cbData))
        {
            lstrcpy(pDisplayInfo->m_szDriverName, szDriver);
            lstrcat(pDisplayInfo->m_szDriverName, TEXT(".dll"));
            TCHAR szPath[MAX_PATH];
            GetSystemDirectory(szPath, MAX_PATH);
            lstrcat(szPath, TEXT("\\"));
            lstrcat(szPath, pDisplayInfo->m_szDriverName);
            GetFileVersion(szPath, pDisplayInfo->m_szDriverVersion, 
                pDisplayInfo->m_szDriverAttributes, pDisplayInfo->m_szDriverLanguageLocal, pDisplayInfo->m_szDriverLanguage,
                &pDisplayInfo->m_bDriverBeta, &pDisplayInfo->m_bDriverDebug);
            FileIsSigned(szPath, &pDisplayInfo->m_bDriverSigned, &pDisplayInfo->m_bDriverSignedValid);
            GetFileDateAndSize(szPath, pDisplayInfo->m_szDriverDateLocal, pDisplayInfo->m_szDriverDate, &pDisplayInfo->m_cbDriver);
        }
        RegCloseKey(hkeyInfo);
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKeyImage, 0, KEY_READ, &hkeyInfo))
    {
        TCHAR szImagePath[MAX_PATH];
        cbData = MAX_PATH;
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyInfo, TEXT("ImagePath"), 0, &dwType, (LPBYTE)szImagePath, &cbData))
        {
            pch = _tcsrchr(szImagePath, TEXT('\\'));
            lstrcpy(pDisplayInfo->m_szMiniVdd, pch + 1);
            if (lstrlen(pDisplayInfo->m_szMiniVdd) > 0)
            {
                TCHAR szPath[MAX_PATH];
                GetSystemDirectory(szPath, MAX_PATH);
                lstrcat(szPath, TEXT("\\drivers\\"));
                lstrcat(szPath, pDisplayInfo->m_szMiniVdd);
                TCHAR szDateLocal[100];
                GetFileDateAndSize( szPath, szDateLocal, pDisplayInfo->m_szMiniVddDate, 
                                    &pDisplayInfo->m_cbMiniVdd );
            }
        }
        RegCloseKey(hkeyInfo);
    }
    
    // Use monitor key to get monitor max resolution (and monitor name, if we don't have it yet)
    if (lstrlen(pDisplayInfo->m_szMonitorKey) > 0)
    {
        // Note: Have to skip first 18 characters of string because it's "Registry\Machine\"
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, pDisplayInfo->m_szMonitorKey + 18, 0, KEY_READ, &hkeyInfo))
        {
            cbData = sizeof(pDisplayInfo->m_szMonitorMaxRes);
            RegQueryValueEx(hkeyInfo, TEXT("MaxResolution"), 0, &dwType, (LPBYTE)pDisplayInfo->m_szMonitorMaxRes, &cbData);
            if (lstrlen(pDisplayInfo->m_szMonitorName) == 0)
            {
                cbData = sizeof(pDisplayInfo->m_szMonitorName);
                RegQueryValueEx(hkeyInfo, TEXT("DriverDesc"), 0, &dwType, (LPBYTE)pDisplayInfo->m_szMonitorName, &cbData);
            }
            RegCloseKey(hkeyInfo);
        }
    }
}


/****************************************************************************
 *
 *  GetRegDisplayInfoWhistler - Returns string location of video struct and 
 *      ImageInfo info in registry
 *
 ****************************************************************************/
VOID GetRegDisplayInfoWhistler(DisplayInfo* pDisplayInfo, TCHAR* szKeyVideo, TCHAR* szKeyImage )
{
    TCHAR* pch;
    TCHAR szKey[MAX_PATH];
    DWORD dwType;
    DWORD cbData;
    HKEY hkeyService;

    // m_szKeyDeviceKey will be something like 
    // "\Registry\Machine\System\ControlSet001\Video\[GUID]\0000",
    // The "\Registry\Machine\" part is useless, so we skip past the 
    // first 18 characters in the string.
    lstrcpy(szKey, pDisplayInfo->m_szKeyDeviceKey + 18);

    // Slice off the "\0000" and add "\Video" to get the service
    pch = _tcsrchr(szKey, TEXT('\\'));
    if (pch != NULL)
        *pch = 0;
    lstrcat(szKey, TEXT("\\Video\\"));

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hkeyService))
    {
        TCHAR szService[MAX_PATH];
        cbData = MAX_PATH;
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyService, TEXT("Service"), 0, &dwType, (LPBYTE)szService, &cbData))
        {
            lstrcpy(szKeyImage, TEXT("System\\CurrentControlSet\\Services\\") );
            lstrcat(szKeyImage, szService);
        }

        RegCloseKey(hkeyService);
    }

    // return something like "\System\ControlSet001\Services\atirage\Device0".  
    lstrcpy(szKeyVideo, pDisplayInfo->m_szKeyDeviceKey + 18);
}


/****************************************************************************
 *
 *  GetRegDisplayInfoWin2k - Returns string location of video struct and 
 *      ImageInfo info in registry
 *
 ****************************************************************************/
VOID GetRegDisplayInfoWin2k(DisplayInfo* pDisplayInfo, TCHAR* szKeyVideo, TCHAR* szKeyImage )
{
    TCHAR* pch;

    // m_szKeyDeviceKey will be something like 
    // "\Registry\Machine\System\ControlSet001\Services\atirage\Device0".  
    // The "\Registry\Machine\" part is useless, so we skip past the 
    // first 18 characters in the string.
    lstrcpy(szKeyImage, pDisplayInfo->m_szKeyDeviceKey + 18);

    // Slice off the "\Device0" to get the miniport driver path
    pch = _tcsrchr(szKeyImage, TEXT('\\'));
    if (pch != NULL)
        *pch = 0;

    // return something like "\System\ControlSet001\Services\atirage\Device0".  
    lstrcpy(szKeyVideo, pDisplayInfo->m_szKeyDeviceKey + 18);
}


/****************************************************************************
 *
 *  GetDirectDrawInfo
 *
 ****************************************************************************/
HRESULT GetDirectDrawInfo(LPDIRECTDRAWCREATE pDDCreate, DisplayInfo* pDisplayInfo)
{
    HRESULT hr;
    LPDIRECTDRAW pdd = NULL;
    GUID* pGUID;
    DDCAPS ddcaps;
    DWORD dwDisplayMemory;

    if (pDisplayInfo->m_guid == GUID_NULL)
        pGUID = NULL;
    else
        pGUID = &pDisplayInfo->m_guid;

    if (FAILED(hr = pDDCreate(pGUID, &pdd, NULL)))
        goto LFail;

    ddcaps.dwSize = sizeof(ddcaps);
    if (FAILED(hr = pdd->GetCaps(&ddcaps, NULL)))
        goto LFail;

    // If AGP is disabled, we won't be able to tell if AGP is supported because
    // the flag will not be set.  So in that case, assume that AGP is supported.
    // If AGP is not disabled, check the existence of AGP and note that we are
    // confident in the knowledge of whether AGP exists or not.  I know, it's yucky.
    if (pDisplayInfo->m_bAGPEnabled)
    {
        pDisplayInfo->m_bAGPExistenceValid = TRUE;
        if (ddcaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM)
            pDisplayInfo->m_bAGPExists = TRUE;
    }
    
    if( ddcaps.dwCaps & DDCAPS_NOHARDWARE ) 
        pDisplayInfo->m_bNoHardware = TRUE;
    else
        pDisplayInfo->m_bNoHardware = FALSE;

    // 28873: if( DDCAPS_NOHARDWARE && m_bDDAccelerationEnabled ) then GetAvailableVidMem is wrong. 
    if( pDisplayInfo->m_bNoHardware && pDisplayInfo->m_bDDAccelerationEnabled )
    {
        LoadString(NULL, IDS_NA, pDisplayInfo->m_szDisplayMemory, 100);
        wsprintf(pDisplayInfo->m_szDisplayMemoryEnglish, TEXT("n/a") );
    }
    else
    {
        if (lstrlen(pDisplayInfo->m_szDisplayMemory) == 0)
        {
            // 26678: returns wrong vid mem for 2nd monitor, so ignore non-hardware devices
            if( (ddcaps.dwCaps & DDCAPS_NOHARDWARE) == 0 )
            {
                // 24351: ddcaps.dwVidMemTotal sometimes includes AGP-accessible memory,
                // which we don't want.  So use GetAvailableVidMem whenever we can, and
                // fall back to ddcaps.dwVidMemTotal if that's a problem.
                dwDisplayMemory = 0;
                LPDIRECTDRAW2 pdd2;
                if (SUCCEEDED(pdd->QueryInterface(IID_IDirectDraw2, (VOID**)&pdd2)))
                {
                    DDSCAPS ddscaps;
                    ddscaps.dwCaps = DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM;
                    pdd2->GetAvailableVidMem(&ddscaps, &dwDisplayMemory, NULL);
                    pdd2->Release();
                }
                if (dwDisplayMemory == 0)
                {
                    dwDisplayMemory = ddcaps.dwVidMemTotal;
                }
                // Add GDI memory except on no-GDI cards (Voodoo-type cards)
                if (pDisplayInfo->m_bCanRenderWindow)
                {
                    DDSURFACEDESC ddsd;
                    ddsd.dwSize = sizeof(ddsd);
                    if (FAILED(hr = pdd->GetDisplayMode(&ddsd)))
                        goto LFail;

                    dwDisplayMemory += ddsd.dwWidth * ddsd.dwHeight * 
                        (ddsd.ddpfPixelFormat.dwRGBBitCount / 8);
                }
                // Round to nearest 512K:
                dwDisplayMemory = ((dwDisplayMemory + (256 * 1024)) / (512 * 1024));
                // So dwDisplayMemory is (number of bytes / 512K), which makes the
                // following line easier.
                wsprintf(pDisplayInfo->m_szDisplayMemory, TEXT("%d.%d MB"), dwDisplayMemory / 2, 
                    (dwDisplayMemory % 2) * 5);
                wsprintf(pDisplayInfo->m_szDisplayMemoryEnglish, pDisplayInfo->m_szDisplayMemory );
            }
        }
    }

    // 24427: Detect driver DDI version
    // 24656: Also detect D3D acceleration without DDCAPS_3D, since that flag is
    // sometimes sensitive to the current desktop color depth.

    // First, see if DD/D3D are disabled, and if so, briefly re-enable them
    BOOL bDDDisabled;
    BOOL bD3DDisabled;
    HKEY hkeyDD;
    HKEY hkeyD3D;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwData;

    bDDDisabled = FALSE;
    bD3DDisabled = FALSE;
    hkeyDD = NULL;
    hkeyD3D = NULL;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        TEXT("SOFTWARE\\Microsoft\\DirectDraw"), 0, KEY_ALL_ACCESS, &hkeyDD))
    {
        dwSize = sizeof(dwData);
        dwData = 0;
        RegQueryValueEx(hkeyDD, TEXT("EmulationOnly"), NULL, &dwType, (BYTE *)&dwData, &dwSize);
        if (dwData != 0)
        {
            bDDDisabled = TRUE;
            // Re-enable DD
            dwData = 0;
            RegSetValueEx(hkeyDD, TEXT("EmulationOnly"), 0, REG_DWORD, (BYTE*)&dwData, sizeof(dwData));
        }
        // Note: don't close key yet
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        TEXT("SOFTWARE\\Microsoft\\Direct3D\\Drivers"), 0, KEY_ALL_ACCESS, &hkeyD3D))
    {
        dwSize = sizeof(dwData);
        dwData = 0;
        RegQueryValueEx(hkeyD3D, TEXT("SoftwareOnly"), NULL, &dwType, (BYTE *)&dwData, &dwSize);
        if (dwData != 0)
        {
            bD3DDisabled = TRUE;
            // Re-enable D3D
            dwData = 0;
            RegSetValueEx(hkeyD3D, TEXT("SoftwareOnly"), 0, REG_DWORD, (BYTE*)&dwData, sizeof(dwData));
        }
        // Note: don't close key yet
    }

    LPDIRECT3D pd3d;
    if (SUCCEEDED(pdd->QueryInterface(IID_IDirect3D, (VOID**)&pd3d)))
    {
        DWORD dwVersion = 0;
        if (SUCCEEDED(pd3d->EnumDevices(EnumDevicesCallback, (VOID*)&dwVersion)))
        {
            pDisplayInfo->m_dwDDIVersion = dwVersion;
        }
        pd3d->Release();
    }

    // While were in this function wrapped with crash protection try to 
    // get adapter info from D3D8, and match it up with the DisplayInfo list.
    // This will also tell us if m_dwDDIVersion==8.
    GetDX8AdapterInfo(pDisplayInfo);

    switch (pDisplayInfo->m_dwDDIVersion)
    {
    case 0:
        wsprintf(pDisplayInfo->m_szDDIVersion, TEXT("Unknown"));
        break;
    case 7:
        if( IsD3D8Working() )
            wsprintf(pDisplayInfo->m_szDDIVersion, TEXT("7"));
        else
            wsprintf(pDisplayInfo->m_szDDIVersion, TEXT("7 (or higher)"));
        break;
    case 8:
        wsprintf(pDisplayInfo->m_szDDIVersion, TEXT("8 (or higher)"));
        break;
    default:
        wsprintf(pDisplayInfo->m_szDDIVersion, TEXT("%d"), pDisplayInfo->m_dwDDIVersion);
        break;
    }

    if (pDisplayInfo->m_dwDDIVersion != 0)
        pDisplayInfo->m_b3DAccelerationExists = TRUE;

    // Re-disable DD and D3D, if necessary
    dwData = 1;
    if (bDDDisabled)
        RegSetValueEx(hkeyDD, TEXT("EmulationOnly"), 0, REG_DWORD, (BYTE*)&dwData, sizeof(dwData));
    if (bD3DDisabled)
        RegSetValueEx(hkeyD3D, TEXT("SoftwareOnly"), 0, REG_DWORD, (BYTE*)&dwData, sizeof(dwData));
    if (hkeyDD != NULL)
        RegCloseKey(hkeyDD);
    if (hkeyD3D != NULL)
        RegCloseKey(hkeyD3D);

    pdd->Release();
    return S_OK;
LFail:
    if (pdd != NULL)
        pdd->Release();
    return hr;
}


/****************************************************************************
 *
 *  EnumDevicesCallback
 *
 ****************************************************************************/
HRESULT CALLBACK EnumDevicesCallback(GUID* pGuid, LPSTR pszDesc, LPSTR pszName, 
    D3DDEVICEDESC* pd3ddevdesc1, D3DDEVICEDESC* pd3ddevdesc2, VOID* pvContext)
{
    DWORD* pdwVersion = (DWORD*)pvContext;
    DWORD dwDevCaps;
    if (pd3ddevdesc1->dcmColorModel == D3DCOLOR_RGB)
    {
        dwDevCaps = pd3ddevdesc1->dwDevCaps;
        if (dwDevCaps & D3DDEVCAPS_DRAWPRIMITIVES2EX)
            *pdwVersion = 7;
        else if (dwDevCaps & D3DDEVCAPS_DRAWPRIMITIVES2)
            *pdwVersion = 6;
        else if (dwDevCaps & D3DDEVCAPS_DRAWPRIMTLVERTEX)
            *pdwVersion = 5;
        else if (dwDevCaps & D3DDEVCAPS_FLOATTLVERTEX)
            *pdwVersion = 3;
    }
    return D3DENUMRET_OK;
}


/****************************************************************************
 *
 *  IsDDHWAccelEnabled
 *
 ****************************************************************************/
BOOL IsDDHWAccelEnabled(VOID)
{
    HKEY hkey;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwData;
    BOOL bResult = TRUE;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        TEXT("SOFTWARE\\Microsoft\\DirectDraw"), 0, KEY_ALL_ACCESS, &hkey))
    {
        dwSize = sizeof(dwData);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("EmulationOnly"), NULL, &dwType, (BYTE *)&dwData, &dwSize))
        {
            if (dwData != 0) 
                bResult = FALSE;
                
            RegCloseKey(hkey);
        }
    }

    return bResult;    
}


/****************************************************************************
 *
 *  IsD3DHWAccelEnabled
 *
 ****************************************************************************/
BOOL IsD3DHWAccelEnabled(VOID)
{
    HKEY hkey;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwData;
    BOOL bIsD3DHWAccelEnabled = TRUE;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        TEXT("SOFTWARE\\Microsoft\\Direct3D\\Drivers"), 0, KEY_ALL_ACCESS, &hkey))
    {
        dwSize = sizeof(dwData);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("SoftwareOnly"), NULL, &dwType, (BYTE *)&dwData, &dwSize))
        {
            if (dwData != 0) 
                bIsD3DHWAccelEnabled = FALSE;
                
            RegCloseKey( hkey );
        }            
    }

    return bIsD3DHWAccelEnabled;
}


/****************************************************************************
 *
 *  IsAGPEnabled
 *
 ****************************************************************************/
BOOL IsAGPEnabled(VOID)
{
    HKEY hkey;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwData;
    BOOL bIsAGPEnabled = TRUE;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        TEXT("SOFTWARE\\Microsoft\\DirectDraw"), 0, KEY_ALL_ACCESS, &hkey))
    {
        dwSize = sizeof(dwData);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("DisableAGPSupport"), NULL, &dwType, (BYTE *)&dwData, &dwSize))
        {
            if (dwData != 0) 
                bIsAGPEnabled = FALSE;
                
            RegCloseKey( hkey );
        }
    }

    return bIsAGPEnabled;
}


//
// GetDeviceValue
//
// read a value from the HW or SW of a PnP device
//
BOOL GetDeviceValue(TCHAR* pszHardwareKey, TCHAR* pszKey, TCHAR* pszValue, BYTE *buf, DWORD cbbuf)
{
    HKEY    hkeyHW;
    HKEY    hkeySW;
    BOOL    f = FALSE;
    DWORD   cb;
    TCHAR   szSoftwareKey[MAX_PATH];

    *(DWORD*)buf = 0;

    //
    // open the HW key
    //
    if (RegOpenKey(HKEY_LOCAL_MACHINE, pszHardwareKey, &hkeyHW) == ERROR_SUCCESS)
    {
        //
        // try to read the value from the HW key
        //
        *buf = 0;
        cb = cbbuf;
        if (RegQueryValueEx(hkeyHW, pszValue, NULL, NULL, buf, &cb) == ERROR_SUCCESS)
        {
            f = TRUE;
        }
        else
        {
            //
            // now try the SW key
            //
            static TCHAR szSW[] = TEXT("System\\CurrentControlSet\\Services\\Class\\");

            lstrcpy(szSoftwareKey, szSW);
            cb = sizeof(szSoftwareKey) - sizeof(szSW);
            RegQueryValueEx(hkeyHW, TEXT("Driver"), NULL, NULL, (LPBYTE)(szSoftwareKey + sizeof(szSW) - 1), &cb);

            if (pszKey)
            {
                lstrcat(szSoftwareKey, TEXT("\\"));
                lstrcat(szSoftwareKey, pszKey);
            }

            if (RegOpenKey(HKEY_LOCAL_MACHINE, szSoftwareKey, &hkeySW) == ERROR_SUCCESS)
            {
                *buf = 0;
                cb = cbbuf;
                if (RegQueryValueEx(hkeySW, pszValue, NULL, NULL, buf, &cb) == ERROR_SUCCESS)
                {
                    f = TRUE;
                }

                RegCloseKey(hkeySW);
            }
        }

        RegCloseKey(hkeyHW);
    }

    return f;
}

//
// FindDevice
//
// enum the started PnP devices looking for a device of a particular class
//
//  iDevice         what device to return (0= first device, 1=second et)
//  szDeviceClass   what class device (ie "Display") NULL will match all
//  szDeviceID      buffer to return the hardware ID (MAX_PATH bytes)
//
// return TRUE if a device was found.
//
// example:
//
//      for (int i=0; FindDevice(i, "Display", DeviceID); i++)
//      {
//      }
//
BOOL FindDevice(INT iDevice, TCHAR* pszDeviceClass, TCHAR* pszDeviceClassNot, TCHAR* pszHardwareKey)
{
    HKEY    hkeyPnP;
    HKEY    hkey;
    DWORD   n;
    DWORD   cb;
    DWORD   dw;
    TCHAR   ach[MAX_PATH+1];

    if (RegOpenKey(HKEY_DYN_DATA, TEXT("Config Manager\\Enum"), &hkeyPnP) != ERROR_SUCCESS)
        return FALSE;

    for (n=0; RegEnumKey(hkeyPnP, n, ach, MAX_PATH+1) == 0; n++)
    {
        static TCHAR szHW[] = TEXT("Enum\\");

        if (RegOpenKey(hkeyPnP, ach, &hkey) != ERROR_SUCCESS)
            continue;

        lstrcpy(pszHardwareKey, szHW);
        cb = MAX_PATH - sizeof(szHW);
        RegQueryValueEx(hkey, TEXT("HardwareKey"), NULL, NULL, (BYTE*)pszHardwareKey + sizeof(szHW) - 1, &cb);

        dw = 0;
        cb = sizeof(dw);
        RegQueryValueEx(hkey, TEXT("Problem"), NULL, NULL, (BYTE*)&dw, &cb);
        RegCloseKey(hkey);

        if (dw != 0)        // if this device has a problem skip it
            continue;

        if (pszDeviceClass || pszDeviceClassNot)
        {
            GetDeviceValue(pszHardwareKey, NULL, TEXT("Class"), (BYTE*)ach, sizeof(ach));

            if (pszDeviceClass && lstrcmpi(pszDeviceClass, ach) != 0)
                continue;

            if (pszDeviceClassNot && lstrcmpi(pszDeviceClassNot, ach) == 0)
                continue;
        }

        //
        // we found a device, make sure it is the one the caller wants
        //
        if (iDevice-- == 0)
        {
            RegCloseKey(hkeyPnP);
            return TRUE;
        }
    }

    RegCloseKey(hkeyPnP);
    return FALSE;
}


/****************************************************************************
 *
 *  CheckRegistry
 *
 ****************************************************************************/
HRESULT CheckRegistry(RegError** ppRegErrorFirst)
{
    HRESULT hr;
    HKEY HKLM = HKEY_LOCAL_MACHINE;
    HKEY HKCR = HKEY_CLASSES_ROOT;

    TCHAR szVersion[100];
    HKEY hkey;
    DWORD cbData;
    ULONG ulType;

    DWORD dwMajor = 0;
    DWORD dwMinor = 0;
    DWORD dwRevision = 0;
    DWORD dwBuild = 0;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectX"),
        0, KEY_READ, &hkey))
    {
        cbData = 100;
        RegQueryValueEx(hkey, TEXT("Version"), 0, &ulType, (LPBYTE)szVersion, &cbData);
        RegCloseKey(hkey);
        if (lstrlen(szVersion) > 6 && 
            lstrlen(szVersion) < 20)
        {
            _stscanf(szVersion, TEXT("%d.%d.%d.%d"), &dwMajor, &dwMinor, &dwRevision, &dwBuild);
        }
    }

    // No registry checking on DX versions before DX7
    if (dwMinor < 7)
        return S_OK;

    // From ddraw.inf (compatibility hacks not included):
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("DirectDraw"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("DirectDraw\\CLSID"), TEXT(""), TEXT("{D7B70EE0-4340-11CF-B063-0020AFC2CD35}"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{D7B70EE0-4340-11CF-B063-0020AFC2CD35}"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{D7B70EE0-4340-11CF-B063-0020AFC2CD35}\\InprocServer32"), TEXT(""), TEXT("ddraw.dll"), CRF_LEAF)))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{D7B70EE0-4340-11CF-B063-0020AFC2CD35}\\InprocServer32"), TEXT("ThreadingModel"), TEXT("Both"))))
        return hr;

    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("DirectDrawClipper"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("DirectDrawClipper\\CLSID"), TEXT(""), TEXT("{593817A0-7DB3-11CF-A2DE-00AA00B93356}"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{593817A0-7DB3-11CF-A2DE-00AA00B93356}"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{593817A0-7DB3-11CF-A2DE-00AA00B93356}\\InprocServer32"), TEXT(""), TEXT("ddraw.dll"), CRF_LEAF)))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{593817A0-7DB3-11CF-A2DE-00AA00B93356}\\InprocServer32"), TEXT("ThreadingModel"), TEXT("Both"))))
        return hr;

    if (!BIsPlatformNT())
    {
        // We can't check for the following entry on Win2000 because it is missing.
        if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{4FD2A832-86C8-11d0-8FCA-00C04FD9189D}"), TEXT(""), TEXT("*"))))
            return hr;
    }
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{4FD2A832-86C8-11d0-8FCA-00C04FD9189D}\\InprocServer32"), TEXT(""), TEXT("ddrawex.dll"), CRF_LEAF)))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{4FD2A832-86C8-11d0-8FCA-00C04FD9189D}\\InprocServer32"), TEXT("ThreadingModel"), TEXT("Both"))))
        return hr;


    // From d3d.inf:
    TCHAR* pszHALKey = TEXT("Software\\Microsoft\\Direct3D\\Drivers\\Direct3D HAL");
    BYTE bArrayHALGuid[] = { 0xe0, 0x3d, 0xe6, 0x84, 0xaa, 0x46, 0xcf, 0x11, 0x81, 0x6f, 0x00, 0x00, 0xc0, 0x20, 0x15, 0x6e };
    TCHAR* pszRampKey = TEXT("Software\\Microsoft\\Direct3D\\Drivers\\Ramp Emulation");
    BYTE bArrayRampGuid[] = { 0x20, 0x6b, 0x08, 0xf2, 0x9f, 0x25, 0xcf, 0x11, 0xa3, 0x1a, 0x00, 0xaa, 0x00, 0xb9, 0x33, 0x56 };
    TCHAR* pszRGBKey = TEXT("Software\\Microsoft\\Direct3D\\Drivers\\RGB Emulation");
    BYTE bArrayRGBGuid[] = { 0x60, 0x5c, 0x66, 0xa4, 0x73, 0x26, 0xcf, 0x11, 0xa3, 0x1a, 0x00, 0xaa, 0x00, 0xb9, 0x33, 0x56 };

    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKLM, pszHALKey, TEXT("Base"), TEXT("hal"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKLM, pszHALKey, TEXT("Description"), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegBinary(ppRegErrorFirst, HKLM, pszHALKey, TEXT("GUID"), bArrayHALGuid, sizeof(bArrayHALGuid))))
        return hr;

    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKLM, pszRampKey, TEXT("Base"), TEXT("ramp"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKLM, pszRampKey, TEXT("Description"), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegBinary(ppRegErrorFirst, HKLM, pszRampKey, TEXT("GUID"), bArrayRampGuid, sizeof(bArrayRampGuid))))
        return hr;

    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKLM, pszRGBKey, TEXT("Base"), TEXT("rgb"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKLM, pszRGBKey, TEXT("Description"), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegBinary(ppRegErrorFirst, HKLM, pszRGBKey, TEXT("GUID"), bArrayRGBGuid, sizeof(bArrayRGBGuid))))
        return hr;

    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKLM, TEXT("Software\\Microsoft\\Direct3D\\DX6TextureEnumInclusionList\\16 bit Bump DuDv"), TEXT("ddpf"), TEXT("00080000 0 16 ff ff00 0 0"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKLM, TEXT("Software\\Microsoft\\Direct3D\\DX6TextureEnumInclusionList\\16 bit BumpLum DuDv"), TEXT("ddpf"), TEXT("000C0000 0 16 1f 3e0 fc00 0"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKLM, TEXT("Software\\Microsoft\\Direct3D\\DX6TextureEnumInclusionList\\16 bit Luminance Alpha"), TEXT("ddpf"), TEXT("00020001 0 16 ff 0 0 ff00"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKLM, TEXT("Software\\Microsoft\\Direct3D\\DX6TextureEnumInclusionList\\24 bit BumpLum DuDv"), TEXT("ddpf"), TEXT("000C0000 0 24 ff ff00 ff0000 0"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKLM, TEXT("Software\\Microsoft\\Direct3D\\DX6TextureEnumInclusionList\\8 bit Luminance"), TEXT("ddpf"), TEXT("00020000 0  8 ff 0 0 0"))))
        return hr;

    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("Direct3DRM"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("Direct3DRM\\CLSID"), TEXT(""), TEXT("{4516EC41-8F20-11d0-9B6D-0000C0781BC3}"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{4516EC41-8F20-11d0-9B6D-0000C0781BC3}"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{4516EC41-8F20-11d0-9B6D-0000C0781BC3}\\InprocServer32"), TEXT(""), TEXT("d3drm.dll"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{4516EC41-8F20-11d0-9B6D-0000C0781BC3}\\InprocServer32"), TEXT("ThreadingModel"), TEXT("Both"))))
        return hr;

    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("DirectXFile"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("DirectXFile\\CLSID"), TEXT(""), TEXT("{4516EC43-8F20-11D0-9B6D-0000C0781BC3}"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{4516EC43-8F20-11D0-9B6D-0000C0781BC3}"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{4516EC43-8F20-11d0-9B6D-0000C0781BC3}\\InprocServer32"), TEXT(""), TEXT("d3dxof.dll"))))
        return hr;
    if (BIsPlatformNT())
    {
        // 23342: This setting is missing on Win9x.
        if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{4516EC43-8F20-11d0-9B6D-0000C0781BC3}\\InprocServer32"), TEXT("ThreadingModel"), TEXT("Both"))))
            return hr;
    }

    return S_OK;
}


/****************************************************************************
 *
 *  DiagnoseDisplay
 *
 ****************************************************************************/
VOID DiagnoseDisplay(SysInfo* pSysInfo, DisplayInfo* pDisplayInfoFirst)
{
    DisplayInfo* pDisplayInfo;
    TCHAR sz[MAX_PATH];
    TCHAR szEnglish[MAX_PATH];
    TCHAR szFmt[MAX_PATH];
    BOOL bShouldReinstall = FALSE;

    for (pDisplayInfo = pDisplayInfoFirst; pDisplayInfo != NULL; 
        pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext)
    {
        if (pDisplayInfo->m_bDDAccelerationEnabled)
        {
            if( pDisplayInfo->m_bNoHardware )
            {
                LoadString(NULL, IDS_ACCELUNAVAIL, sz, 100);
                LoadString(NULL, IDS_ACCELUNAVAIL_ENGLISH, szEnglish, 100);
            }
            else
            {
                LoadString(NULL, IDS_ACCELENABLED, sz, 100);
                LoadString(NULL, IDS_ACCELENABLED_ENGLISH, szEnglish, 100);
            }
        }
        else
        {
            LoadString(NULL, IDS_ACCELDISABLED, sz, 100);
            LoadString(NULL, IDS_ACCELDISABLED_ENGLISH, szEnglish, 100);
        }

        _tcscpy( pDisplayInfo->m_szDDStatus, sz );
        _tcscpy( pDisplayInfo->m_szDDStatusEnglish, szEnglish );

        if (pDisplayInfo->m_b3DAccelerationExists)
        {
            if (pDisplayInfo->m_b3DAccelerationEnabled)
            {
                LoadString(NULL, IDS_ACCELENABLED, sz, 100);
                LoadString(NULL, IDS_ACCELENABLED_ENGLISH, szEnglish, 100);
            }
            else
            {
                LoadString(NULL, IDS_ACCELDISABLED, sz, 100);
                LoadString(NULL, IDS_ACCELDISABLED_ENGLISH, szEnglish, 100);
            }
        }
        else
        {
            LoadString(NULL, IDS_ACCELUNAVAIL, sz, 100);
            LoadString(NULL, IDS_ACCELUNAVAIL_ENGLISH, szEnglish, 100);
        }
        _tcscpy( pDisplayInfo->m_szD3DStatus, sz );
        _tcscpy( pDisplayInfo->m_szD3DStatusEnglish, szEnglish );

        if ( (pDisplayInfo->m_bAGPExistenceValid && !pDisplayInfo->m_bAGPExists) ||
             (!pDisplayInfo->m_bDDAccelerationEnabled) )
        {
            LoadString(NULL, IDS_ACCELUNAVAIL, sz, 100);
            LoadString(NULL, IDS_ACCELUNAVAIL_ENGLISH, szEnglish, 100);
        }
        else
        {
            if (pDisplayInfo->m_bAGPEnabled)
            {
                LoadString(NULL, IDS_ACCELENABLED, sz, 100);
                LoadString(NULL, IDS_ACCELENABLED_ENGLISH, szEnglish, 100);
            }
            else
            {
                LoadString(NULL, IDS_ACCELDISABLED, sz, 100);
                LoadString(NULL, IDS_ACCELDISABLED_ENGLISH, szEnglish, 100);
            }
        }
        _tcscpy( pDisplayInfo->m_szAGPStatus, sz );
        _tcscpy( pDisplayInfo->m_szAGPStatusEnglish, szEnglish );
       
        _tcscpy( pDisplayInfo->m_szNotes, TEXT("") );
        _tcscpy( pDisplayInfo->m_szNotesEnglish, TEXT("") );

        // Report any problems:
        BOOL bProblem = FALSE;
        if( pSysInfo->m_bNetMeetingRunning && 
            !pDisplayInfo->m_b3DAccelerationExists )
        {
            LoadString(NULL, IDS_NETMEETINGWARN, szFmt, MAX_PATH);
            wsprintf(sz, szFmt, pDisplayInfo->m_szDriverName);
            _tcscat( pDisplayInfo->m_szNotes, sz );

            LoadString(NULL, IDS_NETMEETINGWARN_ENGLISH, szFmt, MAX_PATH);
            wsprintf(sz, szFmt, pDisplayInfo->m_szDriverName);
            _tcscat( pDisplayInfo->m_szNotesEnglish, sz );

            bProblem = TRUE;
        }

        if (pDisplayInfo->m_bDriverSignedValid && !pDisplayInfo->m_bDriverSigned)
        {
            LoadString(NULL, IDS_UNSIGNEDDRIVERFMT1, szFmt, MAX_PATH);
            wsprintf(sz, szFmt, pDisplayInfo->m_szDriverName);
            _tcscat( pDisplayInfo->m_szNotes, sz );

            LoadString(NULL, IDS_UNSIGNEDDRIVERFMT1_ENGLISH, szFmt, MAX_PATH);
            wsprintf(sz, szFmt, pDisplayInfo->m_szDriverName);
            _tcscat( pDisplayInfo->m_szNotesEnglish, sz );

            bProblem = TRUE;
        }

        if (pDisplayInfo->m_pRegErrorFirst != NULL)
        {
            LoadString(NULL, IDS_REGISTRYPROBLEM, sz, MAX_PATH);
            _tcscat( pDisplayInfo->m_szNotes, sz );

            LoadString(NULL, IDS_REGISTRYPROBLEM_ENGLISH, sz, MAX_PATH);
            _tcscat( pDisplayInfo->m_szNotesEnglish, sz );

            bProblem = TRUE;
            bShouldReinstall = TRUE;
        }

        if( bShouldReinstall )
        {
            BOOL bTellUser = FALSE;

            // Figure out if the user can install DirectX
            if( BIsPlatform9x() )
                bTellUser = TRUE;
            else if( BIsWin2k() && pSysInfo->m_dwDirectXVersionMajor >= 8 )
                bTellUser = TRUE;

            if( bTellUser )
            {
                LoadString(NULL, IDS_REINSTALL_DX, sz, 300);
                _tcscat( pDisplayInfo->m_szNotes, sz);

                LoadString(NULL, IDS_REINSTALL_DX_ENGLISH, sz, 300);
                _tcscat( pDisplayInfo->m_szNotesEnglish, sz);
            }
        }

        if (!bProblem)
        {
            LoadString(NULL, IDS_NOPROBLEM, sz, MAX_PATH);
            _tcscat( pDisplayInfo->m_szNotes, sz );

            LoadString(NULL, IDS_NOPROBLEM_ENGLISH, sz, MAX_PATH);
            _tcscat( pDisplayInfo->m_szNotesEnglish, sz );
        }

        // Report any DD test results:
        if (pDisplayInfo->m_testResultDD.m_bStarted &&
            !pDisplayInfo->m_testResultDD.m_bCancelled)
        {
            LoadString(NULL, IDS_DDRESULTS, sz, MAX_PATH);
            _tcscat( pDisplayInfo->m_szNotes, sz );
            _tcscat( pDisplayInfo->m_szNotes, pDisplayInfo->m_testResultDD.m_szDescription );
            _tcscat( pDisplayInfo->m_szNotes, TEXT("\r\n") );

            LoadString(NULL, IDS_DDRESULTS_ENGLISH, sz, MAX_PATH);
            _tcscat( pDisplayInfo->m_szNotesEnglish, sz );
            _tcscat( pDisplayInfo->m_szNotesEnglish, pDisplayInfo->m_testResultDD.m_szDescription );
            _tcscat( pDisplayInfo->m_szNotesEnglish, TEXT("\r\n") );
        }
        else
        {
            LoadString(NULL, IDS_DDINSTRUCTIONS, sz, MAX_PATH);
            _tcscat( pDisplayInfo->m_szNotes, sz );

            LoadString(NULL, IDS_DDINSTRUCTIONS_ENGLISH, sz, MAX_PATH);
            _tcscat( pDisplayInfo->m_szNotesEnglish, sz );
        }

        // Report any D3D test results:
        TestResult* pTestResult;
        if( pDisplayInfo->m_dwTestToDisplayD3D == 7 )
            pTestResult = &pDisplayInfo->m_testResultD3D7;
        else
            pTestResult = &pDisplayInfo->m_testResultD3D8;

        if (pTestResult->m_bStarted &&
            !pTestResult->m_bCancelled)
        {
            LoadString(NULL, IDS_D3DRESULTS, sz, MAX_PATH);
            _tcscat( pDisplayInfo->m_szNotes, sz );
            _tcscat( pDisplayInfo->m_szNotes, pTestResult->m_szDescription );
            _tcscat( pDisplayInfo->m_szNotes, TEXT("\r\n") );

            LoadString(NULL, IDS_D3DRESULTS_ENGLISH, sz, MAX_PATH);
            _tcscat( pDisplayInfo->m_szNotesEnglish, sz );
            _tcscat( pDisplayInfo->m_szNotesEnglish, pTestResult->m_szDescription );
            _tcscat( pDisplayInfo->m_szNotesEnglish, TEXT("\r\n") );
        }
        else
        {
            if( pDisplayInfo->m_b3DAccelerationExists && 
                pDisplayInfo->m_b3DAccelerationEnabled )
            {
                LoadString(NULL, IDS_D3DINSTRUCTIONS, sz, MAX_PATH);
                _tcscat( pDisplayInfo->m_szNotes, sz );

                LoadString(NULL, IDS_D3DINSTRUCTIONS_ENGLISH, sz, MAX_PATH);
                _tcscat( pDisplayInfo->m_szNotesEnglish, sz );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\dsprv.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsprv.h
 *  Content:    DirectSound include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/19/98     dereks  Created.
 *@@END_MSINTERNAL
 *
 **************************************************************************/

#ifndef __DSPRV_INCLUDED__
#define __DSPRV_INCLUDED__

#ifndef __DSOUND_INCLUDED__
#error dsound.h not included
#endif // __DSOUND_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// DirectSound Private Component GUID {11AB3EC0-25EC-11d1-A4D8-00C04FC28ACA}
DEFINE_GUID(CLSID_DirectSoundPrivate, 0x11ab3ec0, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// 
// DirectSound Mixer Properties {84624F80-25EC-11d1-A4D8-00C04FC28ACA}
// 

DEFINE_GUID(DSPROPSETID_DirectSoundMixer, 0x84624f80, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum 
{
    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY,
    DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION,
} DSPROPERTY_DIRECTSOUNDMIXER;

typedef enum
{
    DIRECTSOUNDMIXER_SRCQUALITY_WORST,
    DIRECTSOUNDMIXER_SRCQUALITY_PC,
    DIRECTSOUNDMIXER_SRCQUALITY_BASIC,
    DIRECTSOUNDMIXER_SRCQUALITY_ADVANCED,
} DIRECTSOUNDMIXER_SRCQUALITY;

#define DIRECTSOUNDMIXER_SRCQUALITY_DEFAULT DIRECTSOUNDMIXER_SRCQUALITY_PC

typedef struct _DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA
{
    GUID                        DeviceId;   // DirectSound device id
    DIRECTSOUNDMIXER_SRCQUALITY Quality;    // SRC quality
} DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA, *PDSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA;

#define DIRECTSOUNDMIXER_ACCELERATIONF_NORING0MIX   0x00000001
#define DIRECTSOUNDMIXER_ACCELERATIONF_NOHWBUFFERS  0x00000002
#define DIRECTSOUNDMIXER_ACCELERATIONF_NOHW3D       0x00000004
#define DIRECTSOUNDMIXER_ACCELERATIONF_NOHWPROPSETS 0x00000008
                                                        
#define DIRECTSOUNDMIXER_ACCELERATIONF_FULL         0x00000000
#define DIRECTSOUNDMIXER_ACCELERATIONF_STANDARD     0x00000008
#define DIRECTSOUNDMIXER_ACCELERATIONF_NONE         0x0000000F

#define DIRECTSOUNDMIXER_ACCELERATIONF_DEFAULT      DIRECTSOUNDMIXER_ACCELERATIONF_STANDARD

typedef struct _DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA
{
    GUID    DeviceId;   // DirectSound device id
    ULONG   Flags;      // Acceleration flags
} DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA, *PDSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA;

// 
// DirectSound Device Properties {84624F82-25EC-11d1-A4D8-00C04FC28ACA}
// 

DEFINE_GUID(DSPROPSETID_DirectSoundDevice, 0x84624f82, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum
{
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE,
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1,
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W,
} DSPROPERTY_DIRECTSOUNDDEVICE;

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1
#endif // DIRECTSOUND_VERSION >= 0x0700

typedef enum
{
    DIRECTSOUNDDEVICE_TYPE_EMULATED,
    DIRECTSOUNDDEVICE_TYPE_VXD,
    DIRECTSOUNDDEVICE_TYPE_WDM
} DIRECTSOUNDDEVICE_TYPE;

typedef enum
{
    DIRECTSOUNDDEVICE_DATAFLOW_RENDER,
    DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE
} DIRECTSOUNDDEVICE_DATAFLOW;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA
{
    GUID    DeviceId;   // DirectSound device id
    BOOL    Present;    // Presence switch
} DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA
{
    LPSTR                       DeviceName; // waveIn/waveOut device name
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;   // Data flow (i.e. waveIn or waveOut)
    GUID                        DeviceId;   // DirectSound device id
} DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA
{
    LPWSTR                      DeviceName; // waveIn/waveOut device name
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;   // Data flow (i.e. waveIn or waveOut)
    GUID                        DeviceId;   // DirectSound device id
} DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA;

#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA
#endif // UNICODE

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
{
    GUID                        DeviceId;               // DirectSound device id
    CHAR                        DescriptionA[0x100];    // Device description (ANSI)
    WCHAR                       DescriptionW[0x100];    // Device description (Unicode)
    CHAR                        ModuleA[MAX_PATH];      // Device driver module (ANSI)
    WCHAR                       ModuleW[MAX_PATH];      // Device driver module (Unicode)
    DIRECTSOUNDDEVICE_TYPE      Type;                   // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;               // Device dataflow
    ULONG                       WaveDeviceId;           // Wave device id
    ULONG                       Devnode;                // Devnode (or DevInst)
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
{
    DIRECTSOUNDDEVICE_TYPE      Type;           // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;       // Device dataflow
    GUID                        DeviceId;       // DirectSound device id
    LPSTR                       Description;    // Device description
    LPSTR                       Module;         // Device driver module
    LPSTR                       Interface;      // Device interface
    ULONG                       WaveDeviceId;   // Wave device id
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
{
    DIRECTSOUNDDEVICE_TYPE      Type;           // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;       // Device dataflow
    GUID                        DeviceId;       // DirectSound device id
    LPWSTR                      Description;    // Device description
    LPWSTR                      Module;         // Device driver module
    LPWSTR                      Interface;      // Device interface
    ULONG                       WaveDeviceId;   // Wave device id
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA;

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
#endif // DIRECTSOUND_VERSION >= 0x0700

typedef BOOL (CALLBACK *LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK1)(PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA, LPVOID);
typedef BOOL (CALLBACK *LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKA)(PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA, LPVOID);
typedef BOOL (CALLBACK *LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKW)(PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA, LPVOID);

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKW
#else // UNICODE
#define LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKA
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK1
#endif // DIRECTSOUND_VERSION >= 0x0700

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA
{
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK1 Callback;   // Callback function pointer
    LPVOID                                  Context;    // Callback function context argument
} DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA
{
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKA Callback;   // Callback function pointer
    LPVOID                                  Context;    // Callback function context argument
} DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA
{
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKW Callback;   // Callback function pointer
    LPVOID                                  Context;    // Callback function context argument
} DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA;

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA
#endif // DIRECTSOUND_VERSION >= 0x0700

// 
// Basic DirectSound Acceleration Properties {1AEAA606-35F0-11D1-B161-00C04FC28ACA}
// 

DEFINE_GUID(DSPROPSETID_DirectSoundBasicAcceleration, 0x1aeaa606, 0x35f0, 0x11d1, 0xb1, 0x61, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum
{
    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION,
} DSPROPERTY_DIRECTSOUNDBASICACCELERATION;

typedef enum
{
    DIRECTSOUNDBASICACCELERATION_NONE,
    DIRECTSOUNDBASICACCELERATION_SAFE,
    DIRECTSOUNDBASICACCELERATION_STANDARD,
    DIRECTSOUNDBASICACCELERATION_FULL,
} DIRECTSOUNDBASICACCELERATION_LEVEL;

#define DIRECTSOUNDBASICACCELERATION_DEFAULT    DIRECTSOUNDBASICACCELERATION_FULL

typedef struct _DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA
{
    GUID                                DeviceId;   // DirectSound device id
    DIRECTSOUNDBASICACCELERATION_LEVEL  Level;      // Basic acceleration level
} DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA, *PDSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA;

// 
// DirectSound Debug Properties {F2957840-260C-11d1-A4D8-00C04FC28ACA}
// 

DEFINE_GUID(DSPROPSETID_DirectSoundDebug, 0xf2957840, 0x260c, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum
{
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A,
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W,
} DSPROPERTY_DIRECTSOUNDDEBUG;

#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A
#endif // UNICODE

#define DIRECTSOUNDDEBUG_DPFINFOF_PRINTFUNCTIONNAME     0x00000001
#define DIRECTSOUNDDEBUG_DPFINFOF_PRINTPROCESSTHREADID  0x00000002
#define DIRECTSOUNDDEBUG_DPFINFOF_PRINTFILELINE         0x00000004

#define DIRECTSOUNDDEBUG_DPFINFOF_DEFAULT               DIRECTSOUNDDEBUG_DPFINFOF_PRINTFUNCTIONNAME

typedef struct _DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA
{
    ULONG   Flags;              // DPF flags
    ULONG   DpfLevel;           // DPF level
    ULONG   BreakLevel;         // Break level
    CHAR    LogFile[MAX_PATH];  // Log file
} DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA
{
    ULONG   Flags;              // DPF flags
    ULONG   DpfLevel;           // DPF level
    ULONG   BreakLevel;         // Break level
    WCHAR   LogFile[MAX_PATH];  // Log file
} DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA;

#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA
#endif // UNICODE

#define DIRECTSOUNDDEBUG_DPFLEVEL_DEFAULT   2
#define DIRECTSOUNDDEBUG_BREAKLEVEL_DEFAULT 0

// 
// DirectSound Persistent Data {1BE55C3E-36AB-11d1-B162-00C04FC28ACA}
// 

DEFINE_GUID(DSPROPSETID_DirectSoundPersistentData, 0x1be55c3e, 0x36ab, 0x11d1, 0xb1, 0x62, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum
{
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A,
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W,
} DSPROPERTY_DIRECTSOUNDPERSISTENTDATA;

#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A
#endif // UNICODE

typedef struct _DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA
{
    GUID    DeviceId;           // DirectSound device id
    LPSTR   SubKeyName;         // Optional subkey name
    LPSTR   ValueName;          // Value name
    ULONG   RegistryDataType;   // Data type
    LPVOID  Data;               // Data pointer
    ULONG   DataSize;           // Size of data buffer, in bytes
} DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA, *PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA
{
    GUID    DeviceId;           // DirectSound device id
    LPWSTR  SubKeyName;         // Optional subkey name
    LPWSTR  ValueName;          // Value name
    ULONG   RegistryDataType;   // Data type
    LPVOID  Data;               // Data pointer
    ULONG   DataSize;           // Size of data buffer, in bytes
} DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA, *PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA;

#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA
#define PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA
#define PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA
#endif // UNICODE

// 
// DirectSound Buffer Properties {50393DEA-51AD-11d2-91B2-00C04FC28ACA}
// 

DEFINE_GUID(DSPROPSETID_DirectSoundBuffer, 0x50393dea, 0x51ad, 0x11d2, 0x91, 0xb2, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum 
{
    DSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID,
} DSPROPERTY_DIRECTSOUNDBUFFER;

typedef struct _DSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID_DATA
{
    LPDIRECTSOUNDBUFFER Buffer;     // Buffer object pointer
    GUID                DeviceId;   // DirectSound device ID
} DSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID_DATA, *PDSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID_DATA;

#ifdef __cplusplus
}
#endif // __cplusplus

#endif  // __DSPRV_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\dsprvobj.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995,1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsprvobj.c
 *  Content:    DirectSound Private Object wrapper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/12/98    dereks  Created.
 *
 ***************************************************************************/

#define DIRECTSOUND_VERSION  0x0600

// We'll ask for what we need, thank you.
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN

// Public includes
#include <windows.h>
#include <mmsystem.h>
#include <dsound.h>
#include "dsprv.h"

// Private includes
#include "dsprvobj.h"


/***************************************************************************
 *
 *  DirectSoundPrivateCreate
 *
 *  Description:
 *      Creates and initializes a DirectSoundPrivate object.
 *
 *  Arguments:
 *      LPKSPROPERTYSET * [out]: receives IKsPropertySet interface to the
 *                               object.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT DirectSoundPrivateCreate
(
    LPKSPROPERTYSET *       ppKsPropertySet
)
{
    typedef HRESULT (STDAPICALLTYPE *LPFNDLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID *);

    HINSTANCE               hLibDsound              = NULL;
    LPFNGETCLASSOBJECT      pfnDllGetClassObject    = NULL;
    LPCLASSFACTORY          pClassFactory           = NULL;
    LPKSPROPERTYSET         pKsPropertySet          = NULL;
    HRESULT                 hr                      = DS_OK;

    // Get dsound.dll's instance handle.  The dll must already be loaded at this
    // point.
    hLibDsound = 
        GetModuleHandle
        (
            TEXT("dsound.dll")
        );

    if(!hLibDsound)
    {
        hr = DSERR_GENERIC;
    }

    // Find DllGetClassObject
    if(SUCCEEDED(hr))
    {
        pfnDllGetClassObject = (LPFNDLLGETCLASSOBJECT)
            GetProcAddress
            (
                hLibDsound, 
                "DllGetClassObject"
            );

        if(!pfnDllGetClassObject)
        {
            hr = DSERR_GENERIC;
        }
    }

    // Create a class factory object    
    if(SUCCEEDED(hr))
    {
        hr = 
            pfnDllGetClassObject
            (
                CLSID_DirectSoundPrivate, 
                IID_IClassFactory, 
                (LPVOID *)&pClassFactory
            );
    }

    // Create the DirectSoundPrivate object and query for an IKsPropertySet
    // interface
    if(SUCCEEDED(hr))
    {
        hr = 
            pClassFactory->CreateInstance
            (
                NULL, 
                IID_IKsPropertySet, 
                (LPVOID *)&pKsPropertySet
            );
    }

    // Release the class factory
    if(pClassFactory)
    {
        pClassFactory->Release();
    }

    // Success
    if(SUCCEEDED(hr))
    {
        *ppKsPropertySet = pKsPropertySet;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvGetMixerSrcQuality
 *
 *  Description:
 *      Gets the mixer SRC quality for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      DIRECTSOUNDMIXER_SRCQUALITY * [out]: receives mixer SRC quality.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetMixerSrcQuality
(
    LPKSPROPERTYSET                             pKsPropertySet,
    REFGUID                                     guidDeviceId,
    DIRECTSOUNDMIXER_SRCQUALITY *               pSrcQuality
)
{
    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA Data;
    HRESULT                                     hr;

    Data.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundMixer,
            DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pSrcQuality = Data.Quality;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvSetMixerSrcQuality
 *
 *  Description:
 *      Sets the mixer SRC quality for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      DIRECTSOUNDMIXER_SRCQUALITY [in]: mixer SRC quality.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetMixerSrcQuality
(
    LPKSPROPERTYSET                             pKsPropertySet,
    REFGUID                                     guidDeviceId,
    DIRECTSOUNDMIXER_SRCQUALITY                 SrcQuality
)
{
    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA Data;
    HRESULT                                     hr;

    Data.DeviceId = guidDeviceId;
    Data.Quality = SrcQuality;

    hr =
        pKsPropertySet->Set
        (
            DSPROPSETID_DirectSoundMixer,
            DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY,
            NULL,
            0,
            &Data,
            sizeof(Data)
        );

    return hr;
}


/***************************************************************************
 *
 *  PrvGetMixerAcceleration
 *
 *  Description:
 *      Gets the mixer acceleration flags for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      LPDWORD [out]: receives acceleration flags.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetMixerAcceleration
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    LPDWORD                                         pdwAcceleration
)
{
    DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA   Data;
    HRESULT                                         hr;

    Data.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundMixer,
            DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pdwAcceleration = Data.Flags;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvSetMixerAcceleration
 *
 *  Description:
 *      Sets the mixer acceleration flags for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      DWORD [in]: acceleration flags.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetMixerAcceleration
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    DWORD                                           dwAcceleration
)
{
    DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA   Data;
    HRESULT                                         hr;

    Data.DeviceId = guidDeviceId;
    Data.Flags = dwAcceleration;

    hr =
        pKsPropertySet->Set
        (
            DSPROPSETID_DirectSoundMixer,
            DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION,
            NULL,
            0,
            &Data,
            sizeof(Data)
        );

    return hr;
}


/***************************************************************************
 *
 *  PrvGetDevicePresence
 *
 *  Description:
 *      Determines whether a device is enabled.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      LPBOOL [out]: receives TRUE if the device is enabled.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetDevicePresence
(
    LPKSPROPERTYSET                             pKsPropertySet,
    REFGUID                                     guidDeviceId,
    LPBOOL                                      pfEnabled
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA  Data;
    HRESULT                                     hr;

    Data.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pfEnabled = Data.Present;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvSetDevicePresence
 *
 *  Description:
 *      Sets whether a device is enabled.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      BOOL [in]: TRUE if the device is enabled.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetDevicePresence
(
    LPKSPROPERTYSET                             pKsPropertySet,
    REFGUID                                     guidDeviceId,
    BOOL                                        fEnabled
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA  Data;
    HRESULT                                     hr;

    Data.DeviceId = guidDeviceId;
    Data.Present = fEnabled;

    hr =
        pKsPropertySet->Set
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE,
            NULL,
            0,
            &Data,
            sizeof(Data)
        );

    return hr;
}


/***************************************************************************
 *
 *  PrvGetWaveDeviceMapping
 *
 *  Description:
 *      Gets the DirectSound device id (if any) for a given waveIn or
 *      waveOut device description.  This is the description given by
 *      waveIn/OutGetDevCaps (szPname).
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      LPCSTR [in]: wave device description.
 *      BOOL [in]: TRUE if the device description refers to a waveIn device.
 *      LPGUID [out]: receives DirectSound device GUID.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetWaveDeviceMapping
(
    LPKSPROPERTYSET                                     pKsPropertySet,
    LPCTSTR                                             pszWaveDevice,
    BOOL                                                fCapture,
    LPGUID                                              pguidDeviceId
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA Data;
    HRESULT                                             hr;

    Data.DeviceName = (LPTSTR)pszWaveDevice;
    Data.DataFlow = fCapture ? DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE : DIRECTSOUNDDEVICE_DATAFLOW_RENDER;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pguidDeviceId = Data.DeviceId;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvGetDeviceDescription
 *
 *  Description:
 *      Gets the extended description for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device id.
 *      PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA [out]: receives
 *                                                            description.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/
HRESULT PrvGetDeviceDescription
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA *ppData
)
{
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA  pData = NULL;
    ULONG                                           cbData;
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA   Basic;
    HRESULT                                         hr;

    Basic.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
            NULL,
            0,
            &Basic,
            sizeof(Basic),
            &cbData
        );

    if(SUCCEEDED(hr))
    {
        pData = (PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA)new BYTE [cbData];

        if(!pData)
        {
            hr = DSERR_OUTOFMEMORY;
        }
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(pData, cbData);

        pData->DeviceId = guidDeviceId;
        
        hr =
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundDevice,
                DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
                NULL,
                0,
                pData,
                cbData,
                NULL
            );
    }

    if(SUCCEEDED(hr))
    {
        *ppData = pData;
    }
    else if(pData)
    {
        delete pData;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvReleaseDeviceDescription
 *
 ***************************************************************************/
HRESULT PrvReleaseDeviceDescription( PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA pData )
{
    delete[] pData;
    return S_OK;
}


/***************************************************************************
 *
 *  PrvEnumerateDevices
 *
 *  Description:
 *      Enumerates all DirectSound devices.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK [in]: pointer to the callback
 *                                                   function.
 *      LPVOID [in]: context argument to pass to the callback function.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvEnumerateDevices
(
    LPKSPROPERTYSET                             pKsPropertySet,
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK      pfnCallback,
    LPVOID                                      pvContext
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA Data;
    HRESULT                                     hr;

    Data.Callback = pfnCallback;
    Data.Context = pvContext;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    return hr;
}


/***************************************************************************
 *
 *  PrvGetBasicAcceleration
 *
 *  Description:
 *      Gets basic acceleration flags for a given DirectSound device.  This
 *      is the accleration level that the multimedia control panel uses.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      DIRECTSOUNDBASICACCELERATION_LEVEL * [out]: receives basic 
 *                                                  acceleration level.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetBasicAcceleration
(
    LPKSPROPERTYSET                                             pKsPropertySet,
    REFGUID                                                     guidDeviceId,
    DIRECTSOUNDBASICACCELERATION_LEVEL *                        pLevel
)
{
    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA   Data;
    HRESULT                                                     hr;

    Data.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundBasicAcceleration,
            DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pLevel = Data.Level;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvSetBasicAcceleration
 *
 *  Description:
 *      Sets basic acceleration flags for a given DirectSound device.  This
 *      is the accleration level that the multimedia control panel uses.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      DIRECTSOUNDBASICACCELERATION_LEVEL [in]: basic acceleration level.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetBasicAcceleration
(
    LPKSPROPERTYSET                                             pKsPropertySet,
    REFGUID                                                     guidDeviceId,
    DIRECTSOUNDBASICACCELERATION_LEVEL                          Level
)
{
    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA   Data;
    HRESULT                                                     hr;

    Data.DeviceId = guidDeviceId;
    Data.Level = Level;

    hr =
        pKsPropertySet->Set
        (
            DSPROPSETID_DirectSoundBasicAcceleration,
            DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION,
            NULL,
            0,
            &Data,
            sizeof(Data)
        );

    return hr;
}


/***************************************************************************
 *
 *  PrvGetDebugInformation
 *
 *  Description:
 *      Gets the current DirectSound debug settings.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      LPDWORD [in]: receives DPF flags.
 *      PULONG [out]: receives DPF level.
 *      PULONG [out]: receives break level.
 *      LPSTR [out]: receives log file name.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetDebugInformation
(
    LPKSPROPERTYSET                             pKsPropertySet,
    LPDWORD                                     pdwFlags,
    PULONG                                      pulDpfLevel,
    PULONG                                      pulBreakLevel,
    LPTSTR                                      pszLogFile
)
{
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA    Data;
    HRESULT                                     hr;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDebug,
            DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr) && pdwFlags)
    {
        *pdwFlags = Data.Flags;
    }

    if(SUCCEEDED(hr) && pulDpfLevel)
    {
        *pulDpfLevel = Data.DpfLevel;
    }

    if(SUCCEEDED(hr) && pulBreakLevel)
    {
        *pulBreakLevel = Data.BreakLevel;
    }

    if(SUCCEEDED(hr) && pszLogFile)
    {
        lstrcpy
        (
            pszLogFile,
            Data.LogFile
        );
    }
    
    return hr;
}


/***************************************************************************
 *
 *  PrvSetDebugInformation
 *
 *  Description:
 *      Sets the current DirectSound debug settings.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      DWORD [in]: DPF flags.
 *      ULONG [in]: DPF level.
 *      ULONG [in]: break level.
 *      LPCSTR [in]: log file name.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetDebugInformation
(
    LPKSPROPERTYSET                             pKsPropertySet,
    DWORD                                       dwFlags,
    ULONG                                       ulDpfLevel,
    ULONG                                       ulBreakLevel,
    LPCTSTR                                     pszLogFile
)
{
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA    Data;
    HRESULT                                     hr;

    Data.Flags = dwFlags;
    Data.DpfLevel = ulDpfLevel;
    Data.BreakLevel = ulBreakLevel;

    lstrcpy
    (
        Data.LogFile,
        pszLogFile
    );
    
    hr =
        pKsPropertySet->Set
        (
            DSPROPSETID_DirectSoundDebug,
            DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO,
            NULL,
            0,
            &Data,
            sizeof(Data)
        );

    return hr;
}


/***************************************************************************
 *
 *  PrvGetPersistentData
 *
 *  Description:
 *      Gets a registry value stored under the DirectSound subkey of a 
 *      specific hardware device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device id.
 *      LPCSTR [in]: subkey path.
 *      LPCSTR [in]: value name.
 *      LPDWORD [in/out]: receives registry data type.
 *      LPVOID [out]: data buffer.
 *      LPDWORD [in/out]: size of above buffer.  On entry, this argument is
 *                        filled with the maximum size of the data buffer.
 *                        On exit, this argument is filled with the required
 *                        size.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetPersistentData
(
    LPKSPROPERTYSET                                         pKsPropertySet,
    REFGUID                                                 guidDeviceId,
    LPCTSTR                                                 pszSubkey,
    LPCTSTR                                                 pszValue,
    LPDWORD                                                 pdwRegType,
    LPVOID                                                  pvData,
    LPDWORD                                                 pcbData
)
{
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA  pPersist;
    ULONG                                                   cbPersist;
    HRESULT                                                 hr;

    cbPersist = sizeof(*pPersist) + *pcbData;
    
    pPersist = (PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA)
        LocalAlloc
        (
            LPTR,
            cbPersist
        );

    if(pPersist)
    {
        pPersist->DeviceId = guidDeviceId;
        pPersist->SubKeyName = (LPTSTR)pszSubkey;
        pPersist->ValueName = (LPTSTR)pszValue;

        if(pdwRegType)
        {
            pPersist->RegistryDataType = *pdwRegType;
        }

        hr =
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundPersistentData,
                DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA,
                NULL,
                0,
                pPersist,
                cbPersist,
                &cbPersist
            );
    }
    else
    {
        hr = DSERR_OUTOFMEMORY;
    }

    if(SUCCEEDED(hr))
    {
        CopyMemory
        (
            pvData,
            pPersist + 1,
            *pcbData
        );
    }
    
    *pcbData = cbPersist - sizeof(*pPersist);

    if(pPersist && pdwRegType)
    {
        *pdwRegType = pPersist->RegistryDataType;
    }

    if(pPersist)
    {
        LocalFree(pPersist);
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvSetPersistentData
 *
 *  Description:
 *      Sets a registry value stored under the DirectSound subkey of a 
 *      specific hardware device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device id.
 *      LPCSTR [in]: subkey path.
 *      LPCSTR [in]: value name.
 *      DWORD [in]: registry data type.
 *      LPVOID [out]: data buffer.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetPersistentData
(
    LPKSPROPERTYSET                                         pKsPropertySet,
    REFGUID                                                 guidDeviceId,
    LPCTSTR                                                 pszSubkey,
    LPCTSTR                                                 pszValue,
    DWORD                                                   dwRegType,
    LPVOID                                                  pvData,
    DWORD                                                   cbData
)
{
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA  pPersist;
    ULONG                                                   cbPersist;
    HRESULT                                                 hr;

    cbPersist = sizeof(*pPersist) + cbData;
    
    pPersist = (PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA)
        LocalAlloc
        (
            LPTR,
            cbPersist
        );

    if(pPersist)
    {
        pPersist->DeviceId = guidDeviceId;
        pPersist->SubKeyName = (LPTSTR)pszSubkey;
        pPersist->ValueName = (LPTSTR)pszValue;
        pPersist->RegistryDataType = dwRegType;

        CopyMemory
        (
            pPersist + 1,
            pvData,
            cbData
        );

        hr =
            pKsPropertySet->Set
            (
                DSPROPSETID_DirectSoundPersistentData,
                DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA,
                NULL,
                0,
                pPersist,
                cbPersist
            );
    }
    else
    {
        hr = DSERR_OUTOFMEMORY;
    }

    if(pPersist)
    {
        LocalFree(pPersist);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\dsprvobj.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995,1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsprvobj.h
 *  Content:    DirectSound Private Object wrapper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/12/98    dereks  Created.
 *
 ***************************************************************************/

#ifndef __DSPRVOBJ_H__
#define __DSPRVOBJ_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

HRESULT DirectSoundPrivateCreate
(
    LPKSPROPERTYSET *   ppKsPropertySet
);

HRESULT PrvGetMixerSrcQuality
(
    LPKSPROPERTYSET                 pKsPropertySet,
    REFGUID                         guidDeviceId,
    DIRECTSOUNDMIXER_SRCQUALITY *   pSrcQuality
);

HRESULT PrvSetMixerSrcQuality
(
    LPKSPROPERTYSET             pKsPropertySet,
    REFGUID                     guidDeviceId,
    DIRECTSOUNDMIXER_SRCQUALITY SrcQuality
);

HRESULT PrvGetMixerAcceleration
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    LPDWORD         pdwAcceleration
);

HRESULT PrvSetMixerAcceleration
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    DWORD           dwAcceleration
);

HRESULT PrvGetDevicePresence
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    LPBOOL          pfEnabled
);

HRESULT PrvSetDevicePresence
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    BOOL            fEnabled
);

HRESULT PrvGetWaveDeviceMapping
(
    LPKSPROPERTYSET pKsPropertySet,
    LPCTSTR         pszWaveDevice,
    BOOL            fCapture,
    LPGUID          pguidDeviceId
);

HRESULT PrvGetDeviceDescription
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA *ppData
);

HRESULT PrvReleaseDeviceDescription
( 
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA pData 
);

HRESULT PrvEnumerateDevices
(
    LPKSPROPERTYSET                         pKsPropertySet,
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK  pfnCallback,
    LPVOID                                  pvContext
);

HRESULT PrvGetBasicAcceleration
(
    LPKSPROPERTYSET                         pKsPropertySet,
    REFGUID                                 guidDeviceId,
    DIRECTSOUNDBASICACCELERATION_LEVEL *    pLevel
);

HRESULT PrvSetBasicAcceleration
(
    LPKSPROPERTYSET                     pKsPropertySet,
    REFGUID                             guidDeviceId,
    DIRECTSOUNDBASICACCELERATION_LEVEL  Level
);

HRESULT PrvGetDebugInformation
(
    LPKSPROPERTYSET pKsPropertySet,
    LPDWORD         pdwFlags,
    PULONG          pulDpfLevel,
    PULONG          pulBreakLevel,
    LPTSTR          pszLogFile
);

HRESULT PrvSetDebugInformation
(
    LPKSPROPERTYSET pKsPropertySet,
    DWORD           dwFlags,
    ULONG           ulDpfLevel,
    ULONG           ulBreakLevel,
    LPCTSTR         pszLogFile
);

HRESULT PrvGetPersistentData
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    LPCTSTR         pszSubkey,
    LPCTSTR         pszValue,
    LPDWORD         pdwRegType,
    LPVOID          pvData,
    LPDWORD         pcbData
);

HRESULT PrvSetPersistentData
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    LPCTSTR         pszSubkey,
    LPCTSTR         pszValue,
    DWORD           dwRegType,
    LPVOID          pvData,
    DWORD           cbData
);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DSPRVOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\fileinfo.h ===
/****************************************************************************
 *
 *    File: fileinfo.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about files on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef FILEINFO_H
#define FILEINFO_H

struct FileInfo
{
    TCHAR m_szName[60];
    TCHAR m_szVersion[50];
    TCHAR m_szLanguage[100];
    TCHAR m_szLanguageLocal[100]; // Localized m_szLanguage
    TCHAR m_szDatestamp[30];
    TCHAR m_szDatestampLocal[30]; // Localized m_szDatestamp
    TCHAR m_szAttributes[50];
    FILETIME m_FileTime;
    LONG m_numBytes;
    BOOL m_bExists;
    BOOL m_bSigned;
    BOOL m_bInUse;
    BOOL m_bBeta;
    BOOL m_bDebug;
    FLOAT m_fStartShipAt;
    FLOAT m_fStopShipAt;
    BOOL m_bOptional;
    BOOL m_bOptionalOnNT;
    BOOL m_bOptionalOnPreDX8;
    BOOL m_bIgnoreVersionInfo;
    BOOL m_bIgnoreDebug;
    BOOL m_bIgnoreBeta;
    BOOL m_bBDA;
    BOOL m_bNotIA64;
    BOOL m_bOptionalOnWOW64;
    BOOL m_bProblem;
    BOOL m_bObsolete; // Note: this is set by DiagnoseDxFiles, not anything in fileinfo
    FileInfo* m_pFileInfoNext;
};


VOID InitFileInfo(VOID);
HRESULT GetComponentFiles(TCHAR* pszFolder, FileInfo** ppFileInfoFirst, 
                          BOOL bSkipMissingFiles, LONG ids);
VOID DestroyFileList(FileInfo* pFileInfoFirst);
VOID ReleaseDigiSignData(VOID);
VOID FileIsSigned(LPTSTR lpszFile, BOOL* pbSigned, BOOL* pbIsValid);
WORD GetLanguageFromFile(const TCHAR* pszFileName, const TCHAR* pszPath);
HRESULT GetFileVersion(TCHAR* pszFile, TCHAR* pszVersion, 
    TCHAR* pszAttributes, TCHAR* pszLanguageLocal, TCHAR* pszLanguage,
    BOOL* pbBeta = NULL, BOOL* pbDebug = NULL);
HRESULT GetRiffFileVersion(TCHAR* pszFile, TCHAR* pszVersion);
BOOL GetFileDateAndSize(TCHAR* pszFile, TCHAR* pszDateLocal, TCHAR* pszDateEnglish, LONG* pnumBytes);

BOOL GetProgramFilesFolder(TCHAR* pszPath);
BOOL GetDxSetupFolder(TCHAR* pszPath);
VOID DiagnoseDxFiles(SysInfo* pSysInfo, FileInfo* pDxComponentsFileInfoFirst, FileInfo* pDxWinComponentsFileInfoFirst );

#endif // FILEINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\guids.cpp ===
/****************************************************************************
 *
 *    File: guids.cpp 
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Defines all GUIDs used by DxDiag.  Can't use dxguid.lib because
 *          dsprv.h GUIDs aren't in it.
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#define INITGUID
#include <windows.h>
#include <mmsystem.h>
#include <ddraw.h>
#include <d3d.h>
#include <dsound.h>
#include "dsprv.h"
#include <dmusicc.h>
#include <dmusici.h>
#include <dplay.h>
#include <hidclass.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\ghost.h ===
/****************************************************************************
 *
 *    File: ghost.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Allow user to remove/restore "ghost" display devices
 *
 * (C) Copyright 1998-1999 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef GHOST_H
#define GHOST_H

VOID AdjustGhostDevices(HWND hwndMain, DisplayInfo* pDisplayInfoFirst);

#endif // GHOST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\inptinfo.cpp ===
/****************************************************************************
 *
 *    File: inptinfo.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about input devices on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#define DIRECTINPUT_VERSION 0x0800

#include <tchar.h>
#include <Windows.h>
#include <regstr.h>
#include <mmsystem.h>
#include <stdio.h>
#include <hidclass.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <dinput.h>
#include "mmddk.h"
#include "reginfo.h"
#include "sysinfo.h" // for BIsPlatformNT
#include "inptinfo.h"
#include "fileinfo.h"
#include "resource.h"

static HRESULT Get9xInputDeviceInfo(InputInfo* pInputInfo);
static HRESULT GetNTInputDeviceInfo(InputInfo* pInputInfo);
static VOID GetJoystickTypeDesc(DWORD dwType, TCHAR* pszDesc);
static HRESULT CheckRegistry(InputInfo* pInputInfo, RegError** ppRegErrorFirst);


/****************************************************************************
 *
 *  GetInputInfo
 *
 ****************************************************************************/
HRESULT GetInputInfo(InputInfo** ppInputInfo)
{
    HRESULT hr;

    *ppInputInfo = new InputInfo;
    if (*ppInputInfo == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(*ppInputInfo, sizeof(InputInfo));

    (*ppInputInfo)->m_bNT = BIsPlatformNT();
    if ((*ppInputInfo)->m_bNT)
    {
        if (FAILED(hr = GetNTInputDeviceInfo(*ppInputInfo)))
            return hr;
    }
    else
    {
        if (FAILED(hr = Get9xInputDeviceInfo(*ppInputInfo)))
            return hr;
    }
    if (FAILED(hr = CheckRegistry(*ppInputInfo, &(*ppInputInfo)->m_pRegErrorFirst)))
        return hr;
    return S_OK;
}


// Have to do the LoadLibrary/GetProcAddress thing for dinput.dll and setupapi.dll:
typedef HRESULT (WINAPI* PfnDirectInputCreateA)(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTA *ppDI, LPUNKNOWN punkOuter);
typedef HRESULT (WINAPI* PfnDirectInputCreateW)(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTW *ppDI, LPUNKNOWN punkOuter);

typedef WINSETUPAPI HDEVINFO (WINAPI* PfnSetupDiGetClassDevsA)(IN CONST GUID *ClassGuid, IN PCSTR Enumerator, IN HWND hwndParent, IN DWORD Flags);
typedef WINSETUPAPI HDEVINFO (WINAPI* PfnSetupDiGetClassDevsW)(IN CONST GUID *ClassGuid, IN PCWSTR Enumerator, IN HWND hwndParent, IN DWORD Flags);
typedef WINSETUPAPI BOOL (WINAPI* PfnSetupDiEnumDeviceInterfaces)(IN HDEVINFO DeviceInfoSet, IN PSP_DEVINFO_DATA DeviceInfoData, IN CONST GUID *InterfaceClassGuid, IN DWORD MemberIndex, OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData);
typedef WINSETUPAPI BOOL (WINAPI* PfnSetupDiGetDeviceInterfaceDetailA)(IN HDEVINFO DeviceInfoSet, IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData, OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData, IN DWORD DeviceInterfaceDetailDataSize, OUT PDWORD RequiredSize, OUT PSP_DEVINFO_DATA DeviceInfoData);
typedef WINSETUPAPI BOOL (WINAPI* PfnSetupDiGetDeviceInterfaceDetailW)(IN HDEVINFO DeviceInfoSet, IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData, OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_W DeviceInterfaceDetailData, IN DWORD DeviceInterfaceDetailDataSize, OUT PDWORD RequiredSize, OUT PSP_DEVINFO_DATA DeviceInfoData);
typedef WINSETUPAPI BOOL (WINAPI* PfnSetupDiDestroyDeviceInfoList)(IN HDEVINFO DeviceInfoSet);
typedef CMAPI CONFIGRET (WINAPI* PfnCM_Get_Parent)(OUT PDEVINST pdnDevInst, IN DEVINST dnDevInst, IN ULONG ulFlags);
typedef CMAPI CONFIGRET (WINAPI* PfnCM_Get_DevNode_Status)(OUT PULONG pulStatus, OUT PULONG pulProblemNumber, IN DEVINST dnDevInst, IN ULONG ulFlags);
typedef CMAPI CONFIGRET (WINAPI* PfnCM_Get_DevNode_Registry_PropertyW)(IN DEVINST dnDevInst, IN  ULONG ulProperty, OUT PULONG pulRegDataType,   OPTIONAL OUT PVOID Buffer, OPTIONAL IN OUT PULONG pulLength, IN ULONG ulFlags);
typedef CMAPI CONFIGRET (WINAPI* PfnCM_Get_DevNode_Registry_PropertyA)(IN DEVINST dnDevInst, IN  ULONG ulProperty, OUT PULONG pulRegDataType,   OPTIONAL OUT PVOID Buffer, OPTIONAL IN OUT PULONG pulLength, IN ULONG ulFlags);

/****************************************************************************
 *
 *  GetNTInputDeviceInfo
 *
 ****************************************************************************/
HRESULT GetNTInputDeviceInfo(InputInfo* pInputInfo)
{
    HINSTANCE hInstDInput = NULL;
    HINSTANCE hInstSetupApi = NULL;
    LPDIRECTINPUT pDI = NULL;
    GUID guidHid;
    HDEVINFO hdev = NULL;
    SP_DEVICE_INTERFACE_DETAIL_DATA* pdidd;
    InputDeviceInfoNT* pInputDeviceInfoNTNew;
    PfnCM_Get_Parent FnCM_Get_Parent = NULL;
    PfnCM_Get_DevNode_Status FnCM_Get_DevNode_Status = NULL;
    PfnSetupDiEnumDeviceInterfaces FnSetupDiEnumDeviceInterfaces = NULL;
    PfnSetupDiDestroyDeviceInfoList FnSetupDiDestroyDeviceInfoList = NULL;
#ifdef UNICODE
    PfnDirectInputCreateW FnDirectInputCreate = NULL;
    PfnCM_Get_DevNode_Registry_PropertyW FnCM_Get_DevNode_Registry_Property = NULL;
    PfnSetupDiGetClassDevsW FnSetupDiGetClassDevs = NULL;
    PfnSetupDiGetDeviceInterfaceDetailW FnSetupDiGetDeviceInterfaceDetail = NULL;
#else
    PfnDirectInputCreateA FnDirectInputCreate = NULL;
    PfnCM_Get_DevNode_Registry_PropertyA FnCM_Get_DevNode_Registry_Property = NULL;
    PfnSetupDiGetClassDevsA FnSetupDiGetClassDevs = NULL;
    PfnSetupDiGetDeviceInterfaceDetailA FnSetupDiGetDeviceInterfaceDetail = NULL;
#endif

    // Apparently one must initialize DInput before enumerating HID devices
    hInstDInput = LoadLibrary(TEXT("dinput.dll"));
    if (hInstDInput == NULL)
        goto LEnd;
#ifdef UNICODE
    FnDirectInputCreate = (PfnDirectInputCreateW)GetProcAddress(hInstDInput, "DirectInputCreateW");
    if (FnDirectInputCreate == NULL)
        goto LEnd;
#else
    FnDirectInputCreate = (PfnDirectInputCreateA)GetProcAddress(hInstDInput, "DirectInputCreateA");
    if (FnDirectInputCreate == NULL)
        goto LEnd;
#endif
    if (SUCCEEDED(FnDirectInputCreate(NULL, 0x0300, &pDI, NULL)))
        pDI->Release(); // immediately drop DI interface; we don't actually use it

    hInstSetupApi = LoadLibrary(TEXT("setupapi.dll"));
    if (hInstSetupApi == NULL)
        goto LEnd;
    FnCM_Get_Parent = (PfnCM_Get_Parent)GetProcAddress(hInstSetupApi, "CM_Get_Parent");
    if (FnCM_Get_Parent == NULL)
        goto LEnd;
    FnCM_Get_DevNode_Status = (PfnCM_Get_DevNode_Status)GetProcAddress(hInstSetupApi, "CM_Get_DevNode_Status");
    if (FnCM_Get_DevNode_Status == NULL)
        goto LEnd;
    FnSetupDiEnumDeviceInterfaces = (PfnSetupDiEnumDeviceInterfaces)GetProcAddress(hInstSetupApi, "SetupDiEnumDeviceInterfaces");
    if (FnSetupDiEnumDeviceInterfaces == NULL)
        goto LEnd;
    FnSetupDiDestroyDeviceInfoList = (PfnSetupDiDestroyDeviceInfoList)GetProcAddress(hInstSetupApi, "SetupDiDestroyDeviceInfoList");
    if (FnSetupDiDestroyDeviceInfoList == NULL)
        goto LEnd;
#ifdef UNICODE
    FnCM_Get_DevNode_Registry_Property = (PfnCM_Get_DevNode_Registry_PropertyW)GetProcAddress(hInstSetupApi, "CM_Get_DevNode_Registry_PropertyW");
    if (FnCM_Get_DevNode_Registry_Property == NULL)
        goto LEnd;
    FnSetupDiGetClassDevs = (PfnSetupDiGetClassDevsW)GetProcAddress(hInstSetupApi, "SetupDiGetClassDevsW");
    if (FnSetupDiGetClassDevs == NULL)
        goto LEnd;
    FnSetupDiGetDeviceInterfaceDetail = (PfnSetupDiGetDeviceInterfaceDetailW)GetProcAddress(hInstSetupApi, "SetupDiGetDeviceInterfaceDetailW");
    if (FnSetupDiGetDeviceInterfaceDetail == NULL)
        goto LEnd;
#else
    FnCM_Get_DevNode_Registry_Property = (PfnCM_Get_DevNode_Registry_PropertyA)GetProcAddress(hInstSetupApi, "CM_Get_DevNode_Registry_PropertyA");
    if (FnCM_Get_DevNode_Registry_Property == NULL)
        goto LEnd;
    FnSetupDiGetClassDevs = (PfnSetupDiGetClassDevsA)GetProcAddress(hInstSetupApi, "SetupDiGetClassDevsA");
    if (FnSetupDiGetClassDevs == NULL)
        goto LEnd;
    FnSetupDiGetDeviceInterfaceDetail = (PfnSetupDiGetDeviceInterfaceDetailA)GetProcAddress(hInstSetupApi, "SetupDiGetDeviceInterfaceDetailA");
    if (FnSetupDiGetDeviceInterfaceDetail == NULL)
        goto LEnd;
#endif

    guidHid = GUID_CLASS_INPUT;
    hdev = FnSetupDiGetClassDevs(&guidHid, 0, 0, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
    if (hdev == INVALID_HANDLE_VALUE || hdev == NULL)
        return E_FAIL;

    int idev;
    //  There is no way to query the number of devices.
    //  You just have to keep incrementing until you run out.
    //  To avoid infinite looping on internal errors, break on any
    //  error once we have tried more than chdiMax devices, since that's the most
    //  HID will ever give us.  64 is a resonable value for chidMax.  It is the 
    //  max allowed USB/HID devices.  
    for (idev = 0; idev < 64/*chdiMax*/; idev++)
    {
        SP_DEVICE_INTERFACE_DATA did;
        did.cbSize = sizeof(did);
        if (!FnSetupDiEnumDeviceInterfaces(hdev, 0, &guidHid, idev, &did))
        {
            if(GetLastError() == ERROR_NO_MORE_ITEMS)
                break;
            else
                continue;
        }

        /*
         *  Ask for the required size then allocate it then fill it.
         *
         *  Note that we don't need to free the memory on the failure
         *  path; our caller will do the necessary memory freeing.
         *
         *  Sigh.  Windows NT and Windows 98 implement
         *  SetupDiGetDeviceInterfaceDetail differently if you are
         *  querying for the buffer size.
         *
         *  Windows 98 returns FALSE, and GetLastError() returns
         *  ERROR_INSUFFICIENT_BUFFER.
         *
         *  Windows NT returns TRUE.
         *
         *  So we allow the cases either where the call succeeds or
         *  the call fails with ERROR_INSUFFICIENT_BUFFER.
         */
        SP_DEVINFO_DATA dinf;
        DWORD cbRequired;
        if (FnSetupDiGetDeviceInterfaceDetail(hdev, &did, 0, 0, &cbRequired, 0) ||
           GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            pdidd = (SP_DEVICE_INTERFACE_DETAIL_DATA*)(new BYTE[cbRequired]);
            if (pdidd == NULL)
                continue;

            ZeroMemory(pdidd, cbRequired);
            pdidd->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

            dinf.cbSize = sizeof(dinf);

            if (!FnSetupDiGetDeviceInterfaceDetail(hdev, &did, pdidd, cbRequired, &cbRequired, &dinf))
            {
                delete pdidd;
                continue;
            }
            delete pdidd;

            DEVINST dinst;
            if (CR_SUCCESS != FnCM_Get_Parent(&dinst, dinf.DevInst, 0))
                continue;

            pInputDeviceInfoNTNew = new InputDeviceInfoNT;
            if (pInputDeviceInfoNTNew == NULL)
                return E_OUTOFMEMORY;
            ZeroMemory(pInputDeviceInfoNTNew, sizeof(InputDeviceInfoNT));
            if (pInputInfo->m_pInputDeviceInfoNTFirst == NULL)
            {
                pInputInfo->m_pInputDeviceInfoNTFirst = pInputDeviceInfoNTNew;
            }
            else
            {
                InputDeviceInfoNT* pInputDeviceInfoNT;
                for (pInputDeviceInfoNT = pInputInfo->m_pInputDeviceInfoNTFirst; 
                    pInputDeviceInfoNT->m_pInputDeviceInfoNTNext != NULL; 
                    pInputDeviceInfoNT = pInputDeviceInfoNT->m_pInputDeviceInfoNTNext)
                    {
                    }
                pInputDeviceInfoNT->m_pInputDeviceInfoNTNext = pInputDeviceInfoNTNew;
            }
            CONFIGRET cr;
            TCHAR sz[200];
            ULONG ulLength;

            ulLength = 200;
            cr = FnCM_Get_DevNode_Registry_Property(dinst, CM_DRP_DEVICEDESC, 
                NULL, (BYTE*)pInputDeviceInfoNTNew->m_szName, &ulLength, NULL);

            // Friendly name is preferably to device desc, but is often (always?) missing
            ulLength = 200;
            cr = FnCM_Get_DevNode_Registry_Property(dinst, CM_DRP_FRIENDLYNAME, 
                NULL, (BYTE*)sz, &ulLength, NULL);
            if (cr == CR_SUCCESS)
                lstrcpy(pInputDeviceInfoNTNew->m_szName, sz);

            ulLength = 200;
            cr = FnCM_Get_DevNode_Registry_Property(dinst, CM_DRP_MFG, 
                NULL, (BYTE*)pInputDeviceInfoNTNew->m_szProvider, &ulLength, NULL);

            ulLength = 200;
            cr = FnCM_Get_DevNode_Registry_Property(dinst, CM_DRP_HARDWAREID, 
                NULL, (BYTE*)pInputDeviceInfoNTNew->m_szId, &ulLength, NULL);

            cr = FnCM_Get_DevNode_Status(&pInputDeviceInfoNTNew->m_dwStatus, &pInputDeviceInfoNTNew->m_dwProblem, dinst, 0);

            
            DEVINST dinstPort;
            if (CR_SUCCESS != FnCM_Get_Parent(&dinstPort, dinst, 0))
                continue;

            ulLength = 200;
            cr = FnCM_Get_DevNode_Registry_Property(dinstPort, CM_DRP_DEVICEDESC, 
                NULL, (BYTE*)pInputDeviceInfoNTNew->m_szPortName, &ulLength, NULL);

            // Friendly name is preferably to device desc, but is often (always?) missing
            ulLength = 200;
            cr = FnCM_Get_DevNode_Registry_Property(dinstPort, CM_DRP_FRIENDLYNAME, 
                NULL, (BYTE*)sz, &ulLength, NULL);
            if (cr == CR_SUCCESS)
                lstrcpy(pInputDeviceInfoNTNew->m_szPortName, sz);

            ulLength = 200;
            cr = FnCM_Get_DevNode_Registry_Property(dinstPort, CM_DRP_MFG, 
                NULL, (BYTE*)pInputDeviceInfoNTNew->m_szPortProvider, &ulLength, NULL);

            ulLength = 200;
            cr = FnCM_Get_DevNode_Registry_Property(dinstPort, CM_DRP_HARDWAREID, 
                NULL, (BYTE*)pInputDeviceInfoNTNew->m_szPortId, &ulLength, NULL);

            cr = FnCM_Get_DevNode_Status(&pInputDeviceInfoNTNew->m_dwPortStatus, &pInputDeviceInfoNTNew->m_dwPortProblem, dinstPort, 0);
        }
    }

LEnd:
    if (hdev != NULL)
        FnSetupDiDestroyDeviceInfoList(hdev);
    if (hInstSetupApi != NULL)
        FreeLibrary(hInstSetupApi);
    if (hInstDInput != NULL)
        FreeLibrary(hInstDInput);

    return S_OK;
}


/****************************************************************************
 *
 *  Get9xInputDeviceInfo
 *
 ****************************************************************************/
HRESULT Get9xInputDeviceInfo(InputInfo* pInputInfo)
{
    DWORD dwDevNum;
    JOYCAPS jc;
    HKEY hkBase;
    HKEY hkDrv;
    HKEY hkData;
    JOYREGHWCONFIG jhwc;
    DWORD dwBufferLen;
    INT i;
    TCHAR szKey[256];
    TCHAR szOEMKey[256];
    HKEY hkOEMBase;
    HKEY hkOEMData;
    TCHAR szOEMName[256];
    TCHAR szOEMCallout[256];
    InputDeviceInfo* pInputDeviceInfoNew;
    InputDeviceInfo* pInputDeviceInfo;
    TCHAR szPath[MAX_PATH];
    TCHAR sz[200];

    dwDevNum = (DWORD)-1;
    if (JOYERR_NOERROR == joyGetDevCaps(dwDevNum, &jc, sizeof jc))
    {
        if ((ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_JOYCONFIG, 0, KEY_READ, &hkBase))
            && (ERROR_SUCCESS == RegOpenKeyEx(hkBase, jc.szRegKey, 0, KEY_READ, &hkDrv))
            && (ERROR_SUCCESS == RegOpenKeyEx(hkDrv, REGSTR_KEY_JOYCURR, 0, KEY_READ, &hkData)))
        {
            for (i = 0; i < 20; i++)
            {
                wsprintf(szKey, REGSTR_VAL_JOYNCONFIG, i + 1);
                dwBufferLen = sizeof JOYREGHWCONFIG;

                if (ERROR_SUCCESS == RegQueryValueEx(hkData, szKey, 0, NULL, (LPBYTE)&jhwc, &dwBufferLen))
                {
                    // Skip devices whose type is JOY_HW_NONE.
                    if (jhwc.dwType == JOY_HW_NONE)
                        continue; 

                    pInputDeviceInfoNew = new InputDeviceInfo;
                    if (pInputDeviceInfoNew == NULL)
                        return E_OUTOFMEMORY;
                    ZeroMemory(pInputDeviceInfoNew, sizeof(InputDeviceInfo));
                    if (pInputInfo->m_pInputDeviceInfoFirst == NULL)
                    {
                        pInputInfo->m_pInputDeviceInfoFirst = pInputDeviceInfoNew;
                    }
                    else
                    {
                        for (pInputDeviceInfo = pInputInfo->m_pInputDeviceInfoFirst; 
                            pInputDeviceInfo->m_pInputDeviceInfoNext != NULL; 
                            pInputDeviceInfo = pInputDeviceInfo->m_pInputDeviceInfoNext)
                            {
                            }
                        pInputDeviceInfo->m_pInputDeviceInfoNext = pInputDeviceInfoNew;
                    }

                    pInputDeviceInfoNew->m_dwUsageSettings = jhwc.dwUsageSettings;
                    wsprintf(pInputDeviceInfoNew->m_szSettings, TEXT("0x%08x"), jhwc.dwUsageSettings);
                    if (JOY_US_PRESENT & jhwc.dwUsageSettings)
                    {
                        LoadString(NULL, IDS_JOYSTICKPRESENT, sz, 200);
                        lstrcat(pInputDeviceInfoNew->m_szSettings, sz);
                    }

                    // Try reading an OEM name
                    wsprintf(szKey, REGSTR_VAL_JOYNOEMNAME, i + 1);
                    dwBufferLen = sizeof szOEMKey;
                    szOEMKey[0] = 0;
                    szOEMName[0] = 0;
                    if (ERROR_SUCCESS == RegQueryValueEx(hkData, szKey, 0, NULL, (LPBYTE)szOEMKey, &dwBufferLen))
                    {
                        hkOEMBase = 0;
                        hkOEMData = 0;

                        // If there is an OEM name, look in the PrivateProperties to find out 
                        // the name of the device as shown in the control panel applet.
                        if((szOEMKey[0] != 0)
                            && (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_JOYOEM, 0, KEY_READ, &hkOEMBase))
                            && (ERROR_SUCCESS == RegOpenKeyEx(hkOEMBase, szOEMKey, 0, KEY_READ, &hkOEMData))
                            && (ERROR_SUCCESS == RegQueryValueEx(hkOEMData, REGSTR_VAL_JOYOEMNAME, 0, NULL, NULL, &dwBufferLen))
                            && dwBufferLen)
                        {
                            dwBufferLen = sizeof szOEMName;
                            RegQueryValueEx(hkOEMData, REGSTR_VAL_JOYOEMNAME, 0, NULL, (LPBYTE)szOEMName, &dwBufferLen);
                        }
                        if (hkOEMData)
                            RegCloseKey(hkOEMData);
                    }

                    if (hkOEMBase)
                        RegCloseKey(hkOEMBase);
                    
                    if (szOEMName[0] != 0)
                        lstrcpy(pInputDeviceInfoNew->m_szDeviceName, szOEMName);
                    else
                        GetJoystickTypeDesc(jhwc.dwType, pInputDeviceInfoNew->m_szDeviceName);

                    wsprintf(szKey, REGSTR_VAL_JOYNOEMCALLOUT, i + 1);
                    dwBufferLen = sizeof szOEMCallout;

                    if (ERROR_SUCCESS == RegQueryValueEx(hkData, szKey, 0, NULL, (LPBYTE)&szOEMCallout, &dwBufferLen))
                    {
                        lstrcpy(pInputDeviceInfoNew->m_szDriverName, szOEMCallout);
                        GetSystemDirectory(szPath, MAX_PATH);
                        lstrcat(szPath, TEXT("\\"));
                        lstrcat(szPath, szOEMCallout);
                        GetFileVersion(szPath, pInputDeviceInfoNew->m_szDriverVersion, 
                            pInputDeviceInfoNew->m_szDriverAttributes, pInputDeviceInfoNew->m_szDriverLanguageLocal, pInputDeviceInfoNew->m_szDriverLanguage,
                            &pInputDeviceInfoNew->m_bBeta, &pInputDeviceInfoNew->m_bDebug);
                        GetFileDateAndSize(szPath, pInputDeviceInfoNew->m_szDriverDateLocal, pInputDeviceInfoNew->m_szDriverDate, &pInputDeviceInfoNew->m_numBytes);
                        FileIsSigned(szPath, &pInputDeviceInfoNew->m_bDriverSigned, &pInputDeviceInfoNew->m_bDriverSignedValid);
                    }
                    else
                    {
                        LoadString(NULL, IDS_DEFAULT, pInputDeviceInfoNew->m_szDriverName, 100);
                    }
                }
            }
        }
    }

    return S_OK;
}


/****************************************************************************
 *
 *  GetJoystickTypeDesc
 *
 ****************************************************************************/
VOID GetJoystickTypeDesc(DWORD dwType, TCHAR* pszDesc)
{
    LONG ids;

    switch(dwType)
    {
        case JOY_HW_NONE:
            ids = IDS_JOY_HW_NONE;
            break;
        case JOY_HW_CUSTOM:
            ids = IDS_JOY_HW_CUSTOM;
            break;
        case JOY_HW_2A_2B_GENERIC:
            ids = IDS_JOY_HW_2A_2B_GENERIC;
            break;
        case JOY_HW_2A_4B_GENERIC:
            ids = IDS_JOY_HW_2A_4B_GENERIC;
            break;
        case JOY_HW_2B_GAMEPAD:
            ids = IDS_JOY_HW_2B_GAMEPAD;
            break;
        case JOY_HW_2B_FLIGHTYOKE:
            ids = IDS_JOY_HW_2B_FLIGHTYOKE;
            break;
        case JOY_HW_2B_FLIGHTYOKETHROTTLE:
            ids = IDS_JOY_HW_2B_FLIGHTYOKETHROTTLE;
            break;
        case JOY_HW_3A_2B_GENERIC:
            ids = IDS_JOY_HW_3A_2B_GENERIC;
            break;
        case JOY_HW_3A_4B_GENERIC:
            ids = IDS_JOY_HW_3A_4B_GENERIC;
            break;
        case JOY_HW_4B_GAMEPAD:
            ids = IDS_JOY_HW_4B_GAMEPAD;
            break;
        case JOY_HW_4B_FLIGHTYOKE:
            ids = IDS_JOY_HW_4B_FLIGHTYOKE;
            break;
        case JOY_HW_4B_FLIGHTYOKETHROTTLE:
            ids = IDS_JOY_HW_4B_FLIGHTYOKETHROTTLE;
            break;
        default:
            ids = IDS_JOY_UNKNOWN;
            break;
    }
    LoadString(NULL, ids, pszDesc, 60);
}



/****************************************************************************
 *
 *  GetInputDriverInfo
 *
 ****************************************************************************/
HRESULT GetInputDriverInfo(InputInfo* pInputInfo)
{
    HKEY hkBase;
    HKEY hkDrv;
    HKEY hkMedia;
    HKEY hkMediaDriver;
    DWORD dwIndex = 0;
    TCHAR szName[100];
    DWORD dwNameSize;
    TCHAR szClass[100];
    DWORD dwClassSize;
    InputDriverInfo* pInputDriverInfoNew;
    InputDriverInfo* pInputDriverInfo;
    DWORD dwBufferLen;
    TCHAR szActive[10];
    TCHAR szSubMediaKey[10];

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_JOYCONFIG, 0, KEY_READ, &hkBase))
        return S_OK; // This key doesn't exist on NT, so exit silently for now.
    dwNameSize = 100;
    dwClassSize = 100;
    while (ERROR_SUCCESS == RegEnumKeyEx(hkBase, dwIndex, szName, 
        &dwNameSize, NULL, szClass, &dwClassSize, NULL))
    {
        if (szName[dwNameSize - 1] == '>' &&
            szName[dwNameSize - 6] == '<')
        {
            // It's a driver
            pInputDriverInfoNew = new InputDriverInfo;
            if (pInputDriverInfoNew == NULL)
                return E_OUTOFMEMORY;
            ZeroMemory(pInputDriverInfoNew, sizeof(InputDriverInfo));
            if (pInputInfo->m_pInputDriverInfoFirst == NULL)
            {
                pInputInfo->m_pInputDriverInfoFirst = pInputDriverInfoNew;
            }
            else
            {
                for (pInputDriverInfo = pInputInfo->m_pInputDriverInfoFirst; 
                    pInputDriverInfo->m_pInputDriverInfoNext != NULL; 
                    pInputDriverInfo = pInputDriverInfo->m_pInputDriverInfoNext)
                    {
                    }
                pInputDriverInfo->m_pInputDriverInfoNext = pInputDriverInfoNew;
            }
            lstrcpy(pInputDriverInfoNew->m_szRegKey, szName);

            // Read info from reg key
            if (ERROR_SUCCESS != RegOpenKeyEx(hkBase, szName, 0, KEY_READ, &hkDrv))
                return E_FAIL;
            dwBufferLen = 100;
            RegQueryValueEx(hkDrv, TEXT("DeviceID"), 0, NULL, (LPBYTE)pInputDriverInfoNew->m_szDeviceID, &dwBufferLen);
            dwBufferLen = 10;
            RegQueryValueEx(hkDrv, TEXT("Active"), 0, NULL, (LPBYTE)szActive, &dwBufferLen);
            if (lstrcmp(szActive, TEXT("1")) == 0)
                pInputDriverInfoNew->m_bActive = TRUE;
            dwBufferLen = 100;
            RegQueryValueEx(hkDrv, TEXT("Driver"), 0, NULL, (LPBYTE)pInputDriverInfoNew->m_szDriver16, &dwBufferLen);
            RegCloseKey(hkDrv);
            
            // Open corresponding key under Services\Class\Media and read more info
            lstrcpy(szSubMediaKey, &szName[dwNameSize - 5]);
            szSubMediaKey[4] = '\0';
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_CLASS TEXT("\\") REGSTR_KEY_MEDIA_CLASS, 0, KEY_READ, &hkMedia))
            {
                if (ERROR_SUCCESS == RegOpenKeyEx(hkMedia, szSubMediaKey, 0, KEY_READ, &hkMediaDriver))
                {
                    dwBufferLen = 100;
                    RegQueryValueEx(hkMediaDriver, TEXT("MatchingDeviceId"), 0, NULL, (LPBYTE)pInputDriverInfoNew->m_szMatchingDeviceID, &dwBufferLen);
                    dwBufferLen = 100;
                    RegQueryValueEx(hkMediaDriver, TEXT("Driver"), 0, NULL, (LPBYTE)pInputDriverInfoNew->m_szDriver32, &dwBufferLen);
                    RegCloseKey(hkMediaDriver);
                }
                RegCloseKey(hkMedia);
            }
        }
        dwNameSize = 100;
        dwClassSize = 100;
        dwIndex++;
    }
    RegCloseKey(hkBase);

    return S_OK;
}


/****************************************************************************
 *
 *  CheckRegistry
 *
 ****************************************************************************/
HRESULT CheckRegistry(InputInfo* pInputInfo, RegError** ppRegErrorFirst)
{
    HRESULT hr;
    HKEY HKCR = HKEY_CLASSES_ROOT;

    TCHAR szVersion[100];
    HKEY hkey;
    DWORD cbData;
    ULONG ulType;

    DWORD dwMajor = 0;
    DWORD dwMinor = 0;
    DWORD dwRevision = 0;
    DWORD dwBuild = 0;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectX"),
        0, KEY_READ, &hkey))
    {
        cbData = 100;
        RegQueryValueEx(hkey, TEXT("Version"), 0, &ulType, (LPBYTE)szVersion, &cbData);
        RegCloseKey(hkey);
        if (lstrlen(szVersion) > 6 && 
            lstrlen(szVersion) < 20)
        {
            _stscanf(szVersion, TEXT("%d.%d.%d.%d"), &dwMajor, &dwMinor, &dwRevision, &dwBuild);
        }
    }

    // No registry checking on DX versions before DX7
    if (dwMinor < 7)
        return S_OK;

    // 34644: check for poll flags 
    DWORD dwData = 0;
    DWORD dwSize = sizeof(dwData);
    DWORD dwType;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\control\\MediaProperties\\PrivateProperties\\Joystick\\OEM\\Standard Gameport"),
        0, KEY_READ, &hkey))
    {
        RegQueryValueEx(hkey, TEXT("PollFlags"), NULL, &dwType, (BYTE *)&dwData, &dwSize);
        RegCloseKey(hkey);
    }
    pInputInfo->m_bPollFlags = ( dwData == 0x00000001 );

    // From dinput.inf:
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{25E609E0-B259-11CF-BFC7-444553540000}"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{25E609E0-B259-11CF-BFC7-444553540000}\\InProcServer32"), TEXT(""), TEXT("dinput.dll"), CRF_LEAF)))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{25E609E0-B259-11CF-BFC7-444553540000}\\InprocServer32"), TEXT("ThreadingModel"), TEXT("Both"))))
        return hr;

    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{25E609E1-B259-11CF-BFC7-444553540000}"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{25E609E1-B259-11CF-BFC7-444553540000}\\InProcServer32"), TEXT(""), TEXT("dinput.dll"), CRF_LEAF)))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{25E609E1-B259-11CF-BFC7-444553540000}\\InprocServer32"), TEXT("ThreadingModel"), TEXT("Both"))))
        return hr;

    if (!BIsPlatformNT())
    {
        if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{92187326-72B4-11d0-A1AC-0000F8026977}"), TEXT(""), TEXT("*"))))
            return hr;
        if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{92187326-72B4-11d0-A1AC-0000F8026977}\\ProgID"), TEXT(""), TEXT("*"))))
            return hr;

        // Bug 119850: gchand.dll doesn't need to be on any DX7 OS.
//      if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{92187326-72B4-11d0-A1AC-0000F8026977}\\InProcHandler32"), TEXT(""), TEXT("gchand.dll"), CRF_LEAF)))
//          return hr;

        if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{92187326-72B4-11d0-A1AC-0000F8026977}\\InProcServer32"), TEXT(""), TEXT("gcdef.dll"), CRF_LEAF)))
            return hr;
        if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{92187326-72B4-11d0-A1AC-0000F8026977}\\InprocServer32"), TEXT("ThreadingModel"), TEXT("Apartment"))))
            return hr;
    }

    return S_OK;
}


/****************************************************************************
 *
 *  DestroyInputInfo
 *
 ****************************************************************************/
VOID DestroyInputInfo(InputInfo* pInputInfo)
{
    if( pInputInfo )
    {
        DestroyReg( &pInputInfo->m_pRegErrorFirst );

        InputDeviceInfo* pInputDeviceInfo;
        InputDeviceInfo* pInputDeviceInfoNext;

        for (pInputDeviceInfo = pInputInfo->m_pInputDeviceInfoFirst; pInputDeviceInfo != NULL; 
            pInputDeviceInfo = pInputDeviceInfoNext)
        {
            pInputDeviceInfoNext = pInputDeviceInfo->m_pInputDeviceInfoNext;
            delete pInputDeviceInfo;
        }

        InputDeviceInfoNT* pInputDeviceNTInfo;
        InputDeviceInfoNT* pInputDeviceNTInfoNext;

        for (pInputDeviceNTInfo = pInputInfo->m_pInputDeviceInfoNTFirst; pInputDeviceNTInfo != NULL; 
            pInputDeviceNTInfo = pInputDeviceNTInfoNext)
        {
            pInputDeviceNTInfoNext = pInputDeviceNTInfo->m_pInputDeviceInfoNTNext;
            delete pInputDeviceNTInfo;
        }

        InputDriverInfo* pInputDriverInfo;
        InputDriverInfo* pInputDriverInfoNext;

        for (pInputDriverInfo = pInputInfo->m_pInputDriverInfoFirst; pInputDriverInfo != NULL; 
            pInputDriverInfo = pInputDriverInfoNext)
        {
            pInputDriverInfoNext = pInputDriverInfo->m_pInputDriverInfoNext;
            delete pInputDriverInfo;
        }

        delete pInputInfo;
    }
}



/****************************************************************************
 *
 *  DiagnoseInput
 *
 ****************************************************************************/
VOID DiagnoseInput(SysInfo* pSysInfo, InputInfo* pInputInfo)
{
    InputDeviceInfo* pInputDeviceInfo;
    InputDeviceInfoNT* pInputDeviceInfoNT;
    TCHAR szDebug[200];
    TCHAR szBeta[200];
    LONG lwNumDebug;
    LONG lwNumBeta;
    TCHAR szListContinuer[30];
    TCHAR szListEtc[30];
    TCHAR szFmt[300];
    TCHAR szMessage[300];
    BOOL bProblem = FALSE;

    if( pInputInfo == NULL )
        return;

    lwNumDebug = 0;
    lwNumBeta = 0;
    LoadString(NULL, IDS_LISTCONTINUER, szListContinuer, 30);
    LoadString(NULL, IDS_LISTETC, szListEtc, 30);
    for (pInputDeviceInfo = pInputInfo->m_pInputDeviceInfoFirst; pInputDeviceInfo != NULL; 
        pInputDeviceInfo = pInputDeviceInfo->m_pInputDeviceInfoNext)
    {
        if (pInputDeviceInfo->m_bBeta)
        {
            pInputDeviceInfo->m_bProblem = TRUE;
            bProblem = TRUE;
            lwNumBeta++;
            if (lwNumBeta == 1)
            {
                lstrcpy(szBeta, pInputDeviceInfo->m_szDriverName);
            }
            else if (lwNumBeta < 4)
            {
                lstrcat(szBeta, szListContinuer);
                lstrcat(szBeta, pInputDeviceInfo->m_szDriverName);
            }
            else if (lwNumBeta < 5)
            {
                lstrcat(szBeta, szListEtc);
            }
        }
        if (pInputDeviceInfo->m_bDebug)
        {
            pInputDeviceInfo->m_bProblem = TRUE;
            bProblem = TRUE;
            lwNumDebug++;
            if (lwNumDebug == 1)
            {
                lstrcpy(szDebug, pInputDeviceInfo->m_szDriverName);
            }
            else if (lwNumDebug < 4)
            {
                lstrcat(szDebug, szListContinuer);
                lstrcat(szDebug, pInputDeviceInfo->m_szDriverName);
            }
            else if (lwNumDebug < 5)
            {
                lstrcat(szDebug, szListEtc);
            }
        }
    }

    _tcscpy( pSysInfo->m_szInputNotes, TEXT("") );
    _tcscpy( pSysInfo->m_szInputNotesEnglish, TEXT("") );

    for (pInputDeviceInfoNT = pInputInfo->m_pInputDeviceInfoNTFirst; pInputDeviceInfoNT != NULL;
        pInputDeviceInfoNT = pInputDeviceInfoNT->m_pInputDeviceInfoNTNext)
    {
        if (pInputDeviceInfoNT->m_dwProblem != 0)
        {
            bProblem = TRUE;
            pInputDeviceInfoNT->m_bProblem = TRUE;

            LoadString(NULL, IDS_INPUTDEVPROBLEMFMT, szFmt, 300);
            wsprintf(szMessage, szFmt, pInputDeviceInfoNT->m_szName, pInputDeviceInfoNT->m_dwProblem);
            _tcscat( pSysInfo->m_szInputNotes, szMessage );

            LoadString(NULL, IDS_INPUTDEVPROBLEMFMT_ENGLISH, szFmt, 300);
            wsprintf(szMessage, szFmt, pInputDeviceInfoNT->m_szName, pInputDeviceInfoNT->m_dwProblem);
            _tcscat( pSysInfo->m_szInputNotesEnglish, szMessage );
        }
        if (pInputDeviceInfoNT->m_dwPortProblem != 0)
        {
            bProblem = TRUE;
            pInputDeviceInfoNT->m_bProblem = TRUE;

            LoadString(NULL, IDS_INPUTPORTPROBLEMFMT, szFmt, 300);
            wsprintf(szMessage, szFmt, pInputDeviceInfoNT->m_szPortName, pInputDeviceInfoNT->m_dwPortProblem);
            _tcscat( pSysInfo->m_szInputNotes, szMessage );

            LoadString(NULL, IDS_INPUTPORTPROBLEMFMT_ENGLISH, szFmt, 300);
            wsprintf(szMessage, szFmt, pInputDeviceInfoNT->m_szPortName, pInputDeviceInfoNT->m_dwPortProblem);
            _tcscat( pSysInfo->m_szInputNotesEnglish, szMessage );
        }
    }

    if (lwNumBeta > 0)
    {
        if (lwNumBeta == 1)
            LoadString(NULL, IDS_BETADRIVERFMT1, szFmt, 300);
        else
            LoadString(NULL, IDS_BETADRIVERFMT2, szFmt, 300);
        wsprintf(szMessage, szFmt, szBeta);
        _tcscat( pSysInfo->m_szInputNotes, szMessage );

        if (lwNumBeta == 1)
            LoadString(NULL, IDS_BETADRIVERFMT1_ENGLISH, szFmt, 300);
        else
            LoadString(NULL, IDS_BETADRIVERFMT2_ENGLISH, szFmt, 300);
        wsprintf(szMessage, szFmt, szBeta);
        _tcscat( pSysInfo->m_szInputNotesEnglish, szMessage );
    }

    if (lwNumDebug > 0)
    {
        if (lwNumDebug == 1)
            LoadString(NULL, IDS_DEBUGDRIVERFMT1, szFmt, 300);
        else
            LoadString(NULL, IDS_DEBUGDRIVERFMT2, szFmt, 300);
        wsprintf(szMessage, szFmt, szDebug);
        _tcscat( pSysInfo->m_szInputNotes, szMessage );

        if (lwNumDebug == 1)
            LoadString(NULL, IDS_DEBUGDRIVERFMT1_ENGLISH, szFmt, 300);
        else
            LoadString(NULL, IDS_DEBUGDRIVERFMT2_ENGLISH, szFmt, 300);
        wsprintf(szMessage, szFmt, szDebug);
        _tcscat( pSysInfo->m_szInputNotesEnglish, szMessage );
    }

    if (pInputInfo->m_pInputDeviceInfoFirst == NULL && 
        pInputInfo->m_pInputDeviceInfoNTFirst == NULL)
    {
        LoadString(NULL, IDS_NOINPUT, szMessage, 300);
        _tcscat( pSysInfo->m_szInputNotes, szMessage );

        LoadString(NULL, IDS_NOINPUT_ENGLISH, szMessage, 300);
        _tcscat( pSysInfo->m_szInputNotesEnglish, szMessage );
    }
    if (pInputInfo->m_pRegErrorFirst != NULL)
    {
        bProblem = TRUE;
        LoadString(NULL, IDS_REGISTRYPROBLEM, szMessage, 300);
        _tcscat( pSysInfo->m_szInputNotes, szMessage );

        LoadString(NULL, IDS_REGISTRYPROBLEM_ENGLISH, szMessage, 300);
        _tcscat( pSysInfo->m_szInputNotesEnglish, szMessage );
    }
    if (!bProblem)
    {
        LoadString(NULL, IDS_NOPROBLEM, szMessage, 300);
        _tcscat( pSysInfo->m_szInputNotes, szMessage );

        LoadString(NULL, IDS_NOPROBLEM_ENGLISH, szMessage, 300);
        _tcscat( pSysInfo->m_szInputNotesEnglish, szMessage );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\ghost.cpp ===
/****************************************************************************
 *
 *    File: ghost.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Allow user to remove/restore "ghost" display devices
 *
 * (C) Copyright 1998-1999 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <tchar.h>
#include <Windows.h>
#include <multimon.h>
#include "reginfo.h"
#include "sysinfo.h"
#include "dispinfo.h"
#include "resource.h"

// Structure for ghost display devices
struct Ghost
{
    TCHAR m_szKey[100];
    TCHAR m_szDesc[100];
    Ghost* m_pGhostPrev;
    Ghost* m_pGhostNext;
};

static VOID BuildGhostList(BOOL bBackedUp, DisplayInfo* pDisplayInfoFirst, Ghost** ppGhostFirst);
static INT_PTR CALLBACK GhostDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static VOID UpdateStuff(HWND hwnd);
static VOID MoveSelectedItems(HWND hwnd, BOOL bBackup);
static BOOL MoveGhost(HWND hwnd, Ghost* pGhost, BOOL bBackup);
static DWORD RegCreateTree(HKEY hTree, HKEY hReplacement);
static DWORD RegCreateValues(HKEY hReplacement, LPCTSTR lpSubKey, HKEY hNewKey);
static VOID RemoveFromListBox(Ghost* pGhost, HWND hwndList);
static VOID FreeGhostList(Ghost** ppGhostFirst);

static Ghost* s_pGhostBackedUpFirst = NULL;
static Ghost* s_pGhostRestoredFirst = NULL;



/****************************************************************************
 *
 *  AdjustGhostDevices
 *
 ****************************************************************************/
VOID AdjustGhostDevices(HWND hwndMain, DisplayInfo* pDisplayInfoFirst)
{
    HINSTANCE hinst = (HINSTANCE)GetWindowLongPtr(hwndMain, GWLP_HINSTANCE);

    BuildGhostList(TRUE, NULL, &s_pGhostBackedUpFirst);
    BuildGhostList(FALSE, pDisplayInfoFirst, &s_pGhostRestoredFirst);
    DialogBox(hinst, MAKEINTRESOURCE(IDD_GHOST), hwndMain, GhostDialogProc);
    FreeGhostList(&s_pGhostBackedUpFirst);
    FreeGhostList(&s_pGhostRestoredFirst);
}


/****************************************************************************
 *
 *  BuildGhostList
 *
 ****************************************************************************/
VOID BuildGhostList(BOOL bBackedUp, DisplayInfo* pDisplayInfoFirst, Ghost** ppGhostFirst)
{
    HKEY hkey;
    HKEY hkey2;
    DisplayInfo* pDisplayInfo;
    TCHAR* pszCompare;
    TCHAR szName[100];
    LONG iKey;
    Ghost* pGhostNew;
    DWORD cbData = 100;
    DWORD dwType;
    BOOL bActive;

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, bBackedUp ? 
        TEXT("System\\CurrentControlSet\\Services\\Class\\DisplayBackup") : 
        TEXT("System\\CurrentControlSet\\Services\\Class\\Display"), KEY_ALL_ACCESS, NULL, &hkey))
    {
        return;
    }

    iKey = 0;
    while (ERROR_SUCCESS == RegEnumKey(hkey, iKey, szName, 100))
    {
        bActive = FALSE; // unless found TRUE below
        for (pDisplayInfo = pDisplayInfoFirst; pDisplayInfo != NULL; pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext)
        {
            pszCompare = pDisplayInfo->m_szKeyDeviceKey;
            if (lstrlen(pszCompare) > 4)
            {
                pszCompare += (lstrlen(pszCompare) - 4);
                if (lstrcmp(szName, pszCompare) == 0)
                {
                    bActive = TRUE;
                    break;
                }
            }
        }
        if (!bActive &&
            ERROR_SUCCESS == RegOpenKeyEx(hkey, szName, KEY_ALL_ACCESS, NULL, &hkey2))
        {
            pGhostNew = new Ghost;
            if (pGhostNew != NULL)
            {
                ZeroMemory(pGhostNew, sizeof(Ghost));
                cbData = 100;
                RegQueryValueEx(hkey2, TEXT("DriverDesc"), 0, &dwType, (LPBYTE)pGhostNew->m_szDesc, &cbData);
                lstrcpy(pGhostNew->m_szKey, szName);
                pGhostNew->m_pGhostNext = *ppGhostFirst;
                if (pGhostNew->m_pGhostNext != NULL)
                    pGhostNew->m_pGhostNext->m_pGhostPrev = pGhostNew;
                *ppGhostFirst = pGhostNew;
            }
            RegCloseKey(hkey2);
        }
        iKey++;
    }

    RegCloseKey(hkey);
}


/****************************************************************************
 *
 *  GhostDialogProc
 *
 ****************************************************************************/
INT_PTR CALLBACK GhostDialogProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    HWND hwndRList = GetDlgItem(hwnd, IDC_RESTOREDLIST);
    HWND hwndBList = GetDlgItem(hwnd, IDC_BACKEDUPLIST);
    Ghost* pGhost;
    TCHAR sz[200];
    LRESULT iItem;

    switch (msg)
    {
    case WM_INITDIALOG:
        for (pGhost = s_pGhostRestoredFirst; pGhost != NULL; pGhost = pGhost->m_pGhostNext)
        {
            wsprintf(sz, TEXT("%s: %s"), pGhost->m_szKey, pGhost->m_szDesc);
            iItem = SendMessage(hwndRList, LB_ADDSTRING, 0, (LPARAM)sz);
            SendMessage(hwndRList, LB_SETITEMDATA, iItem, (LPARAM)pGhost);
        }

        for (pGhost = s_pGhostBackedUpFirst; pGhost != NULL; pGhost = pGhost->m_pGhostNext)
        {
            wsprintf(sz, TEXT("%s: %s"), pGhost->m_szKey, pGhost->m_szDesc);
            iItem = SendMessage(hwndBList, LB_ADDSTRING, 0, (LPARAM)sz);
            SendMessage(hwndBList, LB_SETITEMDATA, iItem, (LPARAM)pGhost);
        }
        UpdateStuff(hwnd);
        return TRUE;

    case WM_COMMAND:
        {
            WORD wID = LOWORD(wparam);
            switch(wID)
            {
            case IDCANCEL:
                EndDialog(hwnd, IDCANCEL);
                break;
            case IDOK:
                EndDialog(hwnd, IDOK);
                break;
            case IDC_RESTOREDLIST:
                if (HIWORD(wparam) == LBN_SELCHANGE)
                {
                    if (SendMessage(hwndRList, LB_GETSELCOUNT, 0, 0) > 0)
                        EnableWindow(GetDlgItem(hwnd, IDC_BACKUP), TRUE);
                    else
                        EnableWindow(GetDlgItem(hwnd, IDC_BACKUP), FALSE);
                }
                break;
            case IDC_BACKEDUPLIST:
                if (HIWORD(wparam) == LBN_SELCHANGE)
                {
                    if (SendMessage(hwndBList, LB_GETSELCOUNT, 0, 0) > 0)
                        EnableWindow(GetDlgItem(hwnd, IDC_RESTORE), TRUE);
                    else
                        EnableWindow(GetDlgItem(hwnd, IDC_RESTORE), FALSE);
                }
                break;
            case IDC_BACKUP:
                MoveSelectedItems(hwnd, TRUE);
                UpdateStuff(hwnd);
                break;
            case IDC_RESTORE:
                MoveSelectedItems(hwnd, FALSE);
                UpdateStuff(hwnd);
                break;
            }
        }
        return TRUE;
    }
    return FALSE;
}


/****************************************************************************
 *
 *  UpdateStuff - Update some UI details based on lists.
 *
 ****************************************************************************/
VOID UpdateStuff(HWND hwnd)
{
    HWND hwndRList = GetDlgItem(hwnd, IDC_RESTOREDLIST);
    HWND hwndBList = GetDlgItem(hwnd, IDC_BACKEDUPLIST);

    if (SendMessage(hwndRList, LB_GETCOUNT, 0, 0) > 0)
    {
        if (SendMessage(hwndRList, LB_GETSELCOUNT, 0, 0) == 0)
            SendMessage(hwndRList, LB_SETSEL, TRUE, 0); // Select first item
        EnableWindow(GetDlgItem(hwnd, IDC_BACKUP), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hwnd, IDC_BACKUP), FALSE);
    }

    if (SendMessage(hwndBList, LB_GETCOUNT, 0, 0) > 0)
    {
        if (SendMessage(hwndBList, LB_GETSELCOUNT, 0, 0) == 0)
            SendMessage(hwndBList, LB_SETSEL, TRUE, 0); // Select first item
        EnableWindow(GetDlgItem(hwnd, IDC_RESTORE), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hwnd, IDC_RESTORE), FALSE);
    }
}


/****************************************************************************
 *
 *  MoveSelectedItems
 *
 ****************************************************************************/
VOID MoveSelectedItems(HWND hwnd, BOOL bBackup)
{
    HWND hwndFromList;
    HWND hwndToList;
    Ghost** ppGhostFromFirst;
    Ghost** ppGhostToFirst;
    LONG iItemArray[100];
    LONG iItem;
    Ghost* pGhost;
    Ghost* pGhost2;
    TCHAR sz[200];

    if (bBackup)
    {
        hwndFromList = GetDlgItem(hwnd, IDC_RESTOREDLIST);
        hwndToList = GetDlgItem(hwnd, IDC_BACKEDUPLIST);
        ppGhostFromFirst = &s_pGhostRestoredFirst;
        ppGhostToFirst = &s_pGhostBackedUpFirst;
    }
    else
    {
        hwndFromList = GetDlgItem(hwnd, IDC_BACKEDUPLIST);
        hwndToList = GetDlgItem(hwnd, IDC_RESTOREDLIST);
        ppGhostFromFirst = &s_pGhostBackedUpFirst;
        ppGhostToFirst = &s_pGhostRestoredFirst;
    }
    
    SendMessage(hwndFromList, LB_GETSELITEMS, 100, (LPARAM)&iItemArray);
    for (iItem = (LONG) SendMessage(hwndFromList, LB_GETSELCOUNT, 0, 0) - 1; iItem >= 0; iItem--)
    {
        pGhost = (Ghost*)SendMessage(hwndFromList, LB_GETITEMDATA, iItemArray[iItem], 0); 
        if (MoveGhost(hwnd, pGhost, bBackup))
        {
            // Remove from old list
            if (pGhost->m_pGhostNext != NULL)
                pGhost->m_pGhostNext->m_pGhostPrev = pGhost->m_pGhostPrev;
            if (pGhost->m_pGhostPrev == NULL)
                *ppGhostFromFirst = pGhost->m_pGhostNext;
            else
                pGhost->m_pGhostPrev->m_pGhostNext = pGhost->m_pGhostNext;
            
            // Add to new list
            pGhost->m_pGhostPrev = NULL;
            pGhost->m_pGhostNext = *ppGhostToFirst;
            if (pGhost->m_pGhostNext != NULL)
                pGhost->m_pGhostNext->m_pGhostPrev = pGhost;
            *ppGhostToFirst = pGhost;

            // Update list boxes:
            SendMessage(hwndFromList, LB_GETTEXT, iItemArray[iItem], (LPARAM)sz);
            SendMessage(hwndFromList, LB_DELETESTRING, iItemArray[iItem], 0);
            SendMessage(hwndToList, LB_SETITEMDATA, SendMessage(hwndToList, LB_ADDSTRING, 0, (LPARAM)sz), (LPARAM)pGhost);
            
            // If we overwrote another Ghost with the same key, remove it from dest list:
            for (pGhost2 = *ppGhostToFirst; pGhost2 != NULL; pGhost2 = pGhost2->m_pGhostNext)
            {
                if (pGhost2 != pGhost && lstrcmp(pGhost2->m_szKey, pGhost->m_szKey) == 0)
                {
                    if (pGhost2->m_pGhostNext != NULL)
                        pGhost2->m_pGhostNext->m_pGhostPrev = pGhost2->m_pGhostPrev;
                    if (pGhost2->m_pGhostPrev == NULL)
                        *ppGhostToFirst = pGhost2->m_pGhostNext;
                    else
                        pGhost2->m_pGhostPrev->m_pGhostNext = pGhost2->m_pGhostNext;
                    RemoveFromListBox(pGhost2, hwndToList);
                    delete pGhost2;
                    break;
                }
            }
        }
    }
}


/****************************************************************************
 *
 *  MoveGhost
 *
 ****************************************************************************/
BOOL MoveGhost(HWND hwnd, Ghost* pGhost, BOOL bBackup)
{
    HKEY hkeySrcParent = NULL;
    HKEY hkeySrc = NULL;
    HKEY hkeyDestParent = NULL;
    HKEY hkeyDest = NULL;
    DWORD dwDisposition;
    BOOL bRet = FALSE;

    // Open source key:
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, bBackup ? 
        TEXT("System\\CurrentControlSet\\Services\\Class\\Display") : 
        TEXT("System\\CurrentControlSet\\Services\\Class\\DisplayBackup"), 
            KEY_ALL_ACCESS, NULL, &hkeySrcParent))
    {
        goto LEnd;
    }
    if (ERROR_SUCCESS != RegOpenKeyEx(hkeySrcParent, pGhost->m_szKey, 
        KEY_ALL_ACCESS, NULL, &hkeySrc))
    {
        goto LEnd;
    }

    // Create destination key:
    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE, bBackup ? 
        TEXT("System\\CurrentControlSet\\Services\\Class\\DisplayBackup") : 
        TEXT("System\\CurrentControlSet\\Services\\Class\\Display"), 
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyDestParent, &dwDisposition))
    {
        goto LEnd;
    }
    // Ensure key isn't already there:
    if (ERROR_SUCCESS == RegOpenKeyEx(hkeyDestParent, pGhost->m_szKey, KEY_ALL_ACCESS, NULL, &hkeyDest))
    {
        RegCloseKey(hkeyDest);
        hkeyDest = NULL;

        TCHAR szMessage[300];
        TCHAR szTitle[100];

        LoadString(NULL, IDS_APPFULLNAME, szTitle, 100);
        LoadString(NULL, IDS_REPLACEGHOST, szMessage, 300);

        if (IDYES == MessageBox(hwnd, szMessage, szTitle, MB_YESNO))
        {
            RegDeleteKey(hkeyDestParent, pGhost->m_szKey);
        }
        else
        {
            goto LEnd;
        }
    }
    if (ERROR_SUCCESS != RegCreateKeyEx(hkeyDestParent, pGhost->m_szKey, 0, NULL, 
        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyDest, &dwDisposition))
    {
        goto LEnd;
    }

    // Copy tree:
    if (ERROR_SUCCESS != RegCreateValues(hkeySrc, NULL, hkeyDest))
        goto LEnd;
    if (ERROR_SUCCESS != RegCreateTree(hkeyDest, hkeySrc))
        goto LEnd;

    // Delete old tree
    RegDeleteKey(hkeySrcParent, pGhost->m_szKey);

    bRet = TRUE; // Everything succeeded

LEnd:
    if (hkeySrcParent != NULL)
        RegCloseKey(hkeySrcParent);
    if (hkeySrc != NULL)
        RegCloseKey(hkeySrc);
    if (hkeyDestParent != NULL)
        RegCloseKey(hkeyDestParent);
    if (hkeyDest != NULL)
        RegCloseKey(hkeyDest);

    return bRet;
}


/****************************************************************************
 *
 *  RegCreateTree
 *
 ****************************************************************************/
DWORD RegCreateTree(HKEY hTree, HKEY hReplacement)
{
#define REGSTR_MAX_VALUE_LENGTH 300
    DWORD   cdwClass, dwSubKeyLength, dwDisposition, dwKeyIndex = 0;
    LPTSTR  pSubKey = NULL;
    TCHAR   szSubKey[REGSTR_MAX_VALUE_LENGTH]; // this should be dynamic.
    TCHAR   szClass[REGSTR_MAX_VALUE_LENGTH]; // this should be dynamic.
    HKEY    hNewKey, hKey;
    DWORD   lRet;

    for(;;)
    {
        dwSubKeyLength = REGSTR_MAX_VALUE_LENGTH;
        cdwClass = REGSTR_MAX_VALUE_LENGTH;
        lRet=RegEnumKeyEx(
                   hReplacement,
                   dwKeyIndex,
                   szSubKey,
                   &dwSubKeyLength,
                   NULL,
                   szClass,
                   &cdwClass,
                   NULL
                   );
        if(lRet == ERROR_NO_MORE_ITEMS)
        {
            lRet = ERROR_SUCCESS;
            break;
        }
        else if(lRet == ERROR_SUCCESS)
        {
            if ((lRet=RegCreateKeyEx(hTree, szSubKey,0, szClass,
                      REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                      &hNewKey, &dwDisposition)) != ERROR_SUCCESS )
                break;
            else  // add key values and recurse
            {
                if ((lRet=RegCreateValues( hReplacement, szSubKey, hNewKey))
                        != ERROR_SUCCESS)
                {
                    CloseHandle(hNewKey);
                    break;
                }
                if ( (lRet=RegOpenKeyEx(hReplacement, szSubKey, 0,
                                  KEY_ALL_ACCESS, &hKey )) == ERROR_SUCCESS )
                {
                    lRet=RegCreateTree(hNewKey, hKey);
                    CloseHandle(hKey);
                    CloseHandle(hNewKey);
                    if ( lRet != ERROR_SUCCESS )
                            break;
                }
                else
                {
                    CloseHandle(hNewKey);
                    break;
                }
            }
        }
        else
            break;
        ++dwKeyIndex;
    } // end for loop
    return lRet;
}


/****************************************************************************
 *
 *  RegCreateValues
 *
 ****************************************************************************/
DWORD RegCreateValues(HKEY hReplacement, LPCTSTR lpSubKey, HKEY hNewKey)
{
    DWORD    cbValue, dwSubKeyIndex=0, dwType, cdwBuf;
    DWORD    dwValues, cbMaxValueData, i;
    LPTSTR   pSubKey = NULL;
    TCHAR    szValue[REGSTR_MAX_VALUE_LENGTH]; // this should be dynamic.
    HKEY     hKey;
    DWORD    lRet = ERROR_SUCCESS;
    LPBYTE   pBuf;

    if (lstrlen(lpSubKey) == 0)
    {
        hKey = hReplacement;
    }
    else
    {
        if ((lRet = RegOpenKeyEx(hReplacement, lpSubKey, 0,
                    KEY_ALL_ACCESS, &hKey )) != ERROR_SUCCESS)
        {
            return lRet;
        }
    }
    if ((lRet = RegQueryInfoKey (hKey, NULL, NULL, NULL, NULL, NULL,
                   NULL, &dwValues,NULL, &cbMaxValueData,
                   NULL, NULL)) == ERROR_SUCCESS)
    {
        if ( dwValues )
        {
            if ((pBuf = (LPBYTE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                          cbMaxValueData )))
            {
                for (i = 0; i < dwValues ; i++)
                {
                   //  get values to create
                   cbValue = REGSTR_MAX_VALUE_LENGTH;
                   cdwBuf = cbMaxValueData;
                   lRet = RegEnumValue(
                            hKey,     // handle of key to query
                            i,        // index of value to query
                            szValue,  // buffer for value string
                            &cbValue, // address for size of buffer
                            NULL,     // reserved
                            &dwType,  // buffer address for type code
                            pBuf,   // address of buffer for value data
                            &cdwBuf   // address for size of buffer
                            );

                    if ( ERROR_SUCCESS == lRet )
                    {
                        if( (lRet = RegSetValueEx(hNewKey, szValue, 0,
                                   dwType, (CONST BYTE *)pBuf,
                                   cdwBuf))!= ERROR_SUCCESS)
                            break;
                    }
                    else
                        break;

                }  // for loop
            }
            HeapFree(GetProcessHeap(), 0, pBuf);
        }
    }
    if (lstrlen(lpSubKey) != 0)
    {
        CloseHandle(hKey);
    }
    return lRet;
}


/****************************************************************************
 *
 *  RemoveFromListBox
 *
 ****************************************************************************/
VOID RemoveFromListBox(Ghost* pGhostRemove, HWND hwndList)
{
    LONG iItem;
    Ghost* pGhost;

    for (iItem = (LONG) SendMessage(hwndList, LB_GETCOUNT, 0, 0) - 1; iItem >= 0; iItem--)
    {
        pGhost = (Ghost*)SendMessage(hwndList, LB_GETITEMDATA, iItem, 0); 
        if (pGhost == pGhostRemove)
        {
            SendMessage(hwndList, LB_DELETESTRING, iItem, 0); 
            break;
        }
    }
}


/****************************************************************************
 *
 *  FreeGhostList
 *
 ****************************************************************************/
VOID FreeGhostList(Ghost** ppGhostFirst)
{
    Ghost* pGhostNext;
    while (*ppGhostFirst != NULL)
    {
        pGhostNext = (*ppGhostFirst)->m_pGhostNext;
        delete *ppGhostFirst;
        *ppGhostFirst = pGhostNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\fileinfo.cpp ===
/****************************************************************************
 *
 *    File: fileinfo.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about files on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <tchar.h>
#include <Windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include <capi.h>
#include <softpub.h>
#include <winsock.h>
#include "sysinfo.h" // for BIsPlatformNT
#include "fileinfo.h"
#include "resource.h"

// MsCat32.dll function prototypes
typedef BOOL (WINAPI* PfnCryptCATAdminAcquireContext)(OUT HCATADMIN *phCatAdmin,
                                                    IN const GUID *pgSubsystem,
                                                    IN DWORD dwFlags);
typedef BOOL (WINAPI* PfnCryptCATAdminReleaseContext)(IN HCATADMIN hCatAdmin,
                                                    IN DWORD dwFlags);
typedef BOOL (WINAPI* PfnCryptCATAdminReleaseCatalogContext)(IN HCATADMIN hCatAdmin,
                                                      IN HCATINFO hCatInfo,
                                                      IN DWORD dwFlags);
typedef BOOL (WINAPI* PfnCryptCATCatalogInfoFromContext)(IN HCATINFO hCatInfo,
                                                  IN OUT CATALOG_INFO *psCatInfo,
                                                  IN DWORD dwFlags);
typedef HCATINFO (WINAPI* PfnCryptCATAdminEnumCatalogFromHash)(IN HCATADMIN hCatAdmin,
                                                        IN BYTE *pbHash,
                                                        IN DWORD cbHash,
                                                        IN DWORD dwFlags,
                                                        IN OUT HCATINFO *phPrevCatInfo);
typedef BOOL (WINAPI* PfnIsCatalogFile)(IN OPTIONAL HANDLE hFile,
                                      IN OPTIONAL WCHAR *pwszFileName);
typedef BOOL (WINAPI* PfnCryptCATAdminCalcHashFromFileHandle)(IN HANDLE hFile,
                                                       IN OUT DWORD *pcbHash,
                                                       OUT OPTIONAL BYTE *pbHash,
                                                       IN DWORD dwFlags);

// WinTrust.dll function prototypes
typedef HRESULT (WINAPI* PfnWinVerifyTrust)(HWND hWnd,
                                            GUID *pgActionID, 
                                            WINTRUST_DATA *pWinTrustData);
 
// Crypt32.dll function prototypes
typedef BOOL (WINAPI* PfnCertFreeCertificateContext)(IN PCCERT_CONTEXT pCertContext);

struct DigiSignData
{
    BOOL bInitialized;
    BOOL bFailed;

    // Need to LoadLibrary/GetProcAddress for mscat32 APIs since they 
    // don't exist on Win95
    HINSTANCE hInstMsCat32;
    PfnCryptCATAdminAcquireContext CryptCATAdminAcquireContext;
    PfnCryptCATAdminReleaseContext CryptCATAdminReleaseContext;
    PfnCryptCATAdminReleaseCatalogContext CryptCATAdminReleaseCatalogContext;
    PfnCryptCATCatalogInfoFromContext CryptCATCatalogInfoFromContext;
    PfnCryptCATAdminEnumCatalogFromHash CryptCATAdminEnumCatalogFromHash;
    PfnIsCatalogFile IsCatalogFile;
    PfnCryptCATAdminCalcHashFromFileHandle CryptCATAdminCalcHashFromFileHandle;

    // Ditto for wintrust.dll APIs
    HINSTANCE hInstWinTrust;
    PfnWinVerifyTrust WinVerifyTrust;

    // Ditto for cypt32.dll APIs
    HINSTANCE hInstCrypt32;
    PfnCertFreeCertificateContext CertFreeCertificateContext;

    HCATADMIN hCatAdmin;
};

static DigiSignData s_dsd;

static BOOL GetMediaPlayerFolder(TCHAR* pszPath);
static BOOL FileIsSignedOld(LPTSTR lpszFile);
static BOOL VerifyFileNode(TCHAR* lpFileName, TCHAR* lpDirName);
static BOOL VerifyIsFileSigned(LPTSTR pcszMatchFile, PDRIVER_VER_INFO lpVerInfo);
static BOOL InitDigiSignData(VOID);
static BOOL IsFileDigitallySigned(TCHAR* pszFile);
static BOOL IsBadWin95Winsock( FileInfo* pFileInfo );


/****************************************************************************
 *
 *  GetProgramFilesFolder
 *
 ****************************************************************************/
VOID InitFileInfo()
{
    ZeroMemory(&s_dsd, sizeof(s_dsd));
    s_dsd.bFailed      = FALSE;
    s_dsd.bInitialized = FALSE;
}


/****************************************************************************
 *
 *  GetProgramFilesFolder
 *
 ****************************************************************************/
BOOL GetProgramFilesFolder(TCHAR* pszPath)
{
    HKEY hkey;
    DWORD dwType;
    DWORD cb;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE, 
        TEXT("Software\\Microsoft\\Windows\\CurrentVersion"), &hkey))
    {
        return FALSE;
    }
    cb = MAX_PATH;
    RegQueryValueEx(hkey, TEXT("ProgramFilesDir"), NULL, &dwType, (LPBYTE)pszPath, &cb);
    RegCloseKey(hkey);
    if (cb == 0)
        return FALSE;
    return TRUE;
}


/****************************************************************************
 *
 *  FormatFileTime
 *
 ****************************************************************************/
VOID FormatFileTime(FILETIME* pUTCFileTime, TCHAR* pszDateLocal, TCHAR* pszDateEnglish)
{
    FILETIME fileTimeLocal;
    SYSTEMTIME systemTime;
    TCHAR szTime[100];

    FileTimeToLocalFileTime(pUTCFileTime, &fileTimeLocal);
    FileTimeToSystemTime(&fileTimeLocal, &systemTime);
    wsprintf(pszDateEnglish, TEXT("%d/%d/%04d %02d:%02d:%02d"),
        systemTime.wMonth, systemTime.wDay, systemTime.wYear,
        systemTime.wHour, systemTime.wMinute, systemTime.wSecond);
    GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systemTime, NULL, pszDateLocal, 30);
    wsprintf(szTime, TEXT(" %02d:%02d:%02d"), systemTime.wHour, 
        systemTime.wMinute, systemTime.wSecond);
    lstrcat(pszDateLocal, szTime);
}


/****************************************************************************
 *
 *  GetMediaPlayerFolder
 *
 ****************************************************************************/
BOOL GetMediaPlayerFolder(TCHAR* pszPath)
{
    HKEY hkey;
    DWORD dwType;
    DWORD cb;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE, 
        TEXT("Software\\Microsoft\\MediaPlayer"), &hkey))
    {
        return FALSE;
    }
    cb = MAX_PATH;
    RegQueryValueEx(hkey, TEXT("Installation Directory"), NULL, &dwType, (LPBYTE)pszPath, &cb);
    RegCloseKey(hkey);
    if (cb == 0)
        return FALSE;
    return TRUE;
}


/****************************************************************************
 *
 *  GetDxSetupFolder
 *
 ****************************************************************************/
BOOL GetDxSetupFolder(TCHAR* pszPath)
{
    if (!GetProgramFilesFolder(pszPath))
        return FALSE;
    lstrcat(pszPath, TEXT("\\DirectX\\Setup"));
    return TRUE;
}


/****************************************************************************
 *
 *  GetComponentFiles
 *
 ****************************************************************************/
HRESULT GetComponentFiles(TCHAR* pszFolder, FileInfo** ppFileInfoFirst,
                          BOOL bSkipMissingFiles, LONG ids)
{
    LONG cch;
    FileInfo* pFileInfo;
    FileInfo* pFileInfoNew;
    LONG iFile;
    TCHAR szFile[50];
    TCHAR szPath[MAX_PATH];
    TCHAR szComponentFiles[2048];
    TCHAR* pszFilePos;
    TCHAR* pszFilePos2;
    TCHAR* pszFirstParen;
    FLOAT fStartShipAt;
    FLOAT fStopShipAt;
    BOOL bDriversDir;
    BOOL bNTDriversDir;
    BOOL bIgnoreVersionInfo;
    BOOL bIgnoreDebug;
    BOOL bIgnoreBeta;
    BOOL bBDA;
    BOOL bNotIA64;
    BOOL bOptional;
    BOOL bOptionalOnNT;
    BOOL bOptionalOnWOW64;
    BOOL bIsNT = BIsPlatformNT();
    BOOL bIs95 = BIsWin95();

    cch = LoadString(NULL, ids, szComponentFiles, 2048);
    if (cch == 0 || cch >= 2047)
        return E_FAIL;
    pszFilePos = szComponentFiles;

    for (iFile = 0; ; iFile++)
    {
        // Stop if we've gone through the whole list
        if (pszFilePos == NULL)
            break;

        // Pull the next file out of the list
        pszFilePos2 = _tcsstr(pszFilePos, TEXT(","));
        if (pszFilePos2 == NULL)
        {
            lstrcpy(szFile, pszFilePos);
            pszFilePos = NULL;
        }
        else
        {
            _tcsncpy(szFile, pszFilePos, (DWORD)(pszFilePos2 - pszFilePos));
            szFile[pszFilePos2 - pszFilePos] = '\0';
            pszFilePos = pszFilePos2 + 1;
        }

        // Clear file flags
        fStartShipAt = 0.0f;
        fStopShipAt  = 10000.0f;
        bDriversDir = FALSE;
        bNTDriversDir = FALSE;
        bIgnoreVersionInfo = FALSE;
        bIgnoreDebug = FALSE;
        bIgnoreBeta = FALSE;
        bBDA = FALSE;
        bNotIA64 = FALSE;
        bOptional = FALSE;
        bOptionalOnNT = FALSE;
        bOptionalOnWOW64 = FALSE;

        // Look at file flags, if any
        pszFirstParen = _tcsstr(szFile, TEXT("("));
        if (pszFirstParen != NULL)
        {

            // If this file does not exist on NT, and we are running NT, skip it.
            if (_tcsstr(pszFirstParen, TEXT("notNT")) != NULL && bIsNT)
                continue;

            // If this file does not exist on W95, and we are running W95, skip it.
            if (_tcsstr(pszFirstParen, TEXT("not95")) != NULL && bIs95)
                continue;

            // If this file only exists on W95, and we are not running W95, skip it.
            // Note: files like vjoyd.vxd may exist on Win98, but DX setup does not
            // install them or update them, so we ignore them.
            // Note: can't call this "95only" because it would clash with "5only"
            if (_tcsstr(pszFirstParen, TEXT("9fiveonly")) != NULL && !bIs95)
                continue;

            // Check for other flags
            if (_tcsstr(pszFirstParen, TEXT("+")) != NULL)
            {
                if (_tcsstr(pszFirstParen, TEXT("+5")) != NULL)
                    fStartShipAt = 5.0f;
                else if (_tcsstr(pszFirstParen, TEXT("+61")) != NULL)
                    fStartShipAt = 6.1f;
                else if (_tcsstr(pszFirstParen, TEXT("+6")) != NULL)
                    fStartShipAt = 6.0f;
                else if (_tcsstr(pszFirstParen, TEXT("+71")) != NULL)
                    fStartShipAt = 7.1f;
                else if (_tcsstr(pszFirstParen, TEXT("+7")) != NULL)
                    fStartShipAt = 7.0f;
                else if (_tcsstr(pszFirstParen, TEXT("+81")) != NULL)
                    fStartShipAt = 8.1f;
                else if (_tcsstr(pszFirstParen, TEXT("+8")) != NULL)
                    fStartShipAt = 8.0f;
            }

            if (_tcsstr(pszFirstParen, TEXT("-")) != NULL)
            {
                if (_tcsstr(pszFirstParen, TEXT("-5")) != NULL)
                    fStopShipAt = 5.0f;
                else if (_tcsstr(pszFirstParen, TEXT("-61")) != NULL)
                    fStopShipAt = 6.1f;
                else if (_tcsstr(pszFirstParen, TEXT("-6")) != NULL)
                    fStopShipAt = 6.0f;
                else if (_tcsstr(pszFirstParen, TEXT("-71")) != NULL)
                    fStopShipAt = 7.1f;
                else if (_tcsstr(pszFirstParen, TEXT("-7")) != NULL)
                    fStopShipAt = 7.0f;
                else if (_tcsstr(pszFirstParen, TEXT("-81")) != NULL)
                    fStopShipAt = 8.1f;
                else if (_tcsstr(pszFirstParen, TEXT("-8")) != NULL)
                    fStopShipAt = 8.0f;
            }

            // Note: can't call this "DriversDir" because it would clash with "NTDriversDir"
            if (_tcsstr(pszFirstParen, TEXT("DrivDir")) != NULL)
                bDriversDir = TRUE;
            if (_tcsstr(pszFirstParen, TEXT("NTDriversDir")) != NULL)
                bNTDriversDir = TRUE;

            if (_tcsstr(pszFirstParen, TEXT("SkipVer")) != NULL)
                bIgnoreVersionInfo = TRUE;
            if (_tcsstr(pszFirstParen, TEXT("SkipDebug")) != NULL)
                bIgnoreDebug = TRUE;
            if (_tcsstr(pszFirstParen, TEXT("SkipBeta")) != NULL)
                bIgnoreBeta = TRUE;

            if (_tcsstr(pszFirstParen, TEXT("notia64")) != NULL)
                bNotIA64 = TRUE;

            if (_tcsstr(pszFirstParen, TEXT("optnt")) != NULL)
                bOptionalOnNT = TRUE;
            else if (_tcsstr(pszFirstParen, TEXT("optwow")) != NULL)
                bOptionalOnWOW64 = TRUE;
            else if (_tcsstr(pszFirstParen, TEXT("opt")) != NULL)
                bOptional = TRUE;

            if (_tcsstr(pszFirstParen, TEXT("bda")) != NULL)
            {
                bBDA = TRUE;
                bOptional = TRUE;
                bIgnoreVersionInfo = TRUE;
            }

            // End file name at open parenthesis, if any:
            *pszFirstParen = TEXT('\0');
        }

        pFileInfoNew = new FileInfo;
        if (pFileInfoNew == NULL)
            return E_OUTOFMEMORY;
        ZeroMemory(pFileInfoNew, sizeof(FileInfo));

        pFileInfoNew->m_fStartShipAt = fStartShipAt;
        pFileInfoNew->m_fStopShipAt = fStopShipAt;
        pFileInfoNew->m_bIgnoreVersionInfo = bIgnoreVersionInfo;
        pFileInfoNew->m_bIgnoreDebug = bIgnoreDebug;
        pFileInfoNew->m_bIgnoreBeta = bIgnoreBeta;
        pFileInfoNew->m_bBDA = bBDA;
        pFileInfoNew->m_bNotIA64 = bNotIA64;
        pFileInfoNew->m_bOptional = bOptional;
        pFileInfoNew->m_bOptionalOnNT = bOptionalOnNT;
        pFileInfoNew->m_bOptionalOnWOW64 = bOptionalOnWOW64;
        lstrcpy(pFileInfoNew->m_szName, szFile);
        lstrcpy(szPath, pszFolder);
        lstrcat(szPath, TEXT("\\"));

        if (bNTDriversDir && bIsNT)
            lstrcat(szPath, TEXT("Drivers\\"));
        else if (bDriversDir)
            lstrcat(szPath, TEXT("..\\System32\\Drivers\\"));
        lstrcat(szPath, szFile);
        WIN32_FIND_DATA findFileData;
        HANDLE hFind = FindFirstFile(szPath, &findFileData);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            if (bSkipMissingFiles)
            {
                delete pFileInfoNew;
                continue;
            }
        }
        else
        {
            pFileInfoNew->m_bExists = TRUE;
            FindClose(hFind);
        }
        if (pFileInfoNew->m_bExists)
        {
            pFileInfoNew->m_numBytes = findFileData.nFileSizeLow;
            pFileInfoNew->m_FileTime = findFileData.ftLastWriteTime;
            FormatFileTime(&findFileData.ftLastWriteTime, pFileInfoNew->m_szDatestampLocal, 
                pFileInfoNew->m_szDatestamp);
            GetFileVersion(szPath, pFileInfoNew->m_szVersion, pFileInfoNew->m_szAttributes,
                pFileInfoNew->m_szLanguageLocal, pFileInfoNew->m_szLanguage, &pFileInfoNew->m_bBeta, &pFileInfoNew->m_bDebug);
        }
        if (*ppFileInfoFirst == NULL)
            *ppFileInfoFirst = pFileInfoNew;
        else
        {
            for (pFileInfo = *ppFileInfoFirst; 
                pFileInfo->m_pFileInfoNext != NULL; 
                pFileInfo = pFileInfo->m_pFileInfoNext)
                {
                }
            pFileInfo->m_pFileInfoNext = pFileInfoNew;
        }
    }

    return S_OK;
}


/****************************************************************************
 *
 *  DestroyFileList
 *
 ****************************************************************************/
VOID DestroyFileList(FileInfo* pFileInfoFirst)
{
    FileInfo* pFileInfo;
    FileInfo* pFileInfoNext;

    for (pFileInfo = pFileInfoFirst; pFileInfo != NULL; pFileInfo = pFileInfoNext)
    {
        pFileInfoNext = pFileInfo->m_pFileInfoNext;
        delete pFileInfo;
    }
}


/****************************************************************************
 *
 *  GetFileDateAndSize
 *
 ****************************************************************************/
BOOL GetFileDateAndSize(TCHAR* pszFile, TCHAR* pszDateLocal, TCHAR* pszDateEnglish, 
                        LONG* pnumBytes)
{
    WIN32_FIND_DATA findFileData;
    HANDLE hFind;
    
    pszDateLocal[0] = '\0';
    pszDateEnglish[0] = '\0';
    *pnumBytes = 0;
    hFind = FindFirstFile(pszFile, &findFileData);
    if (hFind == INVALID_HANDLE_VALUE)
        return FALSE; // file not found
    FindClose(hFind);
    *pnumBytes = findFileData.nFileSizeLow;
    FormatFileTime(&findFileData.ftLastWriteTime, pszDateLocal, pszDateEnglish);
    
    return TRUE;
}


/****************************************************************************
 *
 *  GetFileVersion
 *
 ****************************************************************************/
HRESULT GetFileVersion(TCHAR* pszFile, TCHAR* pszVersion, TCHAR* pszAttributes,
    TCHAR* pszLanguageLocal, TCHAR* pszLanguage, BOOL* pbBeta, BOOL* pbDebug)
{
    UINT cb;
    DWORD dwHandle;
    BYTE FileVersionBuffer[4096];
    VS_FIXEDFILEINFO* pVersion = NULL;
    DWORD dwVersionAttribs = 0;           // DEBUG, RETAIL, etc.
    DWORD* pdwCharSet = NULL;
    WORD wLanguage;
    LCID lcid;
    TCHAR szDebug[100];
    TCHAR szRetail[100];
    TCHAR szBeta[100];
    TCHAR szFinal[100];
    TCHAR szCombineFmt[100];
    LoadString(NULL, IDS_DEBUG, szDebug, 100);
    LoadString(NULL, IDS_RETAIL, szRetail, 100);
    LoadString(NULL, IDS_BETA, szBeta, 100);
    LoadString(NULL, IDS_FINAL, szFinal, 100);
    LoadString(NULL, IDS_ATTRIBCOMBINE, szCombineFmt, 100);

    cb = GetFileVersionInfoSize(pszFile, &dwHandle/*ignored*/);
    if (cb > 0)
    {
        if (cb > sizeof(FileVersionBuffer))
            cb = sizeof(FileVersionBuffer);

        if (GetFileVersionInfo(pszFile, 0, cb, &FileVersionBuffer))
        {
            pVersion = NULL;
            if (VerQueryValue(&FileVersionBuffer, TEXT("\\"), (VOID**)&pVersion, &cb)
                && pVersion != NULL) 
            {
                if (pszVersion != NULL)
                {
                    wsprintf(pszVersion, TEXT("%d.%02d.%02d.%04d"), 
                        HIWORD(pVersion->dwFileVersionMS),
                        LOWORD(pVersion->dwFileVersionMS), 
                        HIWORD(pVersion->dwFileVersionLS), 
                        LOWORD(pVersion->dwFileVersionLS));
                }
                if (pszAttributes != NULL)
                {
                    dwVersionAttribs = pVersion->dwFileFlags;
                    // Bug 18892: work around DPlay 6.0a
                    if (pVersion->dwFileVersionMS == 0x00040006 &&
                        (pVersion->dwFileVersionLS == 0x0002016b || // 4.06.02.0363
                        pVersion->dwFileVersionLS == 0x00020164)) // 4.06.02.0356
                    {
                        dwVersionAttribs &= ~VS_FF_PRERELEASE;
                    }
                    if (pszVersion != NULL)
                    {
                        TCHAR* pszLeaf = _tcsrchr(pszFile, TEXT('\\'));
                        if( pszLeaf )
                        {
                            pszLeaf++;
                            // Work around several DXMedia files which are incorrectly marked as beta
                            if (lstrcmp(pszLeaf, TEXT("oleaut32.dll")) == 0)
                            {
                                dwVersionAttribs &= ~VS_FF_PRERELEASE;
                            }
                            else if (lstrcmp(pszLeaf, TEXT("quartz.dll")) == 0 &&
                                lstrcmp(pszVersion, TEXT("4.00.96.0729")) == 0)
                            {
                                dwVersionAttribs &= ~VS_FF_PRERELEASE;
                            }
                            else if (lstrcmp(pszLeaf, TEXT("quartz.vxd")) == 0 &&
                                lstrcmp(pszVersion, TEXT("4.00.96.0729")) == 0)
                            {
                                dwVersionAttribs &= ~VS_FF_PRERELEASE;
                            }
                            else if (lstrcmp(pszLeaf, TEXT("mciqtz.drv")) == 0 &&
                                lstrcmp(pszVersion, TEXT("4.00.96.0729")) == 0)
                            {
                                dwVersionAttribs &= ~VS_FF_PRERELEASE;
                            }
                            else if (lstrcmp(pszLeaf, TEXT("mciqtz32.dll")) == 0 &&
                                lstrcmp(pszVersion, TEXT("4.00.96.0729")) == 0)
                            {
                                dwVersionAttribs &= ~VS_FF_PRERELEASE;
                            }
                            else if (lstrcmp(pszLeaf, TEXT("actmovie.exe")) == 0)
                            {
                                dwVersionAttribs &= ~VS_FF_PRERELEASE;
                            }
                            else if (lstrcmp(pszLeaf, TEXT("strmdll.dll")) == 0)
                            {
                                dwVersionAttribs &= ~VS_FF_PRERELEASE;
                            }
                            else if (lstrcmp(pszLeaf, TEXT("unam4ie.exe")) == 0 &&
                                lstrcmp(pszVersion, TEXT("6.00.02.0902")) == 0)
                            {
                                dwVersionAttribs &= ~VS_FF_PRERELEASE;
                            }
                            else if (lstrcmp(pszLeaf, TEXT("unam4ie.exe")) == 0 &&
                                lstrcmp(pszVersion, TEXT("5.01.18.1024")) == 0)
                            {
                                dwVersionAttribs &= ~VS_FF_PRERELEASE;
                            }
                            else if (lstrcmp(pszLeaf, TEXT("iac25_32.ax")) == 0 &&
                                lstrcmp(pszVersion, TEXT("2.00.05.0050")) == 0)
                            {
                                dwVersionAttribs &= ~VS_FF_PRERELEASE;
                            }
                            else if (lstrcmp(pszLeaf, TEXT("iac25_32.ax")) == 0 &&
                                lstrcmp(pszVersion, TEXT("2.00.05.0052")) == 0)
                            {
                                dwVersionAttribs &= ~VS_FF_PRERELEASE;
                            }
                            else if (lstrcmp(pszLeaf, TEXT("tm20dec.ax")) == 0)
                            {
                                dwVersionAttribs &= ~VS_FF_PRERELEASE;
                            }
                            else if (lstrcmp(pszLeaf, TEXT("tm20dec.ax")) == 0 &&
                                lstrcmp(pszVersion, TEXT("1.00.00.0000")) == 0)
                            {
                                dwVersionAttribs &= ~VS_FF_PRERELEASE;
                            }
                            else if (lstrcmp(pszLeaf, TEXT("msdxm.ocx")) == 0)
                            {
                                dwVersionAttribs &= ~VS_FF_PRERELEASE;
                            }
                            else if (lstrcmp(pszLeaf, TEXT("dxmasf.dll")) == 0)
                            {
                                dwVersionAttribs &= ~VS_FF_PRERELEASE;
                            }
                            else if (lstrcmp(pszLeaf, TEXT("iac25_32.ax")) == 0 &&
                                lstrcmp(pszVersion, TEXT("2.00.05.0053")) == 0)
                            {
                                dwVersionAttribs &= ~VS_FF_PRERELEASE; // Since 350883 got punted
                            }
                        }
    
                        wsprintf(pszAttributes, szCombineFmt,
                            (dwVersionAttribs & VS_FF_PRERELEASE ? szBeta : szFinal),
                            (dwVersionAttribs & VS_FF_DEBUG ? szDebug : szRetail));
                        if (pbBeta != NULL)
                            *pbBeta = (dwVersionAttribs & VS_FF_PRERELEASE) ? TRUE : FALSE;
                        if (pbDebug != NULL) 
                            *pbDebug = (dwVersionAttribs & VS_FF_DEBUG) ? TRUE : FALSE;
                    }
                }
            }
            if (pszLanguage != NULL)
            {
                if (VerQueryValue(&FileVersionBuffer, TEXT("\\VarFileInfo\\Translation"), (VOID**)&pdwCharSet, &cb)
                    && pdwCharSet && cb) 
                {
                    wLanguage = LOWORD(*pdwCharSet);
                    lcid = MAKELCID(wLanguage, SORT_DEFAULT);
                    GetLocaleInfo(lcid, LOCALE_SENGLANGUAGE, pszLanguage, 100);
                    if (pszLanguageLocal != NULL)
                    {
                        GetLocaleInfo(lcid, LOCALE_SLANGUAGE, pszLanguageLocal, 100);
                        // Show "English", not "English (United States)".  I can't
                        // find a better way to do this (such that it localizes properly)
                        TCHAR* pszSublanguage;
                        pszSublanguage = _tcsstr(pszLanguageLocal, TEXT(" ("));
                        if (pszSublanguage != NULL)
                            *pszSublanguage = '\0';
                    }
                }
            }
        }
    }
    else
    {
        TCHAR* pszLeaf = _tcsrchr(pszFile, TEXT('\\'));
        if( pszLeaf )
        {
            pszLeaf++;
            if (lstrcmpi(pszLeaf, TEXT("vidx16.dll")) == 0)
            {
                if (pszVersion != NULL)
                    lstrcpy(pszVersion, TEXT("0.00.00.0000"));
                if (pszAttributes != NULL)
                    wsprintf(pszAttributes, TEXT("%s %s"), szFinal, szRetail);
                if (pszLanguage != NULL)
                {
                    wLanguage = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
                    lcid = MAKELCID(wLanguage, SORT_DEFAULT);
                    GetLocaleInfo(lcid,  LOCALE_SENGLANGUAGE, pszLanguage, 100);
                    if (pszLanguageLocal != NULL)
                    {
                        GetLocaleInfo(lcid, LOCALE_SLANGUAGE, pszLanguageLocal, 100);
                        // Show "English", not "English (United States)".  I can't
                        // find a better way to do this (such that it localizes properly)
                        TCHAR* pszSublanguage;
                        pszSublanguage = _tcsstr(pszLanguageLocal, TEXT(" ("));
                        if (pszSublanguage != NULL)
                            *pszSublanguage = '\0';
                    }
                }
            }

        }

    }
    return S_OK;
}


/****************************************************************************
 *
 *  GetLanguageFromFile
 *
 ****************************************************************************/
WORD GetLanguageFromFile(const TCHAR* pszFileName, const TCHAR* pszPath)
{
    BYTE                FileVersionBuffer[4096];
    DWORD              *pdwCharSet;
    UINT                cb;
    DWORD               dwHandle;
    TCHAR               szFileAndPath[MAX_PATH];
    WORD                wLanguage;
  
    lstrcpy(szFileAndPath, pszPath);
    lstrcat(szFileAndPath, TEXT("\\"));
    lstrcat(szFileAndPath, pszFileName);
    memset(&FileVersionBuffer, 0, sizeof FileVersionBuffer);
    wLanguage = 0;
    
    if (cb = GetFileVersionInfoSize(szFileAndPath, &dwHandle/*ignored*/))
    {
        cb = (cb <= sizeof FileVersionBuffer ? cb : sizeof FileVersionBuffer);

        if (GetFileVersionInfo(szFileAndPath, 0, cb, &FileVersionBuffer))
        {
            pdwCharSet = 0;

            if (VerQueryValue(&FileVersionBuffer, TEXT("\\VarFileInfo\\Translation"), (void**)&pdwCharSet, &cb)
                && pdwCharSet && cb) 
            {
                wLanguage = LOWORD(*pdwCharSet);
            }
        }
    }    
    return wLanguage;
}


struct DLSVERSION 
{
    DWORD dwVersionMS;
    DWORD dwVersionLS;
};

#define FOURCC_VERS mmioFOURCC('v','e','r','s')

/****************************************************************************
 *
 *  GetRiffFileVersion
 *
 ****************************************************************************/
HRESULT GetRiffFileVersion(TCHAR* pszFile, TCHAR* pszVersion)
{
    MMIOINFO mmio;
    MMCKINFO mmck1;
    MMCKINFO mmck2;
    DLSVERSION dlsver;
    HMMIO hDLS;

    // DLS file has different version scheme since it's a riff file.
    // So retrieve version info from 'vers' chunk.

    ZeroMemory(&mmio, sizeof(MMIOINFO));
    hDLS = mmioOpen(pszFile,&mmio,MMIO_READ);
    if (hDLS == NULL) 
    {
        return E_FAIL;
    }

    // read riff chunk
    ZeroMemory(&mmck1,sizeof(MMCKINFO));
    if (mmioDescend(hDLS,
                    &mmck1,
                    NULL,
                    MMIO_FINDRIFF) != MMSYSERR_NOERROR) 
    {
         mmioClose(hDLS,0);
         return E_FAIL;
    }
    ZeroMemory(&mmck2,sizeof(MMCKINFO));
    mmck2.ckid = FOURCC_VERS;
    if (mmioDescend(hDLS,
                    &mmck2,
                    &mmck1,
                    MMIO_FINDCHUNK) != MMSYSERR_NOERROR) 
    {
        mmioClose(hDLS,0);
        return E_FAIL;
    }
    if (mmioRead(hDLS,
                 (HPSTR)&dlsver,
                 sizeof(DLSVERSION)) != sizeof(DLSVERSION)) 
    {
        mmioClose(hDLS,0);
        return E_FAIL;
    }

    wsprintf(pszVersion, TEXT("%d.%02d.%02d.%04d"), 
        HIWORD(dlsver.dwVersionMS),
        LOWORD(dlsver.dwVersionMS), 
        HIWORD(dlsver.dwVersionLS), 
        LOWORD(dlsver.dwVersionLS));
    mmioClose(hDLS,0);

    return S_OK;
}


/****************************************************************************
 *
 *  FileIsSigned - use digital signature on all OSs  
 *
 ****************************************************************************/
VOID FileIsSigned(LPTSTR lpszFile, BOOL* pbSigned, BOOL* pbIsValid)
{
    // Look for digital sig
    if( !InitDigiSignData() )
    {
        if( pbSigned )
            *pbSigned  = FALSE;

        if( pbIsValid )
            *pbIsValid = FALSE;

        return;
    }

    if( pbSigned )
        *pbSigned  = IsFileDigitallySigned(lpszFile);
    if( pbIsValid )
        *pbIsValid = TRUE;
}


// 5/12/97(RichGr): From Eric's dsetup16.c.
// *   14-sep-95  ericeng directdraw signed tests, drivers failing dll tests are removed from list
/****************************************************************************
 *
 *  FileIsSignedOld
 *
 ****************************************************************************/
BOOL FileIsSignedOld(LPTSTR lpszFile)
{
typedef struct tagIMAGE_DOS_HEADER      // DOS .EXE header
{
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} IMAGE_DOS_HEADER, * PIMAGE_DOS_HEADER, FAR* LPIMAGE_DOS_HEADER;

typedef struct tagIMAGE_OS2_HEADER      // OS/2 .EXE header
{
    WORD   ne_magic;                    // Magic number
    CHAR   ne_ver;                      // Version number
    CHAR   ne_rev;                      // Revision number
    WORD   ne_enttab;                   // Offset of Entry Table
    WORD   ne_cbenttab;                 // Number of bytes in Entry Table
    LONG   ne_crc;                      // Checksum of whole file
    WORD   ne_flags;                    // Flag word
    WORD   ne_autodata;                 // Automatic data segment number
    WORD   ne_heap;                     // Initial heap allocation
    WORD   ne_stack;                    // Initial stack allocation
    LONG   ne_csip;                     // Initial CS:IP setting
    LONG   ne_sssp;                     // Initial SS:SP setting
    WORD   ne_cseg;                     // Count of file segments
    WORD   ne_cmod;                     // Entries in Module Reference Table
    WORD   ne_cbnrestab;                // Size of non-resident name table
    WORD   ne_segtab;                   // Offset of Segment Table
    WORD   ne_rsrctab;                  // Offset of Resource Table
    WORD   ne_restab;                   // Offset of resident name table
    WORD   ne_modtab;                   // Offset of Module Reference Table
    WORD   ne_imptab;                   // Offset of Imported Names Table
    LONG   ne_nrestab;                  // Offset of Non-resident Names Table
    WORD   ne_cmovent;                  // Count of movable entries
    WORD   ne_align;                    // Segment alignment shift count
    WORD   ne_cres;                     // Count of resource segments
    BYTE   ne_exetyp;                   // Target Operating system
    BYTE   ne_flagsothers;              // Other .EXE flags
    WORD   ne_pretthunks;               // offset to return thunks
    WORD   ne_psegrefbytes;             // offset to segment ref. bytes
    WORD   ne_swaparea;                 // Minimum code swap area size
    WORD   ne_expver;                   // Expected Windows version number
} IMAGE_OS2_HEADER, * PIMAGE_OS2_HEADER, FAR* LPIMAGE_OS2_HEADER;

typedef struct tagWINSTUB
{
    IMAGE_DOS_HEADER idh;
    BYTE             rgb[14];
} WINSTUB, * PWINSTUB, FAR* LPWINSTUB;

typedef struct tagFILEINFO
{
    BYTE   cbInfo[0x120];
} FILEINFO, * PFILEINFO, FAR* LPFILEINFO;



    FILE *             pf;
    int                nRC;
    FILEINFO           fi;
    LPIMAGE_DOS_HEADER lpmz;
//    LPIMAGE_OS2_HEADER lpne;
    BYTE               cbInfo[9+32+2];
    BOOL               IsSigned = FALSE;

    static WINSTUB winstub = {
        {
            IMAGE_DOS_SIGNATURE,            /* magic */
            0,                              /* bytes on last page - varies */
            0,                              /* pages in file - varies */
            0,                              /* relocations */
            4,                              /* paragraphs in header */
            1,                              /* min allocation */
            0xFFFF,                         /* max allocation */
            0,                              /* initial SS */
            0xB8,                           /* initial SP */
            0,                              /* checksum (ha!) */
            0,                              /* initial IP */
            0,                              /* initial CS */
            0x40,                           /* lfarlc */
            0,                              /* overlay number */
            { 0, 0, 0, 0},                 /* reserved */
           0,                              /* oem id */
            0,                              /* oem info */
            0,                              /* compiler bug */
            { 0},                          /* reserved */
            0x80,                           /* lfanew */
        },
        {
            0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD,
            0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21,
        }
    };

    pf = _tfopen(lpszFile, TEXT("rb"));
    if (pf==0)
    {
        return FALSE;
    }

    nRC = fread(&fi, sizeof(BYTE), sizeof(FILEINFO), pf);
    if (nRC != sizeof(FILEINFO))
    {
        goto FileIsSigned_exit;
    }

    lpmz = (LPIMAGE_DOS_HEADER)(&fi);
//    lpne = (LPIMAGE_OS2_HEADER)((WORD)&fi + 0x80);

    winstub.idh.e_cblp = lpmz->e_cblp;
    winstub.idh.e_cp   = lpmz->e_cp;

    if (memcmp(&fi, &winstub, sizeof(winstub)) == 0)
    {
        goto FileIsSigned_exit;
    }

    //        if (lpne->ne_magic == IMAGE_OS2_SIGNATURE ||
    //            lpne->ne_magic == IMAGE_VXD_SIGNATURE ||
    //            lpne->ne_magic == IMAGE_NT_SIGNATURE)
    //        {
    //            DPF(0, "Found a match in the OS2 header");
    //        }
    //        else
    //        {
    //            DPF(0, "Didn't meet second criteria!!!");
    //            goto FileIsSigned_exit;
    //        }

    memcpy(cbInfo, &((PWINSTUB)(&fi)->cbInfo)->rgb[14], sizeof(cbInfo));

    if ( (cbInfo[4]      != ' ' ) ||    // space
         (cbInfo[8]      != ' ' ) ||    // space
         (cbInfo[9+32]   != '\n') ||    // return
         (cbInfo[9+32+1] != '$' ) )     // Dollar Sign
    {
        goto FileIsSigned_exit;
    }

    cbInfo[4] = 0;
    cbInfo[8] = 0;

    if ( (strcmp((const char*)&cbInfo[0], "Cert") != 0) ||
         (strcmp((const char*)&cbInfo[5], "DX2")  != 0) )
    {
        goto FileIsSigned_exit;
    }

    IsSigned=TRUE;

    FileIsSigned_exit:

    fclose(pf);

    return IsSigned;
}


/****************************************************************************
 *
 *  InitDigiSignData
 *
 ****************************************************************************/
BOOL InitDigiSignData(VOID)
{
    TCHAR szPath[MAX_PATH];

    if( s_dsd.bInitialized )
        return TRUE;
    if( s_dsd.bFailed ) 
        return FALSE;

    ZeroMemory(&s_dsd, sizeof(s_dsd));

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\mscat32.dll"));
    s_dsd.hInstMsCat32 = LoadLibrary(szPath);
    if (s_dsd.hInstMsCat32 == NULL)
    {
        s_dsd.bFailed = TRUE;
        return FALSE;
    }

    s_dsd.CryptCATAdminAcquireContext = (PfnCryptCATAdminAcquireContext)GetProcAddress(s_dsd.hInstMsCat32, "CryptCATAdminAcquireContext");
    if (s_dsd.CryptCATAdminAcquireContext == NULL)
    {
        s_dsd.bFailed = TRUE;
        return FALSE;
    }

    s_dsd.CryptCATAdminReleaseContext = (PfnCryptCATAdminReleaseContext)GetProcAddress(s_dsd.hInstMsCat32, "CryptCATAdminReleaseContext");
    if (s_dsd.CryptCATAdminReleaseContext == NULL)
    {
        s_dsd.bFailed = TRUE;
        return FALSE;
    }

    s_dsd.CryptCATAdminReleaseCatalogContext = (PfnCryptCATAdminReleaseCatalogContext)GetProcAddress(s_dsd.hInstMsCat32, "CryptCATAdminReleaseCatalogContext");
    if (s_dsd.CryptCATAdminReleaseCatalogContext == NULL)
    {
        s_dsd.bFailed = TRUE;
        return FALSE;
    }

    s_dsd.CryptCATCatalogInfoFromContext = (PfnCryptCATCatalogInfoFromContext)GetProcAddress(s_dsd.hInstMsCat32, "CryptCATCatalogInfoFromContext");
    if (s_dsd.CryptCATCatalogInfoFromContext == NULL)
    {
        s_dsd.bFailed = TRUE;
        return FALSE;
    }

    s_dsd.CryptCATAdminEnumCatalogFromHash = (PfnCryptCATAdminEnumCatalogFromHash)GetProcAddress(s_dsd.hInstMsCat32, "CryptCATAdminEnumCatalogFromHash");
    if (s_dsd.CryptCATAdminEnumCatalogFromHash == NULL)
    {
        s_dsd.bFailed = TRUE;
        return FALSE;
    }

    s_dsd.IsCatalogFile = (PfnIsCatalogFile)GetProcAddress(s_dsd.hInstMsCat32, "IsCatalogFile");
    if (s_dsd.IsCatalogFile == NULL)
    {
        s_dsd.bFailed = TRUE;
        return FALSE;
    }

    s_dsd.CryptCATAdminCalcHashFromFileHandle = (PfnCryptCATAdminCalcHashFromFileHandle)GetProcAddress(s_dsd.hInstMsCat32, "CryptCATAdminCalcHashFromFileHandle");
    if (s_dsd.CryptCATAdminCalcHashFromFileHandle == NULL)
    {
        s_dsd.bFailed = TRUE;
        return FALSE;
    }

    if (!s_dsd.CryptCATAdminAcquireContext(&s_dsd.hCatAdmin, NULL, 0))
    {
        s_dsd.bFailed = TRUE;
        return FALSE;
    }

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\wintrust.dll"));
    s_dsd.hInstWinTrust = LoadLibrary(szPath);
    if (s_dsd.hInstWinTrust == NULL)
    {
        s_dsd.bFailed = TRUE;
        return FALSE;
    }

    s_dsd.WinVerifyTrust = (PfnWinVerifyTrust)GetProcAddress(s_dsd.hInstWinTrust, "WinVerifyTrust");
    if (s_dsd.WinVerifyTrust == NULL)
    {
        s_dsd.bFailed = TRUE;
        return FALSE;
    }

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\crypt32.dll"));
    s_dsd.hInstCrypt32 = LoadLibrary(szPath);
    if (s_dsd.hInstCrypt32 == NULL)
    {
        s_dsd.bFailed = TRUE;
        return FALSE;
    }

    s_dsd.CertFreeCertificateContext = (PfnCertFreeCertificateContext)GetProcAddress(s_dsd.hInstCrypt32, "CertFreeCertificateContext");
    if (s_dsd.CertFreeCertificateContext == NULL)
    {
        s_dsd.bFailed = TRUE;
        return FALSE;
    }

    s_dsd.bFailed      = FALSE;
    s_dsd.bInitialized = TRUE;
    return TRUE;
}


/****************************************************************************
 *
 *  ReleaseDigiSignData
 *
 ****************************************************************************/
VOID ReleaseDigiSignData(VOID)
{
    if( s_dsd.CryptCATAdminReleaseContext && s_dsd.hCatAdmin )
        s_dsd.CryptCATAdminReleaseContext(s_dsd.hCatAdmin,0);
    if (s_dsd.hInstMsCat32 != NULL)
        FreeLibrary(s_dsd.hInstMsCat32);
    if (s_dsd.hInstWinTrust != NULL)
        FreeLibrary(s_dsd.hInstWinTrust);
    if (s_dsd.hInstCrypt32 != NULL)
        FreeLibrary(s_dsd.hInstCrypt32);
    ZeroMemory(&s_dsd, sizeof(s_dsd));
}


/****************************************************************************
 *
 *  IsFileDigitallySigned
 *
 ****************************************************************************/
BOOL IsFileDigitallySigned(TCHAR* pszFile)
{
    if (!s_dsd.bInitialized)
        return FALSE;
    
    TCHAR lpFileName[MAX_PATH];
    TCHAR lpDirName[MAX_PATH];
    TCHAR* pch;
    lstrcpy(lpDirName, pszFile);
    CharLowerBuff(lpDirName, lstrlen(lpDirName));
    pch = _tcsrchr(lpDirName, TEXT('\\'));
    // 22670: There *should* be a backslash in pszFile, but cope if it isn't
    if (pch == NULL)
    {
        lstrcpy(lpFileName, pszFile);
        GetCurrentDirectory(MAX_PATH, lpDirName);
    }
    else
    {
        lstrcpy(lpFileName, pch + 1);
        *pch = TEXT('\0');
    }
    if (_tcsstr(lpDirName, TEXT("\\")) == NULL)
        lstrcat(lpDirName, TEXT("\\"));

    return VerifyFileNode(lpFileName, lpDirName);
}


/****************************************************************************
 *
 *  VerifyFileNode
 *
 ****************************************************************************/
BOOL VerifyFileNode(TCHAR* lpFileName, TCHAR* lpDirName)
{
    const DWORD HASH_SIZE = 100;
    HANDLE hFile;
    BOOL bRet;
    HCATINFO hCatInfo = NULL;
    HCATINFO PrevCat;
    WINTRUST_DATA WinTrustData;
    WINTRUST_CATALOG_INFO WinTrustCatalogInfo;
    DRIVER_VER_INFO VerInfo;
    GUID  guidSubSystemDriver = DRIVER_ACTION_VERIFY;
    HRESULT hRes;
    DWORD cbHash = HASH_SIZE;
    BYTE szHash[HASH_SIZE];
    LPBYTE lpHash = szHash;
    CATALOG_INFO CatInfo;
#ifndef UNICODE
    WCHAR UnicodeKey[MAX_PATH];
#endif
    BOOL bSigned = FALSE;
    TCHAR szFullPath[MAX_PATH];

    wsprintf(szFullPath, TEXT("%s\\%s"), lpDirName, lpFileName);

    //
    // Get the handle to the file, so we can call CryptCATAdminCalcHashFromFileHandle
    //
    hFile = CreateFile( szFullPath,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    // Initialize the hash buffer
    ZeroMemory(lpHash, HASH_SIZE);

    // Generate the hash from the file handle and store it in lpHash
    if (!s_dsd.CryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, lpHash, 0))
    {
        //
        // If we couldn't generate a hash, it might be an individually signed catalog.
        // If it's a catalog, zero out lpHash and cbHash so we know there's no hash to check.
        //
        if (s_dsd.IsCatalogFile(hFile, NULL))
        {
            lpHash = NULL;
            cbHash = 0;
        } 
        else  // If it wasn't a catalog, we'll bail and this file will show up as unscanned.
        {
            CloseHandle(hFile);
            return FALSE;
        }
    }

    // Close the file handle
    CloseHandle(hFile);

    //
    // Now we have the file's hash.  Initialize the structures that
    // will be used later on in calls to WinVerifyTrust.
    //
    ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
    WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    WinTrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
    WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
    WinTrustData.pPolicyCallbackData = (LPVOID)&VerInfo;

    ZeroMemory(&VerInfo, sizeof(DRIVER_VER_INFO));
    VerInfo.cbStruct = sizeof(DRIVER_VER_INFO);

    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (GetVersionEx(&osvi))
    {
        VerInfo.dwPlatform = osvi.dwPlatformId;
        VerInfo.dwVersion = osvi.dwMajorVersion;
        VerInfo.sOSVersionLow.dwMajor = osvi.dwMajorVersion;
        VerInfo.sOSVersionLow.dwMinor = osvi.dwMinorVersion;
        VerInfo.sOSVersionHigh.dwMajor = osvi.dwMajorVersion;
        VerInfo.sOSVersionHigh.dwMinor = osvi.dwMinorVersion;
    }

    WinTrustData.pCatalog = &WinTrustCatalogInfo;
        
    ZeroMemory(&WinTrustCatalogInfo, sizeof(WINTRUST_CATALOG_INFO));
    WinTrustCatalogInfo.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
    WinTrustCatalogInfo.pbCalculatedFileHash = lpHash;
    WinTrustCatalogInfo.cbCalculatedFileHash = cbHash;
#ifdef UNICODE
    WinTrustCatalogInfo.pcwszMemberTag = lpFileName;
#else
    MultiByteToWideChar(CP_ACP, 0, lpFileName, -1, UnicodeKey, MAX_PATH);
    WinTrustCatalogInfo.pcwszMemberTag = UnicodeKey;
#endif

    //
    // Now we try to find the file hash in the catalog list, via CryptCATAdminEnumCatalogFromHash
    //
    PrevCat = NULL;
    hCatInfo = s_dsd.CryptCATAdminEnumCatalogFromHash(s_dsd.hCatAdmin, lpHash, cbHash, 0, &PrevCat);

    //
    // We want to cycle through the matching catalogs until we find one that matches both hash and member tag
    //
    bRet = FALSE;
    while(hCatInfo && !bRet)
    {
        ZeroMemory(&CatInfo, sizeof(CATALOG_INFO));
        CatInfo.cbStruct = sizeof(CATALOG_INFO);
        if(s_dsd.CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, 0)) 
        {
            WinTrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

            // Now verify that the file is an actual member of the catalog.
            hRes = s_dsd.WinVerifyTrust(NULL, &guidSubSystemDriver, &WinTrustData);
            if (hRes == ERROR_SUCCESS)
            {
/*
#ifdef UNICODE
                GetFullPathName(CatInfo.wszCatalogFile, MAX_PATH, szBuffer, &lpFilePart);
#else
                WideCharToMultiByte(CP_ACP, 0, CatInfo.wszCatalogFile, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
                GetFullPathName(szBuffer, MAX_PATH, szBuffer, &lpFilePart);
#endif
                lpFileNode->lpCatalog = (LPTSTR)MALLOC((lstrlen(lpFilePart) + 1) * sizeof(TCHAR));
                lstrcpy(lpFileNode->lpCatalog, lpFilePart);
*/
                if (VerInfo.pcSignerCertContext != NULL)
                {
                    s_dsd.CertFreeCertificateContext(VerInfo.pcSignerCertContext);
                    VerInfo.pcSignerCertContext = NULL;
                }
                bRet = TRUE;
            }
        }

        if (!bRet)
        {
            // The hash was in this catalog, but the file wasn't a member... so off to the next catalog
            PrevCat = hCatInfo;
            hCatInfo = s_dsd.CryptCATAdminEnumCatalogFromHash(s_dsd.hCatAdmin, lpHash, cbHash, 0, &PrevCat);
        }
    }

    if (!hCatInfo)
    {
        //
        // If it wasn't found in the catalogs, check if the file is individually signed.
        //
        bRet = VerifyIsFileSigned(lpFileName, (PDRIVER_VER_INFO) &VerInfo);
        if (bRet)
        {
            // If so, mark the file as being signed.
            bSigned = TRUE;
        }
    } 
    else 
    {
        // The file was verified in the catalogs, so mark it as signed and free the catalog context.
        bSigned = TRUE;
        s_dsd.CryptCATAdminReleaseCatalogContext(s_dsd.hCatAdmin, hCatInfo, 0);
    }
/*
    if (lpFileNode->bSigned)
    {
#ifdef UNICODE
        lpFileNode->lpVersion = MALLOC((lstrlen(VerInfo.wszVersion) + 1) * sizeof(TCHAR));
        lstrcpy(lpFileNode->lpVersion, VerInfo.wszVersion);
        lpFileNode->lpSignedBy = MALLOC((lstrlen(VerInfo.wszSignedBy) + 1) * sizeof(TCHAR));
        lstrcpy(lpFileNode->lpSignedBy, VerInfo.wszSignedBy);
#else
        WideCharToMultiByte(CP_ACP, 0, VerInfo.wszVersion, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
        lpFileNode->lpVersion = (LPTSTR)MALLOC((lstrlen(szBuffer) + 1) * sizeof(TCHAR));
        lstrcpy(lpFileNode->lpVersion, szBuffer);
        WideCharToMultiByte(CP_ACP, 0, VerInfo.wszSignedBy, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
        lpFileNode->lpSignedBy = (LPTSTR)MALLOC((lstrlen(szBuffer) + 1) * sizeof(TCHAR));
        lstrcpy(lpFileNode->lpSignedBy, szBuffer);
#endif
    }
*/
    return bSigned;
}


/****************************************************************************
 *
 *  VerifyIsFileSigned
 *
 ****************************************************************************/
BOOL VerifyIsFileSigned(LPTSTR pcszMatchFile, PDRIVER_VER_INFO lpVerInfo)
{
    HRESULT hRes;
    WINTRUST_DATA WinTrustData;
    WINTRUST_FILE_INFO WinTrustFile;
    GUID guidOSVerCheck = DRIVER_ACTION_VERIFY;
    GUID guidPublishedSoftware = WINTRUST_ACTION_GENERIC_VERIFY_V2;

    ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
    WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;
    WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
    WinTrustData.pFile = &WinTrustFile;
    WinTrustData.pPolicyCallbackData = (LPVOID)lpVerInfo;

    ZeroMemory(lpVerInfo, sizeof(DRIVER_VER_INFO));
    lpVerInfo->cbStruct = sizeof(DRIVER_VER_INFO);

    ZeroMemory(&WinTrustFile, sizeof(WINTRUST_FILE_INFO));
    WinTrustFile.cbStruct = sizeof(WINTRUST_FILE_INFO);

#ifndef UNICODE
    WCHAR wszFileName[MAX_PATH];
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcszMatchFile, -1, (LPWSTR)&wszFileName, MAX_PATH);
    WinTrustFile.pcwszFilePath = wszFileName;
#else
    WinTrustFile.pcwszFilePath = pcszMatchFile;
#endif

    hRes = s_dsd.WinVerifyTrust(NULL, &guidOSVerCheck, &WinTrustData);
    if (hRes != ERROR_SUCCESS)
        hRes = s_dsd.WinVerifyTrust(NULL, &guidPublishedSoftware, &WinTrustData);

    if (lpVerInfo->pcSignerCertContext != NULL)
    {
        s_dsd.CertFreeCertificateContext(lpVerInfo->pcSignerCertContext);
        lpVerInfo->pcSignerCertContext = NULL;
    }

    return (hRes == ERROR_SUCCESS);
}


/****************************************************************************
 *
 *  DiagnoseDxFiles
 *
 ****************************************************************************/
VOID DiagnoseDxFiles(SysInfo* pSysInfo, FileInfo* pDxComponentsFileInfoFirst, 
                     FileInfo* pDxWinComponentsFileInfoFirst)
{
    FileInfo* pFileInfo;
    TCHAR szHighest[50];
    TCHAR szDXVersion[50];
    BOOL bNT = BIsPlatformNT();
    BOOL bWin2k = BIsWin2k();
    BOOL bIA64 = BIsIA64();
    FLOAT fDXVersion = 0.0f;
    BOOL bDX5 = FALSE;
    BOOL bDX6  = FALSE; // 6.x
    BOOL bDX60 = FALSE; // 6.0
    BOOL bDX61 = FALSE; // 6.1
    BOOL bDX7  = FALSE; // 7.x
    BOOL bDX70 = FALSE; // 7.0
    BOOL bDX71 = FALSE; // 7.1
    BOOL bDX8  = FALSE; // 8.x
    BOOL bDX80 = FALSE; // 8.0
    BOOL bDX81 = FALSE; // 8.1   
    BOOL b64BitDxDiag = BIsDxDiag64Bit();
    TCHAR szMissing[200];
    TCHAR szInWindows[200];
    TCHAR szOld[200];
    TCHAR szDebug[200];
    TCHAR szBeta[200];
    TCHAR szFmt[300];
    TCHAR szMessage[300];
    LONG lwNumInWindows;
    LONG lwNumMissing;
    LONG lwNumOld;
    LONG lwNumDebug;
    LONG lwNumBeta;
    TCHAR szListContinuer[30];
    TCHAR szListEtc[30];
    BOOL bVersionWarnings = TRUE;
    BOOL bWinsockWarning = FALSE;

    // Find highest version number in list
    szHighest[0] = '\0';
    for (pFileInfo = pDxComponentsFileInfoFirst; pFileInfo != NULL; 
        pFileInfo = pFileInfo->m_pFileInfoNext)
    {
        if (pFileInfo->m_bIgnoreVersionInfo)
            continue;

        // ddrawex.dll and dxapi.sys have wacky version numbers, so ignore them
        if (lstrcmpi(pFileInfo->m_szName, TEXT("ddrawex.dll")) == 0 ||
            lstrcmpi(pFileInfo->m_szName, TEXT("dxapi.sys")) == 0)
        {
            continue;
        }

        // Bug 18892: dplayx.dll and dpmodemx.dll can have wacky version numbers if
        // DPlay 6.0a is installed over DX 6.0
        if (lstrcmpi(pFileInfo->m_szName, TEXT("dplayx.dll")) == 0 &&
            lstrcmpi(pFileInfo->m_szVersion, TEXT("4.06.02.0363")) == 0)
        {
            continue;
        }
        if (lstrcmpi(pFileInfo->m_szName, TEXT("dpmodemx.dll")) == 0 &&
            lstrcmpi(pFileInfo->m_szVersion, TEXT("4.06.02.0356")) == 0)
        {
            continue;
        }

        // DPlay 6.1a: dplay files can have higher version numbers if
        // DPlay 6.1a is installed over DX 6.0 (or DX 6.1)
        if (lstrcmpi(pFileInfo->m_szVersion, TEXT("4.06.03.0518")) == 0 &&
            (lstrcmpi(pFileInfo->m_szName, TEXT("dplayx.dll")) == 0 ||
            lstrcmpi(pFileInfo->m_szName, TEXT("dpmodemx.dll")) == 0 ||
            lstrcmpi(pFileInfo->m_szName, TEXT("dpwsockx.dll")) == 0 ||
            lstrcmpi(pFileInfo->m_szName, TEXT("dplaysvr.exe")) == 0))
        {
            continue;
        }

        if (lstrcmp(pFileInfo->m_szVersion, pSysInfo->m_szDxDiagVersion) > 0)
        {
            // Bug 21291: Do not complain about file version newer than DxDiag itself
            continue;
        }

        if (lstrcmp(szHighest, pFileInfo->m_szVersion) < 0)
            lstrcpy(szHighest, pFileInfo->m_szVersion);
    }

    if (bNT)
        lstrcpy(szDXVersion, pSysInfo->m_szDirectXVersion);
    else
        lstrcpy(szDXVersion, szHighest);

    // Determine DX version 
    DWORD dwMajor;
    DWORD dwMinor;
    DWORD dwRevision;
    DWORD dwBuild;
    _stscanf(szDXVersion, TEXT("%d.%d.%d.%d"), &dwMajor, &dwMinor, &dwRevision, &dwBuild);
    if (dwMinor < 6)
        bDX5 = TRUE;
    else if (dwMinor < 7 && dwRevision < 2)
        bDX60 = TRUE;
    else if (dwMinor < 7)
        bDX61 = TRUE;
    else if (dwMinor < 8 && dwRevision < 1)
        bDX70 = TRUE;
    else if (dwMinor < 8)
        bDX71 = TRUE;
    else if (dwMinor == 8 && dwRevision < 1)
        bDX80 = TRUE;
    else if (dwMinor >= 8)
        bDX81 = TRUE;

    // Calc DX ver
    fDXVersion = (float) dwMinor + (float) (dwRevision/10.0f);

    // Is this DX6?
    bDX6 = bDX60 || bDX61;

    // Is this DX7?
    bDX7 = bDX70 || bDX71;

    // Is this DX8?       
    bDX8 = bDX80 || bDX81;

    lwNumInWindows = 0;
    lwNumMissing = 0;
    lwNumOld = 0;
    lwNumDebug = 0;
    lwNumBeta = 0;
    LoadString(NULL, IDS_LISTCONTINUER, szListContinuer, 30);
    LoadString(NULL, IDS_LISTETC, szListEtc, 30);

    for (pFileInfo = pDxWinComponentsFileInfoFirst; pFileInfo != NULL; 
        pFileInfo = pFileInfo->m_pFileInfoNext)
    {
        pFileInfo->m_bProblem = TRUE;
        lwNumInWindows++;
        if (lwNumInWindows == 1)
        {
            lstrcpy(szInWindows, pFileInfo->m_szName);
        }
        else if (lwNumInWindows < 4)
        {
            lstrcat(szInWindows, szListContinuer);
            lstrcat(szInWindows, pFileInfo->m_szName);
        }
        else if (lwNumInWindows < 5)
        {
            lstrcat(szInWindows, szListEtc);
        }
    }

    for (pFileInfo = pDxComponentsFileInfoFirst; pFileInfo != NULL; 
        pFileInfo = pFileInfo->m_pFileInfoNext)
    {
        if (!pFileInfo->m_bExists && !pFileInfo->m_bOptional)
        {
            // A missing file is a problem unless it's optional, OR...
            // (on NT): it's optional on NT
            // (on IA64): it's not on IA64
            // (on IA64): we're running 32-bit dxdiag and its optional on WOW
            // if file hasn't shipped yet on this DX version
            // if file stopped shipping on or after this DX version
            if (bNT && pFileInfo->m_bOptionalOnNT)
            {
            }
            else if (bIA64 && pFileInfo->m_bNotIA64)
            {
            }
            else if (bIA64 && !b64BitDxDiag && pFileInfo->m_bOptionalOnWOW64)
            {
            }       
            else if (fDXVersion+0.05f < pFileInfo->m_fStartShipAt)
            {
            }       
            else if (fDXVersion+0.05f >= pFileInfo->m_fStopShipAt)
            {
            }       
            else
            {
                pFileInfo->m_bProblem = TRUE;
                LoadString(NULL, IDS_FILEMISSING, pFileInfo->m_szVersion, 50);
                lwNumMissing++;
                if (lwNumMissing == 1)
                {
                    lstrcpy(szMissing, pFileInfo->m_szName);
                }
                else if (lwNumMissing < 4)
                {
                    lstrcat(szMissing, szListContinuer);
                    lstrcat(szMissing, pFileInfo->m_szName);
                }
                else if (lwNumMissing < 5)
                {
                    lstrcat(szMissing, szListEtc);
                }
            }
        }

        if (!pFileInfo->m_bExists)
            continue;

        if( BIsWin95() ) 
        {
            if( lstrcmpi(pFileInfo->m_szName, TEXT("wsock32.dll")) )
            {
                if( IsBadWin95Winsock( pFileInfo ) )
                    bWinsockWarning = TRUE;
            }
        }

        // If DX6 or later, flag any dx5 only files as 
        // obsolete (needing to be deleted)
        // manbugs 16765: don't complain about these files, just don't list them
        if (!bDX5 && (pFileInfo->m_fStopShipAt == 6.0f))
        {
            pFileInfo->m_bProblem = TRUE;
            pFileInfo->m_bObsolete = TRUE;
            continue; // don't complain about these files for any other reason
        }

        if (bVersionWarnings && lstrcmp(szHighest, pFileInfo->m_szVersion) != 0)
        {
            if( pFileInfo->m_bIgnoreVersionInfo )
            {
                // Don't warn on files that have m_bIgnoreVersionInfo set
            }
            else if( _tcsstr(pFileInfo->m_szVersion, TEXT("5.01.2600.0000")) != NULL )
            {
                // Allow 5.01.2600.0000 in SP1
            }               
            else if( bDX81 && ( _tcsstr(pFileInfo->m_szVersion, TEXT("4.08.00.0400")) != NULL ||
                                _tcsstr(pFileInfo->m_szVersion, TEXT("5.01.2258.0400")) != NULL ) )
            {
                // Bug 48732: If szHighest is 4.08.00.05xx and 
                // pFileInfo->m_szVersion is 4.08.00.0400 its OK 
            }
            else if( bWin2k && ( 
                     (lstrcmpi(pFileInfo->m_szName, TEXT("d3drm.dll")) == 0     && lstrcmpi(pFileInfo->m_szVersion, TEXT("5.00.2134.0001")) == 0) ||
                     (lstrcmpi(pFileInfo->m_szName, TEXT("d3dxof.dll")) == 0    && lstrcmpi(pFileInfo->m_szVersion, TEXT("5.00.2135.0001")) == 0) ||
                     (lstrcmpi(pFileInfo->m_szName, TEXT("d3dpmesh.dll")) == 0  && lstrcmpi(pFileInfo->m_szVersion, TEXT("5.00.2134.0001")) == 0) 
                               )
                   )
            {
            }
            else if( bDX71 && _tcsstr(pFileInfo->m_szVersion, TEXT("4.07.00.07")) != NULL )
            {
                // Bug 114753: If szHighest is 4.07.01.xxxx and 
                // pFileInfo->m_szVersion is 4.07.00.0700 its OK (for now). 
            }
            else if (!bNT && (bDX60 || bDX61) && CompareString(LOCALE_SYSTEM_DEFAULT, 0, 
                     pFileInfo->m_szVersion, 4, TEXT("4.05"), 4) == CSTR_EQUAL &&
                     ( lstrcmpi(pFileInfo->m_szName, TEXT("dsound.dll")) == 0 ||
                       lstrcmpi(pFileInfo->m_szName, TEXT("dsound.vxd")) == 0 ||
                       lstrcmpi(pFileInfo->m_szName, TEXT("dinput.dll")) == 0 ||
                       lstrcmpi(pFileInfo->m_szName, TEXT("dinput.vxd")) == 0 ||
                       lstrcmpi(pFileInfo->m_szName, TEXT("vjoyd.vxd")) == 0 ||
                       lstrcmpi(pFileInfo->m_szName, TEXT("msanalog.vxd")) == 0 ||
                       lstrcmpi(pFileInfo->m_szName, TEXT("joy.cpl")) == 0 ||
                       lstrcmpi(pFileInfo->m_szName, TEXT("gcdef.dll")) == 0 ||
                       lstrcmpi(pFileInfo->m_szName, TEXT("gchand.dll")) == 0))
            {
                // If Win9x DX6.x, dsound and dinput are allowed to be 4.05.xx.xxxx
                // CompareString is used rather than lstrcmp only because we
                // only want to look at the first four characters of the string

                // Don't report these as version problems
            }
            else if (!bNT && bDX7 && CompareString(LOCALE_SYSTEM_DEFAULT, 0, 
                pFileInfo->m_szVersion, 4, TEXT("4.05"), 4) == CSTR_EQUAL &&
                (lstrcmpi(pFileInfo->m_szName, TEXT("dinput.dll")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("dinput.vxd")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("joy.cpl")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("gchand.dll")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("gcdef.dll")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("vjoyd.vxd")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("msanalog.vxd")) == 0))
            {
                // 21470: On DX7, these input files still exist on Win95,
                // and they stay at DX5 level.
            }
            else if ( !bNT && 
                (lstrcmpi(pFileInfo->m_szName, TEXT("msjstick.drv")) == 0  && lstrcmpi(pFileInfo->m_szVersion, TEXT("4.00.00.0950")) == 0) ||
                (lstrcmpi(pFileInfo->m_szName, TEXT("vjoyd.vxd")) == 0     && lstrcmpi(pFileInfo->m_szVersion, TEXT("4.05.00.0155")) == 0) 
                    )
            {
                // 34687: These stays at the dx5 level.
            }
            else if (!bNT && (lstrcmpi(pFileInfo->m_szName, TEXT("ddrawex.dll")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("dxapi.sys")) == 0))
            {
                // Ignore ddrawex.dll and dxapi.sys on Win9x because they have weird version numbers:
            }
            else if (lstrcmpi(pFileInfo->m_szName, TEXT("dplayx.dll")) == 0 &&
                lstrcmpi(pFileInfo->m_szVersion, TEXT("4.06.02.0363")) == 0)
            {
                // Bug 18892: work around DPlay 6.0a
            }
            else if (lstrcmpi(pFileInfo->m_szName, TEXT("dpmodemx.dll")) == 0 &&
                lstrcmpi(pFileInfo->m_szVersion, TEXT("4.06.02.0356")) == 0)
            {
                // Bug 18892: work around DPlay 6.0a
            }
            else if (lstrcmpi(pFileInfo->m_szVersion, TEXT("4.06.03.0518")) == 0 &&
                (lstrcmpi(pFileInfo->m_szName, TEXT("dplayx.dll")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("dpmodemx.dll")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("dpwsockx.dll")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("dplaysvr.exe")) == 0))
            {
                // DPlay 6.1a: dplay files can have higher version numbers if
                // DPlay 6.1a is installed over DX 6.0 (or DX 6.1)
            }
            else if (lstrcmpi(pFileInfo->m_szName, TEXT("dxsetup.exe")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("dsetup.dll")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("dsetup16.dll")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("dsetup32.dll")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("directx.cpl")) == 0)
            {
                // Bug 18540: Don't complain if dsetup/cpl files are out of date because
                // some updates (OSR) don't update the setup/cpl files which may exist from
                // another (SDK) installation
            }
            else if (!bNT && lstrcmpi(pFileInfo->m_szVersion, TEXT("4.06.02.0436")) == 0 &&
                (lstrcmpi(pFileInfo->m_szName, TEXT("d3drm.dll")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("d3dxof.dll")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("d3dpmesh.dll")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("dplayx.dll")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("dpmodemx.dll")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("dpwsockx.dll")) == 0 ||
                lstrcmpi(pFileInfo->m_szName, TEXT("dplaysvr.exe")) == 0))
            {
                // On DX 6.1a, the RM and DPlay files stay at 4.06.02.0436.  No problemo.
            }
            else if (lstrcmp(pFileInfo->m_szVersion, pSysInfo->m_szDxDiagVersion) > 0)
            {
                // Bug 21291: Do not complain about file version newer than DxDiag itself
            }
            else
            {
                pFileInfo->m_bProblem = TRUE;
                lwNumOld++;
                if (lwNumOld == 1)
                {
                    lstrcpy(szOld, pFileInfo->m_szName);
                }
                else if (lwNumOld < 4)
                {
                    lstrcat(szOld, szListContinuer);
                    lstrcat(szOld, pFileInfo->m_szName);
                }
                else if (lwNumOld < 5)
                {
                    lstrcat(szOld, szListEtc);
                }
            }
        } // end if (bVersionWarnings && lstrcmp(szHighest, pFileInfo->m_szVersion) != 0)

        if (pFileInfo->m_bBeta && !pFileInfo->m_bIgnoreBeta)
        {
            pFileInfo->m_bProblem = TRUE;
            lwNumBeta++;
            if (lwNumBeta == 1)
            {
                lstrcpy(szBeta, pFileInfo->m_szName);
            }
            else if (lwNumBeta < 4)
            {
                lstrcat(szBeta, szListContinuer);
                lstrcat(szBeta, pFileInfo->m_szName);
            }
            else if (lwNumBeta < 5)
            {
                lstrcat(szBeta, szListEtc);
            }
        }

        if (pFileInfo->m_bDebug && !pFileInfo->m_bIgnoreDebug)
        {
            pFileInfo->m_bProblem = TRUE;
            lwNumDebug++;
            if (lwNumDebug == 1)
            {
                lstrcpy(szDebug, pFileInfo->m_szName);
            }
            else if (lwNumDebug < 4)
            {
                lstrcat(szDebug, szListContinuer);
                lstrcat(szDebug, pFileInfo->m_szName);
            }
            else if (lwNumDebug < 5)
            {
                lstrcat(szDebug, szListEtc);
            }
        }
    }

    BOOL bShouldReinstall = FALSE;

    _tcscpy(pSysInfo->m_szDXFileNotes, TEXT("") );
    _tcscpy(pSysInfo->m_szDXFileNotesEnglish, TEXT("") );

    if (lwNumInWindows > 0)
    {
        if (lwNumInWindows == 1)
            LoadString(NULL, IDS_INWINDOWSFMT1, szFmt, 300);
        else
            LoadString(NULL, IDS_INWINDOWSFMT2, szFmt, 300);
        wsprintf(szMessage, szFmt, szInWindows);
        _tcscat(pSysInfo->m_szDXFileNotes, szMessage);

        if (lwNumInWindows == 1)
            LoadString(NULL, IDS_INWINDOWSFMT1_ENGLISH, szFmt, 300);
        else
            LoadString(NULL, IDS_INWINDOWSFMT2_ENGLISH, szFmt, 300);
        wsprintf(szMessage, szFmt, szInWindows);
        _tcscat(pSysInfo->m_szDXFileNotesEnglish, szMessage);
    }

    if (lwNumMissing > 0)
    {
        if (lwNumMissing == 1)
            LoadString(NULL, IDS_MISSINGFMT1, szFmt, 300);
        else
            LoadString(NULL, IDS_MISSINGFMT2, szFmt, 300);
        wsprintf(szMessage, szFmt, szMissing);
        _tcscat(pSysInfo->m_szDXFileNotes, szMessage);

        if (lwNumMissing == 1)
            LoadString(NULL, IDS_MISSINGFMT1_ENGLISH, szFmt, 300);
        else
            LoadString(NULL, IDS_MISSINGFMT2_ENGLISH, szFmt, 300);
        wsprintf(szMessage, szFmt, szMissing);
        _tcscat(pSysInfo->m_szDXFileNotesEnglish, szMessage);

        bShouldReinstall = TRUE;
    }

    if (lwNumOld > 0)
    {
        if (lwNumOld == 1)
            LoadString(NULL, IDS_OLDFMT1, szFmt, 300);
        else
            LoadString(NULL, IDS_OLDFMT2, szFmt, 300);
        wsprintf(szMessage, szFmt, szOld);
        _tcscat(pSysInfo->m_szDXFileNotes, szMessage);

        if (lwNumOld == 1)
            LoadString(NULL, IDS_OLDFMT1_ENGLISH, szFmt, 300);
        else
            LoadString(NULL, IDS_OLDFMT2_ENGLISH, szFmt, 300);
        wsprintf(szMessage, szFmt, szOld);
        _tcscat(pSysInfo->m_szDXFileNotesEnglish, szMessage);

        bShouldReinstall = TRUE;
    }

    if (lwNumBeta > 0)
    {
        if (lwNumBeta == 1)
            LoadString(NULL, IDS_BETAFMT1, szFmt, 300);
        else
            LoadString(NULL, IDS_BETAFMT2, szFmt, 300);
        wsprintf(szMessage, szFmt, szBeta);
        _tcscat(pSysInfo->m_szDXFileNotes, szMessage);

        if (lwNumBeta == 1)
            LoadString(NULL, IDS_BETAFMT1_ENGLISH, szFmt, 300);
        else
            LoadString(NULL, IDS_BETAFMT2_ENGLISH, szFmt, 300);
        wsprintf(szMessage, szFmt, szBeta);
        _tcscat(pSysInfo->m_szDXFileNotesEnglish, szMessage);

        bShouldReinstall = TRUE;
    }

    if (lwNumDebug > 0)
    {
        if (lwNumDebug == 1)
            LoadString(NULL, IDS_DEBUGFMT1, szFmt, 300);
        else
            LoadString(NULL, IDS_DEBUGFMT2, szFmt, 300);
        wsprintf(szMessage, szFmt, szDebug);
        _tcscat( pSysInfo->m_szDXFileNotes, szMessage);

        if (lwNumDebug == 1)
            LoadString(NULL, IDS_DEBUGFMT1_ENGLISH, szFmt, 300);
        else
            LoadString(NULL, IDS_DEBUGFMT2_ENGLISH, szFmt, 300);
        wsprintf(szMessage, szFmt, szDebug);
        _tcscat( pSysInfo->m_szDXFileNotesEnglish, szMessage);

        //bShouldReinstall = TRUE;
    }

    if( bWinsockWarning )
    {
        LoadString(NULL, IDS_WINSOCK_WARN, szMessage, 300);
        _tcscat( pSysInfo->m_szDXFileNotes, szMessage);

        LoadString(NULL, IDS_WINSOCK_WARN_ENGLISH, szMessage, 300);
        _tcscat( pSysInfo->m_szDXFileNotesEnglish, szMessage);
    }

    if( bShouldReinstall )
    {
        BOOL bTellUser = FALSE;

        // Figure out if the user can install DirectX
        if( BIsPlatform9x() )
            bTellUser = TRUE;
        else if( BIsWin2k() && bDX8 )
            bTellUser = TRUE;

        if( bTellUser )
        {
            LoadString(NULL, IDS_REINSTALL_DX, szMessage, 300);
            _tcscat( pSysInfo->m_szDXFileNotes, szMessage);

            LoadString(NULL, IDS_REINSTALL_DX_ENGLISH, szMessage, 300);
            _tcscat( pSysInfo->m_szDXFileNotesEnglish, szMessage);
        }
    }

    if (lwNumMissing == 0 && lwNumOld == 0 && 
        lwNumBeta == 0 && lwNumDebug == 0 && lwNumInWindows == 0)
    {        
        LoadString(NULL, IDS_NOPROBLEM, szMessage, 300);
        _tcscat(pSysInfo->m_szDXFileNotes, szMessage);

        LoadString(NULL, IDS_NOPROBLEM_ENGLISH, szMessage, 300);
        _tcscat(pSysInfo->m_szDXFileNotesEnglish, szMessage);
    }
}


/****************************************************************************
 *
 *  IsBadWin95Winsock
 *
 ****************************************************************************/
BOOL IsBadWin95Winsock( FileInfo* pFileInfo )
{
typedef int (PASCAL* LPWSASTARTUP)(IN WORD wVersionRequired, OUT LPWSADATA lpWSAData);
typedef int (PASCAL* LPWSACLEANUP)(void);

    BOOL         bReturn = FALSE;
    TCHAR        szPath[MAX_PATH];
    HINSTANCE    hInstWSock;
    LPWSASTARTUP pWSAStartup = NULL;
    LPWSACLEANUP pWSACleanup = NULL;

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\wsock32.dll"));
    hInstWSock = LoadLibrary(szPath);
    if (hInstWSock != NULL)
    {
        pWSAStartup = (LPWSASTARTUP)GetProcAddress(hInstWSock, "WSAStartup");
        pWSACleanup = (LPWSACLEANUP)GetProcAddress(hInstWSock, "WSACleanup");
        if (pWSAStartup != NULL && pWSACleanup != NULL)
        {    
            WORD wVersionRequested;
            WSADATA wsaData;
            int err;
            wVersionRequested = MAKEWORD( 2, 2 );

            err = pWSAStartup( wVersionRequested, &wsaData );
            if ( err == 0 ) 
            {
                if ( LOBYTE( wsaData.wVersion ) == 2 && 
                     HIBYTE( wsaData.wVersion ) == 2 ) 
                {
                    FILETIME fileTimeGoodWinsock;
                    SYSTEMTIME systemTimeGoodWinsock;
                    ULARGE_INTEGER ulGoodWinsock;
                    ULARGE_INTEGER ulCurrentWinsock;

                    ZeroMemory( &systemTimeGoodWinsock, sizeof(SYSTEMTIME) );
                    systemTimeGoodWinsock.wYear   = 1998;
                    systemTimeGoodWinsock.wMonth  = 2;
                    systemTimeGoodWinsock.wDay    = 6;
                    systemTimeGoodWinsock.wHour   = 14;
                    systemTimeGoodWinsock.wMinute = 18;
                    systemTimeGoodWinsock.wSecond = 00;

                    SystemTimeToFileTime( &systemTimeGoodWinsock, &fileTimeGoodWinsock );

                    ulCurrentWinsock.LowPart = pFileInfo->m_FileTime.dwLowDateTime;
                    ulCurrentWinsock.HighPart = pFileInfo->m_FileTime.dwHighDateTime;
                    ulGoodWinsock.LowPart = fileTimeGoodWinsock.dwLowDateTime;
                    ulGoodWinsock.HighPart = fileTimeGoodWinsock.dwHighDateTime;

                    if( ulCurrentWinsock.QuadPart < ulGoodWinsock.QuadPart )
                    {
                        bReturn = TRUE;
                    }
                }

                pWSACleanup();
            }
        }
    }

    FreeLibrary(hInstWSock);

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\inptinfo.h ===
/****************************************************************************
 *
 *    File: inptinfo.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about input devices on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef INPUTINFO_H
#define INPUTINFO_H

// DXD_IN_DI_VALUE is the name of a value stored under the registry key 
// HKLM\DXD_IN_DI_KEY that indicates that DxDiag is using
// DirectInput.  If DxDiag starts up and this value exists, DxDiag 
// probably crashed in DirectInput and DxDiag should offer to run without
// using DirectInput.
#define DXD_IN_DI_KEY TEXT("Software\\Microsoft\\DirectX Diagnostic Tool")
#define DXD_IN_DI_VALUE TEXT("DxDiag In DirectInput")

struct InputDeviceInfo
{
    DWORD m_dwUsageSettings;
    TCHAR m_szSettings[100]; // formatted version of m_dwUsageSettings
    TCHAR m_szDeviceName[100];
    TCHAR m_szDriverName[100];
    TCHAR m_szDriverVersion[100];
    TCHAR m_szDriverLanguage[100];
    TCHAR m_szDriverLanguageLocal[100];
    TCHAR m_szDriverDate[100];
    TCHAR m_szDriverDateLocal[100];
    TCHAR m_szDriverAttributes[100];
    LONG m_numBytes;
    BOOL m_bBeta;
    BOOL m_bDebug;
    BOOL m_bDriverSigned;
    BOOL m_bDriverSignedValid;
    BOOL m_bProblem;

    InputDeviceInfo* m_pInputDeviceInfoNext;
};

struct InputDeviceInfoNT
{
    TCHAR m_szName[200];
    TCHAR m_szProvider[200];
    TCHAR m_szId[200];
    DWORD m_dwStatus;
    DWORD m_dwProblem;

    TCHAR m_szPortName[200];
    TCHAR m_szPortProvider[200];
    TCHAR m_szPortId[200];
    DWORD m_dwPortStatus;
    DWORD m_dwPortProblem;

    BOOL m_bProblem;

    InputDeviceInfoNT* m_pInputDeviceInfoNTNext;
};

struct InputDriverInfo
{
    TCHAR m_szRegKey[100];
    TCHAR m_szDeviceID[100];
    TCHAR m_szMatchingDeviceID[100];
    TCHAR m_szDriver16[100];
    TCHAR m_szDriver32[100];
    BOOL m_bActive;
    BOOL m_bProblem;

    InputDriverInfo* m_pInputDriverInfoNext;
};

struct InputInfo
{
    BOOL m_bNT;
    BOOL m_bPollFlags;
    InputDeviceInfo* m_pInputDeviceInfoFirst;
    InputDeviceInfoNT* m_pInputDeviceInfoNTFirst;
    InputDriverInfo* m_pInputDriverInfoFirst;
    RegError* m_pRegErrorFirst;
};


HRESULT GetInputInfo(InputInfo** ppInputInfo);
HRESULT GetInputDriverInfo(InputInfo* pInputInfo);
VOID    DestroyInputInfo(InputInfo* pInputInfo);
VOID    DiagnoseInput(SysInfo* pSysInfo, InputInfo* pInputInfo);


#endif // INPUTINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\main.cpp ===
/****************************************************************************
 *
 *    File: main.cpp 
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Main file for DxDiag.
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 * DxDiag Command-line options:
 *      <none> : Run with graphical user interface
 *      -ghost : Show Ghost Display Devices option (this flag must come next)
 *  -bugreport : GUI, go straight to bug report page/dialog
 *   -saveonly : GUI, just choose where to save text file, save, then exit
 *          -d : No GUI, generate comma-separated-values (csv) file
 *          -p : No GUI, generate text file named dxdiag.txt
 *      <path> : No GUI, generate text file named <path>
 *
 ****************************************************************************/

#define STRICT
#include <tchar.h>
#include <Windows.h>
#include <basetsd.h>
#include <process.h>
#include <commctrl.h>
#include <richedit.h>
#include <commdlg.h>
#include <stdio.h>
#include <shellapi.h>
#include <mmsystem.h>
#include <wbemidl.h>
#include <objbase.h>
#include <d3d.h>
#include <dsound.h>
#include <dmerror.h>
#include <dplay.h>
#include <shlobj.h>
#include <shfolder.h>
#include "resource.h"
#include "reginfo.h"
#include "sysinfo.h"
#include "fileinfo.h"
#include "dispinfo.h"
#include "sndinfo.h"
#include "musinfo.h"
#include "showinfo.h"
#include "inptinfo.h"
#include "netinfo.h"
#include "testdd.h"
#include "testagp.h"
#include "testd3d8.h"
#include "testsnd.h"
#include "testmus.h"
#include "testnet.h"
#include "save.h"
#include "ghost.h"

#define WM_COMMAND_REAL             (WM_APP+2)
#define WM_QUERYSKIP                (WM_APP+3)
#define WM_QUERYSKIP_REAL           (WM_APP+4)
#define WM_NETMEETINGWARN           (WM_APP+5)
#define WM_NETMEETINGWARN_REAL      (WM_APP+6)
#define WM_REPORTERROR              (WM_APP+7)
#define WM_REPORTERROR_REAL         (WM_APP+8)
#define WM_APP_PROGRESS             (WM_APP+10)

struct UI_MSG_NODE
{
    UINT         message;
    WPARAM       wparam;
    LPARAM       lparam;
    UI_MSG_NODE* pNext;
};

struct DXFILE_SORT_INFO
{
    LONG nSortDirection;
    DWORD dwColumnToSort;
};

// This is the only global function in this file:
BOOL BTranslateError(HRESULT hr, TCHAR* psz, BOOL bEnglish = FALSE);

static BOOL OldWindowsVersion(VOID);
static VOID ReportError(LONG idsDescription, HRESULT hr = S_OK);
static VOID ReportErrorReal(LONG idsDescription, HRESULT hr);
static INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static INT_PTR CALLBACK PageDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static HRESULT CreateTabs(HWND hwndTabs);
static HRESULT CleanupPage(HWND hwndTabs, INT iPage);
static HRESULT SetupPage(HWND hwndTabs, INT iPage);
static HRESULT SetupHelpPage(HWND hwndTabs);
static VOID ShowBullets(VOID);
static VOID HideBullets(VOID);
static HRESULT SetupDxFilesPage(VOID);
static HRESULT SetupDisplayPage(LONG iDisplay);
static HRESULT SetupSoundPage(LONG iSound);
static HRESULT SetupMusicPage(VOID);
static HRESULT SetupInputPage(VOID);
static HRESULT SetupInputDevices9x(VOID);
static HRESULT SetupInputDevicesNT(VOID);
static HRESULT SetupNetworkPage(VOID);
static HRESULT SetupStillStuckPage(VOID);
static HRESULT CreateFileInfoColumns(HWND hwndList, BOOL bDrivers);
static HRESULT CreateMusicColumns(HWND hwndList);
static HRESULT AddFileInfo(HWND hwndList, FileInfo* pFileInfoFirst, BOOL bDrivers = FALSE);
static HRESULT AddMusicPortInfo(HWND hwndList, MusicInfo* pMusicInfo);
static HRESULT ScanSystem(VOID);
static VOID SaveInfo(VOID);
static VOID ToggleDDAccel(VOID);
static VOID ToggleD3DAccel(VOID);
static VOID ToggleAGPSupport(VOID);
static VOID ToggleDMAccel(VOID);
static VOID ReportBug(VOID);
static INT_PTR CALLBACK BugDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static VOID SaveAndSendBug(TCHAR* szPath);
static VOID OverrideDDRefresh(VOID);
static INT_PTR CALLBACK OverrideRefreshDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static VOID ShowHelp(VOID);
static VOID RestoreDrivers(VOID);
static BOOL BCanRestoreDrivers(VOID);
static VOID HandleSndSliderChange(INT nScrollCode, INT nPos);
static VOID TroubleShoot( BOOL bTroubleShootSound );
static BOOL QueryCrashProtection( TCHAR* strKey, TCHAR* strValue, int nSkipQuestionID, DWORD dwCurrentStep );
static VOID EnterCrashProtection( TCHAR* strKey, TCHAR* strValue, DWORD dwCurrentStep );
static VOID LeaveCrashProtection( TCHAR* strKey, TCHAR* strValue, DWORD dwCurrentStep );
static VOID TestD3D(HWND hwndMain, DisplayInfo* pDisplayInfo);
static BOOL GetTxtPath( TCHAR* strTxtPath );
static VOID SetTxtPath( TCHAR* strTxtPath );
static UINT WINAPI UIThreadProc( LPVOID lpParameter );

static BOOL s_bGUI = FALSE;
static BOOL s_bGhost = FALSE;
static BOOL s_bBugReport = FALSE;
static BOOL s_bSaveOnly = FALSE;
static HWND s_hwndMain = NULL;
static HWND s_hwndCurPage = NULL;
static HHOOK s_hHook = NULL;
static LONG s_lwCurPage = -1;
static LONG s_iPageDisplayFirst = -1;
static LONG s_iPageSoundFirst = -1;
static LONG s_iPageMusic = -1;
static LONG s_iPageInput = -1;
static LONG s_iPageNetwork = -1;
static LONG s_iPageStillStuck = -1;
static HIMAGELIST s_himgList = NULL;
static SysInfo s_sysInfo;
static FileInfo* s_pDxWinComponentsFileInfoFirst = NULL;
static FileInfo* s_pDxComponentsFileInfoFirst = NULL;
static DisplayInfo* s_pDisplayInfoFirst = NULL;
static LONG s_numDisplayInfo = 0;
static SoundInfo* s_pSoundInfoFirst = NULL;
static LONG s_numSoundInfo = 0;
static MusicInfo* s_pMusicInfo = NULL;
static InputInfo* s_pInputInfo = NULL;
static NetInfo* s_pNetInfo = NULL;
static ShowInfo* s_pShowInfo = NULL;

static CRITICAL_SECTION s_cs;
static DWORD  s_dwMainThreadID      = 0;
static HANDLE s_hUIThread           = NULL;
static HANDLE s_hQuerySkipEvent     = NULL;
static DWORD  s_nSkipComponent      = 0;
static BOOL   s_bQuerySkipAllow     = FALSE;
static UI_MSG_NODE* s_pUIMsgHead    = NULL;
static HANDLE s_hUIMsgEvent         = NULL;
static BOOL   s_bScanDone           = FALSE;

static DXFILE_SORT_INFO s_sortInfo;
static HINSTANCE g_hInst = NULL;
static BOOL s_bUseSystemInfo = TRUE;
static BOOL s_bUseDisplay    = TRUE;
static BOOL s_bUseDSound     = TRUE;
static BOOL s_bUseDMusic     = TRUE;
static BOOL s_bUseDInput     = TRUE;
static BOOL s_bUseDPlay      = TRUE;
static BOOL s_bUseDShow      = TRUE;

class CWMIHelper
{
public:
    CWMIHelper();
    ~CWMIHelper();
};

CWMIHelper     g_WMIHelper;
IWbemServices* g_pIWbemServices;




/****************************************************************************
 *
 *  WinMain - Entry point for DxDiag program
 *
 *  Command-line options:
 *      <none> : Run with graphical user interface
 *      -ghost : Show Ghost Display Devices option (this flag must come next)
 *  -bugreport : GUI, go straight to bug report page/dialog
 *   -saveonly : GUI, just choose where to save text file, save, then exit
 *          -l : No GUI, generate shortcut to DxDiag, then exit
 *          -d : No GUI, generate comma-separated-values (csv) file
 *          -p : No GUI, generate text file named dxdiag.txt
 *      <path> : No GUI, generate text file named <path>
 *
 ****************************************************************************/
INT WINAPI WinMain(HINSTANCE hinstance, HINSTANCE hPrevInstance, 
                   LPSTR lpCmdLine, INT nCmdShow)
{
    HRESULT hr;
    HINSTANCE hinstRichEdit = NULL;

    g_hInst = hinstance;
    s_hQuerySkipEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    s_hUIMsgEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    InitializeCriticalSection( &s_cs );

#ifdef UNICODE
    if (!BIsPlatformNT())
    {
        // Unicode version only runs on WinNT.
        // Can't use ReportError because it calls Unicode APIs
        CHAR szDescription[MAX_PATH];
        CHAR szMessage[MAX_PATH];
        CHAR szFmt2[MAX_PATH];
        CHAR szTitle[MAX_PATH];

        LoadStringA(NULL, IDS_UNICODEREQUIRESNT, szDescription, MAX_PATH);
        LoadStringA(NULL, IDS_ERRORFMT2, szFmt2, MAX_PATH);
        LoadStringA(NULL, IDS_ERRORTITLE, szTitle, MAX_PATH);
        wsprintfA(szMessage, szFmt2, szDescription);
        MessageBoxA(s_hwndMain, szMessage, szTitle, MB_OK);
        return 1;
    }
#endif
    TCHAR* pszCmdLine = GetCommandLine();

    // Skip past program name (first token in command line).
    if (*pszCmdLine == TEXT('"'))  // Check for and handle quoted program name
    {
        pszCmdLine++;
        // Scan, and skip over, subsequent characters until  another
        // double-quote or a null is encountered
        while (*pszCmdLine && (*pszCmdLine != TEXT('"')))
            pszCmdLine++;
        // If we stopped on a double-quote (usual case), skip over it.
        if (*pszCmdLine == TEXT('"'))            
            pszCmdLine++;    
    }
    else    // First token wasn't a quote
    {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }
    // Skip past any white space preceeding the second token.
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' ')))
        pszCmdLine++;

    // Check for ghost flag (which must appear before any 
    // other flags except -media due to this implementation)
    if (_tcsstr(pszCmdLine, TEXT("-ghost")) != NULL)
    {
        s_bGhost = TRUE;
        pszCmdLine += lstrlen(TEXT("-ghost"));

        // Skip past any white space
        while (*pszCmdLine && (*pszCmdLine <= TEXT(' ')))
            pszCmdLine++;
    }

    // Check command line to determine whether to run in GUI mode
    if (lstrcmp(pszCmdLine, TEXT("")) == 0) 
        s_bGUI = TRUE;

    if (lstrcmp(pszCmdLine, TEXT("-bugreport")) == 0)
    {
        s_bGUI = TRUE;
        s_bBugReport = TRUE;
    }

    if (lstrcmp(pszCmdLine, TEXT("-saveonly")) == 0)
    {
        s_bGUI = TRUE;
        s_bSaveOnly = TRUE;
    }

    // Check for pre-Win95 or pre-NT5
    if (OldWindowsVersion())
    {
        ReportError(IDS_OLDWINDOWSVERSION);
        return 1;
    }

    if (s_bBugReport || s_bSaveOnly)
    {
        // Save a text file using GUI and exit

        // ******* GetSystemInfo (SI:1) ********
        if( s_bUseSystemInfo )
        {
            s_bUseSystemInfo = QueryCrashProtection( DXD_IN_SI_KEY, DXD_IN_SI_VALUE, IDS_SI, 1 );
            if( s_bUseSystemInfo )
            {
                EnterCrashProtection( DXD_IN_SI_KEY, DXD_IN_SI_VALUE, 1 );
                GetSystemInfo(&s_sysInfo);
                LeaveCrashProtection( DXD_IN_SI_KEY, DXD_IN_SI_VALUE, 1 );
            }
        }

        // ******* GetBasicDisplayInfo (DD:1) ********
        if( s_bUseDisplay )
        {
            s_bUseDisplay = QueryCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, IDS_DD, 1 );
            if( s_bUseDisplay )
            {
                EnterCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 1 );
                if (FAILED(hr = GetBasicDisplayInfo(&s_pDisplayInfoFirst)))
                    ReportError(IDS_NOBASICDISPLAYINFO, hr);
                LeaveCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 1 );
            }
        }

        // ******* GetBasicSoundInfo (DS:1) ********
        if( s_bUseDSound )
        {
            s_bUseDSound = QueryCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, IDS_DS, 1 );
            if( s_bUseDSound )
            {
                EnterCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 1 );
                if (FAILED(hr = GetBasicSoundInfo(&s_pSoundInfoFirst)))
                    ReportError(IDS_NOBASICSOUNDINFO, hr);  // (but keep running)
                LeaveCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 1 );
            }
        }

        // ******* GetBasicMusicInfo (DM:1)  ********
        if( s_bUseDMusic )
        {
            s_bUseDMusic = QueryCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, IDS_DM, 1 );
            if( s_bUseDMusic )
            {
                EnterCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, 1 );
                if (FAILED(hr = GetBasicMusicInfo(&s_pMusicInfo)))
                    ReportError(IDS_NOBASICMUSICINFO, hr);  // (but keep running)
                LeaveCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, 1 );
            }
        }

        // ******* ScanSystem ********
        ScanSystem();

        if (s_bBugReport)
        {
            DialogBox(hinstance, MAKEINTRESOURCE(IDD_BUGINFO), NULL, BugDialogProc);
        }
        else // s_bSaveOnly
        {
            SaveInfo();
            TCHAR szTitle[MAX_PATH];
            TCHAR szMessage[MAX_PATH];
            LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
            LoadString(NULL, IDS_SAVEDONE, szMessage, MAX_PATH);
            MessageBox(NULL, szMessage, szTitle, MB_OK);
        }
    }
    else if (!s_bGUI) 
    {
        // Save a text file with no GUI and exit
        TCHAR szPath[MAX_PATH];

        // ******* GetSystemInfo (SI:1) ********
        if( s_bUseSystemInfo )
        {
            s_bUseSystemInfo = QueryCrashProtection( DXD_IN_SI_KEY, DXD_IN_SI_VALUE, IDS_SI, 1 );
            if( s_bUseSystemInfo )
            {
                EnterCrashProtection( DXD_IN_SI_KEY, DXD_IN_SI_VALUE, 1 );
                GetSystemInfo(&s_sysInfo);
                LeaveCrashProtection( DXD_IN_SI_KEY, DXD_IN_SI_VALUE, 1 );
            }
        }

        // ******* GetBasicDisplayInfo (DD:1) ********
        if( s_bUseDisplay )
        {
            s_bUseDisplay = QueryCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, IDS_DD, 1 );
            if( s_bUseDisplay )
            {
                EnterCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 1 );
                if (FAILED(hr = GetBasicDisplayInfo(&s_pDisplayInfoFirst)))
                    ReportError(IDS_NOBASICDISPLAYINFO, hr);
                LeaveCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 1 );
            }
        }

        // ******* GetBasicSoundInfo (DS:1) ********
        if( s_bUseDSound )
        {
            s_bUseDSound = QueryCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, IDS_DS, 1 );
            if( s_bUseDSound )
            {
                EnterCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 1 );
                if (FAILED(hr = GetBasicSoundInfo(&s_pSoundInfoFirst)))
                    ReportError(IDS_NOBASICSOUNDINFO, hr);  // (but keep running)
                LeaveCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 1 );
            }
        }

        // ******* GetBasicMusicInfo (DM:1)  ********
        if( s_bUseDMusic )
        {
            s_bUseDMusic = QueryCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, IDS_DM, 1 );
            if( s_bUseDMusic )
            {
                EnterCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, 1 );
                if (FAILED(hr = GetBasicMusicInfo(&s_pMusicInfo)))
                    ReportError(IDS_NOBASICMUSICINFO, hr);  // (but keep running)
                LeaveCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, 1 );
            }
        }

        // ******* ScanSystem ********
        ScanSystem();

        if (_tcsicmp(pszCmdLine, TEXT("-d")) == 0)
        {
            wsprintf(szPath, TEXT("%s_%02d%02d%d_%02d%02d_Config.csv"),
                s_sysInfo.m_szMachine, s_sysInfo.m_time.wMonth, 
                s_sysInfo.m_time.wDay, s_sysInfo.m_time.wYear,  
                s_sysInfo.m_time.wHour, s_sysInfo.m_time.wMinute);
            if (FAILED(hr = SaveAllInfoCsv(szPath, &s_sysInfo, 
                s_pDxComponentsFileInfoFirst, 
                s_pDisplayInfoFirst, s_pSoundInfoFirst, s_pInputInfo)))
            {
                ReportError(IDS_PROBLEMSAVING, hr);
                goto LCleanup;
            }
        }
        else
        {
            if (_tcsicmp(pszCmdLine, TEXT("-p")) == 0)
                lstrcpy(szPath, TEXT("DxDiag.txt"));
            else
                lstrcpy(szPath, pszCmdLine);
            if (FAILED(hr = SaveAllInfo(szPath, &s_sysInfo, 
                s_pDxWinComponentsFileInfoFirst, s_pDxComponentsFileInfoFirst, 
                s_pDisplayInfoFirst, s_pSoundInfoFirst, s_pMusicInfo,
                s_pInputInfo, s_pNetInfo, s_pShowInfo )))
            {
                ReportError(IDS_PROBLEMSAVING, hr);
                goto LCleanup;
            }
        }
    }
    else
    {
        // Do full Windows GUI
        UINT dwUIThreadID;
        s_dwMainThreadID = GetCurrentThreadId();

        // Do scanning that must be done before the main dialog comes up:
        // ******* GetSystemInfo (SI:1) ********
        if( s_bUseSystemInfo )
        {
            s_bUseSystemInfo = QueryCrashProtection( DXD_IN_SI_KEY, DXD_IN_SI_VALUE, IDS_SI, 1 );
            if( s_bUseSystemInfo )
            {
                EnterCrashProtection( DXD_IN_SI_KEY, DXD_IN_SI_VALUE, 1 );
                GetSystemInfo(&s_sysInfo);
                LeaveCrashProtection( DXD_IN_SI_KEY, DXD_IN_SI_VALUE, 1 );
            }
        }

        // ******* GetBasicDisplayInfo (DD:1) ********
        if( s_bUseDisplay )
        {
            s_bUseDisplay = QueryCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, IDS_DD, 1 );
            if( s_bUseDisplay )
            {
                EnterCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 1 );
                if (FAILED(hr = GetBasicDisplayInfo(&s_pDisplayInfoFirst)))
                    ReportError(IDS_NOBASICDISPLAYINFO, hr);
                LeaveCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 1 );
            }
        }

        // ******* GetBasicSoundInfo (DS:1) ********
        if( s_bUseDSound )
        {
            s_bUseDSound = QueryCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, IDS_DS, 1 );
            if( s_bUseDSound )
            {
                EnterCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 1 );
                if (FAILED(hr = GetBasicSoundInfo(&s_pSoundInfoFirst)))
                    ReportError(IDS_NOBASICSOUNDINFO, hr);  // (but keep running)
                LeaveCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 1 );
            }
        }

        // ******* GetBasicMusicInfo (DM:1)  ********
        if( s_bUseDMusic )
        {
            s_bUseDMusic = QueryCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, IDS_DM, 1 );
            if( s_bUseDMusic )
            {
                EnterCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, 1 );
                if (FAILED(hr = GetBasicMusicInfo(&s_pMusicInfo)))
                    ReportError(IDS_NOBASICMUSICINFO, hr);  // (but keep running)
                LeaveCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, 1 );
            }
        }

        if( NULL == s_hUIThread )
        {
            // Create the UI thread
            s_hUIThread = (HANDLE) _beginthreadex( NULL, 0, UIThreadProc, NULL, 0, &dwUIThreadID );

            // Wait for either s_hwndMain is set or the UI thread to exit
            for(;;)
            {
                // Stop of the s_hwndMain is set
                if( s_hwndMain )
                    break;
                // Stop if the UI thread is gone 
                if( WAIT_TIMEOUT != WaitForSingleObject( s_hUIThread, 0 ) )
                    break;
                Sleep(50);
            }
        }

        if( WAIT_TIMEOUT == WaitForSingleObject( s_hUIThread, 0 ) )
        {
            ScanSystem();

            s_bScanDone = TRUE;
            SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

            // Done scaning, so wait for the UI thread to exit
            WaitForSingleObject( s_hUIThread, INFINITE );
        }

        CloseHandle( s_hUIThread );
    }

LCleanup:
    CloseHandle( s_hQuerySkipEvent );
    CloseHandle( s_hUIMsgEvent );
    DeleteCriticalSection( &s_cs );

    // Clean up:
    if (s_pDxComponentsFileInfoFirst != NULL)
        DestroyFileList(s_pDxComponentsFileInfoFirst);
    if (s_pDisplayInfoFirst != NULL)
        DestroyDisplayInfo(s_pDisplayInfoFirst);
    if (s_pSoundInfoFirst != NULL)
        DestroySoundInfo(s_pSoundInfoFirst);
    if (s_pMusicInfo != NULL)
        DestroyMusicInfo(s_pMusicInfo);
    if (s_pNetInfo != NULL)
        DestroyNetInfo(s_pNetInfo);
    if (s_pInputInfo != NULL)
        DestroyInputInfo(s_pInputInfo);
    if (s_pShowInfo != NULL)
        DestroyShowInfo(s_pShowInfo);
    ReleaseDigiSignData();

    return 0;
}





//-----------------------------------------------------------------------------
// Name: UIThreadProc
// Desc: 
//-----------------------------------------------------------------------------
UINT WINAPI UIThreadProc( LPVOID lpParameter )
{
    UNREFERENCED_PARAMETER( lpParameter );
    
    HICON hicon;
    HINSTANCE hinstRichEdit = NULL;
    HWND hMainDlg;
    MSG msg;

    hinstRichEdit = LoadLibrary(TEXT("RICHED32.DLL"));
    if (hinstRichEdit == NULL)
    {
        ReportError(IDS_NORICHED32);
        goto LCleanup;
    }
    InitCommonControls();

    s_himgList = ImageList_Create(16, 16, ILC_COLOR4 | ILC_MASK, 1, 0);
    if (s_himgList == NULL)
    {
        ReportError(IDS_NOIMAGELIST);
        goto LCleanup;
    }
    hicon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_CAUTION)); 
    if (hicon == NULL)
    {
        ReportError(IDS_NOICON);
        goto LCleanup;
    }
    ImageList_AddIcon(s_himgList, hicon); 

    {
        // BUG 21632: Warn user if DirectX version is newer than DxDiag version
        // (Note: don't check down to the build number, just major.minor.revision)
        if( !BIsWinNT() )
        {
            DWORD dwMajorDX = 0, dwMinorDX = 0, dwRevisionDX = 0, dwBuildDX = 0;
            DWORD dwMajorDXD = 0, dwMinorDXD = 0, dwRevisionDXD = 0, dwBuildDXD = 0;
            if( _stscanf(s_sysInfo.m_szDirectXVersion, TEXT("%d.%d.%d.%d"), &dwMajorDX, &dwMinorDX, &dwRevisionDX, &dwBuildDX) != 4 )
            {
                dwMajorDX = 0;
                dwMinorDX = 0;
                dwRevisionDX = 0;
                dwBuildDX = 0;
            }
            if( _stscanf(s_sysInfo.m_szDxDiagVersion, TEXT("%d.%d.%d.%d"), &dwMajorDXD, &dwMinorDXD, &dwRevisionDXD, &dwBuildDXD) != 4 )
            {
                dwMajorDXD = 0;
                dwMinorDXD = 0;
                dwRevisionDXD = 0;
                dwBuildDXD = 0;
            }

            if (dwMajorDX > dwMajorDXD ||
                dwMajorDX == dwMajorDXD && dwMinorDX > dwMinorDXD ||
                dwMajorDX == dwMajorDXD && dwMinorDX == dwMinorDXD && dwRevisionDX > dwRevisionDXD)
            {
                TCHAR szFmt[MAX_PATH];
                TCHAR szMessage[MAX_PATH];
                TCHAR szTitle[MAX_PATH];
                LoadString(NULL, IDS_DXDIAGISOLDFMT, szFmt, MAX_PATH);
                wsprintf(szMessage, szFmt, s_sysInfo.m_szDirectXVersion, s_sysInfo.m_szDxDiagVersion);
                LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
                MessageBox(NULL, szMessage, szTitle, MB_OK);
            }
        }
    }

    // Display the main dialog box.
    hMainDlg = CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_MAINDIALOG), 
                             NULL, DialogProc );

     // Windows messages are available   
    DWORD dwResult;
    BOOL bDone;
    bDone = FALSE;
    for(;;)
    {
        dwResult = MsgWaitForMultipleObjects( 1, &s_hUIMsgEvent, FALSE, 
                                              INFINITE, QS_ALLEVENTS | QS_ALLINPUT | QS_ALLPOSTMESSAGE );
        switch( dwResult )
        {
            case WAIT_OBJECT_0:
            {
                if( s_pUIMsgHead )
                {
                    UI_MSG_NODE* pCurNode = s_pUIMsgHead;
                    UINT         message    = pCurNode->message;
                    WPARAM       wparam     = pCurNode->wparam;
                    LPARAM       lparam     = pCurNode->lparam;;

                    s_pUIMsgHead = s_pUIMsgHead->pNext;

                    delete pCurNode;
                    if( s_pUIMsgHead )
                        SetEvent( s_hUIMsgEvent );

                    switch( message )
                    {
                    case WM_QUERYSKIP:
                        message = WM_QUERYSKIP_REAL;
                        break;
                    case WM_NETMEETINGWARN:
                        message = WM_NETMEETINGWARN_REAL;
                        break;
                    case WM_COMMAND:
                        message = WM_COMMAND_REAL;
                        break;
                    case WM_REPORTERROR:
                        message = WM_REPORTERROR_REAL;
                        break;
                    }

                    SendMessage( hMainDlg, message, wparam, lparam );
                }

                break;
            }

            case WAIT_OBJECT_0 + 1:
            {
                while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) ) 
                { 
                    if( msg.message == WM_QUIT )
                        bDone = TRUE;

                    if( !IsDialogMessage( hMainDlg, &msg ) )  
                    {
                        TranslateMessage( &msg ); 
                        DispatchMessage( &msg ); 
                    }
                }
                break;
            }
        }

        if( bDone )
            break;
    }

    DestroyWindow( hMainDlg );
    
LCleanup:
    while( s_pUIMsgHead )
    {
        UI_MSG_NODE* pDelete = s_pUIMsgHead;
        s_pUIMsgHead = s_pUIMsgHead->pNext;
        delete pDelete;
    }

    // Clean up:
    if (s_himgList != NULL)
        ImageList_Destroy(s_himgList);
    if (hinstRichEdit != NULL)
        FreeLibrary(hinstRichEdit);

    return 0;
}




/****************************************************************************
 *
 *  OldWindowsVersion - Returns TRUE if running NT before NT5 or pre-Win95.
 *  Exception: NT4 is allowed if -bugreport was specified.
 *
 ****************************************************************************/
BOOL OldWindowsVersion(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    if (OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        if (OSVersionInfo.dwMajorVersion == 4)
        {
            if (s_bBugReport)
                return FALSE; // NT4 supported if "-bugreport" by DxMedia request
            if (s_bSaveOnly)
                return FALSE; // NT4 supported if "-saveonly" specified
            // Ask if user wants to run in saveonly mode:
            TCHAR szTitle[MAX_PATH];
            TCHAR szMessage[MAX_PATH];
            LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
            LoadString(NULL, IDS_NT4SAVEONLY, szMessage, MAX_PATH);
            if (IDYES == MessageBox(NULL, szMessage, szTitle, MB_YESNO))
            {
                s_bSaveOnly = TRUE;
                s_bGUI = TRUE;
                return FALSE;
            }
        }
        if (OSVersionInfo.dwMajorVersion < 5)
            return TRUE; // NT4 and earlier not supported
    }
    else
    {
        if (OSVersionInfo.dwMajorVersion < 4)
            return TRUE; // Pre-Win95 not supported
    }
    return FALSE; // Win95 or later, or NT5 or later
}



//-----------------------------------------------------------------------------
// Name: ReportError
// Desc: 
//-----------------------------------------------------------------------------
VOID ReportError(LONG idsDescription, HRESULT hr)
{
    if( s_hwndMain )
        PostMessage( s_hwndMain, WM_REPORTERROR, (WPARAM) idsDescription, (LPARAM) hr );
    else
        ReportErrorReal( idsDescription, hr );
}




//-----------------------------------------------------------------------------
// Name: ReportErrorReal
// Desc: 
//-----------------------------------------------------------------------------
VOID ReportErrorReal(LONG idsDescription, HRESULT hr)
{
    TCHAR szDescription[MAX_PATH];
    TCHAR szMessage[MAX_PATH];
    TCHAR szFmt1[MAX_PATH];
    TCHAR szFmt2[MAX_PATH];
    TCHAR szTitle[MAX_PATH];
    TCHAR szErrorDesc[MAX_PATH];

    LoadString(NULL, idsDescription, szDescription, MAX_PATH);
    LoadString(NULL, IDS_ERRORFMT1, szFmt1, MAX_PATH);
    LoadString(NULL, IDS_ERRORFMT2, szFmt2, MAX_PATH);
    LoadString(NULL, IDS_ERRORTITLE, szTitle, MAX_PATH);

    if (FAILED(hr))
    {
        BTranslateError(hr, szErrorDesc);
        wsprintf(szMessage, szFmt1, szDescription, hr, szErrorDesc);
    }
    else
    {
        wsprintf(szMessage, szFmt2, szDescription);
    }
    
    if (s_bGUI)
        MessageBox(s_hwndMain, szMessage, szTitle, MB_OK);
    else
        _tprintf(szMessage);
}


typedef BOOL (WINAPI* PfnCoSetProxyBlanket)(
                                    IUnknown                 *pProxy,
                                    DWORD                     dwAuthnSvc,
                                    DWORD                     dwAuthzSvc,
                                    OLECHAR                  *pServerPrincName,
                                    DWORD                     dwAuthnLevel,
                                    DWORD                     dwImpLevel,
                                    RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
                                    DWORD                     dwCapabilities );

/****************************************************************************
 *
 *  CWMIHelper - Inits DCOM and g_pIWbemServices
 *
 ****************************************************************************/
CWMIHelper::CWMIHelper(VOID)
{
    HRESULT       hr;
    IWbemLocator* pIWbemLocator = NULL;
    BSTR          pNamespace    = NULL;
    HINSTANCE     hinstOle32 = NULL;

    CoInitialize( 0 );
    hr = CoCreateInstance( CLSID_WbemLocator,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IWbemLocator,
                           (LPVOID*) &pIWbemLocator);
    if( FAILED(hr) || pIWbemLocator == NULL )
        goto LCleanup;

    // Using the locator, connect to WMI in the given namespace.
    pNamespace = SysAllocString( L"\\\\.\\root\\cimv2" );

    hr = pIWbemLocator->ConnectServer( pNamespace, NULL, NULL, 0L, 
                                       0L, NULL, NULL, &g_pIWbemServices );
    if( FAILED(hr) || g_pIWbemServices == NULL )
        goto LCleanup;

    hinstOle32 = LoadLibrary( TEXT("ole32.dll") );
    if( hinstOle32 )
    {
        PfnCoSetProxyBlanket pfnCoSetProxyBlanket = NULL;

        pfnCoSetProxyBlanket = (PfnCoSetProxyBlanket)GetProcAddress( hinstOle32, "CoSetProxyBlanket" );
        if (pfnCoSetProxyBlanket != NULL)
        {

            // Switch security level to IMPERSONATE. 
            hr = pfnCoSetProxyBlanket( g_pIWbemServices,               // proxy
                                    RPC_C_AUTHN_WINNT,              // authentication service
                                    RPC_C_AUTHZ_NONE,               // authorization service
                                    NULL,                           // server principle name
                                    RPC_C_AUTHN_LEVEL_CALL,         // authentication level
                                    RPC_C_IMP_LEVEL_IMPERSONATE,    // impersonation level
                                    NULL,                           // identity of the client
                                    EOAC_NONE );                    // capability flags
            // If CoSetProxyBlanket, just leave it be and see if it works.
        }

    }

LCleanup:
    if( hinstOle32 )
        FreeLibrary(hinstOle32);
    if(pNamespace)
        SysFreeString(pNamespace);
    if(pIWbemLocator)
        pIWbemLocator->Release(); 
}


/****************************************************************************
 *
 *  ~CWMIHelper - Cleanup WMI
 *
 ****************************************************************************/
CWMIHelper::~CWMIHelper(VOID)
{
    if(g_pIWbemServices)
        g_pIWbemServices->Release(); 

    CoUninitialize();
}


/****************************************************************************
 *
 *  DXFilesCompareFunc - Compares items on DirectX files pages
 *
 ****************************************************************************/
int CALLBACK DXFilesCompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lSortMethod)
{
    FileInfo* pFileInfo1 = (FileInfo*) lParam1;
    FileInfo* pFileInfo2 = (FileInfo*) lParam2;

    switch( s_sortInfo.dwColumnToSort )
    {
    case 0:
        return (s_sortInfo.nSortDirection * (_tcscmp( pFileInfo1->m_szName, 
                                                      pFileInfo2->m_szName )));

    case 1:
        return (s_sortInfo.nSortDirection * (_tcscmp( pFileInfo1->m_szVersion, 
                                                      pFileInfo2->m_szVersion )));

    case 2:
        return (s_sortInfo.nSortDirection * (_tcscmp( pFileInfo1->m_szAttributes, 
                                                      pFileInfo2->m_szAttributes )));

    case 3:
        return (s_sortInfo.nSortDirection * (_tcscmp( pFileInfo1->m_szLanguageLocal, 
                                                      pFileInfo2->m_szLanguageLocal )));

    case 4:
        return ( s_sortInfo.nSortDirection * CompareFileTime( &pFileInfo1->m_FileTime, 
                                                              &pFileInfo2->m_FileTime ) );

    case 5:
        if( pFileInfo1->m_numBytes > pFileInfo2->m_numBytes )
            return (s_sortInfo.nSortDirection * 1);
        if( pFileInfo1->m_numBytes < pFileInfo2->m_numBytes )
            return (s_sortInfo.nSortDirection * -1);
        return 0;
    }

    return 0;
}


/****************************************************************************
 *
 *  MsgHook
 *
 ****************************************************************************/
LRESULT FAR PASCAL MsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
   LPMSG pMsg = (LPMSG) lParam;

    if( pMsg && 
        pMsg->message == WM_KEYDOWN &&
        pMsg->wParam  == VK_TAB &&
        GetKeyState(VK_CONTROL) < 0) 
    {
        // Handle a ctrl-tab or ctrl-shift-tab
        if( GetKeyState(VK_SHIFT) < 0 ) 
            PostMessage( s_hwndMain, WM_COMMAND, IDC_PREV_TAB, 0 );
        else
            PostMessage( s_hwndMain, WM_COMMAND, IDC_NEXT_TAB, 0 );

        // Stop further processing, otherwise it will also be handled 
        // as a plain tab key pressed by the internal IsDialogBox() call.
        pMsg->message = WM_NULL;
        pMsg->lParam  = 0;
        pMsg->wParam  = 0;     
    }

    return CallNextHookEx( s_hHook, nCode, wParam, lParam);
} 


/****************************************************************************
 *
 *  DialogProc
 *
 ****************************************************************************/
INT_PTR CALLBACK DialogProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    HWND hwndTabs = GetDlgItem(hwnd, IDC_TAB);

    switch (msg)
    {
    case WM_INITDIALOG:
        {
            SetForegroundWindow( hwnd );

            s_hwndMain = hwnd;
            s_hHook = SetWindowsHookEx( WH_GETMESSAGE, MsgHook,
                                        NULL, GetCurrentThreadId() );         
            HINSTANCE hinst = (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
            HICON hicon = LoadIcon(hinst, MAKEINTRESOURCE(IDI_APP)); 
            SendMessage(hwnd, WM_SETICON, TRUE, (LPARAM)hicon);
            SendMessage(hwnd, WM_SETICON, FALSE, (LPARAM)hicon);

            CreateTabs(hwndTabs);
            SetupPage(hwndTabs, 0);
            SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

            if( s_sysInfo.m_bNetMeetingRunning )
                PostMessage( s_hwndMain, WM_NETMEETINGWARN, 0, 0 );
            
            s_sortInfo.nSortDirection = 1;
            s_sortInfo.dwColumnToSort = -1;
        }
        return TRUE;

        case WM_APP_PROGRESS:
            {
                if( s_lwCurPage == 0 )
                {
                    HWND hProgress = GetDlgItem( s_hwndCurPage, IDC_LOAD_PROGRESS );

                    if( !s_bScanDone )
                    {
                        ShowWindow( hProgress, SW_SHOW );
                        SendMessage( hProgress, PBM_DELTAPOS, 10, 0 );
                        UpdateWindow( s_hwndMain );
                        UpdateWindow( s_hwndCurPage );
                    }
                    else
                    {
                        ShowWindow( hProgress, SW_HIDE );
                        EnableWindow( GetDlgItem(hwnd, IDNEXT), TRUE );
                        EnableWindow( GetDlgItem(hwnd, IDSAVE), TRUE );
                    }
                }
            }
            break;

        case WM_REPORTERROR:
        case WM_NETMEETINGWARN:
        case WM_COMMAND:
        case WM_QUERYSKIP:
        {
            UI_MSG_NODE* pMsg = new UI_MSG_NODE;
            if( NULL == pMsg )
                return TRUE;
            ZeroMemory( pMsg, sizeof(UI_MSG_NODE) );
            pMsg->message = msg;
            pMsg->lparam  = lparam;
            pMsg->wparam  = wparam;

            UI_MSG_NODE* pEnum = s_pUIMsgHead;
            UI_MSG_NODE* pPrev = NULL;
            while( pEnum )
            {
                pPrev = pEnum;
                pEnum = pEnum->pNext;
            }
            if( pPrev )
                pPrev->pNext = pMsg;
            else
                s_pUIMsgHead = pMsg;

            SetEvent( s_hUIMsgEvent );
            return TRUE;
        }

        case WM_REPORTERROR_REAL:
        {
            ReportErrorReal( (LONG) wparam, (HRESULT) lparam );
            return TRUE;
        }

        case WM_NETMEETINGWARN_REAL:
        {
            TCHAR strMessage[MAX_PATH];
            TCHAR strTitle[MAX_PATH];

            LoadString(NULL, IDS_APPFULLNAME, strTitle, MAX_PATH);
            LoadString(NULL, IDS_NETMEETINGWARN, strMessage, MAX_PATH);
            MessageBox( s_hwndMain, strMessage, strTitle, MB_OK|MB_ICONWARNING );
            return TRUE;
        }

        case WM_QUERYSKIP_REAL:
        {
            EnableWindow( s_hwndMain, FALSE );
            TCHAR szTitle[MAX_PATH];
            TCHAR szMessage[MAX_PATH];
            TCHAR szFmt[MAX_PATH];
            TCHAR szMessageComponent[MAX_PATH];
            LoadString(0, IDS_APPFULLNAME, szTitle, MAX_PATH);
            LoadString(0, IDS_SKIP, szFmt, MAX_PATH);
            LoadString(0, s_nSkipComponent, szMessageComponent, MAX_PATH);
            wsprintf( szMessage, szFmt, szMessageComponent, szMessageComponent );

            // Ask the user and store result it s_bQuerySkipAllow
            if( IDYES == MessageBox( s_hwndMain, szMessage, szTitle, MB_YESNO) )
                s_bQuerySkipAllow = FALSE;
            else
                s_bQuerySkipAllow = TRUE;

            EnableWindow( s_hwndMain, TRUE );

            // Set the event, triggering the main thread to wake up 
            SetEvent( s_hQuerySkipEvent );
        }
        return TRUE;

        case WM_COMMAND_REAL:
        {
            WORD wID = LOWORD(wparam);
            INT numTabs;
            INT iTabCur;
            DisplayInfo* pDisplayInfo = NULL;
            SoundInfo* pSoundInfo = NULL;
            switch(wID)
            {
            case IDEXIT:
                PostQuitMessage( 0 );
                break;
            case IDC_NEXT_TAB:
            case IDNEXT:
            case IDC_PREV_TAB:
                if( FALSE == s_bScanDone )
                {
                    MessageBeep( MB_ICONEXCLAMATION );
                    return TRUE;
                }

                numTabs = TabCtrl_GetItemCount(hwndTabs);
                iTabCur = TabCtrl_GetCurFocus(hwndTabs);

                if( wID == IDC_PREV_TAB )
                    iTabCur += numTabs - 1;
                else
                    iTabCur++;
                iTabCur %= numTabs;                
                
                TabCtrl_SetCurFocus(hwndTabs, iTabCur );
                break;
            case IDSAVE:
                SaveInfo();
                break;
            case IDC_APPHELP:
                ShowHelp();
                break;
            case IDC_RESTOREDRIVERS:
                RestoreDrivers();
                break;
            case IDC_TESTDD:
                iTabCur = TabCtrl_GetCurFocus(hwndTabs);
                for (pDisplayInfo = s_pDisplayInfoFirst; iTabCur > s_iPageDisplayFirst; iTabCur--)
                    pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext;
                TestDD(s_hwndMain, pDisplayInfo);
                SetupDisplayPage(TabCtrl_GetCurFocus(hwndTabs) - s_iPageDisplayFirst);
                break;
            case IDC_TESTD3D:
                iTabCur = TabCtrl_GetCurFocus(hwndTabs);
                for (pDisplayInfo = s_pDisplayInfoFirst; iTabCur > s_iPageDisplayFirst; iTabCur--)
                    pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext;
                TestD3D(s_hwndMain, pDisplayInfo);
                SetupDisplayPage(TabCtrl_GetCurFocus(hwndTabs) - s_iPageDisplayFirst);
                break;
            case IDC_TESTSND:
                iTabCur = TabCtrl_GetCurFocus(hwndTabs);
                for (pSoundInfo = s_pSoundInfoFirst; iTabCur > s_iPageSoundFirst; iTabCur--)
                    pSoundInfo = pSoundInfo->m_pSoundInfoNext;
                TestSnd(s_hwndMain, pSoundInfo);
                SetupSoundPage(TabCtrl_GetCurFocus(hwndTabs) - s_iPageSoundFirst);
                break;
            case IDC_PORTLISTCOMBO:
                if (HIWORD(wparam) == CBN_SELCHANGE)
                {
                    LONG iItemPicked = (LONG)SendMessage(GetDlgItem(s_hwndCurPage, IDC_PORTLISTCOMBO), CB_GETCURSEL, 0, 0);
                    LONG iItem = 0;
                    MusicPort* pMusicPort;
                    for (pMusicPort = s_pMusicInfo->m_pMusicPortFirst; pMusicPort != NULL; pMusicPort = pMusicPort->m_pMusicPortNext)
                    {
                        if (pMusicPort->m_bOutputPort)
                        {
                            if (iItem == iItemPicked)
                            {
                                s_pMusicInfo->m_guidMusicPortTest = pMusicPort->m_guid;
                                break;
                            }
                            iItem++;
                        }
                    }
                }
                break;
            case IDC_TESTMUSIC:
                if (s_pMusicInfo != NULL)
                    TestMusic(s_hwndMain, s_pMusicInfo);
                SetupMusicPage();
                break;

            case IDC_TESTPLAY:
            {
                if( s_sysInfo.m_dwDirectXVersionMajor < 8 )
                {
                    TCHAR szMessage[MAX_PATH];
                    TCHAR szTitle[MAX_PATH];
                    LoadString(0, IDS_APPFULLNAME, szTitle, MAX_PATH);
                    LoadString(0, IDS_TESTNEEDSDX8, szMessage, MAX_PATH);
                    MessageBox(s_hwndMain, szMessage, szTitle, MB_OK);
                }
                else
                {
                    if (s_pNetInfo != NULL)
                        TestNetwork(s_hwndMain, s_pNetInfo);
                    SetupNetworkPage();
                }
                break;
            }

            case IDC_DISABLEDD:
                ToggleDDAccel();
                break;
            case IDC_DISABLED3D:
                ToggleD3DAccel();
                break;
            case IDC_DISABLEAGP:
                ToggleAGPSupport();
                break;
            case IDC_DISABLEDM:
                ToggleDMAccel();
                break;
            case IDC_REPORTBUG:
                ReportBug();
                break;
            case IDC_TROUBLESHOOT:
                TroubleShoot( FALSE );
                break;
            case IDC_TROUBLESHOOTSOUND:
                TroubleShoot( TRUE );
                break;
            case IDC_MSINFO:
                {
                    HKEY hkey;
                    TCHAR szMsInfo[MAX_PATH];
                    DWORD cbData = MAX_PATH;
                    DWORD dwType;
                    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                        TEXT("Software\\Microsoft\\Shared Tools\\MSInfo"), 0, KEY_READ, &hkey))
                    {
                        RegQueryValueEx(hkey, TEXT("Path"), 0, &dwType, (LPBYTE)szMsInfo, &cbData);
                        HINSTANCE hinstResult = ShellExecute( s_hwndMain, NULL, szMsInfo, NULL, 
                                                              NULL, SW_SHOWNORMAL ); 
                        if( (INT_PTR)hinstResult < 32 ) 
                            ReportError(IDS_NOMSINFO);
                    }
                    else
                    {
                        ReportError(IDS_NOMSINFO);
                    }
                }
                break;
            case IDC_OVERRIDE:
                OverrideDDRefresh();
                break;
            case IDC_GHOST:
                AdjustGhostDevices(s_hwndMain, s_pDisplayInfoFirst);
                break;
            }
        return TRUE;
        }

    case WM_NOTIFY:
        {
            INT id = (INT)wparam;
            NMHDR* pnmh = (LPNMHDR)lparam;
            UINT code = pnmh->code;
            if (code == TCN_SELCHANGING)
            {
                if( !s_bScanDone )
                {
                    MessageBeep( MB_ICONEXCLAMATION );
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }
             
                CleanupPage(hwndTabs, TabCtrl_GetCurFocus(hwndTabs));
                return TRUE;
            }
            if (code == TCN_SELCHANGE)
                SetupPage(hwndTabs, TabCtrl_GetCurFocus(hwndTabs));

            // If a "DX files" column was clicked
            if (code == LVN_COLUMNCLICK && s_lwCurPage == 1)
            {
                NMLISTVIEW* pnmv = (LPNMLISTVIEW) lparam; 

                // Figure out if we want to reverse sort
                if( s_sortInfo.dwColumnToSort == (DWORD) pnmv->iSubItem )
                    s_sortInfo.nSortDirection = -s_sortInfo.nSortDirection;
                else
                    s_sortInfo.nSortDirection = 1;

                // Set the column to sort, and sort
                s_sortInfo.dwColumnToSort = pnmv->iSubItem;
                ListView_SortItems( GetDlgItem(s_hwndCurPage, IDC_LIST), 
                                    DXFilesCompareFunc, 0 );
            }
        }
        return TRUE;

    case WM_HSCROLL:
        if ((HWND)lparam == GetDlgItem(s_hwndCurPage, IDC_SNDACCELSLIDER))
            HandleSndSliderChange(LOWORD(wparam), HIWORD(wparam));
        return TRUE;

    case WM_CLOSE:
        PostQuitMessage(0);
        return TRUE;

    case WM_DESTROY:
        UnhookWindowsHookEx( s_hHook );
        return TRUE;
    }

    return FALSE;
}


/****************************************************************************
 *
 *  CreateTabs
 *
 ****************************************************************************/
HRESULT CreateTabs(HWND hwndTabs)
{
    TC_ITEM tie; 
    INT i = 0;
    TCHAR sz[MAX_PATH];
    TCHAR szFmt[MAX_PATH];
    DisplayInfo* pDisplayInfo;
    SoundInfo* pSoundInfo;

    tie.mask = TCIF_TEXT | TCIF_IMAGE; 
    tie.iImage = -1; 

    LoadString(NULL, IDS_HELPTAB, sz, MAX_PATH);
    tie.pszText = sz; 
    if (TabCtrl_InsertItem(hwndTabs, i++, &tie) == -1) 
        return E_FAIL;

    LoadString(NULL, IDS_DXFILESTAB, sz, MAX_PATH);
    tie.pszText = sz; 
    if (TabCtrl_InsertItem(hwndTabs, i++, &tie) == -1) 
        return E_FAIL;

    // Create tabs for each display:
    s_iPageDisplayFirst = 2;
    for (pDisplayInfo = s_pDisplayInfoFirst; pDisplayInfo != NULL; 
        pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext)
    {
        if (pDisplayInfo == s_pDisplayInfoFirst && pDisplayInfo->m_pDisplayInfoNext == NULL)
        {
            LoadString(NULL, IDS_ONEDISPLAYTAB, sz, MAX_PATH);
        }
        else
        {
            LoadString(NULL, IDS_MULTIDISPLAYTAB, szFmt, MAX_PATH);
            wsprintf(sz, szFmt, s_numDisplayInfo + 1);
        }
        tie.pszText = sz; 
        if (TabCtrl_InsertItem(hwndTabs, i++, &tie) == -1) 
            return E_FAIL;
        s_numDisplayInfo++;
    }

    // Create tabs for each sound device:
    s_iPageSoundFirst = s_iPageDisplayFirst + s_numDisplayInfo;
    for (pSoundInfo = s_pSoundInfoFirst; pSoundInfo != NULL; 
        pSoundInfo = pSoundInfo->m_pSoundInfoNext)
    {
        if (pSoundInfo == s_pSoundInfoFirst && pSoundInfo->m_pSoundInfoNext == NULL)
        {
            LoadString(NULL, IDS_ONESOUNDTAB, sz, MAX_PATH);
        }
        else
        {
            LoadString(NULL, IDS_MULTISOUNDTAB, szFmt, MAX_PATH);
            wsprintf(sz, szFmt, s_numSoundInfo + 1);
        }
        tie.pszText = sz; 
        if (TabCtrl_InsertItem(hwndTabs, i++, &tie) == -1) 
            return E_FAIL;
        s_numSoundInfo++;
    }

    // Create tab for music device, if DMusic is available:
    if (s_pMusicInfo != NULL && s_pMusicInfo->m_bDMusicInstalled)
    {
        s_iPageMusic = s_iPageSoundFirst + s_numSoundInfo;
        LoadString(NULL, IDS_MUSICTAB, sz, MAX_PATH);
        tie.pszText = sz;
        if (TabCtrl_InsertItem(hwndTabs, i++, &tie) == -1) 
            return E_FAIL;
    }

    if (s_iPageMusic > 0)
        s_iPageInput = s_iPageMusic + 1;
    else 
        s_iPageInput = s_iPageSoundFirst + s_numSoundInfo;
    LoadString(NULL, IDS_INPUTTAB, sz, MAX_PATH);
    tie.pszText = sz;
    if (TabCtrl_InsertItem(hwndTabs, i++, &tie) == -1) 
        return E_FAIL;

    s_iPageNetwork = s_iPageInput + 1;
    LoadString(NULL, IDS_NETWORKTAB, sz, MAX_PATH);
    tie.pszText = sz;
    if (TabCtrl_InsertItem(hwndTabs, i++, &tie) == -1) 
        return E_FAIL;

    s_iPageStillStuck = s_iPageNetwork + 1;
    LoadString(NULL, IDS_STILLSTUCKTAB, sz, MAX_PATH);
    tie.pszText = sz;
    if (TabCtrl_InsertItem(hwndTabs, i++, &tie) == -1) 
        return E_FAIL;

    return S_OK;
}


/****************************************************************************
 *
 *  SetupPage
 *
 ****************************************************************************/
HRESULT SetupPage(HWND hwndTabs, INT iPage)
{
    HRESULT hr;

    s_lwCurPage = iPage;

    // Only enable "Next Page" button if not on last page:
    HWND hwndNextButton = GetDlgItem(s_hwndMain, IDNEXT);
    if (!s_bScanDone || iPage == TabCtrl_GetItemCount(hwndTabs) - 1)
        EnableWindow(hwndNextButton, FALSE);
    else
        EnableWindow(hwndNextButton, TRUE);

    EnableWindow(GetDlgItem(s_hwndMain, IDSAVE), s_bScanDone);
    
    RECT rc;
    WORD idDialog;

    GetClientRect(hwndTabs, &rc);
    TabCtrl_AdjustRect(hwndTabs, FALSE, &rc);

    if (iPage == 0)
        idDialog = IDD_HELPPAGE;
    else if (iPage == 1)
        idDialog = IDD_DXFILESPAGE;
    else if (iPage >= s_iPageDisplayFirst && iPage < s_iPageDisplayFirst + s_numDisplayInfo)
        idDialog = IDD_DISPLAYPAGE;
    else if (iPage >= s_iPageSoundFirst && iPage < s_iPageSoundFirst + s_numSoundInfo)
        idDialog = IDD_SOUNDPAGE;
    else if (iPage == s_iPageMusic)
        idDialog = IDD_MUSICPAGE;
    else if (iPage == s_iPageInput)
        idDialog = IDD_INPUTPAGE;
    else if (iPage == s_iPageNetwork)
        idDialog = IDD_NETWORKPAGE;
    else if (iPage == s_iPageStillStuck)
        idDialog = IDD_STILLSTUCKPAGE;
    else
        return S_OK;

    HINSTANCE hinst = (HINSTANCE)GetWindowLongPtr(hwndTabs, GWLP_HINSTANCE);
    s_hwndCurPage = CreateDialog(hinst, MAKEINTRESOURCE(idDialog),
        s_hwndMain, PageDialogProc);
    SetWindowPos(s_hwndCurPage, NULL, rc.left, rc.top, rc.right - rc.left, 
        rc.bottom - rc.top, 0);

    if (iPage == 0)
    {
        if (FAILED(hr = SetupHelpPage(hwndTabs)))
            return hr;
    }
    else if (iPage == 1)
    {
        if (FAILED(hr = SetupDxFilesPage()))
            return hr;
    }
    else if (iPage >= s_iPageDisplayFirst && iPage < s_iPageDisplayFirst + s_numDisplayInfo)
    {
        if (FAILED(hr = SetupDisplayPage(iPage - s_iPageDisplayFirst)))
            return hr;
    }
    else if (iPage >= s_iPageSoundFirst && iPage < s_iPageSoundFirst + s_numSoundInfo)
    {
        if (FAILED(hr = SetupSoundPage(iPage - s_iPageSoundFirst)))
            return hr;
    }
    else if (iPage == s_iPageMusic)
    {
        if (FAILED(hr = SetupMusicPage()))
            return hr;
    }
    else if (iPage == s_iPageInput)
    {
        if (FAILED(hr = SetupInputPage()))
            return hr;
    }
    else if (iPage == s_iPageNetwork)
    {
        if (FAILED(hr = SetupNetworkPage()))
            return hr;
    }
    else if (iPage == s_iPageStillStuck)
    {
        if (FAILED(hr = SetupStillStuckPage()))
            return hr;
    }

    // Make sure keyboard focus is somewhere
    if (GetFocus() == NULL)
        SetFocus(GetDlgItem(s_hwndMain, IDSAVE));

    ShowWindow(s_hwndCurPage, SW_SHOW);
    return S_OK;
}


/****************************************************************************
 *
 *  PageDialogProc
 *
 ****************************************************************************/
INT_PTR CALLBACK PageDialogProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    switch (msg)
    {
    case WM_INITDIALOG:
        return FALSE;

    case WM_COMMAND:
    case WM_HSCROLL:
    case WM_NOTIFY:
        // Pass the message up to the main dialog proc
        SendMessage(s_hwndMain, msg, wparam, lparam);
        return TRUE;
    }
    return FALSE;
}


/****************************************************************************
 *
 *  CleanupPage
 *
 ****************************************************************************/
HRESULT CleanupPage(HWND hwndTabs, INT iPage)
{
    if (s_hwndCurPage != NULL)
    {
        DestroyWindow(s_hwndCurPage);
        s_hwndCurPage = NULL;
    }
    return S_OK;
}


/****************************************************************************
 *
 *  SetupHelpPage
 *
 ****************************************************************************/
HRESULT SetupHelpPage(HWND hwndTabs)
{
    TCHAR szCopyrightFmt[MAX_PATH];
    TCHAR szUnicode[MAX_PATH];
    TCHAR szCopyright[MAX_PATH];

    LoadString(NULL, IDS_COPYRIGHTFMT, szCopyrightFmt, MAX_PATH);
#ifdef UNICODE
    LoadString(NULL, IDS_UNICODE, szUnicode, MAX_PATH);
#else
    lstrcpy(szUnicode, TEXT(""));
#endif
    wsprintf(szCopyright, szCopyrightFmt, s_sysInfo.m_szDxDiagVersion, szUnicode);

    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DATE), s_sysInfo.m_szTimeLocal);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_COMPUTERNAME), s_sysInfo.m_szMachine);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_OS), s_sysInfo.m_szOSEx);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_LANGUAGE), s_sysInfo.m_szLanguagesLocal);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_PROCESSOR), s_sysInfo.m_szProcessor);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_MEMORY), s_sysInfo.m_szPhysicalMemory);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_PAGEFILE), s_sysInfo.m_szPageFile);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DIRECTXVERSION), s_sysInfo.m_szDirectXVersionLong);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_COPYRIGHT), szCopyright);

    HWND hProgress = GetDlgItem( s_hwndCurPage, IDC_LOAD_PROGRESS );
    SendMessage( hProgress, PBM_SETRANGE, 0, MAKELPARAM(0, 17 * 10) );
    SendMessage( hProgress, PBM_SETPOS, 0, 0 );
    ShowWindow( hProgress, !s_bScanDone ? SW_SHOW : SW_HIDE );

    return S_OK;
}


/****************************************************************************
 *
 *  ShowBullets - Show bullets and 1/4-inch indents in notes box
 *
 ****************************************************************************/
VOID ShowBullets(VOID)
{
    PARAFORMAT pf;
    ZeroMemory(&pf, sizeof(pf));
    pf.cbSize = sizeof(pf);
    pf.dwMask = PFM_NUMBERING | PFM_OFFSET;
    pf.wNumbering = PFN_BULLET;
    pf.dxOffset = 1440 / 4; // a twip is 1440th of an inch, I want a 1/4-inch indent
    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES), EM_SETPARAFORMAT, 0, (LPARAM)&pf);
}


/****************************************************************************
 *
 *  HideBullets
 *
 ****************************************************************************/
VOID HideBullets(VOID)
{
    PARAFORMAT pf;
    ZeroMemory(&pf, sizeof(pf));
    pf.cbSize = sizeof(pf);
    pf.dwMask = PFM_NUMBERING;
    pf.wNumbering = 0;
    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES), EM_SETPARAFORMAT, 0, (LPARAM)&pf);
}


/****************************************************************************
 *
 *  SetupDxFilesPage
 *
 ****************************************************************************/
HRESULT SetupDxFilesPage(VOID)
{
    HRESULT hr;
    HWND hwndList = GetDlgItem(s_hwndCurPage, IDC_LIST);

    ListView_SetImageList(hwndList, s_himgList, LVSIL_STATE);

    if (FAILED(hr = (CreateFileInfoColumns(hwndList, FALSE))))
        return hr;

    ShowBullets();

    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES), 
        EM_REPLACESEL, FALSE, (LPARAM)s_sysInfo.m_szDXFileNotes);

    // Disable bullets so last line doesn't have an empty bullet
    HideBullets();

    if (FAILED(hr = (AddFileInfo(hwndList, s_pDxComponentsFileInfoFirst))))
        return hr;

    // Autosize all columns to fit header/text tightly:
    INT iColumn = 0;
    INT iWidthHeader;
    INT iWidthText;
    while (TRUE)
    {
        if (FALSE == ListView_SetColumnWidth(hwndList, iColumn, LVSCW_AUTOSIZE_USEHEADER))
            break;
        iWidthHeader = ListView_GetColumnWidth(hwndList, iColumn);
        ListView_SetColumnWidth(hwndList, iColumn, LVSCW_AUTOSIZE);
        iWidthText = ListView_GetColumnWidth(hwndList, iColumn);
        if (iWidthText < iWidthHeader)
            ListView_SetColumnWidth(hwndList, iColumn, iWidthHeader);
        iColumn++;
    }
    // Delete the bogus column that was created
    ListView_DeleteColumn(hwndList, iColumn - 1);

    return S_OK;
}


/****************************************************************************
 *
 *  SetupDisplayPage
 *
 ****************************************************************************/
HRESULT SetupDisplayPage(LONG iDisplay)
{
    DisplayInfo* pDisplayInfo;
    TCHAR sz[MAX_PATH];

    pDisplayInfo = s_pDisplayInfoFirst;
    while (iDisplay > 0)
    {
        pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext;
        iDisplay--;
    }
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_ADAPTER), pDisplayInfo->m_szDescription);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_MANUFACTURER), pDisplayInfo->m_szManufacturer);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_CHIPTYPE), pDisplayInfo->m_szChipType);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DACTYPE), pDisplayInfo->m_szDACType);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DISPLAYMEMORY), pDisplayInfo->m_szDisplayMemory);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DISPLAYMODE), pDisplayInfo->m_szDisplayMode);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_MONITOR), pDisplayInfo->m_szMonitorName);

    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DRIVERNAME), pDisplayInfo->m_szDriverName);
    wsprintf(sz, TEXT("%s (%s)"), pDisplayInfo->m_szDriverVersion, pDisplayInfo->m_szDriverLanguageLocal);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DRIVERVERSION), sz);
    if (pDisplayInfo->m_bDriverSignedValid)
    {
        if (pDisplayInfo->m_bDriverSigned)
            LoadString(NULL, IDS_YES, sz, MAX_PATH);
        else
            LoadString(NULL, IDS_NO, sz, MAX_PATH);
    }
    else
        LoadString(NULL, IDS_NA, sz, MAX_PATH);

    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DRIVERSIGNED), sz);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_MINIVDD), pDisplayInfo->m_szMiniVdd);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_VDD), pDisplayInfo->m_szVdd);

    // Diagnose display again since the state may have changed
    // ******* DiagnoseDisplay ********
    DiagnoseDisplay(&s_sysInfo, s_pDisplayInfoFirst);

    if (pDisplayInfo->m_bDDAccelerationEnabled)
    {
        if( pDisplayInfo->m_bNoHardware )
        {
            EnableWindow(GetDlgItem(s_hwndCurPage, IDC_DISABLEDD), FALSE);
        }
        else
        {
            EnableWindow(GetDlgItem(s_hwndCurPage, IDC_DISABLEDD), TRUE);
        }

        LoadString(NULL, IDS_DISABLEDD, sz, MAX_PATH);
        SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DISABLEDD), sz);
    }
    else
    {
        LoadString(NULL, IDS_ENABLEDD, sz, MAX_PATH);
        SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DISABLEDD), sz);
    }

    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DDSTATUS), pDisplayInfo->m_szDDStatus );

    EnableWindow(GetDlgItem(s_hwndCurPage, IDC_TESTDD), TRUE);
    EnableWindow(GetDlgItem(s_hwndCurPage, IDC_TESTD3D), TRUE);

    if (pDisplayInfo->m_b3DAccelerationExists)
    {
        EnableWindow(GetDlgItem(s_hwndCurPage, IDC_DISABLED3D), TRUE);
        if (pDisplayInfo->m_b3DAccelerationEnabled)
        {
            LoadString(NULL, IDS_DISABLED3D, sz, MAX_PATH);
            SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DISABLED3D), sz);
        }
        else
        {
            LoadString(NULL, IDS_ENABLED3D, sz, MAX_PATH);
            SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DISABLED3D), sz);
            EnableWindow(GetDlgItem(s_hwndCurPage, IDC_TESTD3D), FALSE);
        }
    }
    else
    {
        EnableWindow(GetDlgItem(s_hwndCurPage, IDC_DISABLED3D), FALSE);
        LoadString(NULL, IDS_DISABLED3D, sz, MAX_PATH);
        SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DISABLED3D), sz);
        EnableWindow(GetDlgItem(s_hwndCurPage, IDC_TESTD3D), FALSE);
    }

    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_D3DSTATUS), pDisplayInfo->m_szD3DStatus);

    // Set AGP button text to enabled or disabled
    if (pDisplayInfo->m_bAGPEnabled)
        LoadString(NULL, IDS_DISABLEAGP, sz, MAX_PATH);
    else
        LoadString(NULL, IDS_ENABLEAGP, sz, MAX_PATH);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DISABLEAGP), sz);

    // If we are sure that AGP support doesn't exist, show "not avail" for 
    // status, and disable button
    if ( (pDisplayInfo->m_bAGPExistenceValid && !pDisplayInfo->m_bAGPExists) ||
         (!pDisplayInfo->m_bDDAccelerationEnabled) )
    {
        EnableWindow(GetDlgItem(s_hwndCurPage, IDC_DISABLEAGP), FALSE);
    }
    else
    {
        // Otherwise, Show enabled/disabled status and enable button
        EnableWindow(GetDlgItem(s_hwndCurPage, IDC_DISABLEAGP), TRUE);
    }

    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_AGPSTATUS), pDisplayInfo->m_szAGPStatus);

    // Setup notes area.  Clear all text
    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES), EM_SETSEL, 0, -1);
    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES),
        EM_REPLACESEL, FALSE, (LPARAM)"");

    ShowBullets();

    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES),
                EM_REPLACESEL, FALSE, (LPARAM)pDisplayInfo->m_szNotes);

    // Disable bullets so last line doesn't have an empty bullet
    HideBullets();

    return S_OK;
}


/****************************************************************************
 *
 *  SetupSoundPage
 *
 ****************************************************************************/
HRESULT SetupSoundPage(LONG iSound)
{
    SoundInfo* pSoundInfo;
    TCHAR sz[MAX_PATH];

    if( s_pSoundInfoFirst == NULL )
        return S_OK;

    pSoundInfo = s_pSoundInfoFirst;
    while (iSound > 0)
    {
        pSoundInfo = pSoundInfo->m_pSoundInfoNext;
        iSound--;
    }
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DESCRIPTION), pSoundInfo->m_szDescription);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DRIVERNAME), pSoundInfo->m_szDriverName);
    if (lstrlen(pSoundInfo->m_szDriverName) > 0)
        wsprintf(sz, TEXT("%s (%s)"), pSoundInfo->m_szDriverVersion, pSoundInfo->m_szDriverLanguageLocal);
    else
        lstrcpy(sz, TEXT(""));
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DRIVERVERSION), sz);

    if (lstrlen(pSoundInfo->m_szDriverName) > 0)
    {
        if (pSoundInfo->m_bDriverSignedValid)
        {
            if (pSoundInfo->m_bDriverSigned)
                LoadString(NULL, IDS_YES, sz, MAX_PATH);
            else
                LoadString(NULL, IDS_NO, sz, MAX_PATH);
        }
        else
            LoadString(NULL, IDS_NA, sz, MAX_PATH);
    }
    else
        lstrcpy(sz, TEXT(""));
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DRIVERSIGNED), sz);

    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DEVICETYPE), pSoundInfo->m_szType);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DEVICEID), pSoundInfo->m_szDeviceID);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_MANUFACTURERID), pSoundInfo->m_szManufacturerID);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_PRODUCTID), pSoundInfo->m_szProductID);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_OTHERFILES), pSoundInfo->m_szOtherDrivers);
    SetWindowText(GetDlgItem(s_hwndCurPage, IDC_PROVIDER), pSoundInfo->m_szProvider);

    if (pSoundInfo->m_lwAccelerationLevel == -1)
    {
        // Acceleration level cannot be read, so hide controls
        ShowWindow(GetDlgItem(s_hwndCurPage, IDC_SNDACCELLABEL), SW_HIDE);
        ShowWindow(GetDlgItem(s_hwndCurPage, IDC_SNDACCELDESC), SW_HIDE);
        ShowWindow(GetDlgItem(s_hwndCurPage, IDC_SNDACCELSLIDER), SW_HIDE);
    }
    else
    {
        // Acceleration level can be read, so set up controls 
        HWND hwndSlider = GetDlgItem(s_hwndCurPage, IDC_SNDACCELSLIDER);
        SendMessage(hwndSlider, TBM_SETRANGE, TRUE, MAKELONG(0, 3));
        SendMessage(hwndSlider, TBM_SETTICFREQ, 1, 0);
        SendMessage(hwndSlider, TBM_SETPOS, TRUE, pSoundInfo->m_lwAccelerationLevel);
        switch (pSoundInfo->m_lwAccelerationLevel)
        {
        case 0:
            LoadString(NULL, IDS_NOSNDACCELERATION, sz, MAX_PATH);
            break;
        case 1:
            LoadString(NULL, IDS_BASICSNDACCELERATION, sz, MAX_PATH);
            break;
        case 2:
            LoadString(NULL, IDS_STANDARDSNDACCELERATION, sz, MAX_PATH);
            break;
        case 3:
            LoadString(NULL, IDS_FULLSNDACCELERATION, sz, MAX_PATH);
            break;
        default:
            lstrcpy(sz, TEXT(""));
            break;
        }
        SetWindowText(GetDlgItem(s_hwndCurPage, IDC_SNDACCELDESC), sz);
    }

    // Diagnose sound again since the state may have changed
    DiagnoseSound(s_pSoundInfoFirst);

    ShowBullets();
    
    // Setup notes area.  Clear all text
    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES), EM_SETSEL, 0, -1);
    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES),
        EM_REPLACESEL, FALSE, (LPARAM)"");

    ShowBullets();

    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES),
                EM_REPLACESEL, FALSE, (LPARAM)pSoundInfo->m_szNotes);
    
    // Disable bullets so last line doesn't have an empty bullet
    HideBullets();

    return S_OK;
}


/****************************************************************************
 *
 *  SetupMusicPage
 *
 ****************************************************************************/
HRESULT SetupMusicPage(VOID)
{
    HRESULT hr;
    HWND hwndList = GetDlgItem(s_hwndCurPage, IDC_LIST);
    TCHAR sz[MAX_PATH];

    // Set up HW enable/disable text/button:
    if (s_pMusicInfo->m_bAccelerationExists)
    {
        EnableWindow(GetDlgItem(s_hwndCurPage, IDC_DISABLEDM), TRUE);
        if (s_pMusicInfo->m_bAccelerationEnabled)
        {
            LoadString(NULL, IDS_ACCELENABLED, sz, MAX_PATH);
            SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DMSTATUS), sz);
            LoadString(NULL, IDS_DISABLEDM, sz, MAX_PATH);
            SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DISABLEDM), sz);
        }
        else
        {
            LoadString(NULL, IDS_ACCELDISABLED, sz, MAX_PATH);
            SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DMSTATUS), sz);
            LoadString(NULL, IDS_ENABLEDM, sz, MAX_PATH);
            SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DISABLEDM), sz);
        }
    }
    else
    {
        LoadString(NULL, IDS_ACCELUNAVAIL, sz, MAX_PATH);
        SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DMSTATUS), sz);
        EnableWindow(GetDlgItem(s_hwndCurPage, IDC_DISABLEDM), FALSE);
        LoadString(NULL, IDS_DISABLEDM, sz, MAX_PATH);
        SetWindowText(GetDlgItem(s_hwndCurPage, IDC_DISABLEDM), sz);
    }

    // Setup notes area.  Clear all text
    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES), EM_SETSEL, 0, -1);
    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES),
        EM_REPLACESEL, FALSE, (LPARAM)"");

    // ******* DiagnoseMusic ********
    DiagnoseMusic(&s_sysInfo, s_pMusicInfo);

    ShowBullets();

    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES),
                EM_REPLACESEL, FALSE, (LPARAM)s_sysInfo.m_szMusicNotes);

    // Disable bullets so last line doesn't have an empty bullet
    HideBullets();

    // If column 1 doesn't exist yet, create columns, fill in port info, etc.
    LVCOLUMN lv;
    ZeroMemory(&lv, sizeof(lv));
    lv.mask = LVCF_WIDTH;
    if (FALSE == ListView_GetColumn(hwndList, 1, &lv))
    {
        // Show GM path and version
        if (s_pMusicInfo != NULL)
        {
            if (lstrlen(s_pMusicInfo->m_szGMFileVersion) > 0)
            {
                TCHAR szFmt[MAX_PATH];
                LoadString(NULL, IDS_GMFILEFMT, szFmt, MAX_PATH);
                wsprintf(sz, szFmt, s_pMusicInfo->m_szGMFilePath,
                    s_pMusicInfo->m_szGMFileVersion);
            }
            else
            {
                lstrcpy(sz, s_pMusicInfo->m_szGMFilePath);
            }
            SetWindowText(GetDlgItem(s_hwndCurPage, IDC_GMPATH), sz);
        }

        ListView_SetImageList(hwndList, s_himgList, LVSIL_STATE);

        if (FAILED(hr = (CreateMusicColumns(hwndList))))
            return hr;

        ListView_DeleteAllItems( hwndList );
        if (FAILED(hr = (AddMusicPortInfo(hwndList, s_pMusicInfo))))
            return hr;

        // Autosize all columns to fit header/text tightly:
        INT iColumn = 0;
        INT iWidthHeader;
        INT iWidthText;
        while (TRUE)
        {
            if (FALSE == ListView_SetColumnWidth(hwndList, iColumn, LVSCW_AUTOSIZE_USEHEADER))
                break;
            iWidthHeader = ListView_GetColumnWidth(hwndList, iColumn);
            ListView_SetColumnWidth(hwndList, iColumn, LVSCW_AUTOSIZE);
            iWidthText = ListView_GetColumnWidth(hwndList, iColumn);
            if (iWidthText < iWidthHeader)
                ListView_SetColumnWidth(hwndList, iColumn, iWidthHeader);
            iColumn++;
        }
        // Delete the bogus column that was created
        ListView_DeleteColumn(hwndList, iColumn - 1);

        // Fill in output port combo list:
        MusicPort* pMusicPort;
        LONG iPort = 0;
        LONG iPortTestCur = 0;
        SendMessage(GetDlgItem(s_hwndCurPage, IDC_PORTLISTCOMBO), CB_RESETCONTENT, 0, 0);
        for (pMusicPort = s_pMusicInfo->m_pMusicPortFirst; pMusicPort != NULL;
            pMusicPort = pMusicPort->m_pMusicPortNext)
        {
            if (pMusicPort->m_bOutputPort)
            {
                SendMessage(GetDlgItem(s_hwndCurPage, IDC_PORTLISTCOMBO), CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)pMusicPort->m_szDescription);
                if (pMusicPort->m_guid == s_pMusicInfo->m_guidMusicPortTest)
                    iPortTestCur = iPort;
                iPort++;
            }
        }
        SendMessage(GetDlgItem(s_hwndCurPage, IDC_PORTLISTCOMBO), CB_SETCURSEL, iPortTestCur, 0);
    }

    return S_OK;
}


/****************************************************************************
 *
 *  SetupInputPage
 *
 ****************************************************************************/
HRESULT SetupInputPage(VOID)
{
    HRESULT hr;
    TCHAR sz[MAX_PATH];

    // Setup notes area.  Clear all text
    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES), EM_SETSEL, 0, -1);
    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES),
        EM_REPLACESEL, FALSE, (LPARAM)"");

    ShowBullets();

    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES),
                EM_REPLACESEL, FALSE, (LPARAM)s_sysInfo.m_szInputNotes);

    // Disable bullets so last line doesn't have an empty bullet
    HideBullets();


    if (BIsPlatformNT())
    {
        if (FAILED(hr = SetupInputDevicesNT()))
            return hr;
    }
    else
    {
        if (FAILED(hr = SetupInputDevices9x()))
            return hr;
    }

    // Second list: drivers
    HWND hwndList;
    LV_COLUMN col;
    LONG iSubItem = 0;
    LV_ITEM item;
    InputDriverInfo* pInputDriverInfo;
    hwndList = GetDlgItem(s_hwndCurPage, IDC_DRIVERLIST);
    ListView_SetImageList(hwndList, s_himgList, LVSIL_STATE);
    iSubItem = 0;
    col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    col.fmt = LVCFMT_LEFT;
    col.cx = 100;
    LoadString(NULL, IDS_REGISTRYKEY, sz, MAX_PATH);
    col.pszText = sz;
    col.cchTextMax = 100;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_ACTIVE, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_DEVICEID, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_MATCHINGDEVID, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_DRIVER16, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_DRIVER32, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    // Add a bogus column so SetColumnWidth doesn't do strange 
    // things with the last real column
    col.fmt = LVCFMT_RIGHT;
    col.pszText = TEXT("");
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    if( s_pInputInfo == NULL )
        return S_OK;

    for (pInputDriverInfo = s_pInputInfo->m_pInputDriverInfoFirst; pInputDriverInfo != NULL; 
        pInputDriverInfo = pInputDriverInfo->m_pInputDriverInfoNext)
    {
        iSubItem = 0;

        item.mask = LVIF_TEXT | LVIF_STATE;
        item.iItem = ListView_GetItemCount(hwndList);
        item.stateMask = 0xffff;
        item.cchTextMax = 100;
        if (pInputDriverInfo->m_bProblem)
            item.state = (1 << 12);
        else
            item.state = 0;
        item.iSubItem = iSubItem++;
        item.pszText = pInputDriverInfo->m_szRegKey;
        if (-1 == ListView_InsertItem(hwndList, &item))
            return E_FAIL;

        item.mask = LVIF_TEXT;

        item.iSubItem = iSubItem++;
        if (pInputDriverInfo->m_bActive)
            LoadString(NULL, IDS_YES, sz, MAX_PATH);
        else
            LoadString(NULL, IDS_NO, sz, MAX_PATH);
        item.pszText = sz;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        item.pszText = pInputDriverInfo->m_szDeviceID;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        item.pszText = pInputDriverInfo->m_szMatchingDeviceID;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        item.pszText = pInputDriverInfo->m_szDriver16;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        item.pszText = pInputDriverInfo->m_szDriver32;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;
    }

    // Autosize all columns to fit header/text tightly:
    INT iColumn = 0;
    INT iWidthHeader;
    INT iWidthText;
    while (TRUE)
    {
        if (FALSE == ListView_SetColumnWidth(hwndList, iColumn, LVSCW_AUTOSIZE_USEHEADER))
            break;
        iWidthHeader = ListView_GetColumnWidth(hwndList, iColumn);
        ListView_SetColumnWidth(hwndList, iColumn, LVSCW_AUTOSIZE);
        iWidthText = ListView_GetColumnWidth(hwndList, iColumn);
        if (iWidthText < iWidthHeader)
            ListView_SetColumnWidth(hwndList, iColumn, iWidthHeader);
        iColumn++;
    }
    // Delete the bogus column that was created
    ListView_DeleteColumn(hwndList, iColumn - 1);

    return S_OK;
}


/****************************************************************************
 *
 *  SetupInputDevices9x
 *
 ****************************************************************************/
HRESULT SetupInputDevices9x(VOID)
{
    HWND hwndList = GetDlgItem(s_hwndCurPage, IDC_LIST);
    LV_COLUMN col;
    LONG iSubItem = 0;
    LV_ITEM item;
    InputDeviceInfo* pInputDeviceInfo;
    TCHAR sz[MAX_PATH];

    ListView_SetImageList(hwndList, s_himgList, LVSIL_STATE);
    col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    col.fmt = LVCFMT_LEFT;
    col.cx = 100;
    LoadString(NULL, IDS_DEVICENAME, sz, MAX_PATH);
    col.pszText = sz;
    col.cchTextMax = 100;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_USAGE, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_DRIVERNAME, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_VERSION, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_ATTRIBUTES, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_SIGNED, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_LANGUAGE, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    col.fmt = LVCFMT_RIGHT;
    LoadString(NULL, IDS_DATE, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    col.fmt = LVCFMT_RIGHT;
    LoadString(NULL, IDS_SIZE, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    // Add a bogus column so SetColumnWidth doesn't do strange 
    // things with the last real column
    col.fmt = LVCFMT_RIGHT;
    col.pszText = TEXT("");
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    for (pInputDeviceInfo = s_pInputInfo->m_pInputDeviceInfoFirst; pInputDeviceInfo != NULL; 
        pInputDeviceInfo = pInputDeviceInfo->m_pInputDeviceInfoNext)
    {
        iSubItem = 0;

        item.mask = LVIF_TEXT | LVIF_STATE;
        item.iItem = ListView_GetItemCount(hwndList);
        item.stateMask = 0xffff;
        item.cchTextMax = 100;
        if (pInputDeviceInfo->m_bProblem)
            item.state = (1 << 12);
        else
            item.state = 0;
        item.iSubItem = iSubItem++;
        item.pszText = pInputDeviceInfo->m_szDeviceName;
        if (-1 == ListView_InsertItem(hwndList, &item))
            return E_FAIL;

        item.mask = LVIF_TEXT;

        item.iSubItem = iSubItem++;
        item.pszText = pInputDeviceInfo->m_szSettings;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        item.pszText = pInputDeviceInfo->m_szDriverName;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        item.pszText = pInputDeviceInfo->m_szDriverVersion;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        item.pszText = pInputDeviceInfo->m_szDriverAttributes;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        if (pInputDeviceInfo->m_bDriverSignedValid)
        {
            if (pInputDeviceInfo->m_bDriverSigned)
                LoadString(NULL, IDS_YES, sz, MAX_PATH);
            else
                LoadString(NULL, IDS_NO, sz, MAX_PATH);
        }
        else
            LoadString(NULL, IDS_NA, sz, MAX_PATH);

        item.pszText = sz;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        item.pszText = pInputDeviceInfo->m_szDriverLanguageLocal;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        item.pszText = pInputDeviceInfo->m_szDriverDateLocal;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        wsprintf(sz, TEXT("%d"), pInputDeviceInfo->m_numBytes);
        item.pszText = sz;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;
    }

    // Autosize all columns to fit header/text tightly:
    INT iColumn = 0;
    INT iWidthHeader;
    INT iWidthText;
    while (TRUE)
    {
        if (FALSE == ListView_SetColumnWidth(hwndList, iColumn, LVSCW_AUTOSIZE_USEHEADER))
            break;
        iWidthHeader = ListView_GetColumnWidth(hwndList, iColumn);
        ListView_SetColumnWidth(hwndList, iColumn, LVSCW_AUTOSIZE);
        iWidthText = ListView_GetColumnWidth(hwndList, iColumn);
        if (iWidthText < iWidthHeader)
            ListView_SetColumnWidth(hwndList, iColumn, iWidthHeader);
        iColumn++;
    }
    // Delete the bogus column that was created
    ListView_DeleteColumn(hwndList, iColumn - 1);
    return S_OK;
}


/****************************************************************************
 *
 *  SetupInputDevicesNT
 *
 ****************************************************************************/
HRESULT SetupInputDevicesNT(VOID)
{
    HWND hwndList = GetDlgItem(s_hwndCurPage, IDC_LIST);
    LV_COLUMN col;
    LONG iSubItem = 0;
    LV_ITEM item;
    InputDeviceInfoNT* pInputDeviceInfoNT;
    TCHAR sz[MAX_PATH];

    ListView_SetImageList(hwndList, s_himgList, LVSIL_STATE);
    col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    col.fmt = LVCFMT_LEFT;
    col.cx = 100;
    LoadString(NULL, IDS_DEVICENAME, sz, MAX_PATH);
    col.pszText = sz;
    col.cchTextMax = 100;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_PROVIDER, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_DEVICEID, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_STATUS, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_PORTNAME, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_PORTPROVIDER, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_PORTID, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_PORTSTATUS, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    // Add a bogus column so SetColumnWidth doesn't do strange 
    // things with the last real column
    col.fmt = LVCFMT_RIGHT;
    col.pszText = TEXT("");
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    if( s_pInputInfo == NULL )
        return S_OK;

    for (pInputDeviceInfoNT = s_pInputInfo->m_pInputDeviceInfoNTFirst; pInputDeviceInfoNT != NULL; 
        pInputDeviceInfoNT = pInputDeviceInfoNT->m_pInputDeviceInfoNTNext)
    {
        iSubItem = 0;

        item.mask = LVIF_TEXT | LVIF_STATE;
        item.iItem = ListView_GetItemCount(hwndList);
        item.stateMask = 0xffff;
        item.cchTextMax = 100;
        if (pInputDeviceInfoNT->m_bProblem)
            item.state = (1 << 12);
        else
            item.state = 0;
        item.iSubItem = iSubItem++;
        item.pszText = pInputDeviceInfoNT->m_szName;
        if (-1 == ListView_InsertItem(hwndList, &item))
            return E_FAIL;

        item.mask = LVIF_TEXT;

        item.iSubItem = iSubItem++;
        item.pszText = pInputDeviceInfoNT->m_szProvider;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        item.pszText = pInputDeviceInfoNT->m_szId;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        wsprintf(sz, TEXT("0x%x, 0x%x"), pInputDeviceInfoNT->m_dwStatus, pInputDeviceInfoNT->m_dwProblem);
        item.iSubItem = iSubItem++;
        item.pszText = sz;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        item.pszText = pInputDeviceInfoNT->m_szPortName;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        item.pszText = pInputDeviceInfoNT->m_szPortProvider;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        item.pszText = pInputDeviceInfoNT->m_szPortId;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        wsprintf(sz, TEXT("0x%x, 0x%x"), pInputDeviceInfoNT->m_dwPortStatus, pInputDeviceInfoNT->m_dwPortProblem);
        item.iSubItem = iSubItem++;
        item.pszText = sz;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

    }

    // Autosize all columns to fit header/text tightly:
    INT iColumn = 0;
    INT iWidthHeader;
    INT iWidthText;
    while (TRUE)
    {
        if (FALSE == ListView_SetColumnWidth(hwndList, iColumn, LVSCW_AUTOSIZE_USEHEADER))
            break;
        iWidthHeader = ListView_GetColumnWidth(hwndList, iColumn);
        ListView_SetColumnWidth(hwndList, iColumn, LVSCW_AUTOSIZE);
        iWidthText = ListView_GetColumnWidth(hwndList, iColumn);
        if (iWidthText < iWidthHeader)
            ListView_SetColumnWidth(hwndList, iColumn, iWidthHeader);
        iColumn++;
    }
    // Delete the bogus column that was created
    ListView_DeleteColumn(hwndList, iColumn - 1);
    return S_OK;
}


/****************************************************************************
 *
 *  SetupNetworkPage
 *
 ****************************************************************************/
HRESULT SetupNetworkPage(VOID)
{
    TCHAR sz[MAX_PATH];

    // Diagnose net info again since the state may have changed
    // ******* DiagnoseNetInfo ********
    DiagnoseNetInfo(&s_sysInfo, s_pNetInfo);

    // Setup notes area.  Clear all text
    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES), EM_SETSEL, 0, -1);
    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES),
        EM_REPLACESEL, FALSE, (LPARAM)"");

    ShowBullets();

    SendMessage(GetDlgItem(s_hwndCurPage, IDC_NOTES), 
        EM_REPLACESEL, FALSE, (LPARAM)s_sysInfo.m_szNetworkNotes);

    // Disable bullets so last line doesn't have an empty bullet
    HideBullets();

    if( s_pNetInfo == NULL )
        return S_OK;

    // If column 1 doesn't exist yet, create columns, fill in port info, etc.
    HWND hwndList = GetDlgItem(s_hwndCurPage, IDC_DPSPLIST);
    LVCOLUMN lv;
    ZeroMemory(&lv, sizeof(lv));
    lv.mask = LVCF_WIDTH;
    if (FALSE == ListView_GetColumn(hwndList, 1, &lv))
    {
        // Set up service provider list 
        LV_COLUMN col;
        LONG iSubItem = 0;
        LV_ITEM item;
        NetSP* pNetSP;
        NetApp* pNetApp;

        // First list: service providers
        ListView_SetImageList(hwndList, s_himgList, LVSIL_STATE);
        col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        col.fmt = LVCFMT_LEFT;
        col.cx = 100;
        LoadString(NULL, IDS_NAME, sz, MAX_PATH);
        col.pszText = sz;
        col.cchTextMax = 100;
        col.iSubItem = iSubItem;
        if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
            return E_FAIL;
        iSubItem++;

        LoadString(NULL, IDS_REGISTRY, sz, MAX_PATH);
        col.pszText = sz;
        col.iSubItem = iSubItem;
        if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
            return E_FAIL;
        iSubItem++;

        LoadString(NULL, IDS_FILE, sz, MAX_PATH);
        col.pszText = sz;
        col.iSubItem = iSubItem;
        if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
            return E_FAIL;
        iSubItem++;

        LoadString(NULL, IDS_VERSION, sz, MAX_PATH);
        col.pszText = sz;
        col.iSubItem = iSubItem;
        if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
            return E_FAIL;
        iSubItem++;

        // Add a bogus column so SetColumnWidth doesn't do strange 
        // things with the last real column
        col.fmt = LVCFMT_RIGHT;
        col.pszText = TEXT("");
        col.iSubItem = iSubItem;
        if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
            return E_FAIL;
        iSubItem++;

        for (pNetSP = s_pNetInfo->m_pNetSPFirst; pNetSP != NULL; 
            pNetSP = pNetSP->m_pNetSPNext)
        {
            iSubItem = 0;

            item.mask = LVIF_TEXT | LVIF_STATE;
            item.iItem = ListView_GetItemCount(hwndList);
            item.stateMask = 0xffff;
            item.cchTextMax = 100;
            if (pNetSP->m_bProblem)
                item.state = (1 << 12);
            else
                item.state = 0;
            item.iSubItem = iSubItem++;
            item.pszText = pNetSP->m_szName;
            if (-1 == ListView_InsertItem(hwndList, &item))
                return E_FAIL;

            item.mask = LVIF_TEXT;

            item.iSubItem = iSubItem++;
            if (pNetSP->m_bRegistryOK)
                LoadString(NULL, IDS_OK, sz, MAX_PATH);
            else
                LoadString(NULL, IDS_ERROR, sz, MAX_PATH);
            item.pszText = sz;
            if (FALSE == ListView_SetItem(hwndList, &item))
                return E_FAIL;

            item.iSubItem = iSubItem++;
            item.pszText = pNetSP->m_szFile;
            if (FALSE == ListView_SetItem(hwndList, &item))
                return E_FAIL;

            item.iSubItem = iSubItem++;
            item.pszText = pNetSP->m_szVersion;
            if (FALSE == ListView_SetItem(hwndList, &item))
                return E_FAIL;
        }

        // Autosize all columns to fit header/text tightly:
        INT iColumn = 0;
        INT iWidthHeader;
        INT iWidthText;
        while (TRUE)
        {
            if (FALSE == ListView_SetColumnWidth(hwndList, iColumn, LVSCW_AUTOSIZE_USEHEADER))
                break;
            iWidthHeader = ListView_GetColumnWidth(hwndList, iColumn);
            ListView_SetColumnWidth(hwndList, iColumn, LVSCW_AUTOSIZE);
            iWidthText = ListView_GetColumnWidth(hwndList, iColumn);
            if (iWidthText < iWidthHeader)
                ListView_SetColumnWidth(hwndList, iColumn, iWidthHeader);
            iColumn++;
        }
        // Delete the bogus column that was created
        ListView_DeleteColumn(hwndList, iColumn - 1);


        // Second list: lobbyable apps
        hwndList = GetDlgItem(s_hwndCurPage, IDC_DPALIST);
        ListView_SetImageList(hwndList, s_himgList, LVSIL_STATE);
        iSubItem = 0;
        col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        col.fmt = LVCFMT_LEFT;
        col.cx = 100;
        LoadString(NULL, IDS_NAME, sz, MAX_PATH);
        col.pszText = sz;
        col.cchTextMax = 100;
        col.iSubItem = iSubItem;
        if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
            return E_FAIL;
        iSubItem++;

        LoadString(NULL, IDS_REGISTRY, sz, MAX_PATH);
        col.pszText = sz;
        col.iSubItem = iSubItem;
        if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
            return E_FAIL;
        iSubItem++;

        LoadString(NULL, IDS_FILE, sz, MAX_PATH);
        col.pszText = sz;
        col.iSubItem = iSubItem;
        if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
            return E_FAIL;
        iSubItem++;

        LoadString(NULL, IDS_VERSION, sz, MAX_PATH);
        col.pszText = sz;
        col.iSubItem = iSubItem;
        if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
            return E_FAIL;
        iSubItem++;

        LoadString(NULL, IDS_GUID, sz, MAX_PATH);
        col.pszText = sz;
        col.iSubItem = iSubItem;
        if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
            return E_FAIL;
        iSubItem++;

        // Add a bogus column so SetColumnWidth doesn't do strange 
        // things with the last real column
        col.fmt = LVCFMT_RIGHT;
        col.pszText = TEXT("");
        col.iSubItem = iSubItem;
        if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
            return E_FAIL;
        iSubItem++;

        for (pNetApp = s_pNetInfo->m_pNetAppFirst; pNetApp != NULL;
            pNetApp = pNetApp->m_pNetAppNext)
        {
            iSubItem = 0;

            item.mask = LVIF_TEXT | LVIF_STATE;
            item.iItem = ListView_GetItemCount(hwndList);
            item.stateMask = 0xffff;
            item.cchTextMax = 100;
            if (pNetApp->m_bProblem)
                item.state = (1 << 12);
            else
                item.state = 0;
            item.iSubItem = iSubItem++;
            item.pszText = pNetApp->m_szName;
            if (-1 == ListView_InsertItem(hwndList, &item))
                return E_FAIL;

            item.mask = LVIF_TEXT;

            item.iSubItem = iSubItem++;
            if (pNetApp->m_bRegistryOK)
                LoadString(NULL, IDS_OK, sz, MAX_PATH);
            else
                LoadString(NULL, IDS_ERROR, sz, MAX_PATH);
            item.pszText = sz;
            if (FALSE == ListView_SetItem(hwndList, &item))
                return E_FAIL;

            item.iSubItem = iSubItem++;
            item.pszText = pNetApp->m_szExeFile;
            if (FALSE == ListView_SetItem(hwndList, &item))
                return E_FAIL;

            item.iSubItem = iSubItem++;
            item.pszText = pNetApp->m_szExeVersion;
            if (FALSE == ListView_SetItem(hwndList, &item))
                return E_FAIL;

            item.iSubItem = iSubItem++;
            item.pszText = pNetApp->m_szGuid;
            if (FALSE == ListView_SetItem(hwndList, &item))
                return E_FAIL;
        }

        // Autosize all columns to fit header/text tightly:
        iColumn = 0;
        iWidthHeader;
        iWidthText;
        while (TRUE)
        {
            if (FALSE == ListView_SetColumnWidth(hwndList, iColumn, LVSCW_AUTOSIZE_USEHEADER))
                break;
            iWidthHeader = ListView_GetColumnWidth(hwndList, iColumn);
            ListView_SetColumnWidth(hwndList, iColumn, LVSCW_AUTOSIZE);
            iWidthText = ListView_GetColumnWidth(hwndList, iColumn);
            if (iWidthText < iWidthHeader)
                ListView_SetColumnWidth(hwndList, iColumn, iWidthHeader);
            iColumn++;
        }
        // Delete the bogus column that was created
        ListView_DeleteColumn(hwndList, iColumn - 1);
    }

    return S_OK;
}


/****************************************************************************
 *
 *  SetupStillStuckPage
 *
 ****************************************************************************/
HRESULT SetupStillStuckPage(VOID)
{
    EnableWindow(GetDlgItem(s_hwndCurPage, IDC_TROUBLESHOOT), FALSE );
    EnableWindow(GetDlgItem(s_hwndCurPage, IDC_TROUBLESHOOTSOUND), FALSE );
    EnableWindow(GetDlgItem(s_hwndCurPage, IDC_MSINFO), FALSE );
    EnableWindow(GetDlgItem(s_hwndCurPage, IDC_RESTOREDRIVERS), FALSE );
    EnableWindow(GetDlgItem(s_hwndCurPage, IDC_REPORTBUG), FALSE );
    EnableWindow(GetDlgItem(s_hwndCurPage, IDC_GHOST), FALSE );

    // Hide "Troubleshooter" text/button if help file not found
    BOOL bFound;
    TCHAR szHelpPath[MAX_PATH];
    TCHAR szHelpLeaf[MAX_PATH];
    TCHAR szTroubleshooter[MAX_PATH];
    GetWindowsDirectory(szHelpPath, MAX_PATH);
    LoadString(NULL, IDS_HELPDIRLEAF, szHelpLeaf, MAX_PATH);
    lstrcat(szHelpPath, szHelpLeaf);

    if( BIsWin98() || BIsWin95() )
        LoadString(NULL, IDS_TROUBLESHOOTER_WIN98SE, szTroubleshooter, MAX_PATH);
    else if( BIsWinME() )
        LoadString(NULL, IDS_TROUBLESHOOTER_WINME, szTroubleshooter, MAX_PATH);
    else if( BIsWin2k() || BIsWhistler() )
        LoadString(NULL, IDS_TROUBLESHOOTER_WIN2K, szTroubleshooter, MAX_PATH);

    bFound = FALSE;
    lstrcat(szHelpPath, TEXT("\\"));
    lstrcat(szHelpPath, szTroubleshooter);
    if (GetFileAttributes(szHelpPath) != 0xffffffff)
    {
        bFound = TRUE;
    }
    else if( BIsWin98() || BIsWin95() )
    {
        GetWindowsDirectory(szHelpPath, MAX_PATH);
        LoadString(NULL, IDS_HELPDIRLEAF, szHelpLeaf, MAX_PATH);
        lstrcat(szHelpPath, szHelpLeaf);
        lstrcat(szHelpPath, TEXT("\\"));
        LoadString(NULL, IDS_TROUBLESHOOTER_WIN98, szTroubleshooter, MAX_PATH);
        lstrcat(szHelpPath, szTroubleshooter);

        if (GetFileAttributes(szHelpPath) != 0xffffffff)
            bFound = TRUE;
    }

    if( bFound )
    {
        ShowWindow(GetDlgItem(s_hwndCurPage, IDC_TROUBLESHOOT), SW_SHOW);
        EnableWindow(GetDlgItem(s_hwndCurPage, IDC_TROUBLESHOOT), TRUE);
        ShowWindow(GetDlgItem(s_hwndCurPage, IDC_TROUBLESHOOTTEXT), SW_SHOW);
    }

    // Hide "Sound Troubleshooter" text/button if help file not found
    GetWindowsDirectory(szHelpPath, MAX_PATH);
    LoadString(NULL, IDS_HELPDIRLEAF, szHelpLeaf, MAX_PATH);
    lstrcat(szHelpPath, szHelpLeaf);

    if( BIsWin98() || BIsWin95() )
        LoadString(NULL, IDS_TROUBLESHOOTER_WIN98SE, szTroubleshooter, MAX_PATH);
    else if( BIsWinME() )
        LoadString(NULL, IDS_TROUBLESHOOTER_WINME, szTroubleshooter, MAX_PATH);
    else if( BIsWin2k() || BIsWhistler() )
        LoadString(NULL, IDS_TROUBLESHOOTER_WIN2K, szTroubleshooter, MAX_PATH);

    bFound = FALSE;
    lstrcat(szHelpPath, TEXT("\\"));
    lstrcat(szHelpPath, szTroubleshooter);
    if (GetFileAttributes(szHelpPath) != 0xffffffff)
    {
        bFound = TRUE;
    }
    else if( BIsWin98() || BIsWin95() )
    {
        GetWindowsDirectory(szHelpPath, MAX_PATH);
        LoadString(NULL, IDS_HELPDIRLEAF, szHelpLeaf, MAX_PATH);
        lstrcat(szHelpPath, szHelpLeaf);
        lstrcat(szHelpPath, TEXT("\\"));
        LoadString(NULL, IDS_SOUNDTROUBLESHOOTER_WIN98, szTroubleshooter, MAX_PATH);
        lstrcat(szHelpPath, szTroubleshooter);

        if (GetFileAttributes(szHelpPath) != 0xffffffff)
            bFound = TRUE;
    }

    if( bFound )
    {
        ShowWindow(GetDlgItem(s_hwndCurPage, IDC_TROUBLESHOOTSOUND), SW_SHOW);
        EnableWindow(GetDlgItem(s_hwndCurPage, IDC_TROUBLESHOOTSOUND), TRUE);
        ShowWindow(GetDlgItem(s_hwndCurPage, IDC_TROUBLESHOOTSOUNDTEXT), SW_SHOW);
    }

    // Hide "MSInfo" text/button if msinfo32.exe not found
    HKEY hkey;
    TCHAR szMsInfo[MAX_PATH];
    DWORD cbData = MAX_PATH;
    DWORD dwType;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        TEXT("Software\\Microsoft\\Shared Tools\\MSInfo"), 0, KEY_READ, &hkey))
    {
        RegQueryValueEx(hkey, TEXT("Path"), 0, &dwType, (LPBYTE)szMsInfo, &cbData);
        if (GetFileAttributes(szMsInfo) != 0xffffffff)
        {
            ShowWindow(GetDlgItem(s_hwndCurPage, IDC_MSINFO), SW_SHOW);
            EnableWindow(GetDlgItem(s_hwndCurPage, IDC_MSINFO), TRUE);
            ShowWindow(GetDlgItem(s_hwndCurPage, IDC_MSINFOTEXT), SW_SHOW);
        }
        RegCloseKey(hkey);
    }

    // Hide "Restore" text/button if dxsetup.exe not found
    if (BCanRestoreDrivers())
    {
        ShowWindow(GetDlgItem(s_hwndCurPage, IDC_RESTOREDRIVERS), SW_SHOW);
        ShowWindow(GetDlgItem(s_hwndCurPage, IDC_RESTOREDRIVERSTEXT), SW_SHOW);
        EnableWindow(GetDlgItem(s_hwndCurPage, IDC_RESTOREDRIVERS), TRUE);
    }

    // Only show "Report" text/button if magic registry key is set
    BOOL bReport = FALSE;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        TEXT("Software\\Microsoft\\DirectX Diagnostic Tool"), 0, KEY_READ, &hkey))
    {
        cbData = sizeof(bReport);
        RegQueryValueEx(hkey, TEXT("Allow Bug Report"), 0, &dwType, (LPBYTE)&bReport, &cbData);
        if (bReport)
        {
            ShowWindow(GetDlgItem(s_hwndCurPage, IDC_REPORTBUG), SW_SHOW);
            EnableWindow(GetDlgItem(s_hwndCurPage, IDC_REPORTBUG), TRUE);
            ShowWindow(GetDlgItem(s_hwndCurPage, IDC_REPORTBUGTEXT), SW_SHOW);
        }
        RegCloseKey(hkey);
    }

    // Only show "Adjust Ghost Devices" text/button if s_bGhost is set and not NT
    if (s_bGhost && !BIsPlatformNT())
    {
        ShowWindow(GetDlgItem(s_hwndCurPage, IDC_GHOST), SW_SHOW);
        EnableWindow(GetDlgItem(s_hwndCurPage, IDC_GHOST), TRUE);
        ShowWindow(GetDlgItem(s_hwndCurPage, IDC_GHOSTTEXT), SW_SHOW);
    }

    return S_OK;
}


/****************************************************************************
 *
 *  CreateFileInfoColumns
 *
 ****************************************************************************/
HRESULT CreateFileInfoColumns(HWND hwndList, BOOL bDrivers)
{
    LV_COLUMN col;
    LONG iSubItem = 0;
    TCHAR sz[MAX_PATH];

    col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    col.fmt = LVCFMT_LEFT;
    col.cx = 100;
    LoadString(NULL, IDS_NAME, sz, MAX_PATH);
    col.pszText = sz;
    col.cchTextMax = 100;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_VERSION, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    if (bDrivers)
    {
        LoadString(NULL, IDS_SIGNED, sz, MAX_PATH);
        col.pszText = sz;
        col.iSubItem = iSubItem;
        if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
            return E_FAIL;
        iSubItem++;
    }
    else
    {
        LoadString(NULL, IDS_ATTRIBUTES, sz, MAX_PATH);
        col.pszText = sz;
        col.iSubItem = iSubItem;
        if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
            return E_FAIL;
        iSubItem++;
    }

    LoadString(NULL, IDS_LANGUAGE, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    col.fmt = LVCFMT_RIGHT;
    LoadString(NULL, IDS_DATE, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    col.fmt = LVCFMT_RIGHT;
    LoadString(NULL, IDS_SIZE, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    // Add a bogus column so SetColumnWidth doesn't do strange 
    // things with the last real column
    col.fmt = LVCFMT_RIGHT;
    col.pszText = TEXT("");
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    return S_OK;
}


/****************************************************************************
 *
 *  AddFileInfo
 *
 ****************************************************************************/
HRESULT AddFileInfo(HWND hwndList, FileInfo* pFileInfoFirst, BOOL bDrivers)
{
    FileInfo* pFileInfo;
    LV_ITEM item;
    LONG iSubItem;
    TCHAR sz[MAX_PATH];

    for (pFileInfo = pFileInfoFirst; pFileInfo != NULL; 
        pFileInfo = pFileInfo->m_pFileInfoNext)
    {
        // Don't list missing files unless they're a "problem"
        if (!pFileInfo->m_bExists && !pFileInfo->m_bProblem)
            continue;

        // manbugs 16765: don't list obsolete files
        if (pFileInfo->m_bObsolete)
            continue;

        iSubItem = 0;
        item.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
        item.iItem = ListView_GetItemCount(hwndList);
        item.stateMask = 0xffff;
        item.cchTextMax = 100;
        item.lParam = (LPARAM) pFileInfo;

        if (pFileInfo->m_bProblem)
            item.state = (1 << 12);
        else
            item.state = 0;

        item.iSubItem = iSubItem++;
        item.pszText = pFileInfo->m_szName;
        if (-1 == ListView_InsertItem(hwndList, &item))
            return E_FAIL;

        item.mask = LVIF_TEXT;

        item.iSubItem = iSubItem++;
        item.pszText = pFileInfo->m_szVersion;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        if (bDrivers)
        {
            item.iSubItem = iSubItem++;
            if (lstrcmpi(TEXT(".drv"), _tcsrchr(pFileInfo->m_szName, '.')) == 0)
            {
                if (pFileInfo->m_bSigned)
                    LoadString(NULL, IDS_YES, sz, MAX_PATH);
                else
                    LoadString(NULL, IDS_NO, sz, MAX_PATH);
            }
            else
            {
                LoadString(NULL, IDS_NA, sz, MAX_PATH);
            }
            item.pszText = sz;
            if (FALSE == ListView_SetItem(hwndList, &item))
                return E_FAIL;
        }
        else
        {
            item.iSubItem = iSubItem++;
            item.pszText = pFileInfo->m_szAttributes;
            if (FALSE == ListView_SetItem(hwndList, &item))
                return E_FAIL;
        }

        item.iSubItem = iSubItem++;
        item.pszText = pFileInfo->m_szLanguageLocal;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        item.pszText = pFileInfo->m_szDatestampLocal;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        wsprintf(sz, TEXT("%d"), pFileInfo->m_numBytes);
        item.pszText = sz;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;
    }
    return S_OK;
}


/****************************************************************************
 *
 *  CreateMusicColumns
 *
 ****************************************************************************/
HRESULT CreateMusicColumns(HWND hwndList)
{
    LV_COLUMN col;
    LONG iSubItem = 0;
    TCHAR sz[MAX_PATH];

    col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    col.fmt = LVCFMT_LEFT;
    col.cx = 100;
    LoadString(NULL, IDS_DESCRIPTION, sz, MAX_PATH);
    col.pszText = sz;
    col.cchTextMax = 100;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_TYPE, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_KERNELMODE, sz, MAX_PATH);
    col.fmt = LVCFMT_RIGHT;
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_INOUT, sz, MAX_PATH);
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_DLS, sz, MAX_PATH);
    col.fmt = LVCFMT_RIGHT;
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_EXTERNAL, sz, MAX_PATH);
    col.fmt = LVCFMT_RIGHT;
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    LoadString(NULL, IDS_DEFAULTPORT, sz, MAX_PATH);
    col.fmt = LVCFMT_RIGHT;
    col.pszText = sz;
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    // Add a bogus column so SetColumnWidth doesn't do strange 
    // things with the last real column
    col.fmt = LVCFMT_RIGHT;
    col.pszText = TEXT("");
    col.iSubItem = iSubItem;
    if (-1 == ListView_InsertColumn(hwndList, iSubItem, &col))
        return E_FAIL;
    iSubItem++;

    return S_OK;
}


/****************************************************************************
 *
 *  AddMusicPortInfo
 *
 ****************************************************************************/
HRESULT AddMusicPortInfo(HWND hwndList, MusicInfo* pMusicInfo)
{
    MusicPort* pMusicPort;
    LV_ITEM item;
    LONG iSubItem;
    TCHAR sz[MAX_PATH];

    for (pMusicPort = pMusicInfo->m_pMusicPortFirst; pMusicPort != NULL; 
        pMusicPort = pMusicPort->m_pMusicPortNext)
    {
        iSubItem = 0;
        item.mask = LVIF_TEXT | LVIF_STATE;
        item.iItem = ListView_GetItemCount(hwndList);
        item.stateMask = 0xffff;
        item.cchTextMax = 100;

/*      if (pMusicPortInfo->m_bProblem)
            item.state = (1 << 12);
        else
*/          item.state = 0;

        item.iSubItem = iSubItem++;
        item.pszText = pMusicPort->m_szDescription;
        if (-1 == ListView_InsertItem(hwndList, &item))
            return E_FAIL;

        item.mask = LVIF_TEXT;

        item.iSubItem = iSubItem++;
        LoadString(NULL, pMusicPort->m_bSoftware ? IDS_SOFTWARE : IDS_HARDWARE, sz, MAX_PATH);
        item.pszText = sz;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        LoadString(NULL, pMusicPort->m_bKernelMode ? IDS_YES : IDS_NO, sz, MAX_PATH);
        item.pszText = sz;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;
        
        item.iSubItem = iSubItem++;
        LoadString(NULL, pMusicPort->m_bOutputPort ? IDS_OUTPUT : IDS_INPUT, sz, MAX_PATH);
        item.pszText = sz;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;

        item.iSubItem = iSubItem++;
        LoadString(NULL, pMusicPort->m_bUsesDLS ? IDS_YES : IDS_NO, sz, MAX_PATH);
        item.pszText = sz;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;
        
        item.iSubItem = iSubItem++;
        LoadString(NULL, pMusicPort->m_bExternal ? IDS_YES : IDS_NO, sz, MAX_PATH);
        item.pszText = sz;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;
        
        item.iSubItem = iSubItem++;
        LoadString(NULL, pMusicPort->m_bDefaultPort ? IDS_YES : IDS_NO, sz, MAX_PATH);
        item.pszText = sz;
        if (FALSE == ListView_SetItem(hwndList, &item))
            return E_FAIL;
    }
    return S_OK;
}


/****************************************************************************
 *
 *  ScanSystem
 *
 ****************************************************************************/
HRESULT ScanSystem(VOID)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH];

    // ******* GetComponentFiles (SI:2) ********
    if( s_bUseSystemInfo )
    {
        s_bUseSystemInfo = QueryCrashProtection( DXD_IN_SI_KEY, DXD_IN_SI_VALUE, IDS_SI, 2 );
        if( s_bUseSystemInfo )
        {
            EnterCrashProtection( DXD_IN_SI_KEY, DXD_IN_SI_VALUE, 2 );
            // ******* GetComponentFiles in Windows Dir ********
            // First, check for DirectX files incorrectly stored in the Windows folder:
            GetWindowsDirectory(szPath, MAX_PATH);
            if (FAILED(hr = GetComponentFiles(szPath, &s_pDxWinComponentsFileInfoFirst, TRUE, IDS_DXGRAPHICS_COMPONENTFILES)))
                ReportError(IDS_COMPONENTFILESPROBLEM, hr);
            if (FAILED(hr = GetComponentFiles(szPath, &s_pDxWinComponentsFileInfoFirst, TRUE, IDS_DPLAY_COMPONENTFILES)))
                ReportError(IDS_COMPONENTFILESPROBLEM, hr);
            if (FAILED(hr = GetComponentFiles(szPath, &s_pDxWinComponentsFileInfoFirst, TRUE, IDS_DINPUT_COMPONENTFILES)))
                ReportError(IDS_COMPONENTFILESPROBLEM, hr);
            if (FAILED(hr = GetComponentFiles(szPath, &s_pDxWinComponentsFileInfoFirst, TRUE, IDS_DXAUDIO_COMPONENTFILES)))
                ReportError(IDS_COMPONENTFILESPROBLEM, hr);
            if (FAILED(hr = GetComponentFiles(szPath, &s_pDxWinComponentsFileInfoFirst, TRUE, IDS_DXMISC_COMPONENTFILES)))
                ReportError(IDS_COMPONENTFILESPROBLEM, hr);
            if (FAILED(hr = GetComponentFiles(szPath, &s_pDxWinComponentsFileInfoFirst, TRUE, IDS_BDA_COMPONENTFILES)))
                ReportError(IDS_BDA_COMPONENTFILES, hr);
            SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

            // ******* GetComponentFiles in Sys Dir ********
            GetSystemDirectory(szPath, MAX_PATH);
            if (FAILED(hr = GetComponentFiles(szPath, &s_pDxComponentsFileInfoFirst, FALSE, IDS_DXGRAPHICS_COMPONENTFILES)))
                ReportError(IDS_COMPONENTFILESPROBLEM, hr);
            if (FAILED(hr = GetComponentFiles(szPath, &s_pDxComponentsFileInfoFirst, FALSE, IDS_DPLAY_COMPONENTFILES)))
                ReportError(IDS_COMPONENTFILESPROBLEM, hr);
            if (FAILED(hr = GetComponentFiles(szPath, &s_pDxComponentsFileInfoFirst, FALSE, IDS_DINPUT_COMPONENTFILES)))
                ReportError(IDS_COMPONENTFILESPROBLEM, hr);
            if (FAILED(hr = GetComponentFiles(szPath, &s_pDxComponentsFileInfoFirst, FALSE, IDS_DXAUDIO_COMPONENTFILES)))
                ReportError(IDS_COMPONENTFILESPROBLEM, hr);
            if (FAILED(hr = GetComponentFiles(szPath, &s_pDxComponentsFileInfoFirst, FALSE, IDS_DXMISC_COMPONENTFILES)))
                ReportError(IDS_COMPONENTFILESPROBLEM, hr);
            if (GetDxSetupFolder(szPath))
            {
                if (FAILED(hr = GetComponentFiles(szPath, &s_pDxComponentsFileInfoFirst, FALSE, IDS_DXSETUP_COMPONENTFILES)))
                    ReportError(IDS_COMPONENTFILESPROBLEM, hr);
            }

            GetSystemDirectory(szPath, MAX_PATH);
            if (FAILED(hr = GetComponentFiles(szPath, &s_pDxComponentsFileInfoFirst, FALSE, IDS_DXMEDIA_COMPONENTFILES)))
                ReportError(IDS_COMPONENTFILESPROBLEM, hr);
            if (FAILED(hr = GetComponentFiles(szPath, &s_pDxComponentsFileInfoFirst, FALSE, IDS_BDA_COMPONENTFILES)))
                ReportError(IDS_BDA_COMPONENTFILES, hr);
            LeaveCrashProtection( DXD_IN_SI_KEY, DXD_IN_SI_VALUE, 2 );
        }  
    }
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

    // Stop if the UI thread is gone 
    if( s_hUIThread != NULL && WAIT_TIMEOUT != WaitForSingleObject( s_hUIThread, 0 ) )
        return S_FALSE;

    // ******* GetExtraDisplayInfo (DD:2) ********
    if( s_bUseDisplay )
    {
        s_bUseDisplay = QueryCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, IDS_DD, 2 );
        if( s_bUseDisplay )
        {
            EnterCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 2 );
            if (FAILED(hr = GetExtraDisplayInfo(s_pDisplayInfoFirst)))
                ReportError(IDS_NOEXTRADISPLAYINFO, hr);
            LeaveCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 2 );
        }
    }
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

    // Stop if the UI thread is gone 
    if( s_hUIThread != NULL && WAIT_TIMEOUT != WaitForSingleObject( s_hUIThread, 0 ) )
        return S_FALSE;

    // ******* GetDDrawDisplayInfo (DD:3) ********
    if( s_bUseDisplay )
    {
        s_bUseDisplay = QueryCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, IDS_DD, 3 );

        if( !s_bGUI )
        {
            // If there's no gui, then check to see if we are 16 or less colors
            // If we are then don't use DirectDraw otherwise it will pop up a warning box
            HDC hDC = GetDC( NULL );

            if( hDC )
            {
                int nBitsPerPixel = GetDeviceCaps( hDC, BITSPIXEL ); 
                ReleaseDC( NULL, hDC );
        
                if( nBitsPerPixel < 8 )
                    s_bUseDisplay = FALSE;
            }
        }

        if( s_bUseDisplay )
        {
            EnterCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 3 );
            if(FAILED(hr = GetDDrawDisplayInfo(s_pDisplayInfoFirst)))
                ReportError(IDS_NOEXTRADISPLAYINFO, hr); 
            LeaveCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 3 );
        }
    }
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

    // Stop if the UI thread is gone 
    if( s_hUIThread != NULL && WAIT_TIMEOUT != WaitForSingleObject( s_hUIThread, 0 ) )
        return S_FALSE;

    // ******* GetExtraSoundInfo (DS:2) ********
    if( s_bUseDSound )
    {
        s_bUseDSound = QueryCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, IDS_DS, 2 );
        if( s_bUseDSound )
        {
            EnterCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 2 );
            if (FAILED(hr = GetExtraSoundInfo(s_pSoundInfoFirst)))
                ReportError(IDS_NOEXTRASOUNDINFO, hr);
            LeaveCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 2 );
        }
    }
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

    // Stop if the UI thread is gone 
    if( s_hUIThread != NULL && WAIT_TIMEOUT != WaitForSingleObject( s_hUIThread, 0 ) )
        return S_FALSE;

    // ******* GetDSSoundInfo (DS:3) ********
    if( s_bUseDSound )
    {
        s_bUseDSound = QueryCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, IDS_DS, 3 );
        if( s_bUseDSound )
        {
            EnterCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 3 );
            if (FAILED(hr = GetDSSoundInfo(s_pSoundInfoFirst)))
                ReportError(IDS_NOEXTRASOUNDINFO, hr);
            LeaveCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 3 );
        }
    }
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

    // Stop if the UI thread is gone 
    if( s_hUIThread != NULL && WAIT_TIMEOUT != WaitForSingleObject( s_hUIThread, 0 ) )
        return S_FALSE;

    // ******* GetExtraMusicInfo (DM:2) *******
    if( s_bUseDMusic )
    {
        if (s_pMusicInfo != NULL && s_pMusicInfo->m_bDMusicInstalled)
        {
            s_bUseDMusic = QueryCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, IDS_DM, 2 );
            if( s_bUseDMusic )
            {
                EnterCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, 2 );
                if (FAILED(hr = GetExtraMusicInfo(s_pMusicInfo)))
                    ReportError(IDS_NOBASICMUSICINFO, hr);  
                LeaveCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, 2 );
            }
            if (s_pMusicInfo->m_pMusicPortFirst != NULL)
                s_pMusicInfo->m_guidMusicPortTest = s_pMusicInfo->m_pMusicPortFirst->m_guid;
        }
    }
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

    // Stop if the UI thread is gone 
    if( s_hUIThread != NULL && WAIT_TIMEOUT != WaitForSingleObject( s_hUIThread, 0 ) )
        return S_FALSE;

    // ******* GetInputInfo (DI:1) ********
    if( s_bUseDInput )
    {
        s_bUseDInput = QueryCrashProtection( DXD_IN_DI_KEY, DXD_IN_DI_VALUE, IDS_DI, 1 );
        if( s_bUseDInput )
        {
            EnterCrashProtection( DXD_IN_DI_KEY, DXD_IN_DI_VALUE, 1 );
            if (FAILED(hr = GetInputInfo(&s_pInputInfo)))
                ReportError(IDS_NOINPUTINFO, hr);
            LeaveCrashProtection( DXD_IN_DI_KEY, DXD_IN_DI_VALUE, 1 );
        }
    }
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

    // Stop if the UI thread is gone 
    if( s_hUIThread != NULL && WAIT_TIMEOUT != WaitForSingleObject( s_hUIThread, 0 ) )
        return S_FALSE;

    // ******* GetInputDriverInfo (DI:2) ********
    if( s_bUseDInput )
    {
        s_bUseDInput = QueryCrashProtection( DXD_IN_DI_KEY, DXD_IN_DI_VALUE, IDS_DI, 2 );
        if( s_bUseDInput )
        {
            EnterCrashProtection( DXD_IN_DI_KEY, DXD_IN_DI_VALUE, 2 );
            if (FAILED(hr = GetInputDriverInfo(s_pInputInfo)))
                ReportError(IDS_NOINPUTDRIVERINFO, hr);
            LeaveCrashProtection( DXD_IN_DI_KEY, DXD_IN_DI_VALUE, 2 );
        }
    }
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

    // Stop if the UI thread is gone 
    if( s_hUIThread != NULL && WAIT_TIMEOUT != WaitForSingleObject( s_hUIThread, 0 ) )
        return S_FALSE;

    // ******* GetNetInfo (DP:1) ********
    if( s_bUseDPlay )
    {
        s_bUseDPlay = QueryCrashProtection( DXD_IN_DP_KEY, DXD_IN_DP_VALUE, IDS_DP, 1 );
        if( s_bUseDPlay )
        {
            EnterCrashProtection( DXD_IN_DP_KEY, DXD_IN_DP_VALUE, 1 );
            if (FAILED(hr = GetNetInfo(&s_sysInfo, &s_pNetInfo)))
                ReportError(IDS_NONETINFO, hr);
            LeaveCrashProtection( DXD_IN_DP_KEY, DXD_IN_DP_VALUE, 1 );
        }
    }
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

    // Stop if the UI thread is gone 
    if( s_hUIThread != NULL && WAIT_TIMEOUT != WaitForSingleObject( s_hUIThread, 0 ) )
        return S_FALSE;

    // ******* GetBasicShowInfo (SI:3) ********
    if( s_bUseDShow )
    {
        s_bUseDShow = QueryCrashProtection( DXD_IN_SI_KEY, DXD_IN_SI_VALUE, IDS_SI, 3 );
        if( s_bUseDShow )
        {
            EnterCrashProtection( DXD_IN_SI_KEY, DXD_IN_SI_VALUE, 3 );
            if (FAILED(hr = GetBasicShowInfo(&s_pShowInfo)))
                ReportError(IDS_COMPONENTFILESPROBLEM, hr);
            LeaveCrashProtection( DXD_IN_SI_KEY, DXD_IN_SI_VALUE, 3 );
        }
    }
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

    // Stop if the UI thread is gone 
    if( s_hUIThread != NULL && WAIT_TIMEOUT != WaitForSingleObject( s_hUIThread, 0 ) )
        return S_FALSE;

    // ******* DiagnoseDxFiles ********
    DiagnoseDxFiles(&s_sysInfo, s_pDxComponentsFileInfoFirst, 
                    s_pDxWinComponentsFileInfoFirst);
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        
    
    // ******* DiagnoseDisplay ********
    DiagnoseDisplay(&s_sysInfo, s_pDisplayInfoFirst);
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        
    
    // ******* DiagnoseSound ********
    DiagnoseSound(s_pSoundInfoFirst);
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        
    
    // ******* DiagnoseInput ********
    DiagnoseInput(&s_sysInfo, s_pInputInfo);
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        
    
    // ******* DiagnoseMusic ********
    DiagnoseMusic(&s_sysInfo, s_pMusicInfo);
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

    // ******* DiagnoseNetInfo ********
    DiagnoseNetInfo(&s_sysInfo, s_pNetInfo);
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

    return S_OK;
}


/****************************************************************************
 *
 *  SaveInfo
 *
 ****************************************************************************/
VOID SaveInfo(VOID)
{
    HRESULT hr;
    OPENFILENAME ofn;
    TCHAR szFile[MAX_PATH];
    TCHAR szFilter[MAX_PATH];
    TCHAR szExt[MAX_PATH];
    TCHAR* pch = NULL;

    LoadString(NULL, IDS_FILTER, szFilter, MAX_PATH);
    // Filter strings are weird because they contain nulls.
    // The string loaded from a resource has # where nulls
    // should be inserted.
    for (pch = szFilter; *pch != TEXT('\0'); pch++)
    {
        if (*pch == TEXT('#'))
            *pch = TEXT('\0');
    }

    LoadString(NULL, IDS_DEFAULTFILENAME, szFile, MAX_PATH);
    LoadString(NULL, IDS_DEFAULTEXT, szExt, MAX_PATH);

    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = s_hwndMain;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.Flags = OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY;
    ofn.lpstrDefExt = szExt;

    TCHAR szInitialPath[MAX_PATH];
    if( FALSE == GetTxtPath( szInitialPath ) )
        ofn.lpstrInitialDir = NULL;
    else
        ofn.lpstrInitialDir = szInitialPath;

    if (GetSaveFileName(&ofn))
    {
        lstrcpy( szInitialPath, ofn.lpstrFile );
        TCHAR* strLastSlash = _tcsrchr(szInitialPath, '\\' );
        if( NULL != strLastSlash )
        {
            *strLastSlash = 0;
            SetTxtPath( szInitialPath );
        }

        if (FAILED(hr = SaveAllInfo(ofn.lpstrFile, &s_sysInfo, 
            s_pDxWinComponentsFileInfoFirst, s_pDxComponentsFileInfoFirst, 
            s_pDisplayInfoFirst, s_pSoundInfoFirst, s_pMusicInfo,
            s_pInputInfo, s_pNetInfo, s_pShowInfo)))
        {
        }
    }
}


/****************************************************************************
 *
 *  ToggleDDAccel
 *
 ****************************************************************************/
VOID ToggleDDAccel(VOID)
{
    HRESULT hr;
    TCHAR szTitle[MAX_PATH];
    TCHAR szMessage[MAX_PATH];
    BOOL bEnabled = IsDDHWAccelEnabled();
    HKEY hkey;
    DWORD dwData;

    LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
    if (bEnabled)
        LoadString(NULL, IDS_DISABLEDDWARNING, szMessage, MAX_PATH);
    else
        LoadString(NULL, IDS_ENABLEDDWARNING, szMessage, MAX_PATH);
    if (IDOK == MessageBox(s_hwndMain, szMessage, szTitle, MB_OKCANCEL))
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
            TEXT("SOFTWARE\\Microsoft\\DirectDraw"), 0, KEY_ALL_ACCESS, &hkey))
        {
            if (bEnabled) // if acceleration enabled
                dwData = TRUE; // force emulation
            else
                dwData = FALSE; // disable emulation
            if (ERROR_SUCCESS != RegSetValueEx(hkey, TEXT("EmulationOnly"), NULL, 
                REG_DWORD, (BYTE *)&dwData, sizeof(dwData)))
            {
                // TODO: report error
                RegCloseKey(hkey);
                return;

            }
            RegCloseKey(hkey);
        }
        else
        {
            // TODO: report error
            return;
        }
    }

    // update all DisplayInfo to reflect new state:

    // ******* GetExtraDisplayInfo (DD:2) ********
    if( s_bUseDisplay )
    {
        s_bUseDisplay = QueryCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, IDS_DD, 2 );
        if( s_bUseDisplay )
        {
            EnterCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 2 );
            if (FAILED(hr = GetExtraDisplayInfo(s_pDisplayInfoFirst)))
                ReportError(IDS_NOEXTRADISPLAYINFO, hr);
            LeaveCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 2 );
        }
    }

    // ******* GetDDrawDisplayInfo (DD:3) ********
    if( s_bUseDisplay )
    {
        s_bUseDisplay = QueryCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, IDS_DD, 3 );
        if( s_bUseDisplay )
        {
            EnterCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 3 );
            if(FAILED(hr = GetDDrawDisplayInfo(s_pDisplayInfoFirst)))
                ReportError(IDS_NOEXTRADISPLAYINFO, hr); 
            LeaveCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 3 );
        }
    }

    SetupDisplayPage(s_lwCurPage - s_iPageDisplayFirst); // refresh page
}


/****************************************************************************
 *
 *  ToggleD3DAccel
 *
 ****************************************************************************/
VOID ToggleD3DAccel(VOID)
{
    TCHAR szTitle[MAX_PATH];
    TCHAR szMessage[MAX_PATH];
    BOOL bEnabled = IsD3DHWAccelEnabled();
    HKEY hkey;
    DWORD dwData;

    LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
    if (bEnabled)
        LoadString(NULL, IDS_DISABLED3DWARNING, szMessage, MAX_PATH);
    else
        LoadString(NULL, IDS_ENABLED3DWARNING, szMessage, MAX_PATH);
    if (IDOK == MessageBox(s_hwndMain, szMessage, szTitle, MB_OKCANCEL))
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
            TEXT("SOFTWARE\\Microsoft\\Direct3D\\Drivers"), 0, KEY_ALL_ACCESS, &hkey))
        {
            if (bEnabled) // if acceleration enabled
                dwData = TRUE; // force emulation
            else
                dwData = FALSE; // disable emulation
            if (ERROR_SUCCESS != RegSetValueEx(hkey, TEXT("SoftwareOnly"), NULL, 
                REG_DWORD, (BYTE *)&dwData, sizeof(dwData)))
            {
                // TODO: report error
                RegCloseKey(hkey);
                return;

            }
            RegCloseKey(hkey);
            // update all DisplayInfo to reflect new state:
            DisplayInfo* pDisplayInfo;
            for (pDisplayInfo = s_pDisplayInfoFirst; pDisplayInfo != NULL; 
                pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext)
            {
                pDisplayInfo->m_b3DAccelerationEnabled = !bEnabled;
            }
        }
        else
        {
            // TODO: report error
            return;
        }
    }
    SetupDisplayPage(s_lwCurPage - s_iPageDisplayFirst); // refresh page
}


/****************************************************************************
 *
 *  ToggleAGPSupport
 *
 ****************************************************************************/
VOID ToggleAGPSupport(VOID)
{
    HRESULT hr;
    TCHAR szTitle[MAX_PATH];
    TCHAR szMessage[MAX_PATH];
    BOOL bEnabled = IsAGPEnabled();
    HKEY hkey;
    DWORD dwData;

    LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
    if (bEnabled)
        LoadString(NULL, IDS_DISABLEAGPWARNING, szMessage, MAX_PATH);
    else
        LoadString(NULL, IDS_ENABLEAGPWARNING, szMessage, MAX_PATH);
    if (IDOK == MessageBox(s_hwndMain, szMessage, szTitle, MB_OKCANCEL))
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
            TEXT("SOFTWARE\\Microsoft\\DirectDraw"), 0, KEY_ALL_ACCESS, &hkey))
        {
            if (bEnabled) // if AGP enabled
                dwData = TRUE; // disable
            else
                dwData = FALSE; // enable
            if (ERROR_SUCCESS != RegSetValueEx(hkey, TEXT("DisableAGPSupport"), NULL, 
                REG_DWORD, (BYTE *)&dwData, sizeof(dwData)))
            {
                // TODO: report error
                RegCloseKey(hkey);
                return;

            }
            RegCloseKey(hkey);
            // update all DisplayInfo to reflect new state:
            DisplayInfo* pDisplayInfo;
            for (pDisplayInfo = s_pDisplayInfoFirst; pDisplayInfo != NULL; 
                pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext)
            {
                pDisplayInfo->m_bAGPEnabled = !bEnabled;
            }
        }
        else
        {
            // TODO: report error
            return;
        }
    }

    // ******* GetDDrawDisplayInfo (DD:3) ********
    if( s_bUseDisplay )
    {
        s_bUseDisplay = QueryCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, IDS_DD, 3 );
        if( s_bUseDisplay )
        {
            EnterCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 3 );
            if(FAILED(hr = GetDDrawDisplayInfo(s_pDisplayInfoFirst)))
                ReportError(IDS_NOEXTRADISPLAYINFO, hr); 
            LeaveCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 3 );
        }
    }

    SetupDisplayPage(s_lwCurPage - s_iPageDisplayFirst); // refresh page
}


/****************************************************************************
 *
 *  ToggleDMAccel
 *
 ****************************************************************************/
VOID ToggleDMAccel(VOID)
{
    HRESULT hr;
    TCHAR szTitle[MAX_PATH];
    TCHAR szMessage[MAX_PATH];
    BOOL bEnabled = s_pMusicInfo->m_bAccelerationEnabled;
    HKEY hkey;
    DWORD dwData;

    LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
    if (bEnabled)
        LoadString(NULL, IDS_DISABLEDMWARNING, szMessage, MAX_PATH);
    else
        LoadString(NULL, IDS_ENABLEDMWARNING, szMessage, MAX_PATH);
    if (IDOK == MessageBox(s_hwndMain, szMessage, szTitle, MB_OKCANCEL))
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
            TEXT("SOFTWARE\\Microsoft\\DirectMusic"), 0, KEY_ALL_ACCESS, &hkey))
        {
            if (bEnabled) // if acceleration enabled
            {
                dwData = TRUE; // force emulation
                if (ERROR_SUCCESS != RegSetValueEx(hkey, TEXT("DisableHWAcceleration"), NULL, 
                    REG_DWORD, (BYTE *)&dwData, sizeof(dwData)))
                {
                    // TODO: report error
                    RegCloseKey(hkey);
                    return;

                }
            }
            else
            {
                if (ERROR_SUCCESS != RegDeleteValue( hkey, TEXT("DisableHWAcceleration") ))
                {
                    // TODO: report error
                    RegCloseKey(hkey);
                    return;

                }
            }
            RegCloseKey(hkey);
        }
        else
        {
            // TODO: report error
            return;
        }
    }

    // update all MusicInfo to reflect new state:
    if (s_pMusicInfo != NULL)
        DestroyMusicInfo(s_pMusicInfo);

    // ******* GetBasicMusicInfo (DM:1)  ********
    if( s_bUseDMusic )
    {
        s_bUseDMusic = QueryCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, IDS_DM, 1 );
        if( s_bUseDMusic )
        {
            EnterCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, 1 );
            if (FAILED(hr = GetBasicMusicInfo(&s_pMusicInfo)))
                ReportError(IDS_NOBASICMUSICINFO, hr);  
            LeaveCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, 1 );
        }
    }

    // ******* GetExtraMusicInfo (DM:2) *******
    if( s_bUseDMusic )
    {
        s_bUseDMusic = QueryCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, IDS_DM, 2 );
        if( s_bUseDMusic )
        {
            EnterCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, 2 );
            if (FAILED(hr = GetExtraMusicInfo(s_pMusicInfo)))
                ReportError(IDS_NOBASICMUSICINFO, hr);  
            LeaveCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, 2 );
        }
    }

    if (s_pMusicInfo->m_pMusicPortFirst != NULL)
        s_pMusicInfo->m_guidMusicPortTest = s_pMusicInfo->m_pMusicPortFirst->m_guid;
    SetupMusicPage(); // refresh page
}


/****************************************************************************
 *
 *  BugDialogProc
 *
 ****************************************************************************/
INT_PTR CALLBACK BugDialogProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    switch (msg)
    {
        case WM_INITDIALOG:
        {
            TCHAR szFilename[MAX_PATH];

            if( FALSE == GetTxtPath( szFilename ) )
            {
                GetTempPath( MAX_PATH, szFilename );
                lstrcat( szFilename, TEXT("DxDiag.txt"));
            }
            else
            {
                lstrcat( szFilename, TEXT("\\DxDiag.txt"));
            }

            SetWindowText(GetDlgItem(hwnd, IDC_PATH), szFilename);

            return FALSE;
        }

        case WM_COMMAND:
        {
            WORD wID = LOWORD(wparam);
            switch(wID)
            {
                case IDC_BROWSE:
                {
                    OPENFILENAME ofn;
                    TCHAR szFile[MAX_PATH];
                    GetDlgItemText( hwnd, IDC_PATH, szFile, MAX_PATH );

                    ZeroMemory(&ofn, sizeof(ofn));
                    ofn.lStructSize = sizeof(ofn);
                    ofn.hwndOwner = hwnd;
                    ofn.lpstrFilter = TEXT("Text File (*.txt)\0*.txt\0\0");
                    ofn.lpstrFile = szFile;
                    ofn.nMaxFile = MAX_PATH;
                    ofn.Flags = OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY;
                    ofn.lpstrDefExt = TEXT(".txt");

                    if (GetSaveFileName(&ofn))
                        SetWindowText(GetDlgItem(hwnd, IDC_PATH), ofn.lpstrFile);
                    break;
                }

                case IDOK:
                {
                    TCHAR szPath[MAX_PATH];
                    GetWindowText(GetDlgItem(hwnd, IDC_PATH), szPath, MAX_PATH);
                    SaveAndSendBug(szPath);

                    TCHAR* strLastSlash = _tcsrchr(szPath, '\\' );
                    if( NULL != strLastSlash )
                    {
                        *strLastSlash = 0;
                        SetTxtPath( szPath );
                    }

                    EndDialog(hwnd, 0);
                    break;
                }

                case IDCANCEL:
                    EndDialog(hwnd, 0);
                    break;
            }
            return TRUE;
        }
    }
    return FALSE;
}


/****************************************************************************
 *
 *  ReportBug
 *
 ****************************************************************************/
VOID ReportBug(VOID)
{
    HINSTANCE hinst = (HINSTANCE)GetWindowLongPtr(s_hwndMain, GWLP_HINSTANCE);
    // Run the dialog box:
    DialogBox(hinst, MAKEINTRESOURCE(IDD_BUGINFO), s_hwndMain, BugDialogProc);
}


/****************************************************************************
 *
 *  SaveAndSendBug
 *
 ****************************************************************************/
VOID SaveAndSendBug(TCHAR* szPath)
{
    HRESULT hr;

    // Save the DxDiag.txt at szPath
    if (FAILED(hr = SaveAllInfo(szPath, &s_sysInfo, 
        s_pDxWinComponentsFileInfoFirst, s_pDxComponentsFileInfoFirst, 
        s_pDisplayInfoFirst, s_pSoundInfoFirst, s_pMusicInfo,
        s_pInputInfo, s_pNetInfo, NULL)))
    {
        ReportError(IDS_PROBLEMSAVING, hr);
        return;
    }

    // Launch the betaplace web page
    ShellExecute( NULL, NULL, 
                  TEXT("http://www.betaplace.com/"), 
                  NULL, NULL, SW_SHOWNORMAL );
}


/****************************************************************************
 *
 *  OverrideDDRefresh
 *
 ****************************************************************************/
VOID OverrideDDRefresh(VOID)
{
    HINSTANCE hinst = (HINSTANCE)GetWindowLongPtr(s_hwndMain, GWLP_HINSTANCE);
    DialogBox(hinst, MAKEINTRESOURCE(IDD_OVERRIDEDD), s_hwndMain, 
        OverrideRefreshDialogProc);
}


/****************************************************************************
 *
 *  OverrideRefreshDialogProc
 *
 ****************************************************************************/
INT_PTR CALLBACK OverrideRefreshDialogProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    HWND hwndTabs = GetDlgItem(hwnd, IDC_TAB);
    HKEY hkey;
    ULONG ulType = 0;
    DWORD dwRefresh;
    DWORD cbData;

    switch (msg)
    {
    case WM_INITDIALOG:
        dwRefresh = 0;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            TEXT("Software\\Microsoft\\DirectDraw"), 0, KEY_READ, &hkey))
        {
            cbData = sizeof(DWORD);
            RegQueryValueEx(hkey, TEXT("ForceRefreshRate"), 0, &ulType, (LPBYTE)&dwRefresh, &cbData);
        }
        if (dwRefresh == 0)
        {
            CheckRadioButton(hwnd, IDC_DEFAULTREFRESH, IDC_OVERRIDEREFRESH, IDC_DEFAULTREFRESH);
        }
        else
        {
            CheckRadioButton(hwnd, IDC_DEFAULTREFRESH, IDC_OVERRIDEREFRESH, IDC_OVERRIDEREFRESH);
            SetDlgItemInt(hwnd, IDC_OVERRIDEREFRESHVALUE, dwRefresh, FALSE);
        }
        return TRUE;
    case WM_COMMAND:
        {
            WORD wID = LOWORD(wparam);
            BOOL bDontEnd = FALSE;
            switch(wID)
            {
            case IDOK:
                if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    TEXT("Software\\Microsoft\\DirectDraw"), 0, KEY_ALL_ACCESS, &hkey))
                {
                    DWORD dwButtonState;
                    dwButtonState = (DWORD)SendMessage(GetDlgItem(hwnd, IDC_DEFAULTREFRESH), BM_GETCHECK, 0, 0);
                    if (dwButtonState == BST_CHECKED)
                    {
                        RegDeleteValue(hkey, TEXT("ForceRefreshRate"));
                    }
                    else
                    {
                        BOOL bTranslated;
                        UINT ui = GetDlgItemInt(hwnd, IDC_OVERRIDEREFRESHVALUE, &bTranslated, TRUE);
                        if (bTranslated && ui >= 40 && ui <= 120)
                            RegSetValueEx(hkey, TEXT("ForceRefreshRate"), 0, REG_DWORD, (LPBYTE)&ui, sizeof(DWORD));
                        else
                        {
                            TCHAR sz[MAX_PATH];
                            TCHAR szTitle[MAX_PATH];
                            SetDlgItemText(hwnd, IDC_OVERRIDEREFRESHVALUE, TEXT(""));
                            CheckRadioButton(hwnd, IDC_DEFAULTREFRESH, IDC_OVERRIDEREFRESH, IDC_DEFAULTREFRESH);
                            LoadString(NULL, IDS_BADREFRESHVALUE, sz, MAX_PATH);
                            LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
                            MessageBox(hwnd, sz, szTitle, MB_OK);
                            bDontEnd = TRUE;
                        }
                    }
                    RegCloseKey(hkey);
                }
                else
                {
                }
                if (!bDontEnd)
                    EndDialog(hwnd, IDOK);
                break;
            case IDCANCEL:
                EndDialog(hwnd, IDCANCEL);
                break;
            case IDC_OVERRIDEREFRESHVALUE:
                if (HIWORD(wparam) == EN_SETFOCUS)
                {
                    CheckRadioButton(hwnd, IDC_DEFAULTREFRESH, IDC_OVERRIDEREFRESH, IDC_OVERRIDEREFRESH);
                }
                else if (HIWORD(wparam) == EN_KILLFOCUS)
                {
                    TCHAR szEdit[MAX_PATH];
                    BOOL bTranslated;
                    if (GetDlgItemText(hwnd, IDC_OVERRIDEREFRESHVALUE, szEdit, 100) == 0)
                    {
                        CheckRadioButton(hwnd, IDC_DEFAULTREFRESH, IDC_OVERRIDEREFRESH, IDC_DEFAULTREFRESH);
                    }
                    else
                    {
                        UINT ui = GetDlgItemInt(hwnd, IDC_OVERRIDEREFRESHVALUE, &bTranslated, TRUE);
                        if (!bTranslated || ui < 40 || ui > 120)
                        {
                            TCHAR sz[MAX_PATH];
                            TCHAR szTitle[MAX_PATH];
                            LoadString(NULL, IDS_BADREFRESHVALUE, sz, MAX_PATH);
                            LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
                            MessageBox(hwnd, sz, szTitle, MB_OK);
                            SetDlgItemText(hwnd, IDC_OVERRIDEREFRESHVALUE, TEXT(""));
                            CheckRadioButton(hwnd, IDC_DEFAULTREFRESH, IDC_OVERRIDEREFRESH, IDC_DEFAULTREFRESH);
                        }
                    }
                }
                break;
            }
        }
        return TRUE;
    }
    return FALSE;
}


/****************************************************************************
 *
 *  ShowHelp - Look for dxdiag.chm in <windows>\help first, then try the 
 *      same dir as the exe.
 *
 ****************************************************************************/
VOID ShowHelp(VOID)
{
    TCHAR szHelpDir[MAX_PATH];
    TCHAR szHelpFile[MAX_PATH];
    TCHAR szHelpLeaf[MAX_PATH];
    TCHAR szTestPath[MAX_PATH];

    // Since we use HTML help, complain if at least IE5 is not found
    BOOL bIE5Found = FALSE;
    HKEY hkey;
    TCHAR szVersion[MAX_PATH];
    DWORD dwType;
    DWORD cbData;
    DWORD dwMajor;
    DWORD dwMinor;
    DWORD dwRevision;
    DWORD dwBuild;
    lstrcpy(szVersion, TEXT(""));
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        TEXT("Software\\Microsoft\\Internet Explorer"), 0, KEY_READ, &hkey))
    {
        cbData = 100;
        RegQueryValueEx(hkey, TEXT("Version"), 0, &dwType, (LPBYTE)szVersion, &cbData);
        RegCloseKey(hkey);
        if (lstrlen(szVersion) > 0)
        {
            _stscanf(szVersion, TEXT("%d.%d.%d.%d"), &dwMajor, &dwMinor, &dwRevision, &dwBuild);
            if (dwMajor >= 5)
                bIE5Found = TRUE;
        }
    }
    if (!bIE5Found)
    {
        ReportError(IDS_HELPNEEDSIE5);
        return;
    }


    LoadString(NULL, IDS_HELPFILE, szHelpFile, MAX_PATH);
    GetWindowsDirectory(szHelpDir, MAX_PATH);
    LoadString(NULL, IDS_HELPDIRLEAF, szHelpLeaf, MAX_PATH);
    lstrcat(szHelpDir, szHelpLeaf);
    lstrcpy(szTestPath, szHelpDir);
    lstrcat(szTestPath, TEXT("\\"));
    lstrcat(szTestPath, szHelpFile);
    if (GetFileAttributes(szTestPath) == 0xffffffff)
    {
        // File not in windows\help, so try exe's dir:
        GetModuleFileName(NULL, szHelpDir, MAX_PATH);
        TCHAR* pstr = _tcsrchr(szHelpDir, TEXT('\\'));
        if( pstr )
            *pstr = TEXT('\0');
    }
    
    HINSTANCE hInstResult = ShellExecute( s_hwndMain, NULL, szHelpFile, 
                                          NULL, szHelpDir, SW_SHOWNORMAL ) ;
    if( (INT_PTR)hInstResult < 32 ) 
        ReportError(IDS_NOHELP);
}


/****************************************************************************
 *
 *  BTranslateError
 *
 ****************************************************************************/
BOOL BTranslateError(HRESULT hr, TCHAR* psz, BOOL bEnglish)
{
    LONG ids;

    switch (hr)
    {
    case E_INVALIDARG: ids = bEnglish ? IDS_INVALIDARG_ENGLISH : IDS_INVALIDARG; break;
    case E_FAIL: ids = bEnglish ? IDS_FAIL_ENGLISH : IDS_FAIL; break;
    case E_UNEXPECTED: ids = bEnglish ? IDS_UNEXPECTED_ENGLISH : IDS_UNEXPECTED; break;
    case E_NOTIMPL: ids = bEnglish ? IDS_NOTIMPL_ENGLISH : IDS_NOTIMPL; break;
    case E_OUTOFMEMORY: ids = bEnglish ? IDS_OUTOFMEMORY_ENGLISH : IDS_OUTOFMEMORY; break;
    case E_NOINTERFACE: ids = bEnglish ? IDS_NOINTERFACE_ENGLISH : IDS_NOINTERFACE; break;
    case REGDB_E_CLASSNOTREG: ids = bEnglish ? IDS_REGDB_E_CLASSNOTREG_ENGLISH : IDS_REGDB_E_CLASSNOTREG; break;
    
    case DDERR_INVALIDMODE: ids = bEnglish ? IDS_INVALIDMODE_ENGLISH : IDS_INVALIDMODE; break;
    case DDERR_INVALIDPIXELFORMAT: ids = bEnglish ? IDS_INVALIDPIXELFORMAT_ENGLISH : IDS_INVALIDPIXELFORMAT; break;
    case DDERR_CANTCREATEDC: ids = bEnglish ? IDS_CANTCREATEDC_ENGLISH : IDS_CANTCREATEDC; break;
    case DDERR_NOTFOUND: ids = bEnglish ? IDS_NOTFOUND_ENGLISH : IDS_NOTFOUND; break;
    case DDERR_NODIRECTDRAWSUPPORT: ids = bEnglish ? IDS_NODIRECTDRAWSUPPORT_ENGLISH : IDS_NODIRECTDRAWSUPPORT; break;
    case DDERR_NO3D: ids = bEnglish ? IDS_NO3D_ENGLISH : IDS_NO3D; break;

    case D3DERR_INVALID_DEVICE: ids = bEnglish ? IDS_INVALID_DEVICE_ENGLISH : IDS_INVALID_DEVICE; break;
    case D3DERR_INITFAILED: ids = bEnglish ? IDS_INITFAILED_ENGLISH : IDS_INITFAILED; break;
    case D3DERR_MATERIAL_CREATE_FAILED: ids = bEnglish ? IDS_MATERIAL_CREATE_FAILED_ENGLISH : IDS_MATERIAL_CREATE_FAILED; break;
    case D3DERR_LIGHT_SET_FAILED: ids = bEnglish ? IDS_LIGHT_SET_FAILED_ENGLISH : IDS_LIGHT_SET_FAILED; break;
    case DDERR_OUTOFVIDEOMEMORY: ids = bEnglish ? IDS_OUT_OF_VIDEO_MEMORY_ENGLISH : IDS_OUT_OF_VIDEO_MEMORY; break;
#define D3DERR_NOTAVAILABLE 0x8876086a 
    case D3DERR_NOTAVAILABLE: ids = bEnglish ? IDS_D3DERR_NOTAVAILABLE_ENGLISH : IDS_D3DERR_NOTAVAILABLE; break;        

    case DSERR_CONTROLUNAVAIL: ids = bEnglish ? IDS_CONTROLUNAVAIL_ENGLISH : IDS_CONTROLUNAVAIL; break;
    case DSERR_BADFORMAT: ids = bEnglish ? IDS_BADFORMAT_ENGLISH : IDS_BADFORMAT; break;
    case DSERR_BUFFERLOST: ids = bEnglish ? IDS_BUFFERLOST_ENGLISH : IDS_BUFFERLOST; break;
    case DSERR_NODRIVER: ids = bEnglish ? IDS_NODRIVER_ENGLISH : IDS_NODRIVER; break;
    case DSERR_ALLOCATED: ids = bEnglish ? IDS_ALLOCATED_ENGLISH : IDS_ALLOCATED; break;

    case DMUS_E_DRIVER_FAILED: ids = bEnglish ? IDS_DRIVER_FAILED_ENGLISH : IDS_DRIVER_FAILED; break;
    case DMUS_E_PORTS_OPEN: ids = bEnglish ? IDS_PORTS_OPEN_ENGLISH : IDS_PORTS_OPEN; break;
    case DMUS_E_DEVICE_IN_USE: ids = bEnglish ? IDS_DEVICE_IN_USE_ENGLISH : IDS_DEVICE_IN_USE; break;
    case DMUS_E_INSUFFICIENTBUFFER: ids = bEnglish ? IDS_INSUFFICIENTBUFFER_ENGLISH : IDS_INSUFFICIENTBUFFER; break;
    case DMUS_E_CHUNKNOTFOUND: ids = bEnglish ? IDS_CHUNKNOTFOUND_ENGLISH : IDS_CHUNKNOTFOUND; break;
    case DMUS_E_BADINSTRUMENT: ids = bEnglish ? IDS_BADINSTRUMENT_ENGLISH : IDS_BADINSTRUMENT; break;
    case DMUS_E_CANNOTREAD: ids = bEnglish ? IDS_CANNOTREAD_ENGLISH : IDS_CANNOTREAD; break;
    case DMUS_E_LOADER_BADPATH: ids = bEnglish ? IDS_LOADER_BADPATH_ENGLISH : IDS_LOADER_BADPATH; break;
    case DMUS_E_LOADER_FAILEDOPEN: ids = bEnglish ? IDS_LOADER_FAILEDOPEN_ENGLISH : IDS_LOADER_FAILEDOPEN; break;
    case DMUS_E_LOADER_FORMATNOTSUPPORTED: ids = bEnglish ? IDS_LOADER_FORMATNOTSUPPORTED_ENGLISH : IDS_LOADER_FORMATNOTSUPPORTED; break;
    case DMUS_E_LOADER_OBJECTNOTFOUND: ids = bEnglish ? IDS_OBJECTNOTFOUND_ENGLISH : IDS_OBJECTNOTFOUND; break;

    case DPERR_ACCESSDENIED: ids = bEnglish ? IDS_DPERR_ACCESSDENIED_ENGLISH : IDS_DPERR_ACCESSDENIED; break;
    case DPERR_CANTADDPLAYER: ids = bEnglish ? IDS_DPERR_CANTADDPLAYER_ENGLISH : IDS_DPERR_CANTADDPLAYER; break;
    case DPERR_CANTCREATESESSION: ids = bEnglish ? IDS_DPERR_CANTCREATESESSION_ENGLISH : IDS_DPERR_CANTCREATESESSION; break;
    case DPERR_EXCEPTION: ids = bEnglish ? IDS_DPERR_EXCEPTION_ENGLISH : IDS_DPERR_EXCEPTION; break;
    case DPERR_INVALIDOBJECT: ids = bEnglish ? IDS_DPERR_INVALIDOBJECT_ENGLISH : IDS_DPERR_INVALIDOBJECT; break;
    case DPERR_NOCONNECTION: ids = bEnglish ? IDS_DPERR_NOCONNECTION_ENGLISH : IDS_DPERR_NOCONNECTION; break;
    case DPERR_TIMEOUT: ids = bEnglish ? IDS_DPERR_TIMEOUT_ENGLISH : IDS_DPERR_TIMEOUT; break;
    case DPERR_BUSY: ids = bEnglish ? IDS_DPERR_BUSY_ENGLISH : IDS_DPERR_BUSY; break;
    case DPERR_CONNECTIONLOST: ids = bEnglish ? IDS_DPERR_CONNECTIONLOST_ENGLISH : IDS_DPERR_CONNECTIONLOST; break;
    case DPERR_NOSERVICEPROVIDER: ids = bEnglish ? IDS_DPERR_NOSERVICEPROVIDER_ENGLISH : IDS_DPERR_NOSERVICEPROVIDER; break;
    case DPERR_UNAVAILABLE: ids = bEnglish ? IDS_DPERR_UNAVAILABLE_ENGLISH : IDS_DPERR_UNAVAILABLE; break;

    default: ids = bEnglish ? IDS_UNKNOWNERROR_ENGLISH : IDS_UNKNOWNERROR; break;
    }
    LoadString(NULL, ids, psz, 200); 
    if (ids != IDS_UNKNOWNERROR && ids != IDS_UNKNOWNERROR_ENGLISH)
        return TRUE;
    else
        return FALSE;
}


/****************************************************************************
 *
 *  RestoreDrivers
 *
 ****************************************************************************/
VOID RestoreDrivers(VOID)
{
    TCHAR szDir[MAX_PATH];
    if (GetProgramFilesFolder(szDir))
    {
        lstrcat(szDir, TEXT("\\DirectX\\Setup"));

        HINSTANCE hInstResult = ShellExecute( s_hwndMain, NULL, TEXT("DxSetup.exe"), 
                                              NULL, szDir, SW_SHOWNORMAL ) ;
        if( (INT_PTR)hInstResult < 32 ) 
            ReportError(IDS_NODXSETUP);
    }
}


/****************************************************************************
 *
 *  BCanRestoreDrivers - Returns whether backed-up drivers can be restored.
 *      This function checks for the presence of dxsetup.exe where it should 
 *      be, and the existence of files in either <system>\dxbackup\display or
 *      <system>\dxbackup\media.
 *
 ****************************************************************************/
BOOL BCanRestoreDrivers(VOID)
{
    TCHAR szPath[MAX_PATH];

    if (!GetProgramFilesFolder(szPath))
        return FALSE;
    lstrcat(szPath, TEXT("\\DirectX\\Setup\\DxSetup.exe"));
    if (GetFileAttributes(szPath) == 0xffffffff)
        return FALSE;

    if (!GetSystemDirectory(szPath, MAX_PATH))
        return FALSE;
    lstrcat(szPath, TEXT("\\dxbackup\\display"));
    if (GetFileAttributes(szPath) != 0xffffffff)
        return TRUE;

    if (!GetSystemDirectory(szPath, MAX_PATH))
        return FALSE;
    lstrcat(szPath, TEXT("\\dxbackup\\media"));
    if (GetFileAttributes(szPath) != 0xffffffff)
        return TRUE;

    return FALSE;
}


/****************************************************************************
 *
 *  HandleSndSliderChange
 *
 ****************************************************************************/
VOID HandleSndSliderChange(INT nScrollCode, INT nPos)
{
    TCHAR sz[MAX_PATH];

    if (nScrollCode != SB_THUMBTRACK && nScrollCode != SB_THUMBPOSITION)
        nPos = (INT)SendMessage(GetDlgItem(s_hwndCurPage, IDC_SNDACCELSLIDER), TBM_GETPOS, 0, 0);

    if (nScrollCode == SB_THUMBTRACK ||
        nScrollCode == SB_LEFT ||
        nScrollCode == SB_RIGHT ||
        nScrollCode == SB_LINELEFT ||
        nScrollCode == SB_LINERIGHT ||
        nScrollCode == SB_PAGELEFT ||
        nScrollCode == SB_PAGERIGHT)
    {
        switch (nPos)
        {
        case 0:
            LoadString(NULL, IDS_NOSNDACCELERATION, sz, MAX_PATH);
            break;
        case 1:
            LoadString(NULL, IDS_BASICSNDACCELERATION, sz, MAX_PATH);
            break;
        case 2:
            LoadString(NULL, IDS_STANDARDSNDACCELERATION, sz, MAX_PATH);
            break;
        case 3:
            LoadString(NULL, IDS_FULLSNDACCELERATION, sz, MAX_PATH);
            break;
        default:
            lstrcpy(sz, TEXT(""));
            break;
        }
        SetWindowText(GetDlgItem(s_hwndCurPage, IDC_SNDACCELDESC), sz);
    }

    if (nScrollCode != SB_THUMBTRACK && nScrollCode != SB_ENDSCROLL &&
        s_pSoundInfoFirst != NULL )
    {
        HRESULT hr;

        SoundInfo* pSoundInfo = s_pSoundInfoFirst;
        LONG iSound = s_lwCurPage - s_iPageSoundFirst;
        while (iSound > 0)
        {
            pSoundInfo = pSoundInfo->m_pSoundInfoNext;
            iSound--;
        }

        if (nPos != pSoundInfo->m_lwAccelerationLevel)
        {
            if (FAILED(hr = ChangeAccelerationLevel(pSoundInfo, nPos)))
            {
                // TODO: report error
            }

            DestroySoundInfo(s_pSoundInfoFirst);
            pSoundInfo        = NULL;
            s_pSoundInfoFirst = NULL;

            // ******* GetBasicSoundInfo (DS:1) ********
            s_bUseDSound = QueryCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, IDS_DS, 1 );
            if( s_bUseDSound )
            {
                EnterCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 1 );
                if (FAILED(hr = GetBasicSoundInfo(&s_pSoundInfoFirst)))
                    ReportError(IDS_NOBASICSOUNDINFO, hr);  
                LeaveCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 1 );
            }

            // ******* GetExtraSoundInfo (DS:2) ********
            if( s_bUseDSound )
            {
                s_bUseDSound = QueryCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, IDS_DS, 2 );
                if( s_bUseDSound )
                {
                    EnterCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 2 );
                    if (FAILED(hr = GetExtraSoundInfo(s_pSoundInfoFirst)))
                        ReportError(IDS_NOEXTRASOUNDINFO, hr);
                    LeaveCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 2 );
                }
            }

            // ******* GetDSSoundInfo (DS:3) ********
            if( s_bUseDSound )
            {
                s_bUseDSound = QueryCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, IDS_DS, 3 );
                if( s_bUseDSound )
                {
                    EnterCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 3 );
                    if (FAILED(hr = GetDSSoundInfo(s_pSoundInfoFirst)))
                        ReportError(IDS_NOEXTRASOUNDINFO, hr);
                    LeaveCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 3 );
                }
            }

            SetupSoundPage( s_lwCurPage - s_iPageSoundFirst );
        }
    }
}


/****************************************************************************
 *
 *  TroubleShoot
 *
 ****************************************************************************/
VOID TroubleShoot( BOOL bTroubleShootSound )
{
    TCHAR szHelpDir[MAX_PATH];
    TCHAR szHelpLeaf[MAX_PATH];
    TCHAR szHelpExe[MAX_PATH];
    TCHAR szTroubleshooter[MAX_PATH];
    TCHAR szSubInfo[MAX_PATH];

    GetWindowsDirectory(szHelpDir, MAX_PATH);
    LoadString(NULL, IDS_HELPDIRLEAF, szHelpLeaf, MAX_PATH);
    LoadString(NULL, IDS_HELPEXE, szHelpExe, MAX_PATH);

    lstrcat(szHelpDir, szHelpLeaf);

    if( bTroubleShootSound )
    {
        if( BIsWin98() || BIsWin95() )
        {
            TCHAR szHelpPath[MAX_PATH];
            LoadString(NULL, IDS_TROUBLESHOOTER_WIN98SE, szTroubleshooter, MAX_PATH);
            lstrcpy(szHelpPath, szHelpDir);
            lstrcat(szHelpPath, TEXT("\\"));
            lstrcat(szHelpPath, szTroubleshooter);
            if (GetFileAttributes(szHelpPath) == 0xffffffff)
            {
                LoadString(NULL, IDS_SOUNDTROUBLESHOOTER_WIN98, szTroubleshooter, MAX_PATH);
                lstrcpy( szSubInfo, TEXT("") );
            }
            else
            {
                LoadString(NULL, IDS_TROUBLESHOOTER_WIN98SE, szTroubleshooter, MAX_PATH);
                LoadString(NULL, IDS_TSSOUNDSUBINFO_WIN98SE, szSubInfo, MAX_PATH);
            }
        }
        else if( BIsWinME() )
        {
            LoadString(NULL, IDS_TROUBLESHOOTER_WINME_HCP, szHelpExe, MAX_PATH);
            LoadString(NULL, IDS_TSSOUNDSUBINFO_WINME_HCP, szSubInfo, MAX_PATH);

            lstrcat(szHelpExe, szSubInfo);
            lstrcpy(szTroubleshooter, TEXT("") );
            lstrcpy(szSubInfo, TEXT("") );
        }
        else if( BIsWin2k() )
        {
            LoadString(NULL, IDS_TROUBLESHOOTER_WIN2K, szTroubleshooter, MAX_PATH);
            LoadString(NULL, IDS_TSSOUNDSUBINFO_WIN2K, szSubInfo, MAX_PATH);
        }
        else // if( BIsWhistler() )
        {
            lstrcpy( szHelpExe, TEXT("hcp://help/tshoot/tssound.htm") );
            lstrcpy( szTroubleshooter, TEXT("") );
            lstrcpy( szSubInfo, TEXT("") );
        }
    }
    else
    {
        if( BIsWin98() || BIsWin95() )
        {
            TCHAR szHelpPath[MAX_PATH];
            LoadString(NULL, IDS_TROUBLESHOOTER_WIN98SE, szTroubleshooter, MAX_PATH);
            lstrcpy(szHelpPath, szHelpDir);
            lstrcat(szHelpPath, TEXT("\\"));
            lstrcat(szHelpPath, szTroubleshooter);
            if (GetFileAttributes(szHelpPath) == 0xffffffff)
            {
                LoadString(NULL, IDS_TROUBLESHOOTER_WIN98, szTroubleshooter, MAX_PATH);
                lstrcpy( szSubInfo, TEXT("") );
            }
            else
            {
                LoadString(NULL, IDS_TROUBLESHOOTER_WIN98SE, szTroubleshooter, MAX_PATH);
                LoadString(NULL, IDS_TSSUBINFO_WIN98SE, szSubInfo, MAX_PATH);
            }
        }
        else if( BIsWinME() )
        {
            LoadString(NULL, IDS_TROUBLESHOOTER_WINME_HCP, szHelpExe, MAX_PATH);   
            LoadString(NULL, IDS_TSSUBINFO_WINME_HCP, szSubInfo, MAX_PATH);

            lstrcat(szHelpExe, szSubInfo);
            lstrcpy(szTroubleshooter, TEXT("") );
            lstrcpy(szSubInfo, TEXT("") );
        }
        else if( BIsWin2k() )
        {
            LoadString(NULL, IDS_TROUBLESHOOTER_WIN2K, szTroubleshooter, MAX_PATH);   
            LoadString(NULL, IDS_TSSUBINFO_WIN2K, szSubInfo, MAX_PATH);
        }
        else // if( BIsWhistler() )
        {
            lstrcpy( szHelpExe, TEXT("hcp://help/tshoot/tsgame.htm") );
            lstrcpy( szTroubleshooter, TEXT("") );
            lstrcpy( szSubInfo, TEXT("") );
        }
    }

    lstrcat(szTroubleshooter, szSubInfo);
    HINSTANCE hInstResult = ShellExecute( s_hwndMain, NULL, szHelpExe, 
                                      szTroubleshooter, 
                                      szHelpDir, SW_SHOWNORMAL ) ;
    if( (INT_PTR)hInstResult < 32 ) 
        ReportError(IDS_NOTROUBLESHOOTER);
}


/****************************************************************************
 *
 *  QueryCrashProtection
 *
 ****************************************************************************/
BOOL QueryCrashProtection( TCHAR* strKey, TCHAR* strValue, 
                           int nSkipComponent, DWORD dwCurrentStep )
{
    HKEY    hkey            = NULL;
    BOOL    bAllowCall      = TRUE;

    // Open the key
    if( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, strKey, 0, KEY_ALL_ACCESS, &hkey) )
    {
        DWORD dwType = 0;
        DWORD dwCrashedOnStep = 0;
        DWORD cbData = sizeof(dwCrashedOnStep);

        // Query the key for the value of where the last crash occurred
        if( ERROR_SUCCESS == RegQueryValueEx( hkey, strValue, 0, &dwType, 
                                              (BYTE*)&dwCrashedOnStep, &cbData) )
        {
            // If we are at or beyond the crash step, then ask the user
            // to continue or not
            if( dwCurrentStep >= dwCrashedOnStep )
            {
                if( !s_bGUI )
                {
                    // If there's no gui, don't ask just don't use it
                    bAllowCall = FALSE;
                }
                else
                {
                    // If the UI is alive then have it ask the user, 
                    // otherwise do it ourselves
                    if( s_hwndMain && s_hUIThread )
                    {
                        // Mark down which component we're skipping in s_nSkipComponent,
                        // and then post a WM_QUERYSKIP message to the UI thread
                        // it will process this message, ask the user, and signal the
                        // s_hQuerySkipEvent event.
                        s_nSkipComponent = nSkipComponent;
                        PostMessage( s_hwndMain, WM_QUERYSKIP, 0, 0 );

                        HANDLE aWait[2];
                        DWORD dwResult;
                        aWait[0] = s_hQuerySkipEvent;
                        aWait[1] = s_hUIThread;

                        // Its possible that the UI thread exited before it processed the
                        // WM_QUERYSKIP message, so wait for either the event and thread exiting
                        dwResult = WaitForMultipleObjects( 2, aWait, FALSE, INFINITE );
            
                        // If the event was signaled, then get the result from s_bQuerySkipAllow,
                        // otherwise skip this call (the main code will exit if it sees the UI thread gone)
                        if( dwResult == WAIT_OBJECT_0 )
                            bAllowCall = s_bQuerySkipAllow;
                        else
                            bAllowCall = FALSE;
                    }
                    else
                    {
                        // If there's is no gui, ask if to use it now
                        TCHAR szTitle[MAX_PATH];
                        TCHAR szMessage[MAX_PATH];
                        TCHAR szFmt[MAX_PATH];
                        TCHAR szMessageComponent[MAX_PATH];
                        LoadString(0, IDS_APPFULLNAME, szTitle, MAX_PATH);
                        LoadString(0, IDS_SKIP, szFmt, MAX_PATH);
                        LoadString(0, nSkipComponent, szMessageComponent, MAX_PATH);
                        wsprintf( szMessage, szFmt, szMessageComponent, szMessageComponent );
                        if( IDYES == MessageBox( s_hwndMain, szMessage, szTitle, MB_YESNO) )
                            bAllowCall = FALSE;
                    }
                }
            }
        }

        RegCloseKey(hkey);
    }

    return bAllowCall;
}


/****************************************************************************
 *
 *  EnterCrashProtection
 *
 ****************************************************************************/
VOID EnterCrashProtection( TCHAR* strKey, TCHAR* strValue, DWORD dwCurrentStep )
{
    HKEY  hkey = NULL;
    BOOL  bSetValue = FALSE;
    DWORD dwDisposition;

    // Write reg key indicating we are inside the crash protection
    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_LOCAL_MACHINE, strKey, 0, 
                                         NULL, REG_OPTION_NON_VOLATILE, 
                                         KEY_ALL_ACCESS, NULL, &hkey, &dwDisposition) )
    {
        DWORD dwType = 0;
        DWORD dwCrashedOnStep = 0;
        DWORD cbData = sizeof(dwCrashedOnStep);

        // Query the key for the value of where the last crash occurred
        if( ERROR_SUCCESS == RegQueryValueEx( hkey, strValue, 0, &dwType, 
                                             (BYTE*)&dwCrashedOnStep, &cbData) )
        {
            // If we are beyond whats currently in the reg, then update the value
            if( dwCurrentStep > dwCrashedOnStep )
                bSetValue = TRUE;
        }
        else
        {
            // If the value doesn't exist current, then create it
            bSetValue = TRUE;
        }

        if( bSetValue )
        {
            RegSetValueEx( hkey, strValue, 0, REG_DWORD, 
                           (BYTE*)&dwCurrentStep, sizeof(dwCurrentStep));
        }

        RegCloseKey(hkey);
    }        
}


/****************************************************************************
 *
 *  LeaveCrashProtection
 *
 ****************************************************************************/
VOID LeaveCrashProtection( TCHAR* strKey, TCHAR* strValue, DWORD dwCurrentStep )
{
    HKEY  hkey = NULL;

    // Remove reg key since we're done with the crash protection
    if (ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, strKey, 0, 
                                       KEY_ALL_ACCESS, &hkey))
    {
        DWORD dwType = 0;
        DWORD dwCrashedOnStep = 0;
        DWORD cbData = sizeof(dwCrashedOnStep);

        // Query the key for the value of where the last crash occurred
        if( ERROR_SUCCESS == RegQueryValueEx( hkey, strValue, 0, &dwType, 
                                              (BYTE*)&dwCrashedOnStep, &cbData) )
        {
            // If we are at or beyond that crash step, then delete the key
            if( dwCurrentStep >= dwCrashedOnStep )
            {
                RegDeleteValue(hkey, strValue);
            }
        }

        RegCloseKey(hkey);
    }
}


/****************************************************************************
 *
 *  TestD3D
 *
 ****************************************************************************/
VOID TestD3D(HWND hwndMain, DisplayInfo* pDisplayInfo)
{
    TCHAR               sz[MAX_PATH];
    TCHAR               szTitle[MAX_PATH];

    LoadString(NULL, IDS_STARTD3DTEST, sz, MAX_PATH);
    LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);

    if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
        return;

    // Erase old D3D7 test results
    ZeroMemory(&pDisplayInfo->m_testResultD3D7, sizeof(TestResult));
    pDisplayInfo->m_testResultD3D7.m_bStarted = TRUE;

    // Erase old D3D8 test results
    ZeroMemory(&pDisplayInfo->m_testResultD3D8, sizeof(TestResult));
    pDisplayInfo->m_testResultD3D8.m_bStarted = TRUE;

    if( FALSE == BIsIA64() )
    {
        // First test (D3D7)
        LoadString(NULL, IDS_D3DTEST1, sz, MAX_PATH);
        if (IDCANCEL == MessageBox(hwndMain, sz, szTitle, MB_OKCANCEL))
        {
            pDisplayInfo->m_testResultD3D7.m_bCancelled = TRUE;
            goto LEnd;
        }
    
        // Run D3D7 test
        TestD3Dv7( TRUE, hwndMain, pDisplayInfo );
    
        if( pDisplayInfo->m_testResultD3D7.m_bCancelled ||
            pDisplayInfo->m_testResultD3D7.m_iStepThatFailed != 0 )
            goto LEnd;
    }
 
    // Second test (D3D8)
    LoadString(NULL, IDS_D3DTEST2, sz, MAX_PATH);
    if (IDCANCEL == MessageBox(hwndMain, sz, szTitle, MB_OKCANCEL))
    {
        pDisplayInfo->m_testResultD3D8.m_bCancelled = TRUE;
        goto LEnd;
    }

    // Run D3D8 test
    TestD3Dv8( TRUE, hwndMain, pDisplayInfo );

    if( pDisplayInfo->m_testResultD3D8.m_bCancelled ||
        pDisplayInfo->m_testResultD3D8.m_iStepThatFailed != 0 )
        goto LEnd;

LEnd:
    // Default to displaying results of D3D8 tests 
    pDisplayInfo->m_dwTestToDisplayD3D = 8;

    if (pDisplayInfo->m_testResultD3D7.m_bCancelled || pDisplayInfo->m_testResultD3D8.m_bCancelled)
    {
        LoadString(NULL, IDS_TESTSCANCELLED, sz, MAX_PATH);
        lstrcpy(pDisplayInfo->m_testResultD3D7.m_szDescription, sz);
        lstrcpy(pDisplayInfo->m_testResultD3D8.m_szDescription, sz);

        LoadString(NULL, IDS_TESTSCANCELLED_ENGLISH, sz, MAX_PATH);
        lstrcpy(pDisplayInfo->m_testResultD3D7.m_szDescriptionEnglish, sz);
        lstrcpy(pDisplayInfo->m_testResultD3D8.m_szDescriptionEnglish, sz);
    }
    else
    {
        if( pDisplayInfo->m_testResultD3D7.m_iStepThatFailed == 0 )
        {
            LoadString(NULL, IDS_TESTSSUCCESSFUL_ENGLISH, sz, MAX_PATH);
            lstrcpy(pDisplayInfo->m_testResultD3D7.m_szDescriptionEnglish, sz);
            
            LoadString(NULL, IDS_TESTSSUCCESSFUL, sz, MAX_PATH);
            lstrcpy(pDisplayInfo->m_testResultD3D7.m_szDescription, sz);
        }
        
        if( pDisplayInfo->m_testResultD3D8.m_iStepThatFailed == 0 )
        {
            LoadString(NULL, IDS_TESTSSUCCESSFUL, sz, MAX_PATH);
            lstrcpy(pDisplayInfo->m_testResultD3D8.m_szDescription, sz);
            
            LoadString(NULL, IDS_TESTSSUCCESSFUL_ENGLISH, sz, MAX_PATH);
            lstrcpy(pDisplayInfo->m_testResultD3D8.m_szDescriptionEnglish, sz);
        }
        
        if( pDisplayInfo->m_testResultD3D7.m_iStepThatFailed != 0 ||
            pDisplayInfo->m_testResultD3D8.m_iStepThatFailed != 0 )
        {
            TCHAR szDesc[MAX_PATH];
            TCHAR szError[MAX_PATH];
            TestResult* pFailedTestResult = NULL;

            if( pDisplayInfo->m_testResultD3D7.m_iStepThatFailed != 0 )
            {
                pFailedTestResult = &pDisplayInfo->m_testResultD3D7;
                pDisplayInfo->m_dwTestToDisplayD3D = 7;
            }
            else
            {
                pFailedTestResult = &pDisplayInfo->m_testResultD3D8;
                pDisplayInfo->m_dwTestToDisplayD3D = 8;
            }

            if (0 == LoadString(NULL, IDS_FIRSTD3DTESTERROR + pFailedTestResult->m_iStepThatFailed - 1,
                szDesc, MAX_PATH))
            {
                LoadString(NULL, IDS_UNKNOWNERROR, sz, MAX_PATH);
                lstrcpy(szDesc, sz);
            }
            LoadString(NULL, IDS_FAILUREFMT, sz, MAX_PATH);
            BTranslateError(pFailedTestResult->m_hr, szError);
            wsprintf(pFailedTestResult->m_szDescription, sz, 
                pFailedTestResult->m_iStepThatFailed,
                szDesc, pFailedTestResult->m_hr, szError);

            // Nonlocalized version:
            if (0 == LoadString(NULL, IDS_FIRSTD3DTESTERROR_ENGLISH + pFailedTestResult->m_iStepThatFailed - 1,
                szDesc, MAX_PATH))
            {
                LoadString(NULL, IDS_UNKNOWNERROR_ENGLISH, sz, MAX_PATH);
                lstrcpy(szDesc, sz);
            }
            LoadString(NULL, IDS_FAILUREFMT_ENGLISH, sz, MAX_PATH);
            BTranslateError(pFailedTestResult->m_hr, szError, TRUE);
            wsprintf(pFailedTestResult->m_szDescriptionEnglish, sz, 
                        pFailedTestResult->m_iStepThatFailed,
                        szDesc, pFailedTestResult->m_hr, szError);
        }
    }
}


/****************************************************************************
 *
 *  GetTxtPath
 *
 ****************************************************************************/
BOOL GetTxtPath( TCHAR* strTxtPath )
{
    HKEY hkey   = NULL;
    BOOL bFound = FALSE;
    DWORD ulType;
    DWORD cbData;

    // Get default user info from registry
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectX Diagnostic Tool"),
        0, KEY_READ, &hkey))
    {
        cbData = MAX_PATH;
        if( ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("TxtPath"), 0, &ulType, (LPBYTE)strTxtPath, &cbData ) )
            bFound = TRUE;

        RegCloseKey(hkey);
    }

    if( !bFound )
    {
        HKEY hkeyFolder;

        // Same as SHGetSpecialFolderPath( hwnd, szFilename, CSIDL_DESKTOPDIRECTORY, FALSE );
        if (ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
            0, KEY_READ, &hkeyFolder) ) 
        {
            cbData = MAX_PATH;
            if (ERROR_SUCCESS == RegQueryValueEx( hkeyFolder, TEXT("Desktop"), 0, &ulType, (LPBYTE)strTxtPath, &cbData ) )
                bFound = TRUE;

            RegCloseKey( hkeyFolder );
        }
    }

    return bFound;
}


/****************************************************************************
 *
 *  SetTxtPath
 *
 ****************************************************************************/
VOID SetTxtPath( TCHAR* strTxtPath )
{
    HKEY hkey = NULL;

    // Try to save user info into registry
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectX Diagnostic Tool"),
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL))
    {
        RegSetValueEx(hkey, TEXT("TxtPath"), 0, REG_SZ, (BYTE*)strTxtPath, sizeof(TCHAR)*(lstrlen(strTxtPath) + 1));

        RegCloseKey(hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\netinfo.cpp ===
/****************************************************************************
 *
 *    File: netinfo.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about DirectPlay
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <tchar.h>
#include <Windows.h>
#include <multimon.h>
#include <stdio.h>
#include <dplobby.h>
#include "resource.h"
#include "reginfo.h"
#include "sysinfo.h"
#include "dispinfo.h" // for TestResult
#include "fileinfo.h" // for GetFileVersion
#include "netinfo.h"

static HRESULT NewNetSP(NetInfo* pNetInfo, NetSP** ppNetSPNew);
static VOID DeleteNetSP(NetInfo* pNetInfo, NetSP* pNetSP);
static HRESULT NewNetApp(NetInfo* pNetInfo, NetApp** ppNetAppNew);
static HRESULT GetDX7ServiceProviders(NetInfo* pNetInfo);
static HRESULT GetDX8ServiceProviders(NetInfo* pNetInfo);
static HRESULT GetDX7LobbyableApps(NetInfo* pNetInfo);
static HRESULT GetDX8LobbyableApps(NetInfo* pNetInfo);
static BOOL ConvertStringToGUID(const WCHAR* strBuffer, GUID* lpguid);

/****************************************************************************
 *
 *  GetNetInfo
 *
 ****************************************************************************/
HRESULT GetNetInfo(SysInfo* pSysInfo, NetInfo** ppNetInfo)
{
    HRESULT hr = S_OK;
    NetInfo* pNetInfo;

    pNetInfo = new NetInfo;
    if (pNetInfo == NULL)
        return E_OUTOFMEMORY;
    *ppNetInfo = pNetInfo;
    ZeroMemory(pNetInfo, sizeof(NetInfo));

    if( FALSE == BIsIA64() )
    {
        if (FAILED(hr = GetDX7ServiceProviders(pNetInfo)))
            return hr;
        if (FAILED(hr = GetDX7LobbyableApps(pNetInfo)))
            return hr;
    }

    if( pSysInfo->m_dwDirectXVersionMajor >= 8 )
    {
        if (FAILED(hr = GetDX8ServiceProviders(pNetInfo)))
            return hr;
        if (FAILED(hr = GetDX8LobbyableApps(pNetInfo)))
            return hr;
    }

    return hr;
}


/****************************************************************************
 *
 *  NewNetSP
 *
 ****************************************************************************/
HRESULT NewNetSP(NetInfo* pNetInfo, NetSP** ppNetSPNew)
{
    NetSP* pNetSPNew;

    pNetSPNew = new NetSP;
    if (pNetSPNew == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(pNetSPNew, sizeof(NetSP));
    if (pNetInfo->m_pNetSPFirst == NULL)
    {
        pNetInfo->m_pNetSPFirst = pNetSPNew;
    }
    else
    {
        NetSP* pNetSP;
        for (pNetSP = pNetInfo->m_pNetSPFirst; 
            pNetSP->m_pNetSPNext != NULL; 
            pNetSP = pNetSP->m_pNetSPNext)
            {
            }
        pNetSP->m_pNetSPNext = pNetSPNew;
    }
    pNetSPNew->m_bRegistryOK = TRUE; // so far
    *ppNetSPNew = pNetSPNew;
    return S_OK;
}


/****************************************************************************
 *
 *  DeleteNetSP
 *
 ****************************************************************************/
VOID DeleteNetSP(NetInfo* pNetInfo, NetSP* pNetSP)
{
    NetSP* pNetSPPrev = NULL;
    NetSP* pNetSPCur;
    for (pNetSPCur = pNetInfo->m_pNetSPFirst; 
        pNetSPCur != NULL; 
        pNetSPCur = pNetSPCur->m_pNetSPNext)
    {
        if (pNetSPCur == pNetSP)
        {
            if (pNetSPPrev == NULL)
                pNetInfo->m_pNetSPFirst = pNetSPCur->m_pNetSPNext;
            else
                pNetSPPrev->m_pNetSPNext = pNetSPCur->m_pNetSPNext;
            delete pNetSPCur;
            return;
        }
        pNetSPPrev = pNetSPCur;
    }
}


/****************************************************************************
 *
 *  NewNetApp
 *
 ****************************************************************************/
HRESULT NewNetApp(NetInfo* pNetInfo, NetApp** ppNetAppNew)
{
    NetApp* pNetAppNew;

    pNetAppNew = new NetApp;
    if (pNetAppNew == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(pNetAppNew, sizeof(NetApp));
    if (pNetInfo->m_pNetAppFirst == NULL)
    {
        pNetInfo->m_pNetAppFirst = pNetAppNew;
    }
    else
    {
        NetApp* pNetApp;
        for (pNetApp = pNetInfo->m_pNetAppFirst; 
            pNetApp->m_pNetAppNext != NULL; 
            pNetApp = pNetApp->m_pNetAppNext)
            {
            }
        pNetApp->m_pNetAppNext = pNetAppNew;
    }
    pNetAppNew->m_bRegistryOK = TRUE; // so far
    *ppNetAppNew = pNetAppNew;
    return S_OK;
}


/****************************************************************************
 *
 *  GetDX7ServiceProviders
 *
 ****************************************************************************/
HRESULT GetDX7ServiceProviders(NetInfo* pNetInfo)
{
    HRESULT hr;
    HKEY hkey = NULL;
    HKEY hkey2 = NULL;
    DWORD dwIndex;
    DWORD dwBufferLen;
    BOOL bTCPIPFound = FALSE;
    BOOL bIPXFound = FALSE;
    BOOL bModemFound = FALSE;
    BOOL bSerialFound = FALSE;
    TCHAR szName[MAX_PATH+1];
    NetSP* pNetSPNew;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectPlay\\Service Providers"), 0, KEY_READ, &hkey))
    {
        dwIndex = 0;
        while (ERROR_SUCCESS == RegEnumKey(hkey, dwIndex, szName, MAX_PATH+1))
        {
            // Note: I'm not putting the following keyname strings into resources because 
            // they're supposed to be in English regardless of user's system (at least on DX6
            // and higher--see another note below).  If I put them into resources, they're 
            // more likely to get inadvertently localized.
            if (lstrcmpi(szName, TEXT("Internet TCP/IP Connection For DirectPlay")) == 0)
                bTCPIPFound = TRUE;
            else if (lstrcmpi(szName, TEXT("IPX Connection For DirectPlay")) == 0)
                bIPXFound = TRUE;
            else if (lstrcmpi(szName, TEXT("Modem Connection For DirectPlay")) == 0)
                bModemFound = TRUE;
            else if (lstrcmpi(szName, TEXT("Serial Connection For DirectPlay")) == 0)
                bSerialFound = TRUE;

            if (FAILED(hr = NewNetSP(pNetInfo, &pNetSPNew)))
            {
                RegCloseKey(hkey);
                return hr;
            }
            
            pNetSPNew->m_dwDXVer = 7;

            // The following line is the right thing to do on DX5, but in DX6 the
            // name will get overwritten by the "DescriptionW" / "DescriptionA" string.
            lstrcpy(pNetSPNew->m_szName, szName);
            lstrcpy(pNetSPNew->m_szNameEnglish, szName);

            if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szName, 0, KEY_READ, &hkey2))
            {
                // Get (localized) connection name, if it exists
                TCHAR szDescription[200];
                lstrcpy(szDescription, TEXT(""));
                dwBufferLen = 200;
                RegQueryValueEx(hkey2, 
                    // 25080: Always use DescriptionW because it's more localized
                    // than DescriptionA is.
                    TEXT("DescriptionW"), 
                    0, NULL, (LPBYTE)szDescription, &dwBufferLen);

                if (lstrlen(szDescription) > 0)
                    lstrcpy(pNetSPNew->m_szName, szDescription);

                dwBufferLen = 100;
                if (ERROR_SUCCESS == RegQueryValueEx(hkey2, TEXT("Guid"), 0, NULL, (LPBYTE)pNetSPNew->m_szGuid, &dwBufferLen))
                {
                    // On DX5, the names of the registry keys for "Internet TCP/IP Connection 
                    // For DirectPlay", etc. were localized, so we need to check GUIDs to avoid
                    // incorrectly thinking that some standard service providers are missing:
                    if (!bTCPIPFound &&
                        lstrcmpi(pNetSPNew->m_szGuid, TEXT("{36E95EE0-8577-11cf-960C-0080C7534E82}")) == 0)
                    {
                        bTCPIPFound = TRUE;
                    }
                    if (!bIPXFound &&
                        lstrcmpi(pNetSPNew->m_szGuid, TEXT("{685BC400-9D2C-11cf-A9CD-00AA006886E3}")) == 0)
                    {
                        bIPXFound = TRUE;
                    }
                    if (!bModemFound &&
                        lstrcmpi(pNetSPNew->m_szGuid, TEXT("{44EAA760-CB68-11cf-9C4E-00A0C905425E}")) == 0)
                    {
                        bModemFound = TRUE;
                    }
                    if (!bSerialFound &&
                        lstrcmpi(pNetSPNew->m_szGuid, TEXT("{0F1D6860-88D9-11cf-9C4E-00A0C905425E}")) == 0)
                    {
                        bSerialFound = TRUE;
                    }

                    // If a non-English DX5 system was upgraded to DX6, it will have BOTH localized
                    // and non-localized keynames for each service provider.  The DX6 ones have
                    // "DescriptionA" and "DescriptionW" strings
                    // If a SP with this GUID has already been enumerated, replace it with the current
                    // one if the current one has a description.  Otherwise forget about the current
                    // one.
                    NetSP* pNetSPSearch;
                    BOOL bFound = FALSE;
                    for (pNetSPSearch = pNetInfo->m_pNetSPFirst; pNetSPSearch != NULL; pNetSPSearch = pNetSPSearch->m_pNetSPNext)
                    {
                        if (pNetSPSearch == pNetSPNew)
                            continue;
                        if (lstrcmp(pNetSPSearch->m_szGuid, pNetSPNew->m_szGuid) == 0)
                        {
                            bFound = TRUE;
                            break;
                        }
                    }
                    if (bFound)
                    {
                        if (lstrlen(szDescription) > 0)
                        {
                            // Current SP is better, nuke old one
                            DeleteNetSP(pNetInfo, pNetSPSearch);
                        }
                        else
                        {
                            // Old SP is (probably) better, nuke current one
                            DeleteNetSP(pNetInfo, pNetSPNew);
                            goto LDoneWithSubKey;
                        }
                    }
                }
                else
                {
                    pNetSPNew->m_bRegistryOK = FALSE;
                }
                
                TCHAR szPath[MAX_PATH];
                TCHAR* pszFile;
                dwBufferLen = MAX_PATH;
                if (ERROR_SUCCESS == RegQueryValueEx(hkey2, TEXT("Path"), 0, NULL, (LPBYTE)szPath, &dwBufferLen))
                {
                    // On Win9x, szPath is full path.  On NT, it's leaf only.
                    pszFile = _tcsrchr(szPath, TEXT('\\'));
                    if (pszFile == NULL)
                    {
                        lstrcpy(pNetSPNew->m_szFile, szPath);
                        GetSystemDirectory(pNetSPNew->m_szPath, MAX_PATH);
                        lstrcat(pNetSPNew->m_szPath, TEXT("\\"));
                        lstrcat(pNetSPNew->m_szPath, szPath);
                    }
                    else
                    {
                        lstrcpy(pNetSPNew->m_szPath, szPath);
                        lstrcpy(pNetSPNew->m_szFile, pszFile + 1); // skip backslash
                    }

                    WIN32_FIND_DATA findFileData;
                    HANDLE hFind = FindFirstFile(pNetSPNew->m_szPath, &findFileData);
                    if (hFind == INVALID_HANDLE_VALUE)
                    {
                        pNetSPNew->m_bFileMissing = TRUE;
                        LoadString(NULL, IDS_FILEMISSING, pNetSPNew->m_szVersion, 50);
                        LoadString(NULL, IDS_FILEMISSING_ENGLISH, pNetSPNew->m_szVersionEnglish, 50);
                    }
                    else
                    {
                        FindClose(hFind);
                        GetFileVersion(pNetSPNew->m_szPath, pNetSPNew->m_szVersion, 
                            NULL, NULL, NULL);
                        GetFileVersion(pNetSPNew->m_szPath, pNetSPNew->m_szVersionEnglish, 
                            NULL, NULL, NULL);
                    }
                }
                else
                {
                    pNetSPNew->m_bRegistryOK = FALSE;
                }
LDoneWithSubKey:                
                RegCloseKey(hkey2);
            }
            else
            {
                pNetSPNew->m_bRegistryOK = FALSE;
            }
            dwIndex++;
        }
        
        RegCloseKey(hkey);
    }

    if (!bTCPIPFound)
    {
        if (FAILED(hr = NewNetSP(pNetInfo, &pNetSPNew)))
            return hr;
        lstrcpy(pNetSPNew->m_szName, TEXT("Internet TCP/IP Connection For DirectPlay"));
        lstrcpy(pNetSPNew->m_szNameEnglish, TEXT("Internet TCP/IP Connection For DirectPlay"));
        pNetSPNew->m_bRegistryOK = FALSE;
    }
    if (!bIPXFound)
    {
        if (FAILED(hr = NewNetSP(pNetInfo, &pNetSPNew)))
            return hr;
        lstrcpy(pNetSPNew->m_szName, TEXT("IPX Connection For DirectPlay"));
        lstrcpy(pNetSPNew->m_szNameEnglish, TEXT("IPX Connection For DirectPlay"));
        pNetSPNew->m_bRegistryOK = FALSE;
    }
    if (!bModemFound)
    {
        if (FAILED(hr = NewNetSP(pNetInfo, &pNetSPNew)))
            return hr;
        lstrcpy(pNetSPNew->m_szName, TEXT("Modem Connection For DirectPlay"));
        lstrcpy(pNetSPNew->m_szNameEnglish, TEXT("Modem Connection For DirectPlay"));
        pNetSPNew->m_bRegistryOK = FALSE;
    }
    if (!bSerialFound)
    {
        if (FAILED(hr = NewNetSP(pNetInfo, &pNetSPNew)))
            return hr;
        lstrcpy(pNetSPNew->m_szName, TEXT("Serial Connection For DirectPlay"));
        lstrcpy(pNetSPNew->m_szNameEnglish, TEXT("Serial Connection For DirectPlay"));
        pNetSPNew->m_bRegistryOK = FALSE;
    }

    return S_OK;
}


/****************************************************************************
 *
 *  GetDX8ServiceProviders
 *
 ****************************************************************************/
HRESULT GetDX8ServiceProviders(NetInfo* pNetInfo)
{
    HRESULT hr;
    HKEY hkey = NULL;
    HKEY hkey2 = NULL;
    HKEY hkeyDLL = NULL;
    DWORD dwIndex;
    DWORD dwBufferLen;
    BOOL bTCPIPFound = FALSE;
    BOOL bIPXFound = FALSE;
    BOOL bModemFound = FALSE;
    BOOL bSerialFound = FALSE;
    TCHAR szName[MAX_PATH+1];
    NetSP* pNetSPNew;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectPlay8\\Service Providers"), 0, KEY_READ, &hkey))
    {
        dwIndex = 0;
        while (ERROR_SUCCESS == RegEnumKey(hkey, dwIndex, szName, MAX_PATH+1))
        {
            if (FAILED(hr = NewNetSP(pNetInfo, &pNetSPNew)))
            {
                RegCloseKey(hkey);
                return hr;
            }
            
            pNetSPNew->m_dwDXVer = 8;

            if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szName, 0, KEY_READ, &hkey2))
            {
                TCHAR szDescription[200];
                lstrcpy(szDescription, TEXT(""));
                TCHAR szEnglishDescription[200];

                dwBufferLen = 200;
                if (ERROR_SUCCESS == RegQueryValueEx( hkey2, TEXT("Friendly Name"), 0, NULL, (LPBYTE)szDescription, &dwBufferLen) )
                {
                }
                else
                {
                    pNetSPNew->m_bRegistryOK = FALSE;
                }

                lstrcpy(szEnglishDescription, szDescription);

                dwBufferLen = 100;
                if (ERROR_SUCCESS == RegQueryValueEx(hkey2, TEXT("GUID"), 0, NULL, (LPBYTE)pNetSPNew->m_szGuid, &dwBufferLen))
                {
                    WCHAR strBuffer[MAX_PATH];
#ifdef _UNICODE
                    wcscpy( strBuffer, pNetSPNew->m_szGuid );
#else
                    MultiByteToWideChar( CP_ACP, 0, pNetSPNew->m_szGuid, -1, 
                                         strBuffer, _tcslen(pNetSPNew->m_szGuid) );
#endif
                    ConvertStringToGUID( strBuffer, &pNetSPNew->m_guid );
                }
                else
                {
                    pNetSPNew->m_bRegistryOK = FALSE;
                }

                TCHAR szRegKey[200];
                wsprintf( szRegKey, TEXT("CLSID\\%s\\InprocServer32"), pNetSPNew->m_szGuid );
                if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szRegKey, 0, KEY_READ, &hkeyDLL))
                {
                    if (ERROR_SUCCESS == RegQueryValueEx(hkeyDLL, NULL, 0, NULL, (LPBYTE)pNetSPNew->m_szFile, &dwBufferLen))
                    {
                        GetSystemDirectory(pNetSPNew->m_szPath, MAX_PATH);
                        lstrcat(pNetSPNew->m_szPath, TEXT("\\"));
                        lstrcat(pNetSPNew->m_szPath, pNetSPNew->m_szFile);

                        WIN32_FIND_DATA findFileData;
                        HANDLE hFind = FindFirstFile(pNetSPNew->m_szPath, &findFileData);
                        if (hFind == INVALID_HANDLE_VALUE)
                        {
                            pNetSPNew->m_bFileMissing = TRUE;
                            LoadString(NULL, IDS_FILEMISSING, pNetSPNew->m_szVersion, 50);
                            LoadString(NULL, IDS_FILEMISSING_ENGLISH, pNetSPNew->m_szVersionEnglish, 50);
                        }
                        else
                        {
                            FindClose(hFind);
                            GetFileVersion(pNetSPNew->m_szPath, pNetSPNew->m_szVersion, 
                                NULL, NULL, NULL);
                            GetFileVersion(pNetSPNew->m_szPath, pNetSPNew->m_szVersionEnglish, 
                                NULL, NULL, NULL);
                        }
                    }
                    else
                    {
                        pNetSPNew->m_bRegistryOK = FALSE;
                    }

                    RegCloseKey(hkeyDLL);
                }
                else
                {
                    pNetSPNew->m_bRegistryOK = FALSE;
                }

                
                if (!bTCPIPFound &&
                    lstrcmpi(pNetSPNew->m_szGuid, TEXT("{EBFE7BA0-628D-11D2-AE0F-006097B01411}")) == 0)
                {
                    if( lstrcmpi(pNetSPNew->m_szFile, TEXT("dpnwsock.dll") ) != 0)
                        pNetSPNew->m_bRegistryOK = FALSE;

                    lstrcpy( szEnglishDescription, TEXT("DirectPlay8 TCP/IP Service Provider") );
                    bTCPIPFound = TRUE;
                }

                if (!bIPXFound &&
                    lstrcmpi(pNetSPNew->m_szGuid, TEXT("{53934290-628D-11D2-AE0F-006097B01411}")) == 0)
                {
                    if( lstrcmpi(pNetSPNew->m_szFile, TEXT("dpnwsock.dll") ) != 0)
                        pNetSPNew->m_bRegistryOK = FALSE;

                    lstrcpy( szEnglishDescription, TEXT("DirectPlay8 IPX Service Provider") );
                    bIPXFound = TRUE;
                }
                if (!bModemFound &&
                    lstrcmpi(pNetSPNew->m_szGuid, TEXT("{6D4A3650-628D-11D2-AE0F-006097B01411}")) == 0)
                {
                    if( lstrcmpi(pNetSPNew->m_szFile, TEXT("dpnmodem.dll") ) != 0)
                        pNetSPNew->m_bRegistryOK = FALSE;

                    lstrcpy( szEnglishDescription, TEXT("DirectPlay8 Modem Service Provider") );
                    bModemFound = TRUE;
                }
                if (!bSerialFound &&
                    lstrcmpi(pNetSPNew->m_szGuid, TEXT("{743B5D60-628D-11D2-AE0F-006097B01411}")) == 0)
                {
                    if( lstrcmpi(pNetSPNew->m_szFile, TEXT("dpnmodem.dll") ) != 0)
                        pNetSPNew->m_bRegistryOK = FALSE;

                    lstrcpy( szEnglishDescription, TEXT("DirectPlay8 Serial Service Provider") );
                    bSerialFound = TRUE;
                }

                lstrcpy(pNetSPNew->m_szName, szDescription);
                lstrcpy(pNetSPNew->m_szNameEnglish, szEnglishDescription);

                RegCloseKey(hkey2);
            }
            else
            {
                pNetSPNew->m_bRegistryOK = FALSE;
            }
            dwIndex++;
        }
        
        RegCloseKey(hkey);
    }

    if (!bTCPIPFound)
    {
        if (FAILED(hr = NewNetSP(pNetInfo, &pNetSPNew)))
            return hr;
        lstrcpy(pNetSPNew->m_szName, TEXT("DirectPlay8 TCP/IP Service Provider"));
        lstrcpy(pNetSPNew->m_szNameEnglish, TEXT("DirectPlay8 TCP/IP Service Provider"));
        pNetSPNew->m_bRegistryOK = FALSE;
    }
    if (!bIPXFound)
    {
        if (FAILED(hr = NewNetSP(pNetInfo, &pNetSPNew)))
            return hr;
        lstrcpy(pNetSPNew->m_szName, TEXT("DirectPlay8 IPX Service Provider"));
        lstrcpy(pNetSPNew->m_szNameEnglish, TEXT("DirectPlay8 IPX Service Provider"));
        pNetSPNew->m_bRegistryOK = FALSE;
    }
    if (!bModemFound)
    {
        if (FAILED(hr = NewNetSP(pNetInfo, &pNetSPNew)))
            return hr;
        lstrcpy(pNetSPNew->m_szName, TEXT("DirectPlay8 Modem Service Provider"));
        lstrcpy(pNetSPNew->m_szNameEnglish, TEXT("DirectPlay8 Modem Service Provider"));
        pNetSPNew->m_bRegistryOK = FALSE;
    }
    if (!bSerialFound)
    {
        if (FAILED(hr = NewNetSP(pNetInfo, &pNetSPNew)))
            return hr;
        lstrcpy(pNetSPNew->m_szName, TEXT("DirectPlay8 Serial Service Provider"));
        lstrcpy(pNetSPNew->m_szNameEnglish, TEXT("DirectPlay8 Serial Service Provider"));
        pNetSPNew->m_bRegistryOK = FALSE;
    }

    return S_OK;
}


/****************************************************************************
 *
 *  GetDX7LobbyableApps
 *
 ****************************************************************************/
HRESULT GetDX7LobbyableApps(NetInfo* pNetInfo)
{
    HRESULT hr;
    HKEY hkey = NULL;
    HKEY hkey2 = NULL;
    DWORD dwIndex;
    DWORD dwBufferLen;
    TCHAR szName[MAX_PATH+1];
    NetApp* pNetAppNew;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectPlay\\Applications"), 0, KEY_READ, &hkey))
    {
        dwIndex = 0;
        while (ERROR_SUCCESS == RegEnumKey(hkey, dwIndex, szName, MAX_PATH+1))
        {
            BOOL bSkip = FALSE;

            // Bug 37989: skip any dplay app that has the DPLAPP_NOENUM flag set.
            if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szName, 0, KEY_READ, &hkey2))
            {
                dwBufferLen = MAX_PATH;
                DWORD dwFlags = 0;
                dwBufferLen = sizeof(DWORD);
                DWORD dwType = 0;
                RegQueryValueEx(hkey2, TEXT("dwFlags"), 0, &dwType, (LPBYTE)&dwFlags, &dwBufferLen);
                if( (dwFlags & DPLAPP_NOENUM) != 0 )
                    bSkip = TRUE;
                RegCloseKey(hkey2);
            }

            if( bSkip )
            {
                dwIndex++;
                continue;
            }

            if (FAILED(hr = NewNetApp(pNetInfo, &pNetAppNew)))
            {
                RegCloseKey(hkey);
                return hr;
            }
            lstrcpy(pNetAppNew->m_szName, szName);
            pNetAppNew->m_dwDXVer = 7;
            
            if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szName, 0, KEY_READ, &hkey2))
            {
                dwBufferLen = MAX_PATH;
                if (ERROR_SUCCESS == RegQueryValueEx(hkey2, TEXT("Path"), 0, NULL, (LPBYTE)pNetAppNew->m_szExePath, &dwBufferLen))
                {
                }
                else
                {
                    pNetAppNew->m_bRegistryOK = FALSE;
                }
                dwBufferLen = 100;
                if (ERROR_SUCCESS == RegQueryValueEx(hkey2, TEXT("File"), 0, NULL, (LPBYTE)pNetAppNew->m_szExeFile, &dwBufferLen))
                {
                    lstrcat(pNetAppNew->m_szExePath, TEXT("\\"));
                    lstrcat(pNetAppNew->m_szExePath, pNetAppNew->m_szExeFile);

                    WIN32_FIND_DATA findFileData;
                    HANDLE hFind = FindFirstFile(pNetAppNew->m_szExePath, &findFileData);
                    if (hFind == INVALID_HANDLE_VALUE)
                    {
                        pNetAppNew->m_bFileMissing = TRUE;
                        LoadString(NULL, IDS_FILEMISSING, pNetAppNew->m_szExeVersion, 50);
                        LoadString(NULL, IDS_FILEMISSING, pNetAppNew->m_szExeVersionEnglish, 50);
                    }
                    else
                    {
                        FindClose(hFind);
                        GetFileVersion(pNetAppNew->m_szExePath, pNetAppNew->m_szExeVersion, 
                            NULL, NULL, NULL);
                        GetFileVersion(pNetAppNew->m_szExePath, pNetAppNew->m_szExeVersionEnglish, 
                            NULL, NULL, NULL);
                    }
                }
                else
                {
                    pNetAppNew->m_bRegistryOK = FALSE;
                }
                dwBufferLen = 100;
                if (ERROR_SUCCESS == RegQueryValueEx(hkey2, TEXT("Guid"), 0, NULL, (LPBYTE)pNetAppNew->m_szGuid, &dwBufferLen))
                {
                }
                else
                {
                    pNetAppNew->m_bRegistryOK = FALSE;
                }

                RegCloseKey(hkey2);
            }
            else
            {
                pNetAppNew->m_bRegistryOK = FALSE;
            }
            dwIndex++;
        }
        
        RegCloseKey(hkey);
    }

    return S_OK;
}


/****************************************************************************
 *
 *  GetDX8LobbyableApps
 *
 ****************************************************************************/
HRESULT GetDX8LobbyableApps(NetInfo* pNetInfo)
{
    HRESULT hr;
    HKEY hkey = NULL;
    HKEY hkey2 = NULL;
    DWORD dwIndex;
    DWORD dwBufferLen;
    TCHAR szGuid[MAX_PATH+1];
    NetApp* pNetAppNew;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectPlay8\\Applications"), 0, KEY_READ, &hkey))
    {
        dwIndex = 0;
        while (ERROR_SUCCESS == RegEnumKey(hkey, dwIndex, szGuid, MAX_PATH+1))
        {
            if (FAILED(hr = NewNetApp(pNetInfo, &pNetAppNew)))
            {
                RegCloseKey(hkey);
                return hr;
            }
            lstrcpy(pNetAppNew->m_szGuid, szGuid);
            pNetAppNew->m_dwDXVer = 8;
            
            if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szGuid, 0, KEY_READ, &hkey2))
            {
                dwBufferLen = MAX_PATH;
                if (ERROR_SUCCESS == RegQueryValueEx(hkey2, TEXT("ExecutablePath"), 0, NULL, (LPBYTE)pNetAppNew->m_szExePath, &dwBufferLen))
                {
                }
                else
                {
                    pNetAppNew->m_bRegistryOK = FALSE;
                }
                dwBufferLen = 100;
                if (ERROR_SUCCESS == RegQueryValueEx(hkey2, TEXT("ExecutableFilename"), 0, NULL, (LPBYTE)pNetAppNew->m_szExeFile, &dwBufferLen))
                {
                    lstrcat(pNetAppNew->m_szExePath, TEXT("\\"));
                    lstrcat(pNetAppNew->m_szExePath, pNetAppNew->m_szExeFile);

                    WIN32_FIND_DATA findFileData;
                    HANDLE hFind = FindFirstFile(pNetAppNew->m_szExePath, &findFileData);
                    if (hFind == INVALID_HANDLE_VALUE)
                    {
                        pNetAppNew->m_bFileMissing = TRUE;
                        LoadString(NULL, IDS_FILEMISSING, pNetAppNew->m_szExeVersion, 50);
                        LoadString(NULL, IDS_FILEMISSING, pNetAppNew->m_szExeVersionEnglish, 50);
                    }
                    else
                    {
                        FindClose(hFind);
                        GetFileVersion(pNetAppNew->m_szExePath, pNetAppNew->m_szExeVersion, 
                            NULL, NULL, NULL);
                        GetFileVersion(pNetAppNew->m_szExePath, pNetAppNew->m_szExeVersionEnglish, 
                            NULL, NULL, NULL);
                    }
                }
                else
                {
                    pNetAppNew->m_bRegistryOK = FALSE;
                }


                dwBufferLen = MAX_PATH;
                if (ERROR_SUCCESS == RegQueryValueEx(hkey2, TEXT("LauncherPath"), 0, NULL, (LPBYTE)pNetAppNew->m_szLauncherPath, &dwBufferLen))
                {
                }
                else
                {
                    pNetAppNew->m_bRegistryOK = FALSE;
                }
                dwBufferLen = 100;
                if (ERROR_SUCCESS == RegQueryValueEx(hkey2, TEXT("LauncherFilename"), 0, NULL, (LPBYTE)pNetAppNew->m_szLauncherFile, &dwBufferLen))
                {
                    lstrcat(pNetAppNew->m_szLauncherPath, TEXT("\\"));
                    lstrcat(pNetAppNew->m_szLauncherPath, pNetAppNew->m_szLauncherFile);

                    WIN32_FIND_DATA findFileData;
                    HANDLE hFind = FindFirstFile(pNetAppNew->m_szLauncherPath, &findFileData);
                    if (hFind == INVALID_HANDLE_VALUE)
                    {
                        pNetAppNew->m_bFileMissing = TRUE;
                        LoadString(NULL, IDS_FILEMISSING, pNetAppNew->m_szLauncherVersion, 50);
                        LoadString(NULL, IDS_FILEMISSING, pNetAppNew->m_szLauncherVersionEnglish, 50);
                    }
                    else
                    {
                        FindClose(hFind);
                        GetFileVersion(pNetAppNew->m_szExePath, pNetAppNew->m_szLauncherVersion, 
                            NULL, NULL, NULL);
                        GetFileVersion(pNetAppNew->m_szExePath, pNetAppNew->m_szLauncherVersionEnglish, 
                            NULL, NULL, NULL);
                    }
                }
                else
                {
                    pNetAppNew->m_bRegistryOK = FALSE;
                }


                dwBufferLen = 100;
                if (ERROR_SUCCESS == RegQueryValueEx(hkey2, TEXT("ApplicationName"), 0, NULL, (LPBYTE)pNetAppNew->m_szName, &dwBufferLen))
                {
                }
                else
                {
                    pNetAppNew->m_bRegistryOK = FALSE;
                }

                RegCloseKey(hkey2);
            }
            else
            {
                pNetAppNew->m_bRegistryOK = FALSE;
            }
            dwIndex++;
        }
        
        RegCloseKey(hkey);
    }

    return S_OK;
}


/****************************************************************************
 *
 *  DestroyNetInfo
 *
 ****************************************************************************/
VOID DestroyNetInfo(NetInfo* pNetInfo)
{
    if( pNetInfo )
    {
        NetSP* pNetSP;
        NetSP* pNetSPNext;

        for (pNetSP = pNetInfo->m_pNetSPFirst; pNetSP != NULL; 
            pNetSP = pNetSPNext)
        {
            pNetSPNext = pNetSP->m_pNetSPNext;
            delete pNetSP;
        }

        NetApp* pNetApp;
        NetApp* pNetAppNext;

        for (pNetApp = pNetInfo->m_pNetAppFirst; pNetApp != NULL; 
            pNetApp = pNetAppNext)
        {
            pNetAppNext = pNetApp->m_pNetAppNext;
            delete pNetApp;
        }

        delete pNetInfo;
    }
}


/****************************************************************************
 *
 *  DiagnoseNetInfo
 *
 ****************************************************************************/
VOID DiagnoseNetInfo(SysInfo* pSysInfo, NetInfo* pNetInfo)
{
    NetSP* pNetSP;
    NetApp* pNetApp;
    TCHAR szMessage[500];
    TCHAR szFmt[500];
    BOOL bProblem = FALSE;
    BOOL bShouldReinstall = FALSE;

    _tcscpy( pSysInfo->m_szNetworkNotes, TEXT("") );
    _tcscpy( pSysInfo->m_szNetworkNotesEnglish, TEXT("") );

    // Report any problems
    if( pNetInfo != NULL )
    {
        for (pNetSP = pNetInfo->m_pNetSPFirst; pNetSP != NULL; pNetSP = pNetSP->m_pNetSPNext)
        {
            if (!pNetSP->m_bRegistryOK)
            {
                LoadString(NULL, IDS_SPREGISTRYERRORFMT, szFmt, 500);
                wsprintf(szMessage, szFmt, pNetSP->m_szName);
                _tcscat(pSysInfo->m_szNetworkNotes, szMessage);

                LoadString(NULL, IDS_SPREGISTRYERRORFMT_ENGLISH, szFmt, 500);
                wsprintf(szMessage, szFmt, pNetSP->m_szName);
                _tcscat(pSysInfo->m_szNetworkNotesEnglish, szMessage);

                pNetSP->m_bProblem = TRUE;
                bProblem = TRUE;
                bShouldReinstall = TRUE;
            }
            else if (pNetSP->m_bFileMissing)
            {
                LoadString(NULL, IDS_FILEMISSING, pNetSP->m_szVersion, 50);
                LoadString(NULL, IDS_SPFILEMISSINGFMT, szFmt, 500);
                wsprintf(szMessage, szFmt, pNetSP->m_szFile, pNetSP->m_szName);
                _tcscat(pSysInfo->m_szNetworkNotes, szMessage);

                LoadString(NULL, IDS_FILEMISSING_ENGLISH, pNetSP->m_szVersion, 50);
                LoadString(NULL, IDS_SPFILEMISSINGFMT_ENGLISH, szFmt, 500);
                wsprintf(szMessage, szFmt, pNetSP->m_szFile, pNetSP->m_szName);
                _tcscat(pSysInfo->m_szNetworkNotesEnglish, szMessage);

                pNetSP->m_bProblem = TRUE;
                bShouldReinstall = TRUE;
                bProblem = TRUE;
            }
        }
        for (pNetApp = pNetInfo->m_pNetAppFirst; pNetApp != NULL; pNetApp = pNetApp->m_pNetAppNext)
        {
            if (!pNetApp->m_bRegistryOK)
            {
                LoadString(NULL, IDS_APPREGISTRYERRORFMT, szFmt, 500);
                wsprintf(szMessage, szFmt, pNetApp->m_szName);
                _tcscat(pSysInfo->m_szNetworkNotes, szMessage);

                LoadString(NULL, IDS_APPREGISTRYERRORFMT_ENGLISH, szFmt, 500);
                wsprintf(szMessage, szFmt, pNetApp->m_szName);
                _tcscat(pSysInfo->m_szNetworkNotesEnglish, szMessage);

                pNetApp->m_bProblem = TRUE;
                bProblem = TRUE;
            }
    /* 26298: Don't scare users with this warning...it's usually harmless:
            else if (pNetApp->m_bFileMissing)
            {
                LoadString(NULL, IDS_FILEMISSING, pNetApp->m_szVersion, 50);
                LoadString(NULL, IDS_APPFILEMISSINGFMT, szFmt, 500);
                wsprintf(szMessage, szFmt, pNetApp->m_szFile, pNetApp->m_szName);
                _tcscat(pSysInfo->m_szNetworkNotes, szMessage);
                pNetApp->m_bProblem = TRUE;
                bProblem = TRUE;
            }
    */
        }
    }
    else
    {
        bProblem = TRUE;
        bShouldReinstall = TRUE;
    }

    if( bShouldReinstall )
    {
        BOOL bTellUser = FALSE;

        // Figure out if the user can install DirectX
        if( BIsPlatform9x() )
            bTellUser = TRUE;
        else if( BIsWin2k() && pSysInfo->m_dwDirectXVersionMajor >= 8 )
            bTellUser = TRUE;

        if( bTellUser )
        {
            LoadString(NULL, IDS_REINSTALL_DX, szMessage, 500);
            _tcscat( pSysInfo->m_szNetworkNotes, szMessage);

            LoadString(NULL, IDS_REINSTALL_DX_ENGLISH, szMessage, 500);
            _tcscat( pSysInfo->m_szNetworkNotesEnglish, szMessage);
        }
    }

    if (!bProblem)
    {
        LoadString(NULL, IDS_NOPROBLEM, szMessage, 500);
        _tcscat(pSysInfo->m_szNetworkNotes, szMessage);

        LoadString(NULL, IDS_NOPROBLEM_ENGLISH, szMessage, 500);
        _tcscat(pSysInfo->m_szNetworkNotesEnglish, szMessage);
    }

    // Show test results or instructions to run test:
    if (pNetInfo && pNetInfo->m_testResult.m_bStarted)
    {
        LoadString(NULL, IDS_DPLAYRESULTS, szMessage, 500);
        _tcscat( pSysInfo->m_szNetworkNotes, szMessage );
        _tcscat( pSysInfo->m_szNetworkNotes, pNetInfo->m_testResult.m_szDescription );
        _tcscat( pSysInfo->m_szNetworkNotes, TEXT("\r\n") );

        LoadString(NULL, IDS_DPLAYRESULTS_ENGLISH, szMessage, 500);
        _tcscat( pSysInfo->m_szNetworkNotesEnglish, szMessage );
        _tcscat( pSysInfo->m_szNetworkNotesEnglish, pNetInfo->m_testResult.m_szDescriptionEnglish );
        _tcscat( pSysInfo->m_szNetworkNotesEnglish, TEXT("\r\n") );
    }
    else
    {
        LoadString(NULL, IDS_DPLAYINSTRUCTIONS, szMessage, 500);
        _tcscat(pSysInfo->m_szNetworkNotes, szMessage);

        LoadString(NULL, IDS_DPLAYINSTRUCTIONS_ENGLISH, szMessage, 500);
        _tcscat(pSysInfo->m_szNetworkNotesEnglish, szMessage);
    }
}


/****************************************************************************
 *
 *  ConvertStringToGUID
 *
 ****************************************************************************/
BOOL ConvertStringToGUID(const WCHAR* strBuffer, GUID* lpguid)
{
    UINT aiTmp[10];

    if( swscanf( strBuffer, L"{%8X-%4X-%4X-%2X%2X-%2X%2X%2X%2X%2X%2X}",
                    &lpguid->Data1, 
                    &aiTmp[0], &aiTmp[1], 
                    &aiTmp[2], &aiTmp[3],
                    &aiTmp[4], &aiTmp[5],
                    &aiTmp[6], &aiTmp[7],
                    &aiTmp[8], &aiTmp[9] ) != 11 )
    {
    	ZeroMemory(lpguid, sizeof(GUID));
        return FALSE;
    }
    else
    {
        lpguid->Data2       = (USHORT) aiTmp[0];
        lpguid->Data3       = (USHORT) aiTmp[1];
        lpguid->Data4[0]    = (BYTE) aiTmp[2];
        lpguid->Data4[1]    = (BYTE) aiTmp[3];
        lpguid->Data4[2]    = (BYTE) aiTmp[4];
        lpguid->Data4[3]    = (BYTE) aiTmp[5];
        lpguid->Data4[4]    = (BYTE) aiTmp[6];
        lpguid->Data4[5]    = (BYTE) aiTmp[7];
        lpguid->Data4[6]    = (BYTE) aiTmp[8];
        lpguid->Data4[7]    = (BYTE) aiTmp[9];
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\mmddk.h ===
/****************************************************************************/
/*                                                                          */
/*      MMDDK.H - Include file for Multimedia Device Development Kit        */
/*                                                                          */
/*      Note: You must include the WINDOWS.H and MMSYSTEM.H header files    */
/*            before including this file.                                   */
/*                                                                          */
/*      Copyright (c) 1990-1998, Microsoft Corp.  All rights reserved.      */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MMDDK
#define _INC_MMDDK

#include "pshpack1.h"   // Assume byte packing throughout

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*    If defined, the following flags inhibit inclusion
 *    of the indicated items:
 *
 *        MMNOMIDIDEV         - MIDI support
 *        MMNOWAVEDEV         - Waveform support
 *        MMNOAUXDEV          - Auxiliary output support
 *        MMNOMIXERDEV        - Mixer support
 *        MMNOTIMERDEV        - Timer support
 *        MMNOJOYDEV          - Joystick support
 *        MMNOMCIDEV          - MCI support
 *        MMNOTASKDEV         - Task support
 */
#ifdef MMNOTIMER
  #define MMNOTIMERDEV
#endif
#ifdef MMNOWAVE
  #define MMNOWAVEDEV
#endif
#ifdef MMNOMIDI
  #define MMNOMIDIDEV
#endif
#ifdef MMNOAUX
  #define MMNOAUXDEV
#endif
#ifdef MMNOJOY
  #define MMNOJOYDEV
#endif
#ifdef MMNOMMIO
  #define MMNOMMIODEV
#endif
#ifdef MMNOMCI
  #define MMNOMCIDEV
#endif


/***************************************************************************

                       Helper functions for drivers

***************************************************************************/

#ifndef NODRIVERS
#define DRV_LOAD               0x0001
#define DRV_ENABLE             0x0002
#define DRV_OPEN               0x0003
#define DRV_CLOSE              0x0004
#define DRV_DISABLE            0x0005
#define DRV_FREE               0x0006
#define DRV_CONFIGURE          0x0007
#define DRV_QUERYCONFIGURE     0x0008
#define DRV_INSTALL            0x0009
#define DRV_REMOVE             0x000A

#define DRV_RESERVED           0x0800
#define DRV_USER               0x4000

#define DRIVERS_SECTION  TEXT("DRIVERS32")     // Section name for installed drivers
#define MCI_SECTION      TEXT("MCI32")         // Section name for installed MCI drivers

#endif /* !NODRIVERS */

#define DCB_NOSWITCH   0x0008           // don't switch stacks for callback
#define DCB_TYPEMASK   0x0007           // callback type mask
#define DCB_NULL       0x0000           // unknown callback type

// flags for wFlags parameter of DriverCallback()
#define DCB_WINDOW     0x0001           // dwCallback is a HWND
#define DCB_TASK       0x0002           // dwCallback is a HTASK
#define DCB_FUNCTION   0x0003           // dwCallback is a FARPROC
#define DCB_EVENT      0x0005           // dwCallback is an EVENT

BOOL APIENTRY DriverCallback(DWORD_PTR dwCallback, DWORD dwFlags,
    HDRVR hDevice, DWORD dwMsg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

// generic prototype for audio device driver entry-point functions
// midMessage(), modMessage(), widMessage(), wodMessage(), auxMessage()
//typedef DWORD (SOUNDDEVMSGPROC)(WORD, WORD, DWORD, DWORD, DWORD);
//typedef SOUNDDEVMSGPROC FAR *LPSOUNDDEVMSGPROC;

#define DRVM_INIT               100
#define DRVM_EXIT               101
#define DRVM_DISABLE            102
#define DRVM_ENABLE             103


// message base for driver specific messages.
//
#define DRVM_MAPPER             0x2000
#define DRVM_USER               0x4000
#define DRVM_MAPPER_STATUS      (DRVM_MAPPER+0)
#define DRVM_MAPPER_RECONFIGURE (DRVM_MAPPER+1)
#define	DRVM_MAPPER_QUERYDEST	                  (DRVM_MAPPER+20) /* ;Internal*/
#define DRVM_MAPPER_PREFERRED_GET                 (DRVM_MAPPER+21)
#define DRVM_MAPPER_PREFERRED_SET                 (DRVM_MAPPER+22) /* ;Internal*/

#define DRV_QUERYDRVENTRY            (DRV_RESERVED + 1)         /* ;Internal*/
#define DRV_QUERYDEVNODE             (DRV_RESERVED + 2)         /* ;Internal*/
#define DRV_QUERYNAME                (DRV_RESERVED + 3)         /* ;Internal*/
#define DRV_QUERYDRIVERIDS           (DRV_RESERVED + 4)         /* ;Internal*/
#define DRV_QUERYMAPPABLE            (DRV_RESERVED + 5)         /* ;Internal*/
#define DRV_QUERYMAPID               (DRV_RESERVED + 6)         /* ;Internal*/
#define DRV_QUERYNUMPORTS            (DRV_RESERVED + 8)         /* ;Internal*/
#define DRV_QUERYMODULE              (DRV_RESERVED + 9)
#define DRV_QUERYFILENAME            (DRV_RESERVED + 10)        /* ;Internal*/
#define DRV_PNPINSTALL               (DRV_RESERVED + 11)
#define DRV_QUERYDEVICEINTERFACE     (DRV_RESERVED + 12)        /* ;Internal*/
#define DRV_QUERYDEVICEINTERFACESIZE (DRV_RESERVED + 13)        /* ;Internal*/

//
// DRVM_MAPPER_PREFERRED_GET flags
//
#define DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY   0x00000001



//
// messages that have IOCTL format
//    dw1 = NULL or handle
//    dw2 = NULL or ptr to DRVM_IOCTL_DATA
//    return is MMRESULT
//
#define DRVM_IOCTL                0x100
#define DRVM_ADD_THRU             (DRVM_IOCTL+1)
#define DRVM_REMOVE_THRU          (DRVM_IOCTL+2)
#define DRVM_IOCTL_LAST           (DRVM_IOCTL+5)

typedef struct {
    DWORD  dwSize; // size of this structure (inclusive)
    DWORD  dwCmd;  // IOCTL command code, 0x80000000 and above reserved for system
    } DRVM_IOCTL_DATA, FAR * LPDRVM_IOCTL_DATA;

// command code ranges for dwCmd field of DRVM_IOCTL message
// codes from 0 to 0x7FFFFFFF are user defined
// codes from 0x80000000 to 0xFFFFFFFF are reserved for future
// definition by microsoft
//
#define DRVM_IOCTL_CMD_USER   0x00000000L
#define DRVM_IOCTL_CMD_SYSTEM 0x80000000L

// device ID for 386 AUTODMA VxD
#define VADMAD_Device_ID    0X0444

/* PnP version of media device caps */
typedef struct {
    DWORD	cbSize;
    LPVOID	pCaps;
} MDEVICECAPSEX;

#ifndef MMNOWAVEDEV
/****************************************************************************

                       Waveform device driver support

****************************************************************************/

// maximum number of wave device drivers loaded
#ifndef NOWIN31
#define MAXWAVEDRIVERS 10
#else
#define MAXWAVEDRIVERS 4
#endif

#define WODM_INIT      DRVM_INIT
#define WIDM_INIT      DRVM_INIT

// waveform input and output device open information structure
typedef struct waveopendesc_tag {
    HWAVE          hWave;             // handle
    LPWAVEFORMAT   lpFormat;          // format of wave data
    DWORD_PTR      dwCallback;        // callback
    DWORD_PTR      dwInstance;        // app's private instance information
    UINT           uMappedDeviceID;   // device to map to if WAVE_MAPPED set
    DWORD_PTR      dnDevNode;         /* if device is PnP */
} WAVEOPENDESC;
typedef WAVEOPENDESC FAR *LPWAVEOPENDESC;

// messages sent to wodMessage() entry-point function
#define WODM_GETNUMDEVS       3
#define WODM_GETDEVCAPS       4
#define WODM_OPEN             5
#define WODM_CLOSE            6
#define WODM_PREPARE          7
#define WODM_UNPREPARE        8
#define WODM_WRITE            9
#define WODM_PAUSE            10
#define WODM_RESTART          11
#define WODM_RESET            12
#define WODM_GETPOS           13
#define WODM_GETPITCH         14
#define WODM_SETPITCH         15
#define WODM_GETVOLUME        16
#define WODM_SETVOLUME        17
#define WODM_GETPLAYBACKRATE  18
#define WODM_SETPLAYBACKRATE  19
#define WODM_BREAKLOOP        20
// #if (WINVER >= 0x030B)
#define WODM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEOUT_MAPPER_STATUS_DEVICE    0
#define WAVEOUT_MAPPER_STATUS_MAPPED    1
#define WAVEOUT_MAPPER_STATUS_FORMAT    2
// #endif /* WINVER >= 0x030B */
#define WODM_BUSY             21

// messages sent to widMessage() entry-point function
#define WIDM_GETNUMDEVS  50
#define WIDM_GETDEVCAPS  51
#define WIDM_OPEN        52
#define WIDM_CLOSE       53
#define WIDM_PREPARE     54
#define WIDM_UNPREPARE   55
#define WIDM_ADDBUFFER   56
#define WIDM_START       57
#define WIDM_STOP        58
#define WIDM_RESET       59
#define WIDM_GETPOS      60
// #if (WINVER >= 0x030B)
#define WIDM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEIN_MAPPER_STATUS_DEVICE     0
#define WAVEIN_MAPPER_STATUS_MAPPED     1
#define WAVEIN_MAPPER_STATUS_FORMAT     2
// #endif /* WINVER >= 0x30B */

#endif // ifndef MMNOWAVEDEV


#ifndef MMNOMIDIDEV
/****************************************************************************

                          MIDI device driver support

****************************************************************************/

// maximum number of MIDI device drivers loaded
#ifndef NOWIN31
#define MAXMIDIDRIVERS 10
#else
#define MAXMIDIDRIVERS 4
#endif

#define MODM_USER      DRVM_USER
#define MIDM_USER      DRVM_USER
#define MODM_MAPPER    DRVM_MAPPER
#define MIDM_MAPPER    DRVM_MAPPER

#define MODM_INIT      DRVM_INIT
#define MIDM_INIT      DRVM_INIT

#ifndef MMNOMIDI   // This protects the definition of HMIDI in WINMM.H
                   // Win 3.1 works the same way
typedef struct midiopenstrmid_tag {
    DWORD          dwStreamID;
    UINT           uDeviceID;
} MIDIOPENSTRMID;
// MIDI input and output device open information structure
typedef struct midiopendesc_tag {
    HMIDI          hMidi;             // handle
    DWORD_PTR      dwCallback;        // callback
    DWORD_PTR      dwInstance;        // app's private instance information
    DWORD_PTR      dnDevNode;         // DevNode
    DWORD          cIds;              // If stream open, # stream ids
    MIDIOPENSTRMID rgIds[1];          // Array of device ID's (actually [cIds])
} MIDIOPENDESC;
typedef MIDIOPENDESC FAR *LPMIDIOPENDESC;
#endif // MMNOMIDI


/* Flags for MODM_OPEN */
#define MIDI_IO_PACKED      0x00000000L     /* Compatibility mode */
#define MIDI_IO_COOKED      0x00000002L

// messages sent to modMessage() entry-point function
#define MODM_GETNUMDEVS     1
#define MODM_GETDEVCAPS     2
#define MODM_OPEN           3
#define MODM_CLOSE          4
#define MODM_PREPARE        5
#define MODM_UNPREPARE      6
#define MODM_DATA           7
#define MODM_LONGDATA       8
#define MODM_RESET          9
#define MODM_GETVOLUME      10
#define MODM_SETVOLUME      11
#define MODM_CACHEPATCHES       12
#define MODM_CACHEDRUMPATCHES   13

#if (WINVER >= 0x400)
#define MODM_STRMDATA               14
#define MODM_GETPOS                 17
#define MODM_PAUSE                  18
#define MODM_RESTART                19
#define MODM_STOP                   20
#define MODM_PROPERTIES             21
#define MODM_RECONFIGURE            (MODM_USER+0x0768)
#endif


// messages sent to midMessage() entry-point function
#define MIDM_GETNUMDEVS  53
#define MIDM_GETDEVCAPS  54
#define MIDM_OPEN        55
#define MIDM_CLOSE       56
#define MIDM_PREPARE     57
#define MIDM_UNPREPARE   58
#define MIDM_ADDBUFFER   59
#define MIDM_START       60
#define MIDM_STOP        61
#define MIDM_RESET       62

#endif // ifndef MMNOMIDIDEV


#ifndef MMNOAUXDEV
/****************************************************************************

                    Auxiliary audio device driver support

****************************************************************************/

// maximum number of auxiliary device drivers loaded
#ifndef NOWIN31
#define MAXAUXDRIVERS 10
#else
#define MAXAUXDRIVERS 4
#endif

#define AUXM_INIT      DRVM_INIT

// messages sent to auxMessage() entry-point function
#define AUXDM_GETNUMDEVS    3
#define AUXDM_GETDEVCAPS    4
#define AUXDM_GETVOLUME     5
#define AUXDM_SETVOLUME     6

#endif // ifndef MMNOAUXDEV

// #if (WINVER >= 0x030B)
#ifndef MMNOMIXERDEV

#ifndef MAXMIXERDRIVERS

//
//  maximum number of mixer drivers that can be loaded by MSMIXMGR.DLL
//
#define MAXMIXERDRIVERS     10


//
//  mixer device open information structure
//
//
typedef struct tMIXEROPENDESC
{
    HMIXER          hmx;            // handle that will be used
    LPVOID          pReserved0;     // reserved--driver should ignore
    DWORD_PTR       dwCallback;     // callback
    DWORD_PTR       dwInstance;     // app's private instance information
    DWORD_PTR       dnDevNode;      // if device is PnP

} MIXEROPENDESC, *PMIXEROPENDESC, FAR *LPMIXEROPENDESC;



//
//
//
//
#define MXDM_INIT                   100
#define MXDM_USER                   DRV_USER

#define MXDM_BASE                   (1)
#define MXDM_GETNUMDEVS             (MXDM_BASE + 0)
#define MXDM_GETDEVCAPS             (MXDM_BASE + 1)
#define MXDM_OPEN                   (MXDM_BASE + 2)
#define MXDM_CLOSE                  (MXDM_BASE + 3)
#define MXDM_GETLINEINFO            (MXDM_BASE + 4)
#define MXDM_GETLINECONTROLS        (MXDM_BASE + 5)
#define MXDM_GETCONTROLDETAILS      (MXDM_BASE + 6)
#define MXDM_SETCONTROLDETAILS      (MXDM_BASE + 7)

#endif // MAXMIXERDRIVERS

#endif // MMNOMIXERDEV
// #endif /* ifdef WINVER >= 0x030B */

#if !defined(MMNOTIMERDEV)
/****************************************************************************

                        Timer device driver support

****************************************************************************/

typedef struct timerevent_tag {
    WORD                wDelay;         // delay required
    WORD                wResolution;    // resolution required
    LPTIMECALLBACK      lpFunction;     // ptr to callback function
    DWORD               dwUser;         // user DWORD
    WORD                wFlags;         // defines how to program event
    WORD                wReserved1;     // structure packing
} TIMEREVENT;
typedef TIMEREVENT FAR *LPTIMEREVENT;

// messages sent to tddMessage() function
#define TDD_KILLTIMEREVENT  (DRV_RESERVED+0)  // indices into a table of
#define TDD_SETTIMEREVENT   (DRV_RESERVED+4)  // functions; thus offset by
#define TDD_GETSYSTEMTIME   (DRV_RESERVED+8)  // four each time...
#define TDD_GETDEVCAPS      (DRV_RESERVED+12) // room for future expansion
#define TDD_BEGINMINPERIOD  (DRV_RESERVED+16) // room for future expansion
#define TDD_ENDMINPERIOD    (DRV_RESERVED+20) // room for future expansion

#endif // ifndef MMNOTIMERDEV


#ifndef MMNOJOYDEV
/****************************************************************************

                       Joystick device driver support

****************************************************************************/

/* RegisterWindowMessage with this to get msg id of config changes */
#define JOY_CONFIGCHANGED_MSGSTRING     "MSJSTICK_VJOYD_MSGSTR"

/* pre-defined joystick types */
#define JOY_HW_NONE                     0
#define JOY_HW_CUSTOM                   1
#define JOY_HW_2A_2B_GENERIC            2
#define JOY_HW_2A_4B_GENERIC            3
#define JOY_HW_2B_GAMEPAD               4
#define JOY_HW_2B_FLIGHTYOKE            5
#define JOY_HW_2B_FLIGHTYOKETHROTTLE    6
#define JOY_HW_3A_2B_GENERIC            7
#define JOY_HW_3A_4B_GENERIC            8
#define JOY_HW_4B_GAMEPAD               9
#define JOY_HW_4B_FLIGHTYOKE            10
#define JOY_HW_4B_FLIGHTYOKETHROTTLE    11
#define JOY_HW_LASTENTRY                12

/* calibration flags */
#define JOY_ISCAL_XY            0x00000001l     /* XY are calibrated */
#define JOY_ISCAL_Z             0x00000002l     /* Z is calibrated */
#define JOY_ISCAL_R             0x00000004l     /* R is calibrated */
#define JOY_ISCAL_U             0x00000008l     /* U is calibrated */
#define JOY_ISCAL_V             0x00000010l     /* V is calibrated */
#define JOY_ISCAL_POV           0x00000020l     /* POV is calibrated */

/* point of view constants */
#define JOY_POV_NUMDIRS          4
#define JOY_POVVAL_FORWARD       0
#define JOY_POVVAL_BACKWARD      1
#define JOY_POVVAL_LEFT          2
#define JOY_POVVAL_RIGHT         3

/* Specific settings for joystick hardware */
#define JOY_HWS_HASZ            0x00000001l     /* has Z info? */
#define JOY_HWS_HASPOV          0x00000002l     /* point of view hat present */
#define JOY_HWS_POVISBUTTONCOMBOS 0x00000004l   /* pov done through combo of buttons */
#define JOY_HWS_POVISPOLL       0x00000008l     /* pov done through polling */
#define JOY_HWS_ISYOKE          0x00000010l     /* joystick is a flight yoke */
#define JOY_HWS_ISGAMEPAD       0x00000020l     /* joystick is a game pad */
#define JOY_HWS_ISCARCTRL       0x00000040l     /* joystick is a car controller */
/* X defaults to J1 X axis */
#define JOY_HWS_XISJ1Y          0x00000080l     /* X is on J1 Y axis */
#define JOY_HWS_XISJ2X          0x00000100l     /* X is on J2 X axis */
#define JOY_HWS_XISJ2Y          0x00000200l     /* X is on J2 Y axis */
/* Y defaults to J1 Y axis */
#define JOY_HWS_YISJ1X          0x00000400l     /* Y is on J1 X axis */
#define JOY_HWS_YISJ2X          0x00000800l     /* Y is on J2 X axis */
#define JOY_HWS_YISJ2Y          0x00001000l     /* Y is on J2 Y axis */
/* Z defaults to J2 Y axis */
#define JOY_HWS_ZISJ1X          0x00002000l     /* Z is on J1 X axis */
#define JOY_HWS_ZISJ1Y          0x00004000l     /* Z is on J1 Y axis */
#define JOY_HWS_ZISJ2X          0x00008000l     /* Z is on J2 X axis */
/* POV defaults to J2 Y axis, if it is not button based */
#define JOY_HWS_POVISJ1X        0x00010000l     /* pov done through J1 X axis */
#define JOY_HWS_POVISJ1Y        0x00020000l     /* pov done through J1 Y axis */
#define JOY_HWS_POVISJ2X        0x00040000l     /* pov done through J2 X axis */
/* R defaults to J2 X axis */
#define JOY_HWS_HASR            0x00080000l     /* has R (4th axis) info */
#define JOY_HWS_RISJ1X          0x00100000l     /* R done through J1 X axis */
#define JOY_HWS_RISJ1Y          0x00200000l     /* R done through J1 Y axis */
#define JOY_HWS_RISJ2Y          0x00400000l     /* R done through J2 X axis */
/* U & V for future hardware */
#define JOY_HWS_HASU            0x00800000l     /* has U (5th axis) info */
#define JOY_HWS_HASV            0x01000000l     /* has V (6th axis) info */

/* Usage settings */
#define JOY_US_HASRUDDER        0x00000001l     /* joystick configured with rudder */
#define JOY_US_PRESENT          0x00000002l     /* is joystick actually present? */
#define JOY_US_ISOEM            0x00000004l     /* joystick is an OEM defined type */

/* struct for storing x,y, z, and rudder values */
typedef struct joypos_tag {
    DWORD       dwX;
    DWORD       dwY;
    DWORD       dwZ;
    DWORD       dwR;
    DWORD       dwU;
    DWORD       dwV;
} JOYPOS, FAR *LPJOYPOS;

/* struct for storing ranges */
typedef struct joyrange_tag {
    JOYPOS      jpMin;
    JOYPOS      jpMax;
    JOYPOS      jpCenter;
} JOYRANGE,FAR *LPJOYRANGE;

typedef struct joyreguservalues_tag {
    DWORD       dwTimeOut;      /* value at which to timeout joystick polling */
    JOYRANGE    jrvRanges;      /* range of values app wants returned for axes */
    JOYPOS      jpDeadZone;     /* area around center to be considered
                                   as "dead". specified as a percentage
                                   (0-100). Only X & Y handled by system driver */
} JOYREGUSERVALUES, FAR *LPJOYREGUSERVALUES;

typedef struct joyreghwsettings_tag {
    DWORD       dwFlags;
    DWORD       dwNumButtons;           /* number of buttons */
} JOYREGHWSETTINGS, FAR *LPJOYHWSETTINGS;

/* range of values returned by the hardware (filled in by calibration) */
typedef struct joyreghwvalues_tag {
    JOYRANGE    jrvHardware;            /* values returned by hardware */
    DWORD       dwPOVValues[JOY_POV_NUMDIRS];/* POV values returned by hardware */
    DWORD       dwCalFlags;             /* what has been calibrated */
} JOYREGHWVALUES, FAR *LPJOYREGHWVALUES;

/* hardware configuration */
typedef struct joyreghwconfig_tag {
    JOYREGHWSETTINGS    hws;            /* hardware settings */
    DWORD               dwUsageSettings;/* usage settings */
    JOYREGHWVALUES      hwv;            /* values returned by hardware */
    DWORD               dwType;         /* type of joystick */
    DWORD               dwReserved;     /* reserved for OEM drivers */
} JOYREGHWCONFIG, FAR *LPJOYREGHWCONFIG;

// joystick calibration info structure
typedef struct joycalibrate_tag {
    WORD    wXbase;
    WORD    wXdelta;
    WORD    wYbase;
    WORD    wYdelta;
    WORD    wZbase;
    WORD    wZdelta;
} JOYCALIBRATE;
typedef JOYCALIBRATE FAR *LPJOYCALIBRATE;

// prototype for joystick message function
typedef DWORD (JOYDEVMSGPROC)(DWORD, UINT, LONG, LONG);
typedef JOYDEVMSGPROC FAR *LPJOYDEVMSGPROC;

// messages sent to joystick driver's DriverProc() function
#define JDD_GETNUMDEVS          (DRV_RESERVED + 0x0001)
#define JDD_GETDEVCAPS          (DRV_RESERVED + 0x0002)
#define JDD_GETPOS              (DRV_RESERVED + 0x0101)
#define JDD_SETCALIBRATION      (DRV_RESERVED + 0x0102)
#define JDD_CONFIGCHANGED       (DRV_RESERVED + 0x0103)
#define JDD_GETPOSEX            (DRV_RESERVED + 0x0104)

#endif // ifndef MMNOJOYDEV

#ifndef MAKELRESULT
#define MAKELRESULT(low, high)   ((LRESULT)MAKELONG(low, high))
#endif//MAKELRESULT


#ifndef MMNOMCIDEV
/****************************************************************************

                        MCI device driver support

****************************************************************************/


// internal MCI messages
#define MCI_OPEN_DRIVER             0x0801
#define MCI_CLOSE_DRIVER            0x0802

#define MAKEMCIRESOURCE(wRet, wRes) MAKELRESULT((wRet), (wRes))

// string return values only used with MAKEMCIRESOURCE
#define MCI_FALSE                       (MCI_STRING_OFFSET + 19)
#define MCI_TRUE                        (MCI_STRING_OFFSET + 20)

// resource string return values
#define MCI_FORMAT_RETURN_BASE          MCI_FORMAT_MILLISECONDS_S
#define MCI_FORMAT_MILLISECONDS_S       (MCI_STRING_OFFSET + 21)
#define MCI_FORMAT_HMS_S                (MCI_STRING_OFFSET + 22)
#define MCI_FORMAT_MSF_S                (MCI_STRING_OFFSET + 23)
#define MCI_FORMAT_FRAMES_S             (MCI_STRING_OFFSET + 24)
#define MCI_FORMAT_SMPTE_24_S           (MCI_STRING_OFFSET + 25)
#define MCI_FORMAT_SMPTE_25_S           (MCI_STRING_OFFSET + 26)
#define MCI_FORMAT_SMPTE_30_S           (MCI_STRING_OFFSET + 27)
#define MCI_FORMAT_SMPTE_30DROP_S       (MCI_STRING_OFFSET + 28)
#define MCI_FORMAT_BYTES_S              (MCI_STRING_OFFSET + 29)
#define MCI_FORMAT_SAMPLES_S            (MCI_STRING_OFFSET + 30)
#define MCI_FORMAT_TMSF_S               (MCI_STRING_OFFSET + 31)

#define MCI_VD_FORMAT_TRACK_S           (MCI_VD_OFFSET + 5)

#define WAVE_FORMAT_PCM_S               (MCI_WAVE_OFFSET + 0)
#define WAVE_MAPPER_S                   (MCI_WAVE_OFFSET + 1)

#define MCI_SEQ_MAPPER_S                (MCI_SEQ_OFFSET + 5)
#define MCI_SEQ_FILE_S                  (MCI_SEQ_OFFSET + 6)
#define MCI_SEQ_MIDI_S                  (MCI_SEQ_OFFSET + 7)
#define MCI_SEQ_SMPTE_S                 (MCI_SEQ_OFFSET + 8)
#define MCI_SEQ_FORMAT_SONGPTR_S        (MCI_SEQ_OFFSET + 9)
#define MCI_SEQ_NONE_S                  (MCI_SEQ_OFFSET + 10)
#define MIDIMAPPER_S                    (MCI_SEQ_OFFSET + 11)

#define MCI_TABLE_NOT_PRESENT   ((UINT)-1)
// parameters for internal version of MCI_OPEN message sent from
// mciOpenDevice() to the driver
typedef struct {
    MCIDEVICEID wDeviceID;             // device ID
    LPCWSTR     lpstrParams;           // parameter string for entry in SYSTEM.INI
    UINT        wCustomCommandTable;   // custom command table ((-1) if none)
                                       // filled in by the driver
    UINT        wType;                 // driver type
                                       // filled in by the driver
} MCI_OPEN_DRIVER_PARMS;
typedef MCI_OPEN_DRIVER_PARMS FAR * LPMCI_OPEN_DRIVER_PARMS;

// maximum length of an MCI device type
#define MCI_MAX_DEVICE_TYPE_LENGTH 80

// flags for mciSendCommandInternal() which direct mciSendString() how to
// interpret the return value
#define MCI_RESOURCE_RETURNED       0x00010000  // resource ID
#define MCI_COLONIZED3_RETURN       0x00020000  // colonized ID, 3 bytes data
#define MCI_COLONIZED4_RETURN       0x00040000  // colonized ID, 4 bytes data
#define MCI_INTEGER_RETURNED        0x00080000  // integer conversion needed
#define MCI_RESOURCE_DRIVER         0x00100000  // driver owns returned resource

// invalid command table ID
#define MCI_NO_COMMAND_TABLE    ((UINT)(-1))

// command table information type tags
#define MCI_COMMAND_HEAD        0
#define MCI_STRING              1
#define MCI_INTEGER             2
#define MCI_END_COMMAND         3
#define MCI_RETURN              4
#define MCI_FLAG                5
#define MCI_END_COMMAND_LIST    6
#define MCI_RECT                7
#define MCI_CONSTANT            8
#define MCI_END_CONSTANT        9
#define MCI_HWND               10
#define MCI_HPAL               11
#define MCI_HDC                12

// function prototypes for MCI driver functions
DWORD_PTR APIENTRY mciGetDriverData(MCIDEVICEID wDeviceID);
BOOL      APIENTRY mciSetDriverData(MCIDEVICEID wDeviceID, DWORD_PTR dwData);
UINT      APIENTRY mciDriverYield (MCIDEVICEID wDeviceID);
BOOL      APIENTRY mciDriverNotify (HANDLE hwndCallback, MCIDEVICEID wDeviceID,
    UINT uStatus);
UINT  APIENTRY mciLoadCommandResource(HANDLE hInstance,
    LPCWSTR lpResName, UINT wType);
BOOL  APIENTRY mciFreeCommandResource(UINT wTable);

#endif // ifndef MMNOMCIDEV


#ifndef MMNOTASKDEV
/*****************************************************************************

                               Task support

*****************************************************************************/

// error return values
#define TASKERR_NOTASKSUPPORT 1
#define TASKERR_OUTOFMEMORY   2

// task support function prototypes
typedef VOID (TASKCALLBACK) (DWORD dwInst);

typedef TASKCALLBACK FAR *LPTASKCALLBACK;

UINT    APIENTRY mmTaskCreate(LPTASKCALLBACK lpfn, HANDLE FAR * lph, DWORD_PTR dwInst);
VOID    APIENTRY mmTaskBlock(DWORD h);
BOOL    APIENTRY mmTaskSignal(DWORD h);
VOID    APIENTRY mmTaskYield(VOID);
DWORD   APIENTRY mmGetCurrentTask(VOID);

#endif // endif MMNOTASKDEV

#define MMDDKINC

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include "poppack.h"        /* Revert to default packing */

#endif /* _INC_MMDDK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\musinfo.h ===
/****************************************************************************
 *
 *    File: musinfo.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about DirectMusic
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef MUSINFO_H
#define MUSINFO_H

// DXD_IN_DM_VALUE is the name of a value stored under the registry key 
// HKLM\DXD_IN_DM_KEY that indicates that DxDiag is using
// DirectMusic.  If DxDiag starts up and this value exists, DxDiag 
// probably crashed in DirectMusic and DxDiag should offer to run without
// using DirectMusic.
#define DXD_IN_DM_KEY TEXT("Software\\Microsoft\\DirectX Diagnostic Tool")
#define DXD_IN_DM_VALUE TEXT("DxDiag In DirectMusic")

struct MusicPort
{
    GUID m_guid;
    BOOL m_bSoftware;
    BOOL m_bKernelMode;
    BOOL m_bUsesDLS;
    BOOL m_bExternal;
    DWORD m_dwMaxAudioChannels;
    DWORD m_dwMaxChannelGroups;
    BOOL m_bDefaultPort;
    BOOL m_bOutputPort;
    TCHAR m_szDescription[300];
    MusicPort* m_pMusicPortNext;
};

struct MusicInfo
{
    BOOL m_bDMusicInstalled;
    MusicPort* m_pMusicPortFirst;
    TCHAR m_szGMFilePath[MAX_PATH]; 
    TCHAR m_szGMFileVersion[100];
    GUID m_guidMusicPortTest; // This holds the GUID of the music port selected for testing
    BOOL m_bAccelerationEnabled;
    BOOL m_bAccelerationExists;
    RegError* m_pRegErrorFirst;
    TestResult m_testResult; // This is filled in by testmus.cpp
};

HRESULT GetBasicMusicInfo(MusicInfo** ppMusicInfo);
HRESULT GetExtraMusicInfo(MusicInfo* pMusicInfo);
VOID DestroyMusicInfo(MusicInfo* pMusicInfo);
VOID DiagnoseMusic(SysInfo* pSysInfo, MusicInfo* pMusicInfo);

#endif // DISPINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\netinfo.h ===
/****************************************************************************
 *
 *    File: netinfo.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about DirectPlay
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef NETINFO_H
#define NETINFO_H

// DXD_IN_DP_VALUE is the name of a value stored under the registry key 
// HKLM\DXD_IN_DP_KEY that indicates that DxDiag is using
// DirectPlay.  If DxDiag starts up and this value exists, DxDiag 
// probably crashed in DirectPlay and DxDiag should offer to run without
// using DirectPlay.
#define DXD_IN_DP_KEY TEXT("Software\\Microsoft\\DirectX Diagnostic Tool")
#define DXD_IN_DP_VALUE TEXT("DxDiag In DirectPlay")

struct NetSP
{
    TCHAR m_szName[200];
    TCHAR m_szNameEnglish[200];
    TCHAR m_szGuid[100];
    TCHAR m_szFile[100];
    TCHAR m_szPath[MAX_PATH];
    TCHAR m_szVersion[50];
    TCHAR m_szVersionEnglish[50];
    BOOL m_bRegistryOK;
    BOOL m_bProblem;
    BOOL m_bFileMissing;
    BOOL m_bInstalled;
    DWORD m_dwDXVer;
    GUID m_guid;
    NetSP* m_pNetSPNext;
};

struct NetApp
{
    TCHAR m_szName[200];
    TCHAR m_szGuid[100];
    TCHAR m_szExeFile[100];
    TCHAR m_szExePath[MAX_PATH];
    TCHAR m_szExeVersion[50];
    TCHAR m_szExeVersionEnglish[50];
    TCHAR m_szLauncherFile[100];
    TCHAR m_szLauncherPath[MAX_PATH];
    TCHAR m_szLauncherVersion[50];
    TCHAR m_szLauncherVersionEnglish[50];
    BOOL m_bRegistryOK;
    BOOL m_bProblem;
    BOOL m_bFileMissing;
    DWORD m_dwDXVer;
    NetApp* m_pNetAppNext;
};

struct NetInfo
{
    NetSP* m_pNetSPFirst;
    NetApp* m_pNetAppFirst;
    TestResult m_testResult; // This is filled in by testnet.cpp
};

HRESULT GetNetInfo(SysInfo* pSysInfo, NetInfo** ppNetInfo);
VOID DestroyNetInfo(NetInfo* pNetInfo);
VOID DiagnoseNetInfo(SysInfo* pSysInfo, NetInfo* pNetInfo);

#endif // NETINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\musinfo.cpp ===
/****************************************************************************
 *
 *    File: musinfo.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about DirectMusic
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <tchar.h>
#include <Windows.h>
#include <multimon.h>
#include <dmusicc.h>
#include <dmusici.h>
#include <stdio.h> // for sscanf
#include "reginfo.h"
#include "sysinfo.h"
#include "dispinfo.h" // for TestResult
#include "fileinfo.h" // for GetFileVersion
#include "musinfo.h"
#include "resource.h"

static BOOL DoesDMHWAccelExist(IDirectMusic* pdm);
static BOOL IsDMHWAccelEnabled(VOID);
static HRESULT CheckRegistry(RegError** ppRegErrorFirst);

/****************************************************************************
 *
 *  GetBasicMusicInfo - Just create the MusicInfo object and note whether
 *      a valid installation of DirectMusic is present.
 *
 ****************************************************************************/
HRESULT GetBasicMusicInfo(MusicInfo** ppMusicInfo)
{
    HRESULT hr = S_OK;
    MusicInfo* pMusicInfoNew;
    TCHAR szPath[MAX_PATH];
    TCHAR szVersion[100];
    DWORD dwMajor;
    DWORD dwMinor;
    DWORD dwRevision;
    DWORD dwBuild;
    
    pMusicInfoNew = new MusicInfo;
    if (pMusicInfoNew == NULL)
        return E_OUTOFMEMORY;
    *ppMusicInfo = pMusicInfoNew;
    ZeroMemory(pMusicInfoNew, sizeof(MusicInfo));

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\dmusic.dll"));

    WIN32_FIND_DATA findFileData;
    HANDLE hFind = FindFirstFile(szPath, &findFileData);
    if (hFind != INVALID_HANDLE_VALUE)
    {
        FindClose(hFind);
        // Only accept DX 6.1 or higher, since tests fail on 6.0's DirectMusic:
        if (SUCCEEDED(hr = GetFileVersion(szPath, szVersion, NULL, NULL, NULL)))
        {
            _stscanf(szVersion, TEXT("%d.%d.%d.%d"), &dwMajor, &dwMinor, &dwRevision, &dwBuild);
            if (dwMajor > 4 || 
                dwMajor >= 4 && dwMinor > 6 ||
                dwMajor >= 4 && dwMinor >= 6 && dwRevision >= 2)
            {
                pMusicInfoNew->m_bDMusicInstalled = TRUE;
                return S_OK;
            }
        }
    }
    return hr;
}


/****************************************************************************
 *
 *  GetExtraMusicInfo - Get details of all ports, default port, and DLS path.
 *
 ****************************************************************************/
HRESULT GetExtraMusicInfo(MusicInfo* pMusicInfo)
{
    HRESULT hr = S_OK;
    IDirectMusic* pdm = NULL;
    LONG iPort;
    DMUS_PORTCAPS portCaps;
    MusicPort* pMusicPortNew = NULL;
    MusicPort* pMusicPort = NULL;
    GUID guidDefaultPort;

    if (pMusicInfo == NULL)
        return E_FAIL;

    BOOL bWasDisabled = FALSE;
    HKEY hkey = NULL;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwData;

    // See if HW is disabled in registry, and if so, re-enable it (briefly)
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        TEXT("SOFTWARE\\Microsoft\\DirectMusic"), 0, KEY_ALL_ACCESS, &hkey))
    {
        dwSize = sizeof(dwData);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("DisableHWAcceleration"), NULL, &dwType, (BYTE *)&dwData, &dwSize))
        {
            if (dwData != 0)
            {
                bWasDisabled = TRUE;
                dwData = FALSE; // enable (un-disable) HW
                RegSetValueEx(hkey, TEXT("DisableHWAcceleration"), NULL, 
                    REG_DWORD, (BYTE *)&dwData, sizeof(dwData));
            }
        }
        // note: don't close hkey until end of function
    }

    // Initialize COM
    if (FAILED(hr = CoInitialize(NULL)))
        return hr;

    if (FAILED(hr = CoCreateInstance(CLSID_DirectMusic, NULL, CLSCTX_INPROC, 
        IID_IDirectMusic, (VOID**)&pdm)))
    {
        goto LEnd;
    }

    pMusicInfo->m_bAccelerationExists = DoesDMHWAccelExist(pdm);

    if (bWasDisabled)
    {
        // re-disable HW
        dwData = TRUE; // disable HW
        RegSetValueEx(hkey, TEXT("DisableHWAcceleration"), NULL, 
            REG_DWORD, (BYTE *)&dwData, sizeof(dwData));
    }
    if (hkey != NULL)
        RegCloseKey(hkey);

    pMusicInfo->m_bAccelerationEnabled = IsDMHWAccelEnabled();

    // Get default port
    if (FAILED(hr = pdm->GetDefaultPort(&guidDefaultPort)))
        goto LEnd;

    iPort = 0;
    portCaps.dwSize = sizeof(portCaps);
    while (TRUE)
    {
        hr = pdm->EnumPort(iPort, &portCaps);
        if (hr == S_FALSE)
            break;
        if (FAILED(hr))
            goto LEnd;

        pMusicPortNew = new MusicPort;
        if (pMusicPortNew == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto LEnd;
        }
        ZeroMemory(pMusicPortNew, sizeof(MusicPort));
        if (guidDefaultPort == portCaps.guidPort)
        {
            // Special case: always put default device at head of the list.
            pMusicPortNew->m_pMusicPortNext = pMusicInfo->m_pMusicPortFirst;
            pMusicInfo->m_pMusicPortFirst = pMusicPortNew;
        }
        else if (pMusicInfo->m_pMusicPortFirst == NULL)
        {
            pMusicInfo->m_pMusicPortFirst = pMusicPortNew;
        }
        else
        {
            for (pMusicPort = pMusicInfo->m_pMusicPortFirst; 
                pMusicPort->m_pMusicPortNext != NULL; 
                pMusicPort = pMusicPort->m_pMusicPortNext)
                {
                }
            pMusicPort->m_pMusicPortNext = pMusicPortNew;
        }
        pMusicPortNew->m_guid = portCaps.guidPort;
        pMusicPortNew->m_dwMaxAudioChannels = portCaps.dwMaxAudioChannels;
        pMusicPortNew->m_dwMaxChannelGroups = portCaps.dwMaxChannelGroups;
        if (guidDefaultPort == portCaps.guidPort)
            pMusicPortNew->m_bDefaultPort = TRUE;
        pMusicPortNew->m_bSoftware = (portCaps.dwFlags & DMUS_PC_SOFTWARESYNTH ? TRUE : FALSE);
        pMusicPortNew->m_bKernelMode = (portCaps.dwType == DMUS_PORT_KERNEL_MODE ? TRUE : FALSE);
        pMusicPortNew->m_bUsesDLS = (portCaps.dwFlags & DMUS_PC_DLS ? TRUE : FALSE);
        pMusicPortNew->m_bExternal = (portCaps.dwFlags & DMUS_PC_EXTERNAL ? TRUE : FALSE);
        pMusicPortNew->m_bOutputPort = (portCaps.dwClass == DMUS_PC_OUTPUTCLASS);
#ifdef UNICODE
        lstrcpy(pMusicPortNew->m_szDescription, portCaps.wszDescription);
#else
        WideCharToMultiByte(CP_ACP, 0, portCaps.wszDescription, -1, pMusicPortNew->m_szDescription, sizeof pMusicPortNew->m_szDescription, 0, 0);
#endif

        iPort++;
    }

    // Get General Midi DLS File Path and store it in first MusicPort
    TCHAR szGMFilePath[MAX_PATH];
    DWORD dwBufferLen;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectMusic"), 0, KEY_READ, &hkey))
    {
        dwBufferLen = MAX_PATH;
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("GMFilePath"), 0, NULL, (LPBYTE)szGMFilePath, &dwBufferLen))
        {
            ExpandEnvironmentStrings(szGMFilePath, pMusicInfo->m_szGMFilePath, MAX_PATH);
            GetRiffFileVersion(pMusicInfo->m_szGMFilePath, pMusicInfo->m_szGMFileVersion);
        }
        RegCloseKey(hkey);
    }

LEnd:
    if (pdm != NULL)
        pdm->Release();

    // Release COM
    CoUninitialize();

    if (FAILED(hr = CheckRegistry(&pMusicInfo->m_pRegErrorFirst)))
        return hr;

    return hr;
}


/****************************************************************************
 *
 *  DoesDMHWAccelExist
 *
 ****************************************************************************/
BOOL DoesDMHWAccelExist(IDirectMusic* pdm)
{
    BOOL bHWAccel = FALSE;

    // See if default port is hardware
    GUID guidDefaultPort;
    LONG iPort;
    DMUS_PORTCAPS portCaps;
    HRESULT hr;
    if (SUCCEEDED(pdm->GetDefaultPort(&guidDefaultPort)))
    {
        iPort = 0;
        portCaps.dwSize = sizeof(portCaps);
        while (TRUE)
        {
            hr = pdm->EnumPort(iPort, &portCaps);
            if (hr == S_FALSE)
                break;
            if (FAILED(hr))
                break;
            if (guidDefaultPort == portCaps.guidPort)
            {
                if ((portCaps.dwFlags & DMUS_PC_SOFTWARESYNTH) == 0)
                    bHWAccel = TRUE;
                break;
            }
            iPort++;
        }
    }

    return bHWAccel;
}


/****************************************************************************
 *
 *  IsDMHWAccelEnabled
 *
 ****************************************************************************/
BOOL IsDMHWAccelEnabled(VOID)
{
    HKEY hkey;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwData;
    BOOL bIsDMHWAccelEnabled = TRUE;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        TEXT("SOFTWARE\\Microsoft\\DirectMusic"), 0, KEY_ALL_ACCESS, &hkey))
    {
        dwSize = sizeof(dwData);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("DisableHWAcceleration"), NULL, &dwType, (BYTE *)&dwData, &dwSize))
        {
            if (dwData != 0) 
                bIsDMHWAccelEnabled = FALSE;                
        }

        RegCloseKey( hkey );
    }

    return bIsDMHWAccelEnabled;
}


/****************************************************************************
 *
 *  CheckRegistryClass - Helper function for CheckRegistry
 *
 ****************************************************************************/
HRESULT CheckRegistryClass(RegError** ppRegErrorFirst, TCHAR* pszGuid, 
                           TCHAR* pszName, TCHAR* pszLeaf, TCHAR* pszOptLeaf2 = NULL )
{
    HRESULT hr;
    HKEY HKCR = HKEY_CLASSES_ROOT;
    TCHAR szKey[200];
    TCHAR szData[200];

    wsprintf(szKey, TEXT("CLSID\\%s"), pszGuid);
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, szKey, TEXT(""), pszName)))
        return hr;
    wsprintf(szKey, TEXT("CLSID\\%s\\InprocServer32"), pszGuid);

    if( pszOptLeaf2 == NULL )
    {
        if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, szKey, TEXT(""), pszLeaf, CRF_LEAF)))
            return hr;
    }
    else
    {
        HRESULT hrReg1, hrReg2;
        if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, szKey, TEXT(""), pszLeaf, CRF_LEAF, &hrReg1 )))
            return hr;
        if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, szKey, TEXT(""), pszOptLeaf2, CRF_LEAF, &hrReg2 )))
            return hr;
        if( hrReg1 == RET_NOERROR || hrReg2 == RET_NOERROR )
        {
            // If one succeeded, then the other failed, and they both can't succeed.
            // So delete the first error, since it isn't needed.
            RegError* pRegErrorDelete = *ppRegErrorFirst;
            *ppRegErrorFirst = (*ppRegErrorFirst)->m_pRegErrorNext;
            delete pRegErrorDelete;
        }
    }

    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, szKey, TEXT("ThreadingModel"), TEXT("Both"))))
        return hr;
    wsprintf(szKey, TEXT("CLSID\\%s\\ProgID"), pszGuid);
    wsprintf(szData, TEXT("Microsoft.%s.1"), pszName);
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, szKey, TEXT(""), szData)))
        return hr;
    wsprintf(szKey, TEXT("CLSID\\%s\\VersionIndependentProgID"), pszGuid);
    wsprintf(szData, TEXT("Microsoft.%s"), pszName);
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, szKey, TEXT(""), szData)))
        return hr;

    wsprintf(szKey, TEXT("Microsoft.%s"), pszName);
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, szKey, TEXT(""), pszName)))
        return hr;
    wsprintf(szKey, TEXT("Microsoft.%s\\CLSID"), pszName);
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, szKey, TEXT(""), pszGuid)))
        return hr;
    wsprintf(szKey, TEXT("Microsoft.%s\\CurVer"), pszName);
    wsprintf(szData, TEXT("Microsoft.%s.1"), pszName);
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, szKey, TEXT(""), szData)))
        return hr;

    wsprintf(szKey, TEXT("Microsoft.%s.1"), pszName);
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, szKey, TEXT(""), pszName)))
        return hr;
    wsprintf(szKey, TEXT("Microsoft.%s.1\\CLSID"), pszName);
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, szKey, TEXT(""), pszGuid)))
        return hr;

    return S_OK;
}

/****************************************************************************
 *
 *  CheckRegistry
 *
 ****************************************************************************/
HRESULT CheckRegistry(RegError** ppRegErrorFirst)
{
    HRESULT hr;
    HKEY HKCR = HKEY_CLASSES_ROOT;

    TCHAR szVersion[100];
    HKEY hkey;
    DWORD cbData;
    ULONG ulType;

    DWORD dwMajor = 0;
    DWORD dwMinor = 0;
    DWORD dwRevision = 0;
    DWORD dwBuild = 0;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectX"),
        0, KEY_READ, &hkey))
    {
        cbData = 100;
        RegQueryValueEx(hkey, TEXT("Version"), 0, &ulType, (LPBYTE)szVersion, &cbData);
        RegCloseKey(hkey);
        if (lstrlen(szVersion) > 6 && 
            lstrlen(szVersion) < 20)
        {
            _stscanf(szVersion, TEXT("%d.%d.%d.%d"), &dwMajor, &dwMinor, &dwRevision, &dwBuild);
        }
    }

    // No registry checking on DX versions before DX7
    if (dwMinor < 7)
        return S_OK;

    // DirectMusicCollection
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{480FF4B0-28B2-11D1-BEF7-00C04FBF8FEF}"), TEXT("DirectMusicCollection"), TEXT("dmusic.dll"), TEXT("dmusicd.dll") )))
        return hr;

    // DirectMusic
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{636B9F10-0C7D-11D1-95B2-0020AFDC7421}"), TEXT("DirectMusic"), TEXT("dmusic.dll"), TEXT("dmusicd.dll") )))
        return hr;

    // DirectMusicSection
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{3F037241-414E-11D1-A7CE-00A0C913F73C}"), TEXT("DirectMusicSection"), TEXT("dmstyle.dll"), TEXT("dmstyled.dll") )))
        return hr;

    // DirectMusicSynth
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{58C2B4D0-46E7-11D1-89AC-00A0C9054129}"), TEXT("DirectMusicSynth"), TEXT("dmsynth.dll"), TEXT("dmsynthd.dll") )))
        return hr;

    // DirectMusicBand
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{79BA9E00-B6EE-11D1-86BE-00C04FBF8FEF}"), TEXT("DirectMusicBand"), TEXT("dmband.dll"), TEXT("dmbandd.dll") )))
        return hr;

    // DirectMusicSynthSink
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{AEC17CE3-A514-11D1-AFA6-00AA0024D8B6}"), TEXT("DirectMusicSynthSink"), TEXT("dmsynth.dll"), TEXT("dmsynthd.dll") )))
        return hr;

    // DirectMusicPerformance
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC2881-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicPerformance"), TEXT("dmime.dll"), TEXT("dmimed.dll") )))
        return hr;

    // DirectMusicSegment
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC2882-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicSegment"), TEXT("dmime.dll"), TEXT("dmimed.dll") )))
        return hr;

    // DirectMusicSegmentState
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC2883-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicSegmentState"), TEXT("dmime.dll"), TEXT("dmimed.dll") )))
        return hr;

    // DirectMusicGraph
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC2884-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicGraph"), TEXT("dmime.dll"), TEXT("dmimed.dll") )))
        return hr;

    // DirectMusicTempoTrack
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC2885-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicTempoTrack"), TEXT("dmime.dll"), TEXT("dmimed.dll") )))
        return hr;

    // DirectMusicSeqTrack
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC2886-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicSeqTrack"), TEXT("dmime.dll"), TEXT("dmimed.dll") )))
        return hr;

    // DirectMusicSysExTrack
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC2887-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicSysExTrack"), TEXT("dmime.dll"), TEXT("dmimed.dll") )))
        return hr;

    // DirectMusicTimeSigTrack
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC2888-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicTimeSigTrack"), TEXT("dmime.dll"), TEXT("dmimed.dll") )))
        return hr;

    // DirectMusicStyle
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC288a-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicStyle"), TEXT("dmstyle.dll"), TEXT("dmstyled.dll") )))
        return hr;

    // DirectMusicChordTrack
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC288b-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicChordTrack"), TEXT("dmstyle.dll"), TEXT("dmstyled.dll") )))
        return hr;

    // DirectMusicCommandTrack
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC288c-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicCommandTrack"), TEXT("dmstyle.dll"), TEXT("dmstyled.dll") )))
        return hr;

    // DirectMusicStyleTrack
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC288d-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicStyleTrack"), TEXT("dmstyle.dll"), TEXT("dmstyled.dll") )))
        return hr;

    // DirectMusicMotifTrack
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC288e-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicMotifTrack"), TEXT("dmstyle.dll"), TEXT("dmstyled.dll") )))
        return hr;

    // DirectMusicChordMap
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC288f-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicChordMap"), TEXT("dmcompos.dll"), TEXT("dmcompod.dll") )))
        return hr;

    // DirectMusicComposer
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC2890-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicComposer"), TEXT("dmcompos.dll"), TEXT("dmcompod.dll") )))
        return hr;

    // DirectMusicLoader
    // This check fails when upgrading Win98SE (or possibly any system with DX 6.1 or 6.1a) to Win2000 RC2.  So skip it
//  if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC2892-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicLoader"), TEXT("dmloader.dll"))))
//      return hr;

    // DirectMusicBandTrack
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC2894-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicBandTrack"), TEXT("dmband.dll"), TEXT("dmbandd.dll") )))
        return hr;

    // DirectMusicChordMapTrack
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC2896-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicChordMapTrack"), TEXT("dmcompos.dll"), TEXT("dmcompod.dll") )))
        return hr;

    // DirectMusicAuditionTrack
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC2897-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicAuditionTrack"), TEXT("dmstyle.dll"), TEXT("dmstyled.dll") )))
        return hr;

    // DirectMusicMuteTrack
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D2AC2898-B39B-11D1-8704-00600893B1BD}"), TEXT("DirectMusicMuteTrack"), TEXT("dmstyle.dll"), TEXT("dmstyled.dll") )))
        return hr;

    // DirectMusicTemplate
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{D30BCC65-60E8-11D1-A7CE-00A0C913F73C}"), TEXT("DirectMusicTemplate"), TEXT("dmcompos.dll"), TEXT("dmcompod.dll") )))
        return hr;

    // DirectMusicSignPostTrack
    if (FAILED(hr = CheckRegistryClass(ppRegErrorFirst, TEXT("{F17E8672-C3B4-11D1-870B-00600893B1BD}"), TEXT("DirectMusicSignPostTrack"), TEXT("dmcompos.dll"), TEXT("dmcompod.dll") )))
        return hr;

    return S_OK;
}


/****************************************************************************
 *
 *  DestroyMusicInfo
 *
 ****************************************************************************/
VOID DestroyMusicInfo(MusicInfo* pMusicInfo)
{
    if( pMusicInfo )
    {
        DestroyReg( &pMusicInfo->m_pRegErrorFirst );

        MusicPort* pMusicPort;
        MusicPort* pMusicPortNext;

        for (pMusicPort = pMusicInfo->m_pMusicPortFirst; pMusicPort != NULL; 
            pMusicPort = pMusicPortNext)
        {
            pMusicPortNext = pMusicPort->m_pMusicPortNext;
            delete pMusicPort;
        }

        delete pMusicInfo;
    }
}


/****************************************************************************
 *
 *  DiagnoseMusic
 *
 ****************************************************************************/
VOID DiagnoseMusic(SysInfo* pSysInfo, MusicInfo* pMusicInfo)
{
    TCHAR szMessage[500];
    BOOL bProblem = FALSE;

    _tcscpy( pSysInfo->m_szMusicNotes, TEXT("") );
    _tcscpy( pSysInfo->m_szMusicNotesEnglish, TEXT("") );

    // Report any problems
    if (pMusicInfo == NULL || pMusicInfo->m_pMusicPortFirst == NULL)
    {
        LoadString(NULL, IDS_NOPORTS, szMessage, 500);
        _tcscat( pSysInfo->m_szMusicNotes, szMessage );

        LoadString(NULL, IDS_NOPORTS_ENGLISH, szMessage, 500);
        _tcscat( pSysInfo->m_szMusicNotesEnglish, szMessage );

        bProblem = TRUE;
    }
    else if (lstrlen(pMusicInfo->m_szGMFilePath) == 0)
    {
        LoadString(NULL, IDS_NOGMDLS, szMessage, 500);
        _tcscat( pSysInfo->m_szMusicNotes, szMessage );

        LoadString(NULL, IDS_NOGMDLS_ENGLISH, szMessage, 500);
        _tcscat( pSysInfo->m_szMusicNotesEnglish, szMessage );

        bProblem = TRUE;
    }
    else 
    {
        WIN32_FIND_DATA findFileData;
        HANDLE hFind = FindFirstFile(pMusicInfo->m_szGMFilePath, &findFileData);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            LoadString(NULL, IDS_GMDLSFILEMISSING, szMessage, 500);
            _tcscat( pSysInfo->m_szMusicNotes, szMessage );

            LoadString(NULL, IDS_GMDLSFILEMISSING_ENGLISH, szMessage, 500);
            _tcscat( pSysInfo->m_szMusicNotesEnglish, szMessage );

            bProblem = TRUE;
        }
        else
        {
            FindClose(hFind);
        }
    }
    if (pMusicInfo && pMusicInfo->m_pRegErrorFirst != NULL)
    {
        LoadString(NULL, IDS_REGISTRYPROBLEM, szMessage, 500);
        _tcscat( pSysInfo->m_szMusicNotes, szMessage );

        LoadString(NULL, IDS_REGISTRYPROBLEM_ENGLISH, szMessage, 500);
        _tcscat( pSysInfo->m_szMusicNotesEnglish, szMessage );

        bProblem = TRUE;
    }

    // Show test results or instructions to run test:
    if (pMusicInfo && pMusicInfo->m_testResult.m_bStarted)
    {
        LoadString(NULL, IDS_DMUSICRESULTS, szMessage, 500);
        _tcscat( pSysInfo->m_szMusicNotes, szMessage );
        _tcscat( pSysInfo->m_szMusicNotes, pMusicInfo->m_testResult.m_szDescription );
        _tcscat( pSysInfo->m_szMusicNotes, TEXT("\r\n") );

        LoadString(NULL, IDS_DMUSICRESULTS_ENGLISH, szMessage, 500);
        _tcscat( pSysInfo->m_szMusicNotesEnglish, szMessage );
        _tcscat( pSysInfo->m_szMusicNotesEnglish, pMusicInfo->m_testResult.m_szDescriptionEnglish );
        _tcscat( pSysInfo->m_szMusicNotesEnglish, TEXT("\r\n") );

        bProblem = TRUE;
    }
    else
    {
        LoadString(NULL, IDS_DMUSICINSTRUCTIONS, szMessage, 500);
        _tcscat( pSysInfo->m_szMusicNotes, szMessage );

        LoadString(NULL, IDS_DMUSICINSTRUCTIONS_ENGLISH, szMessage, 500);
        _tcscat( pSysInfo->m_szMusicNotesEnglish, szMessage );
    }

    if (!bProblem)
    {
        LoadString(NULL, IDS_NOPROBLEM, szMessage, 500);
        _tcscat( pSysInfo->m_szMusicNotes, szMessage );

        LoadString(NULL, IDS_NOPROBLEM_ENGLISH, szMessage, 500);
        _tcscat( pSysInfo->m_szMusicNotesEnglish, szMessage );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\reginfo.cpp ===
/****************************************************************************
 *
 *    File: reginfo.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather and hold registry information 
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <Windows.h>
#include <tchar.h>
#include "reginfo.h"

static HRESULT AddError(RegError** ppRegErrorFirst, RegError* pRegErrorNew);
static BOOL EqualMemory(BYTE* pb1, BYTE* pb2, DWORD numBytes);


/****************************************************************************
 *
 *  CheckRegDword
 *
 ****************************************************************************/
HRESULT CheckRegDword(RegError** ppRegErrorFirst, HKEY hkeyRoot, TCHAR* pszKey, 
                      TCHAR* pszValue, DWORD dwExpected)
{
    HKEY hkey = NULL;
    RegError regErrorNew;

    ZeroMemory(&regErrorNew, sizeof(RegError));
    regErrorNew.m_hkeyRoot = hkeyRoot;
    lstrcpy(regErrorNew.m_szKey, pszKey);
    lstrcpy(regErrorNew.m_szValue, pszValue);
    regErrorNew.m_dwTypeExpected = REG_DWORD;
    regErrorNew.m_dwExpected = dwExpected;

    if (ERROR_SUCCESS != RegOpenKeyEx(hkeyRoot, pszKey, 0, KEY_READ, &hkey))
    {
        regErrorNew.m_ret = RET_MISSINGKEY;
    }
    else
    {
        regErrorNew.m_dwExpectedSize = sizeof(DWORD);
        regErrorNew.m_dwActualSize = regErrorNew.m_dwExpectedSize; // RegQueryValueEx will change this
        if (ERROR_SUCCESS != RegQueryValueEx(hkey, pszValue, 0, &regErrorNew.m_dwTypeActual, 
            (LPBYTE)&regErrorNew.m_dwActual, &regErrorNew.m_dwActualSize))
        {
            regErrorNew.m_ret = RET_MISSINGVALUE;
        }
        else if (regErrorNew.m_dwTypeActual != regErrorNew.m_dwTypeExpected)
        {
            regErrorNew.m_ret = RET_VALUEWRONGTYPE;
        }
        else if (regErrorNew.m_dwActual != dwExpected)
        {
            regErrorNew.m_ret = RET_VALUEWRONGDATA;
        }
        RegCloseKey(hkey);
    }

    if (regErrorNew.m_ret == RET_NOERROR)
        return S_OK;
    else
        return AddError(ppRegErrorFirst, &regErrorNew);
}


/****************************************************************************
 *
 *  CheckRegString
 *
 ****************************************************************************/
HRESULT CheckRegString(RegError** ppRegErrorFirst, HKEY hkeyRoot, TCHAR* pszKey, 
                       TCHAR* pszValue, TCHAR* pszExpected, CheckRegFlags crf,
                       HRESULT* phrError )
{
    HKEY hkey = NULL;
    RegError regErrorNew;

    ZeroMemory(&regErrorNew, sizeof(RegError));
    regErrorNew.m_hkeyRoot = hkeyRoot;
    lstrcpy(regErrorNew.m_szKey, pszKey);
    lstrcpy(regErrorNew.m_szValue, pszValue);
    regErrorNew.m_dwTypeExpected = REG_SZ;
    lstrcpy(regErrorNew.m_szExpected, pszExpected);

    if (ERROR_SUCCESS != RegOpenKeyEx(hkeyRoot, pszKey, 0, KEY_READ, &hkey))
    {
        regErrorNew.m_ret = RET_MISSINGKEY;
    }
    else
    {
        regErrorNew.m_dwExpectedSize = lstrlen(pszExpected) + 1;
        regErrorNew.m_dwActualSize = sizeof(regErrorNew.m_szActual); // RegQueryValueEx will change this
        if (ERROR_SUCCESS != RegQueryValueEx(hkey, pszValue, 0, &regErrorNew.m_dwTypeActual, 
            (LPBYTE)&regErrorNew.m_szActual, &regErrorNew.m_dwActualSize))
        {
            regErrorNew.m_ret = RET_MISSINGVALUE;
        }
        else if (regErrorNew.m_dwTypeActual != regErrorNew.m_dwTypeExpected)
        {
            regErrorNew.m_ret = RET_VALUEWRONGTYPE;
        }
        else if (lstrcmp(regErrorNew.m_szExpected, TEXT("*")) != 0)
        {
            TCHAR* pszCompare = regErrorNew.m_szActual;
            if (crf & CRF_LEAF)
            {
                pszCompare = _tcsrchr(regErrorNew.m_szActual, TEXT('\\'));
                if (pszCompare == NULL)
                    pszCompare = regErrorNew.m_szActual;
                else
                    pszCompare++; // skip past backslash
            }
            if (lstrcmpi(regErrorNew.m_szExpected, pszCompare) != 0)
            {
                regErrorNew.m_ret = RET_VALUEWRONGDATA;
            }
        }
        RegCloseKey(hkey);
    }

    if( phrError )
        *phrError = regErrorNew.m_ret;

    if (regErrorNew.m_ret == RET_NOERROR)
        return S_OK;
    else
        return AddError(ppRegErrorFirst, &regErrorNew);
}


/****************************************************************************
 *
 *  CheckRegBinary
 *
 ****************************************************************************/
HRESULT CheckRegBinary(RegError** ppRegErrorFirst, HKEY hkeyRoot, TCHAR* pszKey, 
                       TCHAR* pszValue, BYTE* pbDataExpected, DWORD dwSizeExpected)
{
    HKEY hkey = NULL;
    RegError regErrorNew;

    if (dwSizeExpected > sizeof(regErrorNew.m_bExpected))
        return E_INVALIDARG;

    ZeroMemory(&regErrorNew, sizeof(RegError));
    regErrorNew.m_hkeyRoot = hkeyRoot;
    lstrcpy(regErrorNew.m_szKey, pszKey);
    lstrcpy(regErrorNew.m_szValue, pszValue);
    regErrorNew.m_dwTypeExpected = REG_BINARY;
    CopyMemory(regErrorNew.m_bExpected, pbDataExpected, dwSizeExpected);

    if (ERROR_SUCCESS != RegOpenKeyEx(hkeyRoot, pszKey, 0, KEY_READ, &hkey))
    {
        regErrorNew.m_ret = RET_MISSINGKEY;
    }
    else
    {
        regErrorNew.m_dwExpectedSize = dwSizeExpected;
        regErrorNew.m_dwActualSize = sizeof(regErrorNew.m_bExpected); // RegQueryValueEx will change this
        if (ERROR_SUCCESS != RegQueryValueEx(hkey, pszValue, 0, &regErrorNew.m_dwTypeActual, 
            (LPBYTE)&regErrorNew.m_bActual, &regErrorNew.m_dwActualSize))
        {
            regErrorNew.m_ret = RET_MISSINGVALUE;
        }
        else if (regErrorNew.m_dwTypeActual != regErrorNew.m_dwTypeExpected)
        {
            regErrorNew.m_ret = RET_VALUEWRONGTYPE;
        }
        else if (regErrorNew.m_dwActualSize != regErrorNew.m_dwExpectedSize)
        {
            regErrorNew.m_ret = RET_VALUEWRONGDATA;
        }
        else if (!EqualMemory(regErrorNew.m_bExpected, regErrorNew.m_bActual, regErrorNew.m_dwActualSize))
        {
            regErrorNew.m_ret = RET_VALUEWRONGDATA;
        }
        RegCloseKey(hkey);
    }

    if (regErrorNew.m_ret == RET_NOERROR)
        return S_OK;
    else
        return AddError(ppRegErrorFirst, &regErrorNew);
}


/****************************************************************************
 *
 *  AddError - Allocate a RegError node, copy data from pRegErrorNew, and
 *      insert the node at the beginning of the ppRegErrorFirst linked list.
 *
 ****************************************************************************/
HRESULT AddError(RegError** ppRegErrorFirst, RegError* pRegErrorNew)
{
    RegError* pRegErrorInsert;

    pRegErrorInsert = new RegError;
    if (pRegErrorInsert == NULL)
        return E_OUTOFMEMORY;
    *pRegErrorInsert = *pRegErrorNew;
    pRegErrorInsert->m_pRegErrorNext = *ppRegErrorFirst;
    *ppRegErrorFirst = pRegErrorInsert;
    return S_OK;
}


/****************************************************************************
 *
 *  EqualMemory
 *
 ****************************************************************************/
BOOL EqualMemory(BYTE* pb1, BYTE* pb2, DWORD numBytes)
{
    while (numBytes > 0)
    {
        if (*pb1 != *pb2)
            return FALSE;
        pb1++;
        pb2++;
        numBytes--;
    }
    return TRUE;
}


/****************************************************************************
 *
 *  DestroyReg
 *
 ****************************************************************************/
VOID DestroyReg( RegError** ppRegErrorFirst )
{
    if( ppRegErrorFirst && *ppRegErrorFirst )
    {
        RegError* pRegError;
        RegError* pRegErrorNext;

        for (pRegError = *ppRegErrorFirst; pRegError != NULL; 
            pRegError = pRegErrorNext)
        {
            pRegErrorNext = pRegError->m_pRegErrorNext;
            delete pRegError;
        }

        *ppRegErrorFirst = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\reginfo.h ===
/****************************************************************************
 *
 *    File: reginfo.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather and hold registry information 
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef REGINFO_H
#define REGINFO_H

enum RegErrorType
{
    RET_NOERROR = 0,
    RET_MISSINGKEY,
    RET_MISSINGVALUE,
    RET_VALUEWRONGTYPE,
    RET_VALUEWRONGDATA
};

struct RegError
{
    HKEY m_hkeyRoot; // HKLM, HKCU, etc.
    TCHAR m_szKey[300];
    TCHAR m_szValue[100];
    RegErrorType m_ret;
    DWORD m_dwTypeExpected; // REG_DWORD, REG_SZ, or REG_BINARY
    DWORD m_dwTypeActual;

    // The following are used if m_dwType is REG_DWORD:
    DWORD m_dwExpected;
    DWORD m_dwActual;

    // The following are used if m_dwType is REG_SZ:
    TCHAR m_szExpected[200];
    TCHAR m_szActual[200];

    // The following are used if m_dwType is REG_BINARY:
    BYTE m_bExpected[200];
    BYTE m_bActual[200];
    DWORD m_dwExpectedSize;
    DWORD m_dwActualSize;

    RegError* m_pRegErrorNext;
};

enum CheckRegFlags
{
    CRF_NONE = 0,
    CRF_LEAF = 1, // if string is a path, just compare against the leaf
};

HRESULT CheckRegDword(RegError** ppRegErrorFirst, HKEY hkeyRoot, TCHAR* pszKey, TCHAR* pszValue, DWORD dwExpected);
HRESULT CheckRegString(RegError** ppRegErrorFirst, HKEY hkeyRoot, TCHAR* pszKey, TCHAR* pszValue, TCHAR* pszExpected, CheckRegFlags crf = CRF_NONE, HRESULT* phrError = NULL );
HRESULT CheckRegBinary(RegError** ppRegErrorFirst, HKEY hkeyRoot, TCHAR* pszKey, TCHAR* pszValue, BYTE* pbDataExpected, DWORD dwSizeExpected);
VOID DestroyReg( RegError** ppRegErrorFirst );

#endif // REGINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\showinfo.h ===
/****************************************************************************
 *
 *    File: showinfo.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about DirectShow
 *
 * (C) Copyright 2001 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef SHOWINFO_H
#define SHOWINFO_H

struct FilterInfo
{
    TCHAR   m_szName[1024];             // friendly name
    TCHAR   m_szVersion[32];            // version
    CLSID   m_ClsidFilter;              // guid
    TCHAR   m_szFileName[MAX_PATH];     // file name
    TCHAR   m_szFileVersion[32];        // file version
    TCHAR   m_szCatName[1024];          // category name
    CLSID   m_ClsidCat;                 // category guid
    DWORD   m_dwInputs;                 // number input pins
    DWORD   m_dwOutputs;                // number output pins
    DWORD   m_dwMerit;                  // merit - in hex
    FilterInfo* m_pFilterInfoNext;
};

struct ShowInfo
{
    FilterInfo*     m_pFilters;
    DWORD           m_dwFilters;
};

HRESULT GetBasicShowInfo(ShowInfo** ppShowInfo);
VOID DestroyShowInfo(ShowInfo* pShowInfo);



#endif // SHOWINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\save.cpp ===
/****************************************************************************
 *
 *    File: save.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Save gathered information to a file in text or CSV format
 *
 * Note that the text file is always ANSI, even on Unicode builds, to make
 * the resulting file easier to use (e.g., Win9x Notepad doesn't understand 
 * Unicode).
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <tchar.h>
#include <Windows.h>
#include <multimon.h>
#include <stdio.h>
#include "reginfo.h"
#include "sysinfo.h"
#include "fileinfo.h"
#include "dispinfo.h"
#include "sndinfo.h"
#include "musinfo.h"
#include "showinfo.h"
#include "inptinfo.h"
#include "netinfo.h"
#include "save.h"


static HRESULT SaveBugInfo(FILE* pFile, BugInfo* pBugInfo);
static HRESULT SaveSysInfo(FILE* pFile, SysInfo* pSysInfo);
static HRESULT SaveNotesInfo(FILE* pFile, SysInfo* pSysInfo, DisplayInfo* pDisplayInfoFirst, SoundInfo* pSoundInfoFirst);
static HRESULT SaveNote(FILE* pFile, TCHAR* strNote );
static HRESULT SaveDxComponentFileInfo(FILE* pFile, FileInfo* pFileInfoFirst);
static HRESULT SaveDxWinComponentFileInfo(FILE* pFile, FileInfo* pFileInfoFirst);
static HRESULT SaveBackedUpFileInfo(FILE* pFile);
static HRESULT SaveDisplayInfo(FILE* pFile, DisplayInfo* pDisplayInfoFirst);
static HRESULT SaveSoundInfo(FILE* pFile, SoundInfo* pSoundInfoFirst);
static HRESULT SaveMusicInfo(FILE* pFile, MusicInfo* pMusicInfo);
static HRESULT SaveShowInfo(FILE* pFile, ShowInfo* pShowInfo);
static HRESULT SaveInputInfo(FILE* pFile, InputInfo* pInputInfo);
static HRESULT SaveNetInfo(FILE* pFile, NetInfo* pNetInfo);
static HRESULT SaveInactiveDriverInfo(FILE* pFile, DisplayInfo* pDisplayInfoFirst);
static HRESULT SaveRegistryErrorInfo(FILE* pFile, RegError* pRegErrorFirst);
static HRESULT SaveDebugLevels(FILE* pFile, SysInfo* pSysInfo);



/****************************************************************************
 *
 *  SaveAllInfo - Save all gathered information in text format.
 *
 ****************************************************************************/
HRESULT SaveAllInfo(TCHAR* pszFile, SysInfo* pSysInfo, 
    FileInfo* pFileInfoWinComponentsFirst, FileInfo* pFileInfoComponentsFirst, 
    DisplayInfo* pDisplayInfoFirst, SoundInfo* pSoundInfoFirst,
    MusicInfo* pMusicInfo, InputInfo* pInputInfo, 
    NetInfo* pNetInfo, ShowInfo* pShowInfo, BugInfo* pBugInfo)
{
    HRESULT hr = S_OK;
    FILE* pFile;

    pFile = _tfopen(pszFile, TEXT("wt"));
    if (pFile == NULL)
        goto LEnd;

    if (pBugInfo != NULL)
    {
        if (FAILED(hr = SaveBugInfo(pFile, pBugInfo)))
            goto LEnd;
    }

    if (FAILED(hr = SaveSysInfo(pFile, pSysInfo)))
        goto LEnd;
    
    if (FAILED(hr = SaveNotesInfo(pFile, pSysInfo, pDisplayInfoFirst, pSoundInfoFirst)))
        goto LEnd;

    if (FAILED(hr = SaveDxComponentFileInfo(pFile, pFileInfoComponentsFirst)))
        goto LEnd;
    
    if (FAILED(hr = SaveDxWinComponentFileInfo(pFile, pFileInfoWinComponentsFirst)))
        goto LEnd;
    
    if (FAILED(hr = SaveBackedUpFileInfo(pFile)))
        goto LEnd;
    
    if (FAILED(hr = SaveDisplayInfo(pFile, pDisplayInfoFirst)))
        goto LEnd;

    if (FAILED(hr = SaveSoundInfo(pFile, pSoundInfoFirst)))
        goto LEnd;

    if (FAILED(hr = SaveMusicInfo(pFile, pMusicInfo)))
        goto LEnd;

    if (FAILED(hr = SaveShowInfo(pFile, pShowInfo)))
        goto LEnd;
    
    if (FAILED(hr = SaveInputInfo(pFile, pInputInfo)))
        goto LEnd;

    if (FAILED(hr = SaveNetInfo(pFile, pNetInfo)))
        goto LEnd;

    if (FAILED(hr = SaveInactiveDriverInfo(pFile, pDisplayInfoFirst)))
        goto LEnd;

    if (FAILED(hr = SaveDebugLevels(pFile, pSysInfo)))
        goto LEnd;

LEnd:
    if (pFile != NULL)
        fclose(pFile);
    return hr;
}


/****************************************************************************
 *
 *  SaveAllInfoCsv - Save all gathered information in CSV format.
 *
 ****************************************************************************/
HRESULT SaveAllInfoCsv(TCHAR* pszFile, SysInfo* pSysInfo, 
    FileInfo* pFileInfoComponentsFirst, DisplayInfo* pDisplayInfoFirst, 
    SoundInfo* pSoundInfoFirst, InputInfo* pInputInfo)
{
    HRESULT hr = S_OK;
    FILE* pFile;

    pFile = _tfopen(pszFile, TEXT("wt"));
    if (pFile == NULL)
        goto LEnd;

    // Date
    _ftprintf(pFile, TEXT("%02d%02d%d,%02d%02d"),
        pSysInfo->m_time.wMonth, pSysInfo->m_time.wDay, pSysInfo->m_time.wYear,
        pSysInfo->m_time.wHour, pSysInfo->m_time.wMinute);

    // Machine name
    _ftprintf(pFile, TEXT(",%s"), pSysInfo->m_szMachine);

    // DX Version
    _ftprintf(pFile, TEXT(",%s"), pSysInfo->m_szDirectXVersion);
    
    // OS
    _ftprintf(pFile, TEXT(",%s,%d.%d,%d,"),
        pSysInfo->m_szOS, pSysInfo->m_dwMajorVersion, pSysInfo->m_dwMinorVersion,
        LOWORD(pSysInfo->m_dwBuildNumber));
    _ftprintf(pFile, TEXT("%s"), pSysInfo->m_szCSDVersion);

    // Processor - string may have commas, so change them to semicolons
    TCHAR szProcessor[1024];
    TCHAR* psz;
    lstrcpy(szProcessor, pSysInfo->m_szProcessor);
    for (psz = szProcessor; *psz != TEXT('\0'); psz++)
    {
        if (*psz == TEXT(','))
            *psz = TEXT(';');
    }
    _ftprintf(pFile, TEXT(",%s"), szProcessor);

    // Display devices 
    // (chip type, matching ID, DAC type, disp memory, driver name, driver version)
    DisplayInfo* pDisplayInfo;
    pDisplayInfo = pDisplayInfoFirst;
    {
        _ftprintf(pFile, TEXT(",%s"), pDisplayInfo->m_szChipType);
        _ftprintf(pFile, TEXT(",%s"), pDisplayInfo->m_szKeyDeviceID);
        _ftprintf(pFile, TEXT(",%s"), pDisplayInfo->m_szDACType);
        _ftprintf(pFile, TEXT(",%s"), pDisplayInfo->m_szDisplayMemoryEnglish);
        _ftprintf(pFile, TEXT(",%s"), pDisplayInfo->m_szDriverName);
        _ftprintf(pFile, TEXT(",%s"), pDisplayInfo->m_szDriverVersion);
    }

    // Sound devices
    SoundInfo* pSoundInfo;
    for (pSoundInfo = pSoundInfoFirst; pSoundInfo != NULL; 
        pSoundInfo = pSoundInfo->m_pSoundInfoNext)
    {
        _ftprintf(pFile, TEXT(",%s"), pSoundInfo->m_szDescription);
        _ftprintf(pFile, TEXT(",%s"), pSoundInfo->m_szDeviceID);
        _ftprintf(pFile, TEXT(",%s"), pSoundInfo->m_szDriverName);
        _ftprintf(pFile, TEXT(",%s"), pSoundInfo->m_szDriverVersion);
    }

LEnd:
    if (pFile != NULL)
        fclose(pFile);
    return hr;
}


/****************************************************************************
 *
 *  SaveBugInfo
 *
 ****************************************************************************/
HRESULT SaveBugInfo(FILE* pFile, BugInfo* pBugInfo)
{
    _ftprintf(pFile, TEXT("---------------\n"));
    _ftprintf(pFile, TEXT("Bug Information\n"));
    _ftprintf(pFile, TEXT("---------------\n"));
    _ftprintf(pFile, TEXT("      User name: %s\n"), pBugInfo->m_szName);
    _ftprintf(pFile, TEXT("          Email: %s\n"), pBugInfo->m_szEmail);
    _ftprintf(pFile, TEXT("        Company: %s\n"), pBugInfo->m_szCompany);
    _ftprintf(pFile, TEXT("          Phone: %s\n"), pBugInfo->m_szPhone);
    _ftprintf(pFile, TEXT("    City, State: %s\n"), pBugInfo->m_szCityState);
    _ftprintf(pFile, TEXT("        Country: %s\n"), pBugInfo->m_szCountry);
    _ftprintf(pFile, TEXT("Bug Description: %s\n"), pBugInfo->m_szBugDescription);
    _ftprintf(pFile, TEXT("    Repro Steps: %s\n"), pBugInfo->m_szReproSteps);
    _ftprintf(pFile, TEXT("   SW/HW Config: %s\n"), pBugInfo->m_szSwHw);
    _ftprintf(pFile, TEXT("\n"));
    return S_OK;
}


/****************************************************************************
 *
 *  SaveSysInfo
 *
 ****************************************************************************/
HRESULT SaveSysInfo(FILE* pFile, SysInfo* pSysInfo)
{
    _ftprintf(pFile, TEXT("------------------\n"));
    _ftprintf(pFile, TEXT("System Information\n"));
    _ftprintf(pFile, TEXT("------------------\n"));
    _ftprintf(pFile, TEXT("Time of this report: %s\n"), pSysInfo->m_szTime);
    _ftprintf(pFile, TEXT("       Machine name: %s\n"), pSysInfo->m_szMachine);
    _ftprintf(pFile, TEXT("   Operating System: %s\n"), pSysInfo->m_szOSExLong);
    _ftprintf(pFile, TEXT("           Language: %s\n"), pSysInfo->m_szLanguages);
    _ftprintf(pFile, TEXT("System Manufacturer: %s\n"), pSysInfo->m_szSystemManufacturerEnglish);
    _ftprintf(pFile, TEXT("       System Model: %s\n"), pSysInfo->m_szSystemModelEnglish);
    _ftprintf(pFile, TEXT("               BIOS: %s\n"), pSysInfo->m_szBIOSEnglish);
    _ftprintf(pFile, TEXT("          Processor: %s\n"), pSysInfo->m_szProcessor);
    _ftprintf(pFile, TEXT("             Memory: %s\n"), pSysInfo->m_szPhysicalMemory);
    _ftprintf(pFile, TEXT("          Page File: %s\n"), pSysInfo->m_szPageFileEnglish);
    _ftprintf(pFile, TEXT("Primary File System: %s\n"), pSysInfo->m_szD3D8CacheFileSystem );
    _ftprintf(pFile, TEXT("    DirectX Version: %s\n"), pSysInfo->m_szDirectXVersionLong);
    _ftprintf(pFile, TEXT("DX Setup Parameters: %s\n"), pSysInfo->m_szSetupParam);
    
    TCHAR szUnicode[1024];
    TCHAR szBit[1024];

#ifdef _WIN64
    _tcscpy(szBit, TEXT(" 64bit"));
#else
    _tcscpy(szBit, TEXT(" 32bit"));
#endif

#ifdef UNICODE
    _tcscpy(szUnicode, TEXT(" Unicode"));
#else
    _tcscpy(szUnicode, TEXT(""));
#endif

    _ftprintf(pFile, TEXT("     DxDiag Version: %s%s%s\n"), pSysInfo->m_szDxDiagVersion, szBit, szUnicode );
    _ftprintf(pFile, TEXT("\n"));
    return S_OK;
}




/****************************************************************************
 *
 *  SaveNote
 *
 ****************************************************************************/
HRESULT SaveNote(FILE* pFile, TCHAR* strNote )
{
    TCHAR strBuffer[1024*8]; 
    _tcscpy( strBuffer, strNote );

    TCHAR* pEndOfLine;
    TCHAR* pCurrent = strBuffer;
    TCHAR* pStartOfNext;
    BOOL bFirstTime = TRUE;

    pEndOfLine = _tcschr( pCurrent, TEXT('\r') );
    if( pEndOfLine == NULL )
    {
        _ftprintf(pFile, TEXT("%s\n"), pCurrent );
        return S_OK;
    }

    while(TRUE) 
    {
        *pEndOfLine = 0;
        pStartOfNext = pEndOfLine + 2;

        // Output the current line, iff its not a "To test" line
        if( _tcsstr( pCurrent, TEXT("To test") ) == NULL )
        {
            // Ouput trailing spaces everytime except the first time
            if( !bFirstTime )
                _ftprintf(pFile, TEXT("                     ") );
            bFirstTime = FALSE;

            _ftprintf(pFile, TEXT("%s\n"), pCurrent );
        }

        // Advance current
        pCurrent = pStartOfNext;

        // Look for the end of the next, and stop if there's no more
        pEndOfLine = _tcschr( pStartOfNext, TEXT('\r') );
        if( pEndOfLine == NULL )
            break;
    }

    return S_OK;
}


/****************************************************************************
 *
 *  SaveNotesInfo
 *
 ****************************************************************************/
HRESULT SaveNotesInfo(FILE* pFile, SysInfo* pSysInfo, 
                      DisplayInfo* pDisplayInfoFirst, SoundInfo* pSoundInfoFirst)
{
    DisplayInfo* pDisplayInfo;
    SoundInfo* pSoundInfo;
    DWORD dwIndex;

    _ftprintf(pFile, TEXT("------------\n"));
    _ftprintf(pFile, TEXT("DxDiag Notes\n"));
    _ftprintf(pFile, TEXT("------------\n"));
    _ftprintf(pFile, TEXT("  DirectX Files Tab: ") );
    SaveNote(pFile, pSysInfo->m_szDXFileNotesEnglish);

    dwIndex = 1;
    for (pDisplayInfo = pDisplayInfoFirst; pDisplayInfo != NULL; 
        pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext)
    {
        _ftprintf(pFile, TEXT("      Display Tab %d: "), dwIndex);
        SaveNote(pFile, pDisplayInfo->m_szNotesEnglish);
        dwIndex++;
    }

    dwIndex = 1;
    for (pSoundInfo = pSoundInfoFirst; pSoundInfo != NULL; 
        pSoundInfo = pSoundInfo->m_pSoundInfoNext)
    {
        _ftprintf(pFile, TEXT("        Sound Tab %d: "), dwIndex);
        SaveNote(pFile, pSoundInfo->m_szNotesEnglish);
        dwIndex++;
    }

    _ftprintf(pFile, TEXT("          Music Tab: "));
    SaveNote(pFile, pSysInfo->m_szMusicNotesEnglish);
    _ftprintf(pFile, TEXT("          Input Tab: "));
    SaveNote(pFile, pSysInfo->m_szInputNotesEnglish);
    _ftprintf(pFile, TEXT("        Network Tab: "));
    SaveNote(pFile, pSysInfo->m_szNetworkNotesEnglish);
    _ftprintf(pFile, TEXT("\n"));
    return S_OK;
}


/****************************************************************************
 *
 *  SaveDxComponentFileInfo
 *
 ****************************************************************************/
HRESULT SaveDxComponentFileInfo(FILE* pFile, FileInfo* pFileInfoFirst)
{
    FileInfo* pFileInfo;
    TCHAR sz[1024];

    _ftprintf(pFile, TEXT("------------------\n"));
    _ftprintf(pFile, TEXT("DirectX Components\n"));
    _ftprintf(pFile, TEXT("------------------\n"));
    for (pFileInfo = pFileInfoFirst; pFileInfo != NULL; 
        pFileInfo = pFileInfo->m_pFileInfoNext)
    {
        if (!pFileInfo->m_bExists && !pFileInfo->m_bProblem)
            continue;
        wsprintf(sz, TEXT("%12s: %s %s %s %s %s %d bytes %s\n"), 
            pFileInfo->m_szName, 
            pFileInfo->m_szVersion, 
            pFileInfo->m_szLanguage,
            pFileInfo->m_bBeta ? TEXT("Beta") : TEXT("Final"),
            pFileInfo->m_bDebug ? TEXT("Debug") : TEXT("Retail"),
            pFileInfo->m_szDatestamp,
            pFileInfo->m_numBytes,
            pFileInfo->m_bSigned ? TEXT("Digitally Signed") : TEXT(""));
        _ftprintf(pFile, sz);
    }
    _ftprintf(pFile, TEXT("\n"));
    return S_OK;
}


/****************************************************************************
 *
 *  SaveDxWinComponentFileInfo
 *
 ****************************************************************************/
HRESULT SaveDxWinComponentFileInfo(FILE* pFile, FileInfo* pFileInfoFirst)
{
    if (pFileInfoFirst == NULL)
        return S_OK;
    
    FileInfo* pFileInfo;
    TCHAR sz[1024];

    _ftprintf(pFile, TEXT("------------------------------------------------\n"));
    _ftprintf(pFile, TEXT("Components Incorrectly Located in Windows Folder\n"));
    _ftprintf(pFile, TEXT("------------------------------------------------\n"));
    for (pFileInfo = pFileInfoFirst; pFileInfo != NULL; 
        pFileInfo = pFileInfo->m_pFileInfoNext)
    {
        wsprintf(sz, TEXT("%12s: %s %s %s %s %s %d bytes %s\n"), 
            pFileInfo->m_szName, 
            pFileInfo->m_szVersion, 
            pFileInfo->m_szLanguage,
            pFileInfo->m_bBeta ? TEXT("Beta") : TEXT("Final"),
            pFileInfo->m_bDebug ? TEXT("Debug") : TEXT("Retail"),
            pFileInfo->m_szDatestamp,
            pFileInfo->m_numBytes,
            pFileInfo->m_bSigned ? "Digitally Signed" : "");
        _ftprintf(pFile, sz);
    }
    _ftprintf(pFile, TEXT("\n"));
    return S_OK;
}


/****************************************************************************
 *
 *  SaveBackedUpFileInfo - Since this only shows up in the saved report, 
 *      we gather this info on the fly.
 *
 ****************************************************************************/
HRESULT SaveBackedUpFileInfo(FILE* pFile)
{
    FileInfo fileInfo;
    TCHAR szBackupDir[1024];
    TCHAR szCurrentDir[1024];
    TCHAR szFileSpec[1024];
    HANDLE hFindFile;
    WIN32_FIND_DATA findData;
    BOOL bFirstFile = TRUE;
    BOOL bFirstFileThisDir;
    HANDLE hFindFile2;
    WIN32_FIND_DATA findData2;

    GetSystemDirectory(szBackupDir, MAX_PATH);
    lstrcat(szBackupDir, TEXT("\\DXBackup"));
    lstrcpy(szFileSpec, szBackupDir);
    lstrcat(szFileSpec, TEXT("\\*.*"));

    hFindFile = FindFirstFile(szFileSpec, &findData); 
    if (hFindFile != INVALID_HANDLE_VALUE)
    {
        while (TRUE)
        {
            if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY &&
                lstrcmp(findData.cFileName, TEXT(".")) != 0 &&
                lstrcmp(findData.cFileName, TEXT("..")) != 0)
            {
                bFirstFileThisDir = TRUE;
                wsprintf(szCurrentDir, TEXT("%s\\%s"), szBackupDir, findData.cFileName);
                lstrcpy(szFileSpec, szCurrentDir);
                lstrcat(szFileSpec, TEXT("\\*.*"));
                hFindFile2 = FindFirstFile(szFileSpec, &findData2);
                if (hFindFile2 != INVALID_HANDLE_VALUE)
                {
                    while (TRUE)
                    {
                        if ((findData2.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                        {
                            if (bFirstFile)
                            {
                                bFirstFile = FALSE;
                                _ftprintf(pFile, TEXT("-----------------------------------------------\n"));
                                _ftprintf(pFile, TEXT("Backed-up drivers in %s\n"), szBackupDir);
                                _ftprintf(pFile, TEXT("-----------------------------------------------\n"));
                            }
                            else if (bFirstFileThisDir)
                            {
                                _ftprintf(pFile, TEXT("\n"));
                            }
                            if (bFirstFileThisDir)
                            {
                                bFirstFileThisDir = FALSE;
                                _ftprintf(pFile, TEXT("%s:\n"), szCurrentDir);
                            }
                            
                            wsprintf(szFileSpec, TEXT("%s\\%s"), szCurrentDir, findData2.cFileName);
                            ZeroMemory(&fileInfo, sizeof(fileInfo));
                            lstrcpy(fileInfo.m_szName, findData2.cFileName);
                            GetFileVersion(szFileSpec, fileInfo.m_szVersion, fileInfo.m_szAttributes, fileInfo.m_szLanguageLocal, fileInfo.m_szLanguage, &fileInfo.m_bBeta, &fileInfo.m_bDebug);
                            GetFileDateAndSize(szFileSpec, fileInfo.m_szDatestampLocal, fileInfo.m_szDatestamp, &fileInfo.m_numBytes);
                            FileIsSigned(szFileSpec, &fileInfo.m_bSigned, NULL);

                            _ftprintf(pFile, TEXT("%12s: %s %s %s %s Date: %s Size: %d bytes %s\n"), 
                                fileInfo.m_szName, 
                                fileInfo.m_szVersion, 
                                fileInfo.m_szLanguage,
                                fileInfo.m_bBeta ? TEXT("Beta") : TEXT("Final"),
                                fileInfo.m_bDebug ? TEXT("Debug") : TEXT("Retail"),
                                fileInfo.m_szDatestamp,
                                fileInfo.m_numBytes,
                                fileInfo.m_bSigned ? TEXT("Digitally Signed") : TEXT(""));
                        }
                        if (!FindNextFile(hFindFile2, &findData2))
                            break;
                    }
                    FindClose(hFindFile2);
                }
            }
            if (!FindNextFile(hFindFile, &findData))
                break;
        }
        FindClose(hFindFile);
    }; 

    if (!bFirstFile)
        _ftprintf(pFile, TEXT("\n"));

    return S_OK;
}


/****************************************************************************
 *
 *  SaveDisplayInfo
 *
 ****************************************************************************/
HRESULT SaveDisplayInfo(FILE* pFile, DisplayInfo* pDisplayInfoFirst)
{
    DisplayInfo* pDisplayInfo;
    TCHAR szVersion[1024];

    _ftprintf(pFile, TEXT("---------------\n"));
    _ftprintf(pFile, TEXT("Display Devices\n"));
    _ftprintf(pFile, TEXT("---------------\n"));
    for (pDisplayInfo = pDisplayInfoFirst; pDisplayInfo != NULL; 
        pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext)
    {
        wsprintf(szVersion, TEXT("%s (%s)"), pDisplayInfo->m_szDriverVersion, pDisplayInfo->m_szDriverLanguage);

        _ftprintf(pFile, TEXT("        Card name: %s\n"), pDisplayInfo->m_szDescription);
        _ftprintf(pFile, TEXT("     Manufacturer: %s\n"), pDisplayInfo->m_szManufacturer);
        _ftprintf(pFile, TEXT("        Chip type: %s\n"), pDisplayInfo->m_szChipType);
        _ftprintf(pFile, TEXT("         DAC type: %s\n"), pDisplayInfo->m_szDACType);
        _ftprintf(pFile, TEXT("        Device ID: %s\n"), pDisplayInfo->m_szKeyDeviceID);
        _ftprintf(pFile, TEXT("   Display Memory: %s\n"), pDisplayInfo->m_szDisplayMemoryEnglish);
        _ftprintf(pFile, TEXT("     Current Mode: %s\n"), pDisplayInfo->m_szDisplayModeEnglish);
        _ftprintf(pFile, TEXT("          Monitor: %s\n"), pDisplayInfo->m_szMonitorName);
        _ftprintf(pFile, TEXT("  Monitor Max Res: %s\n"), pDisplayInfo->m_szMonitorMaxRes);
        _ftprintf(pFile, TEXT("      Driver Name: %s\n"), pDisplayInfo->m_szDriverName);
        _ftprintf(pFile, TEXT("   Driver Version: %s\n"), szVersion);
        _ftprintf(pFile, TEXT("      DDI Version: %s\n"), pDisplayInfo->m_szDDIVersion);
        _ftprintf(pFile, TEXT("Driver Attributes: %s %s\n"), pDisplayInfo->m_bDriverBeta ? TEXT("Beta") : TEXT("Final"), pDisplayInfo->m_bDriverDebug ? TEXT("Debug") : TEXT("Retail"));
        _ftprintf(pFile, TEXT(" Driver Date/Size: %s, %d bytes\n"), pDisplayInfo->m_szDriverDate, pDisplayInfo->m_cbDriver);
        _ftprintf(pFile, TEXT("    Driver Signed: %s\n"), pDisplayInfo->m_bDriverSignedValid ? ( pDisplayInfo->m_bDriverSigned ? TEXT("Yes") : TEXT("No") ) : TEXT("n/a") );
        _ftprintf(pFile, TEXT("  WHQL Date Stamp: %s\n"), pDisplayInfo->m_bDX8DriverSignedValid ? ( pDisplayInfo->m_bDX8DriverSigned ? pDisplayInfo->m_szDX8DriverSignDate : TEXT("None") ) : TEXT("n/a") );
        _ftprintf(pFile, TEXT("              VDD: %s\n"), pDisplayInfo->m_szVdd);
        _ftprintf(pFile, TEXT("         Mini VDD: %s\n"), pDisplayInfo->m_szMiniVdd);
        _ftprintf(pFile, TEXT("    Mini VDD Date: %s, %d bytes\n"), pDisplayInfo->m_szMiniVddDate, pDisplayInfo->m_cbMiniVdd);
        _ftprintf(pFile, TEXT("Device Identifier: %s\n"), pDisplayInfo->m_szDX8DeviceIdentifier );
        _ftprintf(pFile, TEXT("        Vendor ID: %s\n"), pDisplayInfo->m_szDX8VendorId );
        _ftprintf(pFile, TEXT("        Device ID: %s\n"), pDisplayInfo->m_szDX8DeviceId );
        _ftprintf(pFile, TEXT("        SubSys ID: %s\n"), pDisplayInfo->m_szDX8SubSysId );
        _ftprintf(pFile, TEXT("      Revision ID: %s\n"), pDisplayInfo->m_szDX8Revision );

        if (pDisplayInfo->m_pRegErrorFirst == NULL)
        {
            _ftprintf(pFile, TEXT("         Registry: OK\n"));
        }
        else
        {
            _ftprintf(pFile, TEXT("         Registry: Errors found:\n"));
            SaveRegistryErrorInfo(pFile, pDisplayInfo->m_pRegErrorFirst);
        }

        _ftprintf(pFile, TEXT("     DDraw Status: %s\n"), pDisplayInfo->m_szDDStatusEnglish);
        _ftprintf(pFile, TEXT("       D3D Status: %s\n"), pDisplayInfo->m_szD3DStatusEnglish);
        _ftprintf(pFile, TEXT("       AGP Status: %s\n"), pDisplayInfo->m_szAGPStatusEnglish);

        _ftprintf(pFile, TEXT("DDraw Test Result: %s\n"), pDisplayInfo->m_testResultDD.m_szDescriptionEnglish);
        _ftprintf(pFile, TEXT(" D3D7 Test Result: %s\n"), pDisplayInfo->m_testResultD3D7.m_szDescriptionEnglish);
        _ftprintf(pFile, TEXT(" D3D8 Test Result: %s\n"), pDisplayInfo->m_testResultD3D8.m_szDescriptionEnglish);
        _ftprintf(pFile, TEXT("\n"));
    }

    return S_OK;
}


/****************************************************************************
 *
 *  SaveSoundInfo
 *
 ****************************************************************************/
HRESULT SaveSoundInfo(FILE* pFile, SoundInfo* pSoundInfoFirst)
{
    SoundInfo* pSoundInfo;
    TCHAR szAcceleration[1024];
    TCHAR szVersion[1024];
    TCHAR szAttributes[1024];
    TCHAR szSigned[1024];
    TCHAR szDateSize[1024];

    _ftprintf(pFile, TEXT("-------------\n"));
    _ftprintf(pFile, TEXT("Sound Devices\n"));
    _ftprintf(pFile, TEXT("-------------\n"));
    for (pSoundInfo = pSoundInfoFirst; pSoundInfo != NULL; 
        pSoundInfo = pSoundInfo->m_pSoundInfoNext)
    {
        switch (pSoundInfo->m_lwAccelerationLevel)
        {
        case 0:
            lstrcpy(szAcceleration, TEXT("Emulation Only"));
            break;
        case 1:
            lstrcpy(szAcceleration, TEXT("Basic"));
            break;
        case 2:
            lstrcpy(szAcceleration, TEXT("Standard"));
            break;
        case 3:
            lstrcpy(szAcceleration, TEXT("Full"));
            break;
        default:
            lstrcpy(szAcceleration, TEXT("Unknown"));
            break;
        }
        if (lstrlen(pSoundInfo->m_szDriverName) > 0)
        {
            wsprintf(szVersion, TEXT("%s (%s)"), pSoundInfo->m_szDriverVersion, pSoundInfo->m_szDriverLanguage);
            wsprintf(szAttributes, TEXT("%s %s"), pSoundInfo->m_bDriverBeta ? TEXT("Beta") : TEXT("Final"), pSoundInfo->m_bDriverDebug ? TEXT("Debug") : TEXT("Retail"));
            wsprintf(szSigned, TEXT("%s"), pSoundInfo->m_bDriverSignedValid ? ( pSoundInfo->m_bDriverSigned ? TEXT("Yes") : TEXT("No") ) : TEXT("n/a") );
            wsprintf(szDateSize, TEXT("%s, %d bytes"), pSoundInfo->m_szDriverDate, pSoundInfo->m_numBytes);
        }
        else
        {
            lstrcpy(szVersion, TEXT(""));
            lstrcpy(szAttributes, TEXT(""));
            lstrcpy(szSigned, TEXT(""));
            lstrcpy(szDateSize, TEXT(""));
        }

        _ftprintf(pFile, TEXT("      Description: %s\n"), pSoundInfo->m_szDescription);
        _ftprintf(pFile, TEXT("        Device ID: %s\n"), pSoundInfo->m_szDeviceID);
        _ftprintf(pFile, TEXT("  Manufacturer ID: %s\n"), pSoundInfo->m_szManufacturerID);
        _ftprintf(pFile, TEXT("       Product ID: %s\n"), pSoundInfo->m_szProductID);
        _ftprintf(pFile, TEXT("             Type: %s\n"), pSoundInfo->m_szType);
        _ftprintf(pFile, TEXT("      Driver Name: %s\n"), pSoundInfo->m_szDriverName);
        _ftprintf(pFile, TEXT("   Driver Version: %s\n"), szVersion);
        _ftprintf(pFile, TEXT("Driver Attributes: %s\n"), szAttributes);
        _ftprintf(pFile, TEXT("    Driver Signed: %s\n"), szSigned);
        _ftprintf(pFile, TEXT("    Date and Size: %s\n"), szDateSize);
        _ftprintf(pFile, TEXT("      Other Files: %s\n"), pSoundInfo->m_szOtherDrivers);
        _ftprintf(pFile, TEXT("  Driver Provider: %s\n"), pSoundInfo->m_szProvider);
        _ftprintf(pFile, TEXT("   HW Accel Level: %s\n"), szAcceleration);
        if (pSoundInfo->m_pRegErrorFirst == NULL)
        {
            _ftprintf(pFile, TEXT("         Registry: OK\n"));
        }
        else
        {
            _ftprintf(pFile, TEXT("         Registry: Errors found:\n"));
            SaveRegistryErrorInfo(pFile, pSoundInfo->m_pRegErrorFirst);
        }
        _ftprintf(pFile, TEXT("Sound Test Result: %s\n"), pSoundInfo->m_testResultSnd.m_szDescriptionEnglish);
        _ftprintf(pFile, TEXT("\n"));
    }
    return S_OK;
}


/****************************************************************************
 *
 *  SaveMusicInfo
 *
 ****************************************************************************/
HRESULT SaveMusicInfo(FILE* pFile, MusicInfo* pMusicInfo)
{
    MusicPort* pMusicPort;

    if (pMusicInfo == NULL || !pMusicInfo->m_bDMusicInstalled)
        return S_OK;

    _ftprintf(pFile, TEXT("-----------\n"));
    _ftprintf(pFile, TEXT("DirectMusic\n"));
    _ftprintf(pFile, TEXT("-----------\n"));

    _ftprintf(pFile, TEXT(" DLS Path: %s\n"), pMusicInfo->m_szGMFilePath);
    _ftprintf(pFile, TEXT("  Version: %s\n"), pMusicInfo->m_szGMFileVersion);
    _ftprintf(pFile, TEXT("    Ports:\n"));

    for (pMusicPort = pMusicInfo->m_pMusicPortFirst; pMusicPort != NULL; 
        pMusicPort = pMusicPort->m_pMusicPortNext)
    {
        _ftprintf(pFile, TEXT("           %s, %s (%s), %s, %s, %s%s\n"), 
            pMusicPort->m_szDescription, 
            pMusicPort->m_bSoftware ? TEXT("Software") : TEXT("Hardware"),
            pMusicPort->m_bKernelMode ? TEXT("Kernel Mode") : TEXT("Not Kernel Mode"),
            pMusicPort->m_bOutputPort ? TEXT("Output") : TEXT("Input"), 
            pMusicPort->m_bUsesDLS ? TEXT("DLS") : TEXT("No DLS"), 
            pMusicPort->m_bExternal ? TEXT("External") : TEXT("Internal"), 
            pMusicPort->m_bDefaultPort ? TEXT(", Default Port") : TEXT("")
            );
    }
    if (pMusicInfo->m_pRegErrorFirst == NULL)
    {
        _ftprintf(pFile, TEXT(" Registry: OK\n"));
    }
    else
    {
        _ftprintf(pFile, TEXT(" Registry: Errors found:\n"));
        SaveRegistryErrorInfo(pFile, pMusicInfo->m_pRegErrorFirst);
    }
    _ftprintf(pFile, TEXT("Music Test Result: %s\n"), pMusicInfo->m_testResult.m_szDescriptionEnglish);
    _ftprintf(pFile, TEXT("\n"));
    return S_OK;
}


/****************************************************************************
 *
 *  SaveShowInfo - Since this only shows up in the saved report, 
 *      we gather this info on the fly.
 *
 ****************************************************************************/
HRESULT SaveShowInfo(FILE* pFile, ShowInfo* pShowInfo)
{
    if( pShowInfo == NULL )
        return S_OK;      

    _ftprintf(pFile, TEXT("------------------\n"));
    _ftprintf(pFile, TEXT("DirectShow Filters\n"));
    _ftprintf(pFile, TEXT("------------------\n"));

    FilterInfo* pFilterInfo;

    TCHAR szCurCatName[1024];        
    TCHAR* szFileName = NULL;
    TCHAR* szLastSlash = NULL;
    _tcscpy( szCurCatName, TEXT("") );
    
    pFilterInfo = pShowInfo->m_pFilters;
    while(pFilterInfo)
    {
        if( _tcscmp( pFilterInfo->m_szCatName, szCurCatName ) != 0 )
        {
            _ftprintf(pFile, TEXT("\n%s:\n"), pFilterInfo->m_szCatName);
            _tcscpy( szCurCatName, pFilterInfo->m_szCatName );
        }
            
        _ftprintf(pFile, TEXT("%s,"), pFilterInfo->m_szName);
        _ftprintf(pFile, TEXT("0x%08x,"), pFilterInfo->m_dwMerit);
        _ftprintf(pFile, TEXT("%d,"), pFilterInfo->m_dwInputs);
        _ftprintf(pFile, TEXT("%d,"), pFilterInfo->m_dwOutputs);

        // Display only the file name
        szFileName = pFilterInfo->m_szFileName;
        szLastSlash = _tcsrchr( pFilterInfo->m_szFileName, TEXT('\\') );
        if( szLastSlash ) 
            szFileName = szLastSlash + 1;
        _ftprintf(pFile, TEXT("%s,"), szFileName);

        _ftprintf(pFile, TEXT("%s\n"), pFilterInfo->m_szFileVersion);

        pFilterInfo = pFilterInfo->m_pFilterInfoNext;
    }
    _ftprintf(pFile, TEXT("\n"));

    return S_OK;
}


/****************************************************************************
 *
 *  SaveInputInfo
 *
 ****************************************************************************/
HRESULT SaveInputInfo(FILE* pFile, InputInfo* pInputInfo)
{
    InputDeviceInfo* pInputDeviceInfo;
    InputDeviceInfoNT* pInputDeviceInfoNT;
    InputDriverInfo* pInputDriverInfo;

    _ftprintf(pFile, TEXT("-------------\n"));
    _ftprintf(pFile, TEXT("Input Devices\n"));
    _ftprintf(pFile, TEXT("-------------\n"));

    if( pInputInfo == NULL )
        return S_OK;

    if (pInputInfo->m_bNT)
    {
        for (pInputDeviceInfoNT = pInputInfo->m_pInputDeviceInfoNTFirst; pInputDeviceInfoNT != NULL; 
            pInputDeviceInfoNT = pInputDeviceInfoNT->m_pInputDeviceInfoNTNext)
        {
            _ftprintf(pFile, TEXT("      Device Name: %s\n"), pInputDeviceInfoNT->m_szName);
            _ftprintf(pFile, TEXT("         Provider: %s\n"), pInputDeviceInfoNT->m_szProvider);
            _ftprintf(pFile, TEXT("      Hardware ID: %s\n"), pInputDeviceInfoNT->m_szId);
            _ftprintf(pFile, TEXT("           Status: %d\n"), pInputDeviceInfoNT->m_dwProblem);
            _ftprintf(pFile, TEXT("        Port Name: %s\n"), pInputDeviceInfoNT->m_szPortName);
            _ftprintf(pFile, TEXT("    Port Provider: %s\n"), pInputDeviceInfoNT->m_szPortProvider);
            _ftprintf(pFile, TEXT("          Port ID: %s\n"), pInputDeviceInfoNT->m_szPortId);
            _ftprintf(pFile, TEXT("      Port Status: %d\n"), pInputDeviceInfoNT->m_dwPortProblem);
            _ftprintf(pFile, TEXT("\n"));
        }
    }
    else
    {
        for (pInputDeviceInfo = pInputInfo->m_pInputDeviceInfoFirst; pInputDeviceInfo != NULL; 
            pInputDeviceInfo = pInputDeviceInfo->m_pInputDeviceInfoNext)
        {
            _ftprintf(pFile, TEXT("      Device Name: %s\n"), pInputDeviceInfo->m_szDeviceName);
            _ftprintf(pFile, TEXT("      Driver Name: %s\n"), pInputDeviceInfo->m_szDriverName);
            _ftprintf(pFile, TEXT("   Driver Version: %s"), pInputDeviceInfo->m_szDriverVersion);
            _ftprintf(pFile, TEXT(" (%s)\n"), pInputDeviceInfo->m_szDriverLanguage);
            _ftprintf(pFile, TEXT("Driver Attributes: %s %s\n"), pInputDeviceInfo->m_bBeta ? "Beta" : "Final", pInputDeviceInfo->m_bDebug ? "Debug" : "Retail");
            _ftprintf(pFile, TEXT("    Date and Size: %s, %d bytes\n"), pInputDeviceInfo->m_szDriverDate, pInputDeviceInfo->m_numBytes);
            _ftprintf(pFile, TEXT("\n"));
        }
    }
    
    _ftprintf(pFile, TEXT("Poll w/ Interrupt: "));
    _ftprintf(pFile, (pInputInfo->m_bPollFlags) ? TEXT("Yes\n") : TEXT("No\n") );

    if (pInputInfo->m_pRegErrorFirst == NULL)
    {
        _ftprintf(pFile, TEXT("         Registry: OK\n"));
    }
    else
    {
        _ftprintf(pFile, TEXT("         Registry: Errors found:\n"));
        SaveRegistryErrorInfo(pFile, pInputInfo->m_pRegErrorFirst);
    }
    _ftprintf(pFile, TEXT("\n"));
    _ftprintf(pFile, TEXT("-------------\n"));
    _ftprintf(pFile, TEXT("Input Drivers\n"));
    _ftprintf(pFile, TEXT("-------------\n"));
    for (pInputDriverInfo = pInputInfo->m_pInputDriverInfoFirst; pInputDriverInfo != NULL; 
        pInputDriverInfo = pInputDriverInfo->m_pInputDriverInfoNext)
    {
        _ftprintf(pFile, TEXT("  Registry Key: %s\n"), pInputDriverInfo->m_szRegKey);
        _ftprintf(pFile, TEXT("        Active: %s\n"), pInputDriverInfo->m_bActive ? "Yes" : "No");
        _ftprintf(pFile, TEXT("      DeviceID: %s\n"), pInputDriverInfo->m_szDeviceID);
        _ftprintf(pFile, TEXT("Matching DevID: %s\n"), pInputDriverInfo->m_szMatchingDeviceID);
        _ftprintf(pFile, TEXT(" 16-bit Driver: %s\n"), pInputDriverInfo->m_szDriver16);
        _ftprintf(pFile, TEXT(" 32-bit Driver: %s\n"), pInputDriverInfo->m_szDriver32);
        _ftprintf(pFile, TEXT("\n"));
    }
    _ftprintf(pFile, TEXT("\n"));
    return S_OK;
}


/****************************************************************************
 *
 *  SaveNetInfo
 *
 ****************************************************************************/
HRESULT SaveNetInfo(FILE* pFile, NetInfo* pNetInfo)
{
    NetSP* pNetSP;
    NetApp* pNetApp;

    _ftprintf(pFile, TEXT("----------------------------\n"));
    _ftprintf(pFile, TEXT("DirectPlay Service Providers\n"));
    _ftprintf(pFile, TEXT("----------------------------\n"));

    if( pNetInfo == NULL )
        return S_OK;

    for (pNetSP = pNetInfo->m_pNetSPFirst; pNetSP != NULL; pNetSP = pNetSP->m_pNetSPNext)
    {
        _ftprintf(pFile, TEXT("%s - Registry: %s, File: %s (%s)\n"), 
            pNetSP->m_szNameEnglish,
            pNetSP->m_bRegistryOK ? TEXT("OK") : TEXT("Error"),
            pNetSP->m_szFile,
            pNetSP->m_szVersionEnglish);
    }
    _ftprintf(pFile, TEXT("DirectPlay Test Result: %s\n"), pNetInfo->m_testResult.m_szDescriptionEnglish);
    _ftprintf(pFile, TEXT("\n"));

    _ftprintf(pFile, TEXT("-------------------------\n"));
    _ftprintf(pFile, TEXT("DirectPlay Lobbyable Apps\n"));
    _ftprintf(pFile, TEXT("-------------------------\n"));
    for (pNetApp = pNetInfo->m_pNetAppFirst; pNetApp != NULL; pNetApp = pNetApp->m_pNetAppNext)
    {
        if( pNetApp->m_dwDXVer == 7 )
        {
            _ftprintf(pFile, TEXT("%s (DX%d) - Registry: %s, ExeFile: %s (%s)\n"), 
                pNetApp->m_szName,
                pNetApp->m_dwDXVer,
                pNetApp->m_bRegistryOK ? TEXT("OK") : TEXT("Error"),
                pNetApp->m_szExeFile,
                pNetApp->m_szExeVersionEnglish);
        }
        else
        {
            _ftprintf(pFile, TEXT("%s (DX%d) - Registry: %s, ExeFile: %s (%s) LauncherFile: %s (%s)\n"), 
                pNetApp->m_szName,
                pNetApp->m_dwDXVer,
                pNetApp->m_bRegistryOK ? TEXT("OK") : TEXT("Error"),
                pNetApp->m_szExeFile,
                pNetApp->m_szExeVersionEnglish,
                pNetApp->m_szLauncherFile,
                pNetApp->m_szLauncherVersionEnglish);
        }
    }
    _ftprintf(pFile, TEXT("\n"));
    return S_OK;
}


/****************************************************************************
 *
 *  SaveInactiveDriverInfo
 *
 ****************************************************************************/
HRESULT SaveInactiveDriverInfo(FILE* pFile, DisplayInfo* pDisplayInfoFirst)
{
    BOOL bNoInactive;
    HKEY hKey;
    DWORD cbData;
    DWORD dwIndex;
    TCHAR szSubKeyName[1024];
    DisplayInfo* pDisplayInfo;
    HKEY hSubKey;
    TCHAR szSubSubKey[1024];
    TCHAR szDriverDesc[1024];
    DWORD ulType;
    TCHAR szTempString[1024];

    if (BIsPlatformNT())
        return S_OK;

    _ftprintf(pFile, TEXT("------------------------------------\n"));
    _ftprintf(pFile, TEXT("Inactive Display Entries in Registry\n"));
    _ftprintf(pFile, TEXT("------------------------------------\n"));

    bNoInactive = TRUE;

    // Display info (inactive).
    hKey = 0;
    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Services\\Class\\Display"), 0, KEY_READ, &hKey))
    {
        cbData = sizeof szSubKeyName;
        dwIndex = 0;

        while (!RegEnumKeyEx(hKey, dwIndex, szSubKeyName, &cbData, NULL, NULL, NULL, NULL))
        {
            TCHAR* pch;
            BOOL bMatch = FALSE;

            // See if this driver is used:
            for (pDisplayInfo = pDisplayInfoFirst; pDisplayInfo != NULL;
                pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext)
            {
                pch = _tcsrchr(pDisplayInfo->m_szKeyDeviceKey, TEXT('\\'));
                if (pch != NULL)
                {
                    pch++;
                    
                    if (lstrcmp(szSubKeyName, pch) == 0)
                    {
                        bMatch = TRUE;
                        break;
                    }
                }
            }            

            if (!bMatch)
            {
                hSubKey = 0;
                wsprintf(szSubSubKey, TEXT("System\\CurrentControlSet\\Services\\Class\\Display\\%s"), szSubKeyName);

                if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubSubKey, 0, KEY_READ, &hSubKey))
                {
                    cbData = sizeof szDriverDesc;
                    szDriverDesc[0] = 0;
                    RegQueryValueEx(hSubKey, TEXT("DriverDesc"), 0, &ulType, (LPBYTE)szDriverDesc, &cbData);

                    _ftprintf(pFile, TEXT(" Card name: %s\n"), szDriverDesc);
                    bNoInactive = FALSE;
                }

                if (hSubKey)
                {
                    RegCloseKey(hSubKey);
                    hSubKey = 0;
                }

                wsprintf(szSubSubKey, TEXT("System\\CurrentControlSet\\Services\\Class\\Display\\%s\\DEFAULT"), szSubKeyName);

                if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubSubKey, 0, KEY_READ, &hSubKey))
                {
                    TCHAR szDisplayDriverName[1024];     
                    cbData = sizeof szDisplayDriverName;
                    szDisplayDriverName[0] = 0;
                    RegQueryValueEx(hSubKey, TEXT("DRV"), 0, &ulType, (LPBYTE)szDisplayDriverName, &cbData);

                    _ftprintf(pFile, TEXT("    Driver: %s\n"), szDisplayDriverName);
                    bNoInactive = FALSE;
                }

                if (hSubKey)
                {
                    RegCloseKey(hSubKey);
                    hSubKey = 0;
                }
            } 

            cbData = sizeof szSubKeyName;
            dwIndex++;
        }
    }

    if (hKey)
    {
        RegCloseKey(hKey);
        hKey = 0;
    }

    if (bNoInactive)
        _ftprintf(pFile, TEXT(" None\n"));

    _ftprintf(pFile, TEXT("\n"));

    _ftprintf(pFile, TEXT("----------------------------------\n"));
    _ftprintf(pFile, TEXT("Inactive Sound Entries in Registry\n"));
    _ftprintf(pFile, TEXT("----------------------------------\n"));

    bNoInactive = TRUE;

    hKey = 0;
    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\control\\MediaResources\\wave"), 0, KEY_READ, &hKey))
    {
        dwIndex = 0;
        while (TRUE)
        {
            cbData = sizeof szSubKeyName;
            if (ERROR_SUCCESS != RegEnumKeyEx(hKey, dwIndex, szSubKeyName, &cbData, NULL, NULL, NULL, NULL))
                break;

            if (!RegOpenKeyEx(hKey, szSubKeyName, 0, KEY_READ, &hSubKey))
            {
                cbData = sizeof szTempString;
                if (!RegQueryValueEx(hSubKey, TEXT("Active"), 0, &ulType, (LPBYTE)szTempString, &cbData))
                {
                    if (lstrcmp(szTempString, TEXT("0")) == 0)
                    {
                        TCHAR szWaveOutDesc[1024];
                        TCHAR szWaveDriverName[1024];
                        cbData = sizeof szWaveOutDesc;
                        RegQueryValueEx(hSubKey, TEXT("Description"), 0, &ulType, (LPBYTE)szWaveOutDesc, &cbData);

                        cbData = sizeof szWaveDriverName;
                        RegQueryValueEx(hSubKey, TEXT("Driver"), 0, &ulType, (LPBYTE)szWaveDriverName, &cbData);

                        _ftprintf(pFile, TEXT(" Card name: %s\n"), szWaveOutDesc);
                        _ftprintf(pFile, TEXT("    Driver: %s\n"), szWaveDriverName);
                        bNoInactive = FALSE;
                    }
                }
                RegCloseKey(hSubKey);
            }
            dwIndex++;
        }
        RegCloseKey(hKey);
    }

    if (bNoInactive)
        _ftprintf(pFile, TEXT(" None\n"));

    _ftprintf(pFile, TEXT("\n"));

    return S_OK;
}


/****************************************************************************
 *
 *  SaveRegistryErrorInfo
 *
 ****************************************************************************/
HRESULT SaveRegistryErrorInfo(FILE* pFile, RegError* pRegErrorFirst)
{
    RegError* pRegError = pRegErrorFirst;
    DWORD i;
    CHAR* pszRoot;

    while (pRegError != NULL)
    {
        switch ((DWORD_PTR)pRegError->m_hkeyRoot)
        {
        case (DWORD_PTR)HKEY_LOCAL_MACHINE:
            pszRoot = "HKLM";
            break;
        case (DWORD_PTR)HKEY_CURRENT_USER:
            pszRoot = "HKCU";
            break;
        case (DWORD_PTR)HKEY_CLASSES_ROOT:
            pszRoot = "HKCR";
            break;
        case (DWORD_PTR)HKEY_USERS:
            pszRoot = "HKU";
            break;
        case (DWORD_PTR)HKEY_CURRENT_CONFIG:
            pszRoot = "HKCC";
            break;
        default:
            pszRoot = "";
            break;
        }

        _ftprintf(pFile, TEXT("Key '%s\\%s'"), pszRoot, pRegError->m_szKey);
        switch (pRegError->m_ret)
        {
        case RET_MISSINGKEY:
            _ftprintf(pFile, TEXT(" is missing.\n"));
            break;
        case RET_MISSINGVALUE:
            _ftprintf(pFile, TEXT(" is missing value '%s'.\n"), pRegError->m_szValue);
            break;
        case RET_VALUEWRONGTYPE:
            _ftprintf(pFile, TEXT(" has value '%s', but it is the wrong type.\n"), pRegError->m_szValue);
            break;
        case RET_VALUEWRONGDATA:
            _ftprintf(pFile, TEXT(", Value '%s'"), pRegError->m_szValue);
            switch(pRegError->m_dwTypeActual)
            {
            case REG_DWORD:
                _ftprintf(pFile, TEXT(", should be '%d' but is '%d'.\n"), pRegError->m_dwExpected, pRegError->m_dwActual);
                break;
            case REG_SZ:
                _ftprintf(pFile, TEXT(", should be '%s'"), pRegError->m_szExpected);
                _ftprintf(pFile, TEXT(", but is '%s'.\n"), pRegError->m_szActual);
                break;
            case REG_BINARY:
                _ftprintf(pFile, TEXT(", should be '"));
                for (i = 0; i < pRegError->m_dwExpectedSize; i++)
                    _ftprintf(pFile, TEXT("%02x"), pRegError->m_bExpected[i]);
                _ftprintf(pFile, TEXT("' but is '"));
                for (i = 0; i < pRegError->m_dwActualSize; i++)
                    _ftprintf(pFile, TEXT("%02x"), pRegError->m_bActual[i]);
                _ftprintf(pFile, TEXT("'.\n"));
                break;
            }
            break;
        }
        pRegError = pRegError->m_pRegErrorNext;
    }

    return S_OK;
}




/****************************************************************************
 *
 *  SaveDebugLevels
 *
 ****************************************************************************/
HRESULT SaveDebugLevels(FILE* pFile, SysInfo* pSysInfo)
{
    TCHAR sz[1024];

    if( pSysInfo->m_bIsD3D8DebugRuntimeAvailable        ||
        pSysInfo->m_bIsDInput8DebugRuntimeAvailable     ||
        pSysInfo->m_bIsDMusicDebugRuntimeAvailable      ||
        pSysInfo->m_bIsDDrawDebugRuntime                ||
        pSysInfo->m_bIsDSoundDebugRuntime               ||
        pSysInfo->m_bIsDPlayDebugRuntime                ||
        pSysInfo->m_nD3DDebugLevel > 0                  ||
        pSysInfo->m_nDDrawDebugLevel > 0                ||
        pSysInfo->m_nDIDebugLevel > 0                   ||
        pSysInfo->m_nDMusicDebugLevel > 0               ||
        pSysInfo->m_nDPlayDebugLevel > 0                ||
        pSysInfo->m_nDSoundDebugLevel > 0 )
    {
        _ftprintf(pFile, TEXT("--------------------\n"));
        _ftprintf(pFile, TEXT("DirectX Debug Levels\n"));
        _ftprintf(pFile, TEXT("--------------------\n"));

        _stprintf(sz, TEXT("Direct3D:    %d/4 (%s)\n"), pSysInfo->m_nD3DDebugLevel, pSysInfo->m_bIsD3D8DebugRuntimeAvailable ? (pSysInfo->m_bIsD3DDebugRuntime ? TEXT("debug") : TEXT("retail") ) : TEXT("n/a") );
        _ftprintf(pFile, sz);
        _stprintf(sz, TEXT("DirectDraw:  %d/4 (%s)\n"), pSysInfo->m_nDDrawDebugLevel, pSysInfo->m_bIsDDrawDebugRuntime ? TEXT("debug") : TEXT("retail") );
        _ftprintf(pFile, sz);
        _stprintf(sz, TEXT("DirectInput: %d/5 (%s)\n"), pSysInfo->m_nDIDebugLevel, pSysInfo->m_bIsDInput8DebugRuntimeAvailable ? (pSysInfo->m_bIsDInput8DebugRuntime ? TEXT("debug") : TEXT("retail") ) : TEXT("n/a") );
        _ftprintf(pFile, sz);
        _stprintf(sz, TEXT("DirectMusic: %d/5 (%s)\n"), pSysInfo->m_nDMusicDebugLevel, pSysInfo->m_bIsDMusicDebugRuntimeAvailable ? (pSysInfo->m_bIsDMusicDebugRuntime ? TEXT("debug") : TEXT("retail") ) : TEXT("n/a") );
        _ftprintf(pFile, sz);
        _stprintf(sz, TEXT("DirectPlay:  %d/9 (%s)\n"), pSysInfo->m_nDPlayDebugLevel, pSysInfo->m_bIsDPlayDebugRuntime ? TEXT("debug") : TEXT("retail") );
        _ftprintf(pFile, sz);
        _stprintf(sz, TEXT("DirectSound: %d/5 (%s)\n"), pSysInfo->m_nDSoundDebugLevel, pSysInfo->m_bIsDSoundDebugRuntime ? TEXT("debug") : TEXT("retail") );
        _ftprintf(pFile, sz);
        
        _ftprintf(pFile, TEXT("\n"));
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\showinfo.cpp ===
/****************************************************************************
 *
 *    File: showinfo.cpp 
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about DirectShow on this machine
 *
 * (C) Copyright 2001 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/
#include <windows.h>
#include <stdio.h>
#include <strmif.h>     // Generated IDL header file for streams interfaces
#include <uuids.h>      // declaration of type GUIDs and well-known clsids
#include <assert.h>
#include "sysinfo.h"
#include "fileinfo.h"   // for GetFileVersion
#include "showinfo.h"


/****************************************************************************
 *
 *  Helper IAMFilterData - cut and paste from dshow\h\fil_data.c
 *
 ****************************************************************************/
/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __fil_data_h__
#define __fil_data_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IAMFilterData_FWD_DEFINED__
#define __IAMFilterData_FWD_DEFINED__
typedef interface IAMFilterData IAMFilterData;
#endif  /* __IAMFilterData_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "strmif.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_fil_data_0000 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_fil_data_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fil_data_0000_v0_0_s_ifspec;

#ifndef __IAMFilterData_INTERFACE_DEFINED__
#define __IAMFilterData_INTERFACE_DEFINED__

/* interface IAMFilterData */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMFilterData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97f7c4d4-547b-4a5f-8332-536430ad2e4d")
    IAMFilterData : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseFilterData( 
            /* [size_is][in] */ BYTE __RPC_FAR *rgbFilterData,
            /* [in] */ ULONG cb,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbRegFilter2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFilterData( 
            /* [in] */ REGFILTER2 __RPC_FAR *prf2,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbFilterData,
            /* [out] */ ULONG __RPC_FAR *pcb) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IAMFilterDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAMFilterData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAMFilterData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAMFilterData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseFilterData )( 
            IAMFilterData __RPC_FAR * This,
            /* [size_is][in] */ BYTE __RPC_FAR *rgbFilterData,
            /* [in] */ ULONG cb,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbRegFilter2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateFilterData )( 
            IAMFilterData __RPC_FAR * This,
            /* [in] */ REGFILTER2 __RPC_FAR *prf2,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbFilterData,
            /* [out] */ ULONG __RPC_FAR *pcb);
        
        END_INTERFACE
    } IAMFilterDataVtbl;

    interface IAMFilterData
    {
        CONST_VTBL struct IAMFilterDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMFilterData_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMFilterData_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IAMFilterData_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IAMFilterData_ParseFilterData(This,rgbFilterData,cb,prgbRegFilter2) \
    (This)->lpVtbl -> ParseFilterData(This,rgbFilterData,cb,prgbRegFilter2)

#define IAMFilterData_CreateFilterData(This,prf2,prgbFilterData,pcb)    \
    (This)->lpVtbl -> CreateFilterData(This,prf2,prgbFilterData,pcb)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IAMFilterData_ParseFilterData_Proxy( 
    IAMFilterData __RPC_FAR * This,
    /* [size_is][in] */ BYTE __RPC_FAR *rgbFilterData,
    /* [in] */ ULONG cb,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbRegFilter2);


void __RPC_STUB IAMFilterData_ParseFilterData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMFilterData_CreateFilterData_Proxy( 
    IAMFilterData __RPC_FAR * This,
    /* [in] */ REGFILTER2 __RPC_FAR *prf2,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbFilterData,
    /* [out] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IAMFilterData_CreateFilterData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IAMFilterData_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif


/****************************************************************************
 *
 *  Helper IAMFilterData - cut and paste from dshow\h\fil_data_i.c
 *
 ****************************************************************************/
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IAMFilterData = {0x97f7c4d4,0x547b,0x4a5f,{0x83,0x32,0x53,0x64,0x30,0xad,0x2e,0x4d}};


#ifdef __cplusplus
}
#endif



/****************************************************************************
 *
 *  Forward declaration
 *
 ****************************************************************************/
HRESULT GenerateFilterList(ShowInfo* pShowInfo);
HRESULT EnumerateFilterPerCategory(ShowInfo* pShowInfo, CLSID* clsid, WCHAR* wszCatName);
HRESULT GetFilterInfo(IMoniker* pMon, IAMFilterData* pFD, FilterInfo* pFilterInfo);


/****************************************************************************
 *
 *  GetBasicShowInfo - Get minimal info on DirectShow
 *
 ****************************************************************************/
HRESULT GetBasicShowInfo(ShowInfo** ppShowInfo)
{
    ShowInfo* pShowInfoNew;
    
    pShowInfoNew = new ShowInfo;
    if (pShowInfoNew == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(pShowInfoNew, sizeof(ShowInfo));
    *ppShowInfo = pShowInfoNew;

    return GenerateFilterList(pShowInfoNew);
}

/****************************************************************************
 *
 *  DestroyShowInfo
 *
 ****************************************************************************/
VOID DestroyShowInfo(ShowInfo* pShowInfo)
{
    if (!pShowInfo) return;

    if (pShowInfo->m_dwFilters)
    {
        FilterInfo* pFilterInfo;
        FilterInfo* pFilterInfoNext;

        pFilterInfo = pShowInfo->m_pFilters;
        while(pFilterInfo)
        {
            pFilterInfoNext = pFilterInfo->m_pFilterInfoNext;
            delete pFilterInfo;
            pFilterInfo = pFilterInfoNext;
        }
    }
    delete pShowInfo;
}

HRESULT GenerateFilterList(ShowInfo* pShowInfo)
{
    HRESULT hr;
    ICreateDevEnum* pSysDevEnum = NULL;
    IEnumMoniker*   pMonEnum = NULL;
    IMoniker*       pMon = NULL;
    ULONG cFetched;

    pShowInfo->m_dwFilters = 0;
    hr = CoCreateInstance(CLSID_SystemDeviceEnum,
                          NULL,
                          CLSCTX_INPROC,
                          IID_ICreateDevEnum,
                          (void **)&pSysDevEnum);
    if FAILED(hr)
    {
        return hr;
    }

    // Use the meta-category that contains a list of all categories.
    // This emulates the behavior of Graphedit.
    hr = pSysDevEnum->CreateClassEnumerator(CLSID_ActiveMovieCategories, &pMonEnum, 0);
    pSysDevEnum->Release();
    if FAILED(hr)
    {
        return hr;
    }

    // Enumerate over every category
    while (hr = pMonEnum->Next(1, &pMon, &cFetched), hr == S_OK)
    {
        IPropertyBag *pPropBag;

        // Associate moniker with a file
        hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
        if (SUCCEEDED(hr))
        {
            WCHAR wszCatName[1024] = L"";
            CLSID clsidCategory;
            VARIANT var;
            var.vt = VT_BSTR;

            // Get friendly name
            hr = pPropBag->Read(L"FriendlyName", &var, 0);
            if(SUCCEEDED(hr))
            {
                wcscpy(wszCatName, var.bstrVal);
                SysFreeString(var.bstrVal);
            }
            // Get CLSID string from property bag
            hr = pPropBag->Read(L"CLSID", &var, 0);
            if (SUCCEEDED(hr))
            {
                if (CLSIDFromString(var.bstrVal, &clsidCategory) == S_OK)
                {
                    if (TEXT('\0') == wszCatName[0])
                    {
                        wcscpy(wszCatName, var.bstrVal);
                    }
                }
                SysFreeString(var.bstrVal);
            }

            pPropBag->Release();

            // Start to enumerate the filters for this one category
            hr = EnumerateFilterPerCategory(pShowInfo, &clsidCategory, wszCatName);
        }

        pMon->Release();
    }

    pMonEnum->Release();
    return hr;
}



HRESULT EnumerateFilterPerCategory(ShowInfo* pShowInfo, CLSID* clsid, WCHAR* wszCatName)
{
    HRESULT hr;
    ICreateDevEnum* pSysDevEnum = NULL;
    IEnumMoniker *pMonEnum = NULL;
    IMoniker *pMon = NULL;
    ULONG cFetched;

#ifdef RUNNING_VC    
    // WMP bug 29936: Voxware codec corrupt:  MSMS001 : corrupted heap
    // This causes this call int3 when inside a debugger so skip
    const CLSID clsidACMClassManager = {0x33d9a761,0x90c8,0x11d0,{0xbd,0x43,0x00,0xa0,0xc9,0x11,0xce,0x86}};
    if( *clsid == clsidACMClassManager )
        return S_OK;
#endif

    hr = CoCreateInstance(CLSID_SystemDeviceEnum,
                          NULL,
                          CLSCTX_INPROC,
                          IID_ICreateDevEnum,
                          (void **)&pSysDevEnum);
    if FAILED(hr)
    {
        return hr;
    }

    hr = pSysDevEnum->CreateClassEnumerator(*clsid, &pMonEnum, 0);
    pSysDevEnum->Release();
    if FAILED(hr)
    {
        return hr;
    }

    // If there are no filters of a requested category, don't do anything.
    if(NULL == pMonEnum)
    {
        // could added a string to denote an empty category
        return S_FALSE;
    }


    FilterInfo** ppFilterInfo;
    FilterInfo* pFilterInfoNew;

    ppFilterInfo = &(pShowInfo->m_pFilters);
    while (NULL != *ppFilterInfo)
        ppFilterInfo = &((*ppFilterInfo)->m_pFilterInfoNext);


    // Enumerate all items associated with the moniker
    while(pMonEnum->Next(1, &pMon, &cFetched) == S_OK)
    {
        // get a new record for FilterInfo
        pFilterInfoNew = new FilterInfo;
        if (pFilterInfoNew == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        ZeroMemory(pFilterInfoNew, sizeof(FilterInfo));
        *ppFilterInfo = pFilterInfoNew;
        ppFilterInfo = &(pFilterInfoNew->m_pFilterInfoNext);
        pShowInfo->m_dwFilters++;

        // set category clsid and friendly name
        pFilterInfoNew->m_ClsidCat = *clsid;
#ifdef _UNICODE
        wcscpy(pFilterInfoNew->m_szCatName, wszCatName);
#else
        WideCharToMultiByte(CP_ACP,
                            0,
                            wszCatName,
                            -1,
                            pFilterInfoNew->m_szCatName,
                            sizeof(pFilterInfoNew->m_szCatName),
                            0,
                            0);
#endif

        IPropertyBag *pPropBag;

        // associate moniker with a file
        hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            var.vt = VT_BSTR;

            // get filter's friendly name
            hr = pPropBag->Read(L"FriendlyName", &var, 0);
            if (SUCCEEDED(hr))
            {
#ifdef _UNICODE
                wcscpy(pFilterInfoNew->m_szName, var.bstrVal);
#else
                WideCharToMultiByte(CP_ACP,
                                    0,
                                    var.bstrVal,
                                    -1,
                                    pFilterInfoNew->m_szName,
                                    sizeof(pFilterInfoNew->m_szName),
                                    0,
                                    0);
#endif
                SysFreeString(var.bstrVal);
            }

            // get filter's CLSID
            hr = pPropBag->Read(L"CLSID", &var, 0);
            if(SUCCEEDED(hr))
            {
                if(CLSIDFromString(var.bstrVal, &(pFilterInfoNew->m_ClsidFilter)) == S_OK)
                {
                    // use the guid if we can't get the friendly name
                    if (TEXT('\0') == pFilterInfoNew->m_szName[0])
                    {
#ifdef _UNICODE
                        wcscpy(pFilterInfoNew->m_szName, var.bstrVal);
#else
                        WideCharToMultiByte(CP_ACP,
                                            0,
                                            var.bstrVal,
                                            -1,
                                            pFilterInfoNew->m_szName,
                                            sizeof(pFilterInfoNew->m_szName),
                                            0,
                                            0);
#endif
                    }
                }
                SysFreeString(var.bstrVal);
            }
            pPropBag->Release();
        }


        // start grabbing filter info
        IAMFilterData *pFD;
        hr = CoCreateInstance(CLSID_FilterMapper,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IAMFilterData,
                              (void **)&pFD);
        if(SUCCEEDED(hr))
        {
            hr = GetFilterInfo(pMon, pFD, pFilterInfoNew);
            pFD->Release();
        }
        else
        {
            // Must not be on DX8 or above...
        }

        pMon->Release();
    }

    pMonEnum->Release();
    return hr;
}


HRESULT GetFilterInfo(IMoniker* pMon, IAMFilterData* pFD, FilterInfo* pFilterInfo)
{
    HRESULT hr;

    IPropertyBag *pPropBag;
    hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
    if(SUCCEEDED(hr))
    {
        VARIANT varFilData;
        varFilData.vt = VT_UI1 | VT_ARRAY;
        varFilData.parray = 0; // docs say zero this

        BYTE *pbFilterData = NULL; 
        DWORD dwcbFilterDAta = 0; // 0 if not read
        hr = pPropBag->Read(L"FilterData", &varFilData, 0);
        if(SUCCEEDED(hr))
        {
            if( varFilData.vt == (VT_UI1 | VT_ARRAY) )
            {
                dwcbFilterDAta = varFilData.parray->rgsabound[0].cElements;
                if( SUCCEEDED( SafeArrayAccessData(varFilData.parray, (void **)&pbFilterData) ) )
                {
                    BYTE *pb = NULL;
                    hr = pFD->ParseFilterData(pbFilterData, dwcbFilterDAta, &pb);
                    if(SUCCEEDED(hr))
                    {
                        REGFILTER2** ppRegFilter = (REGFILTER2**)pb;
                        REGFILTER2* pFil = NULL;
                        pFil = *ppRegFilter;
    
                        if( pFil != NULL && pFil->dwVersion == 2 )
                        {
                            pFilterInfo->m_dwMerit = pFil->dwMerit;                             // set merit
                            wsprintf(pFilterInfo->m_szVersion, TEXT("v%d"), pFil->dwVersion);   // set version
    
                            //
                            // Display the filter's filename
                            //            
                            // Read filter's CLSID from property bag.  This CLSID string will be
                            // used to find the filter's filename in the registry.
                            VARIANT varFilterClsid;
                            varFilterClsid.vt = VT_BSTR;
    
                            hr = pPropBag->Read(L"CLSID", &varFilterClsid, 0);
                            if(SUCCEEDED(hr))
                            {
                                TCHAR szKey[512];
    
                                // Convert BSTR to string
                                WCHAR *wszFilterClsid;
                                TCHAR szFilterClsid[1024];
                                wszFilterClsid = varFilterClsid.bstrVal;
    
            #ifdef _UNICODE
                                wcscpy(szFilterClsid, wszFilterClsid);
            #else
                                WideCharToMultiByte(CP_ACP,
                                                    0,
                                                    wszFilterClsid,
                                                    -1,
                                                    szFilterClsid,
                                                    sizeof(szFilterClsid),
                                                    0,
                                                    0);
            #endif
    
                                // Create key name for reading filename registry
                                wsprintf(szKey, TEXT("Software\\Classes\\CLSID\\%s\\InprocServer32\0"),
                                         szFilterClsid);
    
                                // Variables needed for registry query
                                HKEY hkeyFilter=0;
                                DWORD dwSize=MAX_PATH;
                                BYTE szFilename[MAX_PATH];
                                int rc=0;
    
                                // Open the CLSID key that contains information about the filter
                                rc = RegOpenKey(HKEY_LOCAL_MACHINE, szKey, &hkeyFilter);
                                if (rc == ERROR_SUCCESS)
                                {
                                    rc = RegQueryValueEx(hkeyFilter, NULL,  // Read (Default) value
                                                         NULL, NULL, szFilename, &dwSize);
    
                                    if (rc == ERROR_SUCCESS)
                                    {
                                        wsprintf(pFilterInfo->m_szFileName, TEXT("%s"), szFilename);    // set file name & version
                                        GetFileVersion(pFilterInfo->m_szFileName, pFilterInfo->m_szFileVersion, NULL, NULL, NULL, NULL);
                                    }
    
                                    rc = RegCloseKey(hkeyFilter);
                                }

                                SysFreeString(varFilterClsid.bstrVal);
                            }
           
                            int iPinsInput = 0;
                            int iPinsOutput = 0;
    
                            for(UINT iPin = 0; iPin < pFil->cPins; iPin++)
                            {
                                if(pFil->rgPins2[iPin].dwFlags & REG_PINFLAG_B_OUTPUT)
                                {
                                    iPinsOutput++;
                                }
                                else
                                {
                                    iPinsInput++;
                                }
                            }
    
                            pFilterInfo->m_dwInputs = iPinsInput;                           // set input
                            pFilterInfo->m_dwOutputs = iPinsOutput;                         // set output
    
                        }
    
                        CoTaskMemFree( (BYTE*) pFil );
                    }
            
                    SafeArrayUnaccessData(varFilData.parray);
                }
            }

            VariantClear(&varFilData);
        }

        pPropBag->Release();
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\save.h ===
/****************************************************************************
 *
 *    File: save.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Save gathered information to a file in text or CSV format
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef SAVE_H
#define SAVE_H

struct BugInfo
{
	TCHAR m_szName[100];
	TCHAR m_szEmail[100];
	TCHAR m_szCompany[100];
	TCHAR m_szPhone[100];
	TCHAR m_szCityState[100];
	TCHAR m_szCountry[100];
	TCHAR m_szBugDescription[300];
	TCHAR m_szReproSteps[300];
	TCHAR m_szSwHw[300];
};

HRESULT SaveAllInfo(TCHAR* pszFile, SysInfo* pSysInfo, 
	FileInfo* pFileInfoWinComponentsFirst, FileInfo* pFileInfoComponentsFirst, 
	DisplayInfo* pDisplayInfoFirst, SoundInfo* pSoundInfoFirst,
	MusicInfo* pMusicInfo, InputInfo* pInputInfo, 
	NetInfo* pNetInfo, ShowInfo* pShowInfo, BugInfo* pBugInfo = NULL);

HRESULT SaveAllInfoCsv(TCHAR* pszFile, SysInfo* pSysInfo, 
	FileInfo* pFileInfoComponentsFirst, 
	DisplayInfo* pDisplayInfoFirst, SoundInfo* pSoundInfoFirst,
	InputInfo* pInputInfo);

#endif // SAVEINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DxDiag.rc
//
#define IDS_FIRSTDDTESTERROR            2
#define IDS_STRING3                     3
#define IDS_STRING4                     4
#define IDS_STRING5                     5
#define IDS_STRING6                     6
#define IDS_STRING7                     7
#define IDS_STRING8                     8
#define IDS_STRING9                     9
#define IDS_STRING10                    10
#define IDS_STRING11                    11
#define IDS_STRING12                    12
#define IDS_STRING13                    13
#define IDS_STRING14                    14
#define IDS_STRING15                    15
#define IDS_STRING16                    16
#define IDS_STRING17                    17
#define IDS_STRING18                    18
#define IDS_STRING19                    19
#define IDS_STRING20                    20
#define IDS_STRING21                    21
#define IDS_STRING22                    22
#define IDS_FIRSTD3DTESTERROR           30
#define IDS_STRING31                    31
#define IDS_STRING32                    32
#define IDS_STRING33                    33
#define IDS_STRING34                    34
#define IDS_STRING35                    35
#define IDS_STRING36                    36
#define IDS_STRING37                    37
#define IDS_STRING38                    38
#define IDS_STRING39                    39
#define IDS_STRING40                    40
#define IDS_STRING41                    41
#define IDS_STRING42                    42
#define IDS_STRING43                    43
#define IDS_STRING44                    44
#define IDS_STRING45                    45
#define IDS_STRING46                    46
#define IDS_STRING47                    47
#define IDS_STRING48                    48
#define IDS_STRING49                    49
#define IDS_STRING50                    50
#define IDS_STRING51                    51
#define IDS_STRING52                    52
#define IDS_STRING53                    53
#define IDS_STRING54                    54
#define IDS_STRING55                    55
#define IDS_STRING56                    56
#define IDS_STRING57                    57
#define IDS_STRING58                    58
#define IDS_STRING59                    59
#define IDS_STRING60                    60
#define IDS_STRING61                    61
#define IDS_STRING62                    62
#define IDS_STRING63                    63
#define IDS_STRING64                    64
#define IDS_STRING65                    65
#define IDS_STRING66                    66
#define IDS_STRING67                    67
#define IDS_STRING68                    68
#define IDS_STRING69                    69
#define IDS_STRING70                    70
#define IDS_STRING71                    71
#define IDS_STRING72                    72
#define IDS_STRING73                    73
#define IDS_STRING74                    74
#define IDS_STRING75                    75
#define IDS_STRING76                    76
#define IDS_FIRSTDSOUNDTESTERROR        80
#define IDS_STRING81                    81
#define IDS_STRING82                    82
#define IDS_STRING83                    83
#define IDS_STRING84                    84
#define IDS_STRING85                    85
#define IDS_STRING86                    86
#define IDS_STRING87                    87
#define IDS_STRING88                    88
#define IDS_STRING89                    89
#define IDS_STRING90                    90
#define IDS_STRING91                    91
#define IDS_STRING92                    92
#define IDS_STRING93                    93
#define IDS_STRING94                    94
#define IDS_STRING95                    95
#define IDS_STRING96                    96
#define IDS_STRING97                    97
#define IDS_STRING98                    98
#define IDS_STRING99                    99
#define IDS_OLDWINDOWSVERSION           100
#define IDD_MAINDIALOG                  101
#define IDS_NOBASICDISPLAYINFO          101
#define IDD_HELPPAGE                    102
#define IDS_NOBASICSOUNDINFO            102
#define IDD_DXFILESPAGE                 103
#define IDS_PROBLEMSAVING               103
#define IDI_APP                         104
#define IDS_NORICHED32                  104
#define IDI_CAUTION                     105
#define IDS_NOIMAGELIST                 105
#define IDD_DISPLAYPAGE                 106
#define IDS_NOICON                      106
#define IDD_STILLSTUCKPAGE              107
#define IDS_NOTROUBLESHOOTER            107
#define IDD_SOUNDPAGE                   108
#define IDS_NOMSINFO                    108
#define IDD_INPUTPAGE                   109
#define IDS_COMPONENTFILESPROBLEM       109
#define IDD_BUGINFO                     110
#define IDS_DRIVERFILESPROBLEM          110
#define IDS_NOEXTRADISPLAYINFO          111
#define IDS_NOEXTRASOUNDINFO            112
#define IDR_WAVTST                      113
#define IDS_NOINPUTINFO                 113
#define IDS_NOINPUTDRIVERINFO           114
#define IDS_HELPDIRLEAF                 115
#define IDS_HELPEXE                     116
#define IDD_MUSICPAGE                   117
#define IDS_HELPTAB                     118
#define IDR_TSTSGMT                     118
#define IDS_DXFILESTAB                  119
#define IDR_TSTSTYL                     119
#define IDS_ONEDISPLAYTAB               121
#define IDD_TESTNETSETUP                121
#define IDS_MULTIDISPLAYTAB             122
#define IDD_TESTNETSESSIONS             122
#define IDS_ONESOUNDTAB                 123
#define IDD_TESTNETCHAT                 123
#define IDS_MULTISOUNDTAB               124
#define IDD_GHOST                       124
#define IDS_INPUTTAB                    125
#define IDS_STILLSTUCKTAB               126
#define IDS_COPYRIGHTFMT                127
#define IDS_ERRORFMT1                   128
#define IDD_SPLASH                      128
#define IDS_ERRORFMT2                   129
#define IDS_ERRORTITLE                  130
#define IDS_LISTCONTINUER               131
#define IDS_LISTETC                     132
#define IDS_OBSOLETEFMT1                133
#define IDS_OBSOLETEFMT2                134
#define IDS_OLDFMT1                     135
#define IDS_OLDFMT2                     136
#define IDS_BETAFMT1                    137
#define IDS_BETAFMT2                    138
#define IDS_DEBUGFMT1                   139
#define IDS_DEBUGFMT2                   140
#define IDS_NOPROBLEM                   141
#define IDS_BETADRIVERFMT1              142
#define IDS_BETADRIVERFMT2              143
#define IDS_DEBUGDRIVERFMT1             144
#define IDS_DEBUGDRIVERFMT2             145
#define IDS_ACCELENABLED                146
#define IDS_ACCELDISABLED               147
#define IDS_ACCELUNAVAIL                148
#define IDS_ENABLE                      149
#define IDS_DISABLE                     150
#define IDS_NODRIVERPROBLEM             151
#define IDS_DDRESULTS                   152
#define IDS_DDINSTRUCTIONS              153
#define IDS_DSRESULTS                   154
#define IDS_DSINSTRUCTIONS              155
#define IDS_NOINPUT                     156
#define IDS_DEVICENAME                  157
#define IDS_USAGE                       158
#define IDS_DRIVERNAME                  159
#define IDS_VERSION                     160
#define IDS_ATTRIBUTES                  161
#define IDS_SIGNED                      162
#define IDS_LANGUAGE                    163
#define IDS_DATE                        164
#define IDS_SIZE                        165
#define IDS_YES                         166
#define IDS_NO                          167
#define IDS_REGISTRYKEY                 168
#define IDS_ACTIVE                      169
#define IDS_DEVICEID                    170
#define IDS_MATCHINGDEVID               171
#define IDS_DRIVER16                    172
#define IDS_DRIVER32                    173
#define IDS_NAME                        174
#define IDS_DISABLEDDWARNING            175
#define IDS_ENABLEDDWARNING             176
#define IDS_APPFULLNAME                 177
#define IDS_DISABLED3DWARNING           178
#define IDS_ENABLED3DWARNING            179
#define IDS_SENDBUGINSTRUCTIONS         180
#define IDS_EDITOR                      181
#define IDS_DXFBUGS                     182
#define IDS_EMAILERRORFMT               183
#define IDS_D3DRESULTS                  184
#define IDS_D3DINSTRUCTIONS             185
#define IDS_FILTER                      187
#define IDS_DEFAULTFILENAME             188
#define IDS_DEFAULTEXT                  189
#define IDS_UNSIGNEDDRIVERFMT1          190
#define IDS_UNSIGNEDDRIVERFMT2          191
#define IDS_NA                          192
#define IDS_STARTDDTEST                 193
#define IDS_SKIPWINDOWED                194
#define IDS_DDTEST1                     195
#define IDS_CONFIRMDDTEST1              196
#define IDS_DDTEST2                     197
#define IDS_CONFIRMDDTEST2              198
#define IDS_DDTEST3                     199
#define IDS_CONFIRMDDTEST3              200
#define IDS_ENDDDTESTS                  201
#define IDS_TESTSCANCELLED              202
#define IDS_TESTSSUCCESSFUL             203
#define IDS_UNKNOWNERROR                204
#define IDS_FAILUREFMT                  205
#define IDS_STARTD3DTEST                206
#define IDS_D3DTEST1                    207
#define IDS_CONFIRMD3DTEST              208
#define IDS_YOUCANCELLED                209
#define IDS_D3DTEST2                    210
#define IDS_MODIFYAPPFMT1               211
#define IDS_MODIFYAPPFMT2               212
#define IDS_COULDNTMODIFYAPPSETTINGS    213
#define IDS_BADREFRESHVALUE             214
#define IDS_MISSINGFMT1                 215
#define IDS_MISSINGFMT2                 216
#define IDS_HELPFILE                    217
#define IDS_NOHELP                      218
#define IDS_SETDISPLAYMODEFAILED        220
#define IDS_NOBASICMUSICINFO            221
#define IDS_MUSICTAB                    222
#define IDS_NOEXTRAMUSICINFO            223
#define IDS_DESCRIPTION                 224
#define IDS_TYPE                        225
#define IDS_DLS                         226
#define IDS_DEFAULTPORT                 227
#define IDS_NOPORTS                     228
#define IDS_NOGMDLS                     229
#define IDS_GMDLSFILEMISSING            230
#define IDS_INOUT                       231
#define IDS_STARTDMUSICTEST             232
#define IDS_FIRSTDMUSICTESTERROR        233
#define IDS_STRING234                   234
#define IDS_STRING235                   235
#define IDS_STRING236                   236
#define IDS_STRING237                   237
#define IDS_STRING238                   238
#define IDS_STRING239                   239
#define IDS_STRING240                   240
#define IDS_STRING241                   241
#define IDS_STRING242                   242
#define IDS_STRING243                   243
#define IDS_STRING244                   244
#define IDS_STRING245                   245
#define IDS_MUSICPLAYING                246
#define IDS_DMUSICINSTRUCTIONS          247
#define IDS_DMUSICRESULTS               248
#define IDS_OUTPUT                      249
#define IDS_INPUT                       250
#define IDS_SOFTWARE                    251
#define IDS_HARDWARE                    252
#define IDS_FILEMISSING                 253
#define IDS_GMFILEFMT                   254
#define IDS_SKIP                        255
#define IDS_INWINDOWSFMT1               256
#define IDS_INWINDOWSFMT2               257
#define IDS_STARTDSOUNDTEST             258
#define IDS_NOHARDWAREBUFFERING         259
#define IDS_THATSOUNDWAS                260
#define IDS_3D                          261
#define IDS_MONO                        262
#define IDS_STEREO                      263
#define IDS_MULTICHANNEL                264
#define IDS_EMULATED                    265
#define IDS_VXD                         266
#define IDS_WDM                         267
#define IDS_INVALIDARG                  268
#define IDS_FAIL                        269
#define IDS_UNEXPECTED                  270
#define IDS_NOTIMPL                     271
#define IDS_OUTOFMEMORY                 272
#define IDS_NOINTERFACE                 273
#define IDS_INVALIDMODE                 274
#define IDS_INVALIDPIXELFORMAT          275
#define IDS_CANTCREATEDC                276
#define IDS_NOTFOUND                    277
#define IDS_NODIRECTDRAWSUPPORT         278
#define IDS_NO3D                        279
#define IDS_INVALID_DEVICE              280
#define IDS_INITFAILED                  281
#define IDS_MATERIAL_CREATE_FAILED      282
#define IDS_LIGHT_SET_FAILED            283
#define IDS_CONTROLUNAVAIL              284
#define IDS_BADFORMAT                   285
#define IDS_BUFFERLOST                  286
#define IDS_NODRIVER                    287
#define IDS_DRIVER_FAILED               288
#define IDS_PORTS_OPEN                  289
#define IDS_DEVICE_IN_USE               290
#define IDS_INSUFFICIENTBUFFER          291
#define IDS_CHUNKNOTFOUND               292
#define IDS_BADINSTRUMENT               293
#define IDS_CANNOTREAD                  294
#define IDS_LOADER_BADPATH              295
#define IDS_LOADER_FAILEDOPEN           296
#define IDS_LOADER_FORMATNOTSUPPORTED   297
#define IDS_OBJECTNOTFOUND              298
#define IDS_ALLOCATED                   299
#define IDS_NOTUSED2                    300
#define IDS_NOTUSED3                    301
#define IDS_NOTUSED4                    302
#define IDS_NOTUSED5                    303
#define IDS_ENABLEDD                    304
#define IDS_DISABLEDD                   305
#define IDS_ENABLED3D                   306
#define IDS_DISABLED3D                  307
#define IDS_NO16BITWARNING              308
#define IDS_NOMACHINENAME               309
#define IDS_NECPC98                     310
#define IDS_WINVERFMT                   311
#define IDS_DEBUG                       312
#define IDS_LANGUAGEFMT                 313
#define IDS_PAGEFILEFMT                 314
#define IDS_FINAL                       315
#define IDS_BETA                        316
#define IDS_RETAIL                      317
#define IDS_JOYSTICKPRESENT             318
#define IDS_DEFAULT                     319
#define IDS_EXTERNAL                    320
#define IDS_EXTERNALMUSICPLAYING        321
#define IDS_UNICODE                     322
#define IDS_DEFAULTREFRESH              323
#define IDS_OPTIMALREFRESH              324
#define IDS_NUMPROCFMT                  325
#define IDS_NODXSETUP                   326
#define IDS_UNICODEREQUIRESNT           327
#define IDS_OLDFMT1_NT                  328
#define IDS_OLDFMT2_NT                  329
#define IDS_BETAFMT1_NT                 330
#define IDS_BETAFMT2_NT                 331
#define IDS_DEBUGFMT1_NT                332
#define IDS_DEBUGFMT2_NT                333
#define IDS_MISSINGFMT1_NT              334
#define IDS_MISSINGFMT2_NT              335
#define IDS_KERNELMODE                  336
#define IDS_NETWORKTAB                  337
#define IDS_SPREGISTRYERRORFMT          338
#define IDS_SPFILEMISSINGFMT            339
#define IDS_APPREGISTRYERRORFMT         340
#define IDS_APPFILEMISSINGFMT           341
#define IDS_DPLAYRESULTS                342
#define IDS_DPLAYINSTRUCTIONS           343
#define IDS_REGISTRY                    344
#define IDS_FILE                        345
#define IDS_GUID                        346
#define IDS_OK                          347
#define IDS_ERROR                       348
#define IDS_NONETINFO                   349
#define IDS_DEFAULTUSERNAME             350
#define IDS_DEFAULTSESSIONNAME          351
#define IDS_JOINMSGFMT                  352
#define IDS_LEAVEMSGFMT                 353
#define IDS_FIRSTDPLAYTESTERROR         354
#define IDS_STRING355                   355
#define IDS_STRING356                   356
#define IDS_STRING357                   357
#define IDS_STRING358                   358
#define IDS_STRING359                   359
#define IDS_STRING360                   360
#define IDS_STRING361                   361
#define IDS_STRING362                   362
#define IDS_STRING363                   363
#define IDS_NOSNDACCELERATION           366
#define IDS_BASICSNDACCELERATION        367
#define IDS_STANDARDSNDACCELERATION     368
#define IDS_FULLSNDACCELERATION         369
#define IDS_DPERR_ACCESSDENIED          370
#define IDS_DPERR_CANTADDPLAYER         371
#define IDS_DPERR_CANTCREATESESSION     372
#define IDS_DPERR_EXCEPTION             373
#define IDS_DPERR_INVALIDOBJECT         374
#define IDS_DPERR_NOCONNECTION          375
#define IDS_DPERR_TIMEOUT               376
#define IDS_DPERR_BUSY                  377
#define IDS_DPERR_CONNECTIONLOST        378
#define IDS_DPERR_NOSERVICEPROVIDER     379
#define IDS_DPERR_UNAVAILABLE           380
#define IDS_REGDB_E_CLASSNOTREG         381
#define IDS_TESTNEEDSDX8                383
#define IDS_INITCONNECTIONFAILED        384
#define IDS_DXMBUGS                     385
#define IDS_JOY_HW_NONE                 387
#define IDS_JOY_HW_CUSTOM               388
#define IDS_JOY_HW_2A_2B_GENERIC        389
#define IDS_JOY_HW_2A_4B_GENERIC        390
#define IDS_JOY_HW_2B_GAMEPAD           391
#define IDS_JOY_HW_2B_FLIGHTYOKE        392
#define IDS_JOY_HW_2B_FLIGHTYOKETHROTTLE 393
#define IDS_JOY_HW_3A_2B_GENERIC        394
#define IDS_JOY_HW_3A_4B_GENERIC        395
#define IDS_JOY_HW_4B_GAMEPAD           396
#define IDS_JOY_HW_4B_FLIGHTYOKE        397
#define IDS_JOY_HW_4B_FLIGHTYOKETHROTTLE 398
#define IDS_JOY_UNKNOWN                 399
#define IDS_ATTRIBCOMBINE               400
#define IDS_NT4SAVEONLY                 406
#define IDS_SAVEDONE                    407
#define IDS_HELPNEEDSIE5                412
#define IDS_ENABLEAGP                   413
#define IDS_DISABLEAGP                  414
#define IDS_ENABLEAGPWARNING            415
#define IDS_DISABLEAGPWARNING           416
#define IDS_DXDIAGISOLDFMT              417
#define IDS_NOSOUNDDRIVER               418
#define IDS_NEEDUSERNAME                419
#define IDS_NEEDSESSIONNAME             420
#define IDS_DATEFMT                     421
#define IDS_SESSIONLISTERROR            422
#define IDS_ENABLEDM                    423
#define IDS_DISABLEDM                   424
#define IDS_DISABLEDMWARNING            425
#define IDS_ENABLEDMWARNING             426
#define IDS_REGISTRYPROBLEM             427
#define IDS_PROVIDER                    428
#define IDS_STATUS                      429
#define IDS_PORTNAME                    430
#define IDS_PORTPROVIDER                431
#define IDS_PORTID                      432
#define IDS_PORTSTATUS                  433
#define IDS_INPUTDEVPROBLEMFMT          434
#define IDS_INPUTPORTPROBLEMFMT         435
#define IDS_REPLACEGHOST                436
#define IDS_DATACENTERSERVER            437
#define IDS_ADVANCEDSERVER              438
#define IDS_SERVER                      439
#define IDS_PROFESSIONAL                440
#define IDS_REINSTALL_DX                445
#define IDS_LOOKINGFORSESSIONS          446
#define IDS_PERSONAL                    447
#define IDS_CONNECTING			        448
#define IDS_CONNECTED			        449
#define IDS_OUT_OF_VIDEO_MEMORY		    450
#define IDS_DD                  	    451
#define IDS_DS                  	    452
#define IDS_DM                  	    453
#define IDS_DI                  	    454
#define IDS_DP                  	    455
#define IDS_SI                  	    456
#define IDS_D3DERR_NOTAVAILABLE         457
#define IDS_WINSOCK_WARN                458
#define IDS_NETMEETINGWARN              459
#define IDS_FIRSTDDTESTERROR_ENGLISH    500
#define IDS_STRING501                   501
#define IDS_STRING502                   502
#define IDS_STRING503                   503
#define IDS_STRING504                   504
#define IDS_STRING505                   505
#define IDS_STRING506                   506
#define IDS_STRING507                   507
#define IDS_STRING508                   508
#define IDS_STRING509                   509
#define IDS_STRING510                   510
#define IDS_STRING511                   511
#define IDS_STRING512                   512
#define IDS_STRING513                   513
#define IDS_STRING514                   514
#define IDS_STRING515                   515
#define IDS_STRING516                   516
#define IDS_STRING517                   517
#define IDS_STRING518                   518
#define IDS_STRING519                   519
#define IDS_STRING520                   520
#define IDS_FIRSTD3DTESTERROR_ENGLISH   530
#define IDS_STRING531                   531
#define IDS_STRING532                   532
#define IDS_STRING533                   533
#define IDS_STRING534                   534
#define IDS_STRING535                   535
#define IDS_STRING536                   536
#define IDS_STRING537                   537
#define IDS_STRING538                   538
#define IDS_STRING539                   539
#define IDS_STRING540                   540
#define IDS_STRING541                   541
#define IDS_STRING542                   542
#define IDS_STRING543                   543
#define IDS_STRING544                   544
#define IDS_STRING545                   545
#define IDS_STRING546                   546
#define IDS_STRING547                   547
#define IDS_STRING548                   548
#define IDS_STRING549                   549
#define IDS_STRING550                   550
#define IDS_STRING551                   551
#define IDS_STRING552                   552
#define IDS_STRING553                   553
#define IDS_STRING554                   554
#define IDS_STRING555                   555
#define IDS_STRING556                   556
#define IDS_STRING557                   557
#define IDS_STRING558                   558
#define IDS_STRING559                   559
#define IDS_STRING560                   560
#define IDS_STRING561                   561
#define IDS_STRING562                   562
#define IDS_STRING563                   563
#define IDS_STRING564                   564
#define IDS_STRING565                   565
#define IDS_STRING566                   566
#define IDS_STRING567                   567
#define IDS_STRING568                   568
#define IDS_STRING569                   569
#define IDS_STRING570                   570
#define IDS_STRING571                   571
#define IDS_STRING572                   572
#define IDS_STRING573                   573
#define IDS_STRING574                   574
#define IDS_STRING575                   575
#define IDS_STRING576                   576
#define IDS_FIRSTDSOUNDTESTERROR_ENGLISH 580
#define IDS_STRING581                   581
#define IDS_STRING582                   582
#define IDS_STRING583                   583
#define IDS_STRING584                   584
#define IDS_STRING585                   585
#define IDS_STRING586                   586
#define IDS_STRING587                   587
#define IDS_STRING588                   588
#define IDS_STRING589                   589
#define IDS_STRING590                   590
#define IDS_STRING591                   591
#define IDS_STRING592                   592
#define IDS_STRING593                   593
#define IDS_STRING594                   594
#define IDS_STRING595                   595
#define IDS_STRING596                   596
#define IDS_STRING597                   597
#define IDS_STRING598                   598
#define IDS_STRING599                   599
#define IDS_FIRSTDMUSICTESTERROR_ENGLISH 610
#define IDS_STRING611                   611
#define IDS_STRING612                   612
#define IDS_STRING613                   613
#define IDS_STRING614                   614
#define IDS_STRING615                   615
#define IDS_STRING616                   616
#define IDS_STRING617                   617
#define IDS_STRING618                   618
#define IDS_STRING619                   619
#define IDS_STRING620                   620
#define IDS_STRING621                   621
#define IDS_STRING622                   622
#define IDS_UNKNOWNERROR_ENGLISH        630
#define IDS_FAILUREFMT_ENGLISH          631
#define IDS_INVALIDARG_ENGLISH          640
#define IDS_FAIL_ENGLISH                641
#define IDS_UNEXPECTED_ENGLISH          642
#define IDS_NOTIMPL_ENGLISH             643
#define IDS_OUTOFMEMORY_ENGLISH         644
#define IDS_NOINTERFACE_ENGLISH         645
#define IDS_INVALIDMODE_ENGLISH         646
#define IDS_INVALIDPIXELFORMAT_ENGLISH  647
#define IDS_CANTCREATEDC_ENGLISH        648
#define IDS_NOTFOUND_ENGLISH            649
#define IDS_NODIRECTDRAWSUPPORT_ENGLISH 650
#define IDS_NO3D_ENGLISH                651
#define IDS_INVALID_DEVICE_ENGLISH      652
#define IDS_INITFAILED_ENGLISH          653
#define IDS_MATERIAL_CREATE_FAILED_ENGLISH 654
#define IDS_LIGHT_SET_FAILED_ENGLISH    655
#define IDS_CONTROLUNAVAIL_ENGLISH      656
#define IDS_BADFORMAT_ENGLISH           657
#define IDS_BUFFERLOST_ENGLISH          658
#define IDS_NODRIVER_ENGLISH            659
#define IDS_DRIVER_FAILED_ENGLISH       660
#define IDS_PORTS_OPEN_ENGLISH          661
#define IDS_DEVICE_IN_USE_ENGLISH       662
#define IDS_INSUFFICIENTBUFFER_ENGLISH  663
#define IDS_CHUNKNOTFOUND_ENGLISH       664
#define IDS_BADINSTRUMENT_ENGLISH       665
#define IDS_CANNOTREAD_ENGLISH          666
#define IDS_LOADER_BADPATH_ENGLISH      667
#define IDS_LOADER_FAILEDOPEN_ENGLISH   668
#define IDS_LOADER_FORMATNOTSUPPORTED_ENGLISH 669
#define IDS_OBJECTNOTFOUND_ENGLISH      670
#define IDS_ALLOCATED_ENGLISH           671
#define IDS_NOTUSED2_ENGLISH            672
#define IDS_NOTUSED3_ENGLISH            673
#define IDS_NOTUSED4_ENGLISH            674
#define IDS_NOTUSED5_ENGLISH            675
#define IDS_FIRSTDPLAYTESTERROR_ENGLISH 676
#define IDS_STRING677                   677
#define IDS_STRING678                   678
#define IDS_STRING679                   679
#define IDS_STRING680                   680
#define IDS_STRING681                   681
#define IDS_STRING682                   682
#define IDS_STRING683                   683
#define IDS_STRING684                   684
#define IDS_STRING685                   685
#define IDS_DPERR_ACCESSDENIED_ENGLISH  686
#define IDS_DPERR_CANTADDPLAYER_ENGLISH 687
#define IDS_DPERR_CANTCREATESESSION_ENGLISH 688
#define IDS_DPERR_EXCEPTION_ENGLISH     689
#define IDS_DPERR_INVALIDOBJECT_ENGLISH 690
#define IDS_DPERR_NOCONNECTION_ENGLISH  691
#define IDS_DPERR_TIMEOUT_ENGLISH       692
#define IDS_DPERR_BUSY_ENGLISH          693
#define IDS_DPERR_CONNECTIONLOST_ENGLISH 694
#define IDS_DPERR_NOSERVICEPROVIDER_ENGLISH 695
#define IDS_DPERR_UNAVAILABLE_ENGLISH   697
#define IDS_REGDB_E_CLASSNOTREG_ENGLISH 698
#define IDS_TESTSCANCELLED_ENGLISH      699
#define IDS_TESTSSUCCESSFUL_ENGLISH     700
#define IDS_PAGEFILEFMT_ENGLISH         701
#define IDS_LANGUAGEFMT_ENGLISH         702
#define IDS_DEFAULTREFRESH_ENGLISH      703
#define IDS_OPTIMALREFRESH_ENGLISH      704
#define IDS_FILEMISSING_ENGLISH         705
#define IDS_UNSIGNEDDRIVERFMT1_ENGLISH 706
#define IDS_REGISTRYPROBLEM_ENGLISH     707
#define IDS_NOPROBLEM_ENGLISH           708
#define IDS_DDRESULTS_ENGLISH           709
#define IDS_DDINSTRUCTIONS_ENGLISH      710
#define IDS_D3DRESULTS_ENGLISH          711
#define IDS_D3DINSTRUCTIONS_ENGLISH     712
#define IDS_INWINDOWSFMT1_ENGLISH       715
#define IDS_INWINDOWSFMT2_ENGLISH       716
#define IDS_MISSINGFMT1_ENGLISH         717
#define IDS_MISSINGFMT2_ENGLISH         718
#define IDS_OLDFMT1_ENGLISH             719
#define IDS_OLDFMT2_ENGLISH             720
#define IDS_BETAFMT1_ENGLISH            721
#define IDS_BETAFMT2_ENGLISH            722
#define IDS_DEBUGFMT1_ENGLISH           723
#define IDS_DEBUGFMT2_ENGLISH           724
#define IDS_REINSTALL_DX_ENGLISH        725
#define IDS_DSRESULTS_ENGLISH           726
#define IDS_INPUTDEVPROBLEMFMT_ENGLISH  727
#define IDS_INPUTPORTPROBLEMFMT_ENGLISH 728
#define IDS_DSINSTRUCTIONS_ENGLISH      729
#define IDS_BETADRIVERFMT1_ENGLISH      730
#define IDS_BETADRIVERFMT2_ENGLISH      731
#define IDS_DEBUGDRIVERFMT1_ENGLISH     732
#define IDS_DEBUGDRIVERFMT2_ENGLISH     733
#define IDS_NOINPUT_ENGLISH             734
#define IDS_NOPORTS_ENGLISH             735
#define IDS_NOGMDLS_ENGLISH             736
#define IDS_GMDLSFILEMISSING_ENGLISH    737
#define IDS_SPREGISTRYERRORFMT_ENGLISH  738
#define IDS_SPFILEMISSINGFMT_ENGLISH    739
#define IDS_APPREGISTRYERRORFMT_ENGLISH 740
#define IDS_DPLAYRESULTS_ENGLISH        741
#define IDS_DPLAYINSTRUCTIONS_ENGLISH   742
#define IDS_ACCELUNAVAIL_ENGLISH        743
#define IDS_ACCELENABLED_ENGLISH        744
#define IDS_ACCELDISABLED_ENGLISH       745
#define IDS_DMUSICRESULTS_ENGLISH       746
#define IDS_DMUSICINSTRUCTIONS_ENGLISH  747
#define IDS_OUT_OF_VIDEO_MEMORY_ENGLISH 748
#define IDS_D3DERR_NOTAVAILABLE_ENGLISH 749
#define IDS_WINSOCK_WARN_ENGLISH        750
#define IDS_NETMEETINGWARN_ENGLISH      751
#define IDS_TROUBLESHOOTER_WIN98        800
#define IDS_SOUNDTROUBLESHOOTER_WIN98   801
#define IDS_TROUBLESHOOTER_WIN98SE      802
#define IDS_TROUBLESHOOTER_WINME        803
#define IDS_TROUBLESHOOTER_WIN2K        804
#define IDS_TSSUBINFO_WIN98SE           805
#define IDS_TSSUBINFO_WINME_HCP         806
#define IDS_TSSUBINFO_WIN2K             807
#define IDS_TSSOUNDSUBINFO_WIN98SE      808
#define IDS_TSSOUNDSUBINFO_WINME_HCP    809
#define IDS_TSSOUNDSUBINFO_WIN2K        810
#define IDS_TROUBLESHOOTER_WINME_HCP    811
#define IDS_DXGRAPHICS_COMPONENTFILES   812
#define IDS_DPLAY_COMPONENTFILES        813
#define IDS_DINPUT_COMPONENTFILES       814
#define IDS_DXAUDIO_COMPONENTFILES      815
#define IDS_DXMISC_COMPONENTFILES       816
#define IDS_DXMEDIA_COMPONENTFILES      817
#define IDS_DXSETUP_COMPONENTFILES      818
#define IDS_BDA_COMPONENTFILES          819
#define IDNEXT                          1000
#define IDSAVE                          1001
#define IDC_TAB                         1002
#define IDC_LIST                        1003
#define IDC_DRIVERLIST                  1004
#define IDC_NOTES                       1008
#define IDC_TROUBLESHOOT                1010
#define IDC_TESTDD                      1011
#define IDC_TROUBLESHOOTSOUND           1012
#define IDC_TESTSND                     1013
#define IDC_ADAPTER                     1015
#define IDC_MANUFACTURER                1016
#define IDC_CHIPTYPE                    1017
#define IDC_DACTYPE                     1018
#define IDC_DISPLAYMEMORY               1019
#define IDC_DISPLAYMODE                 1022
#define IDC_DDSTATUS                    1024
#define IDC_D3DSTATUS                   1025
#define IDC_DISABLEDD                   1029
#define IDC_DATE                        1030
#define IDC_COMPUTERNAME                1031
#define IDC_OS                          1032
#define IDC_PROCESSOR                   1033
#define IDC_MEMORY                      1034
#define IDC_PAGEFILE                    1035
#define IDC_LANGUAGE                    1036
#define IDC_DISABLED3D                  1037
#define IDC_DIRECTXVERSION              1037
#define IDC_TESTD3D                     1038
#define IDC_VDD                         1039
#define IDC_MINIVDD                     1040
#define IDC_DRIVERVERSION               1041
#define IDC_DRIVERNAME                  1042
#define IDC_TESTAGP                     1043
#define IDC_DESCRIPTION                 1044
#define IDC_REPORTBUG                   1054
#define IDEXIT                          1055
#define IDC_COPYRIGHT                   1056
#define IDC_TROUBLESHOOTTEXT            1057
#define IDC_MSINFO                      1058
#define IDC_MSINFOTEXT                  1059
#define IDC_DRIVERSIGNED                1060
#define IDC_DEFAULTREFRESH              1080
#define IDC_OVERRIDEREFRESH             1081
#define IDC_OVERRIDEREFRESHVALUE        1082
#define IDD_OVERRIDEDD                  1083
#define IDC_OVERRIDE                    1084
#define IDD_NETWORKPAGE                 1084
#define IDC_APPHELP                     1085
#define IDC_REPORTBUGTEXT               1086
#define IDC_GMPATH                      1087
#define IDC_GHOSTTEXT                   1087
#define IDC_TESTMUSIC                   1088
#define IDC_PORTLISTCOMBO               1091
#define IDC_MONITOR                     1092
#define IDC_DEVICEID                    1093
#define IDC_DEVICETYPE                  1094
#define IDC_MANUFACTURERID              1095
#define IDC_PRODUCTID                   1096
#define IDC_OTHERFILES                  1097
#define IDC_PROVIDER                    1098
#define IDC_RESTOREDRIVERS              1099
#define IDC_RESTOREDRIVERSTEXT          1100
#define IDC_DPSPLIST                    1104
#define IDC_DPALIST                     1105
#define IDC_TESTPLAY                    1106
#define IDC_PLAYERNAME                  1107
#define IDC_SPLIST                      1108
#define IDC_CREATESESSION               1109
#define IDC_JOINSESSION                 1110
#define IDC_SESSIONLIST                 1111
#define IDC_CHATOUTPUT                  1112
#define IDC_CHATINPUT                   1113
#define IDC_SEND                        1114
#define IDC_SESSIONNAME                 1115
#define IDC_SNDACCELSLIDER              1116
#define IDC_SNDACCELDESC                1117
#define IDC_SNDACCELLABEL               1118
#define IDC_TROUBLESHOOTSOUNDTEXT       1119
#define IDC_DISABLEAGP                  1120
#define IDC_AGPSTATUS                   1121
#define IDC_DISABLEDM                   1122
#define IDC_DMSTATUS                    1123
#define IDC_GHOST                       1124
#define IDC_BACKUP                      1127
#define IDC_RESTORE                     1128
#define IDC_BACKEDUPLIST                1129
#define IDC_RESTOREDLIST                1130
#define IDC_NEXT_TAB                    1131
#define IDC_PREV_TAB                    1132
#define IDC_BROWSE                      1137
#define IDC_PATH                        1138
#define IDC_PORT                        1139
#define IDC_PORT_TEXT                   1140
#define IDC_LOAD_PROGRESS               1141
#define IDC_LOADING                     1142

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         40003
#define _APS_NEXT_CONTROL_VALUE         1144
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\sndinfo.cpp ===
/****************************************************************************
 *
 *    File: sndinfo.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about sound devices on this machine
 *
 * (C) Copyright 1998-1999 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#define DIRECTSOUND_VERSION  0x0600
#include <tchar.h>
#include <Windows.h>
#include <mmsystem.h>
#include <d3dtypes.h>
#include <dsound.h>
#include <stdio.h>
#include "mmddk.h" // for DRV_QUERYDEVNODE
#include "dsprv.h"
#include "dsprvobj.h"
#include "reginfo.h"
#include "sysinfo.h" // for BIsPlatformNT
#include "dispinfo.h"
#include "sndinfo.h"
#include "fileinfo.h" // for GetFileVersion, FileIsSigned
#include "resource.h"

// This function is defined in sndinfo7.cpp:
HRESULT GetRegKey(LPKSPROPERTYSET pKSPS7, REFGUID guidDeviceID, TCHAR* pszRegKey);

typedef HRESULT (WINAPI* LPDIRECTSOUNDENUMERATE)(LPDSENUMCALLBACK lpDSEnumCallback,
    LPVOID lpContext);
typedef HRESULT (WINAPI* LPDIRECTSOUNDCREATE)(LPGUID lpGUID, LPDIRECTSOUND* ppDS, 
    LPUNKNOWN pUnkOuter);

static BOOL CALLBACK DSEnumCallback(LPGUID pGuid, TCHAR* pszDescription, 
                                    TCHAR* pszModule, LPVOID lpContext);
static VOID GetRegSoundInfo9x(SoundInfo* pSoundInfo);
static VOID GetRegSoundInfoNT(SoundInfo* pSoundInfo);
static HRESULT GetDirectSoundInfo(LPDIRECTSOUNDCREATE pDSCreate, SoundInfo* pSoundInfo);
static HRESULT CheckRegistry(RegError** ppRegErrorFirst);

static LPKSPROPERTYSET s_pKSPS = NULL;
static DWORD s_dwWaveIDDefault = 0;

/****************************************************************************
 *
 *  GetBasicSoundInfo
 *
 ****************************************************************************/
HRESULT GetBasicSoundInfo(SoundInfo** ppSoundInfoFirst)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];
    HINSTANCE hInstDSound = NULL;
    LPDIRECTSOUNDENUMERATE pdse;

    lstrcpy( szPath, TEXT("") );
    
    // Find which waveout device is the default, the one that would
    // be used by DirectSoundCreate(NULL).  If the following code
    // fails, assume it's device 0.
    DWORD dwParam2 = 0;
    waveOutMessage( (HWAVEOUT)IntToPtr(WAVE_MAPPER), DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &s_dwWaveIDDefault, (DWORD_PTR) &dwParam2 );
    if( s_dwWaveIDDefault == -1 )
        s_dwWaveIDDefault = 0;

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\dsound.dll"));
    hInstDSound = LoadLibrary(szPath);
    if (hInstDSound == NULL)
        goto LEnd;
    // Get Private DirectSound object:
    if (FAILED(hr = DirectSoundPrivateCreate(&s_pKSPS)))
    {
        // note: no error.  This will always fail on Win95.
    }

    // Get DirectSoundEnumerate and call it:
    pdse = (LPDIRECTSOUNDENUMERATE)GetProcAddress(hInstDSound, 
#ifdef UNICODE
        "DirectSoundEnumerateW"
#else
        "DirectSoundEnumerateA"
#endif
        );
    if (pdse == NULL)
        goto LEnd;

    if (FAILED(hr = pdse((LPDSENUMCALLBACK)DSEnumCallback, ppSoundInfoFirst)))
        goto LEnd;

LEnd:
    if (s_pKSPS != NULL)
    {
        s_pKSPS->Release();
        s_pKSPS = NULL;
    }
    if (hInstDSound != NULL)
        FreeLibrary(hInstDSound);
    return hr;
}


/****************************************************************************
 *
 *  DSEnumCallback
 *
 ****************************************************************************/
BOOL CALLBACK DSEnumCallback(LPGUID pGuid, TCHAR* pszDescription, 
                             TCHAR* pszModule, LPVOID lpContext)
{
    SoundInfo** ppSoundInfoFirst = (SoundInfo**)lpContext;
    SoundInfo* pSoundInfoNew;
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA pdsdData = NULL;

    if (pGuid == NULL)
        return TRUE; // skip this guy

    // We decided to only report on the default, primary DSound device for
    // now.  Remove the next few lines to show a page per device.
    // Use private interface to get bonus information:
    if (*ppSoundInfoFirst != NULL)
        return FALSE; // We got our device, so stop enumerating
    if (s_pKSPS != NULL)
    {
        if (FAILED(PrvGetDeviceDescription(s_pKSPS, *pGuid, &pdsdData)))
            return TRUE; // error on this device--keep enumerating
        if (pdsdData->WaveDeviceId != s_dwWaveIDDefault)
            return TRUE; // not default device--keep enumerating
    }
    // Note: on Win95, where s_pKSPS is NULL, we can't get the device ID,
    // so we don't know which DSound device is the default one.  So just
    // use the first one that comes up in the enumeration after the one
    // with NULL pGuid.

    pSoundInfoNew = new SoundInfo;
    if (pSoundInfoNew == NULL)
        return FALSE;
    ZeroMemory(pSoundInfoNew, sizeof(SoundInfo));
    if (*ppSoundInfoFirst == NULL)
    {
        *ppSoundInfoFirst = pSoundInfoNew;
    }
    else
    {
        SoundInfo* pSoundInfo;
        for (pSoundInfo = *ppSoundInfoFirst; 
            pSoundInfo->m_pSoundInfoNext != NULL; 
            pSoundInfo = pSoundInfo->m_pSoundInfoNext)
            {
            }
        pSoundInfo->m_pSoundInfoNext = pSoundInfoNew;
    }
    pSoundInfoNew->m_guid = *pGuid;
    lstrcpy(pSoundInfoNew->m_szDescription, pszDescription);
    if (s_pKSPS == NULL)
    {
        // Without the DSound private interface, we can't use it to get
        // waveout device ID or devnode.  Assume device ID is 0, and use
        // waveOutMessage(DRV_QUERYDEVNODE) to get dev node.
        waveOutMessage((HWAVEOUT)0, DRV_QUERYDEVNODE, (DWORD_PTR)&pSoundInfoNew->m_dwDevnode, 0);
        pSoundInfoNew->m_lwAccelerationLevel = -1;
    }
    else
    {
        pSoundInfoNew->m_dwDevnode = pdsdData->Devnode;
        if (pdsdData->Type == 0)
            LoadString(NULL, IDS_EMULATED, pSoundInfoNew->m_szType, 100);
        else if (pdsdData->Type == 1)
            LoadString(NULL, IDS_VXD, pSoundInfoNew->m_szType, 100);
        else if (pdsdData->Type == 2)
            LoadString(NULL, IDS_WDM, pSoundInfoNew->m_szType, 100);
        DIRECTSOUNDBASICACCELERATION_LEVEL accelLevel;
        if (FAILED(PrvGetBasicAcceleration(s_pKSPS, *pGuid, &accelLevel)))
            pSoundInfoNew->m_lwAccelerationLevel = -1;
        else
            pSoundInfoNew->m_lwAccelerationLevel = (LONG)accelLevel;

        // This will only work on DX7 and beyond
        GetRegKey(s_pKSPS, *pGuid, pSoundInfoNew->m_szRegKey);
    }

    WAVEOUTCAPS waveoutcaps;
    LONG devID;
    if (pdsdData == NULL)
        devID = 0;
    else
        devID = pdsdData->WaveDeviceId;
    if (MMSYSERR_NOERROR == waveOutGetDevCaps(devID, &waveoutcaps, sizeof(waveoutcaps)))
    {
        // May want to use mmreg.h to add strings for manufacturer/product names here
        wsprintf(pSoundInfoNew->m_szManufacturerID, TEXT("%d"), waveoutcaps.wMid);
        wsprintf(pSoundInfoNew->m_szProductID, TEXT("%d"), waveoutcaps.wPid);
    }

    // Sometimes, pszModule is the full path.  Sometimes it's just the leaf.
    // Sometimes, it's something inbetween.  Separate the leaf, and look
    // in a few different places.
    TCHAR* pszLeaf;
    pszLeaf = _tcsrchr(pszModule, TEXT('\\'));
    if (pszLeaf == NULL)
    {
        lstrcpy(pSoundInfoNew->m_szDriverName, pszModule);
    }
    else
    {
        lstrcpy(pSoundInfoNew->m_szDriverName, (pszLeaf + 1));
    }
    // Try just module string
    lstrcpy(pSoundInfoNew->m_szDriverPath, pszModule);
    if (pszLeaf == NULL || GetFileAttributes(pSoundInfoNew->m_szDriverPath) == 0xFFFFFFFF)
    {
        // Try windows dir + module string
        GetWindowsDirectory(pSoundInfoNew->m_szDriverPath, MAX_PATH);
        lstrcat(pSoundInfoNew->m_szDriverPath, TEXT("\\"));
        lstrcat(pSoundInfoNew->m_szDriverPath, pszModule);
        if (GetFileAttributes(pSoundInfoNew->m_szDriverPath) == 0xFFFFFFFF)
        {
            // Try system dir + module string
            GetSystemDirectory(pSoundInfoNew->m_szDriverPath, MAX_PATH);
            lstrcat(pSoundInfoNew->m_szDriverPath, TEXT("\\"));
            lstrcat(pSoundInfoNew->m_szDriverPath, pszModule);
            if (GetFileAttributes(pSoundInfoNew->m_szDriverPath) == 0xFFFFFFFF)
            {
                // Try windows dir + \system32\drivers\ + module string
                GetWindowsDirectory(pSoundInfoNew->m_szDriverPath, MAX_PATH);
                lstrcat(pSoundInfoNew->m_szDriverPath, TEXT("\\System32\\Drivers\\"));
                lstrcat(pSoundInfoNew->m_szDriverPath, pszModule);
            }
        }
    }

    PrvReleaseDeviceDescription( pdsdData );

    return TRUE;
}



/****************************************************************************
 *
 *  GetExtraSoundInfo
 *
 ****************************************************************************/
HRESULT GetExtraSoundInfo(SoundInfo* pSoundInfoFirst)
{
    SoundInfo* pSoundInfo;
    BOOL bNT = BIsPlatformNT();

    for (pSoundInfo = pSoundInfoFirst; pSoundInfo != NULL; 
        pSoundInfo = pSoundInfo->m_pSoundInfoNext)
    {
        CheckRegistry(&pSoundInfo->m_pRegErrorFirst);

        if (bNT)
            GetRegSoundInfoNT(pSoundInfo);
        else
            GetRegSoundInfo9x(pSoundInfo);

        // Bug 18245: Try to distinguish between the various IBM MWave cards
        if (_tcsstr(pSoundInfo->m_szDeviceID, TEXT("MWAVEAUDIO_0460")) != NULL)
            lstrcat(pSoundInfo->m_szDescription, TEXT(" (Stingray)"));
        else if (_tcsstr(pSoundInfo->m_szDeviceID, TEXT("MWAVEAUDIO_0465")) != NULL)
            lstrcat(pSoundInfo->m_szDescription, TEXT(" (Marlin)"));
        else 
        {
            TCHAR szBoard[100];
            lstrcpy( szBoard, TEXT("") );            
            GetPrivateProfileString(TEXT("Mwave,Board"), TEXT("board"), TEXT(""),
                szBoard, 100, TEXT("MWave.ini"));
            if (lstrcmp(szBoard, TEXT("MWAT-046")) == 0)
                lstrcat(pSoundInfo->m_szDescription, TEXT(" (Dolphin)"));
            else if (lstrcmp(szBoard, TEXT("MWAT-043")) == 0)
                lstrcat(pSoundInfo->m_szDescription, TEXT(" (Whale)"));
        }

        // Sometimes, like when a sound driver is emulated, the driver
        // will be reported as something like "WaveOut 0".  In this case,
        // just blank out the file-related fields.
        if (_tcsstr(pSoundInfo->m_szDriverName, TEXT(".")) == NULL)
        {
            lstrcpy(pSoundInfo->m_szDriverName, TEXT(""));
            lstrcpy(pSoundInfo->m_szDriverPath, TEXT(""));
        }
        else
        {
            GetFileVersion(pSoundInfo->m_szDriverPath, pSoundInfo->m_szDriverVersion, 
                pSoundInfo->m_szDriverAttributes, pSoundInfo->m_szDriverLanguageLocal, pSoundInfo->m_szDriverLanguage,
                &pSoundInfo->m_bDriverBeta, &pSoundInfo->m_bDriverDebug);

            FileIsSigned(pSoundInfo->m_szDriverPath, &pSoundInfo->m_bDriverSigned, &pSoundInfo->m_bDriverSignedValid);

            GetFileDateAndSize(pSoundInfo->m_szDriverPath, 
                pSoundInfo->m_szDriverDateLocal, pSoundInfo->m_szDriverDate, &pSoundInfo->m_numBytes);
        }
    }

    return S_OK;
}


/****************************************************************************
 *
 *  GetRegSoundInfo9x
 *
 ****************************************************************************/
VOID GetRegSoundInfo9x(SoundInfo* pSoundInfo)
{
    HKEY hkey = NULL;
    DWORD iKey = 0;
    TCHAR szSubKey[200];
    DWORD dwSubKeySize;
    TCHAR szClass[100];
    DWORD dwClassSize;
    HKEY hkeySub = NULL;
    DWORD dwDevnode;
    DWORD cb;
    DWORD dwType;
    HKEY hkeyOther = NULL;

    // We have the DevNode, so find the device in the registry with the 
    // matching DevNode and gather more info there.
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\control\\MediaResources\\wave"),
        0, KEY_READ, &hkey))
    {
        while (TRUE)
        {
            dwSubKeySize = sizeof(szSubKey);
            dwClassSize = sizeof(szClass);
            if (ERROR_SUCCESS != RegEnumKeyEx(hkey, iKey, szSubKey, &dwSubKeySize, NULL, szClass, &dwClassSize, NULL))
                break;
            if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szSubKey, 0, KEY_READ, &hkeySub))
            {
                cb = sizeof(dwDevnode);
                if (ERROR_SUCCESS == RegQueryValueEx(hkeySub, TEXT("DevNode"), NULL, &dwType, (BYTE*)&dwDevnode, &cb))
                {
                    if (dwDevnode == pSoundInfo->m_dwDevnode)
                    {
                        // Found match...gather yummy info
                        cb = sizeof(pSoundInfo->m_szDeviceID);
                        RegQueryValueEx(hkeySub, TEXT("DeviceID"), NULL, &dwType, (BYTE*)pSoundInfo->m_szDeviceID, &cb);

                        // Occasionally the driver name that DirectSoundEnumerate spits out
                        // is garbage (as with my Crystal SoundFusion).  If that's the case,
                        // use the driver name listed here instead.
                        if (lstrlen(pSoundInfo->m_szDriverName) < 4)
                        {
                            cb = sizeof(pSoundInfo->m_szDriverName);
                            RegQueryValueEx(hkeySub, TEXT("Driver"), NULL, &dwType, (BYTE*)pSoundInfo->m_szDriverName, &cb);
                            GetSystemDirectory(pSoundInfo->m_szDriverPath, MAX_PATH);
                            lstrcat(pSoundInfo->m_szDriverPath, TEXT("\\"));
                            lstrcat(pSoundInfo->m_szDriverPath, pSoundInfo->m_szDriverName);
                        }
                        TCHAR szOtherKey[300];
                        cb = sizeof(szOtherKey);
                        RegQueryValueEx(hkeySub, TEXT("SOFTWAREKEY"), NULL, &dwType, (BYTE*)szOtherKey, &cb);
                        if (lstrlen(szOtherKey) > 0)
                        {
                            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOtherKey, 0, KEY_READ, &hkeyOther))
                            {
                                cb = sizeof(pSoundInfo->m_szOtherDrivers);
                                RegQueryValueEx(hkeyOther, TEXT("Driver"), NULL, &dwType, (BYTE*)pSoundInfo->m_szOtherDrivers, &cb);
                                cb = sizeof(pSoundInfo->m_szProvider);
                                RegQueryValueEx(hkeyOther, TEXT("ProviderName"), NULL, &dwType, (BYTE*)pSoundInfo->m_szProvider, &cb);
                                RegCloseKey(hkeyOther);
                            }
                        }
                    }
                }
                RegCloseKey(hkeySub);
            }
            iKey++;
        }
        RegCloseKey(hkey);
    }
}


/****************************************************************************
 *
 *  GetRegSoundInfoNT
 *
 ****************************************************************************/
VOID GetRegSoundInfoNT(SoundInfo* pSoundInfo)
{
    TCHAR szFullKey[200];
    HKEY hkey;
    DWORD cbData;
    DWORD dwType;
    TCHAR szDriverKey[200];
    TCHAR szOtherFullKey[200];

    lstrcpy(szFullKey, TEXT("System\\CurrentControlSet\\Enum\\"));
    lstrcat(szFullKey, pSoundInfo->m_szRegKey);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szFullKey, 0, KEY_READ, &hkey))
    {
        cbData = sizeof(pSoundInfo->m_szDeviceID);
        RegQueryValueEx(hkey, TEXT("HardwareID"), 0, &dwType, (LPBYTE)pSoundInfo->m_szDeviceID, &cbData);

        cbData = sizeof(szDriverKey);
        RegQueryValueEx(hkey, TEXT("Driver"), 0, &dwType, (LPBYTE)szDriverKey, &cbData);
        
        RegCloseKey(hkey);
    }

    lstrcpy(szOtherFullKey, TEXT("System\\CurrentControlSet\\Control\\Class\\"));
    lstrcat(szOtherFullKey, szDriverKey);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOtherFullKey, 0, KEY_READ, &hkey))
    {
        cbData = sizeof(pSoundInfo->m_szProvider);
        RegQueryValueEx(hkey, TEXT("ProviderName"), 0, &dwType, (LPBYTE)pSoundInfo->m_szProvider, &cbData);

        RegCloseKey(hkey);
    }
}


/****************************************************************************
 *
 *  GetDSSoundInfo
 *
 ****************************************************************************/
HRESULT GetDSSoundInfo(SoundInfo* pSoundInfoFirst)
{
    HRESULT hr;
    HRESULT hrRet = S_OK;
    SoundInfo* pSoundInfo;
    TCHAR szPath[MAX_PATH];
    HINSTANCE hInstDSound;
    LPDIRECTSOUNDCREATE pDSCreate;

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\dsound.dll"));
    hInstDSound = LoadLibrary(szPath);
    if (hInstDSound == NULL)
        return E_FAIL;
    pDSCreate = (LPDIRECTSOUNDCREATE)GetProcAddress(hInstDSound, "DirectSoundCreate");
    if (pDSCreate == NULL)
    {
        FreeLibrary(hInstDSound);
        return E_FAIL;
    }
        
    for (pSoundInfo = pSoundInfoFirst; pSoundInfo != NULL; 
        pSoundInfo = pSoundInfo->m_pSoundInfoNext)
    {
        if (FAILED(hr = GetDirectSoundInfo(pDSCreate, pSoundInfo)))
            hrRet = hr; // but keep going
    }
    FreeLibrary(hInstDSound);

    return hrRet;
}


/****************************************************************************
 *
 *  IsDriverWDM
 *
 ****************************************************************************/
BOOL IsDriverWDM( TCHAR* szDriverName )
{
    if( _tcsstr( szDriverName, TEXT(".sys") ) == NULL )
        return FALSE;
    else
        return TRUE;
}


/****************************************************************************
 *
 *  GetDirectSoundInfo
 *
 ****************************************************************************/
HRESULT GetDirectSoundInfo(LPDIRECTSOUNDCREATE pDSCreate, SoundInfo* pSoundInfo)
{
    HRESULT hr;
    LPDIRECTSOUND pds = NULL;
    GUID* pGUID;
    DSCAPS dscaps;

    // Right now, this function only calls DSCreate/GetCaps to determine if
    // the driver is signed.  If we have already determined that it is by 
    // other means, don't bother with this test.
    if (pSoundInfo->m_bDriverSigned)
        return S_OK;

    // Bug 29918: If this is a WDM driver, then don't call GetCaps() since
    // on DX7.1+ GetCaps() will always return DSCAPS_CERTIFIED on WDM drivers
    if( IsDriverWDM( pSoundInfo->m_szDriverName ) )
        return S_OK;

    if (pSoundInfo->m_guid == GUID_NULL)
        pGUID = NULL;
    else
        pGUID = &pSoundInfo->m_guid;

    if (FAILED(hr = pDSCreate(pGUID, &pds, NULL)))
        goto LFail;

    dscaps.dwSize = sizeof(dscaps);
    if (FAILED(hr = pds->GetCaps(&dscaps)))
        goto LFail;

    pSoundInfo->m_bDriverSignedValid = TRUE;
    if (dscaps.dwFlags & DSCAPS_CERTIFIED)
        pSoundInfo->m_bDriverSigned = TRUE;
    
    pds->Release();
    return S_OK;
LFail:
    if (pds != NULL)
        pds->Release();
    return hr;
}


/****************************************************************************
 *
 *  ChangeAccelerationLevel
 *
 ****************************************************************************/
HRESULT ChangeAccelerationLevel(SoundInfo* pSoundInfo, LONG lwLevel)
{
    HRESULT hr = S_OK;
    DIRECTSOUNDBASICACCELERATION_LEVEL level = (DIRECTSOUNDBASICACCELERATION_LEVEL)lwLevel;
    LPKSPROPERTYSET pksps = NULL;
    TCHAR szPath[MAX_PATH];
    HINSTANCE hInstDSound = NULL;

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\dsound.dll"));
    hInstDSound = LoadLibrary(szPath);
    if (hInstDSound == NULL)
    {
        hr = DDERR_NOTFOUND;
        goto LEnd;
    }

    if (FAILED(hr = DirectSoundPrivateCreate(&pksps)))
        goto LEnd;

    if (FAILED(hr = PrvSetBasicAcceleration(pksps, pSoundInfo->m_guid, level)))
        goto LEnd;

LEnd:
    if (pksps != NULL)
        pksps->Release();
    if (hInstDSound != NULL)
        FreeLibrary(hInstDSound);
    pSoundInfo->m_lwAccelerationLevel = lwLevel;
    return hr;
}


/****************************************************************************
 *
 *  CheckRegistry
 *
 ****************************************************************************/
HRESULT CheckRegistry(RegError** ppRegErrorFirst)
{
    HRESULT hr;
    HKEY HKCR = HKEY_CLASSES_ROOT;

    TCHAR szVersion[100];
    HKEY hkey;
    DWORD cbData;
    ULONG ulType;

    DWORD dwMajor = 0;
    DWORD dwMinor = 0;
    DWORD dwRevision = 0;
    DWORD dwBuild = 0;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectX"),
        0, KEY_READ, &hkey))
    {
        cbData = 100;
        RegQueryValueEx(hkey, TEXT("Version"), 0, &ulType, (LPBYTE)szVersion, &cbData);
        RegCloseKey(hkey);
        if (lstrlen(szVersion) > 6 && 
            lstrlen(szVersion) < 20)
        {
            _stscanf(szVersion, TEXT("%d.%d.%d.%d"), &dwMajor, &dwMinor, &dwRevision, &dwBuild);
        }
    }

    // No registry checking on DX versions before DX7
    if (dwMinor < 7)
        return S_OK;

    // From dsound.inf:
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("DirectSound"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("DirectSound\\CLSID"), TEXT(""), TEXT("{47D4D946-62E8-11cf-93BC-444553540000}"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{47D4D946-62E8-11cf-93BC-444553540000}"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{47D4D946-62E8-11cf-93BC-444553540000}\\InprocServer32"), TEXT(""), TEXT("dsound.dll"), CRF_LEAF)))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{47D4D946-62E8-11cf-93BC-444553540000}\\InprocServer32"), TEXT("ThreadingModel"), TEXT("Both"))))
        return hr;

    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("DirectSoundCapture"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("DirectSoundCapture\\CLSID"), TEXT(""), TEXT("{B0210780-89CD-11d0-AF08-00A0C925CD16}"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{B0210780-89CD-11d0-AF08-00A0C925CD16}"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{B0210780-89CD-11d0-AF08-00A0C925CD16}\\InprocServer32"), TEXT(""), TEXT("dsound.dll"), CRF_LEAF)))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{B0210780-89CD-11d0-AF08-00A0C925CD16}\\InprocServer32"), TEXT("ThreadingModel"), TEXT("Both"))))
        return hr;

    return S_OK;
}


/****************************************************************************
 *
 *  DestroySoundInfo
 *
 ****************************************************************************/
VOID DestroySoundInfo(SoundInfo* pSoundInfoFirst)
{
    SoundInfo* pSoundInfo;
    SoundInfo* pSoundInfoNext;

    for (pSoundInfo = pSoundInfoFirst; pSoundInfo != NULL; 
        pSoundInfo = pSoundInfoNext)
    {
        DestroyReg( &pSoundInfo->m_pRegErrorFirst );

        pSoundInfoNext = pSoundInfo->m_pSoundInfoNext;
        delete pSoundInfo;
    }
}


/****************************************************************************
 *
 *  DiagnoseSound
 *
 ****************************************************************************/
VOID DiagnoseSound(SoundInfo* pSoundInfoFirst)
{
    SoundInfo* pSoundInfo;
    TCHAR sz[500];
    TCHAR szFmt[500];

    for (pSoundInfo = pSoundInfoFirst; pSoundInfo != NULL; 
        pSoundInfo = pSoundInfo->m_pSoundInfoNext)
    {
        _tcscpy( pSoundInfo->m_szNotes, TEXT("") );
        _tcscpy( pSoundInfo->m_szNotesEnglish, TEXT("") );

         // Report any problems:
        BOOL bProblem = FALSE;
        if ( pSoundInfo->m_bDriverSignedValid && 
             !pSoundInfo->m_bDriverSigned && 
             lstrlen(pSoundInfo->m_szDriverName) > 0)
        {
            LoadString(NULL, IDS_UNSIGNEDDRIVERFMT1, szFmt, 300);
            wsprintf(sz, szFmt, pSoundInfo->m_szDriverName);
            _tcscat( pSoundInfo->m_szNotes, sz );

            LoadString(NULL, IDS_UNSIGNEDDRIVERFMT1_ENGLISH, szFmt, 300);
            wsprintf(sz, szFmt, pSoundInfo->m_szDriverName);
            _tcscat( pSoundInfo->m_szNotesEnglish, sz );

            bProblem = TRUE;
        }

        if (pSoundInfo->m_pRegErrorFirst != NULL)
        {
            LoadString(NULL, IDS_REGISTRYPROBLEM, sz, 500);
            _tcscat( pSoundInfo->m_szNotes, sz );

            LoadString(NULL, IDS_REGISTRYPROBLEM_ENGLISH, sz, 500);
            _tcscat( pSoundInfo->m_szNotesEnglish, sz );

            bProblem = TRUE;
        }

        // Report any DSound test results:
        if (pSoundInfo->m_testResultSnd.m_bStarted &&
            !pSoundInfo->m_testResultSnd.m_bCancelled)
        {
            LoadString(NULL, IDS_DSRESULTS, sz, 500);
            _tcscat( pSoundInfo->m_szNotes, sz );
            _tcscat( pSoundInfo->m_szNotes, pSoundInfo->m_testResultSnd.m_szDescription );
            _tcscat( pSoundInfo->m_szNotes, TEXT("\r\n") );

            LoadString(NULL, IDS_DSRESULTS_ENGLISH, sz, 500);
            _tcscat( pSoundInfo->m_szNotesEnglish, sz );
            _tcscat( pSoundInfo->m_szNotesEnglish, pSoundInfo->m_testResultSnd.m_szDescriptionEnglish );
            _tcscat( pSoundInfo->m_szNotesEnglish, TEXT("\r\n") );

            bProblem = TRUE;
        }
        else
        {
            LoadString(NULL, IDS_DSINSTRUCTIONS, sz, 500);
            _tcscat( pSoundInfo->m_szNotes, sz );

            LoadString(NULL, IDS_DSINSTRUCTIONS_ENGLISH, sz, 500);
            _tcscat( pSoundInfo->m_szNotesEnglish, sz );
        }

        if (!bProblem)
        {
            LoadString(NULL, IDS_NOPROBLEM, sz, 500);
            _tcscat( pSoundInfo->m_szNotes, sz );

            LoadString(NULL, IDS_NOPROBLEM_ENGLISH, sz, 500);
            _tcscat( pSoundInfo->m_szNotesEnglish, sz );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

MAJORCOMP=
MINORCOMP=

TARGETNAME=dxdiag
TARGETPATH=obj
TARGETTYPE=PROGRAM
UMENTRY=winmain
UMTYPE=windows
UMAPPL=
UMLIBS=

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
            $(SDK_LIB_PATH)\comctl32.lib    \
            $(SDK_LIB_PATH)\winmm.lib       \
            $(SDK_LIB_PATH)\comdlg32.lib    \
            $(SDK_LIB_PATH)\version.lib     \
            $(SDK_LIB_PATH)\shell32.lib     \
            $(SDK_LIB_PATH)\ole32.lib       \
            $(SDK_LIB_PATH)\uuid.lib        \
            $(SDK_LIB_PATH)\oleaut32.lib    \
            $(SDK_LIB_PATH)\dplayx.lib      \
            $(SDK_LIB_PATH)\d3dx8.lib       \
            $(SDK_LIB_PATH)\wbemuuid.lib    \
            $(SDK_LIB_PATH)\strmbase.lib    \

INCLUDES=$(DXROOT)\inc; \
         $(SDK_INC_PATH); \
         $(SDK_INC_PATH)\mfc42;

SOURCES=..\dispinfo.cpp \
        ..\dispinfo8.cpp \
        ..\fileinfo.cpp \
        ..\inptinfo.cpp \
        ..\netinfo.cpp \
        ..\ghost.cpp \
        ..\guids.cpp \
        ..\main.cpp \
        ..\save.cpp \
        ..\dsprvobj.cpp \
        ..\sndinfo.cpp \
        ..\sndinfo7.cpp \
        ..\musinfo.cpp \
        ..\showinfo.cpp \
        ..\sysinfo.cpp \
        ..\reginfo.cpp \
        ..\testdd.cpp \
        ..\testagp.cpp \
        ..\testd3d8.cpp \
        ..\testsnd.cpp \
        ..\testmus.cpp \
        ..\testnet.cpp \
        ..\$(TARGETNAME).rc 

MISCFILES=..\dxdiag.chm

USE_LIBCMT=1

# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.DxDiag
SXS_ASSEMBLY_VERSION=1.0 
#uncomment one of these lines, or put in a similar line
SXS_ASSEMBLY_LANGUAGE=en-us
#SXS_ASSEMBLY_LANGUAGE=en
#SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=DxDiag.Manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\sndinfo.h ===
/****************************************************************************
 *
 *    File: sndinfo.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about sound devices on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef SNDINFO_H
#define SNDINFO_H

// DXD_IN_DS_VALUE is the name of a value stored under the registry key 
// HKLM\DXD_IN_DS_KEY that indicates that DxDiag is using
// DirectSound.  If DxDiag starts up and this value exists, DxDiag 
// probably crashed in DirectSound and DxDiag should offer to run without
// using DirectSound.
#define DXD_IN_DS_KEY TEXT("Software\\Microsoft\\DirectX Diagnostic Tool")
#define DXD_IN_DS_VALUE TEXT("DxDiag In DirectSound")

struct SoundInfo
{
    GUID m_guid;
    DWORD m_dwDevnode;
    TCHAR m_szDeviceID[200];
    TCHAR m_szRegKey[200];
    TCHAR m_szManufacturerID[100];
    TCHAR m_szProductID[100];
    TCHAR m_szDescription[200];
    TCHAR m_szDriverName[200];
    TCHAR m_szDriverPath[MAX_PATH];
    TCHAR m_szDriverVersion[100];
    TCHAR m_szDriverLanguage[100];
    TCHAR m_szDriverLanguageLocal[100];
    TCHAR m_szDriverAttributes[100];
    TCHAR m_szDriverDate[60];
    TCHAR m_szDriverDateLocal[60];
    TCHAR m_szOtherDrivers[200];
    TCHAR m_szProvider[200];
    TCHAR m_szType[100]; // Emulated / vxd / wdm
    LONG m_numBytes;
    BOOL m_bDriverBeta;
    BOOL m_bDriverDebug;
    BOOL m_bDriverSigned;
    BOOL m_bDriverSignedValid;
    LONG m_lwAccelerationLevel;

    RegError* m_pRegErrorFirst;
    TCHAR m_szNotes[3000]; 
    TCHAR m_szNotesEnglish[3000]; 

    TestResult m_testResultSnd; // This is filled in by testsnd.cpp

    SoundInfo* m_pSoundInfoNext;
};

HRESULT GetBasicSoundInfo(SoundInfo** ppSoundInfoFirst);
HRESULT GetExtraSoundInfo(SoundInfo* pSoundInfoFirst);
HRESULT GetDSSoundInfo(SoundInfo* pSoundInfoFirst);
VOID DestroySoundInfo(SoundInfo* pSoundInfoFirst);
HRESULT ChangeAccelerationLevel(SoundInfo* pSoundInfo, LONG lwLevel);
VOID DiagnoseSound(SoundInfo* pSoundInfoFirst);


#endif // DISPINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\sndinfo7.cpp ===
/****************************************************************************
 *
 *    File: sndinfo7.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather DX7-specific sound information
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#define DIRECTSOUND_VERSION  0x0700 // <-- note difference from sndinfo.cpp
#include <tchar.h>
#include <Windows.h>
#include <mmsystem.h>
#include <dsound.h>
#include "dsprv.h"

static HRESULT PrvGetDeviceDescription7
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA *ppData
);

static HRESULT PrvReleaseDeviceDescription7
( 
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA pData 
);


/****************************************************************************
 *
 *  GetRegKey
 *
 ****************************************************************************/
HRESULT GetRegKey(LPKSPROPERTYSET pKSPS7, REFGUID guidDeviceID, TCHAR* pszRegKey)
{
    HRESULT hr;
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA pdsddd;
    TCHAR szInterface[200];
    TCHAR* pchSrc;
    TCHAR* pchDest;

    if (FAILED(hr = PrvGetDeviceDescription7(pKSPS7, guidDeviceID, &pdsddd)))
        return hr;

    if (pdsddd->Interface == NULL) // This seems to always be the case on Win9x
    {
        lstrcpy(pszRegKey, TEXT(""));
        PrvReleaseDeviceDescription7( pdsddd );
        return E_FAIL;
    }

    lstrcpy(szInterface, pdsddd->Interface);

    PrvReleaseDeviceDescription7( pdsddd );
    pdsddd = NULL;

    pchSrc = szInterface + 4; // skip "\\?\"
    pchDest = pszRegKey;
    while (TRUE)
    {
        *pchDest = *pchSrc;
        if (*pchDest == TEXT('#')) // Convert "#" to "\"
            *pchDest = TEXT('\\');
        if (*pchDest == TEXT('{')) // End if "{" found
            *pchDest = TEXT('\0');
        if (*pchDest == TEXT('\0'))
            break;
        pchDest++;
        pchSrc++;
    }
    if (*(pchDest-1) == TEXT('\\')) // Remove final "\"
        *(pchDest-1) = TEXT('\0');
    return S_OK;
}

// The following function is identical to the one defined in dsprvobj.cpp,
// except it is defined with DIRECTSOUND_VERSION at 0x0700, so you get more
// description data (namely the Interface string).
/***************************************************************************
 *
 *  PrvGetDeviceDescription7
 *
 *  Description:
 *      Gets the extended description for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device id.
 *      PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA [out]: receives
 *                                                            description.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

static HRESULT PrvGetDeviceDescription7
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA *ppData
)
{
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA  pData = NULL;
    ULONG                                           cbData;
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA   Basic;
    HRESULT                                         hr;

    Basic.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
            NULL,
            0,
            &Basic,
            sizeof(Basic),
            &cbData
        );

    if(SUCCEEDED(hr))
    {
        pData = (PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA)new BYTE [cbData];

        if(!pData)
        {
            hr = DSERR_OUTOFMEMORY;
        }
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(pData, cbData);

        pData->DeviceId = guidDeviceId;
        
        hr =
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundDevice,
                DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
                NULL,
                0,
                pData,
                cbData,
                NULL
            );
    }

    if(SUCCEEDED(hr))
    {
        *ppData = pData;
    }
    else if(pData)
    {
        delete pData;
    }

    return hr;
}




/***************************************************************************
 *
 *  PrvReleaseDeviceDescription7
 *
 ***************************************************************************/
HRESULT PrvReleaseDeviceDescription7( PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA pData )
{
    delete[] pData;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\testagp.h ===
/****************************************************************************
 *
 *    File: testagp.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Jason Sandlin (jasonsa@microsoft.com)
 * Purpose: Test AGP Texturing functionality on this machine
 *
 * (C) Copyright 2000 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef TESTAGP_H
#define TESTAGP_H

VOID TestD3Dv7(BOOL bUseTexture, HWND hwndMain, DisplayInfo* pDisplayInfo);


#endif // TESTAGP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\sysinfo.cpp ===
/****************************************************************************
 *
 *    File: sysinfo.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 *          CPU type detection code by Rich Granshaw
 *          CPU speed code by Michael Lyons
 * Purpose: Gather system information (OS, hardware, name, etc.) on this machine
 *
 *          \Multimedia\Testsrc\Tools\ShowCPUID\ can be used to debug CPUID problems.
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <tchar.h>
#include <Windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include <wbemidl.h>
#include <objbase.h>
#include <shfolder.h>
#include <dsound.h>
#include "dsprv.h"
#include "dsprvobj.h"
#include "sysinfo.h"
#include "fileinfo.h" // for GetLanguageFromFile
#include "resource.h"


#define REGSTR_PATH_D3D                     TEXT("Software\\Microsoft\\Direct3D")
#define REGSTR_VAL_DDRAW_LOADDEBUGRUNTIME   TEXT("LoadDebugRuntime")
#define REGSTR_DINPUT_DLL                   TEXT("CLSID\\{25E609E4-B259-11CF-BFC7-444553540000}\\InProcServer32")
#define REGSTR_DMUSIC_DLL                   TEXT("CLSID\\{480FF4B0-28B2-11D1-BEF7-00C04FBF8FEF}\\InProcServer32")

struct PROCESSOR_ID_NUMBERS
{
    DWORD dwType;         // Intel: 0 = standard, 1 = Overdrive, 2 = dual processor.
    DWORD dwFamily;       
    DWORD dwModel;
    DWORD dwSteppingID;
};

extern IWbemServices* g_pIWbemServices;
typedef INT (WINAPI* LPDXSETUPGETVERSION)(DWORD* pdwVersion, DWORD* pdwRevision);
static VOID GetProcessorDescription(BOOL bNT, SYSTEM_INFO* psi, TCHAR* pszDesc, BOOL* pbNoCPUSpeed);
static VOID GetProcessorVendorNameAndType(OSVERSIONINFO& OSVersionInfo, 
    SYSTEM_INFO& SystemInfo, TCHAR* pszProcessor, BOOL* pbNoCPUSpeed);
static VOID GetVendorNameAndCaps(TCHAR* pszVendorName, TCHAR* pszIDTLongName, 
    PROCESSOR_ID_NUMBERS& ProcessorIdNumbers, BOOL* pbIsMMX, BOOL* pbIs3DNow, BOOL* pbIsKatmai, /*Pentium III/Streaming SIMD Instrucs*/
    LPDWORD pdwKBytesLevel2Cache, LPDWORD pdwIntelBrandIndex, BOOL* pbNoCPUSpeed);
#ifdef _X86_
static INT GetCPUSpeed(VOID);
static INT GetCPUSpeedViaWMI(VOID);
#endif
static VOID GetComputerSystemInfo(TCHAR* szSystemManufacturerEnglish, TCHAR* szSystemModelEnglish);
static VOID GetBIOSInfo(TCHAR* szBIOSEnglish);
static VOID GetFileSystemStoringD3D8Cache( TCHAR* strFileSystemBuffer );

static VOID GetDXDebugLevels(SysInfo* pSysInfo);
static int  GetDSDebugLevel();
static BOOL IsDMusicDebugRuntime();
static BOOL IsDMusicDebugRuntimeAvailable();
static int  GetDMDebugLevel();
static BOOL IsDInput8DebugRuntime();
static BOOL IsDInput8DebugRuntimeAvailable();
static int  GetDIDebugLevel();
static BOOL IsD3DDebugRuntime();
static BOOL IsD3D8DebugRuntimeAvailable();
static BOOL IsDDrawDebugRuntime();
static BOOL IsDPlayDebugRuntime();
static BOOL IsDSoundDebugRuntime();
static BOOL IsNetMeetingRunning();




/****************************************************************************
 *
 *  BIsPlatformNT
 *
 ****************************************************************************/
BOOL BIsPlatformNT(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return (OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
}


/****************************************************************************
 *
 *  BIsPlatform9x
 *
 ****************************************************************************/
BOOL BIsPlatform9x(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return (OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
}


/****************************************************************************
 *
 *  BIsWin2k
 *
 ****************************************************************************/
BOOL BIsWin2k(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return ( OSVersionInfo.dwPlatformId   == VER_PLATFORM_WIN32_NT && 
             OSVersionInfo.dwMajorVersion == 5 &&
             OSVersionInfo.dwMinorVersion == 0 ); // should be 05.00.xxxx
}


/****************************************************************************
 *
 *  BIsWhistler
 *
 ****************************************************************************/
BOOL BIsWhistler(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return ( OSVersionInfo.dwPlatformId   == VER_PLATFORM_WIN32_NT && 
             OSVersionInfo.dwMajorVersion == 5 &&
             OSVersionInfo.dwMinorVersion == 1 ); // should be 05.01.xxxx
}


/****************************************************************************
 *
 *  BIsWinNT
 *
 ****************************************************************************/
BOOL BIsWinNT(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return ( OSVersionInfo.dwPlatformId   == VER_PLATFORM_WIN32_NT && 
             OSVersionInfo.dwMajorVersion <= 4 ); 
}


/****************************************************************************
 *
 *  BIsWinME
 *
 ****************************************************************************/
BOOL BIsWinME(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return( OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && 
            OSVersionInfo.dwMajorVersion >= 4 && 
            OSVersionInfo.dwMinorVersion >= 90 ); // should be 4.90.xxxx
}


/****************************************************************************
 *
 *  BIsWin98 - from http://kbinternal/kb/articles/q189/2/49.htm
 *
 ****************************************************************************/
BOOL BIsWin98(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return( OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && 
            OSVersionInfo.dwMajorVersion == 4 && 
            OSVersionInfo.dwMinorVersion == 10 ); // should be 4.10.xxxx
}


/****************************************************************************
 *
 *  BIsWin95 - from http://kbinternal/kb/articles/q189/2/49.htm
 *
 ****************************************************************************/
BOOL BIsWin95(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return( OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && 
            OSVersionInfo.dwMajorVersion == 4 && 
            OSVersionInfo.dwMinorVersion < 10 ); // should be 4.00.0950
}


/****************************************************************************
 *
 *  BIsWin3x 
 *
 ****************************************************************************/
BOOL BIsWin3x(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return( OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && 
            OSVersionInfo.dwMajorVersion < 4 ); // should be 3.xx.xxxx
}


/****************************************************************************
 *
 *  BIsIA64 
 *
 ****************************************************************************/
BOOL BIsIA64(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    SYSTEM_INFO SystemInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    GetSystemInfo(&SystemInfo);

    return( OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT && 
            SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 );
}


/****************************************************************************
 *
 *  GetSystemInfo
 *
 ****************************************************************************/
VOID GetSystemInfo(SysInfo* pSysInfo)
{
    TCHAR szSystemPath[MAX_PATH];
    HKEY hKey = NULL;
    HKEY hSubKey = NULL;
    ULONG ulType;
    OSVERSIONINFO OSVersionInfo;
    SYSTEM_INFO SystemInfo;
    DWORD cbData;
    LCID lcid;
    DWORD dwKeyboardSubType;
    WORD wLanguage;
    TCHAR sz[200];
    TCHAR szDebug[100];

    // Get current time
    TCHAR szDate[100];
    TCHAR szTime[100];
    GetLocalTime(&pSysInfo->m_time);
    GetDateFormat(LOCALE_USER_DEFAULT, DATE_LONGDATE, NULL, NULL, szDate, 100);
    wsprintf(szTime, TEXT("%02d:%02d:%02d"), pSysInfo->m_time.wHour, 
        pSysInfo->m_time.wMinute, pSysInfo->m_time.wSecond);
    wsprintf(pSysInfo->m_szTimeLocal, TEXT("%s, %s"), szDate, szTime);

    wsprintf(szDate, TEXT("%d/%d/%d"), pSysInfo->m_time.wMonth, pSysInfo->m_time.wDay, pSysInfo->m_time.wYear);
    wsprintf(pSysInfo->m_szTime, TEXT("%s, %s"), szDate, szTime);

    // Get the computer network name
    cbData = sizeof(pSysInfo->m_szMachine) - 1;
    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Control\\ComputerName\\ComputerName"), 0, KEY_READ, &hKey)
        && !RegQueryValueEx(hKey, TEXT("ComputerName"), 0, &ulType, (LPBYTE)pSysInfo->m_szMachine, &cbData)
        && ulType == REG_SZ)
    {
        // Got data OK.
    }
    else
    {
        LoadString(NULL, IDS_NOMACHINENAME, pSysInfo->m_szMachine, 200);
    }
    if (hKey)
    {
        RegCloseKey(hKey);
        hKey = 0;
    }

    // Check for NEC PC-98
    pSysInfo->m_bNECPC98 = FALSE;
    lcid = GetSystemDefaultLCID();
    if (lcid == 0x0411)                         // Windows 95 J 
    {
        dwKeyboardSubType = GetKeyboardType(1);
        if (HIBYTE(dwKeyboardSubType) == 0x0D)  // NEC PC-98 series
        {
            pSysInfo->m_bNECPC98 = TRUE;
            LoadString(NULL, IDS_NECPC98, sz, 200);
            lstrcat(pSysInfo->m_szMachine, sz);
        }
    }

    // Get Windows version
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    pSysInfo->m_dwMajorVersion = OSVersionInfo.dwMajorVersion;
    pSysInfo->m_dwMinorVersion = OSVersionInfo.dwMinorVersion;
    pSysInfo->m_dwBuildNumber = OSVersionInfo.dwBuildNumber;
    pSysInfo->m_dwPlatformID = OSVersionInfo.dwPlatformId;
    lstrcpy(pSysInfo->m_szCSDVersion, OSVersionInfo.szCSDVersion);
    pSysInfo->m_bDebug = (GetSystemMetrics(SM_DEBUG) > 0);

    // Get OS Name
    TCHAR* pszWindowsKey;
    if (pSysInfo->m_dwPlatformID == VER_PLATFORM_WIN32_NT)
        pszWindowsKey = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion");
    else
        pszWindowsKey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion");
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszWindowsKey, 0, KEY_READ, &hKey))
    {
        cbData = 100;
        RegQueryValueEx(hKey, TEXT("ProductName"), 0, &ulType, (LPBYTE)pSysInfo->m_szOS, &cbData);
        cbData = 100;
        RegQueryValueEx(hKey, TEXT("BuildLab"), 0, &ulType, (LPBYTE)pSysInfo->m_szBuildLab, &cbData);
        RegCloseKey(hKey);
    }
    if (lstrlen(pSysInfo->m_szOS) == 0)
    {
        // it is very strange for ProductName registry info 
        // (see above) to be missing.
        lstrcpy(pSysInfo->m_szOS, TEXT("Windows"));
    }
    if (pSysInfo->m_dwPlatformID == VER_PLATFORM_WIN32_NT)
    {
        // 25598: Append product type (professional, server, etc)
        OSVERSIONINFOEX osve;
        ZeroMemory(&osve, sizeof(osve));
        osve.dwOSVersionInfoSize = sizeof(osve);
        GetVersionEx((OSVERSIONINFO*)&osve);
        if (osve.wProductType == VER_NT_SERVER && osve.wSuiteMask & VER_SUITE_DATACENTER)
        {
            lstrcat(pSysInfo->m_szOS, TEXT(" "));
            LoadString(NULL, IDS_DATACENTERSERVER, sz, 200);
            lstrcat(pSysInfo->m_szOS, sz);
        }
        else if (osve.wProductType == VER_NT_SERVER && osve.wSuiteMask & VER_SUITE_ENTERPRISE)
        {
            lstrcat(pSysInfo->m_szOS, TEXT(" "));
            LoadString(NULL, IDS_ADVANCEDSERVER, sz, 200);
            lstrcat(pSysInfo->m_szOS, sz);
        }
        else if (osve.wProductType == VER_NT_SERVER)
        {
            lstrcat(pSysInfo->m_szOS, TEXT(" "));
            LoadString(NULL, IDS_SERVER, sz, 200);
            lstrcat(pSysInfo->m_szOS, sz);
        }
        else if (osve.wProductType == VER_NT_WORKSTATION && (osve.wSuiteMask & VER_SUITE_PERSONAL))
        {
            lstrcat(pSysInfo->m_szOS, TEXT(" "));
            LoadString(NULL, IDS_PERSONAL, sz, 200);
            lstrcat(pSysInfo->m_szOS, sz);
        }
        else if (osve.wProductType == VER_NT_WORKSTATION)
        {
            lstrcat(pSysInfo->m_szOS, TEXT(" "));
            LoadString(NULL, IDS_PROFESSIONAL, sz, 200);
            lstrcat(pSysInfo->m_szOS, sz);
        }
    }

    // Format Windows version
    LoadString(NULL, IDS_WINVERFMT, sz, 200);
    LoadString(NULL, IDS_DEBUG, szDebug, 100);
    lstrcat(szDebug, TEXT(" "));
    wsprintf(pSysInfo->m_szOSEx, sz, 
        pSysInfo->m_bDebug ? szDebug : TEXT(""),
        pSysInfo->m_szOS, pSysInfo->m_dwMajorVersion, pSysInfo->m_dwMinorVersion, 
        LOWORD(pSysInfo->m_dwBuildNumber));

    TCHAR szOSTmp[200];
    if( _tcslen( pSysInfo->m_szCSDVersion) )
        wsprintf( szOSTmp, TEXT("%s %s"), pSysInfo->m_szOSEx, pSysInfo->m_szCSDVersion );
    else
        wsprintf( szOSTmp, TEXT("%s"), pSysInfo->m_szOSEx );

    if( _tcslen( pSysInfo->m_szBuildLab ) )
        wsprintf( pSysInfo->m_szOSExLong, TEXT("%s (%s)"), szOSTmp, pSysInfo->m_szBuildLab );
    else
        wsprintf( pSysInfo->m_szOSExLong, TEXT("%s"), szOSTmp );

    // Get the original language. 
    GetSystemDirectory(szSystemPath, MAX_PATH);
    if (wLanguage = GetLanguageFromFile(TEXT("user.exe"), szSystemPath))
    {
        lcid = MAKELCID(wLanguage, SORT_DEFAULT);
    }
    // Get the language and regional setting and store them (in English) for saved file:
    TCHAR szLanguage[200];
    TCHAR szLanguageRegional[200];
    if ((!GetLocaleInfo(lcid, LOCALE_SENGLANGUAGE, szLanguage, 200)))
        szLanguage[0] = '\0';                  
    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SENGLANGUAGE, szLanguageRegional, 200))
        szLanguageRegional[0] = '\0';                  
    LoadString(NULL, IDS_LANGUAGEFMT_ENGLISH, sz, 200);
    wsprintf(pSysInfo->m_szLanguages, sz, szLanguage, szLanguageRegional);

    // Now get same info in local language for display:
    if ((!GetLocaleInfo(lcid, LOCALE_SNATIVELANGNAME, szLanguage, 200)))
        szLanguage[0] = '\0';                  
    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SNATIVELANGNAME, szLanguageRegional, 200))
        szLanguageRegional[0] = '\0';                  
    LoadString(NULL, IDS_LANGUAGEFMT, sz, 200);
    wsprintf(pSysInfo->m_szLanguagesLocal, sz, szLanguage, szLanguageRegional);

    // Get info about processor manufacturer and type
    BOOL  bNoCPUSpeed = TRUE;
    
    GetSystemInfo(&SystemInfo);
    GetProcessorDescription(pSysInfo->m_dwPlatformID == VER_PLATFORM_WIN32_NT, 
        &SystemInfo, pSysInfo->m_szProcessor, &bNoCPUSpeed);
    GetComputerSystemInfo(pSysInfo->m_szSystemManufacturerEnglish, pSysInfo->m_szSystemModelEnglish);
    GetBIOSInfo(pSysInfo->m_szBIOSEnglish);

#ifdef _X86_
    // Append processor speed, if it can be computed
    if ( bNoCPUSpeed )
    {
        INT iMhz = GetCPUSpeed();
        if (iMhz > 0)
        {
            TCHAR szSpeed[50];
            wsprintf(szSpeed, TEXT(", ~%dMHz"), iMhz);
            lstrcat(pSysInfo->m_szProcessor, szSpeed);
        }
    }
#endif
    
    BOOL bGotMem = FALSE;

    // Get system memory information
    if( BIsPlatformNT() )
    {
        TCHAR szPath[MAX_PATH];
        GetSystemDirectory(szPath, MAX_PATH);
        lstrcat(szPath, TEXT("\\kernel32.dll"));
        HINSTANCE hKernel32 = LoadLibrary(szPath);
        if( hKernel32 != NULL )
        {
            typedef BOOL (WINAPI* PGlobalMemoryStatusEx)(OUT LPMEMORYSTATUSEX lpBuffer);
            PGlobalMemoryStatusEx pGlobalMemoryStatusEx = (PGlobalMemoryStatusEx)GetProcAddress(hKernel32, "GlobalMemoryStatusEx");
            if( pGlobalMemoryStatusEx != NULL )
            {
                MEMORYSTATUSEX MemoryStatus;
                MemoryStatus.dwLength = sizeof(MEMORYSTATUSEX);
                pGlobalMemoryStatusEx(&MemoryStatus);
                pSysInfo->m_ullPhysicalMemory = MemoryStatus.ullTotalPhys;
                pSysInfo->m_ullUsedPageFile = MemoryStatus.ullTotalPageFile - MemoryStatus.ullAvailPageFile;
                pSysInfo->m_ullAvailPageFile = MemoryStatus.ullAvailPageFile;
                bGotMem = TRUE;
            }
            FreeLibrary(hKernel32);
        }
    }

    if( !bGotMem ) // Win9x or LoadLib failed
    {
        MEMORYSTATUS MemoryStatus;
        MemoryStatus.dwLength = sizeof MemoryStatus;
        GlobalMemoryStatus(&MemoryStatus);
        pSysInfo->m_ullPhysicalMemory = MemoryStatus.dwTotalPhys;
        pSysInfo->m_ullUsedPageFile = MemoryStatus.dwTotalPageFile - MemoryStatus.dwAvailPageFile;
        pSysInfo->m_ullAvailPageFile = MemoryStatus.dwAvailPageFile;
    }

    // Format memory information:
    DWORDLONG dwMB = (DWORDLONG)(pSysInfo->m_ullPhysicalMemory >> 20);
    dwMB += dwMB % 2; // round up to even number
    _stprintf(pSysInfo->m_szPhysicalMemory, TEXT("%I64dMB RAM"), dwMB);
    
    DWORDLONG dwUsedMB  = (pSysInfo->m_ullUsedPageFile >> 20);
    DWORDLONG dwAvailMB = (pSysInfo->m_ullAvailPageFile >> 20);

    LoadString(NULL, IDS_PAGEFILEFMT, sz, 200);
    _stprintf(pSysInfo->m_szPageFile, sz, dwUsedMB, dwAvailMB);

    LoadString(NULL, IDS_PAGEFILEFMT_ENGLISH, sz, 200);
    _stprintf(pSysInfo->m_szPageFileEnglish, sz, dwUsedMB, dwAvailMB);

    // Get DxDiag version:
    TCHAR szFile[MAX_PATH];
    if (0 != GetModuleFileName(NULL, szFile, MAX_PATH))
        GetFileVersion(szFile, pSysInfo->m_szDxDiagVersion, NULL, NULL, NULL, NULL);
    
    // Get DirectX Version using dsetup.dll
    TCHAR szSetupPath[MAX_PATH];
    HINSTANCE hInstDSetup;
    LPDXSETUPGETVERSION pDXSGetVersion;
    BOOL bFound = FALSE;
    LoadString(NULL, IDS_NOTFOUND, pSysInfo->m_szDirectXVersionLong, 100);

    if (!BIsPlatformNT() && GetDxSetupFolder(szSetupPath))
    {
        lstrcat(szSetupPath, TEXT("\\dsetup.dll"));
        hInstDSetup = LoadLibrary(szSetupPath);
        if (hInstDSetup != NULL)
        {
            pDXSGetVersion = (LPDXSETUPGETVERSION)GetProcAddress(hInstDSetup, 
                "DirectXSetupGetVersion");
            if (pDXSGetVersion != NULL)
            {
                DWORD dwVersion = 0;
                DWORD dwRevision = 0;
                if (pDXSGetVersion(&dwVersion, &dwRevision) != 0)
                {
                    wsprintf(pSysInfo->m_szDirectXVersion, TEXT("%d.%02d.%02d.%04d"),
                        HIWORD(dwVersion), LOWORD(dwVersion),
                        HIWORD(dwRevision), LOWORD(dwRevision));
                    bFound = TRUE;
                }
            }
            FreeLibrary(hInstDSetup);
        }
    }
    if (!bFound)
    {
        // Look in registry for DX version instead
        HKEY hkey;
        DWORD cbData;
        ULONG ulType;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectX"),
            0, KEY_READ, &hkey))
        {
            cbData = 100;
            RegQueryValueEx(hkey, TEXT("Version"), 0, &ulType, (LPBYTE)pSysInfo->m_szDirectXVersion, &cbData);
            RegCloseKey(hkey);
            if (lstrlen(pSysInfo->m_szDirectXVersion) > 6 && 
                lstrlen(pSysInfo->m_szDirectXVersion) < 20)
            {
                bFound = TRUE;
            }
        }
    }
    if (!bFound && !BIsPlatformNT())
    {
        // Report ddraw.dll version instead 
        // (except on Win2000, where ddraw.dll version is way different from DX version)
        TCHAR szDDrawPath[MAX_PATH];
        GetSystemDirectory(szDDrawPath, MAX_PATH);
        lstrcat(szDDrawPath, TEXT("\\ddraw.dll"));
        GetFileVersion(szDDrawPath, pSysInfo->m_szDirectXVersion, NULL, NULL, NULL);
    }
    if (lstrlen(pSysInfo->m_szDirectXVersion) > 0)
    {
        // Bug 18501: Add "friendly" version of version name
        DWORD dwMajor;
        DWORD dwMinor;
        DWORD dwRevision;
        DWORD dwBuild;
        TCHAR szFriendly[100];
        lstrcpy(szFriendly, TEXT(""));
        _stscanf(pSysInfo->m_szDirectXVersion, TEXT("%d.%d.%d.%d"), &dwMajor, &dwMinor, &dwRevision, &dwBuild);
        wsprintf(pSysInfo->m_szDirectXVersion, TEXT("%d.%02d.%02d.%04d"), dwMajor, dwMinor, dwRevision, dwBuild);
        // According to http://xevious/directx/versions.htm:
        // 4.02.xx.xxxx is DX1
        // 4.03.xx.xxxx is DX2
        // 4.04.xx.xxxx is DX3
        // 4.05.xx.xxxx is DX5
        // 4.06.00.xxxx is DX6
        // 4.06.02.xxxx is DX6.1
        // 4.06.03.xxxx is DX6.1A
        // 4.07.00.xxxx is DX7.0
        // 4.07.01.xxxx is DX7.1
        // Beyond that, who knows...
        pSysInfo->m_dwDirectXVersionMajor = 0;
        pSysInfo->m_dwDirectXVersionMinor = 0;
        pSysInfo->m_cDirectXVersionLetter = TEXT(' ');
        if (dwMajor == 4 && dwMinor == 2)
        {
            lstrcpy(szFriendly, TEXT("DirectX 1"));
            pSysInfo->m_dwDirectXVersionMajor = 1;
        }
        if (dwMajor == 4 && dwMinor == 3)
        {
            lstrcpy(szFriendly, TEXT("DirectX 2"));
            pSysInfo->m_dwDirectXVersionMajor = 2;
        }
        if (dwMajor == 4 && dwMinor == 4)
        {
            lstrcpy(szFriendly, TEXT("DirectX 3"));
            pSysInfo->m_dwDirectXVersionMajor = 3;
        }
        if (dwMajor == 4 && dwMinor == 5)
        {
            lstrcpy(szFriendly, TEXT("DirectX 5"));
            pSysInfo->m_dwDirectXVersionMajor = 5;
        }
        else if (dwMajor == 4 && dwMinor == 6 && dwRevision == 0)
        {
            lstrcpy(szFriendly, TEXT("DirectX 6"));
            pSysInfo->m_dwDirectXVersionMajor = 6;
        }
        else if (dwMajor == 4 && dwMinor == 6 && dwRevision == 2)
        {
            lstrcpy(szFriendly, TEXT("DirectX 6.1"));
            pSysInfo->m_dwDirectXVersionMajor = 6;
            pSysInfo->m_dwDirectXVersionMinor = 1;
        }
        else if (dwMajor == 4 && dwMinor == 6 && dwRevision == 3)
        {
            lstrcpy(szFriendly, TEXT("DirectX 6.1a"));
            pSysInfo->m_dwDirectXVersionMajor = 6;
            pSysInfo->m_dwDirectXVersionMinor = 1;
            pSysInfo->m_cDirectXVersionLetter = TEXT('a');
        }
        else if (dwMajor == 4 && dwMinor == 7 && dwRevision == 0 && dwBuild == 716)
        {
            lstrcpy(szFriendly, TEXT("DirectX 7.0a"));
            pSysInfo->m_dwDirectXVersionMajor = 7;
            pSysInfo->m_cDirectXVersionLetter = TEXT('a');
        }
        else if (dwMajor == 4 && dwMinor == 7 && dwRevision == 0)
        {
            lstrcpy(szFriendly, TEXT("DirectX 7.0"));
            pSysInfo->m_dwDirectXVersionMajor = 7;
        }
        else if (dwMajor == 4 && dwMinor == 7 && dwRevision == 1)
        {
            lstrcpy(szFriendly, TEXT("DirectX 7.1"));
            pSysInfo->m_dwDirectXVersionMajor = 7;
            pSysInfo->m_dwDirectXVersionMinor = 1;
        }
        else if (dwMajor == 4 && dwMinor == 8 && dwRevision == 0 )
        {
            lstrcpy(szFriendly, TEXT("DirectX 8.0"));
            pSysInfo->m_dwDirectXVersionMajor = 8;
        }
        else 
        {
            lstrcpy(szFriendly, TEXT("DirectX 8.1"));
            pSysInfo->m_dwDirectXVersionMajor = dwMinor;
            pSysInfo->m_dwDirectXVersionMinor = dwRevision;
        }

        if (lstrlen(szFriendly) > 0)
            wsprintf(pSysInfo->m_szDirectXVersionLong, TEXT("%s (%s)"), szFriendly, pSysInfo->m_szDirectXVersion);
        else
            lstrcpy(pSysInfo->m_szDirectXVersionLong, pSysInfo->m_szDirectXVersion);
    }

    // 24169: Detect setup switches
    pSysInfo->m_dwSetupParam = 0xffffffff;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectX"), 0, NULL, &hKey))
    {
        cbData = sizeof(DWORD);
        RegQueryValueEx(hKey, TEXT("Command"), NULL, &ulType, (BYTE*)&(pSysInfo->m_dwSetupParam), &cbData);
        RegCloseKey(hKey);
    }

    // 48330: add debug level in txt file
    GetDXDebugLevels( pSysInfo );

    switch (pSysInfo->m_dwSetupParam)
    {
    case 0xffffffff: lstrcpy(pSysInfo->m_szSetupParam, TEXT("Not found"));       break;
    case 0:          lstrcpy(pSysInfo->m_szSetupParam, TEXT("None"));            break;
    case 1:          lstrcpy(pSysInfo->m_szSetupParam, TEXT("/Silent"));         break;
    case 2:          lstrcpy(pSysInfo->m_szSetupParam, TEXT("/WindowsUpdate"));  break;
    case 3:          lstrcpy(pSysInfo->m_szSetupParam, TEXT("/PackageInstall")); break;
    case 4:          lstrcpy(pSysInfo->m_szSetupParam, TEXT("/Silent /Reboot")); break;
    case 5:          lstrcpy(pSysInfo->m_szSetupParam, TEXT("/Reboot"));         break;
    default:
        wsprintf(pSysInfo->m_szSetupParam, TEXT("Unknown Switch (%d)"), pSysInfo->m_dwSetupParam);
        break;
    }

    GetFileSystemStoringD3D8Cache( pSysInfo->m_szD3D8CacheFileSystem );

    pSysInfo->m_bNetMeetingRunning = IsNetMeetingRunning();
}


/****************************************************************************
 *
 *  GetProcessorDescription
 *
 ****************************************************************************/
VOID GetProcessorDescription(BOOL bNT, SYSTEM_INFO* psi, TCHAR* pszDesc, BOOL* pbNoCPUSpeed)
{
    OSVERSIONINFO OSVersionInfo;
    SYSTEM_INFO SystemInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    GetSystemInfo(&SystemInfo);
    GetProcessorVendorNameAndType(OSVersionInfo, SystemInfo, pszDesc, pbNoCPUSpeed);
    if (SystemInfo.dwNumberOfProcessors > 1)
    {
        TCHAR szFmt[100];
        TCHAR szNumProc[100];
        LoadString(NULL, IDS_NUMPROCFMT, szFmt, 100);
        wsprintf(szNumProc, szFmt, SystemInfo.dwNumberOfProcessors);
        lstrcat(pszDesc, szNumProc);
    }
}


/****************************************************************************
 *
 *  GetProcessorVendorNameAndType
 *
 ****************************************************************************/
VOID GetProcessorVendorNameAndType(OSVERSIONINFO& OSVersionInfo, 
    SYSTEM_INFO& SystemInfo, TCHAR* pszProcessor, BOOL* pbNoCPUSpeed)
{
    TCHAR                   szVendorName[50];
    TCHAR                   szLongName[50];
    TCHAR                   szDesc[100];
    BOOL                    bIsMMX = FALSE;
    BOOL                    bIs3DNow = FALSE;
// 10/27/98(RichGr): Intel's Katmai New Instructions (KNI).
    BOOL                    bIsKatmai = FALSE;  /* 2/04/99(RichGr): Pentium III/Streaming SIMD Instrucs*/ 
    PROCESSOR_ID_NUMBERS    ProcessorIdNumbers;
    DWORD                   dwKBytesLevel2Cache;
    DWORD                   dwIntelBrandIndex;

    memset(&szVendorName[0], 0, sizeof szVendorName);
    memset(&szLongName[0], 0, sizeof szLongName);
    memset(&ProcessorIdNumbers, 0, sizeof ProcessorIdNumbers);

//  6/21/99(RichGr): On the Intel, we can now interpret a 1-byte descriptor to give us
//     the size of the Level 2 cache, if present.   
    dwKBytesLevel2Cache = 0;
//  4/26/01(RichGr): On the Intel, we have a new 1-byte index that specifies the brand.
    dwIntelBrandIndex = 0;

    if (OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS    // Win9x
        || (OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT     // WinNT
            && SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL))
    {
        GetVendorNameAndCaps(szVendorName, szLongName, ProcessorIdNumbers, &bIsMMX, &bIs3DNow,
                             &bIsKatmai, &dwKBytesLevel2Cache, &dwIntelBrandIndex, pbNoCPUSpeed);

        if (szLongName[0])  // Use this if there's anything there.
            lstrcpy(pszProcessor, szLongName);
        else
        {
            lstrcpy(pszProcessor, szVendorName);
            lstrcat(pszProcessor, TEXT(" "));

            if ( !lstrcmp(szVendorName, TEXT("Intel")))
            {
                if (SystemInfo.dwProcessorType == PROCESSOR_INTEL_386)
                    lstrcat(pszProcessor, TEXT("80386"));
                else
                if (SystemInfo.dwProcessorType == PROCESSOR_INTEL_486)
                    lstrcat(pszProcessor, TEXT("80486"));
                else
                if (SystemInfo.dwProcessorType == PROCESSOR_INTEL_PENTIUM)
                {
//  6/21/99(RichGr): A lot of this code is now derived from \\muroc\slm\proj\win\src\shell\cpls\system\sysset.c.
                    switch ( ProcessorIdNumbers.dwFamily )
                    {
// We should, of course, never hit these - they've been dealt with above. 
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            lstrcat(pszProcessor, TEXT("80486"));
                            break;

                        case 5:
                            lstrcat(pszProcessor, TEXT("Pentium"));

                            if ( ProcessorIdNumbers.dwModel == 3 )
                                lstrcat(pszProcessor, TEXT(" Overdrive"));

                            break;

                        case 6:
                            switch ( ProcessorIdNumbers.dwModel )
                            {
                                //
                                //Model 1 and 2 are Pentium Pro
                                //
                                case 0:
                                case 1:
                                case 2:
                                    lstrcat(pszProcessor, TEXT("Pentium Pro"));
                                    break;

                                //
                                //Model 3 and 4 are Pentium II
                                //
                                case 3:
                                case 4:
                                    lstrcat(pszProcessor, TEXT("Pentium II"));
                                    break;

                                //
                                //Model 5 is either Pentium II or Celeron (depending on if the chip
                                //has L2 cache or not)
                                //
                                case 5:
                                    if ( dwKBytesLevel2Cache == 0 )    
                                        //
                                        //No L2 cache so it is a Celeron
                                        //
                                        lstrcat(pszProcessor, TEXT("Celeron"));
                                    else
                                        //
                                        //L2 cache so it is at least a Pentium II.  
                                        //
                                        if ( bIsKatmai )
                                            lstrcat(pszProcessor, TEXT("Pentium III"));
                                        else
                                            lstrcat(pszProcessor, TEXT("Pentium II"));

                                    break;

                                case 6:
                                    if ( dwKBytesLevel2Cache > 128 )    
                                        //
                                        //L2 cache > 128K so it is at least a Pentium II
                                        //
                                        if ( bIsKatmai )
                                            lstrcat(pszProcessor, TEXT("Pentium III"));
                                        else
                                            lstrcat(pszProcessor, TEXT("Pentium II"));
                                    else
                                        //
                                        //L2 cache <= 128K so it is a Celeron
                                        //                                                               
                                        lstrcat(pszProcessor, TEXT("Celeron"));

                                    break;

                                case 7:
                                    lstrcat(pszProcessor, TEXT("Pentium III"));
                                    break;

                                default:
                                    if ( bIsKatmai )
                                    {
                                        //  4/26/01(RichGr): Pentium III Xeons and later have a one-byte Brand Index that we can use.
                                        //     More recent machines have a Brand String as well.
                                        //     see ftp://download.intel.com/design/Pentium4/manuals/24547103.pdf
                                        if (dwIntelBrandIndex == 1)
                                            lstrcat(pszProcessor, TEXT("Celeron"));
                                        else
                                        if (dwIntelBrandIndex == 0 || dwIntelBrandIndex == 2)
                                            lstrcat(pszProcessor, TEXT("Pentium III"));
                                        else
                                        if (dwIntelBrandIndex == 3)
                                            lstrcat(pszProcessor, TEXT("Pentium III Xeon"));
                                        else
                                        if (dwIntelBrandIndex == 8)
                                            lstrcat(pszProcessor, TEXT("Pentium 4"));
                                        else
                                            lstrcat(pszProcessor, TEXT("Pentium"));
                                    }
                                    else
                                        lstrcat(pszProcessor, TEXT("Pentium II"));

                                    break;
                            }

                            break;

                        default:
                            wsprintf( szDesc, TEXT("x86 Family %u Model %u Stepping %u"), ProcessorIdNumbers.dwFamily, ProcessorIdNumbers.dwModel,
                                        ProcessorIdNumbers.dwSteppingID );
                            lstrcat(pszProcessor, szDesc);
                            break;
                    }
                }
            }
            else
            if ( !lstrcmp(szVendorName, TEXT("AMD")))
            {
                if (SystemInfo.dwProcessorType == PROCESSOR_INTEL_486)
                    lstrcat(pszProcessor, TEXT("Am486 or Am5X86"));
                else
                if (SystemInfo.dwProcessorType == PROCESSOR_INTEL_PENTIUM)
                {
                    if (ProcessorIdNumbers.dwFamily == 5)
                    {
                        if (ProcessorIdNumbers.dwModel < 6)
                        {
                            wsprintf(szDesc, TEXT("K5 (Model %d)"), ProcessorIdNumbers.dwModel);
                            lstrcat(pszProcessor, szDesc);
                        }
                        else
                        {
                            lstrcat(pszProcessor, TEXT("K6"));
                        }
                    }
                    else
                    {
                        wsprintf(szDesc, TEXT("K%d (Model %d)"), ProcessorIdNumbers.dwFamily, ProcessorIdNumbers.dwModel);
                        lstrcat(pszProcessor, szDesc);
                    }
                }
            }
            else
            if ( !lstrcmp(szVendorName, TEXT("Cyrix")))
            {
                if (ProcessorIdNumbers.dwFamily == 4)
                {
                    if (ProcessorIdNumbers.dwModel == 4)
                        lstrcat(pszProcessor, TEXT("MediaGX"));
                }
                else
                if (ProcessorIdNumbers.dwFamily == 5)
                {
                    if (ProcessorIdNumbers.dwModel == 2)
                        lstrcat(pszProcessor, TEXT("6x86"));
                    else
                    if (ProcessorIdNumbers.dwModel == 4)
                        lstrcat(pszProcessor, TEXT("GXm"));
                }
                else
                if (ProcessorIdNumbers.dwFamily == 6)
                {
                    lstrcat(pszProcessor, TEXT("6x86MX"));
                }
            }
            else
            if ( !lstrcmp(szVendorName, TEXT("IDT")))
            {
    // 4/21/98(RichGr): There's only 1 chip available at present. 
    // 7/07/98(RichGr): Now there are two chips.
    //    Note: Although the C6 is MMX-compatible, Intel does not allow IDT to display the word "MMX"
    //    in association with the name IDT, so we'll skip that.
    //    See http://www.winchip.com/ for more info. 
                if (ProcessorIdNumbers.dwFamily == 5)
                {
                    if (ProcessorIdNumbers.dwModel == 4)
                        lstrcat(pszProcessor, TEXT("WinChip C6"));
                    else
                    if (ProcessorIdNumbers.dwModel >= 8)   // 7/07/98(RichGr): Assume later models have the same feature.
                        lstrcat(pszProcessor, TEXT("WinChip 2"));
                }
                else
                    lstrcat(pszProcessor, TEXT("WinChip"));
            }
            else
            {
                if (SystemInfo.dwProcessorType == PROCESSOR_INTEL_486)
                    lstrcat(pszProcessor, TEXT("486"));
                else
                if (SystemInfo.dwProcessorType == PROCESSOR_INTEL_PENTIUM)
                {
                    if (ProcessorIdNumbers.dwFamily == 5)
                        lstrcat(pszProcessor, TEXT("P5"));
                    else
                    if (ProcessorIdNumbers.dwFamily == 6)
                        lstrcat(pszProcessor, TEXT("P6"));
                    else
                        lstrcat(pszProcessor, TEXT("P5"));
                }
            }
        }

        if (bIsKatmai
            && !lstrcmp(szVendorName, TEXT("Intel")))
            ;
        else
        {
            if (bIsMMX || bIs3DNow)
                lstrcat(pszProcessor, TEXT(", "));

            if (bIsMMX)
                lstrcat(pszProcessor, TEXT(" MMX"));

            if (bIs3DNow)
            {
                if (bIsMMX)
                    lstrcat(pszProcessor, TEXT(", "));

                lstrcat(pszProcessor, TEXT(" 3DNow"));
            }
        }
    }
    else
    if (OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)        // WinNT
    {
        if (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64)
        {
            lstrcpy(pszProcessor, TEXT("IA64"));
        }
        else
        if (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_MIPS)
        {
            lstrcpy(pszProcessor, TEXT("MIPS "));
            wsprintf(szDesc, TEXT("R%d000"), SystemInfo.wProcessorLevel);
            lstrcat(pszProcessor, szDesc);

            if (SystemInfo.wProcessorRevision)
            {
                wsprintf(szDesc, TEXT(" rev. %d"), LOBYTE(SystemInfo.wProcessorRevision));
                lstrcat(pszProcessor, szDesc);
            }
        }
        else
        if (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA)
        {
            lstrcpy(pszProcessor, TEXT("Alpha "));
            wsprintf(szDesc, TEXT("%d"), SystemInfo.wProcessorLevel);
            lstrcat(pszProcessor, szDesc);

            if (SystemInfo.wProcessorRevision)
            {
                wsprintf(szDesc, TEXT(" Model %C - Pass %d"), HIBYTE(SystemInfo.wProcessorRevision) + 'A',
                        LOBYTE(SystemInfo.wProcessorRevision));
                lstrcat(pszProcessor, szDesc);
            }
        }
        else
        if (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_PPC)
        {
            lstrcpy(pszProcessor, TEXT("Power PC "));
         
            if (SystemInfo.wProcessorLevel == 1)
                lstrcat(pszProcessor, TEXT("601"));
            else
            if (SystemInfo.wProcessorLevel == 3)
                lstrcat(pszProcessor, TEXT("603"));
            else
            if (SystemInfo.wProcessorLevel == 4)
                lstrcat(pszProcessor, TEXT("604"));
            else
            if (SystemInfo.wProcessorLevel == 6)
                lstrcat(pszProcessor, TEXT("603+"));
            else
            if (SystemInfo.wProcessorLevel == 9)
                lstrcat(pszProcessor, TEXT("604+"));
            else
            if (SystemInfo.wProcessorLevel == 20)
                lstrcat(pszProcessor, TEXT("620"));

            if (SystemInfo.wProcessorRevision)
            {
                wsprintf(szDesc, TEXT(" rev. %d.%d"), HIBYTE(SystemInfo.wProcessorRevision), LOBYTE(SystemInfo.wProcessorRevision));
                lstrcat(pszProcessor, szDesc);
            }
        }
        else
            lstrcpy(pszProcessor, TEXT("Unknown "));
    }
}


/****************************************************************************
 *
 *  GetVendorNameAndCaps
 *
 ****************************************************************************/
VOID GetVendorNameAndCaps(TCHAR* pszVendorName, TCHAR* pszLongName, 
    PROCESSOR_ID_NUMBERS& ProcessorIdNumbers, BOOL* pbIsMMX, BOOL* pbIs3DNow, BOOL* pbIsKatmai, /*Pentium III/Streaming SIMD Instrucs*/
    LPDWORD pdwKBytesLevel2Cache, LPDWORD pdwIntelBrandIndex, BOOL* pbNoCPUSpeed)
{
    CHAR        szVendorLabel[13];
    CHAR        szLongName[50];
    DWORD       dwFamilyModelStep;
    BOOL        bCPUID_works;
    DWORD       dwFeaturesFlags;
    BYTE        byteCacheDescriptors[4] = {0,0,0,0};
    DWORD       dwIntelBrandIndex;
    PCHAR       psz;

    memset(&szVendorLabel[0], 0, sizeof szVendorLabel);
    memset(&szLongName[0], 0, sizeof szLongName);
    dwFamilyModelStep = 0;
    dwFeaturesFlags = 0;
    *pbIsMMX = FALSE;
    *pbIs3DNow = FALSE;
    *pbIsKatmai = FALSE;    /* 2/04/99(RichGr): Pentium III/Streaming SIMD Instrucs*/
    bCPUID_works = FALSE;
    *pdwKBytesLevel2Cache = 0;
    dwIntelBrandIndex = 0;

#ifdef _X86_
// Determine whether CPUID instruction can be executed. 
    __asm
    {
// CPUID trashes lots - save everything.  Also, Retail build makes assumptions about reg values.
        pushad                      

// Load value of flags register into eax.   
        pushfd
        pop     eax

// Save original flags register value in ebx.   
        mov     ebx, eax

// Alter bit 21 and write new value into flags register.    
        xor     eax, 0x00200000
        push    eax
        popfd

// Retrieve the new value of the flags register.    
        pushfd
        pop     eax

// Compare with the original value. 
        xor     eax, ebx

// If the new value is the same as the old, the CPUID instruction cannot    
// be executed.  Most 486s and all Pentium-class processors should be able
// to execute CPUID.
// 4/21/98(RichGr): One Cyrix 6x86 machine in the Apps Lab (AP_LAREDO) can't execute
// CPUID in ring 3, for no apparent reason.  Another similar machine works fine.
        je      done1

        mov     bCPUID_works, 1    // bCPUID_works = TRUE

// Execute CPUID with eax = 0 to get Vendor Label.  
        xor     eax, eax 
        _emit   0x0F                // CPUID
        _emit   0xA2

// Move Vendor Label from regs to string.
        mov     dword ptr[szVendorLabel + 0], ebx
        mov     dword ptr[szVendorLabel + 4], edx
        mov     dword ptr[szVendorLabel + 8], ecx

// Execute CPUID with eax = 1 to pick up Family, Model and Stepping ID, and to check for MMX support.   
        mov     eax, 1 
        _emit   0x0F                // CPUID
        _emit   0xA2

// Save Family/Model/Stepping ID.
        mov     dwFamilyModelStep, eax

//  4/26/01(RichGr): Save Brand Index (new for PIII Xeons and after).  This is the low byte only.
        mov     dwIntelBrandIndex, ebx

//  2/04/99(RichGr): Save Features Flags.
        mov     dwFeaturesFlags, edx

//  6/21/99(RichGr): Execute CPUID with eax == 2 to pick up descriptor for size of Level 2 cache.
        mov     eax, 2 
        _emit   0x0F                // CPUID
        _emit   0xA2

// Save Level 2 cache size descriptor in byte 0, together with 3 other cache descriptors in bytes 1 - 3.
// See \\muroc\slm\proj\win\src\shell\cpls\system\sysset.c and cpuid.asm,
// and Intel Architecture Software Developer's Manual (1997), volume 2, p. 105.
        mov     dword ptr[byteCacheDescriptors], edx

done1:
// Restore everything.
        popad         
    }
#endif  // _X86_

    
    dwIntelBrandIndex &= 0xFF;  
    *pdwIntelBrandIndex = dwIntelBrandIndex;

//  6/21/99(RichGr): The following values were helpfully provided by David Penley(Intel):
/* 40H No L2 Cache
   41H L2 Unified cache: 128K Bytes, 4-way set associative, 32 byte line size
   42H L2 Unified cache: 256K Bytes, 4-way set associative, 32 byte line size
   43H L2 Unified cache: 512K Bytes, 4-way set associative, 32 byte line size
   44H L2 Unified cache: 1M Byte, 4-way set associative, 32 byte line size
   45H L2 Unified cache: 2M Byte, 4-way set associative, 32 byte line size

Updated manuals can be had at... http://developer.intel.com/design/pentiumiii/xeon/manuals/
*/

    if (szVendorLabel[0])
    {
        if ( !strcmp(&szVendorLabel[0], "GenuineIntel"))
        { 
           lstrcpy(pszVendorName, TEXT("Intel"));

            // 4/29/01: This doesn't cover the Pentium 4, but we don't need cache size
            //    for it at present.
            if ( byteCacheDescriptors[0] == 0x40 )
                *pdwKBytesLevel2Cache = 0;
            else
            if ( byteCacheDescriptors[0] == 0x41 )
                *pdwKBytesLevel2Cache = 128;
            else
            if ( byteCacheDescriptors[0] == 0x42 )
                *pdwKBytesLevel2Cache = 256;
            else
            if ( byteCacheDescriptors[0] == 0x43 )
                *pdwKBytesLevel2Cache = 512;
            else
            if ( byteCacheDescriptors[0] == 0x44 )
                *pdwKBytesLevel2Cache = 1024;
            else
            if ( byteCacheDescriptors[0] == 0x45 )
                *pdwKBytesLevel2Cache = 2048;
        }
        else
        if ( !strcmp(&szVendorLabel[0], "AuthenticAMD"))
            lstrcpy(pszVendorName, TEXT("AMD"));
        else
        if ( !strcmp(&szVendorLabel[0], "CyrixInstead"))
            lstrcpy(pszVendorName, TEXT("Cyrix"));
        else
        if ( !strcmp(&szVendorLabel[0], "CentaurHauls"))
            lstrcpy(pszVendorName, TEXT("IDT"));
        else
        {
#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, 0, szVendorLabel, -1, pszVendorName, 50);
#else
            lstrcpy(pszVendorName, szVendorLabel);
#endif
        }
    }
    else
        lstrcpy(pszVendorName, TEXT("Intel"));

    if (dwFamilyModelStep)
    {
        ProcessorIdNumbers.dwType        = (dwFamilyModelStep & 0x00003000) >> 12;        
        ProcessorIdNumbers.dwFamily      = (dwFamilyModelStep & 0x00000F00) >> 8;        
        ProcessorIdNumbers.dwModel       = (dwFamilyModelStep & 0x000000F0) >> 4;        
        ProcessorIdNumbers.dwSteppingID  =  dwFamilyModelStep & 0x0000000F;        
    }

    if (dwFeaturesFlags)
    {
// Check whether MMX is supported.
        if (dwFeaturesFlags & 0x00800000)
            *pbIsMMX = TRUE;

// 2/04/99(RichGr): Check whether Katmai is supported (aka Pentium III/Streaming SIMD Instrucs).
        if ((dwFeaturesFlags & 0x02000000)
            && !lstrcmp(pszVendorName, TEXT("Intel")))
            *pbIsKatmai = TRUE;
    }

// 7/07/98(RichGr): Added for IDT's Long Name feature.
// 9/10/98(RichGr): Attempt this on all processors, and skip if there's nothing there.
#ifdef _X86_
    if (bCPUID_works)
    {
    __asm
      {
// CPUID trashes lots - save everything.  Also, Retail build makes assumptions about reg values.
        pushad                      


// 9/10/98(RichGr): Check for extended CPUID support.
        mov     eax, 0x80000000
        _emit   0x0F                // CPUID
        _emit   0xA2
        cmp     eax, 0x80000001     // Jump if no extended CPUID.
        jb      done2

// Check for AMD's 3DNow feature.  Note: They believe this may be added to other non-AMD CPUs as well.
// Adapted from one of AMD's webpages at: http://www.amd.com/3dsdk/library/macros/amddcpu.html
        mov     eax, 0x80000001 
        _emit   0x0F                // CPUID
        _emit   0xA2
        test    edx, 0x80000000     // Check for 3DNow flag.    
        jz      LongName
        mov     eax, pbIs3DNow
        mov     dword ptr[eax], 1    // bIs3DNow = TRUE

// Execute CPUID with eax = 0x80000002 thru 0x80000004 to get 48-byte Long Name (for instance: "IDT WinChip 2-3D"). 
LongName:
        mov     esi, 0x80000001
        xor     edi, edi
NameLoop:
        inc     esi
        mov     eax,esi
        cmp     eax, 0x80000004
        jg      done2

        _emit   0x0F                // CPUID
        _emit   0xA2

// 9/10/98(RichGr): The first time thru, check that there's valid alphanumeric data.
        cmp     esi, 0x80000002     // First time?
        jg      Move                // If not, skip this test.
        cmp     al, 0x20            // If first character < ' ', skip.
        jl      done2
        cmp     al, 0x7a            // If first character > 'z', skip.
        jg      done2
 
// Move Long Name from regs to string.
Move:
        mov     dword ptr[szLongName + edi + 0x0], eax
        mov     dword ptr[szLongName + edi + 0x4], ebx
        mov     dword ptr[szLongName + edi + 0x8], ecx
        mov     dword ptr[szLongName + edi + 0x0c], edx
        add     edi, 0x10
        jmp     NameLoop

done2:
// Restore everything.
        popad         
      }

      if ( szLongName[0] )
      {
        // Move beyond Intel's leading spaces. 
        for (psz = &szLongName[0]; *psz ==  ' '; psz++);

        if (*psz)
        {
#ifdef UNICODE
          MultiByteToWideChar(CP_ACP, 0, psz, -1, pszLongName, 50);
#else
          strcpy(pszLongName, psz);
#endif
          //  4/29/01(RichGr): Intel Brand Strings show the maximum rated CPU Speed, no need for further detection.
          if ( !lstrcmp(pszVendorName, TEXT("Intel")))
            *pbNoCPUSpeed = FALSE;  
        }
      }
    }
#endif  // _X86_
}


#ifdef _X86_

// Some static variables used by GetCPUSpeed
static int s_milliseconds;
static __int64 s_ticks;

/****************************************************************************
 *
 *  fabs
 *
 ****************************************************************************/
FLOAT inline fabs(FLOAT a)
{
    if (a < 0.0f)
        return -a;
    else
        return a;
}


/****************************************************************************
 *
 *  StartTimingCPU
 *
 ****************************************************************************/
int StartTimingCPU( HANDLE& hProcess, DWORD& oldclass )
{
    //
    // detect ability to get info
    //

    //  4/03/2000(RichGr): The RDTSC instruction is crashing on some older Cyrix machines,
    //     so wrap a __try/__except around everything.
    __try
    { 
        __asm
        {
            pushfd                          ; push extended flags
            pop     eax                     ; store eflags into eax
            mov     ebx, eax                ; save EBX for testing later
            xor     eax, (1<<21)            ; switch bit 21
            push    eax                     ; push eflags
            popfd                           ; pop them again
            pushfd                          ; push extended flags
            pop     eax                     ; store eflags into eax
            cmp     eax, ebx                ; see if bit 21 has changed
            jz      no_cpuid                ; make sure it's now on
        }

        //
        // start timing
        //
        // 10/31/99(RichGr): Bump up the priority to real-time, drawing from ToddLa's code.
        //     See  file:\\pyrex\user\toddla\speed.c
        hProcess = GetCurrentProcess();
        oldclass = GetPriorityClass(hProcess);
        SetPriorityClass(hProcess, REALTIME_PRIORITY_CLASS);
        Sleep(10);

        s_milliseconds = -(int)timeGetTime();

        __asm
        {
            lea     ecx, s_ticks            ; get the offset
            mov     dword ptr [ecx], 0      ; zero the memory
            mov     dword ptr [ecx+4], 0    ;
    //      rdtsc                           ; read time-stamp counter
            __emit 0fh 
            __emit 031h
            sub     [ecx], eax              ; store the negative
            sbb     [ecx+4], edx            ; in the variable
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        goto no_cpuid;
    }

    return 0;

no_cpuid:
// 10/31/99(RichGr): In case someone changes the code, make sure that the priority is restored
//     to normal if there is an error return.
    if ( hProcess && oldclass )
        SetPriorityClass( hProcess, oldclass );

    return -1;
}


/****************************************************************************
 *
 *  StopTimingCPU
 *
 ****************************************************************************/
void StopTimingCPU( HANDLE& hProcess, DWORD& oldclass )
{
    s_milliseconds      += (int)timeGetTime();

    __asm
    {
        lea     ecx, s_ticks            ; get the offset
//      rdtsc                           ; read time-stamp counter
        __emit 0fh 
        __emit 031h
        add     [ecx], eax              ; add the tick count
        adc     [ecx+4], edx            ;
    }

// 10/31/99(RichGr): Restore the priority to normal.
    if ( hProcess && oldclass )
        SetPriorityClass( hProcess, oldclass );

    return;
}


/****************************************************************************
 *
 *  CalcCPUSpeed
 *
 ****************************************************************************/
INT CalcCPUSpeed(VOID)
{
    //
    // get the actual cpu speed in MHz, and
    // then find the one in the CPU speed list
    // that is closest
    //
    const struct tagCPUSPEEDS
    {
        float   fSpeed;
        int     iSpeed;
    } cpu_speeds[] =
    {
        //
        // valid CPU speeds that are not integrally divisible by
        // 16.67 MHz
        //
        {  60.00f,   60 },
        {  75.00f,   75 },
        {  90.00f,   90 },
        { 120.00f,  120 },
        { 180.00f,  180 },
    };

    //
    // find the closest one
    //
    float   fSpeed=((float)s_ticks)/((float)s_milliseconds*1000.0f);
    int     iSpeed=cpu_speeds[0].iSpeed;
    float   fDiff=(float)fabs(fSpeed-cpu_speeds[0].fSpeed);

    for (int i=1 ; i<sizeof(cpu_speeds)/sizeof(cpu_speeds[0]) ; i++)
    {
        float fTmpDiff = (float)fabs(fSpeed-cpu_speeds[i].fSpeed);

        if (fTmpDiff < fDiff)
        {
            iSpeed=cpu_speeds[i].iSpeed;
            fDiff=fTmpDiff;
        }
    }

    //
    // now, calculate the nearest multiple of fIncr
    // speed
    //


    //
    // now, if the closest one is not within one incr, calculate
    // the nearest multiple of fIncr speed and see if that's
    // closer
    //
    const float fIncr=16.66666666666666666666667f;
    const int iIncr=4267; // fIncr << 8

    //if (fDiff > fIncr)
    {
        //
        // get the number of fIncr quantums the speed is
        //
        int     iQuantums       = (int)((fSpeed / fIncr) + 0.5f);
        float   fQuantumSpeed   = (float)iQuantums * fIncr;
        float   fTmpDiff        = (float)fabs(fQuantumSpeed - fSpeed);

        if (fTmpDiff < fDiff)
        {
            iSpeed = (iQuantums * iIncr) >> 8;
            fDiff=fTmpDiff;
        }
    }

    return iSpeed;
}


/****************************************************************************
 *
 *  GetCPUSpeed
 *
 ****************************************************************************/
INT GetCPUSpeed(VOID)
{   
    INT nCPUSpeed;

    // Try first using WMI - may not work on Win9x
    nCPUSpeed = GetCPUSpeedViaWMI();
    if( nCPUSpeed != -1 )
        return nCPUSpeed;
  
    // If WMI fails, then fall back on brute force cpu detection.
#undef  MAX_SAMPLES  
#define MAX_SAMPLES  10

    int     nSpeed = 0, nSpeeds[MAX_SAMPLES] = {0};
    int     nCount = 0, nCounts[MAX_SAMPLES] = {0};
    int     i, j;
    HANDLE  hProcess = NULL;
    DWORD   oldclass = 0;

    // 10/12/99(RichGr): Pick up the most frequently occurring speed in a number of short samples,
    //     instead of waiting once for a whole second (see DxDiag).
    for ( i = 0; i < MAX_SAMPLES; i++ )    
    {
        if ( !StartTimingCPU( hProcess, oldclass ))
        {
            // 10/21/99(RichGr): Sleep() time is important.  On a 266 MHz running Win98 under the kernel
            //     debugger, the original value of Sleep(10) sometimes gave a speed of 283 MHz.
            //     Sleep(5) to Sleep(30) were also unreliable.  Sleep(40) and Sleep(50) looked good,
            //     and I picked (50) for a little margin. 
            Sleep(50);       
            StopTimingCPU( hProcess, oldclass );
            nSpeed = CalcCPUSpeed();

            for ( j = 0; j < MAX_SAMPLES; j++ )
            {    
                if ( nSpeeds[j] == 0 || nSpeed == nSpeeds[j] )  // If the speed matches, increment the count.
                {
                    nSpeeds[j] = nSpeed;
                    nCounts[j]++;
                    break;
                }
            }
        }
    }

    // Find the speed with the biggest count.
    for ( i = j = 0, nCount = 0; i < MAX_SAMPLES; i++ )
    {
        if ( nCounts[i] > nCount )
        {
            nCount = nCounts[i];
            j = i;
        }
    }

    return nSpeeds[j];
}


/****************************************************************************
 *
 *  GetCPUSpeedViaWMI
 *
 ****************************************************************************/
INT GetCPUSpeedViaWMI(VOID)
{
    HRESULT hr;
    INT     nCPUSpeed = -1;

    IEnumWbemClassObject*   pEnumProcessorDevs  = NULL;
    IWbemClassObject*       pProcessorDev       = NULL;
    BSTR                    pClassName          = NULL;
    BSTR                    pPropName           = NULL;
    VARIANT                 var;
    DWORD                   uReturned           = 0;

    ZeroMemory( &var, sizeof(VARIANT) );
    VariantClear( &var );

    if( NULL == g_pIWbemServices )
        return -1;

    pClassName = SysAllocString( L"Win32_Processor" );
    hr = g_pIWbemServices->CreateInstanceEnum( pClassName, 0, NULL,
                                                             &pEnumProcessorDevs ); 
    if( FAILED(hr) || pEnumProcessorDevs == NULL )
        goto LCleanup;

    // Get the first one in the list
    hr = pEnumProcessorDevs->Next( 1000,             // timeout in two seconds
                                   1,                // return just one storage device
                                   &pProcessorDev,   // pointer to storage device
                                   &uReturned );     // number obtained: one or zero
    if( FAILED(hr) || uReturned == 0 || pProcessorDev == NULL )
        goto LCleanup;

    // 298510: MaxClockSpeed on WMI on Whistler & beyond works
    if( BIsWhistler() )
        pPropName = SysAllocString( L"MaxClockSpeed" );
    else
        pPropName = SysAllocString( L"CurrentClockSpeed" );

    hr = pProcessorDev->Get( pPropName, 0L, &var, NULL, NULL );
    if( FAILED(hr) )
        goto LCleanup;

    // Success - record VT_I4 value in nCPUSpeed
    nCPUSpeed = var.lVal;

LCleanup:
    VariantClear( &var );

    if(pPropName)
        SysFreeString(pPropName);
    if(pClassName)
        SysFreeString(pClassName);

    if(pProcessorDev)
        pProcessorDev->Release(); 
    if(pEnumProcessorDevs)
        pEnumProcessorDevs->Release(); 

    // Return either -1 or the CPU speed we found.
    return nCPUSpeed;
}

#endif  // _X86_


/****************************************************************************
 *
 *  GetComputerSystemInfo
 *
 ****************************************************************************/
VOID GetComputerSystemInfo(TCHAR* szSystemManufacturerEnglish, TCHAR* szSystemModelEnglish)
{
    HRESULT hr;

    IEnumWbemClassObject*   pEnumDevices = NULL;
    IWbemClassObject*       pDevice      = NULL;
    BSTR                    pClassName   = NULL;
    BSTR                    pPropName    = NULL;
    DWORD                   uReturned    = 0;
    VARIANT                 var;

    ZeroMemory( &var, sizeof(VARIANT) );
    VariantClear( &var );

    if( NULL == g_pIWbemServices )
        goto LCleanup;

    pClassName = SysAllocString( L"Win32_ComputerSystem" );
    hr = g_pIWbemServices->CreateInstanceEnum( pClassName, 0, NULL,
                                               &pEnumDevices ); 
    if( FAILED(hr) || pEnumDevices == NULL )
        goto LCleanup;

    // Get the first one in the list
    hr = pEnumDevices->Next( 1000,             // timeout in two seconds
                            1,                // return just one storage device
                            &pDevice,          // pointer to storage device
                            &uReturned );     // number obtained: one or zero
    if( FAILED(hr) || uReturned == 0 || pDevice == NULL )
        goto LCleanup;

    pPropName = SysAllocString( L"Manufacturer" );
    hr = pDevice->Get( pPropName, 0L, &var, NULL, NULL );
    if( FAILED(hr) )
        goto LCleanup;
    if(pPropName)
    {
        SysFreeString(pPropName);
        pPropName = NULL;
    }
    if( var.bstrVal != NULL )
    {
#ifdef UNICODE
        lstrcpy(szSystemManufacturerEnglish, var.bstrVal);
#else
        WideCharToMultiByte(CP_ACP, 0, var.bstrVal, SysStringLen(var.bstrVal), szSystemManufacturerEnglish, 199, NULL, NULL);
#endif
    }
  
    VariantClear( &var );

    pPropName = SysAllocString( L"Model" );
    hr = pDevice->Get( pPropName, 0L, &var, NULL, NULL );
    if( FAILED(hr) )
        goto LCleanup;
    if(pPropName)
    {
        SysFreeString(pPropName);
        pPropName = NULL;
    }
    if( var.bstrVal != NULL )
    {
#ifdef UNICODE
        lstrcpy(szSystemModelEnglish, var.bstrVal);
#else
        WideCharToMultiByte(CP_ACP, 0, var.bstrVal, SysStringLen(var.bstrVal), szSystemModelEnglish, 199, NULL, NULL);
#endif
    }

    VariantClear( &var );

LCleanup:

    if( NULL == szSystemModelEnglish )
        lstrcpy( szSystemModelEnglish, TEXT("n/a") );
    if( NULL == szSystemManufacturerEnglish )
        lstrcpy( szSystemManufacturerEnglish, TEXT("n/a") );

    if(pPropName)
        SysFreeString(pPropName);
    if(pClassName)
        SysFreeString(pClassName);

    if(pDevice)
        pDevice->Release(); 
    if(pEnumDevices)
        pEnumDevices->Release(); 

    return;
}




/****************************************************************************
 *
 *  GetBIOSInfo
 *
 ****************************************************************************/
VOID GetBIOSInfo(TCHAR* szBIOSEnglish)
{
    HRESULT hr;

    IEnumWbemClassObject*   pEnumDevices = NULL;
    IWbemClassObject*       pDevice      = NULL;
    BSTR                    pClassName   = NULL;
    BSTR                    pPropName    = NULL;
    DWORD                   uReturned    = 0;
    VARIANT                 var;

    ZeroMemory( &var, sizeof(VARIANT) );
    VariantClear( &var );

    if( NULL == g_pIWbemServices )
        goto LCleanup;

    pClassName = SysAllocString( L"Win32_BIOS" );
    hr = g_pIWbemServices->CreateInstanceEnum( pClassName, 0, NULL,
                                               &pEnumDevices ); 
    if( FAILED(hr) || pEnumDevices == NULL )
        goto LCleanup;

    // Get the first one in the list
    hr = pEnumDevices->Next( 1000,             // timeout in two seconds
                            1,                // return just one storage device
                            &pDevice,          // pointer to storage device
                            &uReturned );     // number obtained: one or zero
    if( FAILED(hr) || uReturned == 0 || pDevice == NULL )
        goto LCleanup;

    pPropName = SysAllocString( L"Version" );
    hr = pDevice->Get( pPropName, 0L, &var, NULL, NULL );
    if( FAILED(hr) )
        goto LCleanup;
    if( var.bstrVal != NULL )
    {
#ifdef UNICODE
        lstrcpy(szBIOSEnglish, var.bstrVal);
#else
        WideCharToMultiByte(CP_ACP, 0, var.bstrVal, SysStringLen(var.bstrVal), szBIOSEnglish, 199, NULL, NULL);
#endif
    }

    VariantClear( &var );

LCleanup:

    if( NULL == szBIOSEnglish )
        lstrcpy( szBIOSEnglish, TEXT("n/a") );
 
    if(pPropName)
        SysFreeString(pPropName);
    if(pClassName)
        SysFreeString(pClassName);

    if(pDevice)
        pDevice->Release(); 
    if(pEnumDevices)
        pEnumDevices->Release(); 

    return;
}




/****************************************************************************
 *
 *  GetDXDebugLevels
 *
 ****************************************************************************/
VOID GetDXDebugLevels(SysInfo* pSysInfo)
{
    pSysInfo->m_bIsD3D8DebugRuntimeAvailable      = IsD3D8DebugRuntimeAvailable();
    pSysInfo->m_bIsD3DDebugRuntime                = IsD3DDebugRuntime();
    pSysInfo->m_bIsDInput8DebugRuntimeAvailable   = IsDInput8DebugRuntimeAvailable();
    pSysInfo->m_bIsDInput8DebugRuntime            = IsDInput8DebugRuntime();
    pSysInfo->m_bIsDMusicDebugRuntimeAvailable    = IsDMusicDebugRuntimeAvailable();
    pSysInfo->m_bIsDMusicDebugRuntime             = IsDMusicDebugRuntime();
    pSysInfo->m_bIsDDrawDebugRuntime              = IsDDrawDebugRuntime();
    pSysInfo->m_bIsDPlayDebugRuntime              = IsDPlayDebugRuntime();
    pSysInfo->m_bIsDSoundDebugRuntime             = IsDSoundDebugRuntime();

    pSysInfo->m_nD3DDebugLevel                    = (int) GetProfileInt(TEXT("Direct3D"), TEXT("debug"), 0);
    pSysInfo->m_nDDrawDebugLevel                  = (int) GetProfileInt(TEXT("DirectDraw"),TEXT("debug"), 0);
    pSysInfo->m_nDIDebugLevel                     = GetDIDebugLevel();
    pSysInfo->m_nDMusicDebugLevel                 = GetDMDebugLevel();
    pSysInfo->m_nDPlayDebugLevel                  = (int) GetProfileInt(TEXT("DirectPlay"), TEXT("Debug"), 0);
    pSysInfo->m_nDSoundDebugLevel                 = GetDSDebugLevel();
}




/****************************************************************************
 *
 *  IsD3D8DebugRuntimeAvailable
 *
 ****************************************************************************/
BOOL IsD3D8DebugRuntimeAvailable()
{
    TCHAR szPath[MAX_PATH];

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\d3d8d.dll"));

    if (GetFileAttributes(szPath) != -1)
        return TRUE;
    else 
        return FALSE;
}




/****************************************************************************
 *
 *  IsD3DDebugRuntime
 *
 ****************************************************************************/
BOOL IsD3DDebugRuntime()
{
    DWORD   size;
    DWORD   type;
    DWORD   lData;
    HKEY    hkey;
    BOOL    rc;

    rc = FALSE;
    if (!RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_D3D, &hkey))
    {
        size = sizeof(DWORD);
        if (!RegQueryValueEx(hkey, REGSTR_VAL_DDRAW_LOADDEBUGRUNTIME, NULL, &type, (LPBYTE)&lData, &size))
            if (lData)
                rc = TRUE;
        RegCloseKey(hkey);
    }
    return rc;
}




/****************************************************************************
 *
 *  GetDIDebugLevel
 *
 ****************************************************************************/
int GetDIDebugLevel()
{
    DWORD dwDebugBits;
    DWORD dwDebugBitsMax;
    LONG iGenerator;

    dwDebugBitsMax = 0;
    dwDebugBits = GetProfileInt(TEXT("Debug"), TEXT("dinput"), 0);
    if (dwDebugBits > dwDebugBitsMax)
        dwDebugBitsMax = dwDebugBits;

    enum 
    {
        GENERATOR_KBD = 0,    
        GENERATOR_MOUSE,
        GENERATOR_JOY,    
        GENERATOR_HID,    
        GENERATOR_MAX
    };

    static TCHAR* szGeneratorNames[] = 
    {
        TEXT("DInput.06"),
        TEXT("DInput.04"),
        TEXT("DInput.08"),
        TEXT("DInput.17"),
    };

    static BOOL bGeneratorArray[4];

    for (iGenerator = 0; iGenerator < GENERATOR_MAX; iGenerator++)
    {
        dwDebugBits = GetProfileInt(TEXT("Debug"), szGeneratorNames[iGenerator], 0);
        bGeneratorArray[iGenerator] = (dwDebugBits > 0);
        if (dwDebugBits > dwDebugBitsMax)
            dwDebugBitsMax = dwDebugBits;
    }

    if (dwDebugBitsMax & 0x20) // verbose
        return 5;
    if (dwDebugBitsMax & 0x02) // function entry
        return 4;
    if (dwDebugBitsMax & 0x01) // trace
        return 3;
    if (dwDebugBitsMax & 0x08) // benign
        return 2;
    if (dwDebugBitsMax & 0x10) // severe
        return 1;
    return 0;
}




/****************************************************************************
 *
 *  IsDInput8DebugRuntimeAvailable
 *
 ****************************************************************************/
BOOL IsDInput8DebugRuntimeAvailable()
{
    TCHAR szPath[MAX_PATH];

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\dinput8d.dll"));

    if (GetFileAttributes(szPath) != -1)
        return TRUE;
    else 
        return FALSE;
}




/****************************************************************************
 *
 *  IsDInput8DebugRuntime
 *
 ****************************************************************************/
BOOL IsDInput8DebugRuntime()
{
    DWORD   size;
    DWORD   type;
    TCHAR   szData[MAX_PATH];
    HKEY    hkey;
    BOOL    rc;

    rc = FALSE;
    if (!RegOpenKey(HKEY_CLASSES_ROOT, REGSTR_DINPUT_DLL, &hkey))
    {
        size = sizeof(szData);
        if (!RegQueryValueEx(hkey, NULL, NULL, &type, (LPBYTE)&szData, &size))
        {
            if (_tcsstr(szData, TEXT("dinput8d.dll")))
                rc = TRUE;
        }
        RegCloseKey(hkey);
    }
    return rc;
}




/****************************************************************************
 *
 *  GetDMDebugLevel
 *
 ****************************************************************************/
int GetDMDebugLevel()
{
    DWORD dwDMusicDebugLevel = 0;
    DWORD dw;

    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMBAND"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMCOMPOS"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMIME"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMLOADER"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMUSIC"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMUSIC16"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMUSIC32"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMSTYLE"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMSYNTH"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMSCRIPT"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DSWAVE"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;

    return dwDMusicDebugLevel;
}




/****************************************************************************
 *
 *  IsDMusicDebugRuntimeAvailable
 *
 ****************************************************************************/
BOOL IsDMusicDebugRuntimeAvailable()
{
    TCHAR szPath[MAX_PATH];

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\dmusicd.dll"));

    if (GetFileAttributes(szPath) != -1)
        return TRUE;
    else 
        return FALSE;
}




/****************************************************************************
 *
 *  IsDMusicDebugRuntime
 *
 ****************************************************************************/
BOOL IsDMusicDebugRuntime()
{
    DWORD   size;
    DWORD   type;
    TCHAR   szData[MAX_PATH];
    HKEY    hkey;
    BOOL    rc;

    rc = FALSE;
    if (!RegOpenKey(HKEY_CLASSES_ROOT, REGSTR_DMUSIC_DLL, &hkey))
    {
        size = sizeof(szData);
        if (!RegQueryValueEx(hkey, NULL, NULL, &type, (LPBYTE)&szData, &size))
        {
            if (_tcsstr(szData, TEXT("dmusicd.dll")) ||
                _tcsstr(szData, TEXT("DMUSICD.DLL")))
            {
                rc = TRUE;
            }
        }
        RegCloseKey(hkey);
    }
    return rc;
}




/****************************************************************************
 *
 *  GetDSDebugLevel
 *
 ****************************************************************************/
int GetDSDebugLevel()
{
    DWORD dwSoundLevel = 0;

    // Pick up the DMusic DLL debug settings that are controlled on the
    // DSound page
    HRESULT hr;
    HINSTANCE hinst;
    LPKSPROPERTYSET pksps = NULL;
    hinst = LoadLibrary(TEXT("dsound.dll"));
    if (hinst != NULL)
    {
        if (SUCCEEDED(hr = DirectSoundPrivateCreate(&pksps)))
        {
            hr = PrvGetDebugInformation(pksps, NULL, &dwSoundLevel, NULL, NULL);
            pksps->Release();
        }
        FreeLibrary(hinst);
    }

    return dwSoundLevel;
}



/****************************************************************************
 *
 *  IsFileDebug
 *
 ****************************************************************************/
BOOL IsFileDebug( TCHAR* szPath )
{
    UINT cb;
    DWORD dwHandle;
    BYTE FileVersionBuffer[4096];
    VS_FIXEDFILEINFO* pVersion = NULL;

    cb = GetFileVersionInfoSize(szPath, &dwHandle/*ignored*/);
    if (cb > 0)
    {
        if (cb > sizeof(FileVersionBuffer))
            cb = sizeof(FileVersionBuffer);

        if(GetFileVersionInfo(szPath, 0, cb, &FileVersionBuffer))
        {
            if(VerQueryValue(&FileVersionBuffer, TEXT("\\"), (VOID**)&pVersion, &cb))
            {
                if( pVersion )
                {
                    if( pVersion->dwFileFlags & VS_FF_DEBUG )
                        return TRUE;
                    else 
                        return FALSE;
                }
            }
        }
    }

    return FALSE;
}



/****************************************************************************
 *
 *  IsDDrawDebugRuntime
 *
 ****************************************************************************/
BOOL IsDDrawDebugRuntime()
{
    TCHAR szPath[MAX_PATH];

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\ddraw.dll"));

    return IsFileDebug(szPath);
}



/****************************************************************************
 *
 *  IsDPlayDebugRuntime
 *
 ****************************************************************************/
BOOL IsDPlayDebugRuntime()
{
    TCHAR szPath[MAX_PATH];

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\dpnet.dll"));

    return IsFileDebug(szPath);
}



/****************************************************************************
 *
 *  IsDSoundDebugRuntime
 *
 ****************************************************************************/
BOOL IsDSoundDebugRuntime()
{
    TCHAR szPath[MAX_PATH];

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\dsound.dll"));

    return IsFileDebug(szPath);
}



/****************************************************************************
 *
 *  BIsDxDiag64Bit
 *
 ****************************************************************************/
BOOL BIsDxDiag64Bit(VOID)
{
#ifdef _WIN64
    return TRUE;
#else
    return FALSE;
#endif
}



/****************************************************************************
 *
 *  GetFileSystemStoringD3D8Cache
 *
 ****************************************************************************/
VOID GetFileSystemStoringD3D8Cache( TCHAR* strFileSystemBuffer )
{
    TCHAR strPath[MAX_PATH + 16];
    BOOL bFound = FALSE;
    
    GetSystemDirectory( strPath, MAX_PATH);   
    lstrcat( strPath, TEXT("\\d3d8caps.dat") );
    
    if (GetFileAttributes(strPath) != 0xffffffff)
        bFound = TRUE;

    if( !bFound && BIsPlatformNT() )
    {
        // stolen from \dxg\d3d8\fw\fcache.cpp, OpenCacheFile().
        HMODULE hShlwapi = NULL;
        typedef HRESULT (WINAPI * PSHGETSPECIALFOLDERPATH) (HWND, LPTSTR, int, BOOL);
        PSHGETSPECIALFOLDERPATH pSHGetSpecialFolderPath = NULL;
        
        hShlwapi = LoadLibrary( TEXT("SHELL32.DLL") );
        if( NULL != hShlwapi )
        {
#ifdef UNICODE
            pSHGetSpecialFolderPath = (PSHGETSPECIALFOLDERPATH) 
                GetProcAddress(hShlwapi,"SHGetSpecialFolderPathW");
#else
            pSHGetSpecialFolderPath = (PSHGETSPECIALFOLDERPATH) 
                GetProcAddress(hShlwapi,"SHGetSpecialFolderPathA");
#endif
            
            if(pSHGetSpecialFolderPath)
            {
                HRESULT hr;

                // <user name>\Local Settings\Applicaiton Data (non roaming)
                hr = pSHGetSpecialFolderPath( NULL, strPath,
                                              CSIDL_LOCAL_APPDATA,          
                                              FALSE );
                if( SUCCEEDED(hr) )
                {
                    lstrcat( strPath, TEXT("\\d3d8caps.dat") );

                    if (GetFileAttributes(strPath) != 0xffffffff)
                        bFound = TRUE;
                }
            }
            FreeLibrary(hShlwapi);
        }
    }

    if( bFound )
    {
        DWORD dwVolumeSerialNumber;
        DWORD dwMaxComponentLength;
        DWORD dwFileSystemFlags;

        // Trim to root dir -- "x:\"
        strPath[3] = 0;

        BOOL bSuccess = GetVolumeInformation( strPath, NULL, 0, &dwVolumeSerialNumber, 
                              &dwMaxComponentLength, &dwFileSystemFlags, 
                              strFileSystemBuffer, MAX_PATH );
        if( !bSuccess )
            lstrcpy( strFileSystemBuffer, TEXT("Unknown") );
    }
    else
    {
        lstrcpy( strFileSystemBuffer, TEXT("n/a") );
    }
    
    return;
}



/****************************************************************************
 *
 *  IsNetMeetingRunning
 *
 ****************************************************************************/
BOOL IsNetMeetingRunning()
{
    HWND hNetMeeting = FindWindow( TEXT("MPWClass"), NULL );

    return( hNetMeeting != NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\testagp.cpp ===
/****************************************************************************
 *
 *    File: testagp.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Jason Sandlin (jasonsa@microsoft.com)
 * Purpose: Test AGP Texturing functionality on this machine
 *
 * (C) Copyright 2000 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <Windows.h>
#define DIRECTDRAW_VERSION 0x0700 // run on DX7 and later versions
#include <ddraw.h>
#define DIRECT3D_VERSION 0x0700 // run on DX7 and later versions
#define D3D_OVERLOADS
#include <d3d.h>
#include "reginfo.h"
#include "sysinfo.h"
#include "dispinfo.h"
#include "testagp.h"
#include "resource.h"

#ifndef ReleasePpo
    #define ReleasePpo(ppo) \
        if (*(ppo) != NULL) \
        { \
            (*(ppo))->Release(); \
            *(ppo) = NULL; \
        } \
        else (VOID)0
#endif

enum TESTID
{
    TESTID_LOAD_D3D8_DLL=1,
    TESTID_GET_D3DCREATE8,
    TESTID_D3DCREATE8,
    TESTID_ENUMADAPTERMODES,
    TESTID_GETDEVICECAPS,
    TESTID_NOMODEFOUND,
    TESTID_CREATE_TEST_WINDOW,
    TESTID_CREATE_DEVICE,
    TESTID_GETBACKBUFFER,
    TESTID_GETDESC,
    TESTID_CREATE_VERTEX_BUFFER,
    TESTID_CREATE_INDEX_BUFFER,
    TESTID_LOCK,
    TESTID_UNLOCK,
    TESTID_SETLIGHT,
    TESTID_LIGHTENABLE,
    TESTID_SETTRANSFORM,
    TESTID_SETRENDERSTATE,
    TESTID_CREATETEXTURE,
    TESTID_SETTEXTURESTAGESTATE,
    TESTID_SETTEXTURE,
    TESTID_SETVERTEXSHADER,
    TESTID_USER_CANCELLED,
    TESTID_VIEWPORT_CLEAR,
    TESTID_BEGINSCENE,
    TESTID_SETMATERIAL,
    TESTID_SETSTREAMSOURCE,
    TESTID_SETINDICES,
    TESTID_DRAW_INDEXED_PRIMITIVE,
    TESTID_ENDSCENE,
    TESTID_PRESENT,
    TESTID_USER_VERIFY_D3D7_RENDERING,
    TESTID_USER_VERIFY_D3D8_RENDERING,
    TESTID_LOAD_DDRAW_DLL,
    TESTID_GET_DIRECTDRAWCREATE,
    TESTID_DIRECTDRAWCREATE,
    TESTID_SETCOOPERATIVELEVEL_FULLSCREEN,
    TESTID_SETCOOPERATIVELEVEL_NORMAL,
    TESTID_SETDISPLAYMODE,
    TESTID_CREATEPRIMARYSURFACE_FLIP_ONEBACK,
    TESTID_GETATTACHEDSURFACE,
    TESTID_QUERY_D3D,
    TESTID_SETVIEWPORT,
    TESTID_ENUMTEXTUREFORMATS,
    TESTID_CREATESURFACE,
    TESTID_GETDC,
    TESTID_RELEASEDC,
};

BOOL BTranslateError(HRESULT hr, TCHAR* psz, BOOL bEnglish = FALSE); // from main.cpp (yuck)

typedef HRESULT (WINAPI* LPDIRECTDRAWCREATEEX)(GUID FAR * lpGuid, LPVOID *lplpDD, REFIID iid,IUnknown FAR *pUnkOuter );

static HRESULT Test3D(BOOL bUseTexture, HWND hwndMain, LPDIRECTDRAW7 pdd, GUID guid3DDevice, LONG* piStepThatFailed);
static HRESULT CreateTestWindow(HWND hwndMain, HWND* phwnd);
static HRESULT D3DUtil_SetProjectionMatrix( D3DMATRIX& mat, FLOAT fFOV, FLOAT fAspect, FLOAT fNearPlane, FLOAT fFarPlane );

static HRESULT CreateTexture( LPDIRECTDRAWSURFACE7* ppdds, LPDIRECTDRAW7 pdd, LPDIRECT3DDEVICE7 pd3dDevice, TCHAR* strName, LONG* piStepThatFailed);
static HRESULT CALLBACK TextureSearchCallback( DDPIXELFORMAT* pddpf, VOID* param );

/****************************************************************************
 *
 *  TestAGP
 *
 ****************************************************************************/
VOID TestD3Dv7(BOOL bUseTexture, HWND hwndMain, DisplayInfo* pDisplayInfo)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];
    HINSTANCE hInstDDraw = NULL;
    LPDIRECTDRAWCREATEEX pDDCreateEx = NULL;
    LPDIRECTDRAW7 pdd = NULL;
    BOOL bTestHardwareRendering = FALSE;
    TCHAR sz[300];
    TCHAR szTitle[100];

    if( pDisplayInfo == NULL )
        return;

    LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);

    // Load ddraw.dll
    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\ddraw.dll"));
    hInstDDraw = LoadLibrary(szPath);
    if (hInstDDraw == NULL)
    {
        pDisplayInfo->m_testResultD3D7.m_iStepThatFailed = TESTID_LOAD_DDRAW_DLL;
        pDisplayInfo->m_testResultD3D7.m_hr = DDERR_NOTFOUND;
        goto LEnd;
    }

    // Get DirectDrawCreate entry point
    pDDCreateEx = (LPDIRECTDRAWCREATEEX)GetProcAddress(hInstDDraw, "DirectDrawCreateEx");
    if (pDDCreateEx == NULL)
    {
        pDisplayInfo->m_testResultD3D7.m_iStepThatFailed = TESTID_GET_DIRECTDRAWCREATE;
        pDisplayInfo->m_testResultD3D7.m_hr = DDERR_NOTFOUND;
        goto LEnd;
    }
        
    // Call DirectDrawCreateEx
    if (FAILED(hr = pDDCreateEx(&pDisplayInfo->m_guid, (void**)&pdd, IID_IDirectDraw7, NULL)))
    {
        pDisplayInfo->m_testResultD3D7.m_iStepThatFailed = TESTID_DIRECTDRAWCREATE;
        pDisplayInfo->m_testResultD3D7.m_hr = hr;
        goto LEnd;
    }

    // Get DirectDraw caps
    DDCAPS ddcapsHAL;
    DDCAPS ddcapsHEL;
    ddcapsHAL.dwSize = sizeof(ddcapsHAL);
    ddcapsHEL.dwSize = sizeof(ddcapsHEL);
    if (FAILED(hr = pdd->GetCaps(&ddcapsHAL, &ddcapsHEL)))
    {
        pDisplayInfo->m_testResultD3D7.m_iStepThatFailed = TESTID_GETDEVICECAPS;
        pDisplayInfo->m_testResultD3D7.m_hr = hr;
        goto LEnd;
    }

    POINT ptMouse;
    GetCursorPos(&ptMouse);
    if (FAILED(hr = Test3D(bUseTexture, hwndMain, pdd, IID_IDirect3DHALDevice, &pDisplayInfo->m_testResultD3D7.m_iStepThatFailed)))
    {
        pDisplayInfo->m_testResultD3D7.m_hr = hr;
        goto LEnd;
    }
    SetCursorPos( ptMouse.x, ptMouse.y );
    ReleasePpo(&pdd);

    if (pDisplayInfo->m_testResultD3D7.m_iStepThatFailed == TESTID_USER_CANCELLED)
    {
        LoadString(NULL, IDS_YOUCANCELLED, sz, 300);
        MessageBox(hwndMain, sz, szTitle, MB_OK);
        pDisplayInfo->m_testResultD3D7.m_bCancelled = TRUE;
        goto LEnd;
    }

    LoadString(NULL, IDS_CONFIRMD3DTEST, sz, 300);
    if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
    {
        pDisplayInfo->m_testResultD3D7.m_iStepThatFailed = TESTID_USER_VERIFY_D3D7_RENDERING;
        pDisplayInfo->m_testResultD3D7.m_hr = S_OK;
        goto LEnd;
    }

LEnd:
    ReleasePpo(&pdd);
    if (hInstDDraw != NULL)
        FreeLibrary(hInstDDraw);
}



/****************************************************************************
 *
 *  Test3D - Generate a spinning 3D cube
 *
 ****************************************************************************/
HRESULT Test3D(BOOL bUseTexture, HWND hwndMain, LPDIRECTDRAW7 pdd, GUID guid3DDevice, LONG* piStepThatFailed)
{
    HRESULT                 hr;
    HWND                    hwnd                    = NULL;
    LPDIRECTDRAWSURFACE7    pddsFront               = NULL;
    LPDIRECTDRAWSURFACE7    pddsBack                = NULL;
    LPDIRECT3D7             pd3d                    = NULL;
    LPDIRECT3DDEVICE7       pd3ddev                 = NULL;
    LPDIRECT3DLIGHT         pLight                  = NULL;
    LPDIRECTDRAWSURFACE7    pddsTexture             = NULL;
    BOOL                    bCooperativeLevelSet    = FALSE;
    BOOL                    bDisplayModeSet         = FALSE;
    DDSURFACEDESC2          ddsd;
    D3DDEVICEDESC7          ddDesc;
    DDSCAPS2                ddscaps;
    D3DVIEWPORT7            vp;
    D3DLIGHT7               lightdata;
    D3DMATRIX               mat;
    D3DMATRIX               matRotY;
    D3DMATRIX               matRotX;
    RECT                    rcBack;
    DWORD                   dwWidth;
    DWORD                   dwHeight;
    FLOAT                   fRotY;
    FLOAT                   fRotX;
    INT                     i;

    static const D3DVERTEX vertexArrayFront[] = 
    {
        D3DVERTEX(D3DVECTOR(-1.0, -1.0, -1.0), D3DVECTOR(0.0, 0.0, -1.0),   1.0f, 0.0f),
        D3DVERTEX(D3DVECTOR( 1.0, -1.0, -1.0), D3DVECTOR(0.0, 0.0, -1.0),   0.0f, 0.0f),
        D3DVERTEX(D3DVECTOR(-1.0,  1.0, -1.0), D3DVECTOR(0.0, 0.0, -1.0),   1.0f, 1.0f),
        D3DVERTEX(D3DVECTOR( 1.0,  1.0, -1.0), D3DVECTOR(0.0, 0.0, -1.0),   0.0f, 1.0f),
    };
    static const WORD indexArrayFront[] = 
    {
        0, 2, 1,
        2, 3, 1,
    };

    static const D3DVERTEX vertexArrayBack[] = 
    {
        D3DVERTEX(D3DVECTOR(-1.0, -1.0, 1.0),  D3DVECTOR(0.0, 0.0, 1.0),   0.0f, 0.0f),
        D3DVERTEX(D3DVECTOR( 1.0, -1.0, 1.0),  D3DVECTOR(0.0, 0.0, 1.0),   1.0f, 0.0f),
        D3DVERTEX(D3DVECTOR(-1.0,  1.0, 1.0),  D3DVECTOR(0.0, 0.0, 1.0),   0.0f, 1.0f),
        D3DVERTEX(D3DVECTOR( 1.0,  1.0, 1.0),  D3DVECTOR(0.0, 0.0, 1.0),   1.0f, 1.0f),
    };
    static const WORD indexArrayBack[] = 
    {
        0, 1, 2,
        2, 1, 3,
    };

    static const D3DVERTEX vertexArrayLeft[] = 
    {
        D3DVERTEX(D3DVECTOR(-1.0, -1.0, -1.0),  D3DVECTOR(-1.0, 0.0, 0.0),   0.0f, 0.0f),
        D3DVERTEX(D3DVECTOR(-1.0, -1.0,  1.0),  D3DVECTOR(-1.0, 0.0, 0.0),   1.0f, 0.0f),
        D3DVERTEX(D3DVECTOR(-1.0,  1.0, -1.0),  D3DVECTOR(-1.0, 0.0, 0.0),   0.0f, 1.0f),
        D3DVERTEX(D3DVECTOR(-1.0,  1.0,  1.0),  D3DVECTOR(-1.0, 0.0, 0.0),   1.0f, 1.0f),
    };
    static const WORD indexArrayLeft[] = 
    {
        0, 1, 2,
        2, 1, 3,
    };

    static const D3DVERTEX vertexArrayRight[] = 
    {
        D3DVERTEX(D3DVECTOR(1.0, -1.0, -1.0),  D3DVECTOR(1.0, 0.0, 0.0),   1.0f, 0.0f),
        D3DVERTEX(D3DVECTOR(1.0, -1.0,  1.0),  D3DVECTOR(1.0, 0.0, 0.0),   0.0f, 0.0f),
        D3DVERTEX(D3DVECTOR(1.0,  1.0, -1.0),  D3DVECTOR(1.0, 0.0, 0.0),   1.0f, 1.0f),
        D3DVERTEX(D3DVECTOR(1.0,  1.0,  1.0),  D3DVECTOR(1.0, 0.0, 0.0),   0.0f, 1.0f),
    };
    static const WORD indexArrayRight[] = 
    {
        0, 2, 1,
        2, 3, 1,
    };

    static const D3DVERTEX vertexArrayTop[] = 
    {
        D3DVERTEX(D3DVECTOR(-1.0, 1.0, -1.0),  D3DVECTOR(0.0, 1.0, 0.0),   0.0f, 1.0f),
        D3DVERTEX(D3DVECTOR( 1.0, 1.0, -1.0),  D3DVECTOR(0.0, 1.0, 0.0),   1.0f, 1.0f),
        D3DVERTEX(D3DVECTOR(-1.0, 1.0,  1.0),  D3DVECTOR(0.0, 1.0, 0.0),   0.0f, 0.0f),
        D3DVERTEX(D3DVECTOR( 1.0, 1.0,  1.0),  D3DVECTOR(0.0, 1.0, 0.0),   1.0f, 0.0f),
    };
    static const WORD indexArrayTop[] = 
    {
        0, 2, 1,
        2, 3, 1,
    };

    static const D3DVERTEX vertexArrayBottom[] = 
    {
        D3DVERTEX(D3DVECTOR(-1.0, -1.0, -1.0),  D3DVECTOR(0.0, -1.0, 0.0),   1.0f, 1.0f),
        D3DVERTEX(D3DVECTOR( 1.0, -1.0, -1.0),  D3DVECTOR(0.0, -1.0, 0.0),   0.0f, 1.0f),
        D3DVERTEX(D3DVECTOR(-1.0, -1.0,  1.0),  D3DVECTOR(0.0, -1.0, 0.0),   1.0f, 0.0f),
        D3DVERTEX(D3DVECTOR( 1.0, -1.0,  1.0),  D3DVECTOR(0.0, -1.0, 0.0),   0.0f, 0.0f),
    };
    static const WORD indexArrayBottom[] = 
    {
        0, 1, 2,
        2, 1, 3,
    };

    D3DMATERIAL7 mtrlRed;
    ZeroMemory( &mtrlRed, sizeof(D3DMATERIAL7) );
    mtrlRed.dcvDiffuse.r = mtrlRed.dcvAmbient.r = 1.0f;
    mtrlRed.dcvDiffuse.g = mtrlRed.dcvAmbient.g = 0.0f;
    mtrlRed.dcvDiffuse.b = mtrlRed.dcvAmbient.b = 0.0f;
    mtrlRed.dcvDiffuse.a = mtrlRed.dcvAmbient.a = 1.0f;

    D3DMATERIAL7 mtrlGreen;
    ZeroMemory( &mtrlGreen, sizeof(D3DMATERIAL7) );
    mtrlGreen.dcvDiffuse.r = mtrlGreen.dcvAmbient.r = 0.0f;
    mtrlGreen.dcvDiffuse.g = mtrlGreen.dcvAmbient.g = 1.0f;
    mtrlGreen.dcvDiffuse.b = mtrlGreen.dcvAmbient.b = 0.0f;
    mtrlGreen.dcvDiffuse.a = mtrlGreen.dcvAmbient.a = 1.0f;

    D3DMATERIAL7 mtrlBlue;
    ZeroMemory( &mtrlBlue, sizeof(D3DMATERIAL7) );
    mtrlBlue.dcvDiffuse.r = mtrlBlue.dcvAmbient.r = 0.0f;
    mtrlBlue.dcvDiffuse.g = mtrlBlue.dcvAmbient.g = 0.0f;
    mtrlBlue.dcvDiffuse.b = mtrlBlue.dcvAmbient.b = 1.0f;
    mtrlBlue.dcvDiffuse.a = mtrlBlue.dcvAmbient.a = 1.0f;

    ShowCursor(FALSE);

    // Create test window
    if (FAILED(hr = CreateTestWindow(hwndMain, &hwnd)))
    {
        *piStepThatFailed = TESTID_CREATE_TEST_WINDOW;
        goto LEnd;
    }

    // Set cooperative level
    if (FAILED(hr = pdd->SetCooperativeLevel(hwnd, 
        DDSCL_ALLOWREBOOT | DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN)))
    {
        *piStepThatFailed = TESTID_SETCOOPERATIVELEVEL_FULLSCREEN;
        goto LEnd;
    }
    bCooperativeLevelSet = TRUE;

    // Set display mode
    if (FAILED(hr = pdd->SetDisplayMode(640, 480, 16, 0, 0)))
    {
        TCHAR szMessage[300];
        TCHAR szTitle[100];
        pdd->SetCooperativeLevel(hwnd, DDSCL_NORMAL);
        bCooperativeLevelSet = FALSE;
        SendMessage(hwnd, WM_CLOSE, 0, 0);
        hwnd = NULL;
        LoadString(NULL, IDS_SETDISPLAYMODEFAILED, szMessage, 300);
        LoadString(NULL, IDS_APPFULLNAME, szTitle, 100);
        MessageBox(hwndMain, szMessage, szTitle, MB_OK);
        *piStepThatFailed = TESTID_SETDISPLAYMODE;
        goto LEnd;
    }
    bDisplayModeSet = TRUE;

    // Create front/back buffers
    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_FLIP | 
                          DDSCAPS_COMPLEX | DDSCAPS_3DDEVICE;
    ddsd.dwBackBufferCount = 1;
    if (FAILED(hr = pdd->CreateSurface(&ddsd, &pddsFront, NULL)))
    {
        *piStepThatFailed = TESTID_CREATEPRIMARYSURFACE_FLIP_ONEBACK;
        goto LEnd;
    }
    if( NULL == pddsFront )
    {
        *piStepThatFailed = TESTID_CREATEPRIMARYSURFACE_FLIP_ONEBACK;
        goto LEnd;
    }

    ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT;
    if (FAILED(hr = pddsFront->GetSurfaceDesc(&ddsd)))
    {
        *piStepThatFailed = TESTID_GETDESC;
        goto LEnd;
    }
    dwWidth  = ddsd.dwWidth;
    dwHeight = ddsd.dwHeight;
    SetRect(&rcBack, 0, 0, dwWidth, dwHeight);

    // Get ptr to back buffer
    ZeroMemory( &ddscaps, sizeof(ddscaps) ); 
    ddscaps.dwCaps = DDSCAPS_BACKBUFFER;
    if (FAILED(hr = pddsFront->GetAttachedSurface(&ddscaps, &pddsBack)))
    {
        *piStepThatFailed = TESTID_GETATTACHEDSURFACE;
        goto LEnd;
    }
    if( NULL == pddsBack )
    {
        *piStepThatFailed = TESTID_GETATTACHEDSURFACE;
        goto LEnd;
    }

    // Note: no Z-buffer is created...backface culling works for this test
    
    // Get D3D ptr
    if (FAILED(hr = pdd->QueryInterface(IID_IDirect3D7, (VOID**)&pd3d)))
    {
        *piStepThatFailed = TESTID_QUERY_D3D;
        goto LEnd;
    }
    if( NULL == pd3d )
    {
        *piStepThatFailed = TESTID_QUERY_D3D;
        goto LEnd;
    }

    // Create device
    if (FAILED(hr = pd3d->CreateDevice(guid3DDevice, pddsBack, &pd3ddev)))
    {
        *piStepThatFailed = TESTID_CREATE_DEVICE;
        goto LEnd;
    }
    if( NULL == pd3ddev )
    {
        *piStepThatFailed = TESTID_CREATE_DEVICE;
        goto LEnd;
    }

    // Set the viewport
    vp.dwX      = 0;
    vp.dwY      = 0;
    vp.dwWidth  = dwWidth;
    vp.dwHeight = dwHeight;
    vp.dvMinZ   = 0.0f;
    vp.dvMaxZ   = 1.0f;
    if (FAILED(hr = pd3ddev->SetViewport(&vp)))
    {
        *piStepThatFailed = TESTID_SETVIEWPORT;
        goto LEnd;
    }

    // Add a light
    ZeroMemory(&lightdata, sizeof(lightdata));
    lightdata.dltType = D3DLIGHT_DIRECTIONAL;
    lightdata.dcvDiffuse.r = 1.0f;
    lightdata.dcvDiffuse.g = 1.0f;
    lightdata.dcvDiffuse.b = 1.0f;
    lightdata.dvDirection.x = 0.0f;
    lightdata.dvDirection.y = 0.0f;
    lightdata.dvDirection.z = 1.0f;
    if (FAILED(hr = pd3ddev->SetLight( 0, &lightdata)))
    {
        *piStepThatFailed = TESTID_SETLIGHT;
        goto LEnd;
    }
    if (FAILED(hr = pd3ddev->LightEnable(0, TRUE)))
    {
        *piStepThatFailed = TESTID_LIGHTENABLE; 
        goto LEnd;
    }

    // Set up matrices
    mat = D3DMATRIX(1.0f, 0.0f, 0.0f, 0.0f,
                    0.0f, 1.0f, 0.0f, 0.0f,
                    0.0f, 0.0f, 1.0f, 0.0f,
                    0.0f, 0.0f, 0.0f, 1.0f);
    if (FAILED(hr = pd3ddev->SetTransform(D3DTRANSFORMSTATE_WORLD, &mat)))
    {
        *piStepThatFailed = TESTID_SETTRANSFORM;
        goto LEnd;
    }

    mat = D3DMATRIX(1.0f, 0.0f, 0.0f, 0.0f,
                      0.0f, 1.0f, 0.0f, 0.0f,
                      0.0f, 0.0f, 1.0f, 0.0f,
                      0.0f,  0.0f,  5.0f,  1.0f);
    if (FAILED(hr = pd3ddev->SetTransform(D3DTRANSFORMSTATE_VIEW, &mat)))
    {
        *piStepThatFailed = TESTID_SETTRANSFORM;
        goto LEnd;
    }

    D3DUtil_SetProjectionMatrix( mat, 60.0f * 3.14159f / 180.0f, (float) dwHeight / (float) dwWidth, 1.0f, 1000.0f );
    if (FAILED(hr = pd3ddev->SetTransform(D3DTRANSFORMSTATE_PROJECTION, &mat)))
    {
        *piStepThatFailed = TESTID_SETTRANSFORM;
        goto LEnd;
    }

    fRotY = 3.14f;
    fRotX = 0.0f;

    if (FAILED(hr = pd3ddev->SetRenderState(D3DRENDERSTATE_DITHERENABLE, TRUE)))
    {
        *piStepThatFailed = TESTID_SETRENDERSTATE;
        goto LEnd;
    }
    if (FAILED(hr = pd3ddev->SetRenderState( D3DRENDERSTATE_AMBIENT, 0x40404040 )))
    {
        *piStepThatFailed = TESTID_SETRENDERSTATE; 
        goto LEnd;
    }

    if( bUseTexture )
    {
        D3DMATERIAL7 mtrl;
        ZeroMemory( &mtrl, sizeof(D3DMATERIAL7) );
        mtrl.dcvDiffuse.r = mtrl.dcvAmbient.r = 1.0f;
        mtrl.dcvDiffuse.g = mtrl.dcvAmbient.g = 1.0f;
        mtrl.dcvDiffuse.b = mtrl.dcvAmbient.b = 1.0f;
        mtrl.dcvDiffuse.a = mtrl.dcvAmbient.a = 1.0f;
        if (FAILED(hr = pd3ddev->SetMaterial( &mtrl )))
        {
            *piStepThatFailed = TESTID_SETRENDERSTATE; 
            goto LEnd;
        }

        if (FAILED(hr = CreateTexture( &pddsTexture, pdd, pd3ddev, TEXT("DIRECTX"), piStepThatFailed)))
            goto LEnd;

        if( FAILED( hr = pd3ddev->GetCaps( &ddDesc ) ) )
        {
            *piStepThatFailed = TESTID_GETDEVICECAPS; 
            goto LEnd;
        }   

        if( ddDesc.dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MINFLINEAR )
        {
            if (FAILED(hr = pd3ddev->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTFN_LINEAR )))
            {
                *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
                goto LEnd;
            }
	    }
        if( ddDesc.dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MAGFPOINT )
        {
            if (FAILED(hr = pd3ddev->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTFN_LINEAR )))
            {
                *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
                goto LEnd;
            }
        }

        if (FAILED(hr = pd3ddev->SetTexture( 0, pddsTexture )))
        {
            *piStepThatFailed = TESTID_SETTEXTURE; 
            goto LEnd;
        }
    }

    // Here's the draw loop:
    MSG msg;
    for (i = 0; i < 600; i++)
    {
        if (PeekMessage(&msg, hwnd, WM_KEYDOWN, WM_KEYDOWN, PM_REMOVE))
        {
            *piStepThatFailed = TESTID_USER_CANCELLED;
            goto LEnd;
        }
        matRotY = D3DMATRIX((FLOAT)cos(fRotY),  0.0f, (FLOAT)sin(fRotY), 0.0f,
                            0.0f,               1.0f, 0.0f,              0.0f,
                            (FLOAT)-sin(fRotY), 0.0f, (FLOAT)cos(fRotY), 0.0f,
                            0.0f,               0.0f, 0.0f,              1.0f);

        matRotX = D3DMATRIX(1.0f, 0.0f,               0.0f,              0.0f,
                            0.0f, (FLOAT)cos(fRotX),  (FLOAT)sin(fRotX), 0.0f,
                            0.0f, (FLOAT)-sin(fRotX), (FLOAT)cos(fRotX), 0.0f,
                            0.0f, 0.0f,               0.0f,              1.0f);
        mat = matRotY * matRotX;
        if (FAILED(hr = pd3ddev->SetTransform(D3DTRANSFORMSTATE_WORLD, &mat)))
        {
            *piStepThatFailed = TESTID_SETTRANSFORM;
            goto LEnd;
        }
        if (FAILED(hr = pd3ddev->Clear( 0, NULL, D3DCLEAR_TARGET,
                                        0x00000000, 1.0f, 0L )))
        {
            *piStepThatFailed = TESTID_VIEWPORT_CLEAR;
            goto LEnd;
        }
        if (FAILED(hr = pd3ddev->BeginScene()))
        {
            if( hr == DDERR_SURFACELOST )
            {
                *piStepThatFailed = TESTID_USER_CANCELLED; 
                hr = S_OK;
            }
            else
                *piStepThatFailed = TESTID_BEGINSCENE;
            goto LEnd;
        }

        if( !bUseTexture )
        {
            if (FAILED(hr = pd3ddev->SetMaterial( &mtrlGreen )))
            {
                *piStepThatFailed = TESTID_SETRENDERSTATE; 
                goto LEnd;
            }
        }

        if (FAILED(hr = pd3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,
            D3DFVF_VERTEX, (VOID*)vertexArrayFront, 4, (WORD*)indexArrayFront, 6, 0)))
        {
            *piStepThatFailed = TESTID_DRAW_INDEXED_PRIMITIVE;
            goto LEnd;
        }
        if (FAILED(hr = pd3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,
            D3DFVF_VERTEX, (VOID*)vertexArrayBack, 4, (WORD*)indexArrayBack, 6, 0)))
        {
            *piStepThatFailed = TESTID_DRAW_INDEXED_PRIMITIVE;
            goto LEnd;
        }

        if( !bUseTexture )
        {
            if (FAILED(hr = pd3ddev->SetMaterial( &mtrlRed )))
            {
                *piStepThatFailed = TESTID_SETRENDERSTATE; 
                goto LEnd;
            }
        }

        if (FAILED(hr = pd3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,
            D3DFVF_VERTEX, (VOID*)vertexArrayLeft, 4, (WORD*)indexArrayLeft, 6, 0)))
        {
            *piStepThatFailed = TESTID_DRAW_INDEXED_PRIMITIVE;
            goto LEnd;
        }
        if (FAILED(hr = pd3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,
            D3DFVF_VERTEX, (VOID*)vertexArrayRight, 4, (WORD*)indexArrayRight, 6, 0)))
        {
            *piStepThatFailed = TESTID_DRAW_INDEXED_PRIMITIVE;
            goto LEnd;
        }
        
        if( !bUseTexture )
        {
            if (FAILED(hr = pd3ddev->SetMaterial( &mtrlBlue )))
            {
                *piStepThatFailed = TESTID_SETRENDERSTATE; 
                goto LEnd;
            }
        }

        if (FAILED(hr = pd3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,
            D3DFVF_VERTEX, (VOID*)vertexArrayTop, 4, (WORD*)indexArrayTop, 6, 0)))
        {
            *piStepThatFailed = TESTID_DRAW_INDEXED_PRIMITIVE;
            goto LEnd;
        }
        if (FAILED(hr = pd3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,
            D3DFVF_VERTEX, (VOID*)vertexArrayBottom, 4, (WORD*)indexArrayBottom, 6, 0)))
        {
            *piStepThatFailed = TESTID_DRAW_INDEXED_PRIMITIVE;
            goto LEnd;
        }

        if (FAILED(hr = pd3ddev->EndScene()))
        {
            *piStepThatFailed = TESTID_ENDSCENE;
            goto LEnd;
        }
        if (FAILED(hr = pddsFront->Flip(NULL, DDFLIP_WAIT)))
        {
            *piStepThatFailed = TESTID_PRESENT;
            goto LEnd;
        }
        fRotY += 0.05f;
        fRotX += 0.02f;
        Sleep(10);
    }

LEnd:
    ShowCursor(TRUE);
    ReleasePpo(&pddsTexture);
    ReleasePpo(&pd3ddev);
    ReleasePpo(&pd3d);
    ReleasePpo(&pddsBack);
    ReleasePpo(&pddsFront);
    if (bCooperativeLevelSet)
    {
        if (FAILED(hr))
        {
            // Something has already failed, so report that failure
            // rather than any failure of SetCooperativeLevel
            pdd->SetCooperativeLevel(hwnd, DDSCL_NORMAL);
        }
        else
        {
            if (FAILED(hr = pdd->SetCooperativeLevel(hwnd, DDSCL_NORMAL)))
            {
                *piStepThatFailed = TESTID_SETCOOPERATIVELEVEL_NORMAL;
            }
        }
    }
    if (hwnd != NULL)
        SendMessage(hwnd, WM_CLOSE, 0, 0);
    if (bDisplayModeSet)
    {
        if (FAILED(hr))
        {
            // Something has already failed, so report that failure
            // rather than any failure of RestoreDisplayMode
            pdd->RestoreDisplayMode();
        }
        else
        {
            // Nothing has failed yet, so report any failure of RestoreDisplayMode
            if (FAILED(hr = pdd->RestoreDisplayMode()))
                return hr;
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  CreateTestWindow
 *
 ****************************************************************************/
HRESULT CreateTestWindow(HWND hwndMain, HWND* phwnd)
{
    static BOOL bClassRegistered = FALSE;
    WNDCLASS wndClass;
    TCHAR* pszClass = TEXT("DxDiag AGP7 Test Window"); // Don't need to localize
    HINSTANCE hInst = (HINSTANCE)GetWindowLongPtr(hwndMain, GWLP_HINSTANCE);
    TCHAR szTitle[200];

    if (!bClassRegistered)
    {
        ZeroMemory(&wndClass, sizeof(wndClass));
        wndClass.style = CS_HREDRAW | CS_VREDRAW;
        wndClass.lpfnWndProc = DefWindowProc;
        wndClass.cbClsExtra = 0;
        wndClass.cbWndExtra = 0;
        wndClass.hInstance = hInst;
        wndClass.hIcon = NULL;
        wndClass.hCursor = NULL;
        wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
        wndClass.lpszMenuName = NULL;
        wndClass.lpszClassName = pszClass;
        if (NULL == RegisterClass(&wndClass))
            return E_FAIL;
        bClassRegistered = TRUE;
    }

    LoadString(NULL, IDS_APPFULLNAME, szTitle, 200);
    *phwnd = CreateWindow(pszClass, szTitle, WS_OVERLAPPED, 
        0, 0, 0, 0, hwndMain, NULL, hInst, NULL);
    if (*phwnd == NULL)
        return E_FAIL;

    ShowWindow(*phwnd, SW_SHOW);

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: D3DUtil_SetProjectionMatrix()
// Desc: Sets the passed in 4x4 matrix to a perpsective projection matrix built
//       from the field-of-view (fov, in y), aspect ratio, near plane (D),
//       and far plane (F). Note that the projection matrix is normalized for
//       element [3][4] to be 1.0. This is performed so that W-based range fog
//       will work correctly.
//-----------------------------------------------------------------------------
HRESULT D3DUtil_SetProjectionMatrix( D3DMATRIX& mat, FLOAT fFOV, FLOAT fAspect,
                                     FLOAT fNearPlane, FLOAT fFarPlane )
{
    if( fabs(fFarPlane-fNearPlane) < 0.01f )
        return E_INVALIDARG;
    if( fabs(sin(fFOV/2)) < 0.01f )
        return E_INVALIDARG;

    FLOAT w = fAspect * ( cosf(fFOV/2)/sinf(fFOV/2) );
    FLOAT h =   1.0f  * ( cosf(fFOV/2)/sinf(fFOV/2) );
    FLOAT Q = fFarPlane / ( fFarPlane - fNearPlane );

    ZeroMemory( &mat, sizeof(D3DMATRIX) );
    mat._11 = w;
    mat._22 = h;
    mat._33 = Q;
    mat._34 = 1.0f;
    mat._43 = -Q*fNearPlane;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: TextureSearchCallback()
// Desc: Enumeration callback routine to find a 16-bit texture format. This
//       function is invoked by the ID3DDevice::EnumTextureFormats() function
//       to sort through all the available texture formats for a given device.
//       The pixel format of each enumerated texture format is passed into the
//       "pddpf" parameter. The 2nd parameter is to be used however the app
//       sees fit. In this case, we are using it as an output parameter to 
//       return a normal 16-bit texture format.
//-----------------------------------------------------------------------------
static HRESULT CALLBACK TextureSearchCallback( DDPIXELFORMAT* pddpf, VOID* param )
{
    // Note: Return with DDENUMRET_OK to continue enumerating more formats.

    // Skip any funky modes
    if( pddpf->dwFlags & (DDPF_LUMINANCE|DDPF_BUMPLUMINANCE|DDPF_BUMPDUDV) )
        return DDENUMRET_OK;
    
    // Skip any FourCC formats
    if( pddpf->dwFourCC != 0 )
        return DDENUMRET_OK;

    // Skip alpha modes
    if( pddpf->dwFlags&DDPF_ALPHAPIXELS )
        return DDENUMRET_OK;

    // We only want certain format, so skip all others
    if( pddpf->dwRGBBitCount == 32 && ((DDPIXELFORMAT*)param)->dwRGBBitCount == 0 || 
    	pddpf->dwRGBBitCount == 16 )
	{
	    // We found a good match. Copy the current pixel format to our output
	    // parameter
	    memcpy( (DDPIXELFORMAT*)param, pddpf, sizeof(DDPIXELFORMAT) );
	}

	// Have we found the best match?	
    if( pddpf->dwRGBBitCount == 16 )
	    return DDENUMRET_CANCEL;

	// Keep looking.	
    return DDENUMRET_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateTexture()
// Desc: Is passed a filename and creates a local Bitmap from that file. Some
//       logic and file parsing code could go here to support other image
//       file formats.
//-----------------------------------------------------------------------------
HRESULT CreateTexture( LPDIRECTDRAWSURFACE7* ppdds, 
                       LPDIRECTDRAW7 pdd, LPDIRECT3DDEVICE7 pd3dDevice, 
                       TCHAR* strName, LONG* piStepThatFailed)
{
    HRESULT              hr;
    LPDIRECTDRAWSURFACE7 pddsTexture    = NULL;
    HBITMAP              hbm            = NULL;
    D3DDEVICEDESC7       ddDesc;
    BITMAP               bm;
    DWORD                dwWidth;
    DWORD                dwHeight;
    DDSURFACEDESC2       ddsd;
    LPDIRECTDRAWSURFACE7 pddsRender     = NULL;
    HDC                  hdcTexture     = NULL;
    HDC                  hdcBitmap      = NULL;

    //////////////////////////////////////////////
    // Verify args
    //////////////////////////////////////////////
    if( NULL == ppdds        || 
        NULL == pdd          || 
        NULL == pd3dDevice   || 
        NULL == strName      || 
        NULL == piStepThatFailed )
    {
        // Unknown error - shouldn't happen, but this prevent crashs
        *piStepThatFailed = 0xFFFF; 
        return E_FAIL;
    }

    //////////////////////////////////////////////
    // Load image 
    //////////////////////////////////////////////
    hbm = (HBITMAP)LoadImage( GetModuleHandle(NULL), strName, 
                              IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION );
    if( NULL == hbm )
    {
        *piStepThatFailed = TESTID_CREATETEXTURE; 
        hr = E_FAIL;
        goto LEnd;
    }

    //////////////////////////////////////////////
    // Get caps on device and hbm
    //////////////////////////////////////////////
    if( FAILED( hr = pd3dDevice->GetCaps( &ddDesc ) ) )
    {
        *piStepThatFailed = TESTID_GETDEVICECAPS; 
        goto LEnd;
    }
    
    if( 0 == GetObject( hbm, sizeof(BITMAP), &bm ) ) 
    {
        *piStepThatFailed = TESTID_CREATETEXTURE; 
        hr = E_FAIL;
        goto LEnd;
    }

    dwWidth  = (DWORD)bm.bmWidth;
    dwHeight = (DWORD)bm.bmHeight;

    //////////////////////////////////////////////
    // Setup the new surface desc for the texture. 
    //////////////////////////////////////////////
    ZeroMemory( &ddsd, sizeof(DDSURFACEDESC2) );
    ddsd.dwSize          = sizeof(DDSURFACEDESC2);
    ddsd.dwFlags         = DDSD_CAPS|DDSD_HEIGHT|DDSD_WIDTH|
                           DDSD_PIXELFORMAT|DDSD_TEXTURESTAGE;
    ddsd.ddsCaps.dwCaps  = DDSCAPS_TEXTURE|DDSCAPS_VIDEOMEMORY|DDSCAPS_NONLOCALVIDMEM;
    ddsd.dwWidth         = dwWidth;
    ddsd.dwHeight        = dwHeight;
    
    // Adjust width and height, if the driver requires it
    if( ddDesc.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_POW2 )
    {
        for( ddsd.dwWidth=1;  dwWidth>ddsd.dwWidth;   ddsd.dwWidth<<=1 );
        for( ddsd.dwHeight=1; dwHeight>ddsd.dwHeight; ddsd.dwHeight<<=1 );
    }
    if( ddDesc.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_SQUAREONLY )
    {
        if( ddsd.dwWidth > ddsd.dwHeight ) 
            ddsd.dwHeight = ddsd.dwWidth;
        else                               
            ddsd.dwWidth  = ddsd.dwHeight;
    }

    // Look for a 16-bit texture format
    if( FAILED( hr = pd3dDevice->EnumTextureFormats( TextureSearchCallback, 
                                                     &ddsd.ddpfPixelFormat ) ) )
    {
        *piStepThatFailed = TESTID_ENUMTEXTUREFORMATS; 
        goto LEnd;
    }
    if( 0L == ddsd.ddpfPixelFormat.dwRGBBitCount )
    {
        *piStepThatFailed = TESTID_ENUMTEXTUREFORMATS; 
        goto LEnd;
    }

    //////////////////////////////////////////////
    // Create a new surface for the texture
    //////////////////////////////////////////////
    if( FAILED( hr = pdd->CreateSurface( &ddsd, &pddsTexture, NULL ) ) )
    {
        ddsd.ddsCaps.dwCaps  = DDSCAPS_TEXTURE;
        if( FAILED( hr = pdd->CreateSurface( &ddsd, &pddsTexture, NULL ) ) )
        {
                *piStepThatFailed = TESTID_CREATESURFACE; 
                goto LEnd;
        }
    }
    if( NULL == pddsTexture )
    {
        *piStepThatFailed = TESTID_CREATESURFACE; 
        hr = E_FAIL;
        goto LEnd;
    }

    //////////////////////////////////////////////
    // Get DCs from bitmap and surface
    //////////////////////////////////////////////
    hdcBitmap = CreateCompatibleDC( NULL );
    if( NULL == hdcBitmap )
    {
        *piStepThatFailed = TESTID_CREATETEXTURE; 
        hr = E_FAIL;
        goto LEnd;
    }

    if( NULL == SelectObject( hdcBitmap, hbm ) )
    {
        *piStepThatFailed = TESTID_CREATETEXTURE; 
        hr = E_FAIL;
        goto LEnd;
    }

    // Get a DC for the surface
    if( FAILED( hr = pddsTexture->GetDC( &hdcTexture ) ) )
    {
        *piStepThatFailed = TESTID_GETDC; 
        goto LEnd;
    }
    if( NULL == hdcTexture )
    {
        *piStepThatFailed = TESTID_GETDC; 
        goto LEnd;
    }

    //////////////////////////////////////////////
    // Copy the bitmap image to the surface.
    //////////////////////////////////////////////
    if( 0 == BitBlt( hdcTexture, 0, 0, bm.bmWidth, bm.bmHeight, hdcBitmap,
                     0, 0, SRCCOPY ) )
    {
        if( pddsTexture )
        {
            // Try to release the DC first
            pddsTexture->ReleaseDC( hdcTexture );
        }

        *piStepThatFailed = TESTID_CREATETEXTURE; 
        hr = E_FAIL;
        goto LEnd;
    }

    //////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////
    if( FAILED( hr = pddsTexture->ReleaseDC( hdcTexture ) ) )
    {
        *piStepThatFailed = TESTID_RELEASEDC; 
        goto LEnd;
    }


LEnd:
    if( hdcBitmap )
        DeleteDC( hdcBitmap );
    if( hbm )
        DeleteObject( hbm );

    // Return the newly created texture
    // pddsTexture will be cleaned up in parent fn.
    *ppdds = pddsTexture;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\sysinfo.h ===
/****************************************************************************
 *
 *    File: sysinfo.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather system information (OS, hardware, name, etc.) on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef SYSINFO_H
#define SYSINFO_H

// DXD_IN_SI_VALUE is the name of a value stored under the registry key 
// HKLM\DXD_IN_SI_KEY that indicates that DxDiag is using
// sysinfo.  If DxDiag starts up and this value exists, DxDiag 
// probably crashed in sysinfo and DxDiag should offer to run without
// using sysinfo.
#define DXD_IN_SI_KEY TEXT("Software\\Microsoft\\DirectX Diagnostic Tool")
#define DXD_IN_SI_VALUE TEXT("DxDiag In SystemInfo")

struct SysInfo
{
    SYSTEMTIME m_time;
    TCHAR m_szTimeLocal[100];  // Date/time, localized for UI
    TCHAR m_szTime[100]; // Date/time, dd/mm/yyyy hh:mm:ss for saved report
    TCHAR m_szMachine[200];
    DWORD m_dwMajorVersion;
    DWORD m_dwMinorVersion;
    DWORD m_dwBuildNumber;
    TCHAR m_szBuildLab[100];
    DWORD m_dwPlatformID;
    TCHAR m_szCSDVersion[200];
    TCHAR m_szDirectXVersion[100];
    TCHAR m_szDirectXVersionLong[100];
    DWORD m_dwDirectXVersionMajor;
    DWORD m_dwDirectXVersionMinor;
    TCHAR m_cDirectXVersionLetter;
    TCHAR m_szDxDiagVersion[100];
    DWORD m_dwSetupParam;
    TCHAR m_szSetupParam[100];
    BOOL m_bDebug;
    BOOL m_bNECPC98;
    TCHAR m_szOS[100]; // Formatted version of platform
    TCHAR m_szOSEx[100]; // Formatted version of platform, version, build num
    TCHAR m_szOSExLong[300]; // Formatted version of platform, version, build num, patch, lab
    TCHAR m_szProcessor[200];
    TCHAR m_szSystemManufacturerEnglish[200];
    TCHAR m_szSystemModelEnglish[200];
    TCHAR m_szBIOSEnglish[200];
    TCHAR m_szLanguages[200]; // Formatted version of m_szLanguage, m_szLanguageRegional
    TCHAR m_szLanguagesLocal[200]; // m_szLanguages, in local language
    DWORDLONG m_ullPhysicalMemory;
    TCHAR m_szPhysicalMemory[100]; // Formatted version of physical memory
    DWORDLONG m_ullUsedPageFile;
    DWORDLONG m_ullAvailPageFile;
    TCHAR m_szPageFile[100]; // Formatted version of pagefile
    TCHAR m_szPageFileEnglish[100]; // Formatted version of pagefile
    TCHAR m_szD3D8CacheFileSystem[MAX_PATH];
    BOOL  m_bNetMeetingRunning;

    TCHAR m_szDXFileNotes[3000]; 
    TCHAR m_szMusicNotes[3000]; 
    TCHAR m_szInputNotes[3000]; 
    TCHAR m_szNetworkNotes[3000]; 

    TCHAR m_szDXFileNotesEnglish[3000]; 
    TCHAR m_szMusicNotesEnglish[3000]; 
    TCHAR m_szInputNotesEnglish[3000]; 
    TCHAR m_szNetworkNotesEnglish[3000]; 

    BOOL m_bIsD3D8DebugRuntimeAvailable;
    BOOL m_bIsD3DDebugRuntime;
    BOOL m_bIsDInput8DebugRuntimeAvailable;
    BOOL m_bIsDInput8DebugRuntime;
    BOOL m_bIsDMusicDebugRuntimeAvailable;
    BOOL m_bIsDMusicDebugRuntime;
    BOOL m_bIsDDrawDebugRuntime;
    BOOL m_bIsDPlayDebugRuntime;
    BOOL m_bIsDSoundDebugRuntime;

    int m_nD3DDebugLevel;
    int m_nDDrawDebugLevel;
    int m_nDIDebugLevel;
    int m_nDMusicDebugLevel;
    int m_nDPlayDebugLevel;
    int m_nDSoundDebugLevel;

};

BOOL BIsPlatformNT(VOID);  // Is this a NT codebase?
BOOL BIsPlatform9x(VOID);  // Is this a Win9x codebase?

BOOL BIsWinNT(VOID);  // Is this WinNT v4 (or less)
BOOL BIsWin2k(VOID);  // Is this Win2k?
BOOL BIsWinME(VOID);  // Is this WinME?
BOOL BIsWhistler(VOID);  // Is this Whistler?
BOOL BIsWin98(VOID);  // Is this Win98?
BOOL BIsWin95(VOID);  // Is this Win95?
BOOL BIsWin3x(VOID);  // Is this Win3.x?
BOOL BIsIA64(VOID);   // Is this IA64?

BOOL BIsDxDiag64Bit(VOID); // Is this DxDiag.exe 64bit?

VOID GetSystemInfo(SysInfo* pSysInfo);
VOID GetDXDebugLevel(SysInfo* pSysInfo);


#endif // SYSINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\testd3d8.cpp ===
/****************************************************************************
 *
 *    File: testd3d8.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Jason Sandlin (jasonsa@microsoft.com)
 * Purpose: Test D3D8/AGP Texturing functionality on this machine
 *
 * (C) Copyright 2000 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <Windows.h>
#define DIRECT3D_VERSION 0x0800 // file uses DX8 
#include <d3d8.h>
#include <d3dx8.h>
#include "reginfo.h"
#include "sysinfo.h"
#include "dispinfo.h"
#include "testagp.h"
#include "resource.h"

#ifndef ReleasePpo
    #define ReleasePpo(ppo) \
        if (*(ppo) != NULL) \
        { \
            (*(ppo))->Release(); \
            *(ppo) = NULL; \
        } \
        else (VOID)0
#endif

typedef IDirect3D8* (WINAPI* LPDIRECT3DCREATE8)(UINT SDKVersion);

#define D3DFVF_VERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)

#define MAX_FORMATS             64
#define MAX_MODES               512
#define MAX_CONFIRMED_MODES     512

struct D3DVERTEX
{
    D3DXVECTOR3 p;
    D3DXVECTOR3 n;
    FLOAT       tu, tv;

    D3DVERTEX() {};
    D3DVERTEX( D3DXVECTOR3 vp, D3DXVECTOR3 vn, FLOAT fTu, FLOAT fTv ) : p(vp), n(vn), tu(fTu), tv(fTv) {}
};

struct D3DModeInfo
{
    DWORD      Width;      // Screen width in this mode
    DWORD      Height;     // Screen height in this mode
    D3DFORMAT  Format;     // Pixel format in this mode
    DWORD      dwBehavior; // Hardware / Software / Mixed vertex processing
};

enum TESTID
{
    TESTID_LOAD_D3D8_DLL=1,
    TESTID_GET_D3DCREATE8,
    TESTID_D3DCREATE8,
    TESTID_ENUMADAPTERMODES,
    TESTID_GETDEVICECAPS,
    TESTID_NOMODEFOUND,
    TESTID_CREATE_TEST_WINDOW,
    TESTID_CREATE_DEVICE,
    TESTID_GETBACKBUFFER,
    TESTID_GETDESC,
    TESTID_CREATE_VERTEX_BUFFER,
    TESTID_CREATE_INDEX_BUFFER,
    TESTID_LOCK,
    TESTID_UNLOCK,
    TESTID_SETLIGHT,
    TESTID_LIGHTENABLE,
    TESTID_SETTRANSFORM,
    TESTID_SETRENDERSTATE,
    TESTID_CREATETEXTURE,
    TESTID_SETTEXTURESTAGESTATE,
    TESTID_SETTEXTURE,
    TESTID_SETVERTEXSHADER,
    TESTID_USER_CANCELLED,
    TESTID_VIEWPORT_CLEAR,
    TESTID_BEGINSCENE,
    TESTID_SETMATERIAL,
    TESTID_SETSTREAMSOURCE,
    TESTID_SETINDICES,
    TESTID_DRAW_INDEXED_PRIMITIVE,
    TESTID_ENDSCENE,
    TESTID_PRESENT,
    TESTID_USER_VERIFY_D3D7_RENDERING,
    TESTID_USER_VERIFY_D3D8_RENDERING,
    TESTID_LOAD_DDRAW_DLL,
    TESTID_GET_DIRECTDRAWCREATE,
    TESTID_DIRECTDRAWCREATE,
    TESTID_SETCOOPERATIVELEVEL_FULLSCREEN,
    TESTID_SETCOOPERATIVELEVEL_NORMAL,
    TESTID_SETDISPLAYMODE,
    TESTID_CREATEPRIMARYSURFACE_FLIP_ONEBACK,
    TESTID_GETATTACHEDSURFACE,
    TESTID_QUERY_D3D,
    TESTID_SETVIEWPORT,
    TESTID_ENUMTEXTUREFORMATS,
    TESTID_CREATESURFACE,
    TESTID_GETDC,
    TESTID_RELEASEDC,
};

BOOL BTranslateError(HRESULT hr, TCHAR* psz, BOOL bEnglish = FALSE); // from main.cpp 
static HRESULT SelectModeAndFormat( DisplayInfo* pDisplayInfo, IDirect3D8* pD3D8, D3DModeInfo* pSelectedMode, D3DDEVTYPE* pSelectedDeviceType );
static HRESULT Test3D( BOOL bUseTexture, IDirect3D8* pD3D8, HWND hwndMain, DWORD iAdapter, D3DModeInfo selectedMode, D3DDEVTYPE selectedDeviceType, LONG* piStepThatFailed );
static HRESULT CreateTestWindow(HWND hwndMain, HWND* phwnd);
static HRESULT InitVertexBuffer( IDirect3DDevice8* pd3dDevice, const D3DVERTEX* vertexArray, DWORD dwNumVertices, LPDIRECT3DVERTEXBUFFER8* ppVB, LONG* piStepThatFailed );
static HRESULT InitIndexBuffer( IDirect3DDevice8* pd3dDevice, const WORD* wIndexArray, DWORD dwNumIndices, LPDIRECT3DINDEXBUFFER8* ppIB, LONG* piStepThatFailed );
static HRESULT DrawTwoSides( BOOL bUseTexture, IDirect3DDevice8* pd3dDevice, D3DMATERIAL8* pMtrl, LPDIRECT3DVERTEXBUFFER8 pVB1, LPDIRECT3DINDEXBUFFER8 pIB1, LPDIRECT3DVERTEXBUFFER8 pVB2, LPDIRECT3DINDEXBUFFER8 pIB2, LONG* piStepThatFailed );




//-----------------------------------------------------------------------------
// Name: TestD3Dv8()
// Desc: 
//-----------------------------------------------------------------------------
VOID TestD3Dv8( BOOL bUseTexture, HWND hwndMain, DisplayInfo* pDisplayInfo)
{
    HRESULT             hr             = S_OK;
    TCHAR               sz[MAX_PATH];
    TCHAR               szTitle[MAX_PATH];
    HINSTANCE           hInstD3D8      = NULL;
    IDirect3D8*         pD3D8          = NULL;
    HWND                hwnd           = NULL;
    D3DModeInfo         selectedMode;
    D3DDEVTYPE          selectedDeviceType;
  
    if( pDisplayInfo == NULL )
        return;

    LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);

    LPDIRECT3DCREATE8 pD3DCreate8 = NULL;
    TCHAR szPath[MAX_PATH];

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\d3d8.dll"));

    // This may fail if DX8 isn't on the system
    hInstD3D8 = LoadLibrary(szPath);
    if (hInstD3D8 == NULL)
    {
        pDisplayInfo->m_testResultD3D8.m_iStepThatFailed = TESTID_LOAD_D3D8_DLL;
        pDisplayInfo->m_testResultD3D8.m_hr = E_FAIL;
        goto LEnd;
    }

    pD3DCreate8 = (LPDIRECT3DCREATE8)GetProcAddress(hInstD3D8, "Direct3DCreate8");
    if (pD3DCreate8 == NULL)
    {
        FreeLibrary(hInstD3D8);
        hInstD3D8 = NULL;

        pDisplayInfo->m_testResultD3D8.m_iStepThatFailed = TESTID_GET_D3DCREATE8;
        pDisplayInfo->m_testResultD3D8.m_hr = E_POINTER;
        goto LEnd;
    }

    pD3D8 = pD3DCreate8(D3D_SDK_VERSION);
    if( pD3D8 == NULL )
    {
        // We have the wrong headers since d3d8.dll loaded but D3DCreate8() failed.
        pDisplayInfo->m_testResultD3D8.m_iStepThatFailed = TESTID_D3DCREATE8;
        pDisplayInfo->m_testResultD3D8.m_hr = E_FAIL;
        goto LEnd;
    }

    // Enum and select a support mode and format and device type
    if( FAILED( SelectModeAndFormat( pDisplayInfo, pD3D8, 
                                     &selectedMode, &selectedDeviceType ) ) )
        goto LEnd;

    // Save the cursor
    POINT ptMouse;
    GetCursorPos(&ptMouse);

    // Run the test
    if (FAILED(hr = Test3D( bUseTexture, pD3D8, hwndMain, pDisplayInfo->m_iAdapter, selectedMode, 
                            selectedDeviceType, &pDisplayInfo->m_testResultD3D8.m_iStepThatFailed)))
    {
        pDisplayInfo->m_testResultD3D8.m_hr = hr;
        goto LEnd;
    }

    // Restore the cursor position
    SetCursorPos( ptMouse.x, ptMouse.y );    

    // Tell the user if they canceled
    if (pDisplayInfo->m_testResultD3D8.m_iStepThatFailed == TESTID_USER_CANCELLED)
    {
        LoadString(NULL, IDS_YOUCANCELLED, sz, MAX_PATH);
        MessageBox(hwndMain, sz, szTitle, MB_OK);
        pDisplayInfo->m_testResultD3D8.m_bCancelled = TRUE;
        goto LEnd;
    }

    // Confirm the test succeeded
    LoadString(NULL, IDS_CONFIRMD3DTEST, sz, MAX_PATH);
    if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
    {
        pDisplayInfo->m_testResultD3D8.m_iStepThatFailed = TESTID_USER_VERIFY_D3D8_RENDERING;
        pDisplayInfo->m_testResultD3D8.m_hr = S_OK;
        goto LEnd;
    }

LEnd:
    ReleasePpo( &pD3D8 );
    if( hInstD3D8 )
    {
        FreeLibrary(hInstD3D8);
        hInstD3D8 = NULL;
    }
}




//-----------------------------------------------------------------------------
// Name: Test3D()
// Desc: Generate a spinning 3D cube
//-----------------------------------------------------------------------------
HRESULT Test3D( BOOL bUseTexture, IDirect3D8* pD3D8, HWND hwndMain, DWORD iAdapter, 
                D3DModeInfo selectedMode, D3DDEVTYPE selectedDeviceType, 
                LONG* piStepThatFailed )
{
    LPDIRECT3DDEVICE8       pd3dDevice    = NULL;
    LPDIRECT3DTEXTURE8      pTexture      = NULL;
    LPDIRECT3DVERTEXBUFFER8 pVBFront      = NULL;
    LPDIRECT3DINDEXBUFFER8  pIBFront      = NULL;
    LPDIRECT3DVERTEXBUFFER8 pVBBack       = NULL;
    LPDIRECT3DINDEXBUFFER8  pIBBack       = NULL;
    LPDIRECT3DVERTEXBUFFER8 pVBLeft       = NULL;
    LPDIRECT3DINDEXBUFFER8  pIBLeft       = NULL;
    LPDIRECT3DVERTEXBUFFER8 pVBRight      = NULL;
    LPDIRECT3DINDEXBUFFER8  pIBRight      = NULL;
    LPDIRECT3DVERTEXBUFFER8 pVBTop        = NULL;
    LPDIRECT3DINDEXBUFFER8  pIBTop        = NULL;
    LPDIRECT3DVERTEXBUFFER8 pVBBottom     = NULL;
    LPDIRECT3DINDEXBUFFER8  pIBBottom     = NULL;
    LPDIRECT3DSURFACE8      pBackBuffer   = NULL;   
    D3DMATERIAL8            mtrlWhite;
    D3DMATERIAL8            mtrlRed;
    D3DMATERIAL8            mtrlBlue;
    D3DMATERIAL8            mtrlGreen;
    D3DXMATRIX              matRotY;
    D3DXMATRIX              matRotX;
    D3DXMATRIX              mat;
    D3DSURFACE_DESC         d3dsdBackBuffer;   
    FLOAT                   fRotY;
    FLOAT                   fRotX;
    HRESULT                 hr;
    HWND                    hwnd;
    MSG                     msg;
    DWORD                   i;

    static const D3DVERTEX vertexArrayFront[] = 
    {
        D3DVERTEX(D3DXVECTOR3(-1.0, -1.0, -1.0), D3DXVECTOR3(0.0, 0.0, -1.0),   1.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3( 1.0, -1.0, -1.0), D3DXVECTOR3(0.0, 0.0, -1.0),   0.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3(-1.0,  1.0, -1.0), D3DXVECTOR3(0.0, 0.0, -1.0),   1.0f, 1.0f),
        D3DVERTEX(D3DXVECTOR3( 1.0,  1.0, -1.0), D3DXVECTOR3(0.0, 0.0, -1.0),   0.0f, 1.0f),
    };
    static const WORD indexArrayFront[] = 
    {
        0, 2, 1,
        2, 3, 1,
    };

    static const D3DVERTEX vertexArrayBack[] = 
    {
        D3DVERTEX(D3DXVECTOR3(-1.0, -1.0, 1.0),  D3DXVECTOR3(0.0, 0.0, 1.0),   0.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3( 1.0, -1.0, 1.0),  D3DXVECTOR3(0.0, 0.0, 1.0),   1.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3(-1.0,  1.0, 1.0),  D3DXVECTOR3(0.0, 0.0, 1.0),   0.0f, 1.0f),
        D3DVERTEX(D3DXVECTOR3( 1.0,  1.0, 1.0),  D3DXVECTOR3(0.0, 0.0, 1.0),   1.0f, 1.0f),
    };
    static const WORD indexArrayBack[] = 
    {
        0, 1, 2,
        2, 1, 3,
    };

    static const D3DVERTEX vertexArrayLeft[] = 
    {
        D3DVERTEX(D3DXVECTOR3(-1.0, -1.0, -1.0),  D3DXVECTOR3(-1.0, 0.0, 0.0),   0.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3(-1.0, -1.0,  1.0),  D3DXVECTOR3(-1.0, 0.0, 0.0),   1.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3(-1.0,  1.0, -1.0),  D3DXVECTOR3(-1.0, 0.0, 0.0),   0.0f, 1.0f),
        D3DVERTEX(D3DXVECTOR3(-1.0,  1.0,  1.0),  D3DXVECTOR3(-1.0, 0.0, 0.0),   1.0f, 1.0f),
    };
    static const WORD indexArrayLeft[] = 
    {
        0, 1, 2,
        2, 1, 3,
    };

    static const D3DVERTEX vertexArrayRight[] = 
    {
        D3DVERTEX(D3DXVECTOR3(1.0, -1.0, -1.0),  D3DXVECTOR3(1.0, 0.0, 0.0),   1.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3(1.0, -1.0,  1.0),  D3DXVECTOR3(1.0, 0.0, 0.0),   0.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3(1.0,  1.0, -1.0),  D3DXVECTOR3(1.0, 0.0, 0.0),   1.0f, 1.0f),
        D3DVERTEX(D3DXVECTOR3(1.0,  1.0,  1.0),  D3DXVECTOR3(1.0, 0.0, 0.0),   0.0f, 1.0f),
    };
    static const WORD indexArrayRight[] = 
    {
        0, 2, 1,
        2, 3, 1,
    };

    static const D3DVERTEX vertexArrayTop[] = 
    {
        D3DVERTEX(D3DXVECTOR3(-1.0, 1.0, -1.0),  D3DXVECTOR3(0.0, 1.0, 0.0),   0.0f, 1.0f),
        D3DVERTEX(D3DXVECTOR3( 1.0, 1.0, -1.0),  D3DXVECTOR3(0.0, 1.0, 0.0),   1.0f, 1.0f),
        D3DVERTEX(D3DXVECTOR3(-1.0, 1.0,  1.0),  D3DXVECTOR3(0.0, 1.0, 0.0),   0.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3( 1.0, 1.0,  1.0),  D3DXVECTOR3(0.0, 1.0, 0.0),   1.0f, 0.0f),
    };
    static const WORD indexArrayTop[] = 
    {
        0, 2, 1,
        2, 3, 1,
    };

    static const D3DVERTEX vertexArrayBottom[] = 
    {
        D3DVERTEX(D3DXVECTOR3(-1.0, -1.0, -1.0),  D3DXVECTOR3(0.0, -1.0, 0.0),   1.0f, 1.0f),
        D3DVERTEX(D3DXVECTOR3( 1.0, -1.0, -1.0),  D3DXVECTOR3(0.0, -1.0, 0.0),   0.0f, 1.0f),
        D3DVERTEX(D3DXVECTOR3(-1.0, -1.0,  1.0),  D3DXVECTOR3(0.0, -1.0, 0.0),   1.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3( 1.0, -1.0,  1.0),  D3DXVECTOR3(0.0, -1.0, 0.0),   0.0f, 0.0f),
    };
    static const WORD indexArrayBottom[] = 
    {
        0, 1, 2,
        2, 1, 3,
    };

    ShowCursor(FALSE);
    // Create test window
    if (FAILED(hr = CreateTestWindow(hwndMain, &hwnd)))
    {
        *piStepThatFailed = TESTID_CREATE_TEST_WINDOW;
        goto LEnd;
    }

    // Set up the presentation parameters
    D3DPRESENT_PARAMETERS d3dpp;         
    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    d3dpp.Windowed                          = FALSE;
    d3dpp.BackBufferCount                   = 1;
    d3dpp.MultiSampleType                   = D3DMULTISAMPLE_NONE;
    d3dpp.SwapEffect                        = D3DSWAPEFFECT_DISCARD;
    d3dpp.EnableAutoDepthStencil            = FALSE;
    d3dpp.FullScreen_RefreshRateInHz        = D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_ONE;
    d3dpp.hDeviceWindow                     = hwnd;
    d3dpp.BackBufferWidth                   = selectedMode.Width;
    d3dpp.BackBufferHeight                  = selectedMode.Height;
    d3dpp.BackBufferFormat                  = selectedMode.Format;

    // Create the device
    if( FAILED( hr = pD3D8->CreateDevice( iAdapter, selectedDeviceType,
                                          hwnd, selectedMode.dwBehavior, &d3dpp,
                                          &pd3dDevice ) ) )
    {
        *piStepThatFailed  = TESTID_CREATE_DEVICE;
        goto LEnd;
    }
    if( pd3dDevice == NULL )
    {
        *piStepThatFailed  = TESTID_CREATE_DEVICE;
        hr = E_POINTER;
        goto LEnd;
    }

    // Get the desc of the backbuffer
    if( FAILED( hr = pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer ) ) )
    {
        *piStepThatFailed  = TESTID_GETBACKBUFFER;
        goto LEnd;
    }
    if( pBackBuffer == NULL )
    {
        *piStepThatFailed  = TESTID_GETBACKBUFFER;
        hr = E_POINTER;
        goto LEnd;
    }

    if( FAILED( hr = pBackBuffer->GetDesc( &d3dsdBackBuffer ) ) )
    {
        *piStepThatFailed  = TESTID_GETDESC;
        goto LEnd;
    }
    ReleasePpo(&pBackBuffer);

    // Init the vertex/index buffer for the Front 
    if( FAILED( hr = InitVertexBuffer( pd3dDevice, vertexArrayFront, sizeof(vertexArrayFront)/sizeof(D3DVERTEX), &pVBFront, piStepThatFailed ) ) )
        goto LEnd;
    if( FAILED( hr = InitIndexBuffer( pd3dDevice, indexArrayFront, sizeof(indexArrayFront)/sizeof(WORD), &pIBFront, piStepThatFailed ) ) )
        goto LEnd;

    // Init the vertex/index buffer for the Back
    if( FAILED( hr = InitVertexBuffer( pd3dDevice, vertexArrayBack, sizeof(vertexArrayBack)/sizeof(D3DVERTEX), &pVBBack, piStepThatFailed ) ) )
        goto LEnd;
    if( FAILED( hr = InitIndexBuffer( pd3dDevice, indexArrayBack, sizeof(indexArrayBack)/sizeof(WORD), &pIBBack, piStepThatFailed ) ) )
        goto LEnd;

    // Init the vertex/index buffer for the Left
    if( FAILED( hr = InitVertexBuffer( pd3dDevice, vertexArrayLeft, sizeof(vertexArrayLeft)/sizeof(D3DVERTEX), &pVBLeft, piStepThatFailed ) ) )
        goto LEnd;
    if( FAILED( hr = InitIndexBuffer( pd3dDevice, indexArrayLeft, sizeof(indexArrayLeft)/sizeof(WORD), &pIBLeft, piStepThatFailed ) ) )
        goto LEnd;

    // Init the vertex/index buffer for the Right
    if( FAILED( hr = InitVertexBuffer( pd3dDevice, vertexArrayRight, sizeof(vertexArrayRight)/sizeof(D3DVERTEX), &pVBRight, piStepThatFailed ) ) )
        goto LEnd;
    if( FAILED( hr = InitIndexBuffer( pd3dDevice, indexArrayRight, sizeof(indexArrayRight)/sizeof(WORD), &pIBRight, piStepThatFailed ) ) )
        goto LEnd;

    // Init the vertex/index buffer for the Top
    if( FAILED( hr = InitVertexBuffer( pd3dDevice, vertexArrayTop, sizeof(vertexArrayTop)/sizeof(D3DVERTEX), &pVBTop, piStepThatFailed ) ) )
        goto LEnd;
    if( FAILED( hr = InitIndexBuffer( pd3dDevice, indexArrayTop, sizeof(indexArrayTop)/sizeof(WORD), &pIBTop, piStepThatFailed ) ) )
        goto LEnd;
    
    // Init the vertex/index buffer for the Bottom
    if( FAILED( hr = InitVertexBuffer( pd3dDevice, vertexArrayBottom, sizeof(vertexArrayBottom)/sizeof(D3DVERTEX), &pVBBottom, piStepThatFailed ) ) )
        goto LEnd;
    if( FAILED( hr = InitIndexBuffer( pd3dDevice, indexArrayBottom, sizeof(indexArrayBottom)/sizeof(WORD), &pIBBottom, piStepThatFailed ) ) )
        goto LEnd;

    // Add a light
    D3DLIGHT8 light;
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type        = D3DLIGHT_DIRECTIONAL;
    light.Diffuse.r   = 1.0f;
    light.Diffuse.g   = 1.0f;
    light.Diffuse.b   = 1.0f;
    light.Direction.x = 0.0f;
    light.Direction.y = 0.0f;
    light.Direction.z = 1.0f;

    if( FAILED( hr = pd3dDevice->SetLight( 0, &light ) ) )
    {
        *piStepThatFailed = TESTID_SETLIGHT;
        goto LEnd;
    }
    if( FAILED( hr = pd3dDevice->LightEnable( 0, TRUE ) ) )
    {
        *piStepThatFailed = TESTID_LIGHTENABLE; 
        goto LEnd;
    }

    // Set up matrices
    mat = D3DXMATRIX(1.0f, 0.0f, 0.0f, 0.0f,
                     0.0f, 1.0f, 0.0f, 0.0f,
                     0.0f, 0.0f, 1.0f, 0.0f,
                     0.0f, 0.0f, 0.0f, 1.0f);
    if( FAILED( hr = pd3dDevice->SetTransform( D3DTS_WORLD, &mat ) ) )
    {
        *piStepThatFailed = TESTID_SETTRANSFORM;
        goto LEnd;
    }

    mat = D3DXMATRIX(1.0f, 0.0f, 0.0f, 0.0f,
                     0.0f, 1.0f, 0.0f, 0.0f,
                     0.0f, 0.0f, 1.0f, 0.0f,
                     0.0f, 0.0f, 5.0f, 1.0f);
    if( FAILED( hr = pd3dDevice->SetTransform( D3DTS_VIEW, &mat ) ) )
    {
        *piStepThatFailed = TESTID_SETTRANSFORM;
        goto LEnd;
    }

    D3DXMatrixPerspectiveFovLH( &mat, D3DXToRadian(60.0f), 
                                (float) d3dsdBackBuffer.Width / (float) d3dsdBackBuffer.Height, 
                                1.0f, 1000.0f );
    if( FAILED( hr = pd3dDevice->SetTransform( D3DTS_PROJECTION, &mat ) ) )
    {
        *piStepThatFailed = TESTID_SETTRANSFORM;
        goto LEnd;
    }

    fRotY = 3.14f;
    fRotX = 0.0f;

    if( FAILED( hr = pd3dDevice->SetRenderState( D3DRS_DITHERENABLE, TRUE ) ) )
    {
        *piStepThatFailed = TESTID_SETRENDERSTATE;
        goto LEnd;
    }
    if( FAILED( hr = pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0x40404040 ) ) )
    {
        *piStepThatFailed = TESTID_SETRENDERSTATE; 
        goto LEnd;
    }

    ZeroMemory( &mtrlWhite, sizeof(D3DMATERIAL8) );
    mtrlWhite.Diffuse.r = mtrlWhite.Ambient.r = 1.0f;
    mtrlWhite.Diffuse.g = mtrlWhite.Ambient.g = 1.0f;
    mtrlWhite.Diffuse.b = mtrlWhite.Ambient.b = 1.0f;
    mtrlWhite.Diffuse.a = mtrlWhite.Ambient.a = 0.0f;

    ZeroMemory( &mtrlRed, sizeof(D3DMATERIAL8) );
    mtrlRed.Diffuse.r = mtrlRed.Ambient.r = 1.0f;
    mtrlRed.Diffuse.g = mtrlRed.Ambient.g = 0.0f;
    mtrlRed.Diffuse.b = mtrlRed.Ambient.b = 0.0f;
    mtrlRed.Diffuse.a = mtrlRed.Ambient.a = 0.0f;

    ZeroMemory( &mtrlGreen, sizeof(D3DMATERIAL8) );
    mtrlGreen.Diffuse.r = mtrlGreen.Ambient.r = 0.0f;
    mtrlGreen.Diffuse.g = mtrlGreen.Ambient.g = 1.0f;
    mtrlGreen.Diffuse.b = mtrlGreen.Ambient.b = 0.0f;
    mtrlGreen.Diffuse.a = mtrlGreen.Ambient.a = 0.0f;

    ZeroMemory( &mtrlBlue, sizeof(D3DMATERIAL8) );
    mtrlBlue.Diffuse.r = mtrlBlue.Ambient.r = 0.0f;
    mtrlBlue.Diffuse.g = mtrlBlue.Ambient.g = 0.0f;
    mtrlBlue.Diffuse.b = mtrlBlue.Ambient.b = 1.0f;
    mtrlBlue.Diffuse.a = mtrlBlue.Ambient.a = 0.0f;

    if( bUseTexture )
    {
        D3DCAPS8 d3dCaps;         

        // Load default texture in resource anDefaultTextureResource[i]
        if( FAILED( hr = D3DXCreateTextureFromResourceEx( pd3dDevice, NULL, TEXT("DIRECTX"), 
                                D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, d3dsdBackBuffer.Format, 
                                D3DPOOL_DEFAULT, D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR, 
                                D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR, 0, NULL, NULL, &pTexture ) ) )
        {
            *piStepThatFailed  = TESTID_CREATETEXTURE;
            goto LEnd;
        }

        if( FAILED( hr = pd3dDevice->GetDeviceCaps( &d3dCaps ) ) )
        {
            *piStepThatFailed  = TESTID_GETDEVICECAPS;
            goto LEnd;
        }

        if( d3dCaps.TextureFilterCaps & D3DPTFILTERCAPS_MINFLINEAR )
        {
            if (FAILED(hr = pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR )))
            {
                *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
                goto LEnd;
            }
	    }
    
        if( d3dCaps.TextureFilterCaps & D3DPTFILTERCAPS_MAGFLINEAR )
        {
            if (FAILED(hr = pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR )))
            {
                *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
                goto LEnd;
            }
        }

        if (FAILED( hr = pd3dDevice->SetTexture( 0, pTexture ) ) )
        {
            *piStepThatFailed = TESTID_SETTEXTURE; 
            goto LEnd;
        }

        if (FAILED(hr = pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP ) ) )
        {
            *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
            goto LEnd;
        }

        if (FAILED(hr = pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP ) ) )
        {
            *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
            goto LEnd;
        }

        if (FAILED(hr = pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE ) ) )
        {
            *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
            goto LEnd;
        }

        if (FAILED(hr = pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE ) ) )
        {
            *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
            goto LEnd;
        }

        if (FAILED(hr = pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE ) ) )
        {
            *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
            goto LEnd;
        }

        // Set color
        if( FAILED( hr = pd3dDevice->SetMaterial( &mtrlWhite ) ) )
        {
            *piStepThatFailed = TESTID_SETMATERIAL; 
            goto LEnd;
        }
    }

    if( FAILED( hr = pd3dDevice->SetVertexShader( D3DFVF_VERTEX ) ) )
    {
        *piStepThatFailed = TESTID_SETVERTEXSHADER; 
        goto LEnd;
    }

    // Here's the draw loop:
    for (i = 0; i < 600; i++)
    {
        if (PeekMessage(&msg, hwnd, WM_KEYDOWN, WM_KEYDOWN, PM_REMOVE))
        {
            *piStepThatFailed = TESTID_USER_CANCELLED;
            goto LEnd;
        }

        if( FAILED( hr = pd3dDevice->TestCooperativeLevel() ) )
        {
            *piStepThatFailed = TESTID_USER_CANCELLED;
            goto LEnd;
        }

        // Build world matrix
        D3DXMatrixRotationY( &matRotY, fRotY );
        D3DXMatrixRotationX( &matRotX, fRotX );
        D3DXMatrixMultiply( &mat, &matRotY, &matRotX );

        if( FAILED( hr = pd3dDevice->SetTransform( D3DTS_WORLD, &mat ) ) )
        {
            *piStepThatFailed = TESTID_SETTRANSFORM;
            goto LEnd;
        }

        // Clear the backbuffer
        if (FAILED(hr = pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET,
                                           0x00000000, 1.0f, 0L )))
        {
            *piStepThatFailed = TESTID_VIEWPORT_CLEAR;
            goto LEnd;
        }

        // Begin the scene
        if( FAILED(hr = pd3dDevice->BeginScene() ) )
        {
            *piStepThatFailed = TESTID_BEGINSCENE;
            goto LEnd;
        }

        // Green, Front/Back
        if( FAILED( hr = DrawTwoSides( bUseTexture, pd3dDevice, &mtrlGreen, 
                                       pVBFront, pIBFront, pVBBack, pIBBack, 
                                       piStepThatFailed ) ) ) 
            goto LEnd;


        // Red, Left/Right
        if( FAILED( hr = DrawTwoSides( bUseTexture, pd3dDevice, &mtrlRed, 
                                       pVBLeft, pIBLeft, pVBRight, pIBRight, 
                                       piStepThatFailed ) ) ) 
            goto LEnd;

        // Blue, Top/Bottom
        if( FAILED( hr = DrawTwoSides( bUseTexture, pd3dDevice, &mtrlBlue, 
                                       pVBTop, pIBTop, pVBBottom, pIBBottom, 
                                       piStepThatFailed ) ) ) 
            goto LEnd;

        // End the scene.
        if (FAILED(hr = pd3dDevice->EndScene()))
        {
            *piStepThatFailed = TESTID_ENDSCENE;
            goto LEnd;
        }

        if (FAILED(hr = pd3dDevice->Present( NULL, NULL, NULL, NULL ) ) )
        {
            *piStepThatFailed = TESTID_PRESENT;
            goto LEnd;
        }

        fRotY += 0.05f;
        fRotX += 0.02f;

        Sleep(10);
    }

LEnd:
    ShowCursor(TRUE);
    ReleasePpo(&pTexture);
    ReleasePpo(&pVBFront);
    ReleasePpo(&pIBFront);
    ReleasePpo(&pVBBack);
    ReleasePpo(&pIBBack);
    ReleasePpo(&pVBLeft);
    ReleasePpo(&pIBLeft);
    ReleasePpo(&pVBRight);
    ReleasePpo(&pIBRight);
    ReleasePpo(&pVBTop);
    ReleasePpo(&pIBTop);
    ReleasePpo(&pVBBottom);
    ReleasePpo(&pIBBottom);
    ReleasePpo(&pBackBuffer);
    ReleasePpo(&pd3dDevice);
    if (hwnd != NULL)
        SendMessage(hwnd, WM_CLOSE, 0, 0);

    return hr;
}




//-----------------------------------------------------------------------------
// Name: CreateTestWindow()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CreateTestWindow(HWND hwndMain, HWND* phwnd)
{
    static BOOL bClassRegistered = FALSE;
    WNDCLASS wndClass;
    TCHAR* pszClass = TEXT("DxDiag D3D8 Test Window"); // Don't need to localize
    HINSTANCE hInst = (HINSTANCE)GetWindowLongPtr(hwndMain, GWLP_HINSTANCE);
    TCHAR szTitle[MAX_PATH];

    if (!bClassRegistered)
    {
        ZeroMemory(&wndClass, sizeof(wndClass));
        wndClass.style = CS_HREDRAW | CS_VREDRAW;
        wndClass.lpfnWndProc = DefWindowProc;
        wndClass.cbClsExtra = 0;
        wndClass.cbWndExtra = 0;
        wndClass.hInstance = hInst;
        wndClass.hIcon = NULL;
        wndClass.hCursor = NULL;
        wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
        wndClass.lpszMenuName = NULL;
        wndClass.lpszClassName = pszClass;
        if (NULL == RegisterClass(&wndClass))
            return E_FAIL;
        bClassRegistered = TRUE;
    }

    LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
    *phwnd = CreateWindow( pszClass, szTitle, WS_OVERLAPPED, 
                           0, 0, 0, 0, hwndMain, NULL, hInst, NULL);
    if (*phwnd == NULL)
        return E_FAIL;

    ShowWindow(*phwnd, SW_SHOW);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SortModesCallback()
// Desc: Callback function for sorting display modes (used by BuildDeviceList).
//-----------------------------------------------------------------------------
static int SortModesCallback( const VOID* arg1, const VOID* arg2 )
{
    D3DDISPLAYMODE* p1 = (D3DDISPLAYMODE*)arg1;
    D3DDISPLAYMODE* p2 = (D3DDISPLAYMODE*)arg2;

    if( p1->Format > p2->Format )   return -1;
    if( p1->Format < p2->Format )   return +1;
    if( p1->Width  < p2->Width )    return -1;
    if( p1->Width  > p2->Width )    return +1;
    if( p1->Height < p2->Height )   return -1;
    if( p1->Height > p2->Height )   return +1;

    return 0;
}




//-----------------------------------------------------------------------------
// Name: SelectModeAndFormat()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT SelectModeAndFormat( DisplayInfo* pDisplayInfo, IDirect3D8* pD3D8, 
                             D3DModeInfo* pSelectedMode, D3DDEVTYPE* pSelectedDeviceType )
{
    // Enumerate all display modes on this adapter
    HRESULT        hr;
    D3DDISPLAYMODE modes[MAX_MODES];
    D3DFORMAT      formats[MAX_FORMATS];
    DWORD          dwBehavior[MAX_FORMATS];
    D3DModeInfo    confirmedModes[MAX_CONFIRMED_MODES];   

    ZeroMemory( pSelectedMode, sizeof(D3DModeInfo) );

    DWORD dwNumConfirmedModes   = 0;   
    DWORD dwNumFormats          = 0;
    DWORD dwNumModes            = 0;
    DWORD dwNumAdapterModes     = pD3D8->GetAdapterModeCount( pDisplayInfo->m_iAdapter );
    DWORD dwBestMatchMode       = 0;

    for( UINT iMode = 0; iMode < dwNumAdapterModes; iMode++ )
    {
        // Get the display mode attributes
        D3DDISPLAYMODE DisplayMode;
        if( FAILED( hr = pD3D8->EnumAdapterModes( pDisplayInfo->m_iAdapter, iMode, &DisplayMode ) ) )
        {
            pDisplayInfo->m_testResultD3D8.m_iStepThatFailed = TESTID_ENUMADAPTERMODES;
            pDisplayInfo->m_testResultD3D8.m_hr = hr;
            return hr;
        }

        // Check if the mode already exists (to filter out refresh rates)
        for( DWORD m=0L; m<dwNumModes; m++ )
        {
            if( ( modes[m].Width  == DisplayMode.Width  ) &&
                ( modes[m].Height == DisplayMode.Height ) &&
                ( modes[m].Format == DisplayMode.Format ) )
                break;
        }

        // If we found a new mode, add it to the list of modes
        if( m == dwNumModes )
        {
            modes[dwNumModes].Width       = DisplayMode.Width;
            modes[dwNumModes].Height      = DisplayMode.Height;
            modes[dwNumModes].Format      = DisplayMode.Format;
            modes[dwNumModes].RefreshRate = 0;
            dwNumModes++;

            // Check if the mode's format already exists
            for( DWORD f=0; f<dwNumFormats; f++ )
            {
                if( DisplayMode.Format == formats[f] )
                    break;
            }

            // If the format is new, add it to the list
            if( f== dwNumFormats )
                formats[dwNumFormats++] = DisplayMode.Format;
        }

        if( dwNumFormats == MAX_FORMATS || dwNumModes == MAX_MODES )
            break;
    }

    // Sort the list of display modes (by format, then width, then height)
    qsort( modes, dwNumModes, sizeof(D3DDISPLAYMODE), SortModesCallback );

    const DWORD dwNumDeviceTypes = 2;
    const D3DDEVTYPE DeviceTypes[] = { D3DDEVTYPE_HAL, D3DDEVTYPE_SW };

    // Add devices to adapter
    for( UINT iDevice = 0; iDevice < dwNumDeviceTypes; iDevice++ )
    {
        // Fill in device info
        D3DCAPS8 d3dCaps;         
        if( FAILED( hr = pD3D8->GetDeviceCaps( pDisplayInfo->m_iAdapter, DeviceTypes[iDevice], &d3dCaps ) ) )
        {
            pDisplayInfo->m_testResultD3D8.m_iStepThatFailed = TESTID_GETDEVICECAPS;
            pDisplayInfo->m_testResultD3D8.m_hr = hr;
            return hr;
        }

        // Examine each format supported by the adapter 
        for( DWORD f=0; f<dwNumFormats; f++ )
        {
            // Skip formats that cannot be used as render targets on this device
            if( FAILED( pD3D8->CheckDeviceType( pDisplayInfo->m_iAdapter, DeviceTypes[iDevice],
                                                formats[f], formats[f], FALSE ) ) )
                continue;

            // Figure out the behavior
            if( d3dCaps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT )
            {
                if( d3dCaps.DevCaps & D3DDEVCAPS_PUREDEVICE )
                {
                    dwBehavior[f] = D3DCREATE_HARDWARE_VERTEXPROCESSING |
                                    D3DCREATE_PUREDEVICE;
                }
                else
                {
                    dwBehavior[f] = D3DCREATE_HARDWARE_VERTEXPROCESSING;
                }
            }
            else
            {
                dwBehavior[f] = D3DCREATE_SOFTWARE_VERTEXPROCESSING;
            }
        }

        // Add all enumerated display modes with confirmed formats to the
        // device's list of valid modes
        for( DWORD m=0L; m<dwNumModes; m++ )
        {
            for( DWORD f=0; f<dwNumFormats; f++ )
            {
                if( modes[m].Format == formats[f] )
                {
                    // Add this mode to the device's list of valid modes
                    confirmedModes[dwNumConfirmedModes].Width      = modes[m].Width;
                    confirmedModes[dwNumConfirmedModes].Height     = modes[m].Height;
                    confirmedModes[dwNumConfirmedModes].Format     = modes[m].Format;
                    confirmedModes[dwNumConfirmedModes].dwBehavior = dwBehavior[f];
                    dwNumConfirmedModes++;
                }
            }
        }

        // Select any 640x480 mode for default (but prefer a 16-bit mode)
        for( m=0; m<dwNumConfirmedModes; m++ )
        {
            if( confirmedModes[m].Width==640 && confirmedModes[m].Height==480 )
            {
                dwBestMatchMode = m;
                if( confirmedModes[m].Format == D3DFMT_R5G6B5 ||
                    confirmedModes[m].Format == D3DFMT_X1R5G5B5 ||
                    confirmedModes[m].Format == D3DFMT_A1R5G5B5 )
                {
                    break;
                }
            }
        }

        // If valid modes were found then stop and use this device
        if( dwNumConfirmedModes > 0 )
            break;
    }

    if( dwNumConfirmedModes > 0 )
    {
        *pSelectedDeviceType = DeviceTypes[iDevice];
        *pSelectedMode = confirmedModes[dwBestMatchMode];
        return S_OK;
    }
    else
    {
        pDisplayInfo->m_testResultD3D8.m_iStepThatFailed = TESTID_NOMODEFOUND;
        pDisplayInfo->m_testResultD3D8.m_hr = E_FAIL;
        return E_FAIL;
    }
}




//-----------------------------------------------------------------------------
// Name: InitVertexBuffer()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT InitVertexBuffer( IDirect3DDevice8* pd3dDevice, const D3DVERTEX* vertexArray, 
                          DWORD dwNumVertices, LPDIRECT3DVERTEXBUFFER8* ppVB, 
                          LONG* piStepThatFailed )
{
    HRESULT hr = S_OK;
    DWORD   i;
    D3DVERTEX* vVertex = NULL;

    if( FAILED( hr = pd3dDevice->CreateVertexBuffer( dwNumVertices*sizeof(D3DVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_VERTEX,
                                                  D3DPOOL_MANAGED, ppVB ) ) )
    {
        *piStepThatFailed  = TESTID_CREATE_VERTEX_BUFFER;
        goto LEnd;
    }
    if( *ppVB == NULL )
    {
        *piStepThatFailed  = TESTID_CREATE_VERTEX_BUFFER;
        hr = E_POINTER;
        goto LEnd;
    }

    if( FAILED( hr = (*ppVB)->Lock( 0, 0, (BYTE**)&vVertex, 0 ) ) )
    {
        *piStepThatFailed  = TESTID_LOCK;
        goto LEnd;
    }
    if( vVertex == NULL )
    {
        *piStepThatFailed  = TESTID_LOCK;
        goto LEnd;
    }

    for( i=0; i<dwNumVertices; i++ )
        vVertex[i] = vertexArray[i];

    if( FAILED( hr = (*ppVB)->Unlock() ) )
    {
        *piStepThatFailed = TESTID_UNLOCK;
        goto LEnd;
    }

LEnd:
    return hr;
}




//-----------------------------------------------------------------------------
// Name: InitIndexBuffer()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT InitIndexBuffer( IDirect3DDevice8* pd3dDevice, const WORD* wIndexArray, 
                         DWORD dwNumIndices, LPDIRECT3DINDEXBUFFER8* ppIB, 
                         LONG* piStepThatFailed )
{
    HRESULT hr = S_OK;
    DWORD   i;
    WORD*   pwIndices = NULL;

    if( FAILED( hr = pd3dDevice->CreateIndexBuffer( dwNumIndices*sizeof(WORD),
                                                    D3DUSAGE_WRITEONLY, D3DFMT_INDEX16,
                                                    D3DPOOL_MANAGED, ppIB ) ) )
    {
        *piStepThatFailed  = TESTID_CREATE_INDEX_BUFFER;
        goto LEnd;
    }
    if( *ppIB == NULL )
    {
        *piStepThatFailed  = TESTID_CREATE_INDEX_BUFFER;
        hr = E_POINTER;
        goto LEnd;
    }

    if( FAILED( hr = (*ppIB)->Lock( 0, dwNumIndices*sizeof(WORD), (BYTE**) &pwIndices, 0 ) ) )
    {
        *piStepThatFailed  = TESTID_LOCK;
        goto LEnd;
    }
    if( pwIndices == NULL )
    {
        *piStepThatFailed  = TESTID_LOCK;
        goto LEnd;
    }

    for( i=0; i<dwNumIndices; i++ )
        *pwIndices++ = wIndexArray[i];

    if( FAILED( hr = (*ppIB)->Unlock() ) )
    {
        *piStepThatFailed = TESTID_UNLOCK;
        goto LEnd;
    }

LEnd:
    return hr;
}




//-----------------------------------------------------------------------------
// Name: DrawTwoSides()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DrawTwoSides( BOOL bUseTexture, IDirect3DDevice8* pd3dDevice, D3DMATERIAL8* pMtrl, 
                      LPDIRECT3DVERTEXBUFFER8 pVB1, LPDIRECT3DINDEXBUFFER8 pIB1, 
                      LPDIRECT3DVERTEXBUFFER8 pVB2, LPDIRECT3DINDEXBUFFER8 pIB2, 
                      LONG* piStepThatFailed )
{   
    HRESULT hr;

    if( !bUseTexture )
    {
        // Set color
        if( FAILED( hr = pd3dDevice->SetMaterial( pMtrl ) ) )
        {
            *piStepThatFailed = TESTID_SETMATERIAL; 
            goto LEnd;
        }
    }

    // #1
    if( FAILED( hr = pd3dDevice->SetStreamSource( 0, pVB1, sizeof(D3DVERTEX) ) ) )
    {
        *piStepThatFailed = TESTID_SETSTREAMSOURCE; 
        goto LEnd;
    }

    if( FAILED( hr = pd3dDevice->SetIndices( pIB1, 0 ) ) )
    {
        *piStepThatFailed = TESTID_SETINDICES; 
        goto LEnd;
    }

    if( FAILED( hr = pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, 4, 0, 2 ) ) )
    {
        *piStepThatFailed = TESTID_DRAW_INDEXED_PRIMITIVE; 
        goto LEnd;
    }

    // #2
    if( FAILED( hr = pd3dDevice->SetStreamSource( 0, pVB2, sizeof(D3DVERTEX) ) ) ) 
    {
        *piStepThatFailed = TESTID_SETSTREAMSOURCE; 
        goto LEnd;
    }

    if( FAILED( hr = pd3dDevice->SetIndices( pIB2, 0 ) ) )
    {
        *piStepThatFailed = TESTID_SETINDICES; 
        goto LEnd;
    }

    if( FAILED( hr = pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, 4, 0, 2 ) ) )
    {
        *piStepThatFailed = TESTID_DRAW_INDEXED_PRIMITIVE; 
        goto LEnd;
    }

LEnd:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\testdd.h ===
/****************************************************************************
 *
 *    File: testdd.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Test DirectDraw functionality on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef TESTDD_H
#define TESTDD_H

VOID TestDD(HWND hwndMain, DisplayInfo* pDisplayInfo);


#endif // TESTDD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\testmus.h ===
/****************************************************************************
 *
 *    File: testmus.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Test DMusic functionality on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef TESTMUS_H
#define TESTMUS_H

VOID TestMusic(HWND hwndMain, MusicInfo* pMusicInfo);


#endif // TESTMUS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\testd3d8.h ===
/****************************************************************************
 *
 *    File: testd3d8.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Jason Sandlin (jasonsa@microsoft.com)
 * Purpose: Test D3D8/AGP Texturing functionality on this machine
 *
 * (C) Copyright 2000 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef TESTD3D8_H
#define TESTD3D8_H

VOID TestD3Dv8(BOOL bUseTexture, HWND hwndMain, DisplayInfo* pDisplayInfo);


#endif // TESTD3D8_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\testdd.cpp ===
/****************************************************************************
 *
 *    File: testdd.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Test DirectDraw functionality on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <Windows.h>
#define DIRECTDRAW_VERSION 5 // run on DX5 and later versions
#include <ddraw.h>
#include "reginfo.h"
#include "sysinfo.h"
#include "dispinfo.h"
#include "testdd.h"
#include "resource.h"

#ifndef ReleasePpo
    #define ReleasePpo(ppo) \
        if (*(ppo) != NULL) \
        { \
            (*(ppo))->Release(); \
            *(ppo) = NULL; \
        } \
        else (VOID)0
#endif

enum TESTID
{
    TESTID_LOAD_DDRAW_DLL= 1,
    TESTID_GET_DIRECTDRAWCREATE,
    TESTID_DIRECTDRAWCREATE,
    TESTID_GETCAPS,
    TESTID_USER_VERIFY_RECTANGLES,
    TESTID_USER_VERIFY_WINDOW_BOUNCE,
    TESTID_USER_VERIFY_FULLSCREEN_BOUNCE,
    TESTID_SETCOOPERATIVELEVEL_NORMAL,
    TESTID_CREATEPRIMARYSURFACE,
    TESTID_GETPRIMARYSURFACEDESC,
    TESTID_COLORFILL_BLT_TO_PRIMARY,
    TESTID_CREATE_OFFSCREENPLAIN_SURFACE,
    TESTID_COLORFILL_BLT_TO_OFFSCREENPLAIN,
    TESTID_BLT_OFFSCREENPLAIN_TO_FRONT,
    TESTID_CREATE_TEST_WINDOW,
    TESTID_SETCOOPERATIVELEVEL_FULLSCREEN,
    TESTID_SETDISPLAYMODE,
    TESTID_CREATEPRIMARYSURFACE_FLIP_ONEBACK,
    TESTID_GETATTACHEDSURFACE,
    TESTID_COLORFILL_TO_BACKBUFFER,
    TESTID_FLIP,
};

typedef HRESULT (WINAPI* LPDIRECTDRAWCREATE)(GUID FAR *lpGUID,
    LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter);


BOOL BTranslateError(HRESULT hr, TCHAR* psz, BOOL bEnglish = FALSE); // from main.cpp (yuck)


static HRESULT TestPrimary(HWND hwndMain, LPDIRECTDRAW pdd, LONG* piStepThatFailed);
static HRESULT TestPrimaryBlt(HWND hwndMain, LPDIRECTDRAW pdd, LONG* piStepThatFailed);
static HRESULT TestFullscreen(HWND hwndMain, LPDIRECTDRAW pdd, LONG* piStepThatFailed);
static HRESULT CreateTestWindow(HWND hwndMain, HWND* phwnd);


/****************************************************************************
 *
 *  TestDD
 *
 ****************************************************************************/
VOID TestDD(HWND hwndMain, DisplayInfo* pDisplayInfo)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];
    HINSTANCE hInstDDraw = NULL;
    LPDIRECTDRAWCREATE pDDCreate;
    LPDIRECTDRAW pdd = NULL;
    TCHAR sz[300];
    TCHAR szTitle[100];

    LoadString(NULL, IDS_STARTDDTEST, sz, 300);
    LoadString(NULL, IDS_APPFULLNAME, szTitle, 100);

    if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
        return;

    // Remove info from any previous test:
    ZeroMemory(&pDisplayInfo->m_testResultDD, sizeof(TestResult));

    pDisplayInfo->m_testResultDD.m_bStarted = TRUE;

    // Load ddraw.dll
    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\ddraw.dll"));
    hInstDDraw = LoadLibrary(szPath);
    if (hInstDDraw == NULL)
    {
        pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_LOAD_DDRAW_DLL;
        pDisplayInfo->m_testResultDD.m_hr = DDERR_NOTFOUND;
        goto LEnd;
    }

    // Get DirectDrawCreate entry point
    pDDCreate = (LPDIRECTDRAWCREATE)GetProcAddress(hInstDDraw, "DirectDrawCreate");
    if (pDDCreate == NULL)
    {
        pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_GET_DIRECTDRAWCREATE;
        pDisplayInfo->m_testResultDD.m_hr = DDERR_NOTFOUND;
        goto LEnd;
    }
        
    // Call DirectDrawCreate
    if (FAILED(hr = pDDCreate(&pDisplayInfo->m_guid, &pdd, NULL)))
    {
        pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_DIRECTDRAWCREATE;
        pDisplayInfo->m_testResultDD.m_hr = hr;
        goto LEnd;
    }

    // Get DirectDraw caps
    DDCAPS ddcaps;
    DDCAPS ddcaps2;
    ddcaps.dwSize = sizeof(ddcaps);
    ddcaps2.dwSize = sizeof(ddcaps2);
    if (FAILED(hr = pdd->GetCaps(&ddcaps, &ddcaps2)))
    {
        pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_GETCAPS;
        pDisplayInfo->m_testResultDD.m_hr = hr;
        goto LEnd;
    }
    ReleasePpo(&pdd);

    if (!pDisplayInfo->m_bCanRenderWindow)
    {
        LoadString(NULL, IDS_SKIPWINDOWED, sz, 300);
        MessageBox(hwndMain, sz, szTitle, MB_OK);
    }
    else
    {
        // First test
        LoadString(NULL, IDS_DDTEST1, sz, 300);
        if (IDCANCEL == MessageBox(hwndMain, sz, szTitle, MB_OKCANCEL))
        {
            pDisplayInfo->m_testResultDD.m_bCancelled = TRUE;
            goto LEnd;
        }
        if (FAILED(hr = pDDCreate(&pDisplayInfo->m_guid, &pdd, NULL)))
        {
            pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_DIRECTDRAWCREATE;
            pDisplayInfo->m_testResultDD.m_hr = hr;
            goto LEnd;
        }
        if (FAILED(hr = TestPrimary(hwndMain, pdd, &pDisplayInfo->m_testResultDD.m_iStepThatFailed)))
        {
            pDisplayInfo->m_testResultDD.m_hr = hr;
            goto LEnd;
        }
        ReleasePpo(&pdd);
        LoadString(NULL, IDS_CONFIRMDDTEST1, sz, 300);
        if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
        {
            pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_USER_VERIFY_RECTANGLES;
            pDisplayInfo->m_testResultDD.m_hr = S_OK;
            goto LEnd;
        }

        // Second test
        LoadString(NULL, IDS_DDTEST2, sz, 300);
        if (IDCANCEL == MessageBox(hwndMain, sz, szTitle, MB_OKCANCEL))
        {
            pDisplayInfo->m_testResultDD.m_bCancelled = TRUE;
            goto LEnd;
        }
        if (FAILED(hr = pDDCreate(&pDisplayInfo->m_guid, &pdd, NULL)))
        {
            pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_DIRECTDRAWCREATE;
            pDisplayInfo->m_testResultDD.m_hr = hr;
            goto LEnd;
        }
        if (FAILED(hr = TestPrimaryBlt(hwndMain, pdd, &pDisplayInfo->m_testResultDD.m_iStepThatFailed)))
        {
            pDisplayInfo->m_testResultDD.m_hr = hr;
            goto LEnd;
        }
        ReleasePpo(&pdd);
        LoadString(NULL, IDS_CONFIRMDDTEST2, sz, 300);
        if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
        {
            pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_USER_VERIFY_WINDOW_BOUNCE;
            pDisplayInfo->m_testResultDD.m_hr = S_OK;
        }
    }

    // Third test
    LoadString(NULL, IDS_DDTEST3, sz, 300);
    if (IDCANCEL == MessageBox(hwndMain, sz, szTitle, MB_OKCANCEL))
    {
        pDisplayInfo->m_testResultDD.m_bCancelled = TRUE;
        goto LEnd;
    }
    if (FAILED(hr = pDDCreate(&pDisplayInfo->m_guid, &pdd, NULL)))
    {
        pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_DIRECTDRAWCREATE;
        pDisplayInfo->m_testResultDD.m_hr = hr;
        goto LEnd;
    }
    POINT ptMouse;
    GetCursorPos(&ptMouse);
    if (FAILED(hr = TestFullscreen(hwndMain, pdd, &pDisplayInfo->m_testResultDD.m_iStepThatFailed)))
    {
        pDisplayInfo->m_testResultDD.m_hr = hr;
        goto LEnd;
    }
    SetCursorPos( ptMouse.x, ptMouse.y );
    ReleasePpo(&pdd);
    LoadString(NULL, IDS_CONFIRMDDTEST3, sz, 300);
    if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
    {
        pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_USER_VERIFY_FULLSCREEN_BOUNCE;
        pDisplayInfo->m_testResultDD.m_hr = S_OK;
        goto LEnd;
    }

    LoadString(NULL, IDS_ENDDDTESTS, sz, 300);
    MessageBox(hwndMain, sz, szTitle, MB_OK);

LEnd:
    ReleasePpo(&pdd);
    if (hInstDDraw != NULL)
        FreeLibrary(hInstDDraw);
    if (pDisplayInfo->m_testResultDD.m_bCancelled)
    {
        LoadString(NULL, IDS_TESTSCANCELLED, sz, 300);
        lstrcpy(pDisplayInfo->m_testResultDD.m_szDescription, sz);

        LoadString(NULL, IDS_TESTSCANCELLED_ENGLISH, sz, 300);
        lstrcpy(pDisplayInfo->m_testResultDD.m_szDescription, sz);
    }
    else
    {
        if (pDisplayInfo->m_testResultDD.m_iStepThatFailed == 0)
        {
            LoadString(NULL, IDS_TESTSSUCCESSFUL, sz, 300);
            lstrcpy(pDisplayInfo->m_testResultDD.m_szDescription, sz);

            LoadString(NULL, IDS_TESTSSUCCESSFUL_ENGLISH, sz, 300);
            lstrcpy(pDisplayInfo->m_testResultDD.m_szDescriptionEnglish, sz);
        }
        else
        {
            TCHAR szDesc[200];
            TCHAR szError[200];
            if (0 == LoadString(NULL, IDS_FIRSTDDTESTERROR + pDisplayInfo->m_testResultDD.m_iStepThatFailed - 1,
                szDesc, 200))
            {
                LoadString(NULL, IDS_UNKNOWNERROR, sz, 300);
                lstrcpy(szDesc, sz);
            }
            LoadString(NULL, IDS_FAILUREFMT, sz, 300);
            BTranslateError(pDisplayInfo->m_testResultDD.m_hr, szError);
            wsprintf(pDisplayInfo->m_testResultDD.m_szDescription, sz,
                pDisplayInfo->m_testResultDD.m_iStepThatFailed,
                szDesc, pDisplayInfo->m_testResultDD.m_hr, szError);

            // Nonlocalized version:
            if (0 == LoadString(NULL, IDS_FIRSTDDTESTERROR_ENGLISH + pDisplayInfo->m_testResultDD.m_iStepThatFailed - 1,
                szDesc, 200))
            {
                LoadString(NULL, IDS_UNKNOWNERROR_ENGLISH, sz, 300);
                lstrcpy(szDesc, sz);
            }
            LoadString(NULL, IDS_FAILUREFMT_ENGLISH, sz, 300);
            BTranslateError(pDisplayInfo->m_testResultDD.m_hr, szError, TRUE);
            wsprintf(pDisplayInfo->m_testResultDD.m_szDescriptionEnglish, sz,
                pDisplayInfo->m_testResultDD.m_iStepThatFailed,
                szDesc, pDisplayInfo->m_testResultDD.m_hr, szError);
        }
    }
}


/****************************************************************************
 *
 *  TestPrimary
 *
 ****************************************************************************/
HRESULT TestPrimary(HWND hwndMain, LPDIRECTDRAW pdd, LONG* piStepThatFailed)
{
    HRESULT hr = S_OK;
    DDSURFACEDESC ddsd;
    LPDIRECTDRAWSURFACE pdds = NULL;
    RECT rc;

    if (FAILED(hr = pdd->SetCooperativeLevel(NULL, DDSCL_NORMAL)))
    {
        *piStepThatFailed = TESTID_SETCOOPERATIVELEVEL_NORMAL;
        goto LEnd;
    }

    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
    if (FAILED(hr = pdd->CreateSurface(&ddsd, &pdds, NULL)))
    {
        *piStepThatFailed = TESTID_CREATEPRIMARYSURFACE;
        goto LEnd;
    }
    ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
    if (FAILED(hr = pdds->GetSurfaceDesc(&ddsd)))
    {
        *piStepThatFailed = TESTID_GETPRIMARYSURFACEDESC;
        goto LEnd;
    }
    SetRect(&rc, 0, 0, ddsd.dwWidth, ddsd.dwHeight);
    InflateRect(&rc, -64, -64);

    DDBLTFX ddbltfx;
    ZeroMemory(&ddbltfx, sizeof(ddbltfx));
    ddbltfx.dwSize = sizeof(ddbltfx);
    while (rc.right > rc.left + 2 && rc.bottom > rc.top + 2)
    {
        ddbltfx.dwFillColor = ~ddbltfx.dwFillColor;
        if (FAILED(hr = pdds->Blt(&rc, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx)))
        {
            *piStepThatFailed = TESTID_COLORFILL_BLT_TO_PRIMARY;
            goto LEnd;
        }
        InflateRect(&rc, -4, -4);
    }

    // Give the user a moment to verify the test pattern
    Sleep(2000);

    // Clean up affected screen area in case this display isn't part of the desktop:
    ddbltfx.dwFillColor = 0;
    if (FAILED(hr = pdds->Blt(NULL, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx)))
    {
        *piStepThatFailed = TESTID_COLORFILL_BLT_TO_PRIMARY;
        goto LEnd;
    }

LEnd:
    ReleasePpo(&pdds);
    InvalidateRect(NULL, NULL, FALSE); // repaint desktop
    return hr;
}


/****************************************************************************
 *
 *  TestPrimaryBlt
 *
 ****************************************************************************/
HRESULT TestPrimaryBlt(HWND hwndMain, LPDIRECTDRAW pdd, LONG* piStepThatFailed)
{
    HRESULT hr = S_OK;
    DDSURFACEDESC ddsd;
    LPDIRECTDRAWSURFACE pddsFront = NULL;
    LPDIRECTDRAWSURFACE pddsBack = NULL;
    RECT rc;
    RECT rcDest;
    RECT rcScreen;
    DDBLTFX ddbltfx;
    INT i;
    LONG xv = 1;
    LONG yv = 2;

    if (FAILED(hr = pdd->SetCooperativeLevel(NULL, DDSCL_NORMAL)))
    {
        *piStepThatFailed = TESTID_SETCOOPERATIVELEVEL_NORMAL;
        goto LEnd;
    }

    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
    if (FAILED(hr = pdd->CreateSurface(&ddsd, &pddsFront, NULL)))
    {
        *piStepThatFailed = TESTID_CREATEPRIMARYSURFACE;
        goto LEnd;
    }
    ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT;
    if (FAILED(hr = pddsFront->GetSurfaceDesc(&ddsd)))
    {
        *piStepThatFailed = TESTID_GETPRIMARYSURFACEDESC;
        goto LEnd;
    }
    SetRect(&rcScreen, 0, 0, ddsd.dwWidth, ddsd.dwHeight);

    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
    ddsd.dwWidth = 200;
    ddsd.dwHeight = 200;
    if (FAILED(hr = pdd->CreateSurface(&ddsd, &pddsBack, NULL)))
    {
        *piStepThatFailed = TESTID_CREATE_OFFSCREENPLAIN_SURFACE;
        goto LEnd;
    }

    SetRect(&rc, 0, 0, 32, 32);
    OffsetRect(&rc, 10, 35);

    ZeroMemory(&ddbltfx, sizeof(ddbltfx));
    ddbltfx.dwSize = sizeof(ddbltfx);
    for (i = 0; i < 200; i++)
    {
        ddbltfx.dwFillColor = 0;
        if (FAILED(hr = pddsBack->Blt(NULL, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx)))
        {
            *piStepThatFailed = TESTID_COLORFILL_BLT_TO_OFFSCREENPLAIN;
            goto LEnd;
        }
        OffsetRect(&rc, xv, yv);
        if (rc.left < 2 && xv < 0 || rc.right > 198 && xv > 0)
            xv = -xv;
        if (rc.top < 2 && yv < 0 || rc.bottom > 198 && yv > 0)
            yv = -yv;
        ddbltfx.dwFillColor = 0xffffffff;
        if (FAILED(hr = pddsBack->Blt(&rc, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx)))
        {
            *piStepThatFailed = TESTID_COLORFILL_BLT_TO_OFFSCREENPLAIN;
            goto LEnd;
        }
        SetRect(&rcDest, 0, 0, 200, 200);
        OffsetRect(&rcDest, (rcScreen.right - 200) / 2, (rcScreen.bottom - 200) / 2);
        if (FAILED(hr = pddsFront->Blt(&rcDest, pddsBack, NULL, DDBLT_WAIT, NULL)))
        {
            *piStepThatFailed = TESTID_BLT_OFFSCREENPLAIN_TO_FRONT;
            goto LEnd;
        }
        Sleep(2);
    }

    // Clean up affected screen area in case this display isn't part of the desktop:
    ddbltfx.dwFillColor = 0;
    if (FAILED(hr = pddsFront->Blt(&rc, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx)))
    {
        *piStepThatFailed = TESTID_COLORFILL_BLT_TO_PRIMARY;
        goto LEnd;
    }

LEnd:
    InvalidateRect(NULL, NULL, FALSE); // repaint desktop
    ReleasePpo(&pddsBack);
    ReleasePpo(&pddsFront);
    return hr;
}


/****************************************************************************
 *
 *  TestFullscreen
 *
 ****************************************************************************/
HRESULT TestFullscreen(HWND hwndMain, LPDIRECTDRAW pdd, LONG* piStepThatFailed)
{
    HRESULT hr;
    HWND hwnd = NULL;
    DDSURFACEDESC ddsd;
    LPDIRECTDRAWSURFACE pddsFront = NULL;
    LPDIRECTDRAWSURFACE pddsBack = NULL;
    RECT rc;
    RECT rcScreen;
    DDBLTFX ddbltfx;
    BOOL bDisplayModeSet = FALSE;
    INT i;
    LONG xv = 1;
    LONG yv = 2;

    ShowCursor(FALSE);

    if (FAILED(hr = CreateTestWindow(hwndMain, &hwnd)))
    {
        *piStepThatFailed = TESTID_CREATE_TEST_WINDOW;
        goto LEnd;
    }

    if (FAILED(hr = pdd->SetCooperativeLevel(hwnd, 
        DDSCL_ALLOWREBOOT | DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN)))
    {
        *piStepThatFailed = TESTID_SETCOOPERATIVELEVEL_FULLSCREEN;
        goto LEnd;
    }

    if (FAILED(hr = pdd->SetDisplayMode(640, 480, 16)))
    {
        TCHAR szMessage[300];
        TCHAR szTitle[100];
        pdd->SetCooperativeLevel(hwnd, DDSCL_NORMAL);
        SendMessage(hwnd, WM_CLOSE, 0, 0);
        LoadString(NULL, IDS_SETDISPLAYMODEFAILED, szMessage, 300);
        LoadString(NULL, IDS_APPFULLNAME, szTitle, 100);
        MessageBox(hwndMain, szMessage, szTitle, MB_OK);
        *piStepThatFailed = TESTID_SETDISPLAYMODE;
        goto LEnd;
    }
    bDisplayModeSet = TRUE;

    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_FLIP | DDSCAPS_COMPLEX;
    ddsd.dwBackBufferCount = 1;
    if (FAILED(hr = pdd->CreateSurface(&ddsd, &pddsFront, NULL)))
    {
        *piStepThatFailed = TESTID_CREATEPRIMARYSURFACE_FLIP_ONEBACK;
        goto LEnd;
    }
    ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT;
    if (FAILED(hr = pddsFront->GetSurfaceDesc(&ddsd)))
    {
        *piStepThatFailed = TESTID_GETPRIMARYSURFACEDESC;
        goto LEnd;
    }
    SetRect(&rcScreen, 0, 0, ddsd.dwWidth, ddsd.dwHeight);

    ZeroMemory(&ddbltfx, sizeof(ddbltfx));
    ddbltfx.dwSize = sizeof(ddbltfx);

    DDSCAPS ddscaps;
    ddscaps.dwCaps = DDSCAPS_BACKBUFFER;
    if (FAILED(hr = pddsFront->GetAttachedSurface(&ddscaps, &pddsBack)))
    {
        *piStepThatFailed = TESTID_GETATTACHEDSURFACE;
        goto LEnd;
    }

    SetRect(&rc, 0, 0, 32, 32);
    OffsetRect(&rc, 10, 35);

    ZeroMemory(&ddbltfx, sizeof(ddbltfx));
    ddbltfx.dwSize = sizeof(ddbltfx);
    for (i = 0; i < 200; i++)
    {
        ddbltfx.dwFillColor = 0;
        if (FAILED(hr = pddsBack->Blt(NULL, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx)))
        {
            *piStepThatFailed = TESTID_COLORFILL_TO_BACKBUFFER;
            goto LEnd;
        }
        OffsetRect(&rc, xv, yv);
        if (rc.left < 2 && xv < 0 || rc.right > 198 && xv > 0)
            xv = -xv;
        if (rc.top < 2 && yv < 0 || rc.bottom > 198 && yv > 0)
            yv = -yv;
        OffsetRect(&rc, (rcScreen.right - 200) / 2, (rcScreen.bottom - 200) / 2);
        ddbltfx.dwFillColor = 0xffffffff;
        if (FAILED(hr = pddsBack->Blt(&rc, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx)))
        {
            *piStepThatFailed = TESTID_COLORFILL_TO_BACKBUFFER;
            goto LEnd;
        }
        OffsetRect(&rc, -(rcScreen.right - 200) / 2, -(rcScreen.bottom - 200) / 2);
        if (FAILED(hr = pddsFront->Flip(NULL, DDFLIP_WAIT)))
        {
            *piStepThatFailed = TESTID_FLIP;
            goto LEnd;
        }
        Sleep(2);
    }

    ddbltfx.dwFillColor = 0;
    if (FAILED(hr = pddsFront->Blt(&rc, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx)))
    {
        *piStepThatFailed = TESTID_COLORFILL_BLT_TO_PRIMARY;
        goto LEnd;
    }

LEnd:
    ShowCursor(TRUE);
    ReleasePpo(&pddsBack);
    ReleasePpo(&pddsFront);
    if (FAILED(hr))
    {
        // Something has already failed, so report that failure
        // rather than any failure of SetCooperativeLevel
        pdd->SetCooperativeLevel(hwnd, DDSCL_NORMAL);
    }
    else
    {
        if (FAILED(hr = pdd->SetCooperativeLevel(hwnd, DDSCL_NORMAL)))
        {
            *piStepThatFailed = TESTID_SETCOOPERATIVELEVEL_NORMAL;
        }
    }
    if (hwnd != NULL)
        SendMessage(hwnd, WM_CLOSE, 0, 0);
    if (bDisplayModeSet)
    {
        if (FAILED(hr))
        {
            // Something has already failed, so report that failure
            // rather than any failure of RestoreDisplayMode
            pdd->RestoreDisplayMode();
        }
        else
        {
            // Nothing has failed yet, so report any failure of RestoreDisplayMode
            if (FAILED(hr = pdd->RestoreDisplayMode()))
                return hr;
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  CreateTestWindow
 *
 ****************************************************************************/
HRESULT CreateTestWindow(HWND hwndMain, HWND* phwnd)
{
    static BOOL bClassRegistered = FALSE;
    WNDCLASS wndClass;
    TCHAR* pszClass = TEXT("DxDiag Test Window"); // Don't need to localize
    HINSTANCE hInst = (HINSTANCE)GetWindowLongPtr(hwndMain, GWLP_HINSTANCE);
    TCHAR szTitle[200];

    if (!bClassRegistered)
    {
        ZeroMemory(&wndClass, sizeof(wndClass));
        wndClass.style = CS_HREDRAW | CS_VREDRAW;
        wndClass.lpfnWndProc = DefWindowProc;
        wndClass.cbClsExtra = 0;
        wndClass.cbWndExtra = 0;
        wndClass.hInstance = hInst;
        wndClass.hIcon = NULL;
        wndClass.hCursor = NULL;
        wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
        wndClass.lpszMenuName = NULL;
        wndClass.lpszClassName = pszClass;
        if (NULL == RegisterClass(&wndClass))
            return E_FAIL;
        bClassRegistered = TRUE;
    }

    LoadString(NULL, IDS_APPFULLNAME, szTitle, 200);
    *phwnd = CreateWindow(pszClass, szTitle, WS_OVERLAPPED, 
        0, 0, 0, 0, hwndMain, NULL, hInst, NULL);
    if (*phwnd == NULL)
        return E_FAIL;

    ShowWindow(*phwnd, SW_SHOW);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\testmus.cpp ===
/****************************************************************************
 *
 *    File: testmus.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Test DMusic functionality on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <Windows.h>
#include <multimon.h>
#include <dmusicc.h>
#include <dmusici.h>
#include "reginfo.h"
#include "sysinfo.h"
#include "dispinfo.h"
#include "musinfo.h"
#include "testmus.h"
#include "resource.h"

#ifndef ReleasePpo
    #define ReleasePpo(ppo) \
        if (*(ppo) != NULL) \
        { \
            (*(ppo))->Release(); \
            *(ppo) = NULL; \
        } \
        else (VOID)0
#endif

enum TESTID
{
    TESTID_COINITIALIZE = 1,
    TESTID_CREATEDMLOADER,
    TESTID_CREATEDMPERF,
    TESTID_INITPERF,
    TESTID_CREATEPORT,
    TESTID_ACTIVATEPORT,
    TESTID_SETAUTODOWNLOAD,
    TESTID_ADDPORT,
    TESTID_ASSIGNPCHANNELBLOCK,
    TESTID_SPEWRESOURCETOFILE,
    TESTID_SETSEARCHDIRECTORY,
    TESTID_LOADERGETOBJECT,
    TESTID_PLAYSEGMENT,
};

BOOL BTranslateError(HRESULT hr, TCHAR* psz, BOOL bEnglish = FALSE); // from main.cpp (yuck)

static HRESULT SpewResourceToFile(TCHAR* pszResType, LONG idRes, TCHAR* pszFileName);
static HRESULT LoadSegment( BOOL fUseCWD );
static VOID DeleteTempFile(TCHAR* pszFileName);


/****************************************************************************
 *
 *  TestMusic
 *
 ****************************************************************************/
VOID TestMusic(HWND hwndMain, MusicInfo* pMusicInfo)
{
    HRESULT hr;
    MusicPort* pMusicPort = NULL;
    IDirectMusicLoader* pLoader = NULL;
    IDirectMusicPerformance* pPerformance = NULL;
    IDirectMusic* pdm = NULL;
    IDirectMusicPort* pPort = NULL;
    IDirectMusicSegment* pSegment = NULL;
    BOOL bComInitialized = FALSE;
    TCHAR szFmt[300];
    TCHAR sz[300];
    TCHAR szTitle[100];

    if (pMusicInfo == NULL)
        return;

    // Determine pMusicPort of port to test:
    for (pMusicPort = pMusicInfo->m_pMusicPortFirst; pMusicPort != NULL; pMusicPort = pMusicPort->m_pMusicPortNext)
    {
        if (pMusicPort->m_guid == pMusicInfo->m_guidMusicPortTest)
            break;
    }
    if (pMusicPort == NULL)
        return;

    LoadString(NULL, IDS_APPFULLNAME, szTitle, 100);
    LoadString(NULL, IDS_STARTDMUSICTEST, szFmt, 300);
    wsprintf(sz, szFmt, pMusicPort->m_szDescription);
    if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
        return;

    // Remove info from any previous test:
    ZeroMemory(&pMusicInfo->m_testResult, sizeof(TestResult));

    pMusicInfo->m_testResult.m_bStarted = TRUE;

    // Initialize COM
    if (FAILED(hr = CoInitialize(NULL)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_COINITIALIZE;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }
    bComInitialized = TRUE;

    // Create performance object
    if (FAILED(hr = CoCreateInstance(CLSID_DirectMusicPerformance, NULL,
        CLSCTX_INPROC, IID_IDirectMusicPerformance, (VOID**)&pPerformance)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_CREATEDMPERF;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Initialize the performance -- also creates DirectMusic object
    if (FAILED(hr = pPerformance->Init(&pdm, NULL, hwndMain)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_INITPERF;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Create a port using the user-specified GUID
    DMUS_PORTPARAMS portParams;
    ZeroMemory(&portParams, sizeof(portParams));
    portParams.dwSize = sizeof(portParams);
    portParams.dwValidParams = DMUS_PORTPARAMS_EFFECTS | DMUS_PORTPARAMS_CHANNELGROUPS | 
        DMUS_PORTPARAMS_AUDIOCHANNELS;
    portParams.dwEffectFlags = DMUS_EFFECT_REVERB;
    portParams.dwChannelGroups = pMusicPort->m_dwMaxChannelGroups;
    portParams.dwAudioChannels = pMusicPort->m_dwMaxAudioChannels;
    if (FAILED(hr = pdm->CreatePort(pMusicPort->m_guid, &portParams, &pPort, NULL)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_CREATEPORT;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Activate the port
    if (FAILED(hr = pPort->Activate(TRUE)))
    {
        // Bug 21677: catch case where user has no sound card
        if (hr == DSERR_NODRIVER && !pMusicPort->m_bExternal)
        {
            LoadString(NULL, IDS_NOSOUNDDRIVER, sz, 300);
            MessageBox(hwndMain, sz, szTitle, MB_OK);
        }
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_ACTIVATEPORT;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Set autodownloading to be on
    BOOL fAutoDownload;
    fAutoDownload = TRUE;
    if (FAILED(hr = pPerformance->SetGlobalParam(GUID_PerfAutoDownload, 
        &fAutoDownload, sizeof(BOOL))))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_SETAUTODOWNLOAD;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Add the port to the performance
    if (FAILED(hr = pPerformance->AddPort(pPort)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_ADDPORT;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    if (FAILED(hr = pPerformance->AssignPChannelBlock(0, pPort, 1)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_ASSIGNPCHANNELBLOCK;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    if (FAILED(hr = SpewResourceToFile(TEXT("SGMT"), IDR_TSTSGMT, TEXT("Edge.sgt"))))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_SPEWRESOURCETOFILE;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    if (FAILED(hr = SpewResourceToFile(TEXT("STYL"), IDR_TSTSTYL, TEXT("Edge.sty"))))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_SPEWRESOURCETOFILE;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Create loader object
    if (FAILED(hr = CoCreateInstance(CLSID_DirectMusicLoader, NULL, 
        CLSCTX_INPROC, IID_IDirectMusicLoader, (VOID**)&pLoader)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_CREATEDMLOADER;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Set search path to temp dir to find segment and style:
    WCHAR wszDir[MAX_PATH];
    TCHAR szTempPath[MAX_PATH];
    GetTempPath(MAX_PATH, szTempPath);
    szTempPath[lstrlen(szTempPath) - 1] = '\0';
#ifdef UNICODE
    lstrcpy(wszDir, szTempPath);
#else
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szTempPath, -1, wszDir, MAX_PATH);
#endif
    if (FAILED(hr = pLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, wszDir, FALSE)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_SETSEARCHDIRECTORY;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Load the segment
    // now load the segment file.
    // sections load as type Segment, as do MIDI files, for example.
    DMUS_OBJECTDESC objDesc; // Object descriptor for pLoader->GetObject()
    objDesc.guidClass = CLSID_DirectMusicSegment;
    objDesc.dwSize = sizeof(DMUS_OBJECTDESC);
    wcscpy(objDesc.wszFileName, L"edge.sgt");
    objDesc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME;
    if (FAILED(hr = pLoader->GetObject(&objDesc, IID_IDirectMusicSegment, (VOID**)&pSegment)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_LOADERGETOBJECT;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Play the segment and wait. The DMUS_SEGF_BEAT indicates to play on the 
    // next beat if there is a segment currently playing. The first 0 indicates 
    // to play (on the next beat from) now.
    // The final NULL means do not return an IDirectMusicSegmentState* in
    // the last parameter.
    if (FAILED(hr = pPerformance->PlaySegment(pSegment, DMUS_SEGF_BEAT, 0, NULL)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_PLAYSEGMENT;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    if (pMusicPort->m_bExternal)
        LoadString(NULL, IDS_EXTERNALMUSICPLAYING, sz, 300);
    else
        LoadString(NULL, IDS_MUSICPLAYING, sz, 300);
    MessageBox(hwndMain, sz, szTitle, MB_OK);

    pPerformance->Stop(pSegment, NULL, 0, 0);

LEnd:
    DeleteTempFile(TEXT("Edge.sgt"));
    DeleteTempFile(TEXT("Edge.sty"));

    ReleasePpo(&pdm);
    ReleasePpo(&pPort);
    if (pPerformance != NULL)
        pPerformance->CloseDown();
    ReleasePpo(&pPerformance);
    ReleasePpo(&pLoader);

    if (bComInitialized)
    {
        // Release COM
        CoUninitialize();
    }

    if (pMusicInfo->m_testResult.m_iStepThatFailed == 0)
    {
        LoadString(NULL, IDS_TESTSSUCCESSFUL, sz, 300);
        lstrcpy(pMusicInfo->m_testResult.m_szDescription, sz);

        LoadString(NULL, IDS_TESTSSUCCESSFUL_ENGLISH, sz, 300);
        lstrcpy(pMusicInfo->m_testResult.m_szDescriptionEnglish, sz);
    }
    else
    {
        TCHAR szDesc[200];
        TCHAR szError[200];
        if (0 == LoadString(NULL, IDS_FIRSTDMUSICTESTERROR + 
            pMusicInfo->m_testResult.m_iStepThatFailed - 1, szDesc, 200))
        {
            LoadString(NULL, IDS_UNKNOWNERROR, sz, 300);
            lstrcpy(szDesc, sz);
        }
        LoadString(NULL, IDS_FAILUREFMT, sz, 300);
        BTranslateError(pMusicInfo->m_testResult.m_hr, szError);
        wsprintf(pMusicInfo->m_testResult.m_szDescription, sz, 
            pMusicInfo->m_testResult.m_iStepThatFailed,
            szDesc, pMusicInfo->m_testResult.m_hr, szError);

        // Nonlocalized version:
        if (0 == LoadString(NULL, IDS_FIRSTDMUSICTESTERROR_ENGLISH + 
            pMusicInfo->m_testResult.m_iStepThatFailed - 1, szDesc, 200))
        {
            LoadString(NULL, IDS_UNKNOWNERROR_ENGLISH, sz, 300);
            lstrcpy(szDesc, sz);
        }
        LoadString(NULL, IDS_FAILUREFMT_ENGLISH, sz, 300);
        BTranslateError(pMusicInfo->m_testResult.m_hr, szError, TRUE);
        wsprintf(pMusicInfo->m_testResult.m_szDescriptionEnglish, sz, 
            pMusicInfo->m_testResult.m_iStepThatFailed,
            szDesc, pMusicInfo->m_testResult.m_hr, szError);
    }
}


/****************************************************************************
 *
 *  SpewResourceToFile
 *
 ****************************************************************************/
HRESULT SpewResourceToFile(TCHAR* pszResType, LONG idRes, TCHAR* pszFileName)
{
    TCHAR szTempPath[MAX_PATH];
    HRSRC hResInfo = NULL;
    HGLOBAL hResData = NULL;
    BYTE* pbData = NULL;
    HANDLE hfile;
    DWORD numBytes;
    DWORD numBytesWritten;

    GetTempPath(MAX_PATH, szTempPath);
    lstrcat(szTempPath, pszFileName);
    if (NULL == (hResInfo = FindResource(NULL, MAKEINTRESOURCE(idRes), pszResType)))
        return E_FAIL;
    numBytes = SizeofResource(NULL, hResInfo);
    if (NULL == (hResData = LoadResource(NULL, hResInfo)))
        return E_FAIL;
    if (NULL == (pbData = (BYTE*)LockResource(hResData)))
        return E_FAIL;

    hfile = CreateFile(szTempPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
        FILE_ATTRIBUTE_TEMPORARY, NULL);
    if (hfile == INVALID_HANDLE_VALUE)
        return E_FAIL;
    WriteFile(hfile, pbData, numBytes, &numBytesWritten, NULL);
    CloseHandle(hfile);

    return S_OK;
}


/****************************************************************************
 *
 *  DeleteTempFile
 *
 ****************************************************************************/
VOID DeleteTempFile(TCHAR* pszFileName)
{
    TCHAR szTempPath[MAX_PATH];

    GetTempPath(MAX_PATH, szTempPath);
    lstrcat(szTempPath, pszFileName);
    DeleteFile(szTempPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\testsnd.h ===
/****************************************************************************
 *
 *    File: testsnd.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Kerim Erden (a-kerime@microsoft.com)
 * Purpose: Test DSound functionality on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef TESTSND_H
#define TESTSND_H

VOID TestSnd(HWND hwndMain, SoundInfo* pSoundInfo);

#endif // TESTSND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\testnet.cpp ===
/****************************************************************************
 *
 *    File: testnet.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Jason Sandlin (jasonsa@microsoft.com) 
 * Purpose: Test DPlay8 functionality on this machine
 *
 * (C) Copyright 2000-2001 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/
#define INITGUID
#include <Windows.h>
#include <multimon.h>
#include <dplay8.h>
#include <tchar.h>
#include <wchar.h>
#include <dplobby.h>
#include <mmsystem.h>
#include "reginfo.h"
#include "sysinfo.h"
#include "dispinfo.h"
#include "netinfo.h"
#include "testnet.h"
#include "resource.h"

#ifndef ReleasePpo
    #define ReleasePpo(ppo) \
        if (*(ppo) != NULL) \
        { \
            (*(ppo))->Release(); \
            *(ppo) = NULL; \
        } \
        else (VOID)0
#endif

#define TIMER_WAIT_CONNECT_COMPLETE 0
#define TIMER_UPDATE_SESSION_LIST   1

enum TESTID
{
    TESTID_COINITIALIZE = 1,
    TESTID_CREATEDPLAY,
    TESTID_ADDRESSING,
    TESTID_ENUMSESSIONS,
    TESTID_ENUMPLAYERS,
    TESTID_SENDCHATMESSAGE,
    TESTID_RECEIVE,
    TESTID_SETPEERINFO,
    TESTID_CREATESESSION,
    TESTID_JOINSESSION,  
};

struct DPHostEnumInfo
{
    DPN_APPLICATION_DESC*   pAppDesc;
    IDirectPlay8Address*    pHostAddr;
    IDirectPlay8Address*    pDeviceAddr;
    TCHAR                   szSession[MAX_PATH];
    DWORD                   dwLastPollTime;
    BOOL                    bValid;
    DPHostEnumInfo*         pNext;
};

#define MAX_CHAT_STRING_LENGTH  200
#define MAX_PLAYER_NAME         MAX_PATH
#define MAX_CHAT_STRING         (MAX_PLAYER_NAME + MAX_CHAT_STRING_LENGTH + 32)

struct APP_PLAYER_INFO
{
    LONG  lRefCount;                        // Ref count so we can cleanup when all threads 
                                            // are done w/ this object
    DPNID dpnidPlayer;                      // DPNID of player
    WCHAR strPlayerName[MAX_PLAYER_NAME];   // Player name
};

#define GAME_MSGID_CHAT    1

// Change compiler pack alignment to be BYTE aligned, and pop the current value
#pragma pack( push, 1 )

UNALIGNED struct GAMEMSG_GENERIC
{
    WORD nType;
};

UNALIGNED struct GAMEMSG_CHAT : public GAMEMSG_GENERIC
{
    WCHAR strChatString[MAX_CHAT_STRING_LENGTH];
};

// Pop the old pack alignment
#pragma pack( pop )

struct APP_QUEUE_CHAT_MSG
{
    WCHAR strChatBuffer[MAX_CHAT_STRING];
};

struct APP_PLAYER_MSG 
{
    WCHAR strPlayerName[MAX_PATH];          // Player name
};

#define WM_APP_CHAT             (WM_APP + 1)
#define WM_APP_LEAVE            (WM_APP + 2)
#define WM_APP_JOIN             (WM_APP + 3)
#define WM_APP_CONNECTING       (WM_APP + 4)
#define WM_APP_CONNECTED        (WM_APP + 5)

BOOL BTranslateError(HRESULT hr, TCHAR* psz, BOOL bEnglish = FALSE); // from main.cpp (yuck)

static INT_PTR CALLBACK SetupDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static BOOL FAR PASCAL EnumConnectionsCallback(LPCGUID lpguidSP, VOID* pvConnection, 
    DWORD dwConnectionSize, LPCDPNAME pName, DWORD dwFlags, VOID* pvContext);
static INT_PTR CALLBACK SessionsDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static VOID SessionsDlgInitListbox( HWND hDlg );
static VOID SessionsDlgNoteEnumResponse( PDPNMSG_ENUM_HOSTS_RESPONSE pEnumHostsResponseMsg );
static VOID SessionsDlgUpdateSessionList(HWND hDlg);
static VOID SessionsDlgEnumListCleanup();

static HRESULT InitDirectPlay( BOOL* pbCoInitializeDone );
static HRESULT InitDirectPlayAddresses();
static HRESULT InitSession();
static VOID LoadStringWide( int nID, WCHAR* szWide );

static BOOL FAR PASCAL EnumSessionsCallback(LPCDPSESSIONDESC2 pdpsd, 
    DWORD* pdwTimeout, DWORD dwFlags, VOID* pvContext);
static INT_PTR CALLBACK ChatDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static VOID ShowTextString(HWND hDlg, WCHAR* sz );
static HRESULT SendChatMessage( TCHAR* szMessage );
static HRESULT WINAPI DirectPlayMessageHandler( PVOID pvUserContext, DWORD dwMessageId, PVOID pMsgBuffer );
static BOOL ConvertStringToGUID(const TCHAR* strBuffer, GUID* lpguid);
static VOID ConvertGenericStringToWide( WCHAR* wstrDestination, const TCHAR* tstrSource, int cchDestChar = -1 );
static VOID ConvertWideStringToGeneric( TCHAR* tstrDestination, const WCHAR* wstrSource, int cchDestChar );
static VOID ConvertWideStringToAnsi( CHAR* strDestination, const WCHAR* wstrSource, int cchDestChar );

static const GUID s_guidDPTest = // {61EF80DA-691B-4247-9ADD-1C7BED2BC13E}
{ 0x61ef80da, 0x691b, 0x4247, { 0x9a, 0xdd, 0x1c, 0x7b, 0xed, 0x2b, 0xc1, 0x3e } };

static NetInfo* s_pNetInfo = NULL;
static IDirectPlay8Peer* s_pDP = NULL;
static TCHAR s_szPlayerName[100];
static TCHAR s_szSessionName[100];
static DWORD s_dwPort = 0;
static NetSP* s_pNetSP = NULL;
static BOOL s_bCreateSession = FALSE;
static DPHostEnumInfo* s_pSelectedSession = NULL;
static DPHostEnumInfo s_DPHostEnumHead;
static IDirectPlay8Address* s_pDeviceAddress = NULL;
static IDirectPlay8Address* s_pHostAddress   = NULL;
static DPNHANDLE s_hEnumAsyncOp = NULL;
static DWORD s_dwEnumHostExpireInterval      = 0;
static BOOL s_bEnumListChanged = FALSE;
static BOOL s_bConnecting = FALSE;
static DPHostEnumInfo* s_pDPHostEnumSelected = NULL;
static CRITICAL_SECTION s_csHostEnum;
static DPNID s_dpnidLocalPlayer = 0;
static LONG s_lNumberOfActivePlayers = 0;
static HWND s_hDlg = NULL;
static HWND s_hwndSessionDlg = NULL;
static DPNHANDLE s_hConnectAsyncOp = NULL;
static HRESULT s_hrConnectComplete = S_OK;
static HANDLE s_hConnectCompleteEvent = NULL;


static CRITICAL_SECTION s_csPlayerContext;
#define PLAYER_LOCK()                   EnterCriticalSection( &s_csPlayerContext ); 
#define PLAYER_ADDREF( pPlayerInfo )    if( pPlayerInfo ) pPlayerInfo->lRefCount++;
#define PLAYER_RELEASE( pPlayerInfo )   if( pPlayerInfo ) { pPlayerInfo->lRefCount--; if( pPlayerInfo->lRefCount <= 0 ) delete pPlayerInfo; } pPlayerInfo = NULL;
#define PLAYER_UNLOCK()                 LeaveCriticalSection( &s_csPlayerContext );


/****************************************************************************
 *
 *  TestNetwork
 *
 ****************************************************************************/
VOID TestNetwork(HWND hwndMain, NetInfo* pNetInfo)
{
    BOOL                        bCoInitializeDone = FALSE;
    TCHAR                       sz[300];
    HINSTANCE                   hinst       = (HINSTANCE)GetWindowLongPtr(hwndMain, GWLP_HINSTANCE);

    s_pNetInfo = pNetInfo;
    
    // Remove info from any previous test:
    ZeroMemory(&s_pNetInfo->m_testResult, sizeof(TestResult));
    s_pNetInfo->m_testResult.m_bStarted = TRUE;

    // Setup the s_DPHostEnumHead circular linked list
    ZeroMemory( &s_DPHostEnumHead, sizeof( DPHostEnumInfo ) );
    s_DPHostEnumHead.pNext = &s_DPHostEnumHead;

    InitializeCriticalSection( &s_csHostEnum );
    InitializeCriticalSection( &s_csPlayerContext );
    s_hConnectCompleteEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    // Setup s_pDP, and mark installed SP's
    if( FAILED( InitDirectPlay( &bCoInitializeDone ) ) )
        goto LEnd;

    // Show setup dialog.  This will tell us:
    // - service provider
    // - player name
    // - either create or join
    // - game name (if creating)
    // - port (if SP=TCP/IP)
    DialogBox(hinst, MAKEINTRESOURCE(IDD_TESTNETSETUP), hwndMain, SetupDialogProc);

    if (s_pNetSP == NULL)
    {
        // Something weird happened...no service provider chosen
        goto LEnd;
    }

    // At this point s_szPlayerName, s_szSessionName, s_pNetSP, s_dwPort,
    // and s_bCreateSession have been initialized

    // Setup s_dwEnumHostExpireInterval, s_pDeviceAddress, and s_pHostAddress
    if( FAILED( InitDirectPlayAddresses() ) )
        goto LEnd;

    // Now s_dwEnumHostExpireInterval, s_pDeviceAddress, and s_pHostAddress
    // have been initialized

    // Session list window (if joining session)
    if( !s_bCreateSession )
    {
        // Open a dialog to choose which host to connect to
        DialogBox(hinst, MAKEINTRESOURCE(IDD_TESTNETSESSIONS), hwndMain, SessionsDialogProc);
        // Now s_pDPHostEnumSelected will be NULL or valid

        if( FAILED(s_pNetInfo->m_testResult.m_hr) || s_pDPHostEnumSelected == NULL )
            goto LEnd;

        // Now s_pDPHostEnumSelected is valid
    }

    // Launch chat window and host or join session
    DialogBox(hinst, MAKEINTRESOURCE(IDD_TESTNETCHAT), hwndMain, ChatDialogProc);

LEnd:
    s_pNetSP = NULL;
    ReleasePpo( &s_pDeviceAddress );
    ReleasePpo( &s_pHostAddress );
    if( s_hEnumAsyncOp )
        s_pDP->CancelAsyncOperation( s_hEnumAsyncOp, 0 );
    ReleasePpo(&s_pDP);
    if (bCoInitializeDone)
        CoUninitialize(); // Release COM
    DeleteCriticalSection( &s_csHostEnum );
    DeleteCriticalSection( &s_csPlayerContext );
    CloseHandle( s_hConnectCompleteEvent );

    if (s_pNetInfo->m_testResult.m_bCancelled)
    {
        LoadString(NULL, IDS_TESTSCANCELLED, sz, 300);
        lstrcpy(s_pNetInfo->m_testResult.m_szDescription, sz);

        LoadString(NULL, IDS_TESTSCANCELLED_ENGLISH, sz, 300);
        lstrcpy(s_pNetInfo->m_testResult.m_szDescriptionEnglish, sz);
    }
    else if (s_pNetInfo->m_testResult.m_iStepThatFailed == 0)
    {
        LoadString(NULL, IDS_TESTSSUCCESSFUL, sz, 300);
        lstrcpy(s_pNetInfo->m_testResult.m_szDescription, sz);

        LoadString(NULL, IDS_TESTSSUCCESSFUL_ENGLISH, sz, 300);
        lstrcpy(s_pNetInfo->m_testResult.m_szDescriptionEnglish, sz);
    }
    else
    {
        TCHAR szDesc[300];
        TCHAR szError[300];
        if (0 == LoadString(NULL, IDS_FIRSTDPLAYTESTERROR + 
            s_pNetInfo->m_testResult.m_iStepThatFailed - 1, szDesc, 200))
        {
            LoadString(NULL, IDS_UNKNOWNERROR, sz, 300);
            lstrcpy(szDesc, sz);
        }
        LoadString(NULL, IDS_FAILUREFMT, sz, 300);
        BTranslateError(s_pNetInfo->m_testResult.m_hr, szError);
        wsprintf(s_pNetInfo->m_testResult.m_szDescription, sz, 
            s_pNetInfo->m_testResult.m_iStepThatFailed,
            szDesc, s_pNetInfo->m_testResult.m_hr, szError);

        // Nonlocalized version:
        if (0 == LoadString(NULL, IDS_FIRSTDPLAYTESTERROR_ENGLISH + 
            s_pNetInfo->m_testResult.m_iStepThatFailed - 1, szDesc, 200))
        {
            LoadString(NULL, IDS_UNKNOWNERROR_ENGLISH, sz, 300);
            lstrcpy(szDesc, sz);
        }
        LoadString(NULL, IDS_FAILUREFMT_ENGLISH, sz, 300);
        BTranslateError(s_pNetInfo->m_testResult.m_hr, szError, TRUE);
        wsprintf(s_pNetInfo->m_testResult.m_szDescriptionEnglish, sz, 
            s_pNetInfo->m_testResult.m_iStepThatFailed,
            szDesc, s_pNetInfo->m_testResult.m_hr, szError);
    }
}


/****************************************************************************
 *
 *  InitDirectPlay
 *
 ****************************************************************************/
HRESULT InitDirectPlay( BOOL* pbCoInitializeDone )
{
    HRESULT hr;
    DWORD                       dwItems     = 0;
    DWORD                       dwSize      = 0;
    DPN_SERVICE_PROVIDER_INFO*  pdnSPInfoEnum = NULL;
    DPN_SERVICE_PROVIDER_INFO*  pdnSPInfo     = NULL;
    DWORD                       i;

    // Initialize COM
    if (FAILED(hr = CoInitialize(NULL)))
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_COINITIALIZE;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }
    *pbCoInitializeDone = TRUE;

    // Create DirectPlay object
    if( FAILED( hr = CoCreateInstance( CLSID_DirectPlay8Peer, NULL, 
                                       CLSCTX_INPROC_SERVER,
                                       IID_IDirectPlay8Peer, 
                                       (LPVOID*) &s_pDP ) ) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_CREATEDPLAY;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }

    // Init IDirectPlay8Peer
    if( FAILED( hr = s_pDP->Initialize( NULL, DirectPlayMessageHandler, 0 ) ) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_CREATEDPLAY;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }

    // Enumerate all DirectPlay service providers 
    // to figure out which are installed
    hr = s_pDP->EnumServiceProviders( NULL, NULL, pdnSPInfo, &dwSize,
                                      &dwItems, 0 );
    if( hr != DPNERR_BUFFERTOOSMALL && FAILED(hr) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }
    pdnSPInfo = (DPN_SERVICE_PROVIDER_INFO*) new BYTE[dwSize];
    if( FAILED( hr = s_pDP->EnumServiceProviders( NULL, NULL, pdnSPInfo,
                                                  &dwSize, &dwItems, 0 ) ) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
        s_pNetInfo->m_testResult.m_hr = hr;
        if( pdnSPInfo )
            delete[] pdnSPInfo;
        return hr;
    }

    // Mark installed SP's as such
    pdnSPInfoEnum = pdnSPInfo;
    for ( i = 0; i < dwItems; i++ )
    {
        NetSP* pNetSP;
        for (pNetSP = s_pNetInfo->m_pNetSPFirst; pNetSP != NULL;
             pNetSP = pNetSP->m_pNetSPNext)
        {
            if( pNetSP->m_guid == pdnSPInfoEnum->guid ) 
            {
                pNetSP->m_bInstalled = TRUE;
                break;
            }
        }
        pdnSPInfoEnum++;
    }

    if( pdnSPInfo )
        delete[] pdnSPInfo;

    return S_OK;
}


/****************************************************************************
 *
 *  SetupDialogProc
 *
 ****************************************************************************/
INT_PTR CALLBACK SetupDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            NetSP* pNetSP;
            TCHAR sz[MAX_PATH];
            HWND hwndList = GetDlgItem(hDlg, IDC_SPLIST);
            LONG iItem;
            LONG iSelect = LB_ERR;

            for (pNetSP = s_pNetInfo->m_pNetSPFirst; pNetSP != NULL;
                 pNetSP = pNetSP->m_pNetSPNext)
            {
                if( pNetSP->m_dwDXVer == 8 && pNetSP->m_bInstalled ) 
                {
                    iItem = (LONG)SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)pNetSP->m_szName);
                    if ((LRESULT)iItem != LB_ERR)
                    {
                        SendMessage(hwndList, LB_SETITEMDATA, iItem, (LPARAM)pNetSP);

                        // Try to select TCP/IP by default
                        if( lstrcmpi(pNetSP->m_szGuid,  TEXT("{EBFE7BA0-628D-11D2-AE0F-006097B01411}")) == 0)
                            iSelect = iItem;
                    }
                }
            }

            // Try to select the default preferred provider
            if( iSelect != LB_ERR )
                SendMessage( hwndList, LB_SETCURSEL, iSelect, 0 );
            else
                SendMessage( hwndList, LB_SETCURSEL, 0, 0 );

            SendMessage(hDlg, WM_COMMAND, IDC_SPLIST, 0);
            LoadString(NULL, IDS_DEFAULTUSERNAME, sz, MAX_PATH);
            SetWindowText(GetDlgItem(hDlg, IDC_PLAYERNAME), sz);
            LoadString(NULL, IDS_DEFAULTSESSIONNAME, sz, MAX_PATH);
            SetWindowText(GetDlgItem(hDlg, IDC_SESSIONNAME), sz);
            CheckRadioButton(hDlg, IDC_CREATESESSION, IDC_JOINSESSION, IDC_CREATESESSION);
            return TRUE;
        }

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDC_CREATESESSION:
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_SESSIONNAME), TRUE);
                    break;
                }

                case IDC_JOINSESSION:
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_SESSIONNAME), FALSE);
                    break;
                }

                case IDC_SPLIST:
                {
                    HWND hwndList;
                    hwndList = GetDlgItem(hDlg, IDC_SPLIST);
                    LONG iItem;
                    iItem = (LONG)SendMessage(hwndList, LB_GETCURSEL, 0, 0);
                    NetSP* pNetSP = (NetSP*)SendMessage(hwndList, LB_GETITEMDATA, iItem, 0);

                    // Only enable the port if the selected SP == TCP/IP
                    if( pNetSP && lstrcmp( pNetSP->m_szGuid, TEXT("{EBFE7BA0-628D-11D2-AE0F-006097B01411}") ) == 0 )
                    {
                        EnableWindow( GetDlgItem(hDlg, IDC_PORT), TRUE );
                        EnableWindow( GetDlgItem(hDlg, IDC_PORT_TEXT), TRUE );
                    }
                    else
                    {
                        EnableWindow( GetDlgItem(hDlg, IDC_PORT), FALSE );
                        EnableWindow( GetDlgItem(hDlg, IDC_PORT_TEXT), FALSE );
                    }                 
                    break;
                }

                case IDOK:
                {
                    // Set create/join option
                    if (IsDlgButtonChecked(hDlg, IDC_CREATESESSION))
                        s_bCreateSession = TRUE;
                    else
                        s_bCreateSession = FALSE;

                    // Get player name
                    GetWindowText(GetDlgItem(hDlg, IDC_PLAYERNAME), s_szPlayerName, 100);
                    if (lstrlen(s_szPlayerName) == 0)
                    {
                        TCHAR szMsg[MAX_PATH];
                        TCHAR szTitle[MAX_PATH];
                        LoadString(NULL, IDS_NEEDUSERNAME, szMsg, MAX_PATH);
                        LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
                        MessageBox(hDlg, szMsg, szTitle, MB_OK);
                        break;
                    }

                    // Get port
                    TCHAR szPort[MAX_PATH];
                    GetDlgItemText( hDlg, IDC_PORT, szPort, MAX_PATH);
                    s_dwPort = _ttoi( szPort );

                    // Get session name
                    GetWindowText(GetDlgItem(hDlg, IDC_SESSIONNAME), s_szSessionName, 100);
                    if (s_bCreateSession && lstrlen(s_szSessionName) == 0)
                    {
                        TCHAR szMsg[MAX_PATH];
                        TCHAR szTitle[MAX_PATH];
                        LoadString(NULL, IDS_NEEDSESSIONNAME, szMsg, MAX_PATH);
                        LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
                        MessageBox(hDlg, szMsg, szTitle, MB_OK);
                        break;
                    }

                    // Get sp
                    HWND hwndList;
                    hwndList = GetDlgItem(hDlg, IDC_SPLIST);
                    LONG iItem;
                    iItem = (LONG)SendMessage(hwndList, LB_GETCURSEL, 0, 0);
                    if ((LPARAM)iItem == LB_ERR)
                    {
                        s_pNetInfo->m_testResult.m_bCancelled = TRUE;
                        EndDialog(hDlg, 0);
                        return FALSE;
                    }
                    else
                    {
                        s_pNetSP = (NetSP*)SendMessage(hwndList, LB_GETITEMDATA, iItem, 0);
                    }
                    EndDialog(hDlg, 1);
                    break;
                }

                case IDCANCEL:
                {
                    EndDialog(hDlg, 0);
                    s_pNetInfo->m_testResult.m_bCancelled = TRUE;
                    break;
                }
            }
        }
    }

    return FALSE;
}


/****************************************************************************
 *
 *  InitDirectPlayAddresses
 *
 ****************************************************************************/
HRESULT InitDirectPlayAddresses()
{
    HRESULT hr;

    // Query for the enum host timeout for this SP
    DPN_SP_CAPS dpspCaps;
    ZeroMemory( &dpspCaps, sizeof(DPN_SP_CAPS) );
    dpspCaps.dwSize = sizeof(DPN_SP_CAPS);
    if( FAILED( hr = s_pDP->GetSPCaps( &s_pNetSP->m_guid, &dpspCaps, 0 ) ) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }

    // Set the host expire time to around 3 times
    // length of the dwDefaultEnumRetryInterval
    s_dwEnumHostExpireInterval = dpspCaps.dwDefaultEnumRetryInterval * 3;

    // Create a device address
    ReleasePpo( &s_pDeviceAddress );
    hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL,CLSCTX_INPROC_SERVER,
                           IID_IDirectPlay8Address, (LPVOID*) &s_pDeviceAddress );
    if( FAILED(hr) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }

    if( FAILED( hr = s_pDeviceAddress->SetSP( &s_pNetSP->m_guid ) ) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }

    // Create a host address
    ReleasePpo( &s_pHostAddress );
    hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL,CLSCTX_INPROC_SERVER,
                           IID_IDirectPlay8Address, (LPVOID*) &s_pHostAddress );
    if( FAILED(hr) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }

    // Set the SP
    if( FAILED( hr = s_pHostAddress->SetSP( &s_pNetSP->m_guid ) ) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }

    // If TCP/IP then set the port if its non-zero
    if( s_pNetSP->m_guid == CLSID_DP8SP_TCPIP )
    {
        if( s_bCreateSession )
        {
            if( s_dwPort > 0 )
            {
                // Add the port to pDeviceAddress
                if( FAILED( hr = s_pDeviceAddress->AddComponent( DPNA_KEY_PORT, 
                                                               &s_dwPort, sizeof(s_dwPort),
                                                               DPNA_DATATYPE_DWORD ) ) )
                {
                    s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
                    s_pNetInfo->m_testResult.m_hr = hr;
                    return hr;
                }
            }
        }
        else
        {
            if( s_dwPort > 0 )
            {
                // Add the port to pHostAddress
                if( FAILED( hr = s_pHostAddress->AddComponent( DPNA_KEY_PORT, 
                                                             &s_dwPort, sizeof(s_dwPort),
                                                             DPNA_DATATYPE_DWORD ) ) )
                {
                    s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
                    s_pNetInfo->m_testResult.m_hr = hr;
                    return hr;
                }
            }
        }
    }

    return S_OK;
}


/****************************************************************************
 *
 *  SessionsDialogProc
 *
 ****************************************************************************/
INT_PTR CALLBACK SessionsDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            HRESULT     hr;

            s_hwndSessionDlg = hDlg;
            s_bEnumListChanged = TRUE;

            // Enumerate hosts
            DPN_APPLICATION_DESC    dnAppDesc;
            ZeroMemory( &dnAppDesc, sizeof(DPN_APPLICATION_DESC) );
            dnAppDesc.dwSize          = sizeof(DPN_APPLICATION_DESC);
            dnAppDesc.guidApplication = s_guidDPTest;

            // Enumerate all the active DirectPlay games on the selected connection
            hr = s_pDP->EnumHosts( &dnAppDesc,                            // application description
                                   s_pHostAddress,                        // host address
                                   s_pDeviceAddress,                      // device address
                                   NULL,                                  // pointer to user data
                                   0,                                     // user data size
                                   INFINITE,                              // retry count (forever)
                                   0,                                     // retry interval (0=default)
                                   INFINITE,                              // time out (forever)
                                   NULL,                                  // user context
                                   &s_hEnumAsyncOp,                       // async handle
                                   DPNENUMHOSTS_OKTOQUERYFORADDRESSING    // flags
                                   );
            if( FAILED(hr) )
            {
                s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ENUMSESSIONS;
                s_pNetInfo->m_testResult.m_hr = hr;
                EndDialog(hDlg, 0);
                return TRUE;
            }

            SessionsDlgInitListbox(hDlg);
            SetTimer(hDlg, TIMER_UPDATE_SESSION_LIST, 250, NULL);
            return TRUE;
        }

        case WM_TIMER:
        {
            if( wParam == TIMER_UPDATE_SESSION_LIST )
                SessionsDlgUpdateSessionList(hDlg);
            return TRUE;
        }

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDOK:
                {
                    HWND hwndList = GetDlgItem(hDlg, IDC_SESSIONLIST);

                    LONG iSelCur = (LONG)SendMessage(hwndList, LB_GETCURSEL, 0, 0);
                    if( iSelCur != LB_ERR )
                    {
                        // This will prevent s_pDPHostEnumSelected from being 
                        // deleting due to SessionsDlgUpdateSessionList()
                        EnterCriticalSection( &s_csHostEnum );
                        s_pDPHostEnumSelected = (DPHostEnumInfo*)SendMessage( hwndList, LB_GETITEMDATA, 
                                                                              iSelCur, 0 );

                        if ( (LRESULT)s_pDPHostEnumSelected != LB_ERR && 
                             s_pDPHostEnumSelected != NULL )
                        {
                            // We keep the CS until we are done with s_pDPHostEnumSelected,
                            // otherwise it might change out from under us.
                            EndDialog(hDlg, 1);
                            break;
                        }

                        s_pDPHostEnumSelected = NULL;
                        LeaveCriticalSection( &s_csHostEnum );
                    }

                    s_pNetInfo->m_testResult.m_bCancelled = TRUE;
                    EndDialog(hDlg, 0);
                    break;
                }

                case IDCANCEL:
                {
                    s_pDPHostEnumSelected = NULL;
                    s_pNetInfo->m_testResult.m_bCancelled = TRUE;
                    EndDialog(hDlg, 0);
                    break;
                }
            }
        }

        case WM_DESTROY:
        {
            KillTimer( hDlg, TIMER_UPDATE_SESSION_LIST );
            s_hwndSessionDlg = NULL;
            break;
        }
    }

    return FALSE;
}


/****************************************************************************
 *
 *  SessionsDlgInitListbox
 *
 ****************************************************************************/
VOID SessionsDlgInitListbox( HWND hDlg )
{
    HWND hWndListBox = GetDlgItem( hDlg, IDC_SESSIONLIST );

    LONG numChars;
    TCHAR szFmt[200];   

    LoadString(NULL, IDS_LOOKINGFORSESSIONS, szFmt, 200);
    numChars = (LONG)SendMessage(GetDlgItem(hDlg, IDC_CHATOUTPUT), WM_GETTEXTLENGTH, 0, 0);
    SendMessage(GetDlgItem(hDlg, IDC_CHATOUTPUT), EM_SETSEL, numChars, numChars);
    SendMessage(GetDlgItem(hDlg, IDC_CHATOUTPUT), EM_REPLACESEL, 
        FALSE, (LPARAM)szFmt);

    // Clear the contents from the list box, and
    // display "Looking for sessions" text in listbox
    SendMessage( hWndListBox, LB_RESETCONTENT, 0, 0 );
    SendMessage( hWndListBox, LB_SETITEMDATA,  0, NULL );
    SendMessage( hWndListBox, LB_SETCURSEL,    0, 0 );

    // Disable the join button until sessions are found
    EnableWindow( GetDlgItem( hDlg, IDOK ), FALSE );
}


/****************************************************************************
 *
 *  SessionsDlgNoteEnumResponse
 *
 ****************************************************************************/
VOID SessionsDlgNoteEnumResponse( PDPNMSG_ENUM_HOSTS_RESPONSE pEnumHostsResponseMsg )
{
    HRESULT hr = S_OK;
    BOOL    bFound;

    // This function is called from the DirectPlay message handler so it could be
    // called simultaneously from multiple threads, so enter a critical section
    // to assure that it we don't get race conditions.  
    EnterCriticalSection( &s_csHostEnum );

    DPHostEnumInfo* pDPHostEnum          = s_DPHostEnumHead.pNext;
    DPHostEnumInfo* pDPHostEnumNext      = NULL;
    const DPN_APPLICATION_DESC* pResponseMsgAppDesc =
                            pEnumHostsResponseMsg->pApplicationDescription;

    // Look for a matching session instance GUID.
    bFound = FALSE;
    while ( pDPHostEnum != &s_DPHostEnumHead )
    {
        if( pResponseMsgAppDesc->guidInstance == pDPHostEnum->pAppDesc->guidInstance )
        {
            bFound = TRUE;
            break;
        }

        pDPHostEnumNext = pDPHostEnum;
        pDPHostEnum = pDPHostEnum->pNext;
    }

    if( !bFound )
    {
        s_bEnumListChanged = TRUE;

        // If there's no match, then look for invalid session and use it
        pDPHostEnum = s_DPHostEnumHead.pNext;
        while ( pDPHostEnum != &s_DPHostEnumHead )
        {
            if( !pDPHostEnum->bValid )
                break;

            pDPHostEnum = pDPHostEnum->pNext;
        }

        // If no invalid sessions are found then make a new one
        if( pDPHostEnum == &s_DPHostEnumHead )
        {
            // Found a new session, so create a new node
            pDPHostEnum = new DPHostEnumInfo;
            if( NULL == pDPHostEnum )
            {
                hr = E_OUTOFMEMORY;
                goto LCleanup;
            }

            ZeroMemory( pDPHostEnum, sizeof(DPHostEnumInfo) );

            // Add pDPHostEnum to the circular linked list, m_DPHostEnumHead
            pDPHostEnum->pNext = s_DPHostEnumHead.pNext;
            s_DPHostEnumHead.pNext = pDPHostEnum;
        }
    }

    // Update the pDPHostEnum with new information
    TCHAR strName[MAX_PATH];
    if( pResponseMsgAppDesc->pwszSessionName )
        ConvertWideStringToGeneric( strName, pResponseMsgAppDesc->pwszSessionName, MAX_PATH );
    else
        lstrcpy( strName, TEXT("???") );

    // Cleanup any old enum
    if( pDPHostEnum->pAppDesc )
    {
        delete[] pDPHostEnum->pAppDesc->pwszSessionName;
        delete[] pDPHostEnum->pAppDesc;
    }
    ReleasePpo( &pDPHostEnum->pHostAddr );
    ReleasePpo( &pDPHostEnum->pDeviceAddr );
    pDPHostEnum->bValid = FALSE;

    //
    // Duplicate pEnumHostsResponseMsg->pAddressSender in pDPHostEnum->pHostAddr.
    // Duplicate pEnumHostsResponseMsg->pAddressDevice in pDPHostEnum->pDeviceAddr.
    //
    if( FAILED( hr = pEnumHostsResponseMsg->pAddressSender->Duplicate( &pDPHostEnum->pHostAddr ) ) )
    {
        goto LCleanup;
    }

    if( FAILED( hr = pEnumHostsResponseMsg->pAddressDevice->Duplicate( &pDPHostEnum->pDeviceAddr ) ) )
    {
        goto LCleanup;
    }

    // Deep copy the DPN_APPLICATION_DESC from
    pDPHostEnum->pAppDesc = new DPN_APPLICATION_DESC;
    ZeroMemory( pDPHostEnum->pAppDesc, sizeof(DPN_APPLICATION_DESC) );
    memcpy( pDPHostEnum->pAppDesc, pResponseMsgAppDesc, sizeof(DPN_APPLICATION_DESC) );
    if( pResponseMsgAppDesc->pwszSessionName )
    {
        pDPHostEnum->pAppDesc->pwszSessionName = new WCHAR[ wcslen(pResponseMsgAppDesc->pwszSessionName)+1 ];
        wcscpy( pDPHostEnum->pAppDesc->pwszSessionName,
                pResponseMsgAppDesc->pwszSessionName );
    }

    // Update the time this was done, so that we can expire this host
    // if it doesn't refresh w/in a certain amount of time
    pDPHostEnum->dwLastPollTime = timeGetTime();

    // if this node was previously invalidated, or the session name is now
    // different the session list in the dialog needs to be updated
    if( ( pDPHostEnum->bValid == FALSE ) ||
        ( _tcscmp( pDPHostEnum->szSession, strName ) != 0 ) )
    {
        s_bEnumListChanged = TRUE;
    }
    _tcscpy( pDPHostEnum->szSession, strName );

    // This host is now valid
    pDPHostEnum->bValid = TRUE;

LCleanup:
    LeaveCriticalSection( &s_csHostEnum );
}


/****************************************************************************
 *
 *  SessionsDlgUpdateSessionList
 *
 ****************************************************************************/
VOID SessionsDlgUpdateSessionList( HWND hDlg )
{
    HWND            hWndListBox = GetDlgItem(hDlg, IDC_SESSIONLIST);
    DPHostEnumInfo* pDPHostEnum = NULL;
    DPHostEnumInfo* pDPHostEnumSelected = NULL;
    GUID            guidSelectedInstance;
    BOOL            bFindSelectedGUID;
    BOOL            bFoundSelectedGUID;
    int             nItemSelected;

    DWORD dwCurrentTime = timeGetTime();

    // This is called from the dialog UI thread, NoteEnumResponse()
    // is called from the DirectPlay message handler threads so
    // they may also be inside it at this time, so we need to go into the
    // critical section first
    EnterCriticalSection( &s_csHostEnum );

    // Expire old host enums
    pDPHostEnum = s_DPHostEnumHead.pNext;
    while ( pDPHostEnum != &s_DPHostEnumHead )
    {
        // Check the poll time to expire stale entries.  Also check to see if
        // the entry is already invalid.  If so, don't note that the enum list
        // changed because that causes the list in the dialog to constantly redraw.
        if( ( pDPHostEnum->bValid != FALSE ) &&
            ( pDPHostEnum->dwLastPollTime < dwCurrentTime - s_dwEnumHostExpireInterval ) )
        {
            // This node has expired, so invalidate it.
            pDPHostEnum->bValid = FALSE;
            s_bEnumListChanged  = TRUE;
        }

        pDPHostEnum = pDPHostEnum->pNext;
    }

    // Only update the display list if it has changed since last time
    if( !s_bEnumListChanged )
    {
        LeaveCriticalSection( &s_csHostEnum );
        return;
    }

    s_bEnumListChanged = FALSE;

    bFindSelectedGUID  = FALSE;
    bFoundSelectedGUID = FALSE;

    // Try to keep the same session selected unless it goes away or
    // there is no real session currently selected
    nItemSelected = (int)SendMessage( hWndListBox, LB_GETCURSEL, 0, 0 );
    if( nItemSelected != LB_ERR )
    {
        pDPHostEnumSelected = (DPHostEnumInfo*) SendMessage( hWndListBox, LB_GETITEMDATA,
                                                             nItemSelected, 0 );
        if( pDPHostEnumSelected != NULL && pDPHostEnumSelected->bValid )
        {
            guidSelectedInstance = pDPHostEnumSelected->pAppDesc->guidInstance;
            bFindSelectedGUID = TRUE;
        }
    }

    // Tell listbox not to redraw itself since the contents are going to change
    SendMessage( hWndListBox, WM_SETREDRAW, FALSE, 0 );

    // Test to see if any sessions exist in the linked list
    pDPHostEnum = s_DPHostEnumHead.pNext;
    while ( pDPHostEnum != &s_DPHostEnumHead )
    {
        if( pDPHostEnum->bValid )
            break;
        pDPHostEnum = pDPHostEnum->pNext;
    }

    // If there are any sessions in list,
    // then add them to the listbox
    if( pDPHostEnum != &s_DPHostEnumHead )
    {
        // Clear the contents from the list box and enable the join button
        SendMessage( hWndListBox, LB_RESETCONTENT, 0, 0 );

        EnableWindow( GetDlgItem( hDlg, IDOK ), TRUE );

        pDPHostEnum = s_DPHostEnumHead.pNext;
        while ( pDPHostEnum != &s_DPHostEnumHead )
        {
            // Add host to list box if it is valid
            if( pDPHostEnum->bValid )
            {
                int nIndex = (int)SendMessage( hWndListBox, LB_ADDSTRING, 0,
                                               (LPARAM)pDPHostEnum->szSession );
                SendMessage( hWndListBox, LB_SETITEMDATA, nIndex, (LPARAM)pDPHostEnum );

                if( bFindSelectedGUID )
                {
                    // Look for the session the was selected before
                    if( pDPHostEnum->pAppDesc->guidInstance == guidSelectedInstance )
                    {
                        SendMessage( hWndListBox, LB_SETCURSEL, nIndex, 0 );
                        bFoundSelectedGUID = TRUE;
                    }
                }
            }

            pDPHostEnum = pDPHostEnum->pNext;
        }

        if( !bFindSelectedGUID || !bFoundSelectedGUID )
            SendMessage( hWndListBox, LB_SETCURSEL, 0, 0 );
    }
    else
    {
        // There are no active session, so just reset the listbox
        SessionsDlgInitListbox( hDlg );
    }

    // Tell listbox to redraw itself now since the contents have changed
    SendMessage( hWndListBox, WM_SETREDRAW, TRUE, 0 );
    InvalidateRect( hWndListBox, NULL, FALSE );

    LeaveCriticalSection( &s_csHostEnum );

    return;
}


/****************************************************************************
 *
 *  SessionsDlgEnumListCleanup
 *
 ****************************************************************************/
VOID SessionsDlgEnumListCleanup()
{
    DPHostEnumInfo* pDPHostEnum = s_DPHostEnumHead.pNext;
    DPHostEnumInfo* pDPHostEnumDelete;

    while ( pDPHostEnum != &s_DPHostEnumHead )
    {
        pDPHostEnumDelete = pDPHostEnum;
        pDPHostEnum = pDPHostEnum->pNext;

        if( pDPHostEnumDelete->pAppDesc )
        {
            delete[] pDPHostEnumDelete->pAppDesc->pwszSessionName;
            delete[] pDPHostEnumDelete->pAppDesc;
        }

        // Changed from array delete to Release
        ReleasePpo( &pDPHostEnumDelete->pHostAddr );
        ReleasePpo( &pDPHostEnumDelete->pDeviceAddr );
        delete pDPHostEnumDelete;
    }

    // Re-link the s_DPHostEnumHead circular linked list
    s_DPHostEnumHead.pNext = &s_DPHostEnumHead;
}


/****************************************************************************
 *
 *  ChatDialogProc
 *
 ****************************************************************************/
INT_PTR CALLBACK ChatDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            s_hDlg = hDlg;

            // Join or host the session
            if( FAILED( InitSession() ) )
            {
                EndDialog(hDlg, 0);
            }

            return TRUE;
        }
        
        case WM_TIMER:
        {
            if( wParam == TIMER_WAIT_CONNECT_COMPLETE )
            {
                // Check for connect complete
                if( WAIT_OBJECT_0 == WaitForSingleObject( s_hConnectCompleteEvent, 0 ) )
                {
                    s_bConnecting = FALSE;

                    if( FAILED( s_hrConnectComplete ) )
                    {
                        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_JOINSESSION;
                        s_pNetInfo->m_testResult.m_hr = s_hrConnectComplete;
                        EndDialog(hDlg, 0);
                    }
                    else
                    {
                        // DirectPlay connect successful
                        PostMessage( s_hDlg, WM_APP_CONNECTED, 0, 0 );
                        EnableWindow( GetDlgItem( s_hDlg, IDC_SEND), TRUE );
                    }

                    KillTimer( s_hDlg, TIMER_WAIT_CONNECT_COMPLETE );
                }
            }

            break;
        }

        case WM_APP_CONNECTING:
        {
            WCHAR sz[MAX_PATH];
            LoadStringWide(IDS_CONNECTING, sz);
            ShowTextString( hDlg, sz );
            break;
        }

        case WM_APP_CONNECTED:
        {
            WCHAR sz[MAX_PATH];
            LoadStringWide(IDS_CONNECTED, sz);
            ShowTextString( hDlg, sz );
            break;
        }

        case WM_APP_JOIN:
        {
            APP_PLAYER_MSG* pPlayerMsg = (APP_PLAYER_MSG*) lParam;

            WCHAR szFmt[MAX_PATH];
            WCHAR szSuperMessage[MAX_PATH];

            LoadStringWide(IDS_JOINMSGFMT, szFmt);
            swprintf(szSuperMessage, szFmt, pPlayerMsg->strPlayerName);
            ShowTextString( hDlg, szSuperMessage );

            delete pPlayerMsg;
            break;
        }

        case WM_APP_CHAT:
        {
            APP_QUEUE_CHAT_MSG* pQueuedChat = (APP_QUEUE_CHAT_MSG*) lParam;

            ShowTextString( hDlg, pQueuedChat->strChatBuffer );

            delete pQueuedChat;
            break;
        }

        case WM_APP_LEAVE:
        {
            APP_PLAYER_MSG* pPlayerMsg = (APP_PLAYER_MSG*) lParam;

            WCHAR szSuperMessage[MAX_PATH];
            WCHAR szFmt[MAX_PATH];
            LoadStringWide(IDS_LEAVEMSGFMT, szFmt);
            swprintf(szSuperMessage, szFmt, pPlayerMsg->strPlayerName );
            ShowTextString( hDlg, szSuperMessage );

            delete pPlayerMsg;
            break;
        }

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDC_SEND:
                {
                    HRESULT hr;
                    TCHAR szMessage[MAX_PATH];
                    GetWindowText(GetDlgItem(hDlg, IDC_CHATINPUT), szMessage, MAX_PATH);
                    SendMessage(GetDlgItem(hDlg, IDC_CHATINPUT), EM_SETSEL, 0, -1);
                    SendMessage(GetDlgItem(hDlg, IDC_CHATINPUT), EM_REPLACESEL, FALSE, (LPARAM)"");

                    hr = SendChatMessage( szMessage );
                    if (FAILED(hr))
                    {
                        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_SENDCHATMESSAGE;
                        s_pNetInfo->m_testResult.m_hr = hr;
                        EndDialog(hDlg, 1);
                    }
                }
                break;

            case IDOK:
                EndDialog(hDlg, 1);
                break;

            case IDCANCEL:
                EndDialog(hDlg, 0);
                break;
            }
            return TRUE;
        }

        case WM_DESTROY:
        {
            s_hDlg = NULL;
            break;
        }
    }

    return FALSE;
}


/****************************************************************************
 *
 *  InitSession
 *
 ****************************************************************************/
HRESULT InitSession()
{
    HRESULT hr;

    if( s_bCreateSession )
    {
        // Set peer info name
        WCHAR wszPeerName[MAX_PLAYER_NAME];
        ConvertGenericStringToWide( wszPeerName, s_szPlayerName, MAX_PLAYER_NAME );

        DPN_PLAYER_INFO dpPlayerInfo;
        ZeroMemory( &dpPlayerInfo, sizeof(DPN_PLAYER_INFO) );
        dpPlayerInfo.dwSize = sizeof(DPN_PLAYER_INFO);
        dpPlayerInfo.dwInfoFlags = DPNINFO_NAME;
        dpPlayerInfo.pwszName = wszPeerName;

        // Set the peer info, and use the DPNOP_SYNC since by default this
        // is an async call.  If it is not DPNOP_SYNC, then the peer info may not
        // be set by the time we call Host() below.
        if( FAILED( hr = s_pDP->SetPeerInfo( &dpPlayerInfo, NULL, NULL, DPNOP_SYNC ) ) )
        {
            s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_SETPEERINFO;
            s_pNetInfo->m_testResult.m_hr = hr;
            return hr;
        }

        WCHAR wszSessionName[MAX_PATH];
        ConvertGenericStringToWide( wszSessionName, s_szSessionName );

        // Setup the application desc
        DPN_APPLICATION_DESC dnAppDesc;
        ZeroMemory( &dnAppDesc, sizeof(DPN_APPLICATION_DESC) );
        dnAppDesc.dwSize          = sizeof(DPN_APPLICATION_DESC);
        dnAppDesc.guidApplication = s_guidDPTest;
        dnAppDesc.pwszSessionName = wszSessionName;
        dnAppDesc.dwFlags         = DPNSESSION_MIGRATE_HOST;

        // Host a game on m_pDeviceAddress as described by dnAppDesc
        // DPNHOST_OKTOQUERYFORADDRESSING allows DirectPlay to prompt the user
        // using a dialog box for any device address information that is missing
        if( FAILED( hr = s_pDP->Host( &dnAppDesc,               // the application desc
                                      &s_pDeviceAddress,        // array of addresses of the local devices used to connect to the host
                                      1,                        // number in array
                                      NULL, NULL,               // DPN_SECURITY_DESC, DPN_SECURITY_CREDENTIALS
                                      NULL,                     // player context
                                      DPNHOST_OKTOQUERYFORADDRESSING ) ) ) // flags
        {
            if (hr == DPNERR_USERCANCEL || hr == DPNERR_INVALIDDEVICEADDRESS)
            {
                s_pNetInfo->m_testResult.m_bCancelled = TRUE;
                return hr;
            }
            s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_CREATESESSION;
            s_pNetInfo->m_testResult.m_hr = hr;
            return hr;
        }
    }
    else
    {
        // Set the peer info
        WCHAR wszPeerName[MAX_PLAYER_NAME];
        ConvertGenericStringToWide( wszPeerName, s_szPlayerName, MAX_PLAYER_NAME );

        DPN_PLAYER_INFO dpPlayerInfo;
        ZeroMemory( &dpPlayerInfo, sizeof(DPN_PLAYER_INFO) );
        dpPlayerInfo.dwSize = sizeof(DPN_PLAYER_INFO);
        dpPlayerInfo.dwInfoFlags = DPNINFO_NAME;
        dpPlayerInfo.pwszName = wszPeerName;

        // Set the peer info, and use the DPNOP_SYNC since by default this
        // is an async call.  If it is not DPNOP_SYNC, then the peer info may not
        // be set by the time we call Connect() below.
        if( FAILED( hr = s_pDP->SetPeerInfo( &dpPlayerInfo, NULL, NULL, DPNOP_SYNC ) ) )
        {
            s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_SETPEERINFO;
            s_pNetInfo->m_testResult.m_hr = hr;
            LeaveCriticalSection( &s_csHostEnum );
            return hr;
        }

        ResetEvent( s_hConnectCompleteEvent );
        s_bConnecting = TRUE;

        // Connect to an existing session. DPNCONNECT_OKTOQUERYFORADDRESSING allows
        // DirectPlay to prompt the user using a dialog box for any device address
        // or host address information that is missing
        // We also pass in copies of the app desc and host addr, since pDPHostEnumSelected
        // might be deleted from another thread that calls SessionsDlgExpireOldHostEnums().
        // This process could also be done using reference counting instead.
        hr = s_pDP->Connect( s_pDPHostEnumSelected->pAppDesc,       // the application desc
                             s_pDPHostEnumSelected->pHostAddr,      // address of the host of the session
                             s_pDPHostEnumSelected->pDeviceAddr,    // address of the local device the enum responses were received on
                             NULL, NULL,                          // DPN_SECURITY_DESC, DPN_SECURITY_CREDENTIALS
                             NULL, 0,                             // user data, user data size
                             NULL,                                // player context,
                             NULL, &s_hConnectAsyncOp,            // async context, async handle,
                             DPNCONNECT_OKTOQUERYFORADDRESSING ); // flags

        LeaveCriticalSection( &s_csHostEnum );

        if( hr != E_PENDING && FAILED(hr) )
        {
            if (hr == DPNERR_USERCANCEL)
            {
                s_pNetInfo->m_testResult.m_bCancelled = TRUE;
                return hr;
            }
            s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_JOINSESSION;
            s_pNetInfo->m_testResult.m_hr = hr;
            return hr;
        }

        // Set a timer to wait for m_hConnectCompleteEvent to be signaled.
        // This will tell us when DPN_MSGID_CONNECT_COMPLETE has been processed
        // which lets us know if the connect was successful or not.
        PostMessage( s_hDlg, WM_APP_CONNECTING, 0, 0 );
        SetTimer( s_hDlg, TIMER_WAIT_CONNECT_COMPLETE, 100, NULL );
        EnableWindow( GetDlgItem( s_hDlg, IDC_SEND), FALSE );
    }

    return S_OK;
}


/****************************************************************************
 *
 *  LoadStringWide
 *
 ****************************************************************************/
VOID LoadStringWide( int nID, WCHAR* szWide )
{
    TCHAR sz[MAX_PATH];
    LoadString(NULL, nID, sz, MAX_PATH);
    ConvertGenericStringToWide( szWide, sz, MAX_PATH );
}


/****************************************************************************
 *
 *  ShowTextString
 *
 ****************************************************************************/
VOID ShowTextString( HWND hDlg, WCHAR* sz )
{
    TCHAR szT[MAX_CHAT_STRING];
    ConvertWideStringToGeneric( szT, sz, MAX_CHAT_STRING );

    LONG numChars = (LONG)SendMessage(GetDlgItem(hDlg, IDC_CHATOUTPUT), WM_GETTEXTLENGTH, 0, 0);
    SendMessage(GetDlgItem(hDlg, IDC_CHATOUTPUT), EM_SETSEL, numChars, numChars);
    SendMessage(GetDlgItem(hDlg, IDC_CHATOUTPUT), EM_REPLACESEL, FALSE, (LPARAM)szT);
}


/****************************************************************************
 *
 *  SendChatMessage
 *
 ****************************************************************************/
HRESULT SendChatMessage( TCHAR* szMessage )
{
    // Send a message to all of the players
    GAMEMSG_CHAT msgChat;
    msgChat.nType = GAME_MSGID_CHAT;
    ConvertGenericStringToWide( msgChat.strChatString, szMessage, MAX_CHAT_STRING_LENGTH-1 );
    msgChat.strChatString[MAX_CHAT_STRING_LENGTH-1] = 0;

    DPN_BUFFER_DESC bufferDesc;
    bufferDesc.dwBufferSize = sizeof(GAMEMSG_CHAT);
    bufferDesc.pBufferData  = (BYTE*) &msgChat;

    DPNHANDLE hAsync;
    s_pDP->SendTo( DPNID_ALL_PLAYERS_GROUP, &bufferDesc, 1,
                   0, NULL, &hAsync, 0 );

    return S_OK;
}


/****************************************************************************
 *
 *  DirectPlayMessageHandler
 *
 ****************************************************************************/
HRESULT WINAPI DirectPlayMessageHandler( PVOID pvUserContext, 
                                         DWORD dwMessageId, 
                                         PVOID pMsgBuffer )
{
    switch( dwMessageId )
    {
        case DPN_MSGID_CONNECT_COMPLETE:
        {
            PDPNMSG_CONNECT_COMPLETE pConnectCompleteMsg;
            pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE)pMsgBuffer;

            // Set m_hrConnectComplete, then set an event letting
            // everyone know that the DPN_MSGID_CONNECT_COMPLETE msg
            // has been handled
            s_hrConnectComplete = pConnectCompleteMsg->hResultCode;
            SetEvent( s_hConnectCompleteEvent );
            break;
        }

        case DPN_MSGID_ENUM_HOSTS_RESPONSE:
        {
            PDPNMSG_ENUM_HOSTS_RESPONSE pEnumHostsResponseMsg;
            pEnumHostsResponseMsg = (PDPNMSG_ENUM_HOSTS_RESPONSE)pMsgBuffer;

            // Take note of the host response
            SessionsDlgNoteEnumResponse( pEnumHostsResponseMsg );
            break;
        }

        case DPN_MSGID_ASYNC_OP_COMPLETE:
        {
            PDPNMSG_ASYNC_OP_COMPLETE pAsyncOpCompleteMsg;
            pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE)pMsgBuffer;

            if( pAsyncOpCompleteMsg->hAsyncOp == s_hEnumAsyncOp )
            {
                SessionsDlgEnumListCleanup();
                s_hEnumAsyncOp = NULL;

                // Ignore errors if we are connecting already or something else failed
                if( !s_bConnecting && s_pNetInfo->m_testResult.m_iStepThatFailed == 0 )
                {
                    if( FAILED(pAsyncOpCompleteMsg->hResultCode) )
                    {
                        if( pAsyncOpCompleteMsg->hResultCode == DPNERR_USERCANCEL )
                        {
                            s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ENUMSESSIONS;
                            s_pNetInfo->m_testResult.m_hr = pAsyncOpCompleteMsg->hResultCode;
                            s_pNetInfo->m_testResult.m_bCancelled = TRUE;
                        }
                        else if( pAsyncOpCompleteMsg->hResultCode == DPNERR_ADDRESSING )
                        {
                            TCHAR szTitle[MAX_PATH];
                            TCHAR szMessage[MAX_PATH];
                            LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
                            LoadString(NULL, IDS_SESSIONLISTERROR, szMessage, MAX_PATH);
                            MessageBox(s_hwndSessionDlg, szMessage, szTitle, MB_OK);

                            s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ENUMSESSIONS;
                            s_pNetInfo->m_testResult.m_hr = pAsyncOpCompleteMsg->hResultCode;
                            s_pNetInfo->m_testResult.m_bCancelled = TRUE;
                        }
                        else
                        {
                            s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ENUMSESSIONS;
                            s_pNetInfo->m_testResult.m_hr = pAsyncOpCompleteMsg->hResultCode;
                        }

                        EndDialog(s_hwndSessionDlg, 1);
                    }
                }
            }
            break;
        }

        case DPN_MSGID_TERMINATE_SESSION:
        {
            PDPNMSG_TERMINATE_SESSION pTerminateSessionMsg;
            pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION)pMsgBuffer;

            EndDialog(s_hDlg,0);
            break;
        }

        case DPN_MSGID_CREATE_PLAYER:
        {
            HRESULT hr;
            PDPNMSG_CREATE_PLAYER pCreatePlayerMsg;
            pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER)pMsgBuffer;

            // Get the peer info and extract its name
            DWORD dwSize = 0;
            DPN_PLAYER_INFO* pdpPlayerInfo = NULL;
            // Create a new and fill in a APP_PLAYER_INFO
            APP_PLAYER_INFO* pPlayerInfo = new APP_PLAYER_INFO;
            ZeroMemory( pPlayerInfo, sizeof(APP_PLAYER_INFO) );
            pPlayerInfo->dpnidPlayer = pCreatePlayerMsg->dpnidPlayer;
            wcscpy( pPlayerInfo->strPlayerName, L"???" );
            pPlayerInfo->lRefCount   = 1;

            hr = s_pDP->GetPeerInfo( pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0 );
            if( SUCCEEDED(hr) || hr == DPNERR_BUFFERTOOSMALL )
            {
                pdpPlayerInfo = (DPN_PLAYER_INFO*) new BYTE[ dwSize ];
                ZeroMemory( pdpPlayerInfo, dwSize );
                pdpPlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);

                hr = s_pDP->GetPeerInfo( pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0 );
                if( SUCCEEDED(hr) ) 
                {
                    // This stores a extra TCHAR copy of the player name for 
                    // easier access.  This will be redundent copy since DPlay 
                    // also keeps a copy of the player name in GetPeerInfo()
                    wcsncpy( pPlayerInfo->strPlayerName, 
                             pdpPlayerInfo->pwszName, MAX_PLAYER_NAME );
                    pPlayerInfo->strPlayerName[MAX_PLAYER_NAME-1] = 0;
                }
            }

            if( pdpPlayerInfo->dwPlayerFlags & DPNPLAYER_LOCAL )
                s_dpnidLocalPlayer = pCreatePlayerMsg->dpnidPlayer;

            delete[] pdpPlayerInfo;
            pdpPlayerInfo = NULL;

            if( s_hDlg )
            {
                // Record the buffer handle so the buffer can be returned later 
                APP_PLAYER_MSG* pPlayerMsg = new APP_PLAYER_MSG;
                wcscpy( pPlayerMsg->strPlayerName, pPlayerInfo->strPlayerName );

                // Pass the APP_PLAYER_MSG to the main dialog thread, so it can
                // process it.  It will also cleanup the struct
                PostMessage( s_hDlg, WM_APP_JOIN, pPlayerInfo->dpnidPlayer, (LPARAM) pPlayerMsg );
            }

            // Tell DirectPlay to store this pPlayerInfo 
            // pointer in the pvPlayerContext.
            pCreatePlayerMsg->pvPlayerContext = pPlayerInfo;

            // Update the number of active players, and 
            // post a message to the dialog thread to update the 
            // UI.  This keeps the DirectPlay message handler 
            // from blocking
            InterlockedIncrement( &s_lNumberOfActivePlayers );

            break;
        }

        case DPN_MSGID_DESTROY_PLAYER:
        {
            PDPNMSG_DESTROY_PLAYER pDestroyPlayerMsg;
            pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER)pMsgBuffer;
            APP_PLAYER_INFO* pPlayerInfo = (APP_PLAYER_INFO*) pDestroyPlayerMsg->pvPlayerContext;

            if( s_hDlg )
            {
                // Record the buffer handle so the buffer can be returned later 
                APP_PLAYER_MSG* pPlayerMsg = new APP_PLAYER_MSG;
                wcscpy( pPlayerMsg->strPlayerName, pPlayerInfo->strPlayerName );

                // Pass the APP_PLAYER_MSG to the main dialog thread, so it can
                // process it.  It will also cleanup the struct
                PostMessage( s_hDlg, WM_APP_LEAVE, pPlayerInfo->dpnidPlayer, (LPARAM) pPlayerMsg );
            }

            PLAYER_LOCK();                  // enter player context CS
            PLAYER_RELEASE( pPlayerInfo );  // Release player and cleanup if needed
            PLAYER_UNLOCK();                // leave player context CS

            // Update the number of active players, and 
            // post a message to the dialog thread to update the 
            // UI.  This keeps the DirectPlay message handler 
            // from blocking
            InterlockedDecrement( &s_lNumberOfActivePlayers );
            break;
        }

        case DPN_MSGID_RECEIVE:
        {
            PDPNMSG_RECEIVE pReceiveMsg;
            pReceiveMsg = (PDPNMSG_RECEIVE)pMsgBuffer;
            APP_PLAYER_INFO* pPlayerInfo = (APP_PLAYER_INFO*) pReceiveMsg->pvPlayerContext;

            GAMEMSG_GENERIC* pMsg = (GAMEMSG_GENERIC*) pReceiveMsg->pReceiveData;
            
            if( pReceiveMsg->dwReceiveDataSize == sizeof(GAMEMSG_CHAT) &&
                pMsg->nType == GAME_MSGID_CHAT )
            {
                // This message is sent when a player has send a chat message to us, so 
                // post a message to the dialog thread to update the UI.  
                // This keeps the DirectPlay threads from blocking, and also
                // serializes the recieves since DirectPlayMessageHandler can
                // be called simultaneously from a pool of DirectPlay threads.
                GAMEMSG_CHAT* pChatMessage = (GAMEMSG_CHAT*) pMsg;

                // Record the buffer handle so the buffer can be returned later 
                APP_QUEUE_CHAT_MSG* pQueuedChat = new APP_QUEUE_CHAT_MSG;
                _snwprintf( pQueuedChat->strChatBuffer, MAX_CHAT_STRING, L"<%s> %s\r\n", 
                                pPlayerInfo->strPlayerName, 
                                pChatMessage->strChatString );
                pQueuedChat->strChatBuffer[MAX_CHAT_STRING-1]=0;

                // Pass the APP_QUEUE_CHAT_MSG to the main dialog thread, so it can
                // process it.  It will also cleanup the struct
                PostMessage( s_hDlg, WM_APP_CHAT, pPlayerInfo->dpnidPlayer, (LPARAM) pQueuedChat );
            }
            break;
        }
    }
    
    return S_OK;
}


/****************************************************************************
 *
 *  ConvertAnsiStringToWide
 *
 ****************************************************************************/
VOID ConvertAnsiStringToWide( WCHAR* wstrDestination, const CHAR* strSource, 
                                     int cchDestChar )
{
    if( wstrDestination==NULL || strSource==NULL )
        return;

    if( cchDestChar == -1 )
        cchDestChar = strlen(strSource)+1;

    MultiByteToWideChar( CP_ACP, 0, strSource, -1, 
                         wstrDestination, cchDestChar-1 );

    wstrDestination[cchDestChar-1] = 0;
}


/****************************************************************************
 *
 *  ConvertGenericStringToWide
 *
 ****************************************************************************/
VOID ConvertGenericStringToWide( WCHAR* wstrDestination, const TCHAR* tstrSource, int cchDestChar )
{
    if( wstrDestination==NULL || tstrSource==NULL )
        return;

#ifdef _UNICODE
    if( cchDestChar == -1 )
        wcscpy( wstrDestination, tstrSource );
    else
    {
        wcsncpy( wstrDestination, tstrSource, cchDestChar );
        wstrDestination[cchDestChar-1] = 0;
    }
#else
    ConvertAnsiStringToWide( wstrDestination, tstrSource, cchDestChar );
#endif
}


/****************************************************************************
 *
 *  ConvertWideStringToGeneric
 *
 ****************************************************************************/
VOID ConvertWideStringToGeneric( TCHAR* tstrDestination, const WCHAR* wstrSource, int cchDestChar )
{
    if( tstrDestination==NULL || wstrSource==NULL )
        return;

#ifdef _UNICODE
    if( cchDestChar == -1 )
        wcscpy( tstrDestination, wstrSource );
    else
    {
        wcsncpy( tstrDestination, wstrSource, cchDestChar );
        tstrDestination[cchDestChar-1] = 0;
    }

#else
    ConvertWideStringToAnsi( tstrDestination, wstrSource, cchDestChar );
#endif
}


/****************************************************************************
 *
 *  ConvertWideStringToAnsi
 *
 ****************************************************************************/
VOID ConvertWideStringToAnsi( CHAR* strDestination, const WCHAR* wstrSource, int cchDestChar )
{
    if( strDestination==NULL || wstrSource==NULL )
        return;

    if( cchDestChar == -1 )
        cchDestChar = wcslen(wstrSource)+1;

    WideCharToMultiByte( CP_ACP, 0, wstrSource, -1, strDestination, 
                         cchDestChar-1, NULL, NULL );

    strDestination[cchDestChar-1] = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3d\sources.inc ===
MAJORCOMP=d3dim
MINORCOMP=d3dim
TARGETNAME=d3dim
TARGETPATH=obj

TARGETTYPE=DYNLINK
DLLDEF=$O\$(TARGETNAME).def

!IFDEF NTBBT
X3DLIB=x3dbbt.lib
INTELLIB=ipsgpbbt.lib
INTELKLIB=ikpsgpbbt.lib
!ELSE
X3DLIB=x3d.lib
INTELLIB=ipsgp.lib
INTELKLIB=ikpsgp.lib
!ENDIF

SYNCHRONIZE_DRAIN = 1

INCLUDES=$(DXROOT)\inc;$(INCLUDES)

TARGETLIBS = \
        $(BASEDIR)\public\sdk\lib\*\gdi32.lib\
        $(BASEDIR)\public\sdk\lib\*\user32.lib\
        $(BASEDIR)\public\sdk\lib\*\advapi32.lib\
        $(BASEDIR)\public\sdk\lib\*\uuid.lib

!if !($(AMD64) || $(IA64))
TARGETLIBS=$(TARGETLIBS) \
           $(D3DDX6)\lib\$(PLAT_DIR)\*\$(X3DLIB) \
           $(D3DDX6)\lib\$(PLAT_DIR)\*\$(INTELLIB) \
           $(D3DDX6)\lib\$(PLAT_DIR)\*\$(INTELKLIB)
!endif

LINKLIBS = \
        $(D3DDX6)\d3dutil\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dutil.lib \
        $(D3DDX6)\pipeln\$(PLAT_DIR)\$(_OBJ_DIR)\*\pipeln.lib \
        $(D3DDX6)\d3dim\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dim.lib \
        $(D3DDX6)\rast\mmxemul\$(PLAT_DIR)\$(_OBJ_DIR)\*\mmxemul.lib \
        $(D3DDX6)\rast\cspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rcspan.lib \
        $(D3DDX6)\rast\rampspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rrmpspan.lib \
        $(D3DDX6)\rast\rampmat\$(PLAT_DIR)\$(_OBJ_DIR)\*\rrampmat.lib \
        $(D3DDX6)\rast\mlspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rmlspan.lib \
        $(D3DDX6)\rast\spaninit\$(PLAT_DIR)\$(_OBJ_DIR)\*\rspanini.lib \
        $(D3DDX6)\rast\setup\$(PLAT_DIR)\$(_OBJ_DIR)\*\rsetup.lib \
        $(D3DDX6)\rast\d3dif\$(PLAT_DIR)\$(_OBJ_DIR)\*\rd3dif.lib

!if !($(AMD64) || $(IA64))
LINKLIBS=$(LINKLIBS) \
         $(D3DDX6)\rast\mmxspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rmmxspan.lib
!endif

DLLENTRY = _DllMainCRTStartup

SOURCES = ..\d3dim.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\testnet.h ===
/****************************************************************************
 *
 *    File: testnet.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Test DPlay functionality on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef TESTNET_H
#define TESTNET_H

VOID TestNetwork(HWND hwndMain, NetInfo* pNetInfo);


#endif // TESTNet_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxdiag\testsnd.cpp ===
/****************************************************************************
 *
 *    File: testsnd.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Kerim Erden (a-kerime@microsoft.com)
 * Purpose: Test DSound functionality on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#define DIRECTSOUND_VERSION  0x0600
#include <Windows.h>
#include <mmsystem.h>
#include <d3dtypes.h>
#include <dsound.h>
#include "resource.h"
#include "reginfo.h"
#include "sysinfo.h"
#include "dispinfo.h"
#include "sndinfo.h"
#include "testsnd.h"

struct WAVE
{
    WAVEFORMATEX* psHeader;
    LPBYTE pData;
    DWORD dwSize;
};

typedef HRESULT (WINAPI* LPDIRECTSOUNDCREATE)(GUID* pGUID, LPDIRECTSOUND* ppDS, 
                                              IUnknown* pUnkOuter);

enum TESTID
{
    TESTID_LOAD_DSOUND_DLL = 1,
    TESTID_GET_DIRECTSOUNDCREATE,
    TESTID_DIRECTSOUNDCREATE,
    TESTID_SETCOOP,
    TESTID_GETCAPS,
    TESTID_LOADWAVDATA,
    TESTID_EMULDRIVER,
    TESTID_PRIMBUF,
    TESTID_NOFREEHWBUF,
    TESTID_SECBUF,
    TESTID_SETPOS,
    TESTID_NOSAMPLE,
    TESTID_CREATEEVENT,
    TESTID_SETNOTIF,
    TESTID_LOCKFAIL,
    TESTID_UNLOCKFAIL,
    TESTID_PLAY,
    TESTID_GETCURPOS,
    TESTID_USER_VERIFY_SOFTWARE,
    TESTID_USER_VERIFY_HARDWARE
};

BOOL BTranslateError(HRESULT hr, TCHAR* psz, BOOL bEnglish = FALSE); // from main.cpp (yuck)

static BOOL TestDSInit(HWND hwndMain, LPDIRECTSOUND* ppDS, HINSTANCE* phInstDS, 
    SoundInfo* pSoundInfo);
static BOOL TestDSPlay(HWND hWndMain, DSCAPS* pDSCaps, LPDIRECTSOUND pDS, 
    SoundInfo* pSoundInfo, WAVE* pWave, BOOL bHardware, BOOL b3D);
static BOOL PlayDSound(HWND hWndMain, DSCAPS* pDSCaps, LPDIRECTSOUNDBUFFER pPrim, 
    LPDIRECTSOUNDBUFFER pSec, WAVEFORMATEX* pPrimFmt, DWORD dwBufSize, 
    SoundInfo* pSoundInfo, WAVE* pWave, BOOL bHardware, BOOL b3D);
static BOOL LoadTestData(WAVE* pWave);
static VOID FillFormat(WAVEFORMATEX* pWFM);
static VOID TestDSTerm(LPDIRECTSOUND* ppDS, HINSTANCE* phInstDS, SoundInfo* pSoundInfo);
static VOID TestDSReport(SoundInfo* pSoundInfo);

static BOOL s_b16BitWarningGiven = FALSE;


/****************************************************************************
 *
 *  TestSnd
 *
 ****************************************************************************/
VOID TestSnd(HWND hwndMain, SoundInfo* pSoundInfo)
{
    HINSTANCE hInstDS = NULL;
    LPDIRECTSOUND pDS = NULL;
    DSCAPS sDSCaps;
    HRESULT hr = S_OK;
    WAVE sWaveTest;
    TCHAR sz[300];
    TCHAR szTitle[100];

    // Remove info from any previous test:
    ZeroMemory(&pSoundInfo->m_testResultSnd, sizeof(TestResult));
    s_b16BitWarningGiven = FALSE;

    LoadString(NULL, IDS_STARTDSOUNDTEST, sz, 300);
    LoadString(NULL, IDS_APPFULLNAME, szTitle, 100);
    if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
    {
        pSoundInfo->m_testResultSnd.m_bCancelled = TRUE;
        TestDSReport(pSoundInfo);
        return;
    }

    // Remove info from any previous test:
    ZeroMemory(&pSoundInfo->m_testResultSnd, sizeof(TestResult));

    pSoundInfo->m_testResultSnd.m_bStarted = TRUE;

    if (!TestDSInit(hwndMain, &pDS, &hInstDS, pSoundInfo))
        goto LEnd;

    // Get Caps
    ZeroMemory(&sDSCaps, sizeof(sDSCaps));
    sDSCaps.dwSize = sizeof(sDSCaps);
    if (FAILED(hr = pDS->GetCaps(&sDSCaps)))
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_GETCAPS;
        pSoundInfo->m_testResultSnd.m_hr = hr;
        goto LEnd;
    }

    if (!LoadTestData(&sWaveTest))
    {
        // report cannot load wave data
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_LOADWAVDATA;
        pSoundInfo->m_testResultSnd.m_hr = E_FAIL;
        goto LEnd;
    }

    // Check 2D, software buffers
    if (!TestDSPlay(hwndMain, &sDSCaps, pDS, pSoundInfo, &sWaveTest, FALSE, FALSE))
        goto LEnd;

    // Check 3D, software buffers
    if (!TestDSPlay(hwndMain, &sDSCaps, pDS, pSoundInfo, &sWaveTest, FALSE, TRUE))
        goto LEnd;

    if (sDSCaps.dwFlags & DSCAPS_EMULDRIVER || 
       (sDSCaps.dwFreeHw3DStaticBuffers == 0 && sDSCaps.dwFreeHwMixingStaticBuffers == 0) )
    {
        LoadString(NULL, IDS_NOHARDWAREBUFFERING, sz, 300);
        MessageBox(hwndMain, sz, szTitle, MB_OK);
        goto LEnd;
    }

    // Check 2D, hardware buffers
    if (!TestDSPlay(hwndMain, &sDSCaps, pDS, pSoundInfo, &sWaveTest, TRUE, FALSE))
        goto LEnd;

    // Check 3D, hardware buffers
    if (!TestDSPlay(hwndMain, &sDSCaps, pDS, pSoundInfo, &sWaveTest, TRUE, TRUE))
        goto LEnd;

LEnd:
    TestDSTerm(&pDS, &hInstDS, pSoundInfo);
    TestDSReport(pSoundInfo);
}


/****************************************************************************
 *
 *  TestDSInit
 *
 ****************************************************************************/
BOOL TestDSInit(HWND hwndMain, LPDIRECTSOUND* ppDS, HINSTANCE* phInstDS, 
                SoundInfo* pSoundInfo)
{
    LPDIRECTSOUNDCREATE pDSCreate = NULL;
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];
    
    // Load dsound.dll
    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\dsound.dll"));
    *phInstDS = LoadLibrary(szPath);
    if (NULL == *phInstDS)
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_LOAD_DSOUND_DLL;
        pSoundInfo->m_testResultSnd.m_hr = DDERR_NOTFOUND;
        return FALSE;
    }

    // Get DirectSoundCreate entry point
    pDSCreate = (LPDIRECTSOUNDCREATE)GetProcAddress(*phInstDS, "DirectSoundCreate");
    if (NULL == pDSCreate)
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_GET_DIRECTSOUNDCREATE;
        pSoundInfo->m_testResultSnd.m_hr = DDERR_NOTFOUND;
        return FALSE;
    }

    // Call DirectSoundCreate
    if (FAILED(hr = pDSCreate(NULL, ppDS, NULL)))
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_DIRECTSOUNDCREATE;
        pSoundInfo->m_testResultSnd.m_hr = hr;
        return FALSE;
    }

    // Set cooperative level
    if (FAILED(hr = (*ppDS)->SetCooperativeLevel(hwndMain, DSSCL_EXCLUSIVE)))
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_SETCOOP;
        pSoundInfo->m_testResultSnd.m_hr = hr;
        return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *
 *  TestDSPlay
 *
 ****************************************************************************/
BOOL TestDSPlay(HWND hWndMain, DSCAPS* pDSCaps, LPDIRECTSOUND pDS, 
    SoundInfo* pSoundInfo, WAVE* pWave, BOOL bHardware, BOOL b3D)
{
    BOOL bRet = TRUE;
    DSBUFFERDESC sBufDesc;
    LPDIRECTSOUNDBUFFER pPrimBuf = NULL;
    LPDIRECTSOUNDBUFFER pDSBuf = NULL;
    HRESULT hr = S_OK;
    WAVEFORMATEX sWaveFmt;
    LPDIRECTSOUND3DBUFFER pBuf3D = NULL;

    // Create the Primary Buffer
    ZeroMemory(&sBufDesc, sizeof(sBufDesc));
    sBufDesc.dwSize = sizeof(sBufDesc);
    sBufDesc.dwFlags = DSBCAPS_PRIMARYBUFFER;
    if (b3D)
        sBufDesc.dwFlags |= DSBCAPS_CTRL3D;
    if (FAILED(hr = pDS->CreateSoundBuffer(&sBufDesc, &pPrimBuf, NULL)))
    {
        // Report: Cannot create primary buffer
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_PRIMBUF;
        pSoundInfo->m_testResultSnd.m_hr = hr;
        bRet = FALSE;
        goto LEnd;
    }

    // Create a secondary static buffer
    ZeroMemory(&sBufDesc, sizeof(sBufDesc));
    sBufDesc.dwSize = sizeof(sBufDesc);
    sBufDesc.lpwfxFormat = pWave->psHeader;
    sBufDesc.dwFlags = DSBCAPS_CTRLPOSITIONNOTIFY;
    if (b3D)
        sBufDesc.dwFlags |= DSBCAPS_CTRL3D;
    if (bHardware)
    {
        // Check Hardware free mem
        if ((1 <= (b3D ? pDSCaps->dwFreeHw3DStaticBuffers : pDSCaps->dwFreeHwMixingStaticBuffers)) )
        {
            // Hardware static buffer
            sBufDesc.dwFlags |= DSBCAPS_STATIC | DSBCAPS_LOCHARDWARE;
            sBufDesc.dwBufferBytes = pWave->dwSize;
        }
        else
        {
            // Can't do hardware testing, so exit silently
            goto LEnd;
        }
    }
    else
    {
        sBufDesc.dwFlags |= DSBCAPS_STATIC | DSBCAPS_LOCSOFTWARE;
        sBufDesc.dwBufferBytes = pWave->dwSize;
    }

    if (FAILED(hr = pDS->CreateSoundBuffer(&sBufDesc, &pDSBuf, NULL)))
    {
        if (DSERR_CONTROLUNAVAIL == hr || DSERR_INVALIDPARAM == hr)
        {
            // Driver does not support position notify, try without it
            sBufDesc.dwFlags &= ~DSBCAPS_CTRLPOSITIONNOTIFY;
            hr = pDS->CreateSoundBuffer(&sBufDesc, &pDSBuf, NULL);
        }
        if (FAILED(hr))
        {
            if (hr == DSERR_BADFORMAT || hr == DSERR_INVALIDPARAM)
            {
                // Can't do this test because the test sound's format is not
                // supported.  Skip this test quietly.
                goto LEnd;
            }
            else
            {
                // Report: Cannot create secondary buffer
                pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_SECBUF;
                pSoundInfo->m_testResultSnd.m_hr = hr;
                bRet = FALSE;
                goto LEnd;
            }
        }
    }

    if (b3D)
    {
        if (FAILED(hr = pDSBuf->QueryInterface(IID_IDirectSound3DBuffer, (LPVOID*)&pBuf3D)))
        {
            bRet = FALSE;
            goto LEnd;
        }

        if (FAILED(hr = pBuf3D->SetPosition(D3DVAL(0), D3DVAL(0), D3DVAL(0), DS3D_IMMEDIATE)))
        {
            pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_SETPOS;
            pSoundInfo->m_testResultSnd.m_hr = hr;
            bRet = FALSE;
            goto LEnd;
        }
    }

    // Loop through the formats
    // Check caps, and do not play any formats that are not supported.
    sWaveFmt.wFormatTag = WAVE_FORMAT_PCM;

    // 8 bit mono, 22Khz:
    if ((pDSCaps->dwFlags & DSCAPS_PRIMARY8BIT) && (pDSCaps->dwFlags & DSCAPS_PRIMARYMONO))
    {
        sWaveFmt.wBitsPerSample = 8;
        sWaveFmt.nChannels = 1;
        sWaveFmt.nSamplesPerSec = 22050;
        if (!(pDSCaps->dwFlags & DSCAPS_CONTINUOUSRATE) || 
            ((sWaveFmt.nSamplesPerSec > pDSCaps->dwMinSecondarySampleRate) && 
            (sWaveFmt.nSamplesPerSec < pDSCaps->dwMaxSecondarySampleRate)))
        {
            FillFormat(&sWaveFmt);
            pPrimBuf->SetFormat(&sWaveFmt);
            if (!PlayDSound(hWndMain, pDSCaps, pPrimBuf, pDSBuf, 
                &sWaveFmt, sBufDesc.dwBufferBytes, pSoundInfo, pWave, bHardware, b3D))
            {
                bRet = FALSE;
                goto LEnd;
            }
        }
    }

    // 8 bit stereo, 22Khz:
    if ((pDSCaps->dwFlags & DSCAPS_PRIMARY8BIT) && (pDSCaps->dwFlags & DSCAPS_PRIMARYSTEREO))
    {
        sWaveFmt.wBitsPerSample = 8;
        sWaveFmt.nChannels = 2;
        sWaveFmt.nSamplesPerSec = 22050;
        if (!(pDSCaps->dwFlags & DSCAPS_CONTINUOUSRATE) || 
            ((sWaveFmt.nSamplesPerSec > pDSCaps->dwMinSecondarySampleRate) && 
            (sWaveFmt.nSamplesPerSec < pDSCaps->dwMaxSecondarySampleRate)))
        {
            FillFormat(&sWaveFmt);
            pPrimBuf->SetFormat(&sWaveFmt);
            if (!PlayDSound(hWndMain, pDSCaps, pPrimBuf, pDSBuf, 
                &sWaveFmt, sBufDesc.dwBufferBytes, pSoundInfo, pWave, bHardware, b3D))
            {
                bRet = FALSE;
                goto LEnd;
            }
        }
    }

    // 16 bit mono, 22Khz:
    if ((pDSCaps->dwFlags & DSCAPS_PRIMARY16BIT) && (pDSCaps->dwFlags & DSCAPS_PRIMARYMONO))
    {
        sWaveFmt.wBitsPerSample = 16;
        sWaveFmt.nChannels = 1;
        sWaveFmt.nSamplesPerSec = 22050;
        if (!(pDSCaps->dwFlags & DSCAPS_CONTINUOUSRATE) || 
            ((sWaveFmt.nSamplesPerSec > pDSCaps->dwMinSecondarySampleRate) && 
            (sWaveFmt.nSamplesPerSec < pDSCaps->dwMaxSecondarySampleRate)))
        {
            FillFormat(&sWaveFmt);
            pPrimBuf->SetFormat(&sWaveFmt);
            if (!s_b16BitWarningGiven)
            {
                WAVEFORMATEX wavefmt;
                wavefmt.cbSize = sizeof(wavefmt);
                if (SUCCEEDED(pPrimBuf->GetFormat(&wavefmt, sizeof(wavefmt), NULL)) &&
                    wavefmt.wBitsPerSample != 16)
                {
                    TCHAR szTitle[100];
                    TCHAR szMessage[500];
                    LoadString(NULL, IDS_APPFULLNAME, szTitle, 100);
                    LoadString(NULL, IDS_NO16BITWARNING, szMessage, 500);
                    MessageBox(hWndMain, szMessage, szTitle, MB_OK);
                    s_b16BitWarningGiven = TRUE;
                }
            }
            
            if (!PlayDSound(hWndMain, pDSCaps, pPrimBuf, pDSBuf, 
                &sWaveFmt, sBufDesc.dwBufferBytes, pSoundInfo, pWave, bHardware, b3D))
            {
                bRet = FALSE;
                goto LEnd;
            }
        }
    }

    // 16 bit stereo, 22Khz:
    if ((pDSCaps->dwFlags & DSCAPS_PRIMARY16BIT) && (pDSCaps->dwFlags & DSCAPS_PRIMARYSTEREO))
    {
        sWaveFmt.wBitsPerSample = 16;
        sWaveFmt.nChannels = 2;
        sWaveFmt.nSamplesPerSec = 22050;
        if (!(pDSCaps->dwFlags & DSCAPS_CONTINUOUSRATE) || 
            ((sWaveFmt.nSamplesPerSec > pDSCaps->dwMinSecondarySampleRate) && 
            (sWaveFmt.nSamplesPerSec < pDSCaps->dwMaxSecondarySampleRate)))
        {
            FillFormat(&sWaveFmt);
            pPrimBuf->SetFormat(&sWaveFmt);
            if (!PlayDSound(hWndMain, pDSCaps, pPrimBuf, pDSBuf, 
                &sWaveFmt, sBufDesc.dwBufferBytes, pSoundInfo, pWave, bHardware, b3D))
            {
                bRet = FALSE;
                goto LEnd;
            }
        }
    }

LEnd:
    if (NULL != pPrimBuf)
        pPrimBuf->Release();
    if (NULL != pBuf3D)
        pBuf3D->Release();
    if (NULL != pDSBuf)
        pDSBuf->Release();

    return bRet;
}


/****************************************************************************
 *
 *  PlayDSound
 *
 ****************************************************************************/
BOOL PlayDSound(HWND hWndMain, DSCAPS* pDSCaps, LPDIRECTSOUNDBUFFER pPrim, 
    LPDIRECTSOUNDBUFFER pSec, WAVEFORMATEX* pPrimFmt, DWORD dwBufSize, 
    SoundInfo* pSoundInfo, WAVE* pWave, BOOL bHardware, BOOL b3D)
{
    HRESULT hr;
    VOID* pData = NULL;
    DWORD dwSize;
    LPDIRECTSOUNDNOTIFY pDSNot = NULL;
    HANDLE hNotEvent = NULL;
    DSBPOSITIONNOTIFY sPosNot;
    TCHAR szOut[MAX_PATH];
    DWORD dwCur = 0;
    TCHAR sz[300];
    TCHAR szTitle[100];

    LoadString(NULL, IDS_APPFULLNAME, szTitle, 100);

    if (FAILED(hr = pSec->QueryInterface(IID_IDirectSoundNotify, (LPVOID*)&pDSNot)))
    {
        pDSNot = NULL;
    }

    hNotEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == hNotEvent)
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_CREATEEVENT;
        pSoundInfo->m_testResultSnd.m_hr = S_FALSE;
        return FALSE;
    }

    if (NULL != pDSNot)
    {
        sPosNot.dwOffset = DSBPN_OFFSETSTOP;
        sPosNot.hEventNotify = hNotEvent;
        if (FAILED(hr = pDSNot->SetNotificationPositions(1, &sPosNot)))
        {
            pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_SETNOTIF;
            pSoundInfo->m_testResultSnd.m_hr = hr;
            return FALSE;
        }
    }

    if (FAILED(hr = pSec->Lock(0, dwBufSize, &pData, &dwSize, NULL, 
        0, DSBLOCK_ENTIREBUFFER)))
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_LOCKFAIL;
        pSoundInfo->m_testResultSnd.m_hr = hr;
        return FALSE;
    }

    memcpy(pData, pWave->pData, dwSize);

    if (FAILED(hr = pSec->Unlock(pData, dwSize, NULL, 0)))
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_UNLOCKFAIL;
        pSoundInfo->m_testResultSnd.m_hr = hr;
        return FALSE;
    }

    // Play the buffer
    pSec->SetCurrentPosition(0);
    if (FAILED(hr = pSec->Play(0, 0, 0)))
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_PLAY;
        pSoundInfo->m_testResultSnd.m_hr = hr;
        return FALSE;
    }

    WaitForSingleObject(hNotEvent, (pWave->dwSize * 1000 / pWave->psHeader->nAvgBytesPerSec));

    pSec->Stop();
    CloseHandle(hNotEvent);
    if (NULL != pDSNot)
        pDSNot->Release();

    TCHAR sz3D[50];
    TCHAR szChannelDesc[50];
    TCHAR szHWSW[50];
    LoadString(NULL, IDS_THATSOUNDWAS, sz, 300);
    if (b3D)
    {
        LoadString(NULL, IDS_3D, sz3D, 50);
        lstrcat(sz3D, TEXT(" "));
    }
    else
    {
        lstrcpy(sz3D, TEXT(""));
    }

    if (pPrimFmt->nChannels == 1)
        LoadString(NULL, IDS_MONO, szChannelDesc, 50);
    else if (pPrimFmt->nChannels == 2)
        LoadString(NULL, IDS_STEREO, szChannelDesc, 50);
    else
        LoadString(NULL, IDS_MULTICHANNEL, szChannelDesc, 50);

    if (bHardware)
        LoadString(NULL, IDS_HARDWARE, szHWSW, 50);
    else
        LoadString(NULL, IDS_SOFTWARE, szHWSW, 50);

    wsprintf(szOut, sz, sz3D, szChannelDesc, pPrimFmt->wBitsPerSample,
        pPrimFmt->nSamplesPerSec / 1000, szHWSW);

    INT iReply;
    iReply = MessageBox(hWndMain, szOut, szTitle, MB_YESNOCANCEL);
    if (IDYES == iReply)
    {
        return TRUE;
    }
    else if (IDNO == iReply)
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = (TRUE == bHardware) ? 
            TESTID_USER_VERIFY_HARDWARE : TESTID_USER_VERIFY_SOFTWARE;
        pSoundInfo->m_testResultSnd.m_hr = hr;
        return FALSE;
    }
    else // IDCANCEL
    {
        pSoundInfo->m_testResultSnd.m_bCancelled = TRUE;
        return FALSE;
    }

}


/****************************************************************************
 *
 *  LoadTestData
 *
 ****************************************************************************/
BOOL LoadTestData(WAVE* pWave)
{
    DWORD dwRiff;
    DWORD dwType;
    DWORD dwLength;
    HRSRC hResInfo = NULL;
    HGLOBAL hResData = NULL;
    DWORD* pdw = NULL;
    DWORD* pdwEnd = NULL;
    VOID* pData = NULL;
    WAVEFORMATEX** ppWaveHeader = &pWave->psHeader;
    LPBYTE* ppbWaveData = &pWave->pData;
    DWORD* pcbWaveSize = &pWave->dwSize;

    if (NULL == pWave)
        return FALSE;

    if (NULL == (hResInfo = FindResource(NULL, MAKEINTRESOURCE(IDR_WAVTST), TEXT("WAVE"))))
        return FALSE;
    if (NULL == (hResData = LoadResource(NULL, hResInfo)))
        return FALSE;
    if (NULL == (pData = LockResource(hResData)))
        return FALSE;

    pWave->psHeader = NULL;
    pWave->pData = NULL;
    pWave->dwSize = 0;

    pdw = (DWORD *)pData;
    dwRiff = *pdw++;
    dwLength = *pdw++;
    dwType = *pdw++;

    if (dwRiff != mmioFOURCC('R', 'I', 'F', 'F'))
        return FALSE;

    if (dwType != mmioFOURCC('W', 'A', 'V', 'E'))
        return FALSE;

    pdwEnd = (DWORD*)((BYTE*)pdw + dwLength - 4);

    while (pdw < pdwEnd)
    {
        dwType = *pdw++;
        dwLength = *pdw++;

        switch (dwType)
        {
            case mmioFOURCC('f', 'm', 't', ' '):
                if (ppWaveHeader && !*ppWaveHeader)
                {
                    if (dwLength < sizeof(WAVEFORMAT))
                        return FALSE;

                    *ppWaveHeader = (WAVEFORMATEX*)pdw;

                    if ((!ppbWaveData || *ppbWaveData) && (!pcbWaveSize || *pcbWaveSize))
                        return TRUE;
                }
                break;

            case mmioFOURCC('d', 'a', 't', 'a'):
                if ((ppbWaveData && !*ppbWaveData) || (pcbWaveSize && !*pcbWaveSize))
                {
                    if (ppbWaveData)
                        *ppbWaveData = (LPBYTE)pdw;

                    if (pcbWaveSize)
                        *pcbWaveSize = dwLength;

                    if (!ppWaveHeader || *ppWaveHeader)
                        return TRUE;
                }
                break;
        }

        pdw = (DWORD*)((BYTE*)pdw + ((dwLength + 1) & ~1));
    }
    return FALSE;
}


/****************************************************************************
 *
 *  FillFormat
 *
 ****************************************************************************/
VOID FillFormat(WAVEFORMATEX* pWFM)
{ 
    pWFM->nBlockAlign = (pWFM->nChannels * pWFM->wBitsPerSample) / 8;
    pWFM->nAvgBytesPerSec = pWFM->nSamplesPerSec * pWFM->nBlockAlign;
}


/****************************************************************************
 *
 *  TestDSTerm
 *
 ****************************************************************************/
VOID TestDSTerm(LPDIRECTSOUND* ppDS, HINSTANCE* phInstDS, SoundInfo* pSoundInfo)
{
    if (NULL != *ppDS)
    {
        (*ppDS)->Release();
        *ppDS = NULL;
    }

    if (NULL != *phInstDS)
        FreeLibrary(*phInstDS);
}


/****************************************************************************
 *
 *  TestDSReport
 *
 ****************************************************************************/
VOID TestDSReport(SoundInfo* pSoundInfo)
{
    if (pSoundInfo->m_testResultSnd.m_bCancelled)
    {
        LoadString(NULL, IDS_TESTSCANCELLED, pSoundInfo->m_testResultSnd.m_szDescription, 300);
        LoadString(NULL, IDS_TESTSCANCELLED_ENGLISH, pSoundInfo->m_testResultSnd.m_szDescriptionEnglish, 300);
    }
    else
    {
        if (pSoundInfo->m_testResultSnd.m_iStepThatFailed == 0)
        {
            LoadString(NULL, IDS_TESTSSUCCESSFUL, pSoundInfo->m_testResultSnd.m_szDescription, 300);
            LoadString(NULL, IDS_TESTSSUCCESSFUL_ENGLISH, pSoundInfo->m_testResultSnd.m_szDescriptionEnglish, 300);
        }
        else
        {
            TCHAR szDesc[200];
            TCHAR szError[200];
            TCHAR sz[300];
            if (0 == LoadString(NULL, IDS_FIRSTDSOUNDTESTERROR + pSoundInfo->m_testResultSnd.m_iStepThatFailed - 1,
                szDesc, 200))
            {
                LoadString(NULL, IDS_UNKNOWNERROR, szDesc, 200);
            }
            LoadString(NULL, IDS_FAILUREFMT, sz, 300);
            BTranslateError(pSoundInfo->m_testResultSnd.m_hr, szError);
            wsprintf(pSoundInfo->m_testResultSnd.m_szDescription, sz,
                pSoundInfo->m_testResultSnd.m_iStepThatFailed,
                szDesc, pSoundInfo->m_testResultSnd.m_hr, szError);

            // Nonlocalized version:
            if (0 == LoadString(NULL, IDS_FIRSTDSOUNDTESTERROR_ENGLISH + pSoundInfo->m_testResultSnd.m_iStepThatFailed - 1,
                szDesc, 200))
            {
                LoadString(NULL, IDS_UNKNOWNERROR_ENGLISH, szDesc, 200);
            }
            LoadString(NULL, IDS_FAILUREFMT_ENGLISH, sz, 300);
            BTranslateError(pSoundInfo->m_testResultSnd.m_hr, szError, TRUE);
            wsprintf(pSoundInfo->m_testResultSnd.m_szDescriptionEnglish, sz,
                pSoundInfo->m_testResultSnd.m_iStepThatFailed,
                szDesc, pSoundInfo->m_testResultSnd.m_hr, szError);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\bufiunk.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   bufiunk.c
 *  Content:    Direct3DExecuteBuffer IUnknown implementation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   10/12/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * D3DBuf_QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::QueryInterface"

HRESULT D3DAPI DIRECT3DEXECUTEBUFFERI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{

    /*
     * validate parms
     */
    TRY
        {
            if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
                D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
                return DDERR_INVALIDOBJECT;
            }
            if (!VALID_OUTPTR(ppvObj)) {
                D3D_ERR( "Invalid object pointer" );
                return DDERR_INVALIDPARAMS;
            }
        }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
            D3D_ERR( "Exception encountered validating parameters" );
            return DDERR_INVALIDPARAMS;
        }

    *ppvObj = NULL;

    if( IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IDirect3DExecuteBuffer) )
    {
        AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPUNKNOWN>(this));

        return (D3D_OK);
    }
    return (E_NOINTERFACE);

} /* D3DBuf_QueryInterface */

/*
 * D3DBuf_AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::AddRef"

ULONG D3DAPI DIRECT3DEXECUTEBUFFERI::AddRef()
{
    DWORD       rcnt;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
        {
            if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
                D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
                return 0;
            }
        }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
            D3D_ERR( "Exception encountered validating parameters" );
            return 0;
        }

    this->refCnt++;
    rcnt = this->refCnt;

    return (rcnt);

} /* D3DBuf_AddRef */

/*
 * D3DBuf_Release
 *
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::Release"

ULONG D3DAPI DIRECT3DEXECUTEBUFFERI::Release()
{
    DWORD           lastrefcnt;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
        {
            if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
                D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
                return 0;
            }
        }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
            D3D_ERR( "Exception encountered validating parameters" );
            return 0;
        }

    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    lastrefcnt = this->refCnt;

    if( lastrefcnt == 0 )
    {
        delete this;
        return 0;
    }

    return lastrefcnt;

} /* D3DBuf_Release */

DIRECT3DEXECUTEBUFFERI::~DIRECT3DEXECUTEBUFFERI()
{
    if (this->locked) 
        Unlock();

    /* remove us from the Direct3DDevice object list of execute buffers */
    LIST_DELETE(this, list);

    if (this->hBuf) 
    {
        D3DHAL_DeallocateBuffer(this->lpDevI, this->hBuf);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\buffer.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   buffer.c
 *  Content:    Direct3DExecuteBuffer implementation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   10/12/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

HRESULT hookBufferToDevice(LPDIRECT3DDEVICEI lpDevI,
                                  LPDIRECT3DEXECUTEBUFFERI lpD3DBuf)
{

    LIST_INSERT_ROOT(&lpDevI->buffers, lpD3DBuf, list);
    lpD3DBuf->lpDevI = lpDevI;

    return (D3D_OK);
}

HRESULT D3DAPI DIRECT3DEXECUTEBUFFERI::Initialize(LPDIRECT3DDEVICE lpD3DDevice, LPD3DEXECUTEBUFFERDESC lpDesc)
{
    return DDERR_ALREADYINITIALIZED;
}

/*
 * Create the Buffer
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::CreateExecuteBuffer"

HRESULT D3DAPI DIRECT3DDEVICEI::CreateExecuteBuffer(LPD3DEXECUTEBUFFERDESC lpDesc,
                                                    LPDIRECT3DEXECUTEBUFFER* lplpBuffer,
                                                    IUnknown* pUnkOuter)
{
    LPDIRECT3DEXECUTEBUFFERI    lpBuffer;
    HRESULT         ret;
    D3DEXECUTEBUFFERDESC    debDesc;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_D3DEXECUTEBUFFERDESC_PTR(lpDesc)) {
        D3D_ERR( "Invalid D3DEXECUTEBUFFERDESC pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if (!VALID_OUTPTR(lplpBuffer)) {
        D3D_ERR( "Invalid ptr to the buffer pointer" );
        return DDERR_INVALIDPARAMS;
    }

    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    *lplpBuffer = NULL;
    ret = D3D_OK;

    debDesc = *lpDesc;

    /*
     * We need size of the buffer, and optionally some stuff indicating
     * where the app would like the memory to be - system or card.
     */
    if (!debDesc.dwFlags & D3DDEB_BUFSIZE) {
        D3D_ERR("D3DDEB_BUFSIZE flag not set");
        return (DDERR_INVALIDPARAMS);
    }

    /*
     * Zero is an invalid execute buffer size.
     */
    if (debDesc.dwBufferSize == 0) {
        D3D_ERR("dwBufferSize = 0, zero sized execute buffers are illegal");
        return (DDERR_INVALIDPARAMS);
    }

    /*
     * Check the requested size.
     * If it's larger than allowed, error.
     *
     * The HEL always has the correct maximum value.
     */
    if (this->d3dHELDevDesc.dwMaxBufferSize) {
        /* We have a size for maximum */
        if (debDesc.dwBufferSize > this->d3dHELDevDesc.dwMaxBufferSize) {
            DPF(0,"(ERROR) Direct3DDevice::CreateExecuteBuffer: requested size is too large. %d > %d",
                debDesc.dwBufferSize, this->d3dHELDevDesc.dwMaxBufferSize);
            return (DDERR_INVALIDPARAMS);
        }
    }

    lpBuffer = static_cast<LPDIRECT3DEXECUTEBUFFERI>(new DIRECT3DEXECUTEBUFFERI());
    if (!lpBuffer) {
        D3D_ERR("Out of memory allocating execute-buffer");
        return (DDERR_OUTOFMEMORY);
    }


    /*
     * Allocated memory for the buffer
     */
    {
        LPDIRECTDRAWSURFACE dummy;
        if ((ret = D3DHAL_AllocateBuffer(this, &lpBuffer->hBuf, 
                                         &debDesc,
                                         &dummy)) != DD_OK)
        {
            D3D_ERR("Out of memory allocating internal buffer description");
            delete lpBuffer;
            return ret;
        }
    }

    /*
     * Put this device in the list of those owned by the
     * Direct3DDevice object
     */
    ret = hookBufferToDevice(this, lpBuffer);
    if (ret != D3D_OK) {
        D3D_ERR("Failed to associate buffer with device");
        delete lpBuffer;
        return (ret);
    }

    *lplpBuffer = static_cast<LPDIRECT3DEXECUTEBUFFER>(lpBuffer);

    return (D3D_OK);
}

DIRECT3DEXECUTEBUFFERI::DIRECT3DEXECUTEBUFFERI()
{
    /*
     * setup the object
     */
    pid = 0;
    memset(&debDesc,0,sizeof(D3DEXECUTEBUFFERDESC));
    memset(&exData, 0, sizeof(D3DEXECUTEDATA));
    locked = false; 
    memset(&hBuf, 0, sizeof(D3DI_BUFFERHANDLE));
    refCnt = 1;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::Lock"

HRESULT D3DAPI DIRECT3DEXECUTEBUFFERI::Lock(LPD3DEXECUTEBUFFERDESC lpDesc)
{
    D3DEXECUTEBUFFERDESC    debDesc;
    HRESULT         ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DEXECUTEBUFFERDESC_PTR(lpDesc)) {
            D3D_ERR( "Invalid D3DEXECUTEBUFFERDESC pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    ret = D3D_OK;

    if (this->locked) {
        D3D_ERR("buffer already locked");
        return (D3DERR_EXECUTE_LOCKED);
    }

    debDesc = *lpDesc;
    this->locked = 1;
    this->pid = GetCurrentProcessId();

    {
        LPDIRECTDRAWSURFACE dummy;
        if ((ret = D3DHAL_LockBuffer(this->lpDevI, this->hBuf, &debDesc, &dummy)) != DD_OK)
        {
            D3D_ERR("Failed to lock buffer");
            this->locked = 0;
            return ret;
        }
    }

    *lpDesc = debDesc;

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::Unlock"

HRESULT D3DAPI DIRECT3DEXECUTEBUFFERI::Unlock()
{
    DWORD       pid;
    HRESULT     ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    ret = D3D_OK;

    if (!this->locked) 
    {
        D3D_ERR("buffer not locked");
        return (D3DERR_EXECUTE_NOT_LOCKED);
    }

#ifdef XWIN_SUPPORT
    pid = getpid();
#else
    pid = GetCurrentProcessId();
#endif
    if (pid != this->pid) 
    {
        /* Unlocking process didn't lock it */
        D3D_ERR("Unlocking process didn't lock it");
        return (DDERR_INVALIDPARAMS);
    }

    if ((ret = D3DHAL_UnlockBuffer(this->lpDevI, this->hBuf)) != DD_OK)
    {
        D3D_ERR("Failed to unlock buffer");
        this->locked = 0;
        return ret;
    }

    this->locked = 0;

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::SetExecuteData"

HRESULT D3DAPI DIRECT3DEXECUTEBUFFERI::SetExecuteData(LPD3DEXECUTEDATA lpData)
{
    HRESULT     ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DEXECUTEDATA_PTR(lpData)) {
            D3D_ERR( "Invalid D3DEXECUTEDATA pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    ret = D3D_OK;

    this->exData = *lpData;

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::GetExecuteData"

HRESULT D3DAPI DIRECT3DEXECUTEBUFFERI::GetExecuteData(LPD3DEXECUTEDATA lpData)
{
    HRESULT     ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!lpData) {
            D3D_ERR( "Null D3DExecuteData pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    ret = D3D_OK;

    *lpData = this->exData;

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::Validate"

HRESULT D3DAPI DIRECT3DEXECUTEBUFFERI::Validate(LPDWORD lpdwOffset,
                                                LPD3DVALIDATECALLBACK lpFunc,
                                                LPVOID lpUserArg,
                                                DWORD dwFlags)
{

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DWORD_PTR(lpdwOffset)) {
            D3D_ERR( "Invalid offset pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    return (DDERR_UNSUPPORTED);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::Optimize"

HRESULT D3DAPI DIRECT3DEXECUTEBUFFERI::Optimize(DWORD dwFlags)
{

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (dwFlags) {
        D3D_ERR( "Flags are non-zero" );
        return DDERR_INVALIDPARAMS;
    }

    return (DDERR_UNSUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\d3ddev.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3ddev.cpp
 *  Content:    Direct3D device implementation
 *@@BEGIN_MSINTERNAL
 *
 *  $Id: device.c,v 1.26 1995/12/04 11:29:47 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *   11/11/95   stevela Light code changed.
 *   23/11/95   colinmc Modifications to support aggregatable interfaces
 *   07/12/95   stevela Merged Colin's changes.
 *   10/12/95   stevela Removed AGGREGATE_D3D.
 *   18/12/95   stevela Added GetMatrix, GetState.
 *   15/07/96   andyhird Initialise Render state on devices
 *   13/08/96   andyhird Check surface and device are compatible
 *   18/08/96   colinmc Fixed z-buffer leak
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Create an api for the Direct3DDevice object
 */
extern "C" {
#define this _this
#include "ddrawpr.h"
#undef this
}
#include "commdrv.hpp"
#include "drawprim.hpp"

//#ifdef DEBUG_PIPELINE
#include "testprov.h"
//#endif //DEBUG_PIPELINE

// Remove DDraw's type unsafe definition and replace with our C++ friendly def
#ifdef VALIDEX_CODE_PTR
#undef VALIDEX_CODE_PTR
#endif
#define VALIDEX_CODE_PTR( ptr ) \
(!IsBadCodePtr( (FARPROC) ptr ) )

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice"

extern BOOL isMMXprocessor(void);
extern HRESULT GenGetPickRecords(LPDIRECT3DDEVICEI, D3DI_PICKDATA *);
extern BOOL IsValidD3DDeviceGuid(REFCLSID riid);

BOOL D3DI_isHALValid(LPD3DHAL_CALLBACKS halTable)
{
    if(halTable==NULL) {
        D3D_WARN(0, "HAL callbacks is NULL. HAL will not be enumerated.");
        return FALSE;
    }

    if (halTable->dwSize != D3DHAL_SIZE_V1) {
        D3D_WARN(0, "HAL callbacks invalid - size = %d, wanted %d. HAL will not be enumerated.",
            halTable->dwSize, D3DHAL_SIZE_V1);
        return FALSE;
    }
    if (halTable->dwReserved  ||
        halTable->dwReserved0 ||
        halTable->dwReserved1 ||
        halTable->dwReserved2 ||
        halTable->dwReserved3 ||
        halTable->dwReserved4 ||
        halTable->dwReserved5 ||
        halTable->dwReserved6 ||
        halTable->dwReserved7 ||
        halTable->dwReserved8 ||
        halTable->dwReserved9 ||
        halTable->lpReserved10 ||
        halTable->lpReserved11 ||
        halTable->lpReserved12 ||
        halTable->lpReserved13 ||
        halTable->lpReserved14 ||
        halTable->lpReserved15 ||
        halTable->lpReserved16 ||
        halTable->lpReserved17 ||
        halTable->lpReserved18 ||
        halTable->lpReserved19 ||
        halTable->lpReserved20 ||
        halTable->lpReserved21) {
        D3D_WARN(0, "HAL callbacks invalid - has non-zero reserved fields, HAL will not be enumerated.");
        return FALSE;
    }

    return TRUE;
}

HRESULT DIRECT3DDEVICEI::stateInitialize(BOOL bZEnable)
{
    D3DDEVICEDESC hwDesc, helDesc;
    D3DLINEPATTERN defLPat;
    HRESULT ret;
    float tmpval;
    BOOL ckeyenable = FALSE;

    /* Get the device caps for MONOENABLE */
    memset(&hwDesc, 0, sizeof(D3DDEVICEDESC));
    hwDesc.dwSize = sizeof(D3DDEVICEDESC);
    memset(&helDesc, 0, sizeof(D3DDEVICEDESC));
    helDesc.dwSize = sizeof(D3DDEVICEDESC);

    ret = GetCapsI(&hwDesc, &helDesc);
    if (FAILED(ret)) {
        D3D_ERR("stateInitialise: GetCaps failed");
        return(ret);
    }

    /* If we run on (HAL OR RefRast) AND this is a DX3 app
       then we need to initialize colorkey to TRUE so that the old HW driver (except s3 virge) behavior
       is exhibited. */
    if ( (this->dwVersion < 2) &&
         ( (IS_HW_DEVICE(this)) || (IsEqualIID(this->guid, IID_IDirect3DRefDevice)) ) )
    {
        ckeyenable = TRUE;
    }

    // Obviate SetRenderState filtering 'redundant' render state settings
    // since this is the init step.
    memset( this->rstates, 0xff, sizeof(DWORD)*D3DHAL_MAX_RSTATES );
    this->rstates[D3DRENDERSTATE_PLANEMASK] = 0;
    this->rstates[D3DRENDERSTATE_STENCILMASK] = 0;
    this->rstates[D3DRENDERSTATE_STENCILWRITEMASK] = 0;
    this->rstates[D3DRENDERSTATE_PLANEMASK] = 0;

    SetRenderState( D3DRENDERSTATE_TEXTUREHANDLE, (DWORD)NULL);
    SetRenderState( D3DRENDERSTATE_ANTIALIAS, FALSE);
    SetRenderState( D3DRENDERSTATE_TEXTUREADDRESS, D3DTADDRESS_WRAP);
    if (this->dwVersion <= 2)
    {
        SetRenderState( D3DRENDERSTATE_TEXTUREPERSPECTIVE, FALSE);
        SetRenderState( D3DRENDERSTATE_SPECULARENABLE, TRUE);
    }
    else
    {
        // perspective enabled by default for Device3 and later
        SetRenderState( D3DRENDERSTATE_TEXTUREPERSPECTIVE, TRUE);
        // specular disabled by default for Device3 and later
        SetRenderState( D3DRENDERSTATE_SPECULARENABLE, FALSE);
    }
    SetRenderState( D3DRENDERSTATE_WRAPU, FALSE);
    SetRenderState( D3DRENDERSTATE_WRAPV, FALSE);
    SetRenderState( D3DRENDERSTATE_ZENABLE, bZEnable);
    SetRenderState( D3DRENDERSTATE_FILLMODE, D3DFILL_SOLID);
    SetRenderState( D3DRENDERSTATE_SHADEMODE, D3DSHADE_GOURAUD);

    defLPat.wRepeatFactor = 0;
    defLPat.wLinePattern = 0;

    SetRenderState( D3DRENDERSTATE_LINEPATTERN, *((LPDWORD)&defLPat)); /* 10 */
    /*
      ((LPD3DSTATE)lpPointer)->drstRenderStateType =
      (D3DRENDERSTATETYPE)D3DRENDERSTATE_LINEPATTERN;
      memcpy(&(((LPD3DSTATE)lpPointer)->dwArg[0]), &defLPat, sizeof(DWORD));
      lpPointer = (void *)(((LPD3DSTATE)lpPointer) + 1);*/

    SetRenderState( D3DRENDERSTATE_ROP2, R2_COPYPEN);
    SetRenderState( D3DRENDERSTATE_PLANEMASK, (DWORD)~0);
    SetRenderState( D3DRENDERSTATE_ZWRITEENABLE, TRUE);
    SetRenderState( D3DRENDERSTATE_ALPHATESTENABLE, FALSE);
    SetRenderState( D3DRENDERSTATE_LASTPIXEL, TRUE);
    SetRenderState( D3DRENDERSTATE_SRCBLEND, D3DBLEND_ONE);
    SetRenderState( D3DRENDERSTATE_DESTBLEND, D3DBLEND_ZERO);
    SetRenderState( D3DRENDERSTATE_CULLMODE, D3DCULL_CCW); /* 21 */
    SetRenderState( D3DRENDERSTATE_ZFUNC, D3DCMP_LESSEQUAL);
    SetRenderState( D3DRENDERSTATE_ALPHAREF, 0);
    SetRenderState( D3DRENDERSTATE_ALPHAFUNC, D3DCMP_ALWAYS);
    SetRenderState( D3DRENDERSTATE_DITHERENABLE, FALSE);
    SetRenderState( D3DRENDERSTATE_BLENDENABLE, FALSE);
    SetRenderState( D3DRENDERSTATE_FOGENABLE, FALSE);
    SetRenderState( D3DRENDERSTATE_ZVISIBLE, FALSE);
    SetRenderState( D3DRENDERSTATE_SUBPIXEL, FALSE); /* 30 */
    SetRenderState( D3DRENDERSTATE_SUBPIXELX, FALSE);
    SetRenderState( D3DRENDERSTATE_STIPPLEDALPHA, FALSE);
    SetRenderState( D3DRENDERSTATE_FOGCOLOR, 0);
    SetRenderState( D3DRENDERSTATE_FOGTABLEMODE, D3DFOG_NONE);

    /* Initialise these - although they may not need doing */
    tmpval = 0.0f;
    SetRenderState( D3DRENDERSTATE_FOGTABLESTART, *((DWORD *)&tmpval));
    tmpval = 1.0f;
    SetRenderState( D3DRENDERSTATE_FOGTABLEEND, *((DWORD *)&tmpval));
    tmpval = 1.0f;
    SetRenderState( D3DRENDERSTATE_FOGTABLEDENSITY, *((DWORD *)&tmpval));
    SetRenderState( D3DRENDERSTATE_STIPPLEENABLE, FALSE);
    SetRenderState( D3DRENDERSTATE_EDGEANTIALIAS, FALSE);
    SetRenderState( D3DRENDERSTATE_COLORKEYENABLE, ckeyenable);
    SetRenderState( D3DRENDERSTATE_ALPHABLENDENABLE, FALSE);
    SetRenderState( D3DRENDERSTATE_BORDERCOLOR, 0);
    SetRenderState( D3DRENDERSTATE_TEXTUREADDRESSU, D3DTADDRESS_WRAP);
    SetRenderState( D3DRENDERSTATE_TEXTUREADDRESSV, D3DTADDRESS_WRAP);
    SetRenderState( D3DRENDERSTATE_MIPMAPLODBIAS, 0);
    SetRenderState( D3DRENDERSTATE_ZBIAS, 0);
    SetRenderState( D3DRENDERSTATE_RANGEFOGENABLE, FALSE);
    SetRenderState( D3DRENDERSTATE_ANISOTROPY, 1);

    /* Again - all these probably don't need doing */
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN00, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN01, 0); /* 40 */
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN02, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN03, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN04, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN05, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN06, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN07, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN08, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN09, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN10, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN11, 0); /* 50 */
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN12, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN13, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN14, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN15, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN16, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN17, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN18, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN19, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN20, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN21, 0); /* 60 */
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN22, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN23, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN24, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN25, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN26, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN27, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN28, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN29, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN30, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN31, 0); /* 70 */

     // init stencil states to something reasonable
     // stencil enable is OFF by default since stenciling rasterizers will be
     // faster with it disabled, even if stencil states are benign
    SetRenderState( D3DRENDERSTATE_STENCILENABLE,   FALSE);
    SetRenderState( D3DRENDERSTATE_STENCILFAIL,     D3DSTENCILOP_KEEP);
    SetRenderState( D3DRENDERSTATE_STENCILZFAIL,    D3DSTENCILOP_KEEP);
    SetRenderState( D3DRENDERSTATE_STENCILPASS,     D3DSTENCILOP_KEEP);
    SetRenderState( D3DRENDERSTATE_STENCILFUNC,     D3DCMP_ALWAYS);
    SetRenderState( D3DRENDERSTATE_STENCILREF,      0);
    SetRenderState( D3DRENDERSTATE_STENCILMASK,     0xFFFFFFFF);
    SetRenderState( D3DRENDERSTATE_STENCILWRITEMASK,0xFFFFFFFF);

    // don't forget about texturefactor (like we did in DX6.0...)
    SetRenderState( D3DRENDERSTATE_TEXTUREFACTOR,   0xFFFFFFFF);

    /* Check to see if the driver can do RGB - if not set MONOENABLE to
       true otherwise false (ie. RGB) by default */
    if (hwDesc.dwFlags & D3DDD_COLORMODEL) {
        if ((hwDesc.dcmColorModel & D3DCOLOR_RGB)) {
            D3D_INFO(3, "hw and RGB. MONOENABLE = FALSE");
            SetRenderState( D3DRENDERSTATE_MONOENABLE, FALSE);
        } else {
            D3D_INFO(3, "hw and !RGB. MONOENABLE = TRUE");
            SetRenderState( D3DRENDERSTATE_MONOENABLE, TRUE);
        }
    } else if (helDesc.dwFlags & D3DDD_COLORMODEL) {
        if ((helDesc.dcmColorModel & D3DCOLOR_RGB)) {
            D3D_INFO(3, "hel and RGB. MONOENABLE = FALSE");
            SetRenderState( D3DRENDERSTATE_MONOENABLE, FALSE);
        } else {
            D3D_INFO(3, "hel and !RGB. MONOENABLE = TRUE");
            SetRenderState( D3DRENDERSTATE_MONOENABLE, TRUE);
        }
    } else {
        /* Hmm, something bad has happened if we get here! */
        D3D_ERR("stateInitialise: neither hw or hel caps set");
        return(DDERR_GENERIC);
    }

    for (unsigned i = 0; i < 8; i++)
    {
        SetRenderState( (D3DRENDERSTATETYPE)
                        (D3DRENDERSTATE_WRAPBIAS + i), FALSE );
    }
    for (i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        lpD3DMappedTexI[i] = NULL;
        lpD3DMappedBlock[i] = NULL;
    }
    SetLightState( D3DLIGHTSTATE_COLORVERTEX, TRUE);

    // Obviate SetTextureStageState/Settexture filtering 'redundant' render state
    // settings since this is the init step.
    memset( this->tsstates, 0xff, sizeof(DWORD)*D3DHAL_TSS_MAXSTAGES*D3DHAL_TSS_STATESPERSTAGE );
    for (i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        SetTexture(i, NULL);
        if(i == 0)
            SetTextureStageState(i, D3DTSS_COLOROP, D3DTOP_MODULATE);
        else
            SetTextureStageState(i, D3DTSS_COLOROP, D3DTOP_DISABLE);
        SetTextureStageState(i, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        SetTextureStageState(i, D3DTSS_COLORARG2, D3DTA_CURRENT);
        if(i == 0)
            SetTextureStageState(i, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
        else
            SetTextureStageState(i, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
        SetTextureStageState(i, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        SetTextureStageState(i, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT00, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT01, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT10, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT11, 0);
        SetTextureStageState(i, D3DTSS_TEXCOORDINDEX, 0);
        SetTextureStageState(i, D3DTSS_ADDRESS, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_BORDERCOLOR, 0x00000000);
        SetTextureStageState(i, D3DTSS_MAGFILTER, D3DTFG_POINT);
        SetTextureStageState(i, D3DTSS_MINFILTER, D3DTFN_POINT);
        SetTextureStageState(i, D3DTSS_MIPFILTER, D3DTFP_NONE);
        SetTextureStageState(i, D3DTSS_MIPMAPLODBIAS, 0);
        SetTextureStageState(i, D3DTSS_MAXMIPLEVEL, 0);
        SetTextureStageState(i, D3DTSS_MAXANISOTROPY, 1);
        SetTextureStageState(i, D3DTSS_BUMPENVLSCALE, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVLOFFSET, 0);
    }

    // need to set legacy blend and filtering states after per-stage initialization
    //  to properly set defaults in device
    SetRenderState( D3DRENDERSTATE_TEXTUREMAG, D3DFILTER_NEAREST);
    SetRenderState( D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_NEAREST);
    SetRenderState( D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_MODULATE);

    // Reset request bit as legacy renderstates have been already initialized
    // and no mapping is needed
    this->dwFEFlags &= ~D3DFE_MAP_TSS_TO_RS;

    return(D3D_OK);
}

DWORD BitDepthToDDBD(int bpp)
{
    switch(bpp)
    {
    case 1:
        return DDBD_1;
    case 2:
        return DDBD_2;
    case 4:
        return DDBD_4;
    case 8:
        return DDBD_8;
    case 16:
        return DDBD_16;
    case 24:
        return DDBD_24;
    case 32:
        return DDBD_32;
    default:
        D3D_ERR("Invalid bit depth");
        return 0;
    }
}

HRESULT DIRECT3DDEVICEI::checkDeviceSurface(LPDIRECTDRAWSURFACE lpDDS, LPDIRECTDRAWSURFACE lpZbuffer, LPGUID pGuid)
{
    D3DDEVICEDESC hwDesc, helDesc;
    DDPIXELFORMAT surfPF;
    DDSCAPS surfCaps;
    HRESULT ret;
    DWORD bpp;

    /* Get caps bits - check whether device and surface are:
       - video/system memory and depth compatible */

    if (FAILED(ret = lpDDS->GetCaps(&surfCaps))) {
        D3D_ERR("Failed to get render-target surface caps");
        return(ret);
    }

    memset(&surfPF, 0, sizeof(DDPIXELFORMAT));
    surfPF.dwSize = sizeof(DDPIXELFORMAT);

    if (FAILED(ret = lpDDS->GetPixelFormat(&surfPF))) {
        D3D_ERR("Failed to get render-target surface pixel format");
        return(ret);
    }

    memset(&hwDesc, 0, sizeof(D3DDEVICEDESC));
    hwDesc.dwSize = sizeof(D3DDEVICEDESC);
    memset(&helDesc, 0, sizeof(D3DDEVICEDESC));
    helDesc.dwSize = sizeof(D3DDEVICEDESC);

    // ATTENTION - Why doesn't this just look at the DEVICEI fields?
    ret = GetCapsI(&hwDesc, &helDesc);
    if (FAILED(ret)) {
        D3D_ERR("GetCaps failed");
        return(ret);
    }

    if (hwDesc.dwFlags) {
        /* I'm taking this as evidence that its running on hardware - therefore
           the surface should be in video memory */
        D3D_INFO(3, "Hardware device being used");

        if (!(surfCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
            D3D_ERR("Render-target surface not in video memory for hw device");
            return(D3DERR_SURFACENOTINVIDMEM);
        }
    }

    /* A surface can only have one bit depth - whereas a device can support
       multiple bit depths */
    if (surfPF.dwFlags & DDPF_RGB) {
        D3D_INFO(3, "Render-target surface is RGB");

        bpp = BitDepthToDDBD(surfPF.dwRGBBitCount);
        if (!bpp) {
            D3D_ERR("Bogus render-target surface pixel depth");
            return(DDERR_INVALIDPIXELFORMAT);
       }

       if((surfPF.dwRGBBitCount<16) && (IsEqualIID(*pGuid, IID_IDirect3DRefDevice) || IsEqualIID(*pGuid, IID_IDirect3DNullDevice))) {
           // this is actually subsumed by the following test, but whatever
            D3D_ERR("Reference rasterizer and null device dont support render targets with bitdepth < 16");
            return(DDERR_INVALIDPIXELFORMAT);
       }

        if (!(bpp & helDesc.dwDeviceRenderBitDepth) &&
            !(bpp & hwDesc.dwDeviceRenderBitDepth)) {
            D3D_ERR("Render-target surface bitdepth is not supported by HEL or HW for this device");
            return(DDERR_INVALIDPIXELFORMAT);
        }
    }

    if(lpZbuffer==NULL)
      return D3D_OK;

    memset(&surfPF, 0, sizeof(DDPIXELFORMAT));
    surfPF.dwSize = sizeof(DDPIXELFORMAT);

    if (FAILED(ret = lpZbuffer->GetPixelFormat(&surfPF))) {
        D3D_ERR("Failed to get zbuffer pixel format");
        return(ret);
    }

    if (FAILED(ret = lpZbuffer->GetCaps(&surfCaps))) {
        D3D_ERR("Failed to get Zbuffer caps");
        return(ret);
    }

    if (hwDesc.dwFlags) {
        if (!(surfCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
            D3D_ERR("Zbuffer not in video memory for hw device");
            return(D3DERR_ZBUFF_NEEDS_VIDEOMEMORY);
        }
        D3D_INFO(3, "Hw device, zbuffer in video memory");
    } else if (helDesc.dwFlags) {
        if (!(surfCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)) {
            D3D_ERR("Zbuffer not in system memory for HEL device");
            return(D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY);
        }
        D3D_INFO(3, "Hel device, zbuffer in system memory");

         // have to hack in a check to make sure ramp isn't used with stencil zbuffer
         // cant do this validation until device creation time (instead of at zbuffer creation in
         // ddhel.c) because rgb vs. ramp isn't known until now
         if(IsEqualIID(*pGuid, IID_IDirect3DRampDevice)) {
            if(surfPF.dwFlags & DDPF_STENCILBUFFER) {
                D3D_ERR("Z-Buffer with stencil is invalid with RAMP software rasterizer");
                return DDERR_INVALIDPARAMS;
            }
         }
    }

    if (surfPF.dwFlags & DDPF_ZBUFFER) {
        bpp = BitDepthToDDBD(surfPF.dwZBufferBitDepth);
        if (!bpp) {
            D3D_ERR("Bogus Zbuffer surface pixel depth");
            return(DDERR_INVALIDPIXELFORMAT);
        }
    }

    return(D3D_OK);
}


/*
 * Initialisation - class part and device part
 */

/*
 * Generic class part initialisation
 */
HRESULT InitDeviceI(LPDIRECT3DDEVICEI lpDevI, LPDIRECT3DI lpD3DI)
{
    LPDDRAWI_DIRECTDRAW_GBL lpDDI;
    HRESULT error;

    lpDDI = ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl;

    //
    // Retrieve HAL information from provider.
    //

    error = lpDevI->pHalProv->GetCaps(lpDDI,
                                      &lpDevI->d3dHWDevDesc,
                                      &lpDevI->d3dHELDevDesc,
                                      lpDevI->dwVersion);
    if (error != S_OK)
    {
        return (error);
    }
    D3DHALPROVIDER_INTERFACEDATA HalProviderIData;
    memset(&HalProviderIData,0,sizeof(HalProviderIData));
    HalProviderIData.dwSize = sizeof(HalProviderIData);
    if ((error = lpDevI->pHalProv->GetInterface(lpDDI,
                                                &HalProviderIData,
                                                lpDevI->dwVersion)) != S_OK)
    {
        return error;
    }
    //  interface data for <=DX5 HAL
    lpDevI->lpD3DHALGlobalDriverData = HalProviderIData.pGlobalData;
    lpDevI->lpD3DExtendedCaps        = HalProviderIData.pExtCaps;
    lpDevI->lpD3DHALCallbacks        = HalProviderIData.pCallbacks;
    lpDevI->lpD3DHALCallbacks2       = HalProviderIData.pCallbacks2;
    //  interface data for DX6 HAL
    lpDevI->lpD3DHALCallbacks3       = HalProviderIData.pCallbacks3;

    lpDevI->pfnRampService = HalProviderIData.pfnRampService;
    lpDevI->pfnRastService = HalProviderIData.pfnRastService;
    lpDevI->dwHintFlags = 0;

    // Zero out 8 bpp render target caps for real hardware.
    if (lpDevI->d3dHWDevDesc.dwFlags != 0)
    {
        lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwDeviceRenderBitDepth &=
            (~DDBD_8);
    }

    if (!D3DI_isHALValid(lpDevI->lpD3DHALCallbacks))
    {
        return D3DERR_INITFAILED;
    }

    if (lpDevI->lpD3DExtendedCaps && lpDevI->lpD3DExtendedCaps->dwFVFCaps)
    {
        lpDevI->dwMaxTextureIndices =
            lpDevI->lpD3DExtendedCaps->dwFVFCaps & D3DFVFCAPS_TEXCOORDCOUNTMASK;
        lpDevI->dwMaxTextureBlendStages =
            lpDevI->lpD3DExtendedCaps->wMaxTextureBlendStages;
        lpDevI->dwDeviceFlags |= D3DDEV_FVF;
        if (lpDevI->lpD3DExtendedCaps->dwFVFCaps & D3DFVFCAPS_DONOTSTRIPELEMENTS)
            lpDevI->dwDeviceFlags |= D3DDEV_DONOTSTRIPELEMENTS;

        DWORD value;
        if ((lpDevI->dwDebugFlags & D3DDEBUG_DISABLEDP ||
            lpDevI->dwDebugFlags & D3DDEBUG_DISABLEDP2 ||
            (GetD3DRegValue(REG_DWORD, "DisableFVF", &value, 4) &&
            value != 0)) &&
            FVF_DRIVERSUPPORTED(lpDevI))
        {
            lpDevI->dwMaxTextureIndices = 1;
            lpDevI->dwMaxTextureBlendStages = 1;
            lpDevI->dwDeviceFlags &= ~D3DDEV_FVF;
            lpDevI->dwDebugFlags |= D3DDEBUG_DISABLEFVF;
        }
        if ((GetD3DRegValue(REG_DWORD, "DisableStripFVF", &value, 4) &&
            value != 0))
        {
            lpDevI->dwDeviceFlags |= D3DDEV_DONOTSTRIPELEMENTS;
        }
    }
    else
    {
        lpDevI->dwMaxTextureIndices = 1;
        lpDevI->dwMaxTextureBlendStages = 1;
    }

    lpDevI->pfnDrawPrim = &DIRECT3DDEVICEI::DrawPrim;
    lpDevI->pfnDrawIndexedPrim = &DIRECT3DDEVICEI::DrawIndexPrim;
#if DBG
    lpDevI->dwCaller=0;
    memset(lpDevI->dwPrimitiveType,0,sizeof(lpDevI->dwPrimitiveType));
    memset(lpDevI->dwVertexType1,0,sizeof(lpDevI->dwVertexType1));
    memset(lpDevI->dwVertexType2,0,sizeof(lpDevI->dwVertexType2));
#endif
    return D3D_OK;
}

HRESULT D3DMallocBucket(LPDIRECT3DI lpD3DI, LPD3DBUCKET *lplpBucket)
{
    if (lpD3DI->lpFreeList == NULL ){
      lpD3DI->lpTextureManager->cleanup();  //free unused nodes it may have
      if (lpD3DI->lpFreeList == NULL )
      {
        LPD3DBUCKET   lpBufferList;
        LPVOID  lpBuffer;
        int i;
        *lplpBucket=NULL;
        if (D3DMalloc(&lpBuffer, D3DBUCKETBUFFERSIZE*sizeof(D3DBUCKET)) != D3D_OK)
            return  DDERR_OUTOFMEMORY;
        D3D_INFO(9, "D3DMallocBucket %d Bytes allocated for %d free Buckets",
            D3DBUCKETBUFFERSIZE*sizeof(D3DBUCKET),D3DBUCKETBUFFERSIZE-1);
        lpBufferList=(LPD3DBUCKET)lpBuffer;
        for (i=0;i<D3DBUCKETBUFFERSIZE-2;i++)
            lpBufferList[i].next=&lpBufferList[i+1];
        lpBufferList[D3DBUCKETBUFFERSIZE-2].next=NULL;
        lpD3DI->lpFreeList=(LPD3DBUCKET)lpBuffer; //new free list
        lpBufferList[D3DBUCKETBUFFERSIZE-1].next=lpD3DI->lpBufferList;//add to lpBufferList
        lpBufferList[D3DBUCKETBUFFERSIZE-1].lpBuffer=lpBuffer;
        lpD3DI->lpBufferList=&lpBufferList[D3DBUCKETBUFFERSIZE-1];
      }
    }
    *lplpBucket=lpD3DI->lpFreeList;
    lpD3DI->lpFreeList=lpD3DI->lpFreeList->next;
    return  D3D_OK;
}

void    D3DFreeBucket(LPDIRECT3DI lpD3DI, LPD3DBUCKET lpBucket)
{
    lpBucket->next=lpD3DI->lpFreeList;
    lpD3DI->lpFreeList=lpBucket;
}

/*
 * Generic device part destroy
 */
void DIRECT3DDEVICEI::DestroyDevice()
{
    LPDIRECT3DVIEWPORTI lpViewI;
    LPDIRECTDRAWSURFACE lpDDS=NULL, lpDDSZ=NULL;
    LPDIRECTDRAWSURFACE4 lpDDS_DDS4=NULL;
    LPDIRECTDRAWPALETTE lpDDPal=NULL;
    BOOL bIsDX3Device;

    /* Clear flags that could prohibit cleanup */
    this->dwHintFlags &=  ~(D3DDEVBOOL_HINTFLAGS_INBEGIN_ALL | D3DDEVBOOL_HINTFLAGS_INSCENE);

    /*
     * Remove all viewports attached to this device.
     */
    while ((lpViewI = CIRCLE_QUEUE_FIRST(&this->viewports)) &&
           (lpViewI != (LPDIRECT3DVIEWPORTI)&this->viewports)) {
        DeleteViewport((LPDIRECT3DVIEWPORT3)lpViewI);
    }

    /*
     * free up all textures created by this object - this also frees up Textures
     * We need to do this backwards because we cannot have a texture bound to
     * stage i + 1 when there is a texture bound to stage i.
     */
    for (int i = D3DHAL_TSS_MAXSTAGES - 1; i >= 0; --i)
    {
        if (lpD3DMappedTexI[i])
        {
            lpD3DMappedTexI[i]->Release();
            lpD3DMappedTexI[i] = NULL;
            lpD3DMappedBlock[i] = NULL;
        }
    }
    // The following code can result in D3DHAL_TextureDestroy() being called.
    // This BATCHES NEW INSTRUCTIONS in the instruction stream. So we must
    // make sure that at this point, the device is still able to accept
    // instructions.
    while (LIST_FIRST(&this->texBlocks)) {
        LPD3DI_TEXTUREBLOCK tBlock = LIST_FIRST(&this->texBlocks);
        D3DI_RemoveTextureHandle(tBlock);
        // Remove from device
        LIST_DELETE(tBlock, devList);
        // Remove from texture
        LIST_DELETE(tBlock, list);
        D3DFree(tBlock);
    }

    /*
     * free up all execute buffers created by this object
     */
    while (LIST_FIRST(&this->buffers)) {
        LPDIRECT3DEXECUTEBUFFERI lpBufI =
            LIST_FIRST(&this->buffers);
        lpBufI->Release();
    }

    /*
     * All materials associated with this device must be disassocited
     */
    while (LIST_FIRST(&this->matBlocks)) {
        LPD3DI_MATERIALBLOCK mBlock =
            LIST_FIRST(&this->matBlocks);
        D3DI_RemoveMaterialBlock(mBlock);
    }

    // In DX3, d3d device is aggregated and doesnt keep references to
    // rendertarget surfaces, so they shouldnt be "released"

    bIsDX3Device=(this->lpDDSTarget == (LPDIRECTDRAWSURFACE)(this->lpOwningIUnknown));

    if(!bIsDX3Device)
    {
        // Hold pointers into ddraw object for release after driver is destroyed
        lpDDSZ = this->lpDDSZBuffer;
        lpDDPal = this->lpDDPalTarget;
        if (this->dwVersion == 2)
            lpDDS = this->lpDDSTarget;
        else
            lpDDS_DDS4 = this->lpDDSTarget_DDS4;
    }

    //Unhook so that DDRAW surfaces won't try to flush the dead device
    if (this->lpDDSTarget)
        UnHookD3DDeviceFromSurface(this,((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl);
    if (this->lpDDSZBuffer)
        UnHookD3DDeviceFromSurface(this,((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl);

    if (pGeometryFuncs != &GeometryFuncsGuaranteed)
        delete pGeometryFuncs;

    D3DFE_Destroy(this);

    if (this->lpDirect3DI)
        unhookDeviceFromD3D();

    if (this->wTriIndex)
        D3DFree(this->wTriIndex);

    // Free the rstates that was allocated
    if(!(IS_HW_DEVICE(this) && IS_DP2HAL_DEVICE(this)))
    {
        delete rstates;
    }

    if (this->lpwDPBufferAlloced)
        D3DFree(this->lpwDPBufferAlloced);
    if (this->lpvVertexBatch)
        D3DFree(this->lpvVertexBatch);
    if (this->lpIndexBatch)
        D3DFree(this->lpIndexBatch);
    if (this->lpHWCounts)
        D3DFree(this->lpHWCounts);
    if (this->lpHWTris)
        D3DFree(this->lpHWTris);
    DeleteCriticalSection(&this->BeginEndCSect);

    if (this->pHalProv != NULL)
    {
        this->pHalProv->Release();
    }
    if (this->hDllProv != NULL)
    {
        FreeLibrary(this->hDllProv);
    }

    /* Now that the class has been destroyed, we should be able to release
       any DDraw object that might need to be released */

    if(!bIsDX3Device) {
        if (lpDDS)
            lpDDS->Release();
        if (lpDDSZ)
            lpDDSZ->Release();
        if (lpDDPal)
            lpDDPal->Release();
        if (lpDDS_DDS4)
            lpDDS_DDS4->Release();
    }
}

HRESULT DIRECT3DDEVICEI::hookDeviceToD3D(LPDIRECT3DI lpD3DI)
{

    LIST_INSERT_ROOT(&lpD3DI->devices, this, list);
    this->lpDirect3DI = lpD3DI;

    lpD3DI->numDevs++;

    return (D3D_OK);
}

HRESULT DIRECT3DDEVICEI::unhookDeviceFromD3D()
{
    LIST_DELETE(this, list);
    this->lpDirect3DI->numDevs--;
    this->lpDirect3DI = NULL;

    return (D3D_OK);
}

HRESULT D3DAPI DIRECT3DDEVICEI::Initialize(LPDIRECT3D lpD3D, LPGUID lpGuid, LPD3DDEVICEDESC lpD3Ddd)
{
    return DDERR_ALREADYINITIALIZED;
}


HRESULT HookD3DDeviceToSurface( LPDIRECT3DDEVICEI pd3ddev,
                                LPDDRAWI_DDRAWSURFACE_LCL lpLcl)
{
    LPD3DBUCKET lpD3DDevIList;
    LPDDRAWI_DDRAWSURFACE_MORE  this_more;
    // we only batch with DRAWPRIMITIVE aware HAL, so don't bother otherwise
    if (!lpLcl)     return  DDERR_ALREADYINITIALIZED;
    this_more = lpLcl->lpSurfMore;
    for(lpD3DDevIList=(LPD3DBUCKET)this_more->lpD3DDevIList;
        lpD3DDevIList;lpD3DDevIList=lpD3DDevIList->next) {
        if ((LPDIRECT3DDEVICEI)lpD3DDevIList->lpD3DDevI==pd3ddev)
            return DDERR_ALREADYINITIALIZED;  // this device is already hooked to the surface
    }
    if (D3DMallocBucket(pd3ddev->lpDirect3DI,&lpD3DDevIList) != D3D_OK) {
        D3D_ERR("HookD3DDeviceToSurface: Out of memory");
        return DDERR_OUTOFMEMORY;
    }
    D3D_INFO(8,"adding lpd3ddev=%08lx to surface %08lx",pd3ddev,lpLcl);
    //Link a node to the DDRAW surface
    lpD3DDevIList->lpD3DDevI=(LPVOID)pd3ddev;
    lpD3DDevIList->next=(LPD3DBUCKET)this_more->lpD3DDevIList;
    this_more->lpD3DDevIList=lpD3DDevIList;
    if (DDSCAPS_ZBUFFER & lpLcl->ddsCaps.dwCaps)
    {
        if (pd3ddev->dwVersion==1)
        {
            lpD3DDevIList->lplpDDSZBuffer=(LPDIRECTDRAWSURFACE*)&pd3ddev->lpDDSZBuffer_DDS4;
        }
        else
        {
            lpD3DDevIList->lplpDDSZBuffer=NULL;
        }
    }
    return D3D_OK;
}

void UnHookD3DDeviceFromSurface( LPDIRECT3DDEVICEI pd3ddev,
                                    LPDDRAWI_DDRAWSURFACE_LCL lpLcl)
{
    LPD3DBUCKET last,current,temp;
    LPDDRAWI_DDRAWSURFACE_MORE  this_more;
    // we only batch with DRAWPRIMITIVE aware HAL, so don't bother otherwise
    if (!lpLcl) return;
    this_more = lpLcl->lpSurfMore;

    last=NULL;
    current=(LPD3DBUCKET)this_more->lpD3DDevIList;
    while(current){
        if ((LPDIRECT3DDEVICEI)current->lpD3DDevI==pd3ddev){
            temp=current;
            current=current->next;
            if (last)
                last->next=current;
            else
                this_more->lpD3DDevIList=current;
            D3DFreeBucket(pd3ddev->lpDirect3DI,temp);
            D3D_INFO(8,"removed lpd3ddev=%08lx from surface %08lx",pd3ddev,lpLcl);
            return; // end of search as this is only one pd3ddev in the list
        }
        else{
            last=current;
            current=current->next;
        }
    }
    return;
}

HRESULT D3DFlushStates(LPDIRECT3DDEVICEI lpDevI)
{
    return lpDevI->FlushStates();
}

/*
 * Create a device.
 *
 * NOTE: Radical modifications to support the aggregatable device
 * interface (so devices can be queried off DirectDraw surfaces):
 *
 * 1) This call is no longer a member of the Direct3D device interface.
 *    It is now an API function exported from the Direct3D DLL. Its
 *    a hidden API function - only DirectDraw will ever invoke it.
 *
 * 2) This call is, in effect, the class factory for Direct3DDevice
 *    objects. This function will be invoked to create the aggregated
 *    device object hanging off the DirectDraw surface.
 *
 * NOTE: So the Direct3DDevice knows which DirectDraw surface is
 * its rendering target this function is passed an interface pointer
 * for that DirectDraw surface. I suspect this blows a nice big
 * hole in the COM model as the DirectDraw surface is also the
 * owning interface of the device and I don't think aggregated
 * objects should know about thier owning interfaces. However, to
 * make this thing work this is what we have to do.
 *
 * EXTRA BIG NOTE: Because of the above don't take a reference to
 * the DirectDraw surface passed in. If you do you will get a circular
 * reference and the bloody thing will never die. When aggregated
 * the device interface's lifetime is entirely defined by the
 * lifetime of its owning interface (the DirectDraw surface) so the
 * DirectDraw surface can never go away before the texture.
 *
 * EXTRA EXTRA BIG NOTE: No device description is passed in any more.
 * The only things that can get passed in are things that DirectDraw
 * knows about (which does not include stuff like dither and color
 * model). Therefore, any input parameters must come in via a
 * different IID for the device. The data returned by the device
 * description must now be retrieved by another call.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DCreateDevice"

HRESULT WINAPI Direct3DCreateDevice(REFCLSID            riid,
                                    LPUNKNOWN           lpDirect3D,
                                    LPDIRECTDRAWSURFACE lpDDSTarget,
                                    LPUNKNOWN*          lplpD3DDevice,
                                    IUnknown*           pUnkOuter,
                                    DWORD               dwVersion)
{
    LPDIRECT3DI       lpD3DI;
    LPDIRECT3DDEVICEI     pd3ddev;
    D3DCOLORMODEL     cm = D3DCOLOR_MONO;
    HRESULT ret = D3D_OK;
    HKEY                  hKey = (HKEY) NULL;
    bool                  bDisableDP = false;
    bool                  bDisableST = false;
    bool                  bDisableDP2 = false;
#if _D3D_FORCEDOUBLE
    bool    bForceDouble = true;
#endif  //_D3D_FORCEDOUBLE
    /* No need to validate params as they are passed to us by DirectDraw */

    /* CreateDevice member of IDirect3D2 will cause this function to be called
     * from within Direct3D. The parameters from the application level must be
     * validated. Need a way to validate the surface pointer from outside DDraw.
     */

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    TRY
    {
        if( ! VALID_PTR_PTR( lplpD3DDevice) )
        {
            D3D_ERR( "Invalid ptr to device pointer in Direct3DCreateDevice" );
            return DDERR_INVALIDPARAMS;
        }

        if(!IsValidD3DDeviceGuid(riid)) {
            D3D_ERR( "Unrecognized Device GUID!");
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in Direct3DCreateDevice" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpD3DDevice = NULL;

    // Might be safer to use dynamic_cast<> if RTTI is enabled
    lpD3DI = reinterpret_cast<CDirect3DUnk*>(lpDirect3D)->pD3DI;

#ifndef _X86_
    if(IsEqualIID(riid, IID_IDirect3DRampDevice)) {
         // quietly fail if trying to create a RampDevice on a non-x86 platform
         return DDERR_INVALIDPARAMS;
    }
#endif

    if((dwVersion>=3) && IsEqualIID(riid, IID_IDirect3DRampDevice)) {
         // Ramp not available in Device3.  No more old-style texture handles.
         D3D_ERR( "RAMP Device is incompatible with IDirect3DDevice3 and so cannot be created from IDirect3D3");
         return DDERR_INVALIDPARAMS;
    }

    if (IsEqualIID(riid, IID_IDirect3DMMXDevice) && !isMMXprocessor()) {
      D3D_ERR("Can't create MMX Device on non-MMX machine");
      return DDERR_INVALIDPARAMS;
    }

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey) )
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = 4;
#ifdef WIN95
        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "DisableDP", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD &&
             dwValue != 0)
        {
            bDisableDP = true;
            bDisableDP2 = true;
        }
#endif //WIN95
        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "DisableST", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD &&
             dwValue != 0)
        {
            bDisableST = true;
        }
#ifdef WIN95
        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "DisableDP2", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD &&
             dwValue != 0)
        {
            bDisableDP2 = true;
        }
#endif //WIN95

        D3D_INFO(2,"EnableDP2: %d",!bDisableDP2);
#if _D3D_FORCEDOUBLE
        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "ForceDouble", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD &&
             dwValue == 0)
        {
            bForceDouble = false;
        }
        D3D_INFO(2,"ForceDouble: %d",bForceDouble);
#endif  //_D3D_FORCEDOUBLE
        RegCloseKey( hKey );
    }
    LPD3DHAL_GLOBALDRIVERDATA lpD3DHALGlobalDriverData=((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl->lpD3DGlobalDriverData;
#ifdef WIN95
    /* Test for presence of CB HAL */
    if (IsEqualIID(riid, IID_IDirect3DHALDevice) )
    {
        /* Test for presence of DP2 DDI */
        if ((lpD3DHALGlobalDriverData)
            && (lpD3DHALGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_DRAWPRIMITIVES2EX)
           )
        {
            pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIDP2());
            if (pd3ddev) pd3ddev->deviceType = D3DDEVTYPE_DX7HAL;
        }
        else if ((!bDisableDP2) &&
            ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl->lpD3DHALCallbacks3 &&
            ((LPD3DHAL_CALLBACKS3)((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl->lpD3DHALCallbacks3)->DrawPrimitives2)
        {
            pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIDP2());
        }
        /* Test for presence DP HAL */
        else if ((!bDisableDP) &&
                ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl->lpD3DHALCallbacks2 &&
                ((LPD3DHAL_CALLBACKS2)((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl->lpD3DHALCallbacks2)->DrawOnePrimitive)
        {
            pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIDP());
        }
        else
        {
            pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIHW());
        }
    }
    else // all software rasterizers are DP-enabled
#endif // WIN95
    if (!bDisableDP2)
    {
        if ((lpD3DHALGlobalDriverData)
            && (IsEqualIID(riid, IID_IDirect3DHALDevice) )
            && (lpD3DHALGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_DRAWPRIMITIVES2EX)
           )
        {
            pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIDP2());
            if (pd3ddev) pd3ddev->deviceType = D3DDEVTYPE_DX7HAL;
        }
        else
        {
            pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIDP2());
        }
    }
    else if (!bDisableDP)
        pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIDP());
    else
        pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIHW());

    if (!pd3ddev) {
        D3D_ERR("Failed to allocate space for D3DDevice. Quitting.");
        return (DDERR_OUTOFMEMORY);
    }

    // If we have lost managed textures, we need to cleanup
    // since CheckSurfaces() would fail which would cause
    // FlushStates() to fail, which would result in the
    // current batch being abandoned (along with any device initialization)
    if(lpD3DI->lpTextureManager->CheckIfLost())
    {
        D3D_INFO(2, "Found lost managed textures. Evicting...");
        lpD3DI->lpTextureManager->EvictTextures();
    }

    if (bDisableDP)
        pd3ddev->dwDebugFlags |= D3DDEBUG_DISABLEDP;
    if (bDisableDP2)
        pd3ddev->dwDebugFlags |= D3DDEBUG_DISABLEDP2;

    ret = pd3ddev->Init(riid, lpD3DI, lpDDSTarget, pUnkOuter, lplpD3DDevice, dwVersion);
    if (ret!=D3D_OK)
    {
        delete pd3ddev;
        D3D_ERR("Failed to intilialize D3DDevice");
        return ret;
    }

    if (bDisableST)
        pd3ddev->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_MULTITHREADED;

#ifdef _X86_
    if (((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->dwLocalFlags & DDRAWILCL_FPUSETUP &&
        IS_DP2HAL_DEVICE(pd3ddev))
    {
        WORD wSave, wTemp;
        __asm {
            fstcw wSave
            mov ax, wSave
            and ax, not 300h    ;; single mode
            or  ax, 3fh         ;; disable all exceptions
            and ax, not 0C00h   ;; round to nearest mode
            mov wTemp, ax
            fldcw   wTemp
        }
    }
#if _D3D_FORCEDOUBLE
    if (bForceDouble && (pd3ddev->deviceType <= D3DDEVTYPE_DPHAL))
    {
        pd3ddev->dwDebugFlags |= D3DDEBUG_FORCEDOUBLE;
    }
    else
    {
        pd3ddev->dwDebugFlags &= ~D3DDEBUG_FORCEDOUBLE;
    }
#endif  //_D3D_FORCEDOUBLE
#endif

    return (ret);
}

HRESULT DIRECT3DDEVICEI::Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                              IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice, DWORD dwVersion)
{
    DDSCAPS               ddscaps;
    DDSURFACEDESC     ddsd;
    HRESULT       ret, ddrval;
    LPDIRECTDRAWSURFACE lpDDSZ=NULL;
    LPDIRECTDRAWPALETTE lpDDPal=NULL;
    LPGUID              pGuid;
    BOOL          bIsDX3Device;
    DDSCAPS surfCaps;

    this->dwFVFLastIn = this->dwFVFLastOut = 0;
    this->mDevUnk.refCnt             = 1;
    this->dwVersion          = dwVersion;
    this->mDevUnk.pDevI = this;
    pD3DMappedTexI = (LPVOID*)(this->lpD3DMappedTexI);
    pfnFlushStates = D3DFlushStates;
    this->dwFEFlags |= D3DFE_TSSINDEX_DIRTY;

    /* Single threaded or Multi threaded app ? */
    if (((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->dwLocalFlags & DDRAWILCL_MULTITHREADED)
        this->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_MULTITHREADED;

    /*
     * Are we really being aggregated?
     */

    bIsDX3Device=(pUnkOuter!=NULL);

    if (bIsDX3Device)
    {
        /*
         * Yup - we are being aggregated. Store the supplied
         * IUnknown so we can punt to that.
         * NOTE: We explicitly DO NOT AddRef here.
         */
        this->lpOwningIUnknown = pUnkOuter;
        DDASSERT(dwVersion==1);
    }
    else
    {
        /*
         * Nope - but we pretend we are anyway by storing our
         * own IUnknown as the parent IUnknown. This makes the
         * code much neater.
         */
        this->lpOwningIUnknown = (LPUNKNOWN)&this->mDevUnk;
    }

    // create the begin/end critical section
    InitializeCriticalSection(&this->BeginEndCSect);

    /*
     * Initialise textures
     */
    LIST_INITIALIZE(&this->texBlocks);

    /*
     * Initialise buffers
     */
    LIST_INITIALIZE(&this->buffers);

    /*
     * Initialise viewports
     */
    CIRCLE_QUEUE_INITIALIZE(&this->viewports, DIRECT3DVIEWPORTI);

    this->lpCurrentViewport = NULL;
    this->v_id = 0;

    /*
     * Initialise materials
     */
    LIST_INITIALIZE(&this->matBlocks);

    this->lpvVertexBatch = this->lpIndexBatch = NULL;
    this->dwHWNumCounts = 0;
    this->dwHWOffset = 0;
    this->dwHWTriIndex = 0;
    this->lpTextureBatched = NULL;
    this->dwVertexBase = 0;
    pGeometryFuncs = &GeometryFuncsGuaranteed;

    /*-----------------------------------------------------------------------------------------
     * Up till now we have done the easy part of the initialization. This is the stuff that
     * cannot fail. It initializes the object so that the destructor can be safely called if
     * any of the further initialization does not succeed.
     *---------------------------------------------------------------------------------------*/

    /*
     * Ensure the riid is one we understand.
     *
     * Query the registry.
     */
    pGuid = (GUID *)&riid;

#if DBG
    if (IsEqualIID(*pGuid, IID_IDirect3DRampDevice))
    {
        D3D_INFO(1, "======================= Ramp device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DRGBDevice))
    {
        D3D_INFO(1, "======================= RGB device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DMMXDevice))
    {
        D3D_INFO(1, "======================= RGB(MMX) device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DHALDevice))
    {
        D3D_INFO(1, "======================= HAL device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DRefDevice))
    {
        D3D_INFO(1, "======================= Reference Rasterizer device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DNullDevice))
    {
        D3D_INFO(1, "======================= Null device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DNewRGBDevice))
    {
        D3D_INFO(1, "======================= New RGB device selected");
    }
    D3D_INFO(1,"with HAL deviceType=%d",deviceType);
#endif

    // set up flag to use MMX when requested RGB
    BOOL bUseMMXAsRGBDevice = FALSE;
    if (IsEqualIID(*pGuid, IID_IDirect3DRGBDevice) && isMMXprocessor())
    {
        bUseMMXAsRGBDevice = TRUE;
        // read reg key to override use of MMX for RGB
        HKEY    hKey = (HKEY) NULL;
        if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH, &hKey) )
        {
            DWORD dwType;
            DWORD dwValue;
            DWORD dwSize = 4;

            if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "UseMMXForRGB", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
                 dwType == REG_DWORD &&
                 dwValue == 0)
            {
                bUseMMXAsRGBDevice = FALSE;
            }
            RegCloseKey( hKey );
        }
        if (bUseMMXAsRGBDevice)
        {
            D3D_INFO(1, "  using MMX in RGB device");
        }
    }

    BOOL bIsRamp = FALSE;
    if (IsEqualIID(*pGuid, IID_IDirect3DRampDevice))
    {
        bIsRamp = TRUE;
    }

    if (IsEqualIID(*pGuid, IID_IDirect3DRGBDevice) &&
        isMMXprocessor())
    {
        // Check for whether this app is one of the Intel ones
        // that want the MMX rasterizer
        LPDDRAWI_DIRECTDRAW_LCL lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl;

        // 0x4 corresponds to the "Intel app that wants MMX"
        // flag defined in ddrawpr.h
        if ( lpDDLcl->dwAppHackFlags & 0x4 )
        {
            pGuid = (GUID *)&IID_IDirect3DMMXDevice;
        }
    }

    /*
     * Check if the 3D cap is set on the surface.
     */
    memset(&ddsd, 0, sizeof ddsd);
    ddsd.dwSize = sizeof ddsd;
    ddrval = lpDDS->GetSurfaceDesc(&ddsd);
    if (ddrval != DD_OK) {
        D3D_ERR("Failed to get surface description of device's surface.");
        return (ddrval);
    }

    if (!(ddsd.ddsCaps.dwCaps & DDSCAPS_3DDEVICE)) {
        D3D_ERR("**** The DDSCAPS_3DDEVICE is not set on this surface.");
        D3D_ERR("**** You need to add DDSCAPS_3DDEVICE to ddsCaps.dwCaps");
        D3D_ERR("**** when creating the surface.");
        return (DDERR_INVALIDCAPS);
    }

    if (ddsd.ddsCaps.dwCaps & DDSCAPS_ZBUFFER) {
        D3D_ERR("**** DDSCAPS_ZBUFFER is set on this surface.");
        D3D_ERR("**** Rendering into Z buffer surfaces is not");
        D3D_ERR("**** currently supported by Direct3D.");
        return (DDERR_INVALIDCAPS);
    }

    if (ddsd.dwWidth > 2048 || ddsd.dwHeight > 2048)
    {
        D3D_ERR("**** Surface too large - must be <= 2048 in width & height.");
        return (DDERR_INVALIDOBJECT);
    }

    /* Check for palette... */
    ret = lpDDS->GetPalette(&lpDDPal);
    if ((ret != DD_OK) && (ret != DDERR_NOPALETTEATTACHED))
    {
        /*
         * NOTE: Again, not an error (yet) if there is no palette attached.
         * But if there is palette and we can't get at it for some reason
         * - fail.
         */
        D3D_ERR("Supplied DirectDraw Palette is invalid - can't create device");
        return (DDERR_INVALIDPARAMS);
    }

    /*
     * We're going to check now whether we should have got a palette.
     */
    if (ret == DDERR_NOPALETTEATTACHED) {
        if (ddsd.ddpfPixelFormat.dwRGBBitCount < 16) {
            D3D_ERR("No palette supplied for palettized surface - can't create device");
            return (DDERR_NOPALETTEATTACHED);
        }
    }

    // For DX3, we must not keep references to Palette and ZBuffer to avoid
    // circular references in the aggregation model.  But for DX5+, we want
    // to keep references to both to ensure they dont disappear.

    if(bIsDX3Device && (lpDDPal != NULL))
       lpDDPal->Release();  // release the reference GetPalette created
    this->lpDDPalTarget = lpDDPal;

    // Check for ZBuffer

    memset(&surfCaps, 0, sizeof(DDSCAPS));
    surfCaps.dwCaps = DDSCAPS_ZBUFFER;

    if (FAILED(ret = lpDDS->GetAttachedSurface(&surfCaps, &lpDDSZ))) {
        if (ret != DDERR_NOTFOUND) {
           D3D_ERR("Failed GetAttachedSurface for ZBuffer");
           goto handle_err;
        }
        D3D_INFO(2, "No zbuffer is attached to rendertarget surface (which is OK)");
    }

    if(bIsDX3Device && (lpDDSZ != NULL))
       lpDDSZ->Release();   // release the reference GetAttachedSurface created
    this->lpDDSZBuffer = lpDDSZ;

    this->guid = *pGuid;

    // Try to get a HAL provider for this driver (may need to use MMX guid if
    // using MMX for RGB requested device)
    ret = GetSwHalProvider(
        bUseMMXAsRGBDevice ? IID_IDirect3DMMXAsRGBDevice : riid,
        &this->pHalProv, &this->hDllProv);

    if (ret == S_OK)
    {
        // Got a software provider.
    }
    else if (ret == E_NOINTERFACE &&
             ((ret = GetHwHalProvider(riid, &this->pHalProv,
                                     &this->hDllProv,
                                     ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl)) == S_OK))
    {
        // Got a hardware provider.
    }
    else
    {
        if(IsEqualIID(riid, IID_IDirect3DHALDevice)) {
            D3D_ERR("Requested HAL Device non-existent or invalid");
        } else {
            D3D_ERR("Unable to get D3D Device provider for requested GUID");
        }
        goto handle_err;
    }

    {
        // Initialize test HAL provider to drop HAL calls (sort of a Null device)
        //
        DWORD value = 0;
        if (GetD3DRegValue(REG_DWORD, "DisableRendering", &value, sizeof(DWORD)) &&
            value != 0)
        {
            ret = GetTestHalProvider(
                    riid, ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl,
                    &this->pHalProv, this->pHalProv, 0);
            if (ret != D3D_OK)
            {
                D3D_ERR("Unable to set up 'DisableRendering' mode");
                goto handle_err;
            }
        }
    }

    // Initialise general DEVICEI information.
    if ((ret = InitDeviceI(this, lpD3DI)) != D3D_OK)
    {
        D3D_ERR("Failed to initialise device");
        goto handle_err;
    }

    // Check the surface and device to see if they're compatible
    if (FAILED(ret = checkDeviceSurface(lpDDS,lpDDSZ,pGuid))) {
        D3D_ERR("Device and surface aren't compatible");
        goto handle_err;
    }

    // Create front-end support structures.
    // ATTENTION - We probably want to avoid doing this if the driver
    // does its own front end.  Software fallbacks complicate the issue,
    // though.
    ret = D3DFE_Create(this, lpD3DI->lpDD, lpDDS, lpDDSZ, lpDDPal);
    if (ret != D3D_OK)
    {
        D3D_ERR("Failed to create front-end data-structures.");
        goto handle_err;
    }

    // Figure out place for rstates
    if (IS_HW_DEVICE(this) && IS_DP2HAL_DEVICE(this))
    {
        // In case of HW DP2 HAL we reuse the kernel allocated
        // memory for RStates since we need the driver to update
        // it
        rstates = (LPDWORD)lpwDPBuffer;
    }
    else
    {
        // In all other cases we simply allocate memory for rstates
        rstates = new DWORD[D3DHAL_MAX_RSTATES];
    }
    D3DFE_PROCESSVERTICES::lpdwRStates = this->rstates;

    // Check if we have a processor specific implementation available
    //  only use if DisablePSGP is not in registry or set to zero
    DWORD value;
    if (!GetD3DRegValue(REG_DWORD, "DisablePSGP", &value, sizeof(DWORD)))
    {
        value = 0;
    }

#ifdef _X86_
extern HRESULT D3DAPI pii_FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);
    if (pfnFEContextCreate == pii_FEContextCreate)
    {
        // here if this is PentiumII PSGP

        // regkey disable for PII PSGP - default is ENABLED
        DWORD dwValue2;  // disable if this is TRUE
        if (!GetD3DRegValue(REG_DWORD, "DisablePIIPSGP", &dwValue2, sizeof(DWORD)))
        {
            dwValue2 = 0;
        }
        else
        {
            D3D_INFO(2, "DisablePIIPSGP %d",dwValue2);
        }

        // do disable
        if ( dwValue2 )
        {
            pfnFEContextCreate = NULL;
        }
    }
#endif

    if (pfnFEContextCreate && ( value == 0) && (!bIsRamp) )
    {
        D3D_INFO(2, "PSGP enabled for device");
        // Ask the PV implementation to create a device specific "context"
        LPD3DFE_PVFUNCS pOptGeoFuncs = pGeometryFuncs;
        ret = pfnFEContextCreate(dwDeviceFlags, &pOptGeoFuncs);
        if ((ret == D3D_OK) && pOptGeoFuncs)
        {
            D3D_INFO(2, "using PSGP");
            pGeometryFuncs = pOptGeoFuncs;
        }
    }

    /*
     * put this device in the list of those owned by the Direct3D object
     */
    ret = hookDeviceToD3D(lpD3DI);
    if (ret != D3D_OK)
    {
        D3D_ERR("Failed to associate device with Direct3D");
        goto handle_err;
    }
    {
        if(lpD3DHALGlobalDriverData->hwCaps.dwMaxVertexCount == 0)
        {
            lpD3DHALGlobalDriverData->hwCaps.dwMaxVertexCount = __INIT_VERTEX_NUMBER;
        }
        if (TLVbuf.Grow(this, (__INIT_VERTEX_NUMBER*2)*sizeof(D3DTLVERTEX)) != DD_OK)
        {
            D3D_ERR( "Out of memory in DeviceCreate (TLVbuf)" );
            ret = DDERR_OUTOFMEMORY;
            goto handle_err;
        }
        if (HVbuf.Grow((__INIT_VERTEX_NUMBER*2)*sizeof(D3DFE_CLIPCODE)) != DD_OK)
        {
            D3D_ERR( "Out of memory in DeviceCreate (HVBuf)" );
            ret = DDERR_OUTOFMEMORY;
            goto handle_err;
        }
        ret = this->ClipperState.clipBuf.Grow
                (this, MAX_CLIP_VERTICES*__MAX_VERTEX_SIZE);
        if (ret != D3D_OK)
        {
            D3D_ERR( "Out of memory in DeviceCreate (ClipBuf)" );
            ret = DDERR_OUTOFMEMORY;
            goto handle_err;
        }
        ret = this->ClipperState.clipBufPrim.Grow
                (this, MAX_CLIP_TRIANGLES*sizeof(D3DTRIANGLE));
        if (ret != D3D_OK)
        {
            D3D_ERR( "Out of memory in DeviceCreate (ClipBufPrim)" );
            ret = DDERR_OUTOFMEMORY;
            goto handle_err;
        }

    }
    /*
     * IDirect3DDevice2 specific initialization
     */
    if (D3DMalloc((void**)&this->wTriIndex, dwD3DTriBatchSize*4*sizeof(WORD)) != DD_OK) {
        D3D_ERR( "Out of memory in DeviceCreate (wTriIndex)" );
        ret = DDERR_OUTOFMEMORY;
        goto handle_err;
    }

    if (D3DMalloc((void**)&this->lpHWCounts, dwHWBufferSize*sizeof(D3DI_HWCOUNTS)/32 ) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate (HWCounts)" );
        ret = DDERR_OUTOFMEMORY;
        goto handle_err;
    }
    memset(this->lpHWCounts, 0, sizeof(D3DI_HWCOUNTS) );
    this->lpHWVertices = (LPD3DTLVERTEX) this->lpwDPBuffer;
    if (D3DMalloc((void**)&this->lpHWTris, dwHWMaxTris*sizeof(D3DTRIANGLE) ) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate (HWVertices)" );
        ret = DDERR_OUTOFMEMORY;
        goto handle_err;
    }

    if (DDERR_OUTOFMEMORY == (ret=HookD3DDeviceToSurface(this, ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl)))
        goto handle_err;
    if (lpDDSZ && (DDERR_OUTOFMEMORY == (ret=HookD3DDeviceToSurface(this, ((LPDDRAWI_DDRAWSURFACE_INT) lpDDSZ)->lpLcl))))
    {
        UnHookD3DDeviceFromSurface(this, ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl);
        goto handle_err;
    }

    /* Set the initial render state of the device */
    if (FAILED(ret = stateInitialize(lpDDSZ!=NULL))) {
        D3D_ERR("Failed to set initial state for device");
        goto handle_err;
    }

    /*
     * NOTE: We don't return the actual device interface. We
     * return the device's special IUnknown interface which
     * will be used in a QueryInterface to get the actual
     * Direct3D device interface.
     */
    *lplpD3DDevice = static_cast<LPUNKNOWN>(&(this->mDevUnk));


    return (D3D_OK);
handle_err:
    // might be able to simplify if this fn and not D3DFE_Create sets this->lpDDSZBuffer/this->lpDDPalette
    if(lpDDSZ!=NULL) {
       if(!bIsDX3Device) {
           lpDDSZ->Release();    // release the reference GetAttachedSurface created
       }
       this->lpDDSZBuffer=NULL;  // make sure the device destructor doesn't try to re-release this
                                 // I'd let device destructor handle this, but errors can occur before D3DFE_Create is called
    }

    if(lpDDPal!=NULL) {
      if(!bIsDX3Device) {
        lpDDPal->Release();      // release the reference GetPalette created
      }
      this->lpDDPalTarget=NULL;  // make sure the device destructor doesn't try to re-release this
    }

    D3D_ERR("Device creation failed!!");
    return(ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetStats"

HRESULT D3DAPI DIRECT3DDEVICEI::GetStats(LPD3DSTATS lpStats)
{
    // not implemented for Device3 (and newer) interfaces
    if (this->dwVersion >= 3)
    {
        D3D_INFO(3, "GetStats not implemented for Device3 interface");
        return E_NOTIMPL;
    }

    D3DSTATS    stats;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_D3DSTATS_PTR(lpStats)) {
            D3D_ERR( "Invalid D3DSTATS pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in GetStats" );
        return DDERR_INVALIDPARAMS;
    }

    stats = this->D3DStats;

    *lpStats = stats;
    lpStats->dwSize = sizeof(D3DSTATS);

    return DD_OK;
}

/**
 ** Viewport Management
 **/
HRESULT DIRECT3DDEVICEI::hookViewportToDevice(LPDIRECT3DVIEWPORTI lpD3DView)
{

    CIRCLE_QUEUE_INSERT_END(&this->viewports, DIRECT3DVIEWPORTI,
                            lpD3DView, vw_list);
    lpD3DView->lpDevI = this;

    this->numViewports++;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::AddViewport"

HRESULT D3DAPI DIRECT3DDEVICEI::AddViewport(LPDIRECT3DVIEWPORT lpD3DView)
{
    return AddViewport((LPDIRECT3DVIEWPORT3)lpD3DView);
}

HRESULT D3DAPI DIRECT3DDEVICEI::AddViewport(LPDIRECT3DVIEWPORT2 lpD3DView)
{
    return AddViewport((LPDIRECT3DVIEWPORT3)lpD3DView);
}

HRESULT D3DAPI DIRECT3DDEVICEI::AddViewport(LPDIRECT3DVIEWPORT3 lpD3DView)
{
    LPDIRECT3DVIEWPORTI lpViewI;
    HRESULT err = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    lpViewI = (LPDIRECT3DVIEWPORTI)lpD3DView;

    if (lpViewI->lpDevI) {
        D3D_ERR("viewport already associated with a device");
        return (DDERR_INVALIDPARAMS);
    }

    err = hookViewportToDevice(lpViewI);

    /*
     * AddRef the viewport.
     */
    lpD3DView->AddRef();

    return (err);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::DeleteViewport"

HRESULT D3DAPI DIRECT3DDEVICEI::DeleteViewport(LPDIRECT3DVIEWPORT lpD3DView)
{
    return DeleteViewport((LPDIRECT3DVIEWPORT3)lpD3DView);
}

HRESULT D3DAPI DIRECT3DDEVICEI::DeleteViewport(LPDIRECT3DVIEWPORT2 lpD3DView)
{
    return DeleteViewport((LPDIRECT3DVIEWPORT3)lpD3DView);
}

HRESULT D3DAPI DIRECT3DDEVICEI::DeleteViewport(LPDIRECT3DVIEWPORT3 lpD3DView)
{
    LPDIRECT3DVIEWPORTI lpViewI;
    HRESULT err = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(lpD3DView)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in DeleteViewport" );
        return DDERR_INVALIDPARAMS;
    }
    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "DeleteViewport in Begin" );
        return D3DERR_INBEGIN;
    }
    lpViewI = (LPDIRECT3DVIEWPORTI)lpD3DView;

    if (lpViewI->lpDevI != this) {
        D3D_ERR("This Viewport is not associated with this device");
        return (DDERR_INVALIDPARAMS);
    }

    /*
     * Remove this viewport from the device.
     */
    CIRCLE_QUEUE_DELETE(&this->viewports, lpViewI, vw_list);
    this->numViewports--;

    lpViewI->lpDevI = NULL;
    if (lpViewI == lpCurrentViewport)
    {
        // AnanKan (6/10/98):
        // Apparently this release needs to be done for proper COM
        // implementation, since we do lpCurrentViewport->AddRef() when
        // we make a viewport the current viewport of the device. But this
        // breaks some old apps (pplane.exe)
        if(!(this->dwDeviceFlags & D3DDEV_PREDX6DEVICE))
            lpCurrentViewport->Release();
        lpCurrentViewport = NULL;
        v_id = 0;
    }

    /*
     * Release the viewport.
     */
    lpD3DView->Release();

    return (err);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::NextViewport"

HRESULT D3DAPI DIRECT3DDEVICEI::NextViewport(LPDIRECT3DVIEWPORT lpD3DView,
                                   LPDIRECT3DVIEWPORT* lplpView,
                                   DWORD dwFlags)
{
    return NextViewport((LPDIRECT3DVIEWPORT3)lpD3DView,
                               (LPDIRECT3DVIEWPORT3*)lplpView, dwFlags);
}

HRESULT D3DAPI DIRECT3DDEVICEI::NextViewport(LPDIRECT3DVIEWPORT2 lpD3DView,
                                    LPDIRECT3DVIEWPORT2* lplpView,
                                    DWORD dwFlags)
{
    return NextViewport((LPDIRECT3DVIEWPORT3)lpD3DView,
                               (LPDIRECT3DVIEWPORT3*)lplpView, dwFlags);
}

HRESULT D3DAPI DIRECT3DDEVICEI::NextViewport(LPDIRECT3DVIEWPORT3 lpD3DView,
                                    LPDIRECT3DVIEWPORT3* lplpView,
                                    DWORD dwFlags)
{
    LPDIRECT3DVIEWPORTI lpViewI;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_OUTPTR(lplpView)) {
            D3D_ERR( "Invalid pointer to viewport object pointer" );
            return DDERR_INVALIDPARAMS;
        }

        *lplpView = NULL;

        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (dwFlags == D3DNEXT_NEXT) {
            if (!VALID_DIRECT3DVIEWPORT3_PTR(lpD3DView)) {
                D3D_ERR( "Invalid Direct3DViewport pointer" );
                return DDERR_INVALIDPARAMS;
            }
            lpViewI = (LPDIRECT3DVIEWPORTI)lpD3DView;
            if (lpViewI->lpDevI != this) {
                D3D_ERR("This Viewport is not associated with this device");
                return (DDERR_INVALIDPARAMS);
            }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR("Exception encountered validating parameters in NextViewport");
        return DDERR_INVALIDPARAMS;
    }

    if (this->numViewports <= 0) {
        D3D_ERR( "No viewport has been added to the device yet." );
        return D3DERR_NOVIEWPORTS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "NextViewport called in Begin" );
        return D3DERR_INBEGIN;
    }
    switch (dwFlags) {
    case D3DNEXT_NEXT:
        *lplpView = (LPDIRECT3DVIEWPORT3)
            CIRCLE_QUEUE_NEXT(&this->viewports,lpViewI,vw_list);
        break;
    case D3DNEXT_HEAD:
        *lplpView = (LPDIRECT3DVIEWPORT3)
            CIRCLE_QUEUE_FIRST(&this->viewports);
        break;
    case D3DNEXT_TAIL:
        *lplpView = (LPDIRECT3DVIEWPORT3)
            CIRCLE_QUEUE_LAST(&this->viewports);
        break;
    default:
        D3D_ERR("invalid dwFlags in NextViewport");
        return (DDERR_INVALIDPARAMS);
    }
    if (*lplpView == (LPDIRECT3DVIEWPORT3)&this->viewports) {
        *lplpView = NULL;
    }

    /*
     * Must AddRef the returned object
     */
    if (*lplpView) {
        (*lplpView)->AddRef();
    }

    return (D3D_OK);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::Execute"

HRESULT D3DAPI DIRECT3DDEVICEI::Execute(LPDIRECT3DEXECUTEBUFFER lpBuffer,
                              LPDIRECT3DVIEWPORT lpD3DView,
                              DWORD dwInpFlags)
{
    HRESULT ret;
    LPDIRECT3DVIEWPORTI lpD3DViewI;
    LPDIRECT3DVIEWPORTI lpD3DOldViewI;
    BOOL viewportChanged;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(lpBuffer))
        {
            D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (lpD3DView && (!VALID_DIRECT3DVIEWPORT_PTR(lpD3DView)) )
        {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in Execute" );
        return DDERR_INVALIDPARAMS;
    }
    lpD3DOldViewI = lpCurrentViewport;
    if (lpD3DView)
        lpD3DViewI = (LPDIRECT3DVIEWPORTI)lpD3DView;
    else
        lpD3DViewI = lpCurrentViewport;

    // The viewport must be associated with lpDev device
    //
    if (lpD3DViewI->lpDevI != this)
    {
        return (DDERR_INVALIDPARAMS);
    }

    lpCurrentViewport = lpD3DViewI;

    ret = CheckDeviceSettings(this);
    if (ret != D3D_OK)
    {
        lpCurrentViewport = lpD3DOldViewI;
        D3D_ERR("Bad Device settings");
        return (ret);
    }

    /*
     * Save existing fp state and then disable divide-by-zero exceptions.
     * XXX need a better way for non-intel platforms.
     */

    LPDIRECT3DEXECUTEBUFFERI lpBufferI;
    D3DI_EXECUTEDATA exData;

    lpBufferI = (LPDIRECT3DEXECUTEBUFFERI)lpBuffer;

    /* Make sure this buffer is associated with the correct device */
    if (lpBufferI->lpDevI != this)
    {
        D3D_ERR("Exe-buffer not associated with this device");
        return (DDERR_INVALIDPARAMS);
    }

    if (lpBufferI->locked)
    {
        D3D_ERR("Exe-buffer is locked");
        return (D3DERR_EXECUTE_LOCKED);
    }

    /* Apply any cached render states */
    if ((ret=this->FlushStates()) != D3D_OK)
    {
        D3D_ERR("Error trying to flush batched commands");
        return ret;
    }
    /*
     * Create an execute data structure
     */
    memset(&exData, 0, sizeof(exData));
    exData.dwSize = sizeof(D3DI_EXECUTEDATA);
    exData.dwHandle = lpBufferI->hBuf;
    exData.dwVertexOffset = lpBufferI->exData.dwVertexOffset;
    exData.dwVertexCount = lpBufferI->exData.dwVertexCount;
    exData.dwInstructionOffset = lpBufferI->exData.dwInstructionOffset;
    exData.dwInstructionLength = lpBufferI->exData.dwInstructionLength;
    exData.dwHVertexOffset = lpBufferI->exData.dwHVertexOffset;

#if DBG
// Validation
    if (exData.dwVertexOffset > exData.dwInstructionOffset ||
        (exData.dwVertexCount * sizeof(D3DVERTEX) + exData.dwVertexOffset) >
        exData.dwInstructionOffset)
    {
        D3D_WARN(1, "Execute: Instruction and vertex areas overlap");
    }

#endif

    this->dwFlags = D3DPV_INSIDEEXECUTE;
    this->dwVIDOut = D3DFVF_TLVERTEX;

    ret = this->ExecuteI(&exData, dwInpFlags);
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to Execute");
        return ret;
    }

    this->dwFEFlags &= ~D3DFE_TLVERTEX;    // This flag could be set inside
    // Flush immediately since we cannot batch across EB calls (for DP2)
    if ((ret=this->FlushStates()) != D3D_OK)
    {
        D3D_ERR("Error trying to flush batched commands");
        return ret;
    }
    lpBufferI->exData.dsStatus = exData.dsStatus;

    lpCurrentViewport = lpD3DOldViewI;

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetCaps"

HRESULT D3DAPI CDirect3DDevice::GetCaps(LPD3DDEVICEDESC lpD3DHWDevDesc,
                              LPD3DDEVICEDESC lpD3DHELDevDesc)
{
    HRESULT ret;

    ret = GetCapsI(lpD3DHWDevDesc, lpD3DHELDevDesc);
    if ((ret == D3D_OK) && IS_PRE_DX5_DEVICE(this))
    {
        lpD3DHELDevDesc->dpcLineCaps.dwTextureFilterCaps &= ~(D3DPTFILTERCAPS_MIPNEAREST |
                                                              D3DPTFILTERCAPS_MIPLINEAR |
                                                              D3DPTFILTERCAPS_LINEARMIPNEAREST);
        lpD3DHELDevDesc->dpcTriCaps.dwTextureFilterCaps &= ~(D3DPTFILTERCAPS_MIPNEAREST |
                                                             D3DPTFILTERCAPS_MIPLINEAR |
                                                             D3DPTFILTERCAPS_LINEARMIPNEAREST);
    }
    return ret;
}

HRESULT D3DAPI D3DAPI DIRECT3DDEVICEI::GetCaps(LPD3DDEVICEDESC lpD3DHWDevDesc,
                               LPD3DDEVICEDESC lpD3DHELDevDesc)
{
    return GetCapsI(lpD3DHWDevDesc, lpD3DHELDevDesc);
}

HRESULT DIRECT3DDEVICEI::GetCapsI(LPD3DDEVICEDESC lpD3DHWDevDesc,
                               LPD3DDEVICEDESC lpD3DHELDevDesc)
{
    HRESULT ret;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DDEVICEDESC_PTR(lpD3DHWDevDesc)) {
            D3D_ERR( "Invalid D3DDEVICEDESC pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_D3DDEVICEDESC_PTR(lpD3DHELDevDesc)) {
            D3D_ERR( "Invalid D3DDEVICEDESC pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in GetCaps" );
        return DDERR_INVALIDPARAMS;
    }

    memcpy(lpD3DHWDevDesc, &this->d3dHWDevDesc, lpD3DHWDevDesc->dwSize);
    memcpy(lpD3DHELDevDesc, &this->d3dHELDevDesc, lpD3DHELDevDesc->dwSize);
    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::Pick"

HRESULT D3DAPI DIRECT3DDEVICEI::Pick(LPDIRECT3DEXECUTEBUFFER lpD3DExBuf,
                           LPDIRECT3DVIEWPORT lpD3DView,
                           DWORD dwFlags,
                           LPD3DRECT lpRect)
{
    HRESULT ret;
    LPDIRECT3DVIEWPORTI lpD3DViewI;
    LPDIRECT3DVIEWPORTI lpD3DOldViewI;
    LPDIRECT3DEXECUTEBUFFERI lpBufferI;
    D3DI_PICKDATA pdata;
    D3DI_EXECUTEDATA exData;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(lpD3DExBuf)) {
            D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DVIEWPORT_PTR(lpD3DView)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DRECT_PTR(lpRect)) {
            D3D_ERR( "Invalid D3DRECT pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    lpD3DViewI = (LPDIRECT3DVIEWPORTI)lpD3DView;

    /*
     * The viewport must be associated with this device
     */
    if (lpD3DViewI->lpDevI != this) {
        D3D_ERR("viewport not associated with this device");
        return (DDERR_INVALIDPARAMS);
    }

    lpBufferI = (LPDIRECT3DEXECUTEBUFFERI)lpD3DExBuf;

    /* Make sure this buffer is associated with the correct device */
    if (lpBufferI->lpDevI != this) {
        D3D_ERR("Exe-buffer not associated with this device");
        return (DDERR_INVALIDPARAMS);
    }

    if (lpBufferI->locked) {
        D3D_ERR("Exe-buffer is locked");
        return (D3DERR_EXECUTE_LOCKED);
    }

    lpD3DOldViewI = lpCurrentViewport;
    lpCurrentViewport = lpD3DViewI;

    ret = CheckDeviceSettings(this);
    if (ret != D3D_OK)
    {
        D3D_ERR("Bad Device settings");
        lpCurrentViewport = lpD3DOldViewI;
        return (ret);
    }

    /*
     * Create an execute data structure
     */
    memset(&exData, 0, sizeof(exData));
    exData.dwSize = sizeof(D3DI_EXECUTEDATA);
    exData.dwHandle = lpBufferI->hBuf;
    memcpy((LPBYTE)(&exData.dwVertexOffset), 
           (LPBYTE)(&lpBufferI->exData.dwVertexOffset),
           sizeof(D3DEXECUTEDATA) - sizeof(DWORD));
    pdata.exe = &exData;
    pdata.pick.x1 = lpRect->x1;
    pdata.pick.y1 = lpRect->y1;
    pdata.pick.x2 = lpRect->x2;
    pdata.pick.y2 = lpRect->y2;

    this->dwFlags = D3DPV_INSIDEEXECUTE;
    this->dwVIDOut = D3DFVF_TLVERTEX;

    D3DHAL_ExecutePick(this, &pdata);

    this->dwFEFlags &= ~D3DFE_TLVERTEX;    // This flag could be set inside
    lpCurrentViewport = lpD3DOldViewI;

    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetPickRecords"

HRESULT D3DAPI DIRECT3DDEVICEI::GetPickRecords(LPDWORD count,
                                     LPD3DPICKRECORD records)
{
    HRESULT     ret;
    D3DI_PICKDATA   pdata;
    D3DPICKRECORD*  tmpBuff;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DWORD_PTR(count)) {
            D3D_ERR( "Invalid DWORD pointer" );
            return DDERR_INVALIDPARAMS;
        }
#if DBG
        if (*count && records && IsBadWritePtr(records, *count * sizeof(D3DPICKRECORD))) {
            D3D_ERR( "Invalid D3DPICKRECORD pointer" );
            return DDERR_INVALIDPARAMS;
        }
#endif
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    pdata.records = NULL;
    GenGetPickRecords(this, &pdata);

    if (count && records && *count >= (unsigned long)pdata.pick_count)
    {
        int picked_size = pdata.pick_count * sizeof(D3DPICKRECORD);

        if (D3DMalloc((void**)&tmpBuff, picked_size) != DD_OK)
        {
            return (DDERR_OUTOFMEMORY);
        }
        pdata.records = tmpBuff;
        GenGetPickRecords(this, &pdata);
        memcpy((char*)records, (char*)tmpBuff, picked_size);
        D3DFree(tmpBuff);
    }

    *count = pdata.pick_count;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::EnumTextureFormats"


#define DEFINEPF(flags, fourcc, bpp, rMask, gMask, bMask, aMask) \
    { sizeof(DDPIXELFORMAT), (flags), (fourcc), (bpp), (rMask), (gMask), (bMask), (aMask) }

static DDPIXELFORMAT g_DX5TexEnumIncListStatic[] = {
DEFINEPF(DDPF_RGB,                      0UL, 16UL, 0x00007c00UL, 0x000003e0UL, 0x0000001fUL, 0x00000000), // 16bit 555
DEFINEPF(DDPF_RGB|DDPF_ALPHAPIXELS,     0UL, 16UL, 0x00007c00UL, 0x000003e0UL, 0x0000001fUL, 0x00008000), // 16bit 1555
DEFINEPF(DDPF_RGB,                      0UL, 16UL, 0x0000f800UL, 0x000007e0UL, 0x0000001fUL, 0x00000000), // 16bit 565
DEFINEPF(DDPF_RGB|DDPF_ALPHAPIXELS,     0UL, 16UL, 0x00000f00UL, 0x000000f0UL, 0x0000000fUL, 0x0000f000), // 16bit 4444
DEFINEPF(DDPF_RGB|DDPF_ALPHAPIXELS,     0UL, 32UL, 0x00ff0000UL, 0x0000ff00UL, 0x000000ffUL, 0xff000000), // 32bit 8888
DEFINEPF(DDPF_RGB,                      0UL, 32UL, 0x00ff0000UL, 0x0000ff00UL, 0x000000ffUL, 0x00000000), // 32bit 888
DEFINEPF(DDPF_RGB,                      0UL,  8UL, 0x000000e0UL, 0x0000001cUL, 0x00000003UL, 0x00000000), // 8bit  332
DEFINEPF(DDPF_RGB|DDPF_PALETTEINDEXED4, 0UL,  4UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000), // 4bit pal
DEFINEPF(DDPF_RGB|DDPF_PALETTEINDEXED8, 0UL,  8UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000), // 8bit pal
};
DWORD g_cDX5TexEnumIncListStatic = sizeof(g_DX5TexEnumIncListStatic)/sizeof(DDPIXELFORMAT);

BOOL
MatchDDPIXELFORMAT( DDPIXELFORMAT* pddpfA, DDPIXELFORMAT* pddpfB )
{
    if ( pddpfA->dwFlags != pddpfB->dwFlags ) return FALSE;
    if ( pddpfA->dwRGBBitCount != pddpfB->dwRGBBitCount ) return FALSE;
    if ( pddpfA->dwRBitMask != pddpfB->dwRBitMask ) return FALSE;
    if ( pddpfA->dwGBitMask != pddpfB->dwGBitMask ) return FALSE;
    if ( pddpfA->dwBBitMask != pddpfB->dwBBitMask ) return FALSE;
    if ( pddpfA->dwRGBAlphaBitMask != pddpfB->dwRGBAlphaBitMask ) return FALSE;
    if ( pddpfA->dwFourCC != pddpfB->dwFourCC ) return FALSE;
    return TRUE;
}

void
LoadTexEnumInclList( char* pResPath, DDPIXELFORMAT*& pddpfInclList, DWORD& cInclList)
{
    HKEY hKey = (HKEY)NULL;
    if (ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE,
        pResPath, &hKey))
    {
        DWORD cSubKeys = 0;
        if ( ERROR_SUCCESS == RegQueryInfoKey ( hKey,
                NULL,NULL,NULL, &cSubKeys, NULL,
                NULL,NULL,NULL,NULL,NULL,NULL ) )
        {
            D3D_INFO(3,"LoadTexEnumInclList: cSubKeys = %d",cSubKeys);

            if (cSubKeys == 0) return;

            // allocate space for ddpf inclusion list
            cInclList = cSubKeys;
            if (D3DMalloc((void**)&pddpfInclList, cInclList*sizeof(DDPIXELFORMAT)) != D3D_OK) {
                D3D_ERR("malloc failed on texture enum inclusion list");
                pddpfInclList = NULL;
                cInclList = 0;
            }
            memset( pddpfInclList, 0, cInclList*sizeof(DDPIXELFORMAT) );

            for (DWORD i=0; i<cSubKeys; i++)
            {
                char pName[128] = "";
                DWORD cbName = 128;
                if (ERROR_SUCCESS == RegEnumKeyEx( hKey, i, pName, &cbName,
                        NULL,NULL,NULL,NULL ) )
                {
                    HKEY hTexKey = (HKEY)NULL;
                    if (ERROR_SUCCESS == RegOpenKey( hKey, pName, &hTexKey))
                    {
                        DWORD dwType; DWORD dwSize;

                        // get string of full ddpf
                        char pDDPFStr[128] = ""; DWORD cbDDPFStr = 128;
                        if (ERROR_SUCCESS == RegQueryValueEx(hTexKey, "ddpf",
                                NULL, &dwType, (LPBYTE)pDDPFStr, &cbDDPFStr) )
                        {
                            sscanf(pDDPFStr, "%x %x %d %x %x %x %x",
                                &pddpfInclList[i].dwFlags,&pddpfInclList[i].dwFourCC,&pddpfInclList[i].dwRGBBitCount,
                                &pddpfInclList[i].dwRBitMask,&pddpfInclList[i].dwGBitMask,&pddpfInclList[i].dwBBitMask,
                                &pddpfInclList[i].dwRGBAlphaBitMask);
                        }

                        D3D_INFO(3,"LoadTexEnumInclList: <%s> %08x %08x %2d %08x %08x %08x %08x",
                            pName,
                            pddpfInclList[i].dwFlags,
                            pddpfInclList[i].dwFourCC,
                            pddpfInclList[i].dwRGBBitCount,
                            pddpfInclList[i].dwRBitMask,
                            pddpfInclList[i].dwGBitMask,
                            pddpfInclList[i].dwBBitMask,
                            pddpfInclList[i].dwRGBAlphaBitMask);
                    }
                    else
                    {
                        D3D_INFO(3,"LoadTexEnumInclList: failed to open subkey %s",pName);
                    }
                }
                else
                {
                    D3D_INFO(3,"LoadTexEnumInclList: failed to enumerate subkey %d",i);
                }
            }
        }
    }
}

HRESULT
DoEnumTextureFormats(
    DIRECT3DDEVICEI* lpDevI,
    LPD3DENUMTEXTUREFORMATSCALLBACK lpEnumCallbackDX5, // DX5 version
    LPD3DENUMPIXELFORMATSCALLBACK lpEnumCallbackDX6,   // DX6 version
    LPVOID lpContext)
{
    HRESULT ret, userRet;
    LPDDSURFACEDESC lpDescs, lpRetDescs;
    DWORD num_descs;
    DWORD i;

    ret = D3D_OK;

    num_descs = lpDevI->lpD3DHALGlobalDriverData->dwNumTextureFormats;
    lpDescs = lpDevI->lpD3DHALGlobalDriverData->lpTextureFormats;
    if (!num_descs)
    {
        D3D_ERR("no texture formats supported");
        return (D3DERR_TEXTURE_NO_SUPPORT);
    }

    if (D3DMalloc((void**)&lpRetDescs, sizeof(DDSURFACEDESC) * num_descs) != D3D_OK)
    {
        D3D_ERR("failed to alloc space for return descriptions");
        return (DDERR_OUTOFMEMORY);
    }
    memcpy(lpRetDescs, lpDescs, sizeof(DDSURFACEDESC) * num_descs);

    // get apphack flags
    LPDDRAWI_DIRECTDRAW_LCL lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)(lpDevI->lpDD))->lpLcl;
    DWORD dwEnumInclAppHack =
        ((lpDDLcl->dwAppHackFlags & DDRAW_APPCOMPAT_TEXENUMINCL_0)?1:0) |
        ((lpDDLcl->dwAppHackFlags & DDRAW_APPCOMPAT_TEXENUMINCL_1)?2:0);
    // two bit field:
    //  0 - no apphack (default behavior)
    //  1 - use no inclusion list
    //  2 - use DX5 inclusion list
    //  3 - use DX6 inclusion list
    D3D_INFO(3, "APPCOMPAT_TEXENUMINCL: %d",dwEnumInclAppHack);

    // enumeration limit defaults true for <DX6 interfaces, and can be disabled by apphack
    BOOL bEnumLimit = (lpDevI->dwVersion < 3) ? TRUE : FALSE;
    if (lpDDLcl->dwAppHackFlags & DDRAW_APPCOMPAT_TEXENUMLIMIT) { bEnumLimit = FALSE; }
    D3D_INFO(3, "EnumTextureFormats: bEnumLimit %d",bEnumLimit);

#if DBG
    // debug capability to eliminate enumeration of any subset of first 32 textures
    DWORD dwEnumDisable = 0x0;
    GetD3DRegValue(REG_DWORD, "TextureEnumDisable", &dwEnumDisable, sizeof(DWORD));
    D3D_INFO(3, "TextureEnumDisable: %08x",dwEnumDisable);
#endif

    DDPIXELFORMAT* pDX5TexEnumIncList = NULL;
    DWORD cDX5TexEnumIncList = 0;
    // load DX5 inclusion list from registry
    LoadTexEnumInclList( RESPATH_D3D "\\DX5TextureEnumInclusionList",
        pDX5TexEnumIncList, cDX5TexEnumIncList );

    DDPIXELFORMAT* pDX6TexEnumIncList = NULL;
    DWORD cDX6TexEnumIncList = 0;
    // load DX6 list only for DX6 interface or apphack
    if ((lpDevI->dwVersion == 3) || (dwEnumInclAppHack >= 3))
    {
        LoadTexEnumInclList( RESPATH_D3D "\\DX6TextureEnumInclusionList",
            pDX6TexEnumIncList, cDX6TexEnumIncList );
    }

    userRet = D3DENUMRET_OK;
    int cEnumLimit = 0;
    for (i = 0; i < num_descs && userRet == D3DENUMRET_OK; i++)
    {

        D3D_INFO(3,"EnumTextureFormats: %2d %08x %08x %2d %08x %08x %08x %08x",i,
            lpRetDescs[i].ddpfPixelFormat.dwFlags,
            lpRetDescs[i].ddpfPixelFormat.dwFourCC,
            lpRetDescs[i].ddpfPixelFormat.dwRGBBitCount,
            lpRetDescs[i].ddpfPixelFormat.dwRBitMask,
            lpRetDescs[i].ddpfPixelFormat.dwGBitMask,
            lpRetDescs[i].ddpfPixelFormat.dwBBitMask,
            lpRetDescs[i].ddpfPixelFormat.dwRGBAlphaBitMask);

#if DBG
        if ( (i < 32) && (dwEnumDisable & (1<<i)) )
        {
            D3D_INFO(3, "EnumTextureFormats: filtering texture %d",i);
            continue;
        }
#endif

        // Filtering out texture formats which are not on inclusion list -
        if ( (dwEnumInclAppHack != 1) && // inclusion list not disabled by apphack
             !(lpRetDescs[i].ddpfPixelFormat.dwFlags == DDPF_FOURCC) ) // not FourCC
        {
            BOOL bMatched = FALSE;

            // match against DX5 base (static) inclusion list
            for (DWORD j=0; j<g_cDX5TexEnumIncListStatic; j++)
            {
                if (MatchDDPIXELFORMAT( &(g_DX5TexEnumIncListStatic[j]), &(lpRetDescs[i].ddpfPixelFormat)))
                {
                    bMatched = TRUE; break;
                }
            }
            // match against DX5 extended (regkey) inclusion list
            if (!bMatched && cDX5TexEnumIncList)
            {
                for (DWORD j=0; j<cDX5TexEnumIncList; j++)
                {
                    if (MatchDDPIXELFORMAT( &(pDX5TexEnumIncList[j]), &(lpRetDescs[i].ddpfPixelFormat)))
                    {
                        bMatched = TRUE; break;
                    }
                }
            }

            // match against DX6 regkey list for:
            //   (DX6 interface AND apphack not forcing DX5 inclusion list only) OR
            //   (apphack forcing DX6 inclusion list)
            if ( ((lpDevI->dwVersion == 3) && (dwEnumInclAppHack != 2)) ||
                 (dwEnumInclAppHack == 3) )
            {
                for (DWORD j=0; j<cDX6TexEnumIncList; j++)
                {
                    if (MatchDDPIXELFORMAT( &(pDX6TexEnumIncList[j]), &(lpRetDescs[i].ddpfPixelFormat)))
                    {
                        bMatched = TRUE; break;
                    }
                }
            }

            if (!bMatched) {
                D3D_INFO(3, "EnumTextureFormats: filtering non-included texture %d",i);
                continue;
            }
        }

        // exclude DXT1..5 for <DX6 interfaces
        if ( (lpDevI->dwVersion < 3) && (lpRetDescs[i].ddpfPixelFormat.dwFlags == DDPF_FOURCC) )
        {
            if ( (lpRetDescs[i].ddpfPixelFormat.dwFourCC == MAKEFOURCC('D', 'X', 'T', '1')) ||
                 (lpRetDescs[i].ddpfPixelFormat.dwFourCC == MAKEFOURCC('D', 'X', 'T', '2')) ||
                 (lpRetDescs[i].ddpfPixelFormat.dwFourCC == MAKEFOURCC('D', 'X', 'T', '3')) ||
                 (lpRetDescs[i].ddpfPixelFormat.dwFourCC == MAKEFOURCC('D', 'X', 'T', '4')) ||
                 (lpRetDescs[i].ddpfPixelFormat.dwFourCC == MAKEFOURCC('D', 'X', 'T', '5')) )
            {
                D3D_INFO(3, "EnumTextureFormats: filtering DXT1..5 format for DX3/5 interfaces");
                continue;
            }
        }

        // exclude all FourCC code formats for <DX6 interfaces on DX7 drivers
        if ( (lpDevI->dwVersion < 3) && IS_DX7HAL_DEVICE(lpDevI) &&
             (lpRetDescs[i].ddpfPixelFormat.dwFlags == DDPF_FOURCC) )
        {
            D3D_INFO(3, "EnumTextureFormats: filtering all FOURCC formats for DX3/5 interfaces on DX7 HALs");
            continue;
        }

        // do enumeration if not ('limit enabled' && 'limit exceeded')
        if ( !(bEnumLimit && (++cEnumLimit > 10)) )
        {
            if (lpEnumCallbackDX5)
            {
                userRet = (*lpEnumCallbackDX5)(&lpRetDescs[i], lpContext);
            }
            if (lpEnumCallbackDX6)
            {
                userRet = (*lpEnumCallbackDX6)(&(lpRetDescs[i].ddpfPixelFormat), lpContext);
            }
        }
        else
        {
            D3D_INFO(3, "EnumTextureFormats: enumeration limit exceeded");
        }
    }

    D3DFree(lpRetDescs);
    if (pDX5TexEnumIncList) D3DFree(pDX5TexEnumIncList);
    if (pDX6TexEnumIncList) D3DFree(pDX6TexEnumIncList);

    return (D3D_OK);
}


// Device/Device2 version
HRESULT D3DAPI DIRECT3DDEVICEI::EnumTextureFormats(
    LPD3DENUMTEXTUREFORMATSCALLBACK lpEnumCallback,
    LPVOID lpContext)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALIDEX_CODE_PTR(lpEnumCallback)) {
            D3D_ERR( "Invalid callback pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    return DoEnumTextureFormats(this, lpEnumCallback, NULL, lpContext);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::EnumTextureFormats"

// Device3 version
HRESULT D3DAPI DIRECT3DDEVICEI::EnumTextureFormats(
    LPD3DENUMPIXELFORMATSCALLBACK lpEnumCallback,
    LPVOID lpContext)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALIDEX_CODE_PTR(lpEnumCallback)) {
            D3D_ERR( "Invalid callback pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    return DoEnumTextureFormats(this, NULL, lpEnumCallback, lpContext);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SwapTextureHandles"

HRESULT D3DAPI DIRECT3DDEVICEI::SwapTextureHandles(LPDIRECT3DTEXTURE lpTex1,
                                         LPDIRECT3DTEXTURE lpTex2)
{
    LPDIRECT3DTEXTUREI lpTex1I;
    LPDIRECT3DTEXTUREI lpTex2I;
    HRESULT ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DTEXTURE_PTR(lpTex1)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DTEXTURE_PTR(lpTex2)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        lpTex1I = static_cast<LPDIRECT3DTEXTUREI>(lpTex1);
        lpTex2I = static_cast<LPDIRECT3DTEXTUREI>(lpTex2);
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    ret = SwapTextureHandles((LPDIRECT3DTEXTURE2)lpTex1I,
                                     (LPDIRECT3DTEXTURE2)lpTex2I);
    return ret;
}

HRESULT D3DAPI DIRECT3DDEVICEI::SwapTextureHandles(LPDIRECT3DTEXTURE2 lpTex1,
                                          LPDIRECT3DTEXTURE2 lpTex2)
{
    LPDIRECT3DTEXTUREI lpTex1I;
    LPDIRECT3DTEXTUREI lpTex2I;
    HRESULT servRet;
    D3DTEXTUREHANDLE hTex;
    LPD3DI_TEXTUREBLOCK lptBlock1,lptBlock2;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DTEXTURE2_PTR(lpTex1)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DTEXTURE2_PTR(lpTex2)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        lpTex1I = static_cast<LPDIRECT3DTEXTUREI>(lpTex1);
        lpTex2I = static_cast<LPDIRECT3DTEXTUREI>(lpTex2);
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    if (lpTex1I->lpDDSSys || lpTex2I->lpDDSSys)
    {
        D3D_ERR("Can't Swap Managed textures. Returning DDERR_INVALIDPARAMS");
        return  DDERR_INVALIDPARAMS;
    }
    if (!(lptBlock1=D3DI_FindTextureBlock(lpTex1I,this)))
    {
        D3D_ERR("lpTex1 is an invalid texture handle.");
        return  DDERR_INVALIDPARAMS;
    }
    if (!(lptBlock2=D3DI_FindTextureBlock(lpTex2I,this)))
    {
        D3D_ERR("lpTex2 is an invalid texture handle.");
        return  DDERR_INVALIDPARAMS;
    }
    if (D3D_OK != (servRet=FlushStates()))
    {
        D3D_ERR("Error trying to flush batched commands during TextureSwap");
        return  servRet;
    }

    if (IS_DX7HAL_DEVICE(this))
    {
        LPDDRAWI_DDRAWSURFACE_LCL surf1 = ((LPDDRAWI_DDRAWSURFACE_INT)lpTex1I->lpDDS)->lpLcl;
        LPDDRAWI_DDRAWSURFACE_LCL surf2 = ((LPDDRAWI_DDRAWSURFACE_INT)lpTex2I->lpDDS)->lpLcl;
        LPDDRAWI_DIRECTDRAW_LCL pDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)lpDirect3DI->lpDD)->lpLcl;
        DDASSERT(pDDLcl != NULL);

        // Update DDraw handle in driver GBL object.
        pDDLcl->lpGbl->hDD = pDDLcl->hDD;
        // Swap the handles stored in the surface locals
        surf1->lpSurfMore->dwSurfaceHandle = lptBlock2->hTex;
        surf2->lpSurfMore->dwSurfaceHandle = lptBlock1->hTex;
        // Swap the surface pointers stored in the handle table stored in
        // ddraw local
        SURFACEHANDLELIST(pDDLcl).dwList[lptBlock1->hTex].lpSurface = surf2;
        SURFACEHANDLELIST(pDDLcl).dwList[lptBlock2->hTex].lpSurface = surf1;

        // call the driver to switch the textures mapped to the handles in
        // the driver
        DDASSERT(NULL != pDDLcl->lpGbl->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx);
        DDHAL_CREATESURFACEEXDATA   csdex;
        DWORD   rc;
        csdex.ddRVal  = DDERR_GENERIC;
        csdex.dwFlags = 0;
        csdex.lpDDLcl = pDDLcl;
        csdex.lpDDSLcl = surf1;
        rc = pDDLcl->lpGbl->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx(&csdex);
        if(  DDHAL_DRIVER_HANDLED == rc && DD_OK != csdex.ddRVal)
        {
            // Driver call failed
            D3D_ERR("DdSwapTextureHandles failed!");
            return  D3DERR_TEXTURE_SWAP_FAILED;
        }
        csdex.lpDDSLcl = surf2;
        rc = pDDLcl->lpGbl->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx(&csdex);
        if(  DDHAL_DRIVER_HANDLED == rc && DD_OK != csdex.ddRVal)
        {
            // Driver call failed
            D3D_ERR("DdSwapTextureHandles failed!");
            return  D3DERR_TEXTURE_SWAP_FAILED;
        }
    }
    else
    {
        servRet=D3DHAL_TextureSwap(this,lptBlock1->hTex,lptBlock2->hTex);
        if (D3D_OK != servRet)
        {
            D3D_ERR("SwapTextureHandles HAL call failed");
            return  D3DERR_TEXTURE_SWAP_FAILED;
        }
    }
    hTex=lptBlock1->hTex;
    lptBlock1->hTex=lptBlock2->hTex;
    lptBlock2->hTex=hTex;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::CreateMatrix"

HRESULT D3DAPI DIRECT3DDEVICEI::CreateMatrix(LPD3DMATRIXHANDLE lphMatrix)
{
    HRESULT servRet;
    D3DMATRIXHANDLE hMat;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DMATRIXHANDLE_PTR(lphMatrix)) {
            D3D_ERR( "Invalid D3DMATRIXHANDLE pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    *lphMatrix = 0;

    servRet = D3DHAL_MatrixCreate(this, &hMat);
    if (servRet != D3D_OK)
    {
        D3D_ERR("Could not create matrix.");
        return (DDERR_OUTOFMEMORY);
    }

    D3D_INFO(4, "CreateMatrix, Matrix created. handle = %d", hMat);
    *lphMatrix = hMat;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetMatrix"

HRESULT D3DAPI DIRECT3DDEVICEI::SetMatrix(D3DMATRIXHANDLE hMatrix,
                                const LPD3DMATRIX lpdmMatrix)
{
    HRESULT servRet;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DMATRIX_PTR(lpdmMatrix)) {
            D3D_ERR( "Invalid D3DMATRIX pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (!hMatrix) {
        D3D_ERR("NULL hMatrix passed");
        return (DDERR_INVALIDPARAMS);
    }

    servRet = D3DHAL_MatrixSetData(this, hMatrix, lpdmMatrix);
    if (servRet != D3D_OK)
    {
        D3D_ERR("Could not set matrix");
        return (DDERR_INVALIDPARAMS);
    }

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetMatrix"

HRESULT D3DAPI DIRECT3DDEVICEI::GetMatrix(D3DMATRIXHANDLE hMatrix,
                                LPD3DMATRIX lpdmMatrix)
{
    HRESULT servRet;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DMATRIX_PTR(lpdmMatrix)) {
            D3D_ERR( "Invalid D3DMATRIX pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (!hMatrix)
    {
        D3D_ERR("NULL hMatrix passed.");
        return (DDERR_INVALIDPARAMS);
    }

    memset(lpdmMatrix, 0, sizeof(D3DMATRIX));

    servRet = D3DHAL_MatrixGetData(this, hMatrix, lpdmMatrix);
    if (servRet != D3D_OK)
    {
        D3D_ERR("Could not get matrix");
        return (DDERR_INVALIDPARAMS);
    }

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::DeleteMatrix"

HRESULT D3DAPI DIRECT3DDEVICEI::DeleteMatrix(D3DMATRIXHANDLE hMatrix)
{
    HRESULT servRet;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (!hMatrix) {
        D3D_ERR("invalid D3DMATRIXHANDLE");
        return DDERR_INVALIDPARAMS;
    }

    servRet = D3DHAL_MatrixDestroy(this, hMatrix);
    if (servRet != D3D_OK)
    {
        D3D_ERR("Could not delete matrix");
        return (DDERR_INVALIDPARAMS);
    }

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::BeginScene"

HRESULT D3DAPI DIRECT3DDEVICEI::BeginScene()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE)
    {
        D3D_ERR("BeginScene, already in scene.");
        return (D3DERR_SCENE_IN_SCENE);
    }

    // Check if we lost surfaces or rtarget / zbuffer was locked
    HRESULT servRet = this->CheckSurfaces();
    if (servRet != D3D_OK)
    {
        // If we lost surfaces
        if (servRet == DDERR_SURFACELOST)
        {
            // Even if the app restores the rendertargets and z buffer, it
            // doesn't know anything about vidmem execute buffers or
            // managed texture surfaces in vidmem. So, we need to do
            // this on our own. We first check if it is safe to restore
            // surfaces. If not, we fail in the usual way. Else, we
            // do the restore. Note that we will fail *only* if the
            // app calls BeginScene at the wrong time.
            servRet = this->lpDirect3DI->lpDD4->TestCooperativeLevel();
            if (servRet == DD_OK)
            {
                // Everything must be evicted otherwise Restore might not work
                // as there might be new surface allocated, in fact, we should
                // post a flag in Device so that Texture manage stop calling
                // CreateSurface() if this flag is indicating TestCooperativeLevel()
                // failed, however, even we added those, the EvictTextures below
                // is still needed but not this critical--kanqiu
                this->lpDirect3DI->lpTextureManager->EvictTextures();
                servRet = this->lpDirect3DI->lpDD4->RestoreAllSurfaces();
                if (servRet != DD_OK)
                    return D3DERR_SCENE_BEGIN_FAILED;
            }
            else
                return DDERR_SURFACELOST;
        }
        else
        {
            // Render target and / or the z buffer was locked
            return servRet;
        }
    }
    servRet = D3DHAL_SceneCapture(this, TRUE);

    if (servRet != D3D_OK && servRet != DDERR_NOTFOUND)
    {
        D3D_ERR("Could not BeginScene.");
        return D3DERR_SCENE_BEGIN_FAILED;
    }

    this->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_INSCENE;
    if (lpD3DHALGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR)
    {
        lpDirect3DI->lpTextureManager->TimeStamp();
    }

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::EndScene"

HRESULT D3DAPI DIRECT3DDEVICEI::EndScene()
{
    HRESULT servRet;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (!(this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE)) {
        D3D_ERR("EndScene, not in scene.");
        return (D3DERR_SCENE_NOT_IN_SCENE);
    }

    this->dwHintFlags &= ~D3DDEVBOOL_HINTFLAGS_INSCENE;
    if (IS_DX7HAL_DEVICE(this))
    {
        // must set the token before FlushStates()
        SetRenderStateI((D3DRENDERSTATETYPE)D3DRENDERSTATE_SCENECAPTURE, FALSE);
    }

    servRet = FlushStates();    //time to flush DrawPrimitives
    if (servRet != D3D_OK)
    {
        D3D_ERR("Could not Flush commands in EndScene!");
        return (D3DERR_SCENE_END_FAILED);
    }
    if (!IS_DX7HAL_DEVICE(this))
    {
        servRet = D3DHAL_SceneCapture(this, FALSE);

        if (servRet != D3D_OK && servRet != DDERR_NOTFOUND)
        {
            DPF(0, "(ERROR) Direct3DDevice::EndScene: Could not EndScene. Returning %d", servRet);
            return (D3DERR_SCENE_END_FAILED);
        }
    }

    // Did we lose any surfaces during this scene ?
    if (this->dwFEFlags & D3DFE_LOSTSURFACES)
    {
        D3D_INFO(3, "reporting DDERR_SURFACELOST in EndScene");
        this->dwFEFlags &= ~D3DFE_LOSTSURFACES;
        return DDERR_SURFACELOST;
    }

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetDirect3D"

HRESULT D3DAPI DIRECT3DDEVICEI::GetDirect3D(LPDIRECT3D* lplpD3D)
{
    LPDIRECT3D3 lpD3D3;
    HRESULT ret;

    ret = GetDirect3D(&lpD3D3);
    if (ret == D3D_OK)
    {
    //  *lplpD3D = dynamic_cast<LPDIRECT3D>(lpD3D3); // This is possible using RTTI
        *lplpD3D = static_cast<LPDIRECT3D>(static_cast<LPDIRECT3DI>(lpD3D3)); // This is safe even using static_cast
    }
    return ret;
}

HRESULT D3DAPI DIRECT3DDEVICEI::GetDirect3D(LPDIRECT3D2* lplpD3D)
{
    LPDIRECT3D3 lpD3D3;
    HRESULT ret;

    ret = GetDirect3D(&lpD3D3);
    if (ret == D3D_OK)
    {
    //  *lplpD3D = dynamic_cast<LPDIRECT3D>(lpD3D3); // This is possible using RTTI
        *lplpD3D = static_cast<LPDIRECT3D2>(static_cast<LPDIRECT3DI>(lpD3D3)); // This is safe even using static_cast
    }
    return ret;
}

HRESULT D3DAPI DIRECT3DDEVICEI::GetDirect3D(LPDIRECT3D3* lplpD3D)
{

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(lplpD3D)) {
            D3D_ERR( "Invalid Direct3D pointer pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpD3D = (LPDIRECT3D3) this->lpDirect3DI;
    (*lplpD3D)->AddRef();

    return (D3D_OK);
}

void
D3DDeviceDescConvert(LPD3DDEVICEDESC lpOut,
                     LPD3DDEVICEDESC_V1 lpV1,
                     LPD3DHAL_D3DEXTENDEDCAPS lpExt)
{
    if(lpV1!=NULL)
       memcpy(lpOut, lpV1, D3DDEVICEDESCSIZE_V1);

    if (lpExt)
    {
        // DX5
        lpOut->dwSize = D3DDEVICEDESCSIZE;
        lpOut->dwMinTextureWidth = lpExt->dwMinTextureWidth;
        lpOut->dwMaxTextureWidth = lpExt->dwMaxTextureWidth;
        lpOut->dwMinTextureHeight = lpExt->dwMinTextureHeight;
        lpOut->dwMaxTextureHeight = lpExt->dwMaxTextureHeight;
        lpOut->dwMinStippleWidth = lpExt->dwMinStippleWidth;
        lpOut->dwMaxStippleWidth = lpExt->dwMaxStippleWidth;
        lpOut->dwMinStippleHeight = lpExt->dwMinStippleHeight;
        lpOut->dwMaxStippleHeight = lpExt->dwMaxStippleHeight;

        // DX6
        lpOut->dwMaxTextureRepeat = lpExt->dwMaxTextureRepeat;
        lpOut->dwMaxTextureAspectRatio = lpExt->dwMaxTextureAspectRatio;
        lpOut->dwMaxAnisotropy = lpExt->dwMaxAnisotropy;
        lpOut->dvGuardBandLeft = lpExt->dvGuardBandLeft;
        lpOut->dvGuardBandTop = lpExt->dvGuardBandTop;
        lpOut->dvGuardBandRight = lpExt->dvGuardBandRight;
        lpOut->dvGuardBandBottom = lpExt->dvGuardBandBottom;
        lpOut->dvExtentsAdjust = lpExt->dvExtentsAdjust;
        lpOut->dwStencilCaps = lpExt->dwStencilCaps;
        lpOut->dwFVFCaps = lpExt->dwFVFCaps;
        lpOut->dwTextureOpCaps = lpExt->dwTextureOpCaps;
        lpOut->wMaxTextureBlendStages = lpExt->wMaxTextureBlendStages;
        lpOut->wMaxSimultaneousTextures = lpExt->wMaxSimultaneousTextures;
    }
}

//---------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::CheckSurfaces"
HRESULT DIRECT3DDEVICEI::CheckSurfaces()
{
    if(this->lpDirect3DI->lpTextureManager->CheckIfLost())
    {
        D3D_ERR("Managed Textures lost");
        return DDERR_SURFACELOST;
    }
    if ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl->lpGbl->dwUsageCount ||
         (this->lpDDSZBuffer && ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl->lpGbl->dwUsageCount) )
    {
        D3D_ERR("Render target or Z buffer locked");
        return DDERR_SURFACEBUSY;
    }
    if ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl->dwFlags & DDRAWISURF_INVALID )\
        {
            D3D_ERR("Render target buffer lost");
            return DDERR_SURFACELOST;
        }
    if ( this->lpDDSZBuffer && ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl->dwFlags & DDRAWISURF_INVALID ) )
    {
        D3D_ERR("Z buffer lost");
        return DDERR_SURFACELOST;
    }
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\d3diunk.cpp ===
/*==========================================================================;
*
*  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
*
*  File:    d3diunk.c
*  Content: Direct3D IUnknown
*@@BEGIN_MSINTERNAL
* 
*  $Id$
*
*  History:
*   Date    By  Reason
*   ====    ==  ======
*   07/12/95    stevela Merged Colin's changes.
*   27/08/96   stevela Ifdefed out the Close of gHEvent.  We're using
*                      DirectDraw's critical section.
*@@END_MSINTERNAL
*
***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * If we are built with aggregation enabled then we actually need two
 * different Direct3D QueryInterface, AddRef and Releases. One which
 * does the right thing on the Direct3D object and one which simply
 * punts to the owning interface.
 */

/*
 * CDirect3DUnk::QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::QueryInterface"

HRESULT D3DAPI CDirect3DUnk::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if( !VALID_OUTPTR( ppvObj ) )
        {
            D3D_ERR( "Invalid obj ptr" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    
    *ppvObj = NULL;

    D3D_INFO(3, "Direct3D IUnknown QueryInterface");
    
    if(IsEqualIID(riid, IID_IUnknown))
    {
        /*
         * Asking for IUnknown and we are IUnknown so just bump the
         * reference count and return this interface.
         * NOTE: Must AddRef through the interface being returned.
         */
        pD3DI->AddRef();
        // explicit ::CDirect3D disambiguation required since there are multiple IUnknown DIRECT3DI inherits from
        *ppvObj = static_cast<LPVOID>(static_cast<LPUNKNOWN>(static_cast<CDirect3D*>(pD3DI)));
    }
    else if (IsEqualIID(riid, IID_IDirect3D))
    {
        /*
         * Asking for legacy interface - add ref and return old interface
         */
        pD3DI->AddRef();
        // No disambiguation required. Only one IDirect3D base for DIRECT3DI
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3D>(pD3DI));
    }
    else if (IsEqualIID(riid, IID_IDirect3D2))
    {
        /*
         * Asking for (second) legacy interface - add ref and return old interface
         */
        pD3DI->AddRef();
        // No disambiguation required. Only one IDirect3D2 base for DIRECT3DI
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3D2>(pD3DI));
    }
    else if (IsEqualIID(riid, IID_IDirect3D3))
    {
        pD3DI->AddRef();
        // No disambiguation required. Only one IDirect3D3 base for DIRECT3DI
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3D3>(pD3DI));
    }
    else
    {
        /*
         * Don't understand this interface. Fail.
         * NOTE: Used to return DDERR_GENERIC. Now return
         * E_NOINTERFACE.
         */
        return (E_NOINTERFACE);
    }
    
    return (D3D_OK);
    
} /* CDirect3DUnk::QueryInterface */

/*
 * CDirect3DUnk::AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DUnk::AddRef"

ULONG D3DAPI CDirect3DUnk::AddRef()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    refCnt++;
    D3D_INFO(3, "Direct3D IUnknown AddRef: Reference count = %d", refCnt);
    return (refCnt);
    
} /* CDirect3DUnk::AddRef */

/*
 * CDirect3DUnk::Release
 */
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DUnk::Release"

ULONG D3DAPI CDirect3DUnk::Release()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    /*
     * decrement the ref count. if we hit 0, free the object
     */
    refCnt--;
    D3D_INFO(3, "Direct3D IUnknown Release: Reference count = %d", refCnt);
    
    if( refCnt == 0 )
    {
        delete pD3DI; // Delete Parent object
        return 0;
    }
    return refCnt;
    
} /* D3DIUnknown_Release */

DIRECT3DI::~DIRECT3DI()
{
    D3D_INFO(3, "Release Direct3D Object");
    
    /*
     * free up all viewports created by this object
     */
    while (LIST_FIRST(&this->viewports)) {
        LPDIRECT3DVIEWPORTI lpViewI = LIST_FIRST(&this->viewports);
        lpViewI->Release();
    }
    
    /*
     * free up all lights created by this object
     */
    while (LIST_FIRST(&this->lights)) {
        LPDIRECT3DLIGHTI lpLightI = LIST_FIRST(&this->lights);
        lpLightI->Release();
    }
    
    /*
     * free up all devices created by this object
     */
    while (LIST_FIRST(&this->devices)) {
        LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&this->devices);
        lpDevI->Release();
    }
    
    /*
     * free up all materials left around
     */
    while (LIST_FIRST(&this->materials)) {
        LPDIRECT3DMATERIALI lpMatI = LIST_FIRST(&this->materials);
        lpMatI->Release();
    }
    
    delete lpTextureManager;
    /*
     * free up all allocated Buckets
     */
#if DBG
    /* this->lpFreeList must have all the buckets that are allocated */
    if (this->lpFreeList || this->lpBufferList)
    {
        int i,j;
        LPD3DBUCKET   temp;
        for (i=0,temp=this->lpFreeList;temp;i++) temp=temp->next;
        for (j=0,temp=this->lpBufferList;temp;j++) temp=temp->next;
        D3D_INFO(4,"D3D Release: recovered %d buckets in lpFreeList in %d buffers",i,j);
        DDASSERT(j*(D3DBUCKETBUFFERSIZE-1)==i);
    }
#endif  //DBG
    while (this->lpBufferList)
    {
        LPD3DBUCKET   temp=this->lpBufferList;
        this->lpBufferList=temp->next;
        D3DFree(temp->lpBuffer);
        D3D_INFO(4,"D3D Release:lpBufferList %d bytes freed",D3DBUCKETBUFFERSIZE*sizeof(D3DBUCKET));
    }
    this->lpFreeList=NULL;
}
    
/*
  * DIRECT3DI::QueryInterface
  */
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::QueryInterface"
  
HRESULT D3DAPI DIRECT3DI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT ret;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if( !VALID_OUTPTR( ppvObj ) )
        {
            D3D_ERR( "Invalid obj ptr" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    
    *ppvObj = NULL;

    ret = this->lpOwningIUnknown->QueryInterface(riid, ppvObj);
    return ret;
}

/*
 * DIRECT3DI::AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::AddRef"

ULONG D3DAPI DIRECT3DI::AddRef()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * Punt to the owning interface.
     */
    return  this->lpOwningIUnknown->AddRef();
}

/*
 * DIRECT3DI::Release
 */
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::Release"

ULONG D3DAPI DIRECT3DI::Release()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    /*
     * Punt to the owning interface.
     */
    return  this->lpOwningIUnknown->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\beginend.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       beginend.c
 *  Content:    Begin/End implementation
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "drawprim.hpp"
#include "d3dfei.h"

// This should be moved with other DP flags so that no one uses this bit
#define __NON_FVF_INPUT         0x80000000

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "MoveData"

_inline void MoveData(LPVOID lpData, DWORD destOffset, DWORD srcOffset,
                      DWORD size)
{
    memcpy((char*)lpData + destOffset, (char*)lpData + srcOffset, size);
}
//---------------------------------------------------------------------
void CleanupBeginEnd(LPDIRECT3DDEVICEI lpDevI)
{
    lpDevI->lpVertexIndices = NULL;
    lpDevI->lpvVertexData = NULL;
    lpDevI->dwBENumVertices = 0;
    lpDevI->dwBENumIndices = 0;
    lpDevI->dwHintFlags &= ~D3DDEVBOOL_HINTFLAGS_INBEGIN_ALL;
}
//---------------------------------------------------------------------
HRESULT
DoFlushBeginEnd(LPDIRECT3DDEVICEI lpDevI)
{
    HRESULT ret;

    lpDevI->lpwIndices = NULL;
    lpDevI->dwNumIndices = 0;
    lpDevI->lpClipFlags = (D3DFE_CLIPCODE*)lpDevI->HVbuf.GetAddress();
    lpDevI->position.lpvData = lpDevI->lpvVertexData;

    ret = lpDevI->ProcessPrimitive();
    return ret;
}
//---------------------------------------------------------------------
__inline void Dereference(LPDIRECT3DDEVICEI lpDevI, DWORD indexStart, DWORD numVer)
{
    char *dst_vptr = (char*)lpDevI->lpvVertexBatch;
    char *src_vptr = (char*)lpDevI->lpvVertexData;
    WORD *iptr = &lpDevI->lpVertexIndices[indexStart];
    DWORD size = lpDevI->position.dwStride;
    for (DWORD i=0; i < numVer; i++)
    {
        memcpy(dst_vptr, &src_vptr[iptr[i]*size], size);
        dst_vptr += size;
    }
}
//---------------------------------------------------------------------
HRESULT
DoFlushBeginIndexedEnd(LPDIRECT3DDEVICEI lpDevI)
{
    HRESULT             ret;
    DWORD               i;
    static BOOL         offScreen;  // all vertices are off screen

    lpDevI->dwNumVertices = lpDevI->dwBENumVertices;
    lpDevI->lpwIndices = lpDevI->lpVertexIndices;
    lpDevI->lpClipFlags = (D3DFE_CLIPCODE*)lpDevI->HVbuf.GetAddress();
    lpDevI->position.lpvData = lpDevI->lpvVertexData;

    if ( (lpDevI->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN) &&
         (!(lpDevI->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN_FIRST_FLUSH)) )
    {      // if this is the first flush
        lpDevI->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_INBEGIN_FIRST_FLUSH;
        offScreen = 0;
        if (lpDevI->dwBENumIndices < lpDevI->dwMaxIndexCount)
        {   // single flush case
            /*
              If the user is using a large vertex array for relatively few prims
              we need to dereference the indexed prims into another array.  Otherwise
              we waste too much time transforming and lighting vertices that we never use.

              Since BeginIndexed requires that the user pass in an array of vertices we
              know that this->lpvVertexBatch is not being used.  So derefernce into it.
              We know it's there because the index space gets created at the same time.

              Also note that since the max size fo the index array is bigger than
              the vertex array we may have to do this in several small batches.
              */

            if (!FVF_TRANSFORMED(lpDevI->dwVIDIn))
            {
                if (lpDevI->dwBENumIndices*INDEX_BATCH_SCALE < lpDevI->dwBENumVertices)
                {
                    WORD  *iptr;
                    DWORD indexStart = 0;
                    DWORD numPrims;
                    DWORD numIndices = lpDevI->dwBENumIndices;

                    switch (lpDevI->primType)
                    {
                    case D3DPT_LINELIST :
                    {
                        do
                        {
                            numPrims = min(numIndices/2, lpDevI->dwMaxVertexCount/2);
                            DWORD numVer = numPrims << 1;

                            Dereference(lpDevI, indexStart, numVer);

                            lpDevI->dwNumVertices = numVer;
                            lpDevI->dwNumPrimitives = numPrims;
                            lpDevI->position.lpvData = lpDevI->lpvVertexBatch;

                            ret = lpDevI->ProcessPrimitive();
                            if (ret != D3D_OK)
                            {
                                return ret;
                            }
                            indexStart += numVer;
                            numIndices -= numVer;
                        } while (numIndices > 1);
                        break;
                    }
                    case D3DPT_LINESTRIP :
                        do
                        {
                            numPrims = min(numIndices-1, lpDevI->dwMaxVertexCount-1);
                            DWORD numVer = numPrims + 1;

                            Dereference(lpDevI, indexStart, numVer);

                            lpDevI->dwNumVertices = numPrims+1;
                            lpDevI->dwNumPrimitives = numPrims;
                            lpDevI->position.lpvData = lpDevI->lpvVertexBatch;

                            ret = lpDevI->ProcessPrimitive();
                            if (ret != D3D_OK)
                            {
                                return ret;
                            }
                            indexStart += numPrims;
                            numIndices -= numPrims;
                        } while (numIndices > 1);
                        break;
                    case D3DPT_TRIANGLELIST :
                        do
                        {
                            numPrims = min(numIndices/3, lpDevI->dwMaxVertexCount/3);
                            DWORD numVer = numPrims*3;

                            Dereference(lpDevI, indexStart, numVer);

                            lpDevI->dwNumVertices = numVer;
                            lpDevI->dwNumPrimitives = numPrims;
                            lpDevI->position.lpvData = lpDevI->lpvVertexBatch;

                            ret = lpDevI->ProcessPrimitive();
                            if (ret != D3D_OK)
                            {
                                return ret;
                            }
                            indexStart += numVer;
                            numIndices -= numVer;
                        } while (numIndices > 2);
                        break;
                    case D3DPT_TRIANGLESTRIP :
                        do
                        {
                            numPrims = min(numIndices-2, lpDevI->dwMaxVertexCount-2);
                            DWORD numVer = numPrims + 2;

                            Dereference(lpDevI, indexStart, numVer);

                            lpDevI->dwNumVertices = numVer;
                            lpDevI->dwNumPrimitives = numPrims;
                            lpDevI->position.lpvData = lpDevI->lpvVertexBatch;

                            ret = lpDevI->ProcessPrimitive();
                            if (ret != D3D_OK)
                            {
                                return ret;
                            }
                            indexStart += numPrims;
                            numIndices -= numPrims;
                        } while (numIndices > 2);
                        break;
                    case D3DPT_TRIANGLEFAN :
                        // lock in center of fan
                        char *tmp = (char*)lpDevI->lpvVertexBatch;
                        char *src = (char*)lpDevI->lpvVertexData;
                        DWORD size = lpDevI->position.dwStride;
                        memcpy(lpDevI->lpvVertexBatch,
                               &src[lpDevI->lpVertexIndices[0]*size], size);
                        lpDevI->lpvVertexBatch = tmp + size;
                        indexStart = 1;
                        do
                        {
                            numPrims = min(numIndices-2, lpDevI->dwMaxVertexCount-2);

                            Dereference(lpDevI, indexStart, numPrims + 1);

                            lpDevI->dwNumVertices = numPrims+2;
                            lpDevI->dwNumPrimitives = numPrims;
                            lpDevI->position.lpvData = tmp;

                            ret = lpDevI->ProcessPrimitive();
                            if (ret != D3D_OK)
                            {
                                return ret;
                            }
                            indexStart += numPrims;
                            numIndices -= numPrims;
                        } while (numIndices > 2);
                        lpDevI->lpvVertexBatch = tmp; // Restore
                        break;
                    }   // end of prim type switch

                    return D3D_OK;
                }
                // else fall through to the no batching case
            }

            // no batching case
            ret = lpDevI->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);

            return ret;
        }
        else
        {
            // this is the first of n possible batches so t&l all vertices just once
            ret = lpDevI->ProcessPrimitive(__PROCPRIMOP_PROCVERONLY);
            if (ret != D3D_OK)
            {
                return ret;
            }
            // This flag is cleared in CleanupBeginEnd
            lpDevI->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_INBEGIN_BIG_PRIM;
            if (lpDevI->dwClipIntersection)
            {
                // all vertices are off screen so we can just bail
                offScreen = 1;  // so we can early out next flush
                return D3D_OK;
            }
        }
    }   // end if if first flush

    // for secondary flushes don't bother to draw if we don't need to
    if (!offScreen)
        ret = DoDrawIndexedPrimitive(lpDevI);

    return ret;
}   // end of DoFlushBeginIndexedEnd()
//---------------------------------------------------------------------
// Computes the number of primitives
// Input:  lpDevI->primType
//         dwNumVertices
// Output: lpDevI->dwNumPrimitives
//         lpDevI->D3DStats
//         return value = "Real" number of vertices (indices)
#undef DPF_MODNAME
#define DPF_MODNAME "GetNumPrimBE"

inline DWORD GetNumPrimBE(LPDIRECT3DDEVICEI lpDevI, DWORD dwNumVertices)
{
    lpDevI->dwNumPrimitives = 0;
    switch (lpDevI->primType)
    {
    case D3DPT_POINTLIST:
        lpDevI->D3DStats.dwPointsDrawn += dwNumVertices;
        lpDevI->dwNumPrimitives = dwNumVertices;
        return dwNumVertices;
    case D3DPT_LINELIST:
        lpDevI->dwNumPrimitives = dwNumVertices >> 1;
        lpDevI->D3DStats.dwLinesDrawn += lpDevI->dwNumPrimitives;
        return lpDevI->dwNumPrimitives << 1;
    case D3DPT_LINESTRIP:
        if (dwNumVertices < 2)
            return 0;
        lpDevI->dwNumPrimitives = dwNumVertices - 1;
        lpDevI->D3DStats.dwLinesDrawn += lpDevI->dwNumPrimitives;
        return dwNumVertices;
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        if (dwNumVertices < 3)
            return 0;        
        lpDevI->dwNumPrimitives = dwNumVertices - 2;
        lpDevI->D3DStats.dwTrianglesDrawn += lpDevI->dwNumPrimitives;
        return dwNumVertices;
    case D3DPT_TRIANGLELIST:
        lpDevI->dwNumPrimitives = dwNumVertices / 3;
        lpDevI->D3DStats.dwTrianglesDrawn += lpDevI->dwNumPrimitives;
        return lpDevI->dwNumPrimitives * 3;
    }
    return 0;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "BeginEnd"

HRESULT FlushBeginEndBatch(LPDIRECT3DDEVICEI lpDevI, BOOL leaving)
{
    HRESULT ret;
#ifdef _X86_
    unsigned short fpsave, fptemp;
#endif

    if (lpDevI->dwBENumIndices == 0xFFFFFFFF)
        lpDevI->dwNumVertices = GetNumPrimBE(lpDevI, lpDevI->dwBENumVertices);
    else
        lpDevI->dwNumIndices = GetNumPrimBE(lpDevI, lpDevI->dwBENumIndices);

    if (lpDevI->dwNumPrimitives < 1)
    {
        return DDERR_INVALIDPARAMS;
    }

    ret = (*lpDevI->pfnDoFlushBeginEnd)(lpDevI);

    /*
     * ReInit the device Begin/End states
     */
    if (!leaving)
        /*
         * Figure out how many and which vertices to keep for next batch.
         */
    {
        DWORD *dataCountPtr;
        DWORD vertexSize;       // size in bytes
        DWORD offset;           // start offset

        lpDevI->wFlushed = TRUE;

        if (lpDevI->lpVertexIndices)
        {
            dataCountPtr = &(lpDevI->dwBENumIndices);
            lpDevI->lpcCurrentPtr = (char*)lpDevI->lpVertexIndices;
            vertexSize = 2;
            offset = lpDevI->dwBENumIndices * 2;
        }
        else
        {
            dataCountPtr = &(lpDevI->dwBENumVertices);
            lpDevI->lpcCurrentPtr = (char*)lpDevI->lpvVertexData;
            vertexSize = lpDevI->position.dwStride;
            offset = lpDevI->dwBENumVertices * lpDevI->position.dwStride;
        }
        switch (lpDevI->primType)
        {
        case D3DPT_LINELIST:
            if (*dataCountPtr & 1)
            {
                MoveData(lpDevI->lpcCurrentPtr, 0, offset - vertexSize,
                         vertexSize);
                *dataCountPtr = 1;
                lpDevI->lpcCurrentPtr += vertexSize;
            } else
                *dataCountPtr = 0;
            break;
        case D3DPT_LINESTRIP:
            MoveData(lpDevI->lpcCurrentPtr, 0, offset - vertexSize, vertexSize);
            *dataCountPtr = 1;
            lpDevI->lpcCurrentPtr += vertexSize;
            break;
        case D3DPT_TRIANGLEFAN:
            MoveData(lpDevI->lpcCurrentPtr, vertexSize, offset - vertexSize,
                     vertexSize);
            *dataCountPtr = 2;
            lpDevI->lpcCurrentPtr += (vertexSize << 1);
            break;
        case D3DPT_TRIANGLESTRIP:
        {
            DWORD size = vertexSize << 1;
            MoveData(lpDevI->lpcCurrentPtr, 0, offset - size, size);
            *dataCountPtr = 2;
            lpDevI->lpcCurrentPtr += size;
            break;
        }
        case D3DPT_POINTLIST:
            *dataCountPtr = 0;
            break;
        case D3DPT_TRIANGLELIST:
        {
            DWORD rem = (*dataCountPtr % 3);
            if ( rem != 0 )
            {
                DWORD size = rem * vertexSize;
                MoveData(lpDevI->lpcCurrentPtr, 0, offset - size, size);
            }
            *dataCountPtr = rem;
            lpDevI->lpcCurrentPtr += rem * vertexSize;
        }
        break;
        default:
            D3D_ERR( "Unknown or unsupported primitive type requested in BeginEnd" );
            ret = D3DERR_INVALIDPRIMITIVETYPE;
        }
    }

    return ret;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CheckBegin"

HRESULT CheckBegin(LPDIRECT3DDEVICEI lpDevI,
                          D3DPRIMITIVETYPE ptPrimitiveType,
                          DWORD dwVertexType,
                          DWORD dwFlags)
{
    lpDevI->dwFlags = 0;
#if DBG
    switch (ptPrimitiveType)
    {
    case D3DPT_POINTLIST:
    case D3DPT_LINELIST:
    case D3DPT_LINESTRIP:
    case D3DPT_TRIANGLELIST:
    case D3DPT_TRIANGLESTRIP:
    case D3DPT_TRIANGLEFAN:
        break;
    default:
        D3D_ERR( "Invalid primitive type given to Begin" );
        return DDERR_INVALIDPARAMS;
    }

    if (dwFlags & __NON_FVF_INPUT)
    {
        switch ((D3DVERTEXTYPE)dwVertexType)
        {
        case D3DVT_TLVERTEX:
        case D3DVT_LVERTEX:
        case D3DVT_VERTEX:
            break;
        default:
            D3D_ERR( "Invalid vertex type given to Begin" );
            return DDERR_INVALIDPARAMS;
        }
        if (!IsDPFlagsValid(dwFlags & ~__NON_FVF_INPUT))
            return DDERR_INVALIDPARAMS;
        lpDevI->dwVIDIn = d3dVertexToFVF[dwVertexType];
        dwFlags &= ~__NON_FVF_INPUT;
    }
    else
    {
        if (ValidateFVF(dwVertexType) != D3D_OK)
            return DDERR_INVALIDPARAMS;
        lpDevI->dwVIDIn = dwVertexType;
    }

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(lpDevI))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

#else
    lpDevI->dwVIDIn = dwVertexType;
#endif
    HRESULT err = CheckDeviceSettings(lpDevI);
    if (err != D3D_OK)
        return err;
    err = CheckVertexBatch(lpDevI);
    if (err != D3D_OK)
        return err;

    // acts as boolean
    lpDevI->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_INBEGIN;
    // indicates first flush
    lpDevI->dwHintFlags &= ~D3DDEVBOOL_HINTFLAGS_INBEGIN_FIRST_FLUSH;
    lpDevI->primType = ptPrimitiveType;
    lpDevI->position.dwStride = GetVertexSizeFVF(lpDevI->dwVIDIn);
    lpDevI->dwBENumVertices = 0;
    ComputeOutputFVF(lpDevI);

    // dwMaxVertexCount should be even to properly break a primitive when
    // flushing
    lpDevI->dwMaxVertexCount = (BEGIN_DATA_BLOCK_MEM_SIZE /
                                lpDevI->position.dwStride) & ~1;
    lpDevI->dwMaxIndexCount = BEGIN_DATA_BLOCK_SIZE * 16;
    lpDevI->dwBENumIndices = 0;
    lpDevI->lpvVertexData = NULL;
    lpDevI->lpVertexIndices = NULL;
    lpDevI->dwFlags |= dwFlags;
    lpDevI->wFlushed = FALSE;
    if (lpDevI->dwVIDIn & D3DFVF_NORMAL)
        lpDevI->dwFlags |= D3DPV_LIGHTING;
    return D3D_OK;
}
//*********************************************************************
//                     API calls
//*********************************************************************
#undef DPF_MODNAME
#define DPF_MODNAME "Begin"

HRESULT D3DAPI
DIRECT3DDEVICEI::Begin(D3DPRIMITIVETYPE ptPrimitiveType,
                       DWORD dwVertexType,
                       DWORD dwFlags)
{
    HRESULT ret;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                            // Release in the destructor

    /*
     * Check/validate parameters, initialize related fields in the device.
     */
    if ((ret = CheckBegin(this, ptPrimitiveType, dwVertexType, dwFlags)) != D3D_OK)
    {
        return ret;
    }
    Profile(PROF_BEGIN,ptPrimitiveType,dwVertexType);
    this->dwBENumIndices = 0xffffffff;    // mark as being in Begin rather
                                        // than BeginIndexed

    lpvVertexData = lpvVertexBatch;
    lpcCurrentPtr = (char*)lpvVertexBatch;

    pfnDoFlushBeginEnd = DoFlushBeginEnd;

    if ( IS_MT_DEVICE(this) )
        EnterCriticalSection(&BeginEndCSect);

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "BeginIndexed"

HRESULT D3DAPI
DIRECT3DDEVICEI::BeginIndexed(D3DPRIMITIVETYPE ptPrimitiveType,
                              DWORD vtVertexType,
                              LPVOID lpvVertices,
                              DWORD dwNumVertices,
                              DWORD dwFlags)
{
    HRESULT ret;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                            // Release in the destructor
#if DBG
    if (ptPrimitiveType == D3DPT_POINTLIST)
    {
        D3D_ERR( "BeginIndexed does not support D3DPT_POINTLIST" );
        return DDERR_INVALIDPARAMS;
    }

    /*
     * validate lpvVertices & dwNumVertices
     */
    if ( dwNumVertices > 65535ul )
    {
        D3D_ERR( "BeginIndexed vertex array > 64K" );
        return DDERR_INVALIDPARAMS;
    }
    if ( dwNumVertices == 0ul )
    {
        D3D_ERR( "Number of vertices for BeginIndexed is zero" );
        return DDERR_INVALIDPARAMS;
    }
    TRY
    {
        if (!VALID_PTR(lpvVertices, sizeof(D3DVERTEX)*dwNumVertices))
        {
            D3D_ERR( "Invalid vertex pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    /*
     * Check/validate parameters, initialize related fields in the device.
     */
    if ((ret = CheckBegin(this, ptPrimitiveType, vtVertexType, dwFlags)) != D3D_OK)
        return ret;
    
    Profile(PROF_BEGININDEXED,ptPrimitiveType,vtVertexType);

    this->dwBENumVertices = dwNumVertices;
    this->lpvVertexData = lpvVertices;
    this->pfnDoFlushBeginEnd = DoFlushBeginIndexedEnd;
    this->lpVertexIndices = this->lpIndexBatch;
    this->lpcCurrentPtr = (char*)this->lpIndexBatch;

    if ( IS_MT_DEVICE(this) )
        EnterCriticalSection(&this->BeginEndCSect);

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Begin(D3DVERTEXTYPE)"

HRESULT D3DAPI
DIRECT3DDEVICEI::Begin(D3DPRIMITIVETYPE ptPrimitiveType,
                       D3DVERTEXTYPE vertexType,
                       DWORD dwFlags)
{
#if DBG
    dwFlags |= __NON_FVF_INPUT;
    return Begin(ptPrimitiveType, (DWORD)vertexType, dwFlags);
#else
    return Begin(ptPrimitiveType, (DWORD)d3dVertexToFVF[vertexType], dwFlags);
#endif
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "BeginIndexed(D3DVERTEXTYPE)"

HRESULT D3DAPI
DIRECT3DDEVICEI::BeginIndexed(D3DPRIMITIVETYPE ptPrimitiveType,
                              D3DVERTEXTYPE  vertexType,
                              LPVOID lpvVertices,
                              DWORD dwNumVertices,
                              DWORD dwFlags)
{
#if DBG
    dwFlags |= __NON_FVF_INPUT;
    return BeginIndexed(ptPrimitiveType, (DWORD) vertexType, lpvVertices,
                        dwNumVertices, dwFlags);
#else
    return BeginIndexed(ptPrimitiveType, (DWORD) d3dVertexToFVF[vertexType], lpvVertices,
                        dwNumVertices, dwFlags);
#endif
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Vertex"

HRESULT D3DAPI
DIRECT3DDEVICEI::Vertex(LPVOID lpVertex)
{
    D3DVERTEX       *dataPtr;
    HRESULT         ret = D3D_OK;
#if DBG
    // validate parms
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer in Vertex" );
            return DDERR_INVALIDOBJECT;
        }
        if (lpVertex == NULL || (! VALID_PTR(lpVertex, 32)) )
        {
            D3D_ERR( "Invalid vertex pointer in Vertex" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in Vertex" );
        CleanupBeginEnd(this);
        return DDERR_INVALIDPARAMS;
    }

    if (!(this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN))
    {
        D3D_ERR( "Vertex call not in Begin" );
        CleanupBeginEnd(this);
        return D3DERR_NOTINBEGIN;
    }
#endif
    // store the data
    if (dwBENumVertices >= dwMaxVertexCount)
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                                // Release in the destructor
        if ((ret = FlushBeginEndBatch(this, FALSE)) != D3D_OK)
        {
            CleanupBeginEnd(this);
            return ret;
        }
    }
    memcpy(lpcCurrentPtr, lpVertex, this->position.dwStride);
    lpcCurrentPtr += this->position.dwStride;
    dwBENumVertices++;

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Index"

HRESULT D3DAPI
DIRECT3DDEVICEI::Index(WORD dwIndex)
{
    WORD    *dataPtr;
    DWORD   *dataCountPtr;
    HRESULT ret = D3D_OK;
#if DBG
    // validate parms
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer in Index" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in Index" );
        CleanupBeginEnd(this);
        return DDERR_INVALIDPARAMS;
    }

    if (!(this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN))
    {
        D3D_ERR( "Index call not in Begin" );
        CleanupBeginEnd(this);
        return D3DERR_NOTINBEGIN;
    }

    // check if data valid
    if (this->dwBENumVertices < dwIndex)
    {
        D3D_ERR( "Invalid index value passed to Index" );
        CleanupBeginEnd(this);
        return DDERR_INVALIDPARAMS;
    }
#endif
    // store the data
    if (dwBENumIndices >= dwMaxIndexCount)
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                                // Release in the destructor
        if ((ret = FlushBeginEndBatch(this, FALSE)) != D3D_OK)
        {
            CleanupBeginEnd(this);
            return ret;
        }
    }
    *(WORD*)lpcCurrentPtr = dwIndex;
    dwBENumIndices++;
    lpcCurrentPtr += 2;

    return D3D_OK;
}   // end of D3DDev2_Index()
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "End"

HRESULT D3DAPI
DIRECT3DDEVICEI::End(DWORD dwFlags)
{
    HRESULT ret;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                            // Release in the destructor
#if DBG
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if ( !(this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN))
    {
        D3D_ERR( "End not in Begin/BeginIndex" );
        return D3DERR_NOTINBEGIN;
    }
#endif
    if ( IS_MT_DEVICE(this) )
        LeaveCriticalSection(&this->BeginEndCSect);

    /*
     * Draw the primitives
     */
    ret = FlushBeginEndBatch(this, TRUE);

    if (IS_DP2HAL_DEVICE(this) && 
        this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN_BIG_PRIM)
    {
        CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
        ret = dev->EndPrim(this->dwNumVertices * this->dwOutputSize);
    }
    CleanupBeginEnd(this);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\d3dcreat.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3di.h
 *  Content:    Direct3D HAL include file
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   09/11/95   stevela Initial rev with this header.
 *   07/12/95   stevela Merged Colin's changes.
 *   10/12/95   stevela Removed AGGREGATE_D3D.
 *                      Validate args.
 *   17/04/96   colinmc Bug 17008: DirectDraw/Direct3D deadlock
 *   29/04/96   colinmc Bug 19954: Must query for Direct3D before texture
 *                      or device
 *   27/08/96   stevela Ifdefed out definition of ghEvent as we're using
 *                      DirectDraw's critical section.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Create an api for the Direct3D object
 */

// Remove DDraw's type unsafe definition and replace with our C++ friendly def
#ifdef VALIDEX_CODE_PTR
#undef VALIDEX_CODE_PTR
#endif
#define VALIDEX_CODE_PTR( ptr ) \
(!IsBadCodePtr( (FARPROC) ptr ) )

LPCRITICAL_SECTION      lpD3DCSect;

#if DBG
    int     iD3DCSCnt;
#endif

HRESULT D3DAPI DIRECT3DI::Initialize(REFCLSID riid)
{
    return DDERR_ALREADYINITIALIZED;
}
//---------------------------------------------------------------------
// for use by fns that take a GUID param before device is created
BOOL IsValidD3DDeviceGuid(REFCLSID riid) {

    if (IsBadReadPtr(&riid, sizeof(CLSID))) {
        return FALSE;
    }
    if( IsEqualIID(riid, IID_IDirect3DRampDevice) ||
        IsEqualIID(riid, IID_IDirect3DRGBDevice)  ||
        IsEqualIID(riid, IID_IDirect3DMMXDevice)  ||
        IsEqualIID(riid, IID_IDirect3DHALDevice)  ||
        IsEqualIID(riid, IID_IDirect3DRefDevice)  ||
        IsEqualIID(riid, IID_IDirect3DNullDevice) ||
        IsEqualIID(riid, IID_IDirect3DNewRGBDevice)) {
       return TRUE;
    } else {
        return FALSE;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DCreate"

DIRECT3DI::DIRECT3DI(IUnknown* pUnkOuter, LPDDRAWI_DIRECTDRAW_INT pDDrawInt)
{
    // HACK.  D3D needs a DD1 DDRAWI interface because it uses CreateSurface1 internally
    // for exebufs, among other things.  Because pDDrawInt could be any DDRAWI type,
    // we need to QI to find a DD1 interface.  But the D3DI object cannot keep a reference
    // to its parent DD object because it is aggegrated with the DD obj, so that would constitute
    // a circular reference that would prevent deletion. So we QI for DD1 interface, copy it into D3DI
    // and release it, then point lpDD at the copy. (disgusting)

    // another HACK alert: dont know which DDRAWI type pDDrawInt is, but a cast to LPDIRECTDRAW should
    // work because QI is in the same place in all the DDRAWI vtables and is the same fn for all
    HRESULT ret;

    ret = ((LPDIRECTDRAW)pDDrawInt)->QueryInterface(IID_IDirectDraw, (LPVOID*)&lpDD);
    if(FAILED(ret)) {
      lpDD=NULL;  //signal failure
      D3D_ERR( "QueryInterface for IDDraw failed" );
      return;
    }
    memcpy(&DDInt_DD1,lpDD,sizeof(DDInt_DD1));
    lpDD->Release();
    lpDD=(LPDIRECTDRAW)&DDInt_DD1;

    ret = ((LPDIRECTDRAW)pDDrawInt)->QueryInterface(IID_IDirectDraw4, (LPVOID*)&lpDD4);
    if(FAILED(ret))
    {
        lpDD4=NULL;  //signal failure
        D3D_WARN(1,"QueryInterface for IDDraw4 failed" );
    }
    else
    {
        memcpy(&DDInt_DD4,lpDD4,sizeof(DDInt_DD4));
        lpDD4->Release();
        lpDD4=(LPDIRECTDRAW4)&DDInt_DD4;
        D3D_INFO(4,"QueryInterface for IDDraw4 succeeded" );
    }

    numDevs =
        numViewports =
        numLights =
        numMaterials = 0;
    mD3DUnk.pD3DI = this;
    mD3DUnk.refCnt = 1;


    LIST_INITIALIZE(&devices);
    LIST_INITIALIZE(&viewports);
    LIST_INITIALIZE(&lights);
    LIST_INITIALIZE(&materials);

    v_next = 1;
    lpFreeList=NULL;    /* nothing is allocated initially */
    lpBufferList=NULL;
    lpTextureManager=new TextureCacheManager(this);


    /*
     * Are we really being aggregated?
     */
    if (pUnkOuter != NULL)
    {
        /*
         * Yup - we are being aggregated. Store the supplied
         * IUnknown so we can punt to that.
         * NOTE: We explicitly DO NOT AddRef here.
         */
        this->lpOwningIUnknown = pUnkOuter;
        /*
         * Store away the interface pointer
         */
    }
    else
    {
        /*
         * Nope - but we pretend we are anyway by storing our
         * own IUnknown as the parent IUnknown. This makes the
         * code much neater.
         */
        this->lpOwningIUnknown = static_cast<LPUNKNOWN>(&this->mD3DUnk);
    }
}



extern "C" HRESULT WINAPI Direct3DCreate(LPCRITICAL_SECTION lpDDCSect,
                                         LPUNKNOWN*         lplpDirect3D,
                                         IUnknown*          pUnkOuter)
{
    LPDIRECT3DI pd3d;

    DPFINIT();

    /*
     * No need to validate params as DirectDraw is giving them to us.
     */

    /*
     * Is another thread coming in and is this the first time?
     */

    /*
     * We can let every invocation of this function assign
     * the critical section as we know its always going to
     * be the same value (for a D3D session).
     */
    lpD3DCSect = lpDDCSect;
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    *lplpDirect3D = NULL;

    // We do not support non aggregated Direct3D object yet
    if (!pUnkOuter)
        return DDERR_INVALIDPARAMS;

    if (!(pd3d = static_cast<LPDIRECT3DI>(new DIRECT3DI(pUnkOuter, (LPDDRAWI_DIRECTDRAW_INT)pUnkOuter))))
    {
        return (DDERR_OUTOFMEMORY);
    }

    if(pd3d->lpDD==NULL) {  //QI failed
       delete pd3d;
       return E_NOINTERFACE;
    }

    /*
     * NOTE: The special IUnknown is returned and not the actual
     * Direct3D interface so you can't use this to drive Direct3D.
     * You must query off this interface for the Direct3D interface.
     */
    *lplpDirect3D = static_cast<LPUNKNOWN>(&(pd3d->mD3DUnk));

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::EnumDevices"

extern BOOL isMMXprocessor(void);

typedef struct _D3DI_DeviceType {
    CONST GUID *pGuid;
    char name[256];
    char description[512];
} D3DI_DeviceType;

// Static definitions for various enumerable devices
static D3DI_DeviceType RampDevice =
{
    &IID_IDirect3DRampDevice, "Ramp Emulation",
    "Microsoft Direct3D Mono(Ramp) Software Emulation"
};
static D3DI_DeviceType RGBDevice =
{
    &IID_IDirect3DRGBDevice, "RGB Emulation",
    "Microsoft Direct3D RGB Software Emulation"
};
static D3DI_DeviceType HALDevice =
{
    &IID_IDirect3DHALDevice, "Direct3D HAL",
    "Microsoft Direct3D Hardware acceleration through Direct3D HAL"
};
static D3DI_DeviceType MMXDevice =
{
    &IID_IDirect3DMMXDevice, "MMX Emulation",
    "Microsoft Direct3D MMX Software Emulation"
};
static D3DI_DeviceType RefDevice =
{
    &IID_IDirect3DRefDevice, "Reference Rasterizer",
    "Microsoft Reference Rasterizer"
};
static D3DI_DeviceType NullDevice =
{
    &IID_IDirect3DNullDevice, "Null device",
    "Microsoft Null Device"
};

static D3DI_DeviceType *AllDevices[] =
{
    &RampDevice, &RGBDevice, &HALDevice, &MMXDevice, &RefDevice, &NullDevice, NULL
};

HRESULT
DIRECT3DI::EnumDevices(LPD3DENUMDEVICESCALLBACK lpEnumCallback,
                       LPVOID lpContext, DWORD dwSize, DWORD dwVer)
{
    HRESULT err, userRet;
    HKEY hKey;
    LONG result;
    int i;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALIDEX_CODE_PTR((FARPROC)lpEnumCallback)) {
            D3D_ERR( "Invalid callback pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    BOOL bSoftwareOnly = FALSE;
    DWORD dwEnumReference = 0;
    BOOL bEnumNullDevice = FALSE;
    BOOL bEnumSeparateMMX = FALSE;

    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RESPATH, 0, KEY_READ, &hKey);
    if (result == ERROR_SUCCESS)
    {
        DWORD dwData, dwType;
        DWORD dwDataSize;

        // Enumerate software rasterizers only ?
        dwDataSize = sizeof(dwData);
        result = RegQueryValueEx(hKey, "SoftwareOnly", NULL,
                                 &dwType, (BYTE *) &dwData, &dwDataSize);
        if ( result == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            bSoftwareOnly = ( dwData != 0 );
        }

        // Enumerate Reference Rasterizer ?
        dwDataSize = sizeof(dwData);
        result = RegQueryValueEx(hKey, "EnumReference", NULL,
                                 &dwType, (BYTE *)&dwData, &dwDataSize);
        if (result == ERROR_SUCCESS &&
            dwType == REG_DWORD &&
            dwDataSize == sizeof(dwData))
        {
            dwEnumReference = dwData;
        }

        if (dwVer >= 3)
        {
            // Enumerate MMX Rasterizer separately for DX6?
            dwDataSize = sizeof(dwData);
            result = RegQueryValueEx(hKey, "EnumSeparateMMX", NULL,
                                     &dwType, (BYTE *)&dwData, &dwDataSize);
            if (result == ERROR_SUCCESS &&
                dwType == REG_DWORD &&
                dwDataSize == sizeof(dwData))
            {
                bEnumSeparateMMX = (BOOL)dwData;
            }
        }
        else
        {
            // Enumerate MMX Rasterizer separately for DX5
            // MMX is not enumerated for DX3 and older later
            bEnumSeparateMMX = TRUE;
        }

        // Enumerate Null Device ?
        dwDataSize = sizeof(dwData);
        result = RegQueryValueEx(hKey, "EnumNullDevice", NULL,
                                 &dwType, (BYTE *)&dwData, &dwDataSize);
        if (result == ERROR_SUCCESS &&
            dwType == REG_DWORD &&
            dwDataSize == sizeof(dwData))
        {
            bEnumNullDevice = (BOOL)dwData;
        }


        RegCloseKey( hKey );
    }

    D3DI_DeviceType **lpDevices = AllDevices;

    userRet = D3DENUMRET_OK;
    for (i = 0; lpDevices[i] && userRet == D3DENUMRET_OK; i++)
    {
        LPSTR drvName = lpDevices[i]->name;
        LPSTR drvDesc = lpDevices[i]->description;
        REFCLSID riid = *lpDevices[i]->pGuid;
        D3DDEVICEDESC HWDesc;
        D3DDEVICEDESC HELDesc;
        LPDDRAWI_DIRECTDRAW_GBL lpDDGbl;
        IHalProvider *pHalProv;
        HINSTANCE hDll;

        if ( (dwVer < 2 || !isMMXprocessor()) &&
             IsEqualIID(riid, IID_IDirect3DMMXDevice ) )
        {
            // Not Device2, not on MMX machine, or DisableMMX is set.
            // Don't enumerate the MMX device.
            continue;
        }

        if ( !bEnumSeparateMMX &&
             IsEqualIID(riid, IID_IDirect3DMMXDevice ) )
        {
            // Not enumerating MMX separate from RGB.
            continue;
        }

        if ( IsEqualIID(riid, IID_IDirect3DRefDevice) &&
             !(dwEnumReference == 1) &&                     // enumerate for all devices if value == 1
             !( (dwVer >= 3) && (dwEnumReference == 2) ) )  // enumerate for Device3+ if value == 2
        {
            // Not enumerating the reference.
            continue;
        }

        if (!bEnumNullDevice &&
            IsEqualIID(riid, IID_IDirect3DNullDevice))
        {
            // Not enumerating the Null device.
            continue;
        }

#ifndef _X86_
        if (IsEqualIID(riid, IID_IDirect3DRampDevice))
        {
            // Not enumerating ramp for non-x86 (alpha) platforms.
            continue;
        }
#endif

        if((dwVer>=3) && IsEqualIID(riid, IID_IDirect3DRampDevice)) {
            // Ramp not available in Device3.  No more old-style texture handles.
            continue;
        }

        // By COM definition, our owning IUnknown is a pointer to the
        // DirectDraw object that was used to create us.
        // Check this for the existence of a Direct3D HAL.
        lpDDGbl = ((LPDDRAWI_DIRECTDRAW_INT)this->lpDD)->lpLcl->lpGbl;

        // See if this is a software driver.
        err = GetSwHalProvider(riid, &pHalProv, &hDll);
        if (err == S_OK)
        {
            // Successfully got a software driver.
        }
        else if (err == E_NOINTERFACE &&
                 ! bSoftwareOnly &&
                 GetHwHalProvider(riid, &pHalProv, &hDll, lpDDGbl) == S_OK)
        {
            // Successfully got a hardware driver.
        }
        else
        {
            // Unrecognized driver.
            continue;
        }

        err = pHalProv->GetCaps(lpDDGbl, &HWDesc, &HELDesc, dwVer);

        pHalProv->Release();
        if (hDll != NULL)
        {
            FreeLibrary(hDll);
        }

        if (err != S_OK)
        {
            continue;
        }

        HWDesc.dwSize = dwSize;
        HELDesc.dwSize = dwSize;

        userRet = (*lpEnumCallback)((GUID *) lpDevices[i]->pGuid, drvDesc, drvName,
                                    &HWDesc, &HELDesc, lpContext);
    }

    return D3D_OK;
}

HRESULT D3DAPI CDirect3D::EnumDevices(LPD3DENUMDEVICESCALLBACK lpEnumCallback,
                                      LPVOID lpContext)
{
    return EnumDevices(lpEnumCallback, lpContext, D3DDEVICEDESCSIZE_V1, 1);
}

HRESULT D3DAPI CDirect3D2::EnumDevices(LPD3DENUMDEVICESCALLBACK lpEnumCallback,
                                       LPVOID lpContext)
{
    return EnumDevices(lpEnumCallback, lpContext, D3DDEVICEDESCSIZE_V2, 2);
}

HRESULT D3DAPI CDirect3D3::EnumDevices(LPD3DENUMDEVICESCALLBACK lpEnumCallback,
                                       LPVOID lpContext)
{
    return EnumDevices(lpEnumCallback, lpContext, D3DDEVICEDESCSIZE, 3);
}

#define MATCH(cap)      ((matchCaps->cap & primCaps->cap) == matchCaps->cap)

static BOOL MatchCaps(DWORD dwFlags,
                      LPD3DPRIMCAPS matchCaps,
                      LPD3DPRIMCAPS primCaps)
{
    if (dwFlags & D3DFDS_MISCCAPS) {
        if (!MATCH(dwMiscCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_RASTERCAPS) {
        if (!MATCH(dwRasterCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_ZCMPCAPS) {
        if (!MATCH(dwZCmpCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_ALPHACMPCAPS) {
        if (!MATCH(dwAlphaCmpCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_SRCBLENDCAPS) {
        if (!MATCH(dwSrcBlendCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_DSTBLENDCAPS) {
        if (!MATCH(dwDestBlendCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_SHADECAPS) {
        if (!MATCH(dwShadeCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_TEXTURECAPS) {
        if (!MATCH(dwTextureCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_TEXTUREFILTERCAPS) {
        if (!MATCH(dwTextureFilterCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_TEXTUREBLENDCAPS) {
        if (!MATCH(dwTextureBlendCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_TEXTUREADDRESSCAPS) {
        if (!MATCH(dwTextureAddressCaps))
            return FALSE;
    }
    return TRUE;
}

#undef MATCH

typedef struct _enumArgs {
    D3DFINDDEVICESEARCH search;

    int                 foundHardware;
    int                 foundSoftware;
    D3DFINDDEVICERESULT result;
} enumArgs;

HRESULT WINAPI enumFunc(LPGUID lpGuid,
                        LPSTR lpDeviceDescription,
                        LPSTR lpDeviceName,
                        LPD3DDEVICEDESC lpHWDesc,
                        LPD3DDEVICEDESC lpHELDesc,
                        LPVOID lpContext)
{
    enumArgs* lpArgs = (enumArgs*)lpContext;
    BOOL bHardware = (lpHWDesc->dcmColorModel != 0);

    if (lpArgs->search.dwFlags & D3DFDS_GUID) {
        if (!IsEqualGUID(lpArgs->search.guid, *lpGuid))
            return D3DENUMRET_OK;
    }

    if (lpArgs->search.dwFlags & D3DFDS_HARDWARE) {
        if (lpArgs->search.bHardware != bHardware)
            return D3DENUMRET_OK;
    }

    if (lpArgs->search.dwFlags & D3DFDS_COLORMODEL) {
        if ((lpHWDesc->dcmColorModel & lpArgs->search.dcmColorModel) == 0
            && (lpHELDesc->dcmColorModel & lpArgs->search.dcmColorModel) == 0) {
            return D3DENUMRET_OK;
        }
    }

    if (lpArgs->search.dwFlags & D3DFDS_TRIANGLES) {
        if (!MatchCaps(lpArgs->search.dwFlags,
                       &lpArgs->search.dpcPrimCaps, &lpHWDesc->dpcTriCaps)
            && !MatchCaps(lpArgs->search.dwFlags,
                          &lpArgs->search.dpcPrimCaps, &lpHELDesc->dpcTriCaps))
            return D3DENUMRET_OK;
    }

    if (lpArgs->search.dwFlags & D3DFDS_LINES) {
        if (!MatchCaps(lpArgs->search.dwFlags,
                       &lpArgs->search.dpcPrimCaps, &lpHWDesc->dpcLineCaps)
            && !MatchCaps(lpArgs->search.dwFlags,
                          &lpArgs->search.dpcPrimCaps, &lpHELDesc->dpcLineCaps))
            return D3DENUMRET_OK;
    }

    if (lpArgs->foundHardware && !bHardware)
        return D3DENUMRET_OK;

    if (bHardware)
        lpArgs->foundHardware = TRUE;
    else
        lpArgs->foundSoftware = TRUE;

    lpArgs->result.guid = *lpGuid;

    lpArgs->result.ddHwDesc = *lpHWDesc;
    lpArgs->result.ddSwDesc = *lpHELDesc;

    return D3DENUMRET_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::FindDevice"


HRESULT D3DAPI CDirect3D::FindDevice(LPD3DFINDDEVICESEARCH lpSearch, LPD3DFINDDEVICERESULT lpResult)
{
    return FindDevice(lpSearch,lpResult,1);
}

HRESULT D3DAPI CDirect3D2::FindDevice(LPD3DFINDDEVICESEARCH lpSearch, LPD3DFINDDEVICERESULT lpResult)
{
    return FindDevice(lpSearch,lpResult,2);
}

HRESULT D3DAPI CDirect3D3::FindDevice(LPD3DFINDDEVICESEARCH lpSearch, LPD3DFINDDEVICERESULT lpResult)
{
    return FindDevice(lpSearch,lpResult,3);
}

HRESULT
DIRECT3DI::FindDevice(LPD3DFINDDEVICESEARCH lpSearch,
                      LPD3DFINDDEVICERESULT lpResult, DWORD dwVer)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    TRY
    {
        if (!VALID_D3DFINDDEVICESEARCH_PTR(lpSearch)) {
            D3D_ERR( "Invalid search pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_D3DFINDDEVICERESULT_PTR(lpResult)) {
            D3D_ERR( "Invalid result pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    enumArgs args;
    memset(&args, 0, sizeof args);
    args.result.dwSize = sizeof(args.result);
    args.search = *lpSearch;

    switch(dwVer) {
        case 1: CDirect3D::EnumDevices(enumFunc, &args);  break;
        case 2: CDirect3D2::EnumDevices(enumFunc, &args);  break;
        case 3: CDirect3D3::EnumDevices(enumFunc, &args);  break;
    }

    if (args.foundHardware || args.foundSoftware) {
        DWORD dwSize = lpResult->dwSize;
        if (dwSize == sizeof( D3DFINDDEVICERESULT ) )
        {
            // The app is using DX6
            D3D_INFO(4, "New D3DFINDDEVICERESULT size");
            memcpy(lpResult, &args.result, lpResult->dwSize);
        }
        else
        {
            // The app is pre DX6
            DWORD dwSize = lpResult->dwSize;
            DWORD dDescSize = (dwSize - (sizeof(DWORD) + sizeof(GUID)))/2;
            D3D_INFO(4, "Old D3DFINDDEVICERESULT size");

            // Copy the header
            memcpy(lpResult, &args.result, sizeof(DWORD)+sizeof(GUID));

            //restore the size
            lpResult->dwSize = dwSize;

            // Copy and convert the embedded D3DDEVICEDESC's
            // DDescSize = (lpResult->dwSize - (sizeof(DWORD) + sizeof(GUID)))/2
            // This calculation assumes that the structure of
            // LPD3DFINDDEVICERESULT is the same as in DX6, DX5, if it is changed
            // This computation needs to be updated

            memcpy((LPVOID) (&lpResult->ddHwDesc),
                   &args.result.ddHwDesc,
                   dDescSize);
            memcpy((LPVOID) ((ULONG_PTR)&lpResult->ddHwDesc + dDescSize),
                   &args.result.ddSwDesc,
                   dDescSize);

        }
        return D3D_OK;
    }
    else
    {
        return DDERR_NOTFOUND;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DI::EnumZBufferFormats"

HRESULT D3DAPI DIRECT3DI::EnumZBufferFormats(REFCLSID riid,
                                             LPD3DENUMPIXELFORMATSCALLBACK lpEnumCallback,
                                             LPVOID lpContext)
{
    HRESULT ret, userRet;
    LPDDPIXELFORMAT lpTmpPixFmts;
    DWORD i,cPixFmts;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    ret = D3D_OK;

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3D3_PTR(this)) {
            D3D_ERR( "Invalid Direct3D3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALIDEX_CODE_PTR(lpEnumCallback)) {
            D3D_ERR( "Invalid callback pointer" );
            return DDERR_INVALIDPARAMS;
        }

        if(!IsValidD3DDeviceGuid(riid)) {
            D3D_ERR( "Invalid D3D Device GUID" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if(IsEqualIID(riid, IID_IDirect3DHALDevice)) {
        LPDDRAWI_DIRECTDRAW_GBL pDdGbl=((LPDDRAWI_DIRECTDRAW_INT)this->lpDD)->lpLcl->lpGbl;
        LPD3DHAL_GLOBALDRIVERDATA lpD3DHALGlobalDriverData=pDdGbl->lpD3DGlobalDriverData;
        DWORD dwHW_ZBitDepthFlags;
        if (NULL == lpD3DHALGlobalDriverData)
        {
            D3D_ERR("No HAL Support ZBufferBitDepths!");
            return (DDERR_NOZBUFFERHW);
        }
        cPixFmts=pDdGbl->dwNumZPixelFormats;
        if (cPixFmts==0) {
            // driver is pre-dx6, so it doesn't support stencil buffer pix fmts or this callback.
            // we can fake support using DD_BD bits in dwZBufferBitDepth in D3DDEVICEDESC
            D3D_WARN(6,"EnumZBufferFormats not supported directly by driver, faking it using dwDeviceZBufferBitDepth DD_BD bits");

            dwHW_ZBitDepthFlags=lpD3DHALGlobalDriverData->hwCaps.dwDeviceZBufferBitDepth;

            if(!(dwHW_ZBitDepthFlags & (DDBD_8|DDBD_16|DDBD_24|DDBD_32))) {
                    D3D_ERR("No Supported ZBufferBitDepths!");
                    return (DDERR_NOZBUFFERHW);
            }

            // malloc space for 4 DDPIXELFORMATs, since that the most there could be (DDBD_8,16,24,32)
            if (D3DMalloc((void**)&lpTmpPixFmts, 4*sizeof(DDPIXELFORMAT)) != D3D_OK) {
                    D3D_ERR("failed to alloc space for return descriptions");
                    return (DDERR_OUTOFMEMORY);
            }

            DWORD zdepthflags[4]= {DDBD_8,DDBD_16,DDBD_24,DDBD_32};
            DWORD zbitdepths[4]= {8,16,24,32};
            DWORD zbitmasks[4]= {0xff,0xffff,0xffffff,0xffffffff};

            memset(lpTmpPixFmts,0,sizeof(4*sizeof(DDPIXELFORMAT)));

            // create some DDPIXELFORMATs the app can look at
            for(i=0;i<4;i++) {
                if(dwHW_ZBitDepthFlags & zdepthflags[i]) {
                    lpTmpPixFmts[cPixFmts].dwSize=sizeof(DDPIXELFORMAT);
                    lpTmpPixFmts[cPixFmts].dwFlags=DDPF_ZBUFFER;
                    lpTmpPixFmts[cPixFmts].dwZBufferBitDepth=zbitdepths[i];
                    lpTmpPixFmts[cPixFmts].dwZBitMask= zbitmasks[i];
                    cPixFmts++;
                }
            }
        } else {
            // only show the app a temp copy of DDraw's real records

            if (D3DMalloc((void**)&lpTmpPixFmts, cPixFmts*sizeof(DDPIXELFORMAT)) != D3D_OK) {
                D3D_ERR("Out of memory allocating space for return descriptions");
                return (DDERR_OUTOFMEMORY);
            }
            memcpy(lpTmpPixFmts, pDdGbl->lpZPixelFormats, cPixFmts*sizeof(DDPIXELFORMAT));
        }
    } else {
        // Handle SW rasterizers
        DDPIXELFORMAT  *pDDPF;

        // malloc space for 10 DDPIXELFORMAT's, which is currently more than enough for the SW rasterizers
        if (D3DMalloc((void**)&lpTmpPixFmts, 10*sizeof(DDPIXELFORMAT)) != D3D_OK) {
                D3D_ERR("Out of memory allocating space for return descriptions");
                return (DDERR_OUTOFMEMORY);
        }

        cPixFmts=GetSwZBufferFormats(riid,&pDDPF);
        memcpy(lpTmpPixFmts, pDDPF, cPixFmts*sizeof(DDPIXELFORMAT));
    }

    userRet = D3DENUMRET_OK;
    for (i = 0; (i < cPixFmts) && (userRet == D3DENUMRET_OK); i++) {
        userRet = (*lpEnumCallback)(&lpTmpPixFmts[i], lpContext);
    }

    D3DFree(lpTmpPixFmts);

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::EnumOptTextureFormats"

HRESULT D3DAPI DIRECT3DI::EnumOptTextureFormats(REFCLSID riid, LPD3DENUMOPTTEXTUREFORMATSCALLBACK lpEnumCallback, LPVOID lpContext)
{
    HRESULT ret, userRet;
    LPDDSURFACEDESC lpDescs;
    LPDDSURFACEDESC2 lpRetDescs;
    LPDDOPTSURFACEDESC lpRetOptDescs;
    LPD3DHAL_GLOBALDRIVERDATA lpD3DHALGlobalDriverData;
    DWORD num_descs;
    DWORD i;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    ret = D3D_OK;
    //
    // Validation
    //

    TRY
    {
        if (!VALID_DIRECT3D3_PTR(this)) {
            D3D_ERR( "Invalid Direct3D pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALIDEX_CODE_PTR(lpEnumCallback)) {
            D3D_ERR( "Invalid callback pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if(!IsValidD3DDeviceGuid(riid)) {
            D3D_ERR( "Invalid D3D Device GUID" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if(IsEqualIID(riid, IID_IDirect3DHALDevice)) {

        lpD3DHALGlobalDriverData=((LPDDRAWI_DIRECTDRAW_INT)this->lpDD)->lpLcl->lpGbl->lpD3DGlobalDriverData;

        num_descs = lpD3DHALGlobalDriverData->dwNumTextureFormats;
        lpDescs = lpD3DHALGlobalDriverData->lpTextureFormats;
    } else {
        num_descs = GetSwTextureFormats(riid,&lpDescs,3/*enum for Device3*/);
    }

    if (!num_descs)
    {
        D3D_ERR("no texture formats supported");
        return (D3DERR_TEXTURE_NO_SUPPORT);
    }

    //
    // Make a local copy of these formats
    //
    if (D3DMalloc((void**)&lpRetDescs, sizeof(DDSURFACEDESC2) * num_descs)
        != D3D_OK)
    {
        D3D_ERR("Out of memory allocating space for return descriptions");
        return (DDERR_OUTOFMEMORY);
    }
    for (i=0; i<num_descs; i++)
    {
        // We can copy only the subset of the data
        memcpy(&lpRetDescs[i], &lpDescs[i], sizeof(DDSURFACEDESC));
    }
    userRet = D3DENUMRET_OK;

    //
    // First return the unoptimized formats......
    //
    for (i = 0; i < num_descs && userRet == D3DENUMRET_OK; i++)
    {
        userRet = (*lpEnumCallback)(&lpRetDescs[i], NULL, lpContext);
    }

    //
    // ......Now return the formats capable of being optimized
    //
    for (i = 0; i < num_descs && userRet == D3DENUMRET_OK; i++)
    {
        userRet = (*lpEnumCallback)(&lpRetDescs[i], NULL, lpContext);
    }

    D3DFree(lpRetDescs);

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3D::EvictManagedTextures"
HRESULT D3DAPI
DIRECT3DI::EvictManagedTextures()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    if (!VALID_DIRECT3D_PTR(this))
    {
        D3D_ERR( "Invalid Direct3D3 pointer" );
        return DDERR_INVALIDOBJECT;
    }
    lpTextureManager->EvictTextures();
    return  D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3D::FlushDevicesExcept"

HRESULT DIRECT3DI::FlushDevicesExcept(LPDIRECT3DDEVICEI pDev)
{
    LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&this->devices);
    while (lpDevI)
    {
        if(lpDevI != pDev)
        {
            HRESULT hr = lpDevI->FlushStates();
            if(hr != D3D_OK)
            {
                DPF_ERR("Error flushing device in FlushDevicesExcept");
                return hr;
            }
        }
        lpDevI = LIST_NEXT(lpDevI,list);
    }
    return D3D_OK;
}

extern "C" void WINAPI PaletteUpdateNotify(
    LPVOID pD3DIUnknown,
    DWORD dwPaletteHandle,
    DWORD dwStartIndex,
    DWORD dwNumberOfIndices,
    LPPALETTEENTRY pFirstIndex)
{
    LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(pD3DIUnknown)->pD3DI;
    DDASSERT(lpD3D);
    LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&lpD3D->devices);
    while (lpDevI)
    {
        D3D_INFO(4,"PaletteUpdateNotify lpDevI(%x) %08lx %08lx %08lx %08lx",
            lpDevI,dwPaletteHandle,dwStartIndex,dwNumberOfIndices,*(DWORD*)&pFirstIndex[10]);
        if (IS_DX7HAL_DEVICE(lpDevI))
        {
            if(lpD3D->numDevs > 1)
                lpD3D->FlushDevicesExcept(lpDevI);
            static_cast<CDirect3DDeviceIDP2*>(lpDevI)->UpdatePalette(dwPaletteHandle,dwStartIndex,dwNumberOfIndices,pFirstIndex);
            if(lpD3D->numDevs > 1)
                lpDevI->FlushStates();
            break;
        }
        lpDevI = LIST_NEXT(lpDevI,list);
    }
}

extern "C" void WINAPI PaletteAssociateNotify(
    LPVOID pD3DIUnknown,
    DWORD dwPaletteHandle,
    DWORD dwPaletteFlags,
    DWORD dwSurfaceHandle )
{
    LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(pD3DIUnknown)->pD3DI;
    DDASSERT(lpD3D);
    LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&lpD3D->devices);
    while (lpDevI)
    {
        D3D_INFO(4,"PaletteAssociateNotify lpDevI(%x) %08lx %08lx",
            lpDevI,dwPaletteHandle, dwSurfaceHandle);
        if (IS_DX7HAL_DEVICE(lpDevI))
        {
            if(lpD3D->numDevs > 1)
                lpD3D->FlushDevicesExcept(lpDevI);
            static_cast<CDirect3DDeviceIDP2*>(lpDevI)->SetPalette(dwPaletteHandle,dwPaletteFlags,dwSurfaceHandle);
            if(lpD3D->numDevs > 1)
                lpDevI->FlushStates();
            break;
        }
        lpDevI = LIST_NEXT(lpDevI,list);
    }
}

extern "C" void WINAPI SurfaceFlipNotify(LPVOID pD3DIUnknown)
{
    LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(pD3DIUnknown)->pD3DI;
    DDASSERT(lpD3D);
    LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&lpD3D->devices);
    D3D_INFO(4,"SurfaceFlipNotify");
    while (lpDevI)
    {
        if (IS_DX7HAL_DEVICE(lpDevI))
        {
#ifndef WIN95
            if(lpDevI->hSurfaceTarget != ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface)
            {
                static_cast<CDirect3DDeviceIDP2*>(lpDevI)->SetRenderTargetI(lpDevI->lpDDSTarget,lpDevI->lpDDSZBuffer);
                lpDevI->hSurfaceTarget=((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface;
            }
#else
            if(lpDevI->hSurfaceTarget != ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->lpSurfMore->dwSurfaceHandle)
            {
                static_cast<CDirect3DDeviceIDP2*>(lpDevI)->SetRenderTargetI(lpDevI->lpDDSTarget,lpDevI->lpDDSZBuffer);
                lpDevI->hSurfaceTarget=((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->lpSurfMore->dwSurfaceHandle;
            }
#endif
        }
        lpDevI = LIST_NEXT(lpDevI,list);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "FlushD3DDevices"

extern "C" HRESULT WINAPI FlushD3DDevices(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl)
{
    LPD3DBUCKET list = reinterpret_cast<LPD3DBUCKET>(surf_lcl->lpSurfMore->lpD3DDevIList);
    while(list)
    {
        LPD3DBUCKET temp = list->next;
        reinterpret_cast<LPDIRECT3DDEVICEI>(list->lpD3DDevI)->FlushStates();
        list = temp;
    }
    return DD_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FlushD3DDevices2"

extern "C" HRESULT WINAPI FlushD3DDevices2(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl)
{
    LPD3DBUCKET list = reinterpret_cast<LPD3DBUCKET>(surf_lcl->lpSurfMore->lpD3DDevIList);
    while(list)
    {
        LPD3DBUCKET temp = list->next;
        if (list->lplpDDSZBuffer)   
            *list->lplpDDSZBuffer = 0; // detached
        reinterpret_cast<LPDIRECT3DDEVICEI>(list->lpD3DDevI)->FlushStates();
        list = temp;
    }
    return DD_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\d3dmem.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3dmem.c
 *  Content:    Direct3D mem allocation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10/12/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

static D3DMALLOCFUNCTION malloc_function = (D3DMALLOCFUNCTION) MemAlloc;
static D3DREALLOCFUNCTION realloc_function = (D3DREALLOCFUNCTION) MemReAlloc;
static D3DFREEFUNCTION free_function = MemFree;

#undef DPF_MODNAME
#define DPF_MODNAME "D3DMalloc"

HRESULT D3DAPI D3DMalloc(LPVOID* p_return, size_t size)
{
    void* p;

    if (!VALID_OUTPTR(p_return)) {
        D3D_ERR("Bad pointer given");
        return DDERR_OUTOFMEMORY;
    }
    if (size > 0) {
        p = malloc_function(size);
        if (p == NULL)
            return (DDERR_OUTOFMEMORY);
    } else {
        p = NULL;
    }
    *p_return = p;
    
    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DRealloc"

HRESULT D3DAPI D3DRealloc(LPVOID* p_inout, size_t size)
{
    void* p = *p_inout;
    HRESULT err = D3D_OK;

    if (!VALID_OUTPTR(p_inout)) 
    {
        D3D_ERR("Bad pointer given");
        return DDERR_OUTOFMEMORY;
    }
    if (size > 0) 
    {
        if (p) 
        {
            p = realloc_function(p, size);
            if (p == NULL)
                return (DDERR_OUTOFMEMORY);
        } 
        else
            return D3DMalloc(p_inout, size);
    } 
    else 
    if (size == 0) 
    {
        D3DFree(p);
        p = NULL;
    } 
    else
        return (DDERR_INVALIDPARAMS);
    *p_inout = p;
    return (err);
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DFree"

VOID D3DAPI D3DFree(LPVOID p)
{
    if (p == NULL) return;

    if (!VALID_DWORD_PTR(p)) {
        D3D_ERR("invalid pointer");
        return;
    }
    if (p) {
        free_function(p);
    }
}

#define CACHE_LINE 32
HRESULT MallocAligned(void** p_return, size_t size)
{
    char* p;
    size_t offset;
    HRESULT error;

    if (!p_return)
	return DDERR_INVALIDPARAMS;

    if (size > 0) {
	if ((error = D3DMalloc((void**) &p, size + CACHE_LINE)) != DD_OK)
        {
            *p_return = NULL;
            return error;
        }
	offset = CACHE_LINE - (DWORD)((ULONG_PTR)p & (CACHE_LINE - 1));
	p += offset;
	((size_t*)p)[-1] = offset;
    } else
	p = NULL;
    *p_return = p;
    return DD_OK;
}

void FreeAligned(void* p)
{
    if (p) {
        size_t offset = ((size_t*)p)[-1];
	p = (void*) ((unsigned char*)p - offset);
    	D3DFree(p);
    }
}

HRESULT ReallocAligned(void** p_inout, size_t size)
{
    char* p = (char*)*p_inout;
    HRESULT error;

    if (!p_inout)
	return DDERR_INVALIDPARAMS;

    if (size > 0) {
	if (p) {
	    size_t old_offset = ((size_t*)p)[-1];
	    size_t new_offset;
	    
	    p -= old_offset;
	    if ((error = D3DRealloc((void**) &p, size + CACHE_LINE)) != DD_OK)
		return error;

	    new_offset = CACHE_LINE - (DWORD)((ULONG_PTR)p & (CACHE_LINE - 1));
	    if (old_offset != new_offset)
	    	memmove(p + new_offset, p + old_offset, size);
	    p += new_offset;
	    ((size_t*)p)[-1] = new_offset;
	} else
	    return MallocAligned(p_inout, size);
    } else if (size == 0) {
	FreeAligned(p);
	p = NULL;
    } else
	return DDERR_INVALIDPARAMS;
    *p_inout = p;
    return DD_OK;
}

//----------------------------------------------------------------------------
// Growing aligned buffer implementation.
//
HRESULT CAlignedBuffer32::Grow(DWORD growSize)
{
    if (allocatedBuf)
        D3DFree(allocatedBuf);
    size = growSize;
    if (D3DMalloc(&allocatedBuf, size + 31) != DD_OK)
    {
        allocatedBuf = 0;
        alignedBuf = 0;
        size = 0;
        return DDERR_OUTOFMEMORY;
    }
    alignedBuf = (LPVOID)(((ULONG_PTR)allocatedBuf + 31 ) & ~31);
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CBufferDDS::Grow"
//----------------------------------------------------------------------
// Growing buffer using DDS implementation.
//
HRESULT CBufferDDS::Grow(LPDIRECT3DDEVICEI lpDevI, DWORD growSize)
{
    DWORD dwRefCnt = 1;
    if (growSize <= size)
        return D3D_OK;
    if (allocatedBuf)
    {
        // Save reference count before deleting
        dwRefCnt = allocatedBuf->AddRef() - 1;
        // Release till gone!
        while (allocatedBuf->Release());
    }
    size = growSize;
    DDSURFACEDESC2 ddsd;
    memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
    ddsd.dwSize = sizeof(DDSURFACEDESC2);
    ddsd.dwFlags = DDSD_WIDTH | DDSD_CAPS;
    ddsd.dwWidth = size + 31; 
    ddsd.ddsCaps.dwCaps = DDSCAPS_EXECUTEBUFFER | DDSCAPS_SYSTEMMEMORY;
    LPDIRECTDRAWSURFACE4 lpDDS4;
    HRESULT ret = lpDevI->lpDirect3DI->lpDD4->CreateSurface(&ddsd, &lpDDS4, NULL);
    if (ret != DD_OK) 
    {
        D3D_ERR("Failed to allocate Vertex Buffer");
        size = 0;
        return ret;
    }
    ret = lpDDS4->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&allocatedBuf);
    if (ret != DD_OK) 
    {
        D3D_ERR("failed to QI for DDS1");
        allocatedBuf = 0;
        size = 0;
        return ret;
    }
    ret = lpDDS4->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_NOSYSLOCK, NULL);
    if (ret != DD_OK)
    {
        D3D_ERR("Could not lock system memory Vertex Buffer.");
        allocatedBuf = 0;
        size = 0;
        return ret;
    }
    lpDDS4->Release();
    alignedBuf = ddsd.lpSurface;
    // Restore reference count
    while (--dwRefCnt)
        allocatedBuf->AddRef();
    return D3D_OK;
}
//----------------------------------------------------------------------
// Growing aligned vertex buffer implementation.
//
HRESULT CBufferVB::Grow(LPDIRECT3DDEVICEI lpDevI, DWORD growSize)
{
    D3DVERTEXBUFFERDESC vbdesc = {sizeof(D3DVERTEXBUFFERDESC), 0, D3DFVF_TLVERTEX, 0};
    DWORD dwRefCnt = 1;
    // Note the assumption that base is not zero only for DP2 HAL
    if (IS_DP2HAL_DEVICE(lpDevI))
    {
        CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(lpDevI);
        HRESULT ret;
        ret = dev->FlushStates(growSize);
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in CBufferVB::Grow");
            return ret;
        }
        base = 0;
    }
    if (growSize <= size)
        return D3D_OK;
    if (allocatedBuf)
    {
        if (IS_DP2HAL_DEVICE(lpDevI))
        {
            CDirect3DDeviceIDP2 &dev = *static_cast<CDirect3DDeviceIDP2*>(lpDevI);
            if (dev.lpDP2CurrBatchVBI == allocatedBuf)
            {
                dev.lpDP2CurrBatchVBI->Release();
                dev.lpDP2CurrBatchVBI = NULL;
            }
        }
        // Save reference count before deleting
        dwRefCnt = allocatedBuf->AddRef() - 1;
        // Release till gone!
        while (allocatedBuf->Release());
    }
    vbdesc.dwNumVertices = (growSize + 31) / sizeof(D3DTLVERTEX);
    size = vbdesc.dwNumVertices * sizeof(D3DTLVERTEX);
    if (!IS_DP2HAL_DEVICE(lpDevI) || !IS_HW_DEVICE(lpDevI))
    {
        vbdesc.dwCaps = D3DVBCAPS_SYSTEMMEMORY;
    }
    if (lpDevI->lpDirect3DI->CreateVertexBufferI(&vbdesc, &allocatedBuf, D3DDP_DONOTCLIP | D3DVBFLAGS_CREATEMULTIBUFFER) != DD_OK)
    {
        allocatedBuf = 0;
        size = 0;
        return DDERR_OUTOFMEMORY;
    }
    // Restore reference count
    while (--dwRefCnt)
        allocatedBuf->AddRef();
    allocatedBuf->Lock(DDLOCK_WAIT, &alignedBuf, NULL);
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\d3dtex.cpp ===
/*==========================================================================;
*
*  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
*
*  File:    texture.c
*  Content: Direct3DTexture interface
*@@BEGIN_MSINTERNAL
*
*  $Id$
*
*  History:
*   Date    By  Reason
*   ====    ==  ======
*   07/12/95   stevela  Merged Colin's changes.
*   10/12/95    stevela Removed AGGREGATE_D3D
*   17/04/96   colinmc Bug 12185: Debug output too aggresive
*   30/04/96   stevela Bug 18898: Wrong error returned on invalid GetHandle
*@@END_MSINTERNAL
*
***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
* Create an api for the Direct3DTexture object
*/

#undef  DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture"

/*
*  Routines to associate textures with the D3DDevice.
*
*  Note that the texture block structures support both the Texture/Texture2
*  interface and the Texture3 interface (the block struct has
*  pointers to both and one of the pointers must be NULL).  This
*  means that the 'hook' call for each must null out the pointer
*  for the other, and the GetTextureHandle must not return a valid
*  handle for the 'other' texture interface (return NULL).
*
*  The D3DI_RemoveTextureBlock is the only call made to cleanup
*  when devices go away.  In this case, it is called for both
*  Texture(2) and Texture3, so it checks the pointers and calls
*  the Texture3 version if appropriate.
*/
LPD3DI_TEXTUREBLOCK hookTextureToDevice(LPDIRECT3DDEVICEI lpDevI,
    LPDIRECT3DTEXTUREI lpD3DText)
{

    LPD3DI_TEXTUREBLOCK nBlock;

    if (D3DMalloc((void**)&nBlock, sizeof(D3DI_TEXTUREBLOCK)) != D3D_OK)
    {
        D3D_ERR("failed to allocate space for texture block");
        return NULL;
    }
    nBlock->lpDevI = lpDevI;
    nBlock->lpD3DTextureI = lpD3DText;
    nBlock->hTex = 0;              // initialized to be zero

    LIST_INSERT_ROOT(&lpD3DText->blocks, nBlock, list);
    LIST_INSERT_ROOT(&lpDevI->texBlocks, nBlock, devList);

    return nBlock;
}

void D3DI_RemoveTextureHandle(LPD3DI_TEXTUREBLOCK lpBlock)
{
    /*  check if this block refers to a Texture/Texture2 - this
     *   needs to handle both texture types for device cleanup
     */
    if (lpBlock->hTex)
    {
        //  block refers to a Texture/Texture2
        LPD3DI_MATERIALBLOCK mat;

        // Remove the texture from any materials which reference it.
        for (mat = LIST_FIRST(&lpBlock->lpDevI->matBlocks);
             mat; mat = LIST_NEXT(mat,devList)) {
            if (mat->lpD3DMaterialI->dmMaterial.hTexture == lpBlock->hTex) {
                D3DMATERIAL m = mat->lpD3DMaterialI->dmMaterial;
                LPDIRECT3DMATERIAL lpMat =
                    (LPDIRECT3DMATERIAL) mat->lpD3DMaterialI;
                m.hTexture = 0L;
                lpMat->SetMaterial(&m);
            }
        }
        D3DHAL_TextureDestroy(lpBlock);
    }
}

LPD3DI_TEXTUREBLOCK D3DI_FindTextureBlock(LPDIRECT3DTEXTUREI lpTex,
                                          LPDIRECT3DDEVICEI lpDev)
{
    LPD3DI_TEXTUREBLOCK tBlock;

    tBlock = LIST_FIRST(&lpTex->blocks);
    while (tBlock) {
        //  return match for Texture(2) only (not Texture3)
        if (tBlock->lpDevI == lpDev) {
            return tBlock;
        }
        tBlock = LIST_NEXT(tBlock,list);
    }
    return NULL;
}

HRESULT D3DAPI DIRECT3DTEXTUREI::Initialize(LPDIRECT3DDEVICE lpD3D, LPDIRECTDRAWSURFACE lpDDS)
{
    return DDERR_ALREADYINITIALIZED;
}

/*
* Create a texture.
*
* NOTE: Radical modifications to support the aggregatable texture
* interface (so textures can be queried off DirectDraw surfaces):
*
* 1) This call is no longer a member of the Direct3D device interface.
*    It is now an API function exported from the Direct3D DLL. Its
*    a hidden API function - only DirectDraw will ever invoke it.
*
* 2) This call no longer establishes the realtionship between a
*    texture and a device. That is performed by the GetHandle()
*    member of the Direct3DTexture interface.
*
* 3) This call is, in effect, the class factory for Direct3DTexture
*    objects. This function will be invoked to create the aggregated
*    texture object hanging off the DirectDraw surface.
*
* NOTE: So the Direct3DTexture knows which DirectDraw surface is
* supplying its bits this function is passed an interface pointer
* for that DirectDraw surface. I suspect this blows a nice big
* hole in the COM model as the DirectDraw surface is also the
* owning interface of the texture and I don't think aggregated
* objects should know about thier owning interfaces. However, to
* make this thing work this is what we have to do.
*
* EXTRA BIG NOTE: Because of the above don't take a reference to
* the DirectDraw surface passed in. If you do you will get a circular
* reference and the bloody thing will never die. When aggregated
* the texture interface's lifetime is entirely defined by the
* lifetime of its owning interface (the DirectDraw surface) so the
* DirectDraw surface can never go away before the texture.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DCreateTexture"
HRESULT D3DAPI Direct3DCreateTexture(REFIID              riid,
                                     LPDIRECTDRAWSURFACE lpDDS,
                                     LPUNKNOWN*          lplpD3DText,
                                     IUnknown*           pUnkOuter)
{
    LPDDRAWI_DDRAWSURFACE_LCL lpLcl;
    LPDDPIXELFORMAT lpPF;
    LPDIRECT3DTEXTUREI lpText;
    LPDIRECTDRAWPALETTE lpDDPal;
    HRESULT ddrval;
    DWORD   dwFlags;
    *lplpD3DText = NULL;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /* No need to validate params as they are passed to us by DirectDraw */

    if ((!IsEqualIID(riid, IID_IDirect3DTexture)) &&
        (!IsEqualIID(riid, IID_IDirect3DTexture2))) {
        /*
         * Not an error worth reporting by debug messages as this is
         * almost certainly just DirectDraw probing us with an
         * unknown IID.
         */
        return (E_NOINTERFACE);
    }

    lpText =  static_cast<LPDIRECT3DTEXTUREI>(new DIRECT3DTEXTUREI(pUnkOuter));

    if (!lpText) {
        D3D_ERR("failed to allocate space for texture object");
        return (DDERR_OUTOFMEMORY);
    }

    // QI lpDDS for lpDDS4 interface
    ddrval = lpDDS->QueryInterface(IID_IDirectDrawSurface4, (LPVOID*)&lpText->lpDDS);

    if(FAILED(ddrval))
    {
        D3D_ERR("QI for IID_IDirectDrawSurface4 failed");
        delete lpText;
        return ddrval;
    }

    memcpy(&lpText->DDSInt4,lpText->lpDDS,sizeof(DDRAWI_DDRAWSURFACE_INT));
    lpText->lpDDS->Release();

    lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl;
    if (DDSCAPS2_TEXTUREMANAGE & lpLcl->lpSurfMore->ddsCapsEx.dwCaps2)
    {
        lpText->lpDDSSys=(LPDIRECTDRAWSURFACE4)&lpText->DDSInt4;
        lpText->lpDDSSys1Tex=lpDDS; //save it for create texture handle to driver
        lpText->lpDDS=NULL;
        lpText->lpDDS1Tex=NULL;

        // Next, we need to loop thru and set pointers to the dirty
        // bit in the DDraw surfaces
        DDSCAPS2 ddscaps;
        LPDIRECTDRAWSURFACE4 lpDDSTmp, lpDDS = lpText->lpDDSSys;
        do
        {
            ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpSurfMore->lpbDirty = &(lpText->bDirty);
            memset(&ddscaps, 0, sizeof(ddscaps));
            ddscaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
            ddrval = lpDDS->GetAttachedSurface(&ddscaps, &lpDDSTmp);
            if(lpDDS != lpText->lpDDSSys)
                lpDDS->Release();
            lpDDS = lpDDSTmp;
            if(ddrval != DD_OK && ddrval != DDERR_NOTFOUND)
            {
                D3D_ERR("GetAttachedSurface for obtaining mipmaps failed");
                delete lpText;
                return ddrval;
            }
        }
        while(ddrval == DD_OK);
    }
    else
    {
        lpText->lpDDSSys=NULL;
        lpText->lpDDSSys1Tex=NULL;
        lpText->lpDDS=(LPDIRECTDRAWSURFACE4)&lpText->DDSInt4;
        lpText->lpDDS1Tex=lpDDS;    //save it for create texture handle to driver
    }
    lpText->lpTMBucket=NULL;
    lpText->LogTexSize=0;
    lpText->bDirty = TRUE;

    /*
     * Are we palettized?
     */

    if (lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)
        lpPF = &lpLcl->lpGbl->ddpfSurface;
    else
        lpPF = &lpLcl->lpGbl->lpDD->vmiData.ddpfDisplay;

    if ( (lpPF->dwFlags & DDPF_PALETTEINDEXED1) ||
         (lpPF->dwFlags & DDPF_PALETTEINDEXED2) ||
         (lpPF->dwFlags & DDPF_PALETTEINDEXED4) ||
         (lpPF->dwFlags & DDPF_PALETTEINDEXED8) )
    {
        ddrval = lpDDS->GetPalette(&lpDDPal);
        if (ddrval != DD_OK) {
            if (ddrval != DDERR_NOPALETTEATTACHED) {
                delete lpText;
                D3D_ERR("No palette in a palettized texture");
                return ddrval;
            }
            D3D_INFO(3, "Texture is not palettized");
            lpText->bIsPalettized = false;
        } else {
            lpText->bIsPalettized = true;
            lpDDPal->Release();
            D3D_INFO(3, "Texture is palettized");
        }
    }

    /*
     * Note, we return the IUnknown rather than the texture
     * interface. So if you want to do anything real with
     * this baby you must query for the texture interface.
     */
    *lplpD3DText = static_cast<LPUNKNOWN>(&(lpText->mTexUnk));

    return (D3D_OK);
}

DIRECT3DTEXTUREI::DIRECT3DTEXTUREI(LPUNKNOWN pUnkOuter)
{
    /*
     * setup the object
     *
     * NOTE: Device and handle established when GetHandle() is called
     */
    mTexUnk.refCnt = 1;
    LIST_INITIALIZE(&blocks);
    mTexUnk.pTexI=this;

    /*
    * Are we really being aggregated?
    */
    if (pUnkOuter != NULL)
    {
        /*
         * Yup - we are being aggregated. Store the supplied
         * IUnknown so we can punt to that.
         * NOTE: We explicitly DO NOT AddRef here.
         */
        lpOwningIUnknown = pUnkOuter;
    }
    else
    {
        /*
         * Nope - but we pretend we are anyway by storing our
         * own IUnknown as the parent IUnknown. This makes the
         * code much neater.
        */
        lpOwningIUnknown = static_cast<LPUNKNOWN>(&(this->mTexUnk));
    }

    // Not currently in use
    bInUse = FALSE;
}

/*
* GetHandle
*
* NOTE: Now establishes relationship betwewn texture and device
* (which used to be done by CreateTexture) and generates the
* texture handle.
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::GetHandle"

HRESULT D3DAPI DIRECT3DTEXTUREI::GetHandle(LPDIRECT3DDEVICE   lpD3DDevice,
                                           LPD3DTEXTUREHANDLE lphTex)
{
    LPDIRECT3DDEVICEI   lpDev;
    LPD3DI_TEXTUREBLOCK lptBlock;
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DTEXTURE2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DDEVICE_PTR(lpD3DDevice)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DTEXTUREHANDLE_PTR(lphTex)) {
            D3D_ERR( "Invalid D3DTEXTUREHANDLE pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (lpDDSSys)
    {
        D3D_ERR( "Handle is not available since the texture is managed" );
        return  DDERR_INVALIDOBJECT;    //managed texture has no handle
    }
    lpDev = static_cast<LPDIRECT3DDEVICEI>(lpD3DDevice);
    lptBlock = D3DI_FindTextureBlock(this, lpDev);
    *lphTex=0;

    if (NULL == lptBlock) {
    /*
     * NOTE: We used to do this in CreateTexture. Perhaps the service
     * name should be changed (as the texture is now already created
     * when this function is invoked).
     *
     * Indicate to driver that source is a DirectDraw surface, so it
     * can Lock() when required.
     */
        lptBlock = hookTextureToDevice(lpDev, this);
        if ( NULL == lptBlock) {
            D3D_ERR("failed to associate texture with device");
            return DDERR_OUTOFMEMORY;
        }
    }
    if (!lptBlock->hTex)
    {
        HRESULT ret;
        ret = D3DHAL_TextureCreate(lpDev, &lptBlock->hTex, lpDDS1Tex);
        if (ret != D3D_OK)
        {
            return  ret;
        }
        D3D_INFO(6,"lpTexI=%08lx lptBlock=%08lx hTex=%08lx",this,lptBlock,lptBlock->hTex);
    }
    *lphTex=lptBlock->hTex;
    DDASSERT(lptBlock->hTex);
    return D3D_OK;
}

HRESULT D3DAPI DIRECT3DTEXTUREI::GetHandle(LPDIRECT3DDEVICE2   lpD3DDevice,
                                           LPD3DTEXTUREHANDLE lphTex)
{
    LPDIRECT3DDEVICEI   lpDev;
    LPD3DI_TEXTUREBLOCK lptBlock;
    HRESULT ret;
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DTEXTURE2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture2 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DDEVICE2_PTR(lpD3DDevice)) {
            D3D_ERR( "Invalid Direct3DDevice2 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DTEXTUREHANDLE_PTR(lphTex)) {
            D3D_ERR( "Invalid D3DTEXTUREHANDLE pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (lpDDSSys)
    {
        D3D_ERR( "Handle is not available since texture is managed" );
        return  DDERR_INVALIDOBJECT;    //managed texture has no handle
    }

    lpDev = static_cast<LPDIRECT3DDEVICEI>(lpD3DDevice);

    lptBlock = D3DI_FindTextureBlock(this, lpDev);
    /*
     * Do cap verification if we've not used this device before.
     */

    *lphTex=0;
    if (NULL == lptBlock) {
        ret=VerifyTextureCaps(lpDev, (LPDDRAWI_DDRAWSURFACE_INT)lpDDS);
        if (ret != D3D_OK)
        {
            return  ret;
        }

        /*
         * Put this device in the list of those owned by the
         * Direct3DDevice object
         */
        lptBlock = hookTextureToDevice(lpDev, this);
        if ( NULL == lptBlock) {
            D3D_ERR("failed to associate texture with device");
            return DDERR_OUTOFMEMORY;
        }
    }
    if (!lptBlock->hTex)
    {
        ret = D3DHAL_TextureCreate(lpDev, &lptBlock->hTex, lpDDS1Tex);
        if (ret != D3D_OK)
        {
            return  ret;
        }
        D3D_INFO(6,"lpTexI=%08lx lptBlock=%08lx hTex=%08lx",this,lptBlock,lptBlock->hTex);
    }
    *lphTex=lptBlock->hTex;
    DDASSERT(lptBlock->hTex);
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetTextureDDIHandle"

HRESULT
GetTextureDDIHandle(LPDIRECT3DTEXTUREI lpTexI,
                     LPDIRECT3DDEVICEI lpDevI,
                     LPD3DI_TEXTUREBLOCK* lplpBlock)
{
#ifdef __DD_OPT_SURFACE
    LPDDRAWI_DDRAWSURFACE_LCL pSurf_lcl = NULL;
#endif //__DD_OPT_SURFACE
    HRESULT ret;
    LPD3DI_TEXTUREBLOCK lpBlock=*lplpBlock; //in case has the pointer

#ifdef __DD_OPT_SURFACE
    // If the surface is Empty, return 0 handle
    if (lpTexI->lpDDS)
    {
        pSurf_lcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpTexI->lpDDS)->lpLcl;
    }
    else
    {
        pSurf_lcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpTexI->lpDDSSys)->lpLcl;
    }

    DDASSERT (pSurf_lcl);

    if (pSurf_lcl->dwFlags & DDRAWISURF_EMPTYSURFACE)
    {
        D3D_WARN(1, "Cannot get DDI handle to an empty surface, call load first");
        return  D3DERR_OPTTEX_CANNOTCOPY;
    }
#endif //__DD_OPT_SURFACE
    DDASSERT(lpTexI && lpDevI);
    /*
     * Find out if we've used this device before.
     */
    if (!lpBlock)
    {
        lpBlock = D3DI_FindTextureBlock(lpTexI, lpDevI);
        if (!lpBlock)
        {
            /*
             * Put this device in the list of those owned by the
             * Direct3DDevice object
             */
            lpBlock=hookTextureToDevice(lpDevI, lpTexI);
            if (!lpBlock)
            {
                D3D_ERR("failed to associate texture with device");
                return DDERR_OUTOFMEMORY;
            }
        }
        *lplpBlock = lpBlock;
    }
    if (!lpBlock->hTex)
    {
        LPDIRECTDRAWSURFACE lpDDS1Temp;
        if (!lpTexI->lpDDS)
        {
          if (lpDevI->dwFEFlags &  D3DFE_REALHAL)
          {
            // We need to make sure that we don't evict any mapped textures
            DWORD dwStage;
            for (dwStage=0;dwStage < lpDevI->dwMaxTextureBlendStages; dwStage++)
                if(lpDevI->lpD3DMappedTexI[dwStage])
                    lpDevI->lpD3DMappedTexI[dwStage]->bInUse = TRUE;

            ret=lpDevI->lpDirect3DI->lpTextureManager->allocNode(lpBlock);

            for (dwStage=0;dwStage < lpDevI->dwMaxTextureBlendStages; dwStage++)
                if(lpDevI->lpD3DMappedTexI[dwStage])
                    lpDevI->lpD3DMappedTexI[dwStage]->bInUse = FALSE;

            if (D3D_OK != ret)
            {
                D3D_ERR("Failed to create video memory surface");
                return ret;
            }
            if (!(lpDevI->lpD3DHALGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR))
                lpDevI->lpDirect3DI->lpTextureManager->TimeStamp(lpTexI->lpTMBucket);

            if (lpBlock->hTex)  return  D3D_OK; //this means Texmanager reused a texture handle

            // QI lpDDS4 for lpDDS interface
            if (DD_OK != (ret=lpTexI->lpDDS->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&lpDDS1Temp)))
            {
                D3D_ERR("QI IID_IDirectDrawSurface failed");
                lpTexI->lpTMBucket->lpD3DTexI=NULL; //clean up
                lpTexI->lpTMBucket=NULL;
                lpTexI->lpDDS->Release();
                lpTexI->lpDDS=NULL;
                return ret;
            }
            lpTexI->lpDDS1Tex = lpDDS1Temp;
          }
          else
          {
            lpDDS1Temp = lpTexI->lpDDSSys1Tex;
          }
        }
        else
            lpDDS1Temp = lpTexI->lpDDS1Tex;
        DDASSERT(NULL != lpDDS1Temp);
        {
            CLockD3DST lockObject(lpDevI, DPF_MODNAME, REMIND(""));
            if (D3D_OK != (ret=D3DHAL_TextureCreate(lpDevI, &lpBlock->hTex, lpDDS1Temp)))
                return ret;
        }
    }
    else
        if (lpTexI->lpTMBucket && !(lpDevI->lpD3DHALGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR))
            lpDevI->lpDirect3DI->lpTextureManager->TimeStamp(lpTexI->lpTMBucket);

    DDASSERT(lpBlock->hTex);
    return D3D_OK;
}

/*
* Load
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::Load"

#define HEL_BLT_ALPAHPIXELS_BROKEN

HRESULT D3DAPI DIRECT3DTEXTUREI::Load(LPDIRECT3DTEXTURE lpD3DSrc)
{
    LPDIRECT3DTEXTUREI  this_src;
    HRESULT ddrval;
    LPDIRECTDRAWSURFACE4 lpDDSSrc, lpDDSDst;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DTEXTURE_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DTEXTURE_PTR(lpD3DSrc)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    this_src  = static_cast<LPDIRECT3DTEXTUREI>(lpD3DSrc);
    lpDDSSrc = this_src->lpDDSSys;
    if (!lpDDSSrc)
        lpDDSSrc = this_src->lpDDS;

    lpDDSDst = lpDDSSys;
    if (!lpDDSDst)
        lpDDSDst = lpDDS;
    ddrval = CopySurface(lpDDSDst, lpDDSSrc, NULL);
    return ddrval;
}

HRESULT D3DAPI DIRECT3DTEXTUREI::Load(LPDIRECT3DTEXTURE2 lpD3DSrc)
{
    LPDIRECT3DTEXTUREI  this_src;
    HRESULT     ddrval;
    LPDIRECTDRAWSURFACE4 lpDDSSrc, lpDDSDst;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        this_src = static_cast<LPDIRECT3DTEXTUREI>(lpD3DSrc);
        if (!VALID_DIRECT3DTEXTURE2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DTEXTURE2_PTR(this_src)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    lpDDSSrc = this_src->lpDDSSys;
    if (!lpDDSSrc)
        lpDDSSrc = this_src->lpDDS;

    lpDDSDst = lpDDSSys;
    if (!lpDDSDst)
        lpDDSDst = lpDDS;
    ddrval = CopySurface(lpDDSDst, lpDDSSrc, NULL);
    return ddrval;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CopySurface"

HRESULT CopySurface(LPDIRECTDRAWSURFACE4 lpDDSDst,
                    LPDIRECTDRAWSURFACE4 lpDDSSrc,
                    LPDIRECTDRAWCLIPPER  lpClipper)
{
    DDSURFACEDESC2   ddsd;
#ifdef __DD_OPT_SURFACE
    DDSURFACEDESC2   ddsdSrc;
    BOOL bDstIsOptimized, bSrcIsOptimized;
    LPDIRECTDRAWOPTSURFACE pOptSurfSrc = NULL;
    LPDIRECTDRAWOPTSURFACE pOptSurfDst = NULL;
#endif //__DD_OPT_SURFACE
    HRESULT     ddrval=DD_OK;
    PALETTEENTRY    ppe[256];
    LPDIRECTDRAWPALETTE lpDDPalSrc, lpDDPalDst;
    int psize;
    DDCOLORKEY ckey;

    if (!lpDDSSrc || !lpDDSDst) return  DD_OK;
    memset(&ddsd, 0, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddrval = lpDDSDst->GetSurfaceDesc(&ddsd);

#ifdef __DD_OPT_SURFACE
    memset(&ddsdSrc, 0, sizeof(ddsdSrc));
    ddsdSrc.dwSize = sizeof(ddsdSrc);
    ddrval = lpDDSSrc->GetSurfaceDesc(&ddsdSrc);

    if (bDstIsOptimized = (ddsd.ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
    {
        // Fetch the OptSurface Interface
        ddrval = lpDDSDst->QueryInterface (IID_IDirectDrawOptSurface,
                                           (LPVOID *)&pOptSurfDst);
        if (ddrval != DD_OK)
        {
            D3D_ERR( "QI failed for Opt Surfaces" );
            goto exit_copy_surf;
        }
    }

    if (bSrcIsOptimized = (ddsdSrc.ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
    {
        // Fetch the OptSurface Interface
        ddrval = lpDDSDst->QueryInterface (IID_IDirectDrawOptSurface,
                                           (LPVOID *)&pOptSurfSrc);
        if (ddrval != DD_OK)
        {
            D3D_ERR( "QI failed for Opt Surfaces" );
            goto exit_copy_surf;
        }
    }


    // Cases:
    //        Dst=Opt   Src=Opt  : Copy the surface
    //        Dst=Opt   Src=UnOpt: Optimize the surface
    //        Dst=UnOpt Src=Opt  : UnOptimize and load
    //        Dst=UnOpt Src=UnOpt: Normal operation
    //
    if (bDstIsOptimized && bSrcIsOptimized)
    {
        // Copy the surface
        ddrval = pOptSurfSrc->CopyOptimizedSurf (pOptSurfSrc);
        if (ddrval != DD_OK)
        {
            D3D_ERR ("CopyOptimizedSurf failed");
        }
        goto exit_copy_surf;
    }
    else if (bDstIsOptimized && !bSrcIsOptimized)
    {
        LPDIRECTDRAWSURFACE4 pDDS4 = NULL;

        // Optimize the surface
        ddrval = lpDDSDst->QueryInterface (IID_IDirectDrawSurface4,
                                           (LPVOID *)&pOptSurfSrc);
        if (ddrval != DD_OK)
        {
            D3D_ERR( "QI failed for IID_IDirectDrawSurface4" );
            goto exit_copy_surf;
        }

        ddrval = pOptSurfSrc->LoadUnoptimizedSurf (pDDS4);
        if (ddrval != DD_OK)
        {
            D3D_ERR ("CopyOptimizedSurf failed");
        }
        pDDS4->Release();
        goto exit_copy_surf;
    }
    else if (!bDstIsOptimized && bSrcIsOptimized)
    {
        LPDIRECTDRAWOPTSURFACE pDDS4 = NULL;

        // ATTENTION: Unoptimize the surface ??
        D3D_ERR ("CopyOptimizedSurf failed");
        ddrval = D3DERR_OPTTEX_CANNOTCOPY;
        goto exit_copy_surf;
    }
#endif //__DD_OPT_SURFACE

    if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8) {
        psize = 256;
    } else if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED4) {
        psize = 16;
    } else {
        psize = 0;
    }

    if (psize) {
        ddrval = lpDDSSrc->GetPalette(&lpDDPalSrc);
        if (ddrval != DD_OK) {
            if (ddrval != DDERR_NOPALETTEATTACHED) {
                D3D_ERR("Failed to get palette");
                return ddrval;
            }
        } else {
            ddrval = lpDDPalSrc->GetEntries(0, 0, psize, ppe);
            if (ddrval != DD_OK) {
                D3D_ERR("Failed to get palette entries");
                lpDDPalSrc->Release();
                return ddrval;
            }
            lpDDPalSrc->Release();
            ddrval = lpDDSDst->GetPalette(&lpDDPalDst);
            if (ddrval != DD_OK) {
                D3D_ERR("Failed to get palette");
                return ddrval;
            }
            ddrval = lpDDPalDst->SetEntries(0, 0, psize, ppe);
            if (ddrval != DD_OK) {
                D3D_ERR("Failed to set palette entries");
                lpDDPalDst->Release();
                return ddrval;
            }
            lpDDPalDst->Release();
        }
    }

    lpDDSSrc->AddRef();
    lpDDSDst->AddRef();
    do {
        DDSCAPS2 ddscaps;
        LPDIRECTDRAWSURFACE4 lpDDSTmp;

        LPREGIONLIST lpRegionList = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSSrc)->lpLcl->lpSurfMore->lpRegionList;
        if(lpClipper)
        {
            if(lpRegionList)
            {
                if(lpRegionList->rdh.nCount &&
                    lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                {
                    if(lpClipper->SetClipList((LPRGNDATA)lpRegionList, 0) != DD_OK)
                    {
                        D3D_ERR("Failed to set clip list");
                    }
                    if(lpDDSDst->SetClipper(lpClipper) != DD_OK)
                    {
                        D3D_ERR("Failed to detach the clipper");
                    }
                }
            }
        }

        ddrval = lpDDSDst->Blt(NULL, lpDDSSrc,
                               NULL, DDBLT_WAIT, NULL);

        if(lpClipper)
        {
            if(lpRegionList)
            {
                if(lpRegionList->rdh.nCount)
                {
                    if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                    {
                        if(lpDDSDst->SetClipper(NULL) != DD_OK)
                        {
                            D3D_ERR("Failed to detach the clipper");
                        }
                    }
                    lpRegionList->rdh.nCount = 0;
                    lpRegionList->rdh.nRgnSize = 0;
                    lpRegionList->rdh.rcBound.left = LONG_MAX;
                    lpRegionList->rdh.rcBound.right = 0;
                    lpRegionList->rdh.rcBound.top = LONG_MAX;
                    lpRegionList->rdh.rcBound.bottom = 0;
                }
            }
        }

        if (ddrval == E_NOTIMPL && (psize == 16 || psize == 4 || psize == 2) ) {
            DDSURFACEDESC2 ddsd_s, ddsd_d;
            LPBYTE psrc, pdst;
            DWORD i;
            DWORD dwBytesPerLine;

            memset(&ddsd_s, 0, sizeof ddsd_s);
            memset(&ddsd_d, 0, sizeof ddsd_d);
            ddsd_s.dwSize = ddsd_d.dwSize = sizeof(ddsd_s);

            if ((ddrval = lpDDSSrc->Lock(NULL, &ddsd_s, DDLOCK_WAIT, NULL)) != DD_OK) {
                lpDDSSrc->Release();
                lpDDSDst->Release();
                D3D_ERR("Failed to lock src surface");
                return ddrval;
            }
            if ((ddrval = lpDDSDst->Lock(NULL, &ddsd_d, DDLOCK_WAIT, NULL)) != DD_OK) {
                lpDDSSrc->Unlock(NULL);
                lpDDSSrc->Release();
                lpDDSDst->Release();
                D3D_ERR("Failed to lock dst surface");
                return ddrval;
            }

            switch (psize)
            {
            case 16: dwBytesPerLine = (ddsd.dwWidth + 1) / 2; break;
            case 4: dwBytesPerLine = (ddsd.dwWidth + 3) / 4; break;
            case 2: dwBytesPerLine = (ddsd.dwWidth + 7) / 8; break;
            }

            psrc = (LPBYTE)ddsd_s.lpSurface;
            pdst = (LPBYTE)ddsd_d.lpSurface;
            for (i = 0; i < ddsd_s.dwHeight; i++) {
                memcpy( pdst, psrc, dwBytesPerLine );
                psrc += ddsd_s.lPitch;
                pdst += ddsd_d.lPitch;
            }

            lpDDSSrc->Unlock(NULL);
            lpDDSDst->Unlock(NULL);
            lpDDSSrc->Release();    //Offset the AddRefs before
            lpDDSDst->Release();

            return D3D_OK;

        }
        else if (ddrval != DD_OK)
        {
            lpDDSSrc->Release();    //Offset the AddRefs before
            lpDDSDst->Release();
            D3D_ERR("Blt failure");
            return ddrval;
        }
        /* Copy color keys */
        ddrval = lpDDSSrc->GetColorKey(DDCKEY_DESTBLT, &ckey);
        if (DD_OK == ddrval)
            lpDDSDst->SetColorKey(DDCKEY_DESTBLT, &ckey);
        ddrval = lpDDSSrc->GetColorKey(DDCKEY_SRCBLT, &ckey);
        if (DD_OK == ddrval)
            lpDDSDst->SetColorKey(DDCKEY_SRCBLT, &ckey);

        memset(&ddscaps, 0, sizeof(ddscaps));
        ddscaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
        ddrval = lpDDSSrc->GetAttachedSurface(&ddscaps, &lpDDSTmp);
        lpDDSSrc->Release();
        lpDDSSrc = lpDDSTmp;
        if (ddrval == DDERR_NOTFOUND) {
            // no more surfaces in the chain
            lpDDSDst->Release();
            break;
        } else if (ddrval != DD_OK) {
            lpDDSDst->Release();
            D3D_ERR("GetAttachedSurface failed with something other than DDERR_NOTFOUND.");
            return ddrval;
        }
        memset(&ddscaps, 0, sizeof(ddscaps));
        ddscaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
        ddrval = lpDDSDst->GetAttachedSurface(&ddscaps, &lpDDSTmp);
        lpDDSDst->Release();
        lpDDSDst = lpDDSTmp;
        if (ddrval == DDERR_NOTFOUND) {
            lpDDSSrc->Release();
            D3D_ERR("Destination texture has fewer attached mipmap surfaces than source.");
            return ddrval;
        } else if (ddrval != DD_OK) {
            lpDDSSrc->Release();
            D3D_ERR("GetAttachedSurface failed with something other than DDERR_NOTFOUND.");
            return ddrval;
        }
    } while (1);

    return D3D_OK;

#ifdef __DD_OPT_SURFACE
exit_copy_surf:
    // Job done, release any optimized surface interfaces
    if (pOptSurfSrc)
    {
        pOptSurfSrc->Release();
        pOptSurfSrc = NULL;
    }
    if (pOptSurfDst)
    {
        pOptSurfDst->Release();
        pOptSurfDst = NULL;
    }
    return  ddrval;
#endif //__DD_OPT_SURFACE
}

/*
* Unload
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::Unload"

HRESULT D3DAPI DIRECT3DTEXTUREI::Unload()
{
    HRESULT     ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DTEXTURE_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    return (ret);
}

/*
* PaletteChanged
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::PaletteChanged"

HRESULT D3DAPI DIRECT3DTEXTUREI::PaletteChanged(DWORD dwStart, DWORD dwCount)
{
    HRESULT     ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DTEXTURE_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    // if haven't mapped to a device yet, can ignore this call, since will
    // be creating the ramp palette from scratch anyway.
    LPD3DI_TEXTUREBLOCK tBlock = LIST_FIRST(&this->blocks);
    while (tBlock) {
        if (tBlock->hTex)
        {
            if(tBlock->lpDevI->pfnRampService!=NULL)
            {
                ret = CallRampService(tBlock->lpDevI, RAMP_SERVICE_PALETTE_CHANGED,tBlock->hTex,0);
            }
        }
        tBlock=LIST_NEXT(tBlock,list);
    }

    return (ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\deviunk.cpp ===
/*==========================================================================;
*
*  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
*
*  File:    deviunk.c
*  Content: Direct3DDevice IUnknown
*@@BEGIN_MSINTERNAL
* 
*  $Id$
*
*  History:
*   Date    By  Reason
*   ====    ==  ======
*   07/12/95    stevela Merged Colin's changes.
*   10/12/95    stevela Removed AGGREGATE_D3D.
*@@END_MSINTERNAL
*
***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
* If we are built with aggregation enabled then we actually need two
* different Direct3D QueryInterface, AddRef and Releases. One which
* does the right thing on the Direct3DTexture object and one which
* simply punts to the owning interface.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice"

/*
* D3DDevIUnknown_QueryInterface
*/
HRESULT D3DAPI CDirect3DDeviceUnk::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_OUTPTR(ppvObj)) {
            D3D_ERR( "Invalid pointer to object pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    
    D3D_INFO(3, "Direct3DDevice IUnknown QueryInterface");
    
    *ppvObj = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
    {
        /*
         * Asking for IUnknown and we are IUnknown.
         * NOTE: Must AddRef through the interface being returned.
         */
        pDevI->AddRef();
        *ppvObj = static_cast<LPVOID>(this);
    }
    else if (IS_DX5_COMPATIBLE_DEVICE(pDevI))
    { /* Non aggregated device, possible IIDs: Device, Device2, Device3 */
        if (IsEqualIID(riid, IID_IDirect3DDevice))
        {
            pDevI->AddRef();
            *ppvObj = static_cast<LPVOID>(static_cast<IDirect3DDevice*>(pDevI));
            pDevI->guid = IID_IDirect3DDevice;
        }
        else if (IsEqualIID(riid, IID_IDirect3DDevice2))
        {
            pDevI->AddRef();
            *ppvObj = static_cast<LPVOID>(static_cast<IDirect3DDevice2*>(pDevI));
            pDevI->guid = IID_IDirect3DDevice2;
        }
        else if (IsEqualIID(riid, IID_IDirect3DDevice3))
        {
            if(pDevI->dwVersion<3) {
                D3D_ERR("Cannot QueryInterface for Device3 from device created as Device2");
                return E_NOINTERFACE;
            }

            pDevI->AddRef();
            *ppvObj = static_cast<LPVOID>(static_cast<IDirect3DDevice3*>(pDevI));
            pDevI->guid = IID_IDirect3DDevice3;
        }
        else
        {
            D3D_ERR("unknown interface");
            return (E_NOINTERFACE);
        }
    }
    else if (IsEqualIID(riid, pDevI->guid))
    { /* DDraw Aggregated device, possible IIDs: RampDevice, RGBDevice, HALDevice */
        pDevI->AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<CDirect3DDevice*>(pDevI));
    }
    else
    {
        D3D_ERR("unknown interface");
        return (E_NOINTERFACE);
    }
    
    return (D3D_OK);
    
} /* D3DDevIUnknown_QueryInterface */

/*
  * D3DDevIUnknown_AddRef
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::AddRef"

ULONG D3DAPI CDirect3DDeviceUnk::AddRef()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    this->refCnt++;
    D3D_INFO(3, "Direct3DDevice IUnknown AddRef: Reference count = %d", this->refCnt);
    
    return (this->refCnt);
    
} /* D3DDevIUnknown_AddRef */

/*
  * D3DDevIUnknown_Release
  *
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::Release"

ULONG D3DAPI CDirect3DDeviceUnk::Release()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    
    D3D_INFO(3, "Direct3DDevice IUnknown Release: Reference count = %d", this->refCnt);
    
    if( this->refCnt == 0 )
    {
        delete pDevI; // Delete Parent object
        return 0;
    }
    return this->refCnt;
    
} /* D3DDevIUnknown_Release */

/*
  * D3DDev_QueryInterface
  */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::QueryInterface"
  
HRESULT D3DAPI DIRECT3DDEVICEI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT ret;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     ,    */
    TRY
    {
        if( !VALID_OUTPTR( ppvObj ) )
        {
            D3D_ERR("Invalid obj ptr" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
     
    *ppvObj = NULL;
      
    /*
     * Punt to the owning interface.
     */
    ret = this->lpOwningIUnknown->QueryInterface(riid, ppvObj);
      
    return ret;
} /* D3DDev_QueryInterface */
/*
    * D3DDev_AddRef
  */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::AddRef"
  
ULONG D3DAPI DIRECT3DDEVICEI::AddRef()
{
    ULONG ret;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    /*
     * Punt to owning interface.
     */
    ret = this->lpOwningIUnknown->AddRef();
      
    return ret;
} /* D3DDev_AddRef */

/*
 * D3DDev_Release
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::Release"
  
ULONG D3DAPI DIRECT3DDEVICEI::Release()
{
    ULONG ret;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    /*
     * Punt to owning interface.
     */
    ret = this->lpOwningIUnknown->Release();
    
    return ret;
} /* D3DDev_Release */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\devstate.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       devstate.c
 *  Content:    device state management
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "drawprim.hpp"

extern HRESULT checkDeviceSurface(LPDIRECT3DDEVICEI lpD3DDev,
                                  LPDIRECTDRAWSURFACE lpDDS);
extern HRESULT CalcDDSurfInfo(LPDIRECT3DDEVICEI lpDevI, BOOL bUpdateZBufferFields);
extern HRESULT downloadView(LPDIRECT3DVIEWPORTI lpViewI);

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetCurrentViewport"

HRESULT D3DAPI DIRECT3DDEVICEI::SetCurrentViewport(LPDIRECT3DVIEWPORT2 lpViewport)
{
    return SetCurrentViewport((LPDIRECT3DVIEWPORT3)lpViewport);
}

HRESULT D3DAPI DIRECT3DDEVICEI::SetCurrentViewport(LPDIRECT3DVIEWPORT3 lpViewport)
{
    LPDIRECT3DVIEWPORTI lpD3DViewI,lpOldViewportI;
    HRESULT err;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        lpD3DViewI = (LPDIRECT3DVIEWPORTI)lpViewport;
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DVIEWPORT3_PTR(lpViewport))
        {
            D3D_ERR( "Invalid viewport pointer passed to SetCurrentViewport" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in SetCurrentViewport" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "SetCurrentViewport in Begin" );
        return D3DERR_INBEGIN;
    }

    /*
     * The viewport must be associated with this device
     */
    if (lpD3DViewI->lpDevI != this)
    {
        D3D_ERR( "Viewport not associated with this device" );
        return (DDERR_INVALIDPARAMS);
    }

    lpOldViewportI=this->lpCurrentViewport;
    this->lpCurrentViewport = lpD3DViewI;

    if (lpD3DViewI->v_id != v_id && lpD3DViewI->v_data_is_set)
    {
        err = downloadView(lpD3DViewI);
        if (err != D3D_OK)
        {
            this->lpCurrentViewport = lpOldViewportI;
            return err;
        }
    }

    if(lpOldViewportI!=NULL)
      lpOldViewportI->Release();

    this->lpCurrentViewport->AddRef();

    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetCurrentViewport"

HRESULT D3DAPI DIRECT3DDEVICEI::GetCurrentViewport(LPDIRECT3DVIEWPORT2 *lpViewport)
{
    return GetCurrentViewport((LPDIRECT3DVIEWPORT3*)lpViewport);
}

HRESULT D3DAPI DIRECT3DDEVICEI::GetCurrentViewport(LPDIRECT3DVIEWPORT3 *lpViewport)
{
    LPDIRECT3DVIEWPORTI lpD3DViewI;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        lpD3DViewI = (LPDIRECT3DVIEWPORTI)lpViewport;
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_PTR_PTR(lpViewport))
        {
            D3D_ERR( "Invalid viewport pointer passed to GetCurrentViewport" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in GetCurrentViewport" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "GetCurrentViewport in Begin" );
        return D3DERR_INBEGIN;
    }

    if (VALID_DIRECT3DVIEWPORT3_PTR(this->lpCurrentViewport))
    {
        this->lpCurrentViewport->AddRef();
        *lpViewport = (LPDIRECT3DVIEWPORT3)this->lpCurrentViewport;
        return D3D_OK;
    }
    else
    {
        return D3DERR_NOCURRENTVIEWPORT;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetRenderState"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetRenderState(D3DRENDERSTATETYPE dwState, DWORD value)
{
    // Takes D3D lock (MT only).
    // Lock released in the destructor.
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));

#if DBG

#ifdef DEBUG_PIPELINE
    extern void SetDebugRenderState(DWORD value);
    if (dwState == (D3DRENDERSTATETYPE)0xFFFFFFFF)
    {
        SetDebugRenderState(value);
        return D3D_OK;
    }
#endif
#endif  //DBG range check below is needed for backward comp with DX5

    if (dwState >= D3DHAL_MAX_RSTATES || dwState == 0)
    {
        D3D_ERR( "Invalid render state type" );
        return DDERR_INVALIDPARAMS;
    }

#if DBG
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in SetRenderState" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "SetRenderState in Begin" );
        return D3DERR_INBEGIN;
    }
#endif
    if (D3DRENDERSTATE_FLUSHBATCH == dwState)
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                        // Release in the destructor
        HRESULT ret;
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in SetRenderState");
            return ret;
        }

        return D3D_OK;
    }

    // map legacy renderstate into WRAP0 - needed for clipping if nothing else
    if ( (D3DRENDERSTATE_WRAPU == dwState) || (D3DRENDERSTATE_WRAPV == dwState) )
    {
        DWORD dwWRAP0State = this->rstates[D3DRENDERSTATE_WRAP0];
        DWORD dwWrapFlag = (D3DRENDERSTATE_WRAPU == dwState) ? (D3DWRAP_U) : (D3DWRAP_V);
        if (value) dwWRAP0State |= dwWrapFlag;
        else         dwWRAP0State &= ~dwWrapFlag;
        if ( dwWRAP0State != this->rstates[D3DRENDERSTATE_WRAP0] )
        {
            SetDeviceRenderState(this, D3DRENDERSTATE_WRAP0, dwWRAP0State);
            // send new RS's to DX6 aware drivers only
            if (IS_DP2HAL_DEVICE(this))
            {
                SetRenderStateI(D3DRENDERSTATE_WRAP0, dwWRAP0State);
            }
        }
    }

    // map WRAP0 into legacy renderstate
    if (D3DRENDERSTATE_WRAP0 == dwState)
    {
        if (!(IS_DP2HAL_DEVICE(this)))
        {
            BOOLEAN ustate = (value & D3DWRAP_U) ? TRUE : FALSE;
            BOOLEAN vstate = (value & D3DWRAP_V) ? TRUE : FALSE;
            if (this->rstates[D3DRENDERSTATE_WRAPU] == ustate &&
                this->rstates[D3DRENDERSTATE_WRAPV] == vstate)
            {
                D3D_WARN(4,"Ignoring redundant SetRenderState");
            }
            else
            {
                SetDeviceRenderState(this, D3DRENDERSTATE_WRAPU, ustate);
                SetRenderStateI(D3DRENDERSTATE_WRAPU, ustate);
                SetDeviceRenderState(this, D3DRENDERSTATE_WRAPV, vstate);
                SetRenderStateI(D3DRENDERSTATE_WRAPV, vstate);
            }
        }
    }

    if (this->rstates[dwState] == value && IS_DP2HAL_DEVICE(this))
    {
        D3D_WARN(4,"Ignoring redundant SetRenderState");
        return D3D_OK;
    }

    /* Save latest state for GetRenderState() */
    SetDeviceRenderState(this, dwState, value);

    return SetRenderStateI(dwState, value);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIHW::SetRenderStateI"

HRESULT D3DAPI
CDirect3DDeviceIHW::SetRenderStateI(D3DRENDERSTATETYPE dwState, DWORD value)
{
    LPDWORD lpRS;
    if (dwState > D3DRENDERSTATE_STIPPLEPATTERN31)
    {
        D3D_WARN(4,"Trying to send invalid state %d to legacy driver",dwState);
        return D3D_OK;
    }
    if (dwState > D3DRENDERSTATE_FLUSHBATCH && dwState < D3DRENDERSTATE_STIPPLEPATTERN00)
    {
        D3D_WARN(4,"Trying to send invalid state %d to legacy driver",dwState);
        return D3D_OK;
    }
    if ( this->dwHWOffset + 8 >= dwHWBufferSize )
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                        // Release in the destructor
        HRESULT ret;
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in BeginIndexed");
            return ret;
        }
    }
    if (this->lpHWCounts[this->dwHWNumCounts].wNumVertices)
    {
        this->dwHWNumCounts += 1;
        memset(&this->lpHWCounts[this->dwHWNumCounts], 0, sizeof(D3DI_HWCOUNTS) );
    }

    lpRS = (LPDWORD) (((char *) this->lpHWVertices) + this->dwHWOffset);
    lpRS[0] = dwState;
    lpRS[1] = value;
    this->lpHWCounts[this->dwHWNumCounts].wNumStateChanges += 1;
    this->dwHWOffset += 8;

    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetRenderState"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetRenderState(D3DRENDERSTATETYPE dwState, LPDWORD lpdwValue)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                    // Release in the destructor

    if (dwState >= D3DHAL_MAX_RSTATES || dwState == 0) {
        D3D_ERR( "Invalid render state value" );
        return DDERR_INVALIDPARAMS;
    }

    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_PTR(lpdwValue, sizeof(DWORD)))
        {
            D3D_ERR( "Invalid DWORD pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    *lpdwValue = this->rstates[dwState];
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetTexture"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetTexture(DWORD dwStage, LPDIRECT3DTEXTURE2 *lplpTex)
{
    // Takes D3D lock (MT only).
    // Lock released in the destructor.
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));

#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }
#endif

    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_PTR(lplpTex, sizeof(DWORD)))
        {
            D3D_ERR( "Invalid DWORD pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    // Don't bother to check for DX6 support, just return the
    // cached value.
    *lplpTex = lpD3DMappedTexI[dwStage];
    if (*lplpTex)   (*lplpTex)->AddRef();
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetTexture"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetTexture(DWORD dwStage, LPDIRECT3DTEXTURE2 lpTex)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));
#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }

    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
#endif

    if (lpD3DMappedTexI[dwStage] == (LPDIRECT3DTEXTUREI)lpTex)
    {
        return  D3D_OK;
    }

#if DBG
    if (lpTex)
    {
        LPDIRECT3DTEXTUREI  lpTexI= (LPDIRECT3DTEXTUREI)lpTex;
        HRESULT ret;
        if (
            (!lpTexI->lpDDSSys)
            && (lpTexI->DDSInt4.lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
            && (!(lpD3DHALGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_TEXTURESYSTEMMEMORY))
            )
        {
            D3D_ERR( "Device cannot render using texture surface from system memory" );
            return DDERR_INVALIDPARAMS;
        }
        ret=VerifyTextureCaps(this, &lpTexI->DDSInt4);
        if (D3D_OK != ret)
        {
            return  ret;
        }
    }
#endif

    LPDDRAWI_DDRAWSURFACE_INT   surf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   surf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   surf_gbl;
    // we are ssumeing lpTex->lpOwningIUnknown is always a LPDDRAWI_DDRAWSURFACE_INT
    // if in the future when texture is not aggregated on ddraw surface, change is needed here
    if (lpD3DMappedTexI[dwStage])
    {   //the following is a hack of Surface Release() for perf reason
        surf_int=(LPDDRAWI_DDRAWSURFACE_INT)lpD3DMappedTexI[dwStage]->lpOwningIUnknown;
        if (surf_int->dwIntRefCnt > 1)  // only do this short way when it's not going away
        {
            surf_lcl=surf_int->lpLcl;
            surf_gbl=surf_lcl->lpGbl;
            surf_gbl->dwRefCnt--;
            surf_lcl->dwLocalRefCnt--;
            surf_int->dwIntRefCnt--;
        }
        else
            lpD3DMappedTexI[dwStage]->Release();
    }

    lpD3DMappedTexI[dwStage] = (LPDIRECT3DTEXTUREI)lpTex;
    if (lpTex)
    {   //the following is a hack of lpTex->AddRef() for perf reason
        surf_int=(LPDDRAWI_DDRAWSURFACE_INT)((LPDIRECT3DTEXTUREI)lpTex)->lpOwningIUnknown;
        surf_lcl=surf_int->lpLcl;
        surf_gbl=surf_lcl->lpGbl;
        surf_gbl->dwRefCnt++;
        surf_lcl->dwLocalRefCnt++;
        surf_int->dwIntRefCnt++;
        lpD3DMappedBlock[dwStage] = NULL;
    }
    else
    {
        lpD3DMappedBlock[dwStage] = (LPD3DI_TEXTUREBLOCK)TRUE;  //indicate a dirty if lpTex==NULL
    }
    if (this->tsstates[dwStage][D3DTSS_COLOROP] != D3DTOP_DISABLE)
    {
        this->dwFVFLastIn = 0;  // Force to recompute outputVID
        this->dwFEFlags |= D3DFE_TSSINDEX_DIRTY;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetTextureStageState"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetTextureStageState(DWORD dwStage,
                                      D3DTEXTURESTAGESTATETYPE dwState,
                                      LPDWORD pdwValue)
{
    // Takes D3D lock (MT only).
    // Lock released in the destructor.
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));

#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES ||
        dwState == 0 || dwState >= D3DTSS_MAX)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }
#endif  //DBG

    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_PTR(pdwValue, sizeof(DWORD)))
        {
            D3D_ERR( "Invalid DWORD pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    // Don't bother to check for DX6 support, just return the
    // cached value.
    *pdwValue = tsstates[dwStage][dwState];
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::CreateDevice"

extern HRESULT WINAPI Direct3DCreateDevice(REFCLSID            riid,
                                           LPUNKNOWN           lpDirect3D,
                                           LPDIRECTDRAWSURFACE lpDDSTarget,
                                           LPUNKNOWN*          lplpD3DDevice,
                                           IUnknown*           pUnkOuter,
                                           DWORD               dwVersion);

HRESULT D3DAPI DIRECT3DI::CreateDevice(REFCLSID devType,
                                       LPDIRECTDRAWSURFACE4 lpDDS4,
                                       LPDIRECT3DDEVICE3 *lplpDirect3DDevice3,
                                       LPUNKNOWN pUnkOuter) {
    HRESULT ret;
    LPUNKNOWN lpUnkDevice;
    LPDIRECTDRAWSURFACE lpDDS;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    TRY
    {
        if (!VALID_DIRECT3D3_PTR(this)) {
            D3D_ERR( "Invalid Direct3D pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(lplpDirect3DDevice3)) {
            D3D_ERR( "Invalid pointer to Device object pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_D3D_DIRECTDRAWSURFACE4_PTR(((LPDDRAWI_DDRAWSURFACE_INT)lpDDS4)))
        {
            D3D_ERR( "Invalid DirectDrawSurface4 pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in CreateDevice" );
        return DDERR_INVALIDPARAMS;
    }

    if (pUnkOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION;
    }

    *lplpDirect3DDevice3=NULL;

    // QI lpDDS4 for lpDDS interface
    ret = lpDDS4->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&lpDDS);
    if (FAILED(ret))
        return ret;
    lpDDS->Release();

    ret = Direct3DCreateDevice(devType, &this->mD3DUnk, lpDDS, (LPUNKNOWN *) &lpUnkDevice, NULL, 3);

    if(FAILED(ret) || (lpUnkDevice==NULL))
      return ret;

    // QI device1 for a device3 interface
    ret = lpUnkDevice->QueryInterface(IID_IDirect3DDevice3, (LPVOID*)lplpDirect3DDevice3);

    lpUnkDevice->Release();  // release unneeded interface

    return ret;
}

HRESULT D3DAPI DIRECT3DI::CreateDevice(REFCLSID devType,
                                       LPDIRECTDRAWSURFACE lpDDS,
                                       LPDIRECT3DDEVICE2 *lplpDirect3DDevice2)
{
    HRESULT ret;
    LPUNKNOWN lpUnkDevice;
    ULONG refcnt;

    TRY
    {
        if (!VALID_DIRECT3D3_PTR(this)) {
            D3D_ERR( "Invalid Direct3D pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALID_OUTPTR(lplpDirect3DDevice2)) {
            D3D_ERR( "Invalid pointer to Device object pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_D3D_DIRECTDRAWSURFACE_PTR(((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)))
        {
            D3D_ERR( "Invalid DirectDrawSurface pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in CreateDevice" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpDirect3DDevice2=NULL;

    // Create a device3 object
    ret = Direct3DCreateDevice(devType, &this->mD3DUnk, lpDDS, (LPUNKNOWN *) &lpUnkDevice, NULL, 2);

    if(FAILED(ret) || (lpUnkDevice==NULL)) {
       return ret;
    }

    // QI it for a device2 interface
    ret = lpUnkDevice->QueryInterface(IID_IDirect3DDevice2, (LPVOID*)lplpDirect3DDevice2);

    lpUnkDevice->Release();  // releasing unneeded interface

    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetLightState"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetLightState(D3DLIGHTSTATETYPE dwState, DWORD value)
{
    HRESULT                         ret = D3D_OK;
    D3DSTATE                        state;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    state.dlstLightStateType = dwState;
    state.dwArg[0] = value;

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "SetLightState in Begin" );
        return D3DERR_INBEGIN;
    }

    return D3DHELInst_D3DOP_STATELIGHT(this, 1, &state);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetLightState"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetLightState(D3DLIGHTSTATETYPE dwState, LPDWORD lpValue)
{

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    float* lpfValue = (float*)lpValue;
#if DBG
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_PTR(lpValue, sizeof(DWORD)))
        {
            D3D_ERR( "Invalid DWORD pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in GetLightState" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "GetLightState in Begin" );
        return D3DERR_INBEGIN;
    }
#endif
    switch (dwState)
    {
    case D3DLIGHTSTATE_MATERIAL:
        *lpValue = (DWORD)this->lighting.hMat;
        break;
    case D3DLIGHTSTATE_AMBIENT:
        *lpValue = this->lighting.ambient_save;
        break;
    case D3DLIGHTSTATE_FOGMODE:
        *lpValue = this->lighting.fog_mode;
        break;
    case D3DLIGHTSTATE_FOGSTART:
        *lpfValue = this->lighting.fog_start;
        break;
    case D3DLIGHTSTATE_FOGEND:
        *lpfValue = this->lighting.fog_end;
        break;
    case D3DLIGHTSTATE_FOGDENSITY:
        *lpfValue = this->lighting.fog_density;
        break;
    case D3DLIGHTSTATE_COLORMODEL:
        *lpValue = this->lighting.color_model;
        break;
    case D3DLIGHTSTATE_COLORVERTEX:
        // return value for Device3 only
        if (dwVersion == 3)
        {
            *lpValue = (0x0 != (dwFEFlags & D3DFE_COLORVERTEX));
            break;
        }
        // else fall through to error return
    default:
        D3D_ERR( "Invalid state value passed to GetLightState" );
        return DDERR_INVALIDPARAMS; /* Do we return an error code or should we just ignore ? */
    }
    return D3D_OK;
}

/*
    transform matrix functions
*/

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetTransform"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetTransform(D3DTRANSFORMSTATETYPE dtsTransformState, LPD3DMATRIX lpMat)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                    // Release in the destructor
    HRESULT ret = D3D_OK;
    D3DFE_TRANSFORM *lpHelTransform = &this->transform;
#if DBG
    if (!lpMat) {
        D3D_ERR( "NULL matrix pointer passed to SetTransform" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "SetTransform in Begin" );
        return D3DERR_INBEGIN;
    }
#endif
    switch (dtsTransformState)
    {
    case D3DTRANSFORMSTATE_WORLD      : D3DFE_SetMatrixWorld(this, lpMat); break;
    case D3DTRANSFORMSTATE_VIEW       : D3DFE_SetMatrixView(this, lpMat); break;
    case D3DTRANSFORMSTATE_PROJECTION :
        D3DFE_SetMatrixProj(this, lpMat);
        if ((ret = this->UpdateDrvWInfo()) != DD_OK)
        {
            return ret;
        }
        break;
    default :
        D3D_ERR( "Invalid state value passed to SetTransform" );
        ret = DDERR_INVALIDPARAMS; /* Work Item: Generate new meaningful return code */
        break;
    }

    return ret;
}       // end of D3DDev_SetTransform()


#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetTransform"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetTransform(D3DTRANSFORMSTATETYPE dtsTransformState, LPD3DMATRIX lpMat)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                    // Release in the destructor
    HRESULT ret = D3D_OK;
    D3DFE_TRANSFORM *lpHelTransform;
#if DBG
    if (!lpMat) {
        D3D_ERR( "NULL matrix pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "GetTransform in Begin" );
        return D3DERR_INBEGIN;
    }
#endif
    lpHelTransform = &this->transform;
    switch (dtsTransformState) {
    case D3DTRANSFORMSTATE_WORLD :
        *lpMat = *(LPD3DMATRIX)&lpHelTransform->world._11;
        break;
    case D3DTRANSFORMSTATE_VIEW :
        *lpMat = *(LPD3DMATRIX)&lpHelTransform->view._11;
        break;
    case D3DTRANSFORMSTATE_PROJECTION :
        *lpMat = *(LPD3DMATRIX)&lpHelTransform->proj._11;
        break;
    default :
        D3D_ERR( "Invalid state value passed to GetTransform" );
        ret = DDERR_INVALIDPARAMS; /* Work Item: Generate new meaningful return code */
        break;
    }

    return ret;
}       // end of D3DDev2_GetTransform()


#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::MultiplyTransform"

/*
    MultiplyTransform -- this preconcatenates the new matrix to the specified transform matrix

        this really screams for overloaded matrix ops...
*/
HRESULT D3DAPI
DIRECT3DDEVICEI::MultiplyTransform(D3DTRANSFORMSTATETYPE dtsTransformState, LPD3DMATRIX lpMat)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                    // Release in the destructor
    HRESULT         ret = D3D_OK;
    D3DFE_TRANSFORM *lpHelTransform;
#if DBG
    if (!lpMat) {
        D3D_ERR( "NULL matrix pointer passed to MultiplyTransform" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "MultiplyTransform in Begin" );
        return D3DERR_INBEGIN;
    }
#endif
    lpHelTransform = &this->transform;
    switch (dtsTransformState)
    {
    case D3DTRANSFORMSTATE_WORLD      : D3DFE_MultMatrixWorld(this, lpMat); break;
    case D3DTRANSFORMSTATE_VIEW       : D3DFE_MultMatrixView(this, lpMat); break;
    case D3DTRANSFORMSTATE_PROJECTION : D3DFE_MultMatrixProj(this, lpMat); break;
    default :
        D3D_ERR( "Invalid state value passed to MultiplyTransform" );
        ret = DDERR_INVALIDPARAMS; /* Work Item: Generate new meaningful return code */
        return ret;
    }
    return ret;
}       // end of D3DDev2_MultiplyTransform()

void InvalidateHandles(LPDIRECT3DDEVICEI lpDevI)
{
    /* free up all textures created by this object */
    LPD3DI_TEXTUREBLOCK tBlock=LIST_FIRST(&lpDevI->texBlocks);
    while (tBlock)
    {
        D3DI_RemoveTextureHandle(tBlock);
        tBlock=LIST_NEXT(tBlock,devList);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetRenderTarget"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetRenderTarget(LPDIRECTDRAWSURFACE lpDDS, DWORD dwFlags) {

  LPDIRECTDRAWSURFACE4 lpDDS4;
  HRESULT ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    TRY
    {
        if (!VALID_DIRECT3DDEVICE2_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice2 pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALID_D3D_DIRECTDRAWSURFACE_PTR((LPDDRAWI_DDRAWSURFACE_INT)lpDDS))
        {
            D3D_ERR( "Invalid DirectDrawSurface pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in SetRenderTarget" );
        return DDERR_INVALIDPARAMS;
    }

    /* Make sure this device was not aggregated from DDS (DX3-style) */
    if ((LPDIRECTDRAWSURFACE)this->lpOwningIUnknown==this->lpDDSTarget)
    {
        D3D_ERR("Cannot change render target on old device (those QI'ed from a ddraw-surface");
        return D3DERR_DEVICEAGGREGATED;
    }

    // QI lpDDS for lpDDS4 interface, which will be used internally by D3D
    ret = lpDDS->QueryInterface(IID_IDirectDrawSurface4, (LPVOID*)&lpDDS4);

    if(FAILED(ret))
      return ret;

    // SetRenderTarget AddRef'd the DDS4 interface, so it's safe to release it here and decrmt the refcnt
    lpDDS4->Release();

    ret=this->SetRenderTarget(lpDDS4,dwFlags);

    return ret;
}

HRESULT D3DAPI
DIRECT3DDEVICEI::SetRenderTarget(LPDIRECTDRAWSURFACE4 lpDDS4, DWORD dwFlags)
{
    DDSCAPS2 ddscaps;
    DDSURFACEDESC2 ddsd;
    HRESULT     ret, ddrval;
    LPDIRECTDRAWSURFACE lpZ=NULL,lpDDS=NULL;
    LPDIRECTDRAWSURFACE4 lpZ_DDS4=NULL;
    LPDIRECTDRAWPALETTE lpPal=NULL;
    DWORD i, j;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALID_D3D_DIRECTDRAWSURFACE4_PTR(((LPDDRAWI_DDRAWSURFACE_INT)lpDDS4)))
        {
            D3D_ERR( "Invalid DirectDrawSurface4 pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in SetRenderTarget" );
        return DDERR_INVALIDPARAMS;
    }

    // Flush before switching RenderTarget..
    ret = FlushStates();
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to FlushStates in SetRenderTarget");
        return ret;
    }

    /* Make sure this device was not aggregated from DDS (DX3-style) */
    if ((LPDIRECTDRAWSURFACE)this->lpOwningIUnknown==this->lpDDSTarget)
    {
        D3D_ERR("Cannot change render target on device QI'ed from DDS");
        return D3DERR_DEVICEAGGREGATED;
    }

    /*
     * Check if the 3D cap is set on the surface.
     */
    memset(&ddsd, 0, sizeof ddsd);
    ddsd.dwSize = sizeof ddsd;
    ddrval = lpDDS4->GetSurfaceDesc(&ddsd);
    if (ddrval != DD_OK)
    {
        D3D_ERR("Failed to get surface description of device's surface.");
        return (ddrval);
    }

    if (!(ddsd.ddsCaps.dwCaps & DDSCAPS_3DDEVICE))
    {
        D3D_ERR("**** The DDSCAPS_3DDEVICE is not set on this surface.");
        D3D_ERR("**** You need to add DDSCAPS_3DDEVICE to ddsCaps.dwCaps");
        D3D_ERR("**** when creating the surface.");
        return (DDERR_INVALIDCAPS);
    }
    if (!(this->lpD3DHALGlobalDriverData->hwCaps.dwDeviceRenderBitDepth & BitDepthToDDBD(ddsd.ddpfPixelFormat.dwRGBBitCount))) {
        D3D_ERR("Rendering surface's RGB bit count not supported by hardware device");
        return (DDERR_INVALIDCAPS);
    }
    if (ddsd.dwWidth > 2048 || ddsd.dwHeight > 2048)
    {
        D3D_ERR("Surface dimension > 2048");
        return DDERR_INVALIDPARAMS;
    }

    /* The z-buffer... */
    ddscaps.dwCaps = DDSCAPS_ZBUFFER;
    ret = lpDDS4->GetAttachedSurface(&ddscaps, &lpZ_DDS4);
    if ((ret != DD_OK) && (ret != DDERR_NOTFOUND))
    {
        /*
         * NOTE: Not an error if the z-buffer is not found. We will let the
         * dirver handle that (it might fail or create its own z-buffer).
         */
        D3D_ERR("Supplied DirectDraw Z-Buffer is invalid - can't set render target");
        ret=DDERR_INVALIDPARAMS;
        goto handle_error;
    }
    if (lpZ_DDS4)
        lpZ_DDS4->Release(); // We do not need to addref this one;

    // QI lpDDS4 for lpDDS interface, which will be used internally by D3D
    ret = lpDDS4->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&lpDDS);

    if(FAILED(ret))
      goto handle_error;

    /* The palette... */
    ret = lpDDS->GetPalette(&lpPal);
    if ((ret != DD_OK) && (ret != DDERR_NOPALETTEATTACHED))
    {
        /*
         * NOTE: Again, not an error (yet) if there is no palette attached.
         * But if there is palette and we can't get at it for some reason
         * - fail.
         */
        D3D_ERR("Supplied DirectDraw Palette is invalid - can't create device");
        ret=DDERR_INVALIDPARAMS;
        goto handle_error;
    }

    /*
     * We're going to check now whether we should have got a palette.
     */
    if (ret == DDERR_NOPALETTEATTACHED)
    {
        if (ddsd.ddpfPixelFormat.dwRGBBitCount < 16)
        {
            D3D_ERR("No palette supplied for palettized surface");
            ret=DDERR_NOPALETTEATTACHED;
            goto handle_error;
        }
    }

    /* Verify Z buffer */

    if (lpZ_DDS4!=NULL)
    {
        memset(&ddsd, 0, sizeof(ddsd));
        ddsd.dwSize = sizeof(ddsd);
        if ((ret=lpZ_DDS4->GetSurfaceDesc(&ddsd)) != DD_OK)
        {
            D3D_ERR("Failed to getsurfacedesc on Z");
            goto handle_error;
        }

        // QI lpDDS4 for lpDDS interface, which will be used internally by D3D
        ret = lpZ_DDS4->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&lpZ);

        if(FAILED(ret))
          goto handle_error;
    }
    else
    {
        if (this->lpDDSZBuffer)
        {
            D3D_ERR("Current rendertarget contains ZBuffer, but new one does not!");
            ret=DDERR_INVALIDPARAMS;
            goto handle_error;
        }
    }
    if (IS_DX7HAL_DEVICE(this))
    {
        static_cast<CDirect3DDeviceIDP2*>(this)->SetRenderTargetI(lpDDS, lpZ);
    }
    else
    if (this->lpD3DHALCallbacks2->SetRenderTarget)
    {
        D3DHAL_SETRENDERTARGETDATA rtData;

        rtData.dwhContext = this->dwhContext;
#ifndef WIN95
        if (dwFEFlags & D3DFE_REALHAL)
        {
            if (lpDDS)
                rtData.lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl;
            else
                rtData.lpDDSLcl = NULL;
            
            if (lpZ)
                rtData.lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpZ)->lpLcl;
            else
                rtData.lpDDSZLcl = NULL;
        }
        else
#endif //WIN95
        {
            rtData.lpDDS = lpDDS;
            rtData.lpDDSZ = lpZ;
        }
        rtData.ddrval = 0;
        CALL_HAL2ONLY(ret, this, SetRenderTarget, &rtData);
        if ((ret != DDHAL_DRIVER_HANDLED) || (rtData.ddrval != DD_OK))
        {
            D3D_ERR( "Driver call failed in SetRenderTarget" );
            // Need sensible return value in this case,
            // currently we return whatever the driver stuck in here.
            ret = rtData.ddrval;
            goto handle_error;
        }
    }
    else
    {
        D3DHAL_CONTEXTCREATEDATA cdata;
        D3DHAL_CONTEXTDESTROYDATA ddata;

        /* Destroy old context */
        memset(&ddata, 0, sizeof(D3DHAL_CONTEXTDESTROYDATA));
        ddata.dwhContext = this->dwhContext;

        CALL_HALONLY(ret, this, ContextDestroy, &ddata);
        if (ret != DDHAL_DRIVER_HANDLED || ddata.ddrval != DD_OK)
        {
            DPF(0, "(ERROR) ContextDestroy. Failed. dwhContext = %d", ddata.dwhContext);
            // Need sensible return value in this case,
            // currently we return whatever the driver stuck in here.
            ret = ddata.ddrval;
            goto handle_error;
        }

        /* Create new context */
        memset(&cdata, 0, sizeof(D3DHAL_CONTEXTCREATEDATA));

#ifndef WIN95
        if (dwFEFlags & D3DFE_REALHAL)
        {
            if (this->lpDD)
                cdata.lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)(this->lpDD))->lpLcl; 
            else
                cdata.lpDDLcl = NULL;
            
            if (lpDDS)
                cdata.lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl;
            else
                cdata.lpDDSLcl = NULL;
            
            if (lpZ)
                cdata.lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpZ)->lpLcl;
            else
                cdata.lpDDSZLcl = NULL;
            
        }
        else
#endif //WIN95
        {
            cdata.lpDDGbl = this->lpDDGbl; 
            cdata.lpDDS = lpDDS;
            cdata.lpDDSZ = lpZ;
        }

        cdata.dwPID = GetCurrentProcessId();

        CALL_HALONLY(ret, this, ContextCreate, &cdata);
        if (ret != DDHAL_DRIVER_HANDLED || cdata.ddrval != DD_OK)
        {
            D3D_ERR("HAL call to ContextCreate failed in SetRenderTarget");
            // Need sensible return value in this case,
            // currently we return whatever the driver stuck in here.
            return cdata.ddrval;
        }
        this->dwhContext = cdata.dwhContext;
        D3D_INFO(9, "in halCreateContext. Succeeded. dwhContext = %d", cdata.dwhContext);

        /* Set up renderstates */
        // note we can't do a loop from 1 to D3DHAL_MAX_RSTATES(256) as some of rstates are not
        // valid states, passin them down to drivers(like voodoo2 DX6 driver) will crash.
        for (i= 1 ; i<  D3DRENDERSTATE_WRAPBIAS+8; ++i)
        {
            this->SetRenderStateI((D3DRENDERSTATETYPE)i, this->rstates[i]);
        }
        if ( IS_DP2HAL_DEVICE(this) ) {
            CDirect3DDeviceIDP2 *dp2dev = static_cast<CDirect3DDeviceIDP2 *>(this);
            for (i=0; i<dwMaxTextureBlendStages; ++i)
                for (j=0; j<D3DTSS_MAX; ++j)
                {
                    D3D_INFO(6,"Calling SetTSSI(%d,%d,%08lx)",i,j,this->tsstates[i][j]);
                    dp2dev->SetTSSI(i, (D3DTEXTURESTAGESTATETYPE)j, this->tsstates[i][j]);
                }
        }
    }

    if (this->lpDDSTarget)
    UnHookD3DDeviceFromSurface(this,((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSTarget)->lpLcl);  //unhook previous surfaces if any
    if (this->lpDDSZBuffer)
    UnHookD3DDeviceFromSurface(this,((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSZBuffer)->lpLcl); //unhook previous surfaces if any

    if (DDERR_OUTOFMEMORY == (ret=HookD3DDeviceToSurface(this, ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS4)->lpLcl)))
    {
            goto handle_error;
    }
    if (lpZ_DDS4 && (DDERR_OUTOFMEMORY == (ret=HookD3DDeviceToSurface(this, ((LPDDRAWI_DDRAWSURFACE_INT) lpZ_DDS4)->lpLcl))))
    {
        UnHookD3DDeviceFromSurface(this, ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS4)->lpLcl);
        goto handle_error;
    }
    // release old device DDS/DDS4 interfaces and replace with the new ones,
    // which are mostly already AddRef'd (except for lpDDS4)

    /// DDSZBuffer ///
    if(this->lpDDSZBuffer)
      this->lpDDSZBuffer->Release();

    // lpZ AddRef'd by QI
    this->lpDDSZBuffer = lpZ;

    /// DDSZBuffer DDS4 ///
    this->lpDDSZBuffer_DDS4=lpZ_DDS4; // This needs no AddRef or Release

    ///  DDSTarget  ///
    if (this->dwVersion == 2)
    {
        this->lpDDSTarget->Release();
        // lpDDS AddRef'd by QI
        this->lpDDSTarget = lpDDS;
    }
    else
    {
        this->lpDDSTarget = lpDDS;
        // lpDDS AddRef'd by QI so release it
        this->lpDDSTarget->Release();
    }
#ifndef WIN95
    hSurfaceTarget = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl->hDDSurface;
    D3D_INFO(6,"in SetRenderTarget hSurfaceTarget=%08lx lpDDSTarget=%08lx",hSurfaceTarget,lpDDSTarget);
#else
    hSurfaceTarget = (unsigned long)((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl->lpSurfMore->dwSurfaceHandle;
    D3D_INFO(6,"in SetRenderTarget hSurfaceTarget=%08lx lpDDSTarget=%08lx",hSurfaceTarget,lpDDSTarget);
#endif
    ///  DDSTarget DDS4  ///
    if (this->dwVersion == 3)
    {
        this->lpDDSTarget_DDS4->Release();
        lpDDS4->AddRef();  // ensure lpDDS4 (which was an argument) doesnt disappear
    }
    this->lpDDSTarget_DDS4=lpDDS4;

    if (this->lpDDPalTarget)
      this->lpDDPalTarget->Release();

    // already AddRef'd by GetPalette()
    this->lpDDPalTarget = lpPal;

    InvalidateHandles(this);

    if( FAILED( ret=CalcDDSurfInfo(this,FALSE) ) )
        goto handle_error;
    
    return ret;

 handle_error:

    if(lpPal)
      lpPal->Release();
    if(lpZ)
      lpZ->Release();
    if(lpZ_DDS4)
      lpZ_DDS4->Release();
    if(lpDDS)
      lpDDS->Release();

    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetRenderTarget"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetRenderTarget(LPDIRECTDRAWSURFACE* lplpDDS) {

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    TRY
    {
        if (!VALID_DIRECT3DDEVICE2_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice2 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if ( !VALID_OUTPTR( lplpDDS ) )
        {
            D3D_ERR( "Invalid ptr to DDS ptr" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpDDS = this->lpDDSTarget;

    this->lpDDSTarget->AddRef();
    return D3D_OK;

}

HRESULT D3DAPI
DIRECT3DDEVICEI::GetRenderTarget(LPDIRECTDRAWSURFACE4* lplpDDS)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if ( !VALID_OUTPTR( lplpDDS ) )
        {
            D3D_ERR( "Invalid ptr to DDS ptr" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpDDS = this->lpDDSTarget_DDS4;

    this->lpDDSTarget_DDS4->AddRef();
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetClipStatus"

#define D3DSTATUS_VALID 0x80000000L /* Reserved Status flag to indicate SetClipStatus is called */

HRESULT D3DAPI DIRECT3DDEVICEI::SetClipStatus(LPD3DCLIPSTATUS status)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                    // Release in the destructor
#if DBG
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (! VALID_PTR(status, sizeof(D3DCLIPSTATUS)) )
        {
            D3D_ERR( "Invalid status pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "SetClipStatus in Begin" );
        return D3DERR_INBEGIN;
    }
#endif
    // D3DCLIPSTATUS_EXTENTS3 not supported in Device3
    if (dwVersion == 3 && status->dwFlags & D3DCLIPSTATUS_EXTENTS3)
    {
        D3D_ERR( "D3DCLIPSTATUS_EXTENTS3 not supported for Device3" );
        return DDERR_INVALIDPARAMS;
    }
    if (status->dwFlags & D3DCLIPSTATUS_STATUS)
        this->iClipStatus = status->dwStatus;

    if (status->dwFlags & (D3DCLIPSTATUS_EXTENTS2 | D3DCLIPSTATUS_EXTENTS3))
    {
        this->rExtents.x1 = status->minx;
        this->rExtents.y1 = status->miny;
        this->rExtents.x2 = status->maxx;
        this->rExtents.y2 = status->maxy;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetClipStatus"

HRESULT D3DAPI DIRECT3DDEVICEI::GetClipStatus(LPD3DCLIPSTATUS status)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                    // Release in the destructor
#if DBG
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (! VALID_PTR(status, sizeof(D3DCLIPSTATUS)) )
        {
            D3D_ERR( "Invalid status pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    if (dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "GetClipStatus in Begin" );
        return D3DERR_INBEGIN;
    }
#endif
    status->dwStatus = iClipStatus;
    status->dwFlags = D3DCLIPSTATUS_EXTENTS2;
    status->minx = this->rExtents.x1;
    status->miny = this->rExtents.y1;
    status->maxx = this->rExtents.x2;
    status->maxy = this->rExtents.y2;
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::UpdateTextures"

HRESULT DIRECT3DDEVICEI::UpdateTextures()
{
    BOOL    bFlushed=FALSE;
    DWORD   dwStage;
    D3DTEXTUREHANDLE    dwDDIHandle;
    LPDIRECT3DTEXTUREI  lpTexI;
    LPD3DI_TEXTUREBLOCK lpBlock;
    for (dwStage=0;dwStage < this->dwMaxTextureBlendStages; dwStage++)
    {
        lpTexI=this->lpD3DMappedTexI[dwStage];
        lpBlock=this->lpD3DMappedBlock[dwStage];
        if(lpTexI)
        {
            if (lpTexI->lpTMBucket)
            {
                if (lpTexI->bDirty)
                {
                    FlushD3DStates(((LPDDRAWI_DDRAWSURFACE_INT)(lpTexI->lpDDS))->lpLcl);
                    if (DD_OK != CopySurface(lpTexI->lpDDS,lpTexI->lpDDSSys,this->lpClipper))
                    {
                        D3D_ERR("Error copying surface while updating textures");
                    }
                    else
                    {
                        lpTexI->bDirty=FALSE;
                        D3D_INFO(4,"UpdateTextures: Dirty texture updated");
                    }
                }
            }
            if (lpBlock)
            {
                if (lpBlock->hTex)
                {
                    continue;   //nothing need to be done further
                }
            }

            GetTextureDDIHandle(lpTexI, this, &lpBlock);
            this->lpD3DMappedBlock[dwStage]=lpBlock;
            if (lpBlock)
            {
                dwDDIHandle = lpBlock->hTex;
                if (dwDDIHandle)
                {
                    if(lpTexI->lpDDS != NULL)
                    {
                        BatchTextureToDevice(this, ((LPDDRAWI_DDRAWSURFACE_INT) lpTexI->lpDDS)->lpLcl);
                    }
                    else
                    {
                        BatchTextureToDevice(this, ((LPDDRAWI_DDRAWSURFACE_INT) lpTexI->lpDDSSys)->lpLcl);
                    }
                }
            }
            else
            {
                dwDDIHandle = 0;    //something is wrong we disable this texture
            }
        }
        else if (lpBlock)
        {
            this->lpD3DMappedBlock[dwStage]=NULL; //a SetTexture(Stage,NULL) issued
            dwDDIHandle = 0;    //tell driver to disable this texture
        }
        else
        {
            continue;   //both zero, no action needed
        }
        if (IS_DP2HAL_DEVICE(this))
        {
            CDirect3DDeviceIDP2 *dp2dev = static_cast<CDirect3DDeviceIDP2 *>(this);
            dp2dev->SetTSSI(dwStage, (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP, dwDDIHandle);
            // Update runtime copy of state.
            dp2dev->tsstates[dwStage][D3DTSS_TEXTUREMAP] = dwDDIHandle;
        }
        else
        {
            if(this->dwFEFlags & D3DFE_DISABLE_TEXTURES)
                break;
            CDirect3DDeviceIHW *dev = static_cast<CDirect3DDeviceIHW *>(this);
            (void)dev->SetRenderStateI(D3DRENDERSTATE_TEXTUREHANDLE, dwDDIHandle);
            // Update runtime copy of state.
            dev->rstates[D3DRENDERSTATE_TEXTUREHANDLE] = dwDDIHandle;
        }
    }
    return D3D_OK;
}

//---------------------------------------------------------------------
// This function is called from HALEXE.CPP, from device::SetRenderState and
// from device::SetTexture.
// Always use this function to update RSTATES.
//
HRESULT
SetDeviceRenderState(LPDIRECT3DDEVICEI lpDevI, D3DRENDERSTATETYPE type,
                     DWORD value)
{
    DWORD *rstates = lpDevI->rstates;
    switch (type)
    {
    case D3DRENDERSTATE_FOGENABLE:
        rstates[type] = value;      // set rstates BEFORE calling SetFogFlags
        SetFogFlags(lpDevI);
        break;
    case D3DRENDERSTATE_SPECULARENABLE:
            lpDevI->dwFEFlags |= D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY;
        lpDevI->dwFVFLastIn = 0; // Force re-computing of FVF id
        break;
    case D3DRENDERSTATE_TEXTUREHANDLE:
        if ((rstates[D3DRENDERSTATE_TEXTUREHANDLE] == 0) != (value == 0))
            lpDevI->dwFVFLastIn = 0;
        if (value)
            lpDevI->dwDeviceFlags |= D3DDEV_LEGACYTEXTURE;
        else
            lpDevI->dwDeviceFlags &= ~D3DDEV_LEGACYTEXTURE;


        break;
    }
    rstates[type] = value;      // set rstates for all other cases
    return D3D_OK;
}

#if DBG
static  char ProfileStr[PROF_DRAWINDEXEDPRIMITIVEVB+1][32]=
{
    "Execute",
    "Begin",
    "BeginIndexed",
    "DrawPrimitive(Device2)",
    "DrawIndexedPrimitive(Device2)",
    "DrawPrimitiveStrided",
    "DrawIndexedPrimitiveStrided",
    "DrawPrimitive(Device3)",
    "DrawIndexedPrimitive(Device3)",
    "DrawPrimitiveVB",
    "DrawIndexedPrimitiveVB",
};
static  char PrimitiveStr[D3DPT_TRIANGLEFAN][16]=
{
    "POINTLIST",
    "LINELIST",
    "LINESTRIP",
    "TRIANGLELIST",
    "TRIANGLESTRIP",
    "TRIANGLEFAN",
};
static  char VertexStr[D3DVT_TLVERTEX][16]=
{
    "D3DVERTEX",
    "D3DLVERTEX",
    "D3DTLVERTEX",
};
#define PROFILE_LEVEL 1

void    DIRECT3DDEVICEI::Profile(DWORD caller, D3DPRIMITIVETYPE dwPrimitive, DWORD dwVertex)
{
    DWORD   bitwisecaller= 1 << caller;
    DWORD   bitwisePrimitive = 1 << (DWORD)dwPrimitive;
    DWORD   bitwiseVertex1 = 1 << (dwVertex & 0x001F);
    DWORD   bitwiseVertex2 = 1 << ((dwVertex & 0x03E0) >> 5);
    char    str[256];
    DDASSERT(PROF_DRAWINDEXEDPRIMITIVEVB >= caller);
    DDASSERT(D3DPT_TRIANGLEFAN >= dwPrimitive && D3DPT_POINTLIST<= dwPrimitive);
    if (dwCaller & bitwisecaller)
    {
        if (dwPrimitiveType[caller] & bitwisePrimitive)
        {
            if ((dwVertexType1[caller] & bitwiseVertex1) &&
                (dwVertexType2[caller] & bitwiseVertex2))
            {
                return; //matching a previous api call, no spew, could count stat though
            }
            else
            {
                dwVertexType1[caller] |= bitwiseVertex1;
                dwVertexType2[caller] |= bitwiseVertex2;
            }
        }
        else
        {
            dwPrimitiveType[caller] |= bitwisePrimitive;
            dwVertexType1[caller] |= bitwiseVertex1;
            dwVertexType2[caller] |= bitwiseVertex2;
        }
    }
    else
    {
        this->dwCaller |= bitwisecaller;
        dwPrimitiveType[caller] |= bitwisePrimitive;
        dwVertexType1[caller] |= bitwiseVertex1;
        dwVertexType2[caller] |= bitwiseVertex2;
    }
    wsprintf( (LPSTR) str, ProfileStr[caller]);
    strcat(str,":");
    strcat(str,PrimitiveStr[dwPrimitive-1]);
    if (dwVertex > D3DVT_TLVERTEX)
    {
        if (dwVertex == D3DFVF_VERTEX)
        {
            dwVertex = D3DVT_VERTEX;
        }
        else
        if (dwVertex == D3DFVF_LVERTEX)
        {
            dwVertex = D3DVT_LVERTEX;
        }
        else
        if (dwVertex == D3DFVF_TLVERTEX)
        {
            dwVertex = D3DVT_TLVERTEX;
        }
        else
        {
            D3D_INFO(PROFILE_LEVEL,"Profile:%s FVFType=%08lx",str,dwVertex);
            return;
        }
    }
    else
    {
        DDASSERT(dwVertex >= D3DVT_VERTEX);
    }
    strcat(str,":");
    strcat(str,VertexStr[dwVertex-1]);
    D3D_INFO(PROFILE_LEVEL,"Profile:%s",str);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\genpick.cpp ===
/*
 *
 * Copyright (c) Microsoft Corp. 1997
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#include "pch.cpp"
#pragma hdrstop

#include "commdrv.hpp"


#define FILLSPAN(left, right, zleft, zstep, px, result)                 \
    do {                                                                \
        int x = FXTOI(left);                                            \
        int w = FXTOI(right) - x;                                       \
        if (w > 0) {                                                    \
            if ((x <= px) && (px < (x + w))) {                          \
                int t = px - x;                                         \
                int z = zleft + t * zstep;                              \
                *result = FXTOVAL(z >> 8);                              \
                return TRUE;                                            \
            }                                                           \
        }                                                               \
    } while (0)

int ZTFill1(int xl, int dxl,
                   int xr, int dxr,
                   int zl, int dzl, int dz,
                   int h, int y, int px, int py, float* result)
{

    while (1) {
        h--;
        if (y++ == py)
            FILLSPAN(xl, xr, zl, dz, px, result);
        if (!h) return FALSE;
        xl += dxl;
        xr += dxr;
        zl += dzl;
    }
}

int ZTFill2( int xl1, int dxl1,
                    int xl2, int dxl2,
                    int xr1, int dxr1,
                    int xr2, int dxr2,
                    int zl,
                    int dzl1,
                    int dzl2,
                    int dz,
                    int h1, int h2,
                    int y, int px, int py, float* result)
{
    while (h1) {
        h1--;
        if (y++ == py)
            FILLSPAN(xl1, xr1, zl, dz, px, result);
        xl1 += dxl1;
        xr1 += dxr1;
        zl += dzl1;
    }
    while (1) {
        h2--;
        if (y++ == py)
            FILLSPAN(xl2, xr2, zl, dz, px, result);
        if (!h2) return FALSE;
        xl2 += dxl2;
        xr2 += dxr2;
        zl += dzl2;
    }
}

int GenPickTriangle(LPDIRECT3DDEVICEI lpDevI,
                    D3DTLVERTEX*   base,
                    D3DTRIANGLE*   tri,
                    D3DRECT*   rect,
                    D3DVALUE*  result)
{
    int h1, h2, h3;
    float h1s, h3s;
    int y, y1, y2, y3;
    D3DTLVERTEX *p1, *p2, *p3;
    float xl, xr, xm, ml, ml2, mr, mr2;
    float zl, zr, zm, mz, mz2, zstep;
    float dx;

    int px = rect->x1;
    int py = rect->y1;

    p1 = base + tri->v1;
    p2 = base + tri->v2;
    p3 = base + tri->v3;

    y1 = VALTOI(p1->sy);
    y2 = VALTOI(p2->sy);
    y3 = VALTOI(p3->sy);

    if (y1 == y2 && y2 == y3)
        return FALSE;
    {
        int y;
        D3DTLVERTEX *p;

        /*
         * Work out which vertex is topmost.
         */
        if (y2 <= y1 && y2 <= y3) {
            y = y1;
            y1 = y2;
            y2 = y3;
            y3 = y;
            p = p1;
            p1 = p2;
            p2 = p3;
            p3 = p;
        } else if (y3 <= y1 && y3 <= y2) {
            y = y1;
            y1 = y3;
            y3 = y2;
            y2 = y;
            p = p1;
            p1 = p3;
            p3 = p2;
            p2 = p;
        }
    }

    y = y1;

    if (py < y)
        return FALSE;

    if (py >= y2 && py >= y3)
        return FALSE;

    h1 = y2 - y1;
    h2 = y3 - y2;
    h3 = y3 - y1;

    if (h1 == 0) {
        xl = p1->sx;
        xr = p2->sx;
        dx = xr - xl;
        if (dx <= 0)
            return FALSE;
        zl = p1->sz;
        zr = p2->sz;
        zstep = RLDDICheckDiv16(zr - zl, dx);
        xm = p3->sx;
        ml = (xm - xl) / h2;
        mr = (xm - xr) / h2;
        mz = ((p3->sz) - zl) / h2;

        if (ZTFill1(VALTOFX(xl), VALTOFX(ml), VALTOFX(xr), VALTOFX(mr),
                    VALTOFX24(zl), VALTOFX24(mz), VALTOFX24(zstep), h2,
                    y, px, py, result)) {
            return TRUE;
        }
    } else if (h2 == 0) {
        xl = p3->sx;
        xr = p2->sx;
        dx = xr - xl;
        if (dx <= 0)
            return FALSE;
        zl = p3->sz;
        zr = p2->sz;
        zm = p1->sz;
        zstep = RLDDICheckDiv16(zr - zl, dx);
        if (h1 == 1)
            ;
        else {
            xm = p1->sx;
            ml = (xl - xm) / h1;
            mr = (xr - xm) / h1;
            mz = (zl - zm) / h1;

            if (ZTFill1(VALTOFX(xm), VALTOFX(ml), VALTOFX(xm), VALTOFX(mr),
                        VALTOFX24(zm), VALTOFX24(mz), VALTOFX24(zstep), h1,
                        y, px, py, result)) {
                return TRUE;
            }
        }
    } else if (h3 == 0) {
        xl = p3->sx;
        xr = p1->sx;
        dx = xr - xl;
        if (dx <= 0)
            return FALSE;
        zl = p3->sz;
        zr = p1->sz;
        zstep = RLDDICheckDiv16(zr - zl, dx);
        xm = p2->sx;
        ml = (xm - xl) / h1;
        mr = (xm - xr) / h1;
        mz = ((p2->sz)- zl) / h1;
        if (ZTFill1(VALTOFX(xl), VALTOFX(ml), VALTOFX(xr), VALTOFX(mr),
                    VALTOFX24(zl), VALTOFX24(mz), VALTOFX24(zstep), h1,
                    y, px, py, result)) {
            return TRUE;
        }
    } else if (h1 < h3) {
        float denom;
        float dx1, dx2;

        xl = p3->sx;
        xr = p2->sx;
        xm = p1->sx;

        dx1 = xr - xm;
        dx2 = xl - xm;

        /*
         * Make a stab at guessing the sign of the area for quick backface
         * culling.  Note that h1 and h3 are positive.
         */
        if (dx1 < 0 && dx2 > 0)
            return FALSE;

        /*
         * This uses Mul24 to get an 8 bit precision result otherwise
         * we can get the wrong result for large triangles.
         */
        denom = RLDDIFMul24(dx1, ITOVAL(h3)) - RLDDIFMul24(dx2, ITOVAL(h1));

        if (denom <= 0)
            return FALSE;

        h1s = RLDDIFDiv8(ITOVAL(h1), denom);
        h3s = RLDDIFDiv8(ITOVAL(h3), denom);

        zl = p3->sz;
        zr = p2->sz;
        zm = p1->sz;
        zstep = RLDDIFMul16(zr - zm, h3s) - RLDDIFMul16(zl - zm, h1s);

        ml = (xl - xm) / h3;
        mz = (zl - zm) / h3;
        mr = (xr - xm) / h1;
        mr2 = (xl - xr) / h2;

        if (ZTFill2(VALTOFX(xm), VALTOFX(ml), VALTOFX(xm + h1*ml), VALTOFX(ml),
                    VALTOFX(xm), VALTOFX(mr), VALTOFX(xr), VALTOFX(mr2),
                    VALTOFX24(zm), VALTOFX24(mz), VALTOFX24(mz), VALTOFX24(zstep),
                    h1, h2, y, px, py, result)) {
            return TRUE;
        }
    } else {
        float denom;
        float dx1, dx2;

        xl = p3->sx;
        xr = p2->sx;
        xm = p1->sx;

        dx1 = xr - xm;
        dx2 = xl - xm;

        /*
         * Make a stab at guessing the sign of the area for quick backface
         * culling.  Note that h1 and h3 are positive.
         */
        if (dx1 < 0 && dx2 > 0)
            return FALSE;

        /*
         * This uses Mul24 to get an 8 bit precision result otherwise
         * we can get the wrong result for large triangles.
         */
        denom = RLDDIFMul24(dx1, ITOVAL(h3)) - RLDDIFMul24(dx2, ITOVAL(h1));

        if (denom <= 0)
            return FALSE;

        h1s = RLDDIFDiv8(ITOVAL(h1), denom);
        h3s = RLDDIFDiv8(ITOVAL(h3), denom);

        zl = p3->sz;
        zr = p2->sz;
        zm = p1->sz;
        zstep = RLDDIFMul16(zr - zm, h3s) - RLDDIFMul16(zl - zm, h1s);

        ml = (xl - xm) / h3;
        mz = (zl - zm) / h3;
        mr = (xr - xm) / h1;
        h2 = -h2;
        ml2 = (xr - xl) / h2;
        mz2 = (zr - zl) / h2;

        if (ZTFill2(VALTOFX(xm), VALTOFX(ml), VALTOFX(xl), VALTOFX(ml2),
                    VALTOFX(xm), VALTOFX(mr), VALTOFX(xm + h3*mr), VALTOFX(mr),
                    VALTOFX24(zm), VALTOFX24(mz), VALTOFX24(mz2), VALTOFX24(zstep),
                    h3, h2, y, px, py, result)) {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT GenAddPickRecord(LPDIRECT3DDEVICEI lpDevI,
                         D3DOPCODE op, int offset, float result)
{
    D3DI_PICKDATA* pdata = &lpDevI->pick_data;

    int i;

    i = pdata->pick_count++;

    if (D3DRealloc((void**) &pdata->records, pdata->pick_count *
                   sizeof(D3DPICKRECORD))) {
        return (DDERR_OUTOFMEMORY);
    }

    pdata->records[i].bOpcode = op;
    pdata->records[i].dwOffset = offset;
    pdata->records[i].dvZ = result;
    return (D3D_OK);
}

HRESULT GenGetPickRecords(LPDIRECT3DDEVICEI lpDevI, D3DI_PICKDATA* pdata)
{
    D3DI_PICKDATA* drv_pdata = &lpDevI->pick_data;
    int picked_count;
    int picked_size;

    picked_count = drv_pdata->pick_count;
    picked_size = picked_count * sizeof(D3DPICKRECORD);

    if (pdata->records == NULL) {
        pdata->pick_count = drv_pdata->pick_count;
    } else {
        memcpy((char*)pdata->records, (char*)drv_pdata->records, picked_size);
        pdata->pick_count = drv_pdata->pick_count;
    }

    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\dp2hal.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       cbhal.cpp
 *  Content:    DrawPrimitive implementation for command buffer HALs
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
#include "drawprim.hpp"
#include "clipfunc.h"
#include "d3dfei.h"

extern const DWORD LOWVERTICESNUMBER;
extern "C" HRESULT WINAPI
DDInternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID* lpBits );
extern "C" FLATPTR GetAliasedVidMem( LPDDRAWI_DIRECTDRAW_LCL   pdrv_lcl,
                          LPDDRAWI_DDRAWSURFACE_LCL surf_lcl,
                          FLATPTR                   fpVidMem );

// Each vertex buffer is big enough to hold 256 TL vertices
const DWORD CDirect3DDeviceIDP2::dwD3DDefaultVertexBatchSize = 256; // * 32 = 8K bytes
// Command buffer size tuned to 16K to minimize flushes in Unreal
const DWORD CDirect3DDeviceIDP2::dwD3DDefaultCommandBatchSize = 16384; // * 1 = 16K bytes

inline void CDirect3DDeviceIDP2::ClearBatch()
{
    // Reset command buffer
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)lpvDP2Commands;
    dwDP2CommandLength = 0;
    dp2data.dwCommandOffset = 0;
    dp2data.dwCommandLength = 0;
    bDP2CurrCmdOP = 0;
    // Reset vertex buffer
    if (this->dwFlags & D3DPV_WITHINPRIMITIVE)
    {
        // Do not reset vertex buffer
        // or reset to the start of current primitives'
        // vertex data to prevent unecessary processing
        // of unused vertices by the driver.
        /*
        dp2data.dwVertexOffset = dwDP2CurrPrimVertexOffset;
        dp2data.dwVertexLength -= dwDP2CurrPrimVertexOffset;
        */
    }
    else
    {
        dp2data.dwVertexOffset = 0;
        dp2data.dwVertexLength = 0;
        dwVertexBase = 0;
        TLVbuf.Base() = 0;
        if (dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES)
        {
            // We are flushing a user mem primitive.
            // We need to clear dp2data.lpUMVertices
            // since we are done with it. We replace
            // it with TLVbuf.
            DDASSERT(lpDP2CurrBatchVBI == NULL);
            dp2data.lpDDVertex = ((LPDDRAWI_DDRAWSURFACE_INT)TLVbuf.GetDDS())->lpLcl;
            lpDP2CurrBatchVBI = TLVbuf.GetVBI();
            lpDP2CurrBatchVBI->AddRef();
            dp2data.dwFlags &= ~D3DHALDP2_USERMEMVERTICES;
        }
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::CheckSurfaces()"
HRESULT CDirect3DDeviceIDP2::CheckSurfaces()
{
    HRESULT hr;
    if(this->lpDirect3DI->lpTextureManager->CheckIfLost())
    {
        D3D_ERR("Managed Textures lost");
        return DDERR_SURFACELOST;
    }
    if ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl->lpGbl->dwUsageCount ||
         (this->lpDDSZBuffer && ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl->lpGbl->dwUsageCount) )
    {
        D3D_ERR("Render target or Z buffer locked");
        return DDERR_SURFACEBUSY;
    }
    if ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl->dwFlags & DDRAWISURF_INVALID )\
        {
            D3D_ERR("Render target buffer lost");
            return DDERR_SURFACELOST;
        }
    if ( this->lpDDSZBuffer && ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl->dwFlags & DDRAWISURF_INVALID ) )
    {
        D3D_ERR("Z buffer lost");
        return DDERR_SURFACELOST;
    }
    if (!(this->dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES) && (this->dp2data.lpDDVertex->dwFlags & DDRAWISURF_INVALID))
    {
        D3D_ERR("Vertex buffer lost");
        return DDERR_SURFACELOST;
    }
    if (this->dp2data.lpDDCommands->dwFlags & DDRAWISURF_INVALID)
    {
        D3D_ERR("Command buffer lost");
        return DDERR_SURFACELOST;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::FlushStates(void)"

HRESULT CDirect3DDeviceIDP2::FlushStates()
{
    HRESULT dwRet=D3D_OK;
    FlushTextureFromDevice( this ); // delink all texture surfaces
    if (dwDP2CommandLength) // Do we have some instructions to flush ?
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
        // Check if render target and / or z buffer is lost
        if ((dwRet = CheckSurfaces()) != D3D_OK)
        { // If lost, we'll just chuck all this work into the bit bucket
            ClearBatch();
            if (dwRet == DDERR_SURFACELOST)
            {
                this->dwFEFlags |= D3DFE_LOSTSURFACES;
                dwRet = D3D_OK;
            }
        }
        else
        {
            // Save since it will get overwritten by ddrval after DDI call
            DWORD dwVertexSize = dp2data.dwVertexSize;
            dp2data.dwCommandLength = dwDP2CommandLength;
            //we clear this to break re-entering as SW rasterizer needs to lock DDRAWSURFACE
            dwDP2CommandLength = 0;
            // Try and set these 2 values only once during initialization
            dp2data.dwhContext = this->dwhContext;
            dp2data.lpdwRStates = this->rstates;
            DDASSERT(dp2data.dwVertexSize != 0);
            // If we need the same TLVbuf next time do not swap buffers.
            if (this->dwFlags & D3DPV_WITHINPRIMITIVE)
            {
                dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
            }
            D3D_INFO(6, "dwVertexType passed to the driver = 0x%08x", dp2data.dwVertexType);
#ifndef WIN95
            if (!IS_DX7HAL_DEVICE(this))
            {
                if((dwRet = CheckContextSurface(this)) != D3D_OK)
                {
                    ClearBatch();
                    return dwRet;
                }
            }
#else
            // Take Win 16 Lock here
            LOCK_HAL( dwRet, this );
#endif //WIN95

            // Spin waiting on the driver if wait requested
            do {
                // Need to set this since the driver may have overwrote it by
                // setting ddrval = DDERR_WASSTILLDRAWING
                dp2data.dwVertexSize = dwVertexSize;
                CALL_HAL3ONLY_NOLOCK(dwRet, this, DrawPrimitives2, &dp2data);
                if (dwRet != DDHAL_DRIVER_HANDLED)
                {
                    D3D_ERR ( "Driver not handled in DrawPrimitives2" );
                    // Need sensible return value in this case,
                    // currently we return whatever the driver stuck in here.
                }
            } while (dp2data.ddrval == DDERR_WASSTILLDRAWING);
            if (dp2data.ddrval == D3DERR_COMMAND_UNPARSED)
            { // This should never occur since the driver must understand
              // all the instruction we batch.
                D3D_ERR("Driver could not parse this batch!");
                dwRet = DDERR_GENERIC; // Some thing better here ?
            }
            else
            {
                dwRet= dp2data.ddrval;
#ifdef WIN95
                // update command buffer pointer
                if ((dwRet == D3D_OK) && (dp2data.dwFlags & D3DHALDP2_SWAPCOMMANDBUFFER))
                {
                    // Get Aliased vid mem pointer if it is a vid mem surf.
                    if (dp2data.dwFlags & D3DHALDP2_VIDMEMCOMMANDBUF)
                    {
                        D3D_INFO(7, "Got back new vid mem command buffer");
                        FLATPTR paliasbits = GetAliasedVidMem( dp2data.lpDDCommands->lpSurfMore->lpDD_lcl,
                            dp2data.lpDDCommands, (FLATPTR) dp2data.lpDDCommands->lpGbl->fpVidMem );
                        if (paliasbits == NULL)
                        {
                            DPF_ERR("Could not get Aliased pointer for vid mem command buffer");
                            // Since we can't use this pointer, set it's size to 0
                            // That way next time around we will try and allocate a new one
                            dp2data.lpDDCommands->lpGbl->dwLinearSize = 0;
                        }
                        lpvDP2Commands = (LPVOID)paliasbits;
                    }
                    else
                    {
                        D3D_INFO(7, "Got back new sys mem command buffer");
                        lpvDP2Commands = (LPVOID)dp2data.lpDDCommands->lpGbl->fpVidMem;
                    }
                    dwDP2CommandBufSize = dp2data.lpDDCommands->lpGbl->dwLinearSize;
                }
                // update vertex buffer pointer
                if ((dwRet == D3D_OK) && (dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER))
                {
                    if (dp2data.dwFlags & D3DHALDP2_VIDMEMVERTEXBUF)
                    {
                        D3D_INFO(7, "Got back new vid mem vertex buffer");
                        FLATPTR paliasbits = GetAliasedVidMem( dp2data.lpDDVertex->lpSurfMore->lpDD_lcl,
                            dp2data.lpDDVertex, (FLATPTR) dp2data.lpDDVertex->lpGbl->fpVidMem );
                        if (paliasbits == NULL)
                        {
                            DPF_ERR("Could not get Aliased pointer for vid mem vertex buffer");
                            // Since we can't use this pointer, set it's size to 0
                            // That way next time around we will try and allocate a new one
                            dp2data.lpDDVertex->lpGbl->dwLinearSize = 0;
                        }
                        TLVbuf.alignedBuf = (LPVOID)paliasbits;
                    }
                    else
                    {
                        D3D_INFO(7, "Got back new sys mem vertex buffer");
                        TLVbuf.alignedBuf = (LPVOID)dp2data.lpDDVertex->lpGbl->fpVidMem;
                    }
                    TLVbuf.size = dp2data.lpDDVertex->lpGbl->dwLinearSize;
                }
#endif
            }
#ifdef WIN95
            // Release Win16 Lock here
            UNLOCK_HAL( this );
#endif
            // Restore to value before the DDI call
            dp2data.dwVertexSize = dwVertexSize;
            ClearBatch();
        }
    }
    // There are situations when the command stream has no data, but there is data in
    // the vertex pool. This could happen, for instance if every triangle got rejected
    // while clipping. In this case we still need to "Flush out" the vertex data.
    else if (dp2data.dwCommandLength == 0)
    {
        ClearBatch();
    }
    return dwRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::FlushStates(DWORD)"

HRESULT CDirect3DDeviceIDP2::FlushStates(DWORD dwReqSize)
{
    // Request the driver to grow the command buffer upon flush
    dp2data.dwReqVertexBufSize = dwReqSize;
    dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER | D3DHALDP2_REQVERTEXBUFSIZE;
    HRESULT ret = FlushStates();
    dp2data.dwFlags &= ~D3DHALDP2_REQVERTEXBUFSIZE;
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::GrowCommandBuffer"
// Check and grow command buffer
HRESULT CDirect3DDeviceIDP2::GrowCommandBuffer(LPDIRECT3DI lpD3DI, DWORD dwSize)
{
    HRESULT ret;
    if (dwSize > dwDP2CommandBufSize)
    {
        if (lpDDSCB1)
            lpDDSCB1->Release();
        // Create command buffer through DirectDraw
        DDSURFACEDESC2 ddsd;
        memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
        ddsd.dwSize = sizeof(DDSURFACEDESC2);
        ddsd.dwFlags = DDSD_WIDTH | DDSD_CAPS;
        ddsd.dwWidth = dwSize;
        ddsd.ddsCaps.dwCaps = DDSCAPS_EXECUTEBUFFER;
        if (IS_HW_DEVICE(this))
            ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        else
            ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
        ddsd.ddsCaps.dwCaps2 = DDSCAPS2_COMMANDBUFFER;
        // Try explicit video memory first
        D3D_INFO(7, "Trying to create a vid mem command buffer");
        ret = lpD3DI->lpDD4->CreateSurface(&ddsd, &lpDDSCB1, NULL);
        if (ret != DD_OK)
        {
            // If that failed, try explicit system memory
            ddsd.ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
            ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
            D3D_INFO(7, "Trying to create a sys mem command buffer");
            ret = lpD3DI->lpDD4->CreateSurface(&ddsd, &lpDDSCB1, NULL);
            if (ret != DD_OK)
            {
                D3D_ERR("failed to allocate Command Buffer 1");
                return ret;
            }
        }
        // Lock command buffer
        ret = lpDDSCB1->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_NOSYSLOCK, NULL);
        if (ret != DD_OK)
        {
            D3D_ERR("Could not lock command buffer.");
            return ret;
        }
        // update command buffer pointer
        lpvDP2Commands = ddsd.lpSurface;
        dp2data.lpDDCommands = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSCB1)->lpLcl;
        dwDP2CommandBufSize = dwSize;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::Init"

HRESULT CDirect3DDeviceIDP2::Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice, DWORD dwVersion)
{
    dwDP2CommandBufSize = 0;
    dwDP2Flags =0;
    lpDDSCB1 = NULL;
    lpvDP2Commands = NULL;
    // We do this early in case of DP2 since GrowCommandBuffer depends on this check
    if (IsEqualIID(riid, IID_IDirect3DHALDevice))
    {
        this->dwFEFlags |=  D3DFE_REALHAL;
    }
    HRESULT ret = GrowCommandBuffer(lpD3DI, dwD3DDefaultCommandBatchSize);
    if (ret != D3D_OK)
        return ret;
    // Fill the dp2data structure with initial values
    dp2data.dwFlags = D3DHALDP2_SWAPCOMMANDBUFFER;
    dp2data.dwVertexType = D3DFVF_TLVERTEX; // Initial assumption
    dp2data.dwVertexSize = sizeof(D3DTLVERTEX); // Initial assumption
    ClearBatch();

    // Initialize the DDI independent part of the device
    ret = DIRECT3DDEVICEI::Init(riid, lpD3DI, lpDDS, pUnkOuter, lplpD3DDevice, dwVersion);
    if (ret != D3D_OK)
    {
        return ret;
    }
    lpDP2CurrBatchVBI = TLVbuf.GetVBI();
    lpDP2CurrBatchVBI->AddRef();
    dp2data.lpDDVertex = ((LPDDRAWI_DDRAWSURFACE_INT)(lpDP2CurrBatchVBI->GetDDS()))->lpLcl;
    return ret;
}
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::~CDirect3DDeviceIDP2"

CDirect3DDeviceIDP2::~CDirect3DDeviceIDP2()
{
    DestroyDevice();
    if (lpDDSCB1)
        lpDDSCB1->Release();
    if (lpDP2CurrBatchVBI)
        lpDP2CurrBatchVBI->Release();
}
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::SetRenderStateI"

HRESULT D3DAPI CDirect3DDeviceIDP2::SetRenderStateI(D3DRENDERSTATETYPE dwStateType,
                                    DWORD value)
{
    HRESULT ret = D3D_OK;
    if (bDP2CurrCmdOP == D3DDP2OP_RENDERSTATE)
    { // Last instruction is a renderstate, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2RENDERSTATE) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2RENDERSTATE lpRState = (LPD3DHAL_DP2RENDERSTATE)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpRState->RenderState = dwStateType;
            lpRState->dwState = value;
            dwDP2CommandLength += sizeof(D3DHAL_DP2RENDERSTATE);
        D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
            return ret;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2RENDERSTATE) > dwDP2CommandBufSize)
    {
            ret = FlushStates();

            // Since we ran out of space, we were not able to put (dwStateType, value)
            // into the batch so rstates will reflect only the last batched
            // renderstate (since the driver updates rstates from the batch).
            // To fix this, we simply put the current (dwStateType, value) into rstates.
            this->rstates[dwStateType]=value;

            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in SetRenderStateI");
                return ret;
            }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_RENDERSTATE;
    bDP2CurrCmdOP = D3DDP2OP_RENDERSTATE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add renderstate data
    LPD3DHAL_DP2RENDERSTATE lpRState = (LPD3DHAL_DP2RENDERSTATE)(lpDP2CurrCommand + 1);
    lpRState->RenderState = dwStateType;
    lpRState->dwState = value;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2RENDERSTATE);
    return ret;
}

// Map D3DPRIMITIVETYPE to D3DHAL_DP2OPERATION
const iprim2cmdop[] = {
    0, // Invalid
    0, // Points are invalid too
    D3DDP2OP_INDEXEDLINELIST2,
    D3DDP2OP_INDEXEDLINESTRIP,
    D3DDP2OP_INDEXEDTRIANGLELIST2,
    D3DDP2OP_INDEXEDTRIANGLESTRIP,
    D3DDP2OP_INDEXEDTRIANGLEFAN
};

// Map D3DPRIMITIVETYPE to D3DHAL_DP2OPERATION (Execute buffer case)
// Only triangle lists and line lists are valid
const iprim2cmdopEx[] = {
    0,
    0,
    D3DDP2OP_INDEXEDLINELIST,
    0,
    D3DDP2OP_INDEXEDTRIANGLELIST,
    0,
    0
};

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::DrawIndexPrim"

//---------------------------------------------------------------------
//
// The vertices are already in the vertex buffer.
//
HRESULT CDirect3DDeviceIDP2::DrawIndexPrim()
{
    HRESULT ret = D3D_OK;
    DWORD dwByteCount;          // Command length plus indices
    DWORD dwIndicesByteCount;   // Indices only
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        UpdateTextures();
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }
    if (this->dwFlags & D3DPV_INSIDEEXECUTE)
    {
        if (this->primType == D3DPT_TRIANGLELIST)
            // Edge flags WORD presents in every triangle
            dwIndicesByteCount = sizeof(WORD) * this->dwNumPrimitives * 4;
        else
            // This is Line List
            dwIndicesByteCount = sizeof(WORD) * this->dwNumIndices;
        dwByteCount = dwIndicesByteCount + sizeof(D3DHAL_DP2COMMAND);
    }
    else
    {
        dwIndicesByteCount = sizeof(WORD) * this->dwNumIndices;
        dwByteCount = dwIndicesByteCount + sizeof(D3DHAL_DP2COMMAND) +
                      sizeof(D3DHAL_DP2STARTVERTEX);
    }

    if (dwDP2CommandLength + dwByteCount > dwDP2CommandBufSize)
    {
        // Request the driver to grow the command buffer upon flush
        dp2data.dwReqCommandBufSize = dwByteCount;
        dp2data.dwFlags |= D3DHALDP2_REQCOMMANDBUFSIZE;
        ret = FlushStates();
        dp2data.dwFlags &= ~D3DHALDP2_REQCOMMANDBUFSIZE;
        if (ret != D3D_OK)
            return ret;
        // Check if the driver did give us what we need or do it ourselves
        ret = GrowCommandBuffer(this->lpDirect3DI, dwByteCount);
        if (ret != D3D_OK)
        {
            D3D_ERR("Could not grow Command Buffer");
            return ret;
        }
    }
    // Insert indexed primitive instruction
    LPD3DHAL_DP2COMMAND lpDP2CurrCommand;
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                       dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wPrimitiveCount = (WORD)this->dwNumPrimitives;

    LPBYTE pIndices = (BYTE*)(lpDP2CurrCommand + 1);     // Place for indices
    if (!(this->dwFlags & D3DPV_INSIDEEXECUTE))
    {
        lpDP2CurrCommand->bCommand = (BYTE)iprim2cmdop[this->primType];
        ((LPD3DHAL_DP2STARTVERTEX)(lpDP2CurrCommand+1))->wVStart =
            (WORD)this->dwVertexBase;
        pIndices += sizeof(D3DHAL_DP2STARTVERTEX);
    }
    else
    {
        // If we are inside Execute, the indexed triangle and line lists
        // do not have wVStart inside the command
        lpDP2CurrCommand->bCommand = (BYTE)iprim2cmdopEx[this->primType];
    }

    D3D_INFO(6, "Write Ins :%08lx @ %08lx", *(LPDWORD)lpDP2CurrCommand,lpDP2CurrCommand);
    D3D_INFO(6, "Vertex Base: %08lx", this->dwVertexBase);

#if DBG
    if (lpDP2CurrCommand->bCommand == 0)
    {
        D3D_ERR("Illegal primitive type");
        return DDERR_GENERIC;
    }
#endif
    bDP2CurrCmdOP = lpDP2CurrCommand->bCommand;

    memcpy(pIndices, this->lpwIndices, dwIndicesByteCount);

    wDP2CurrCmdCnt = lpDP2CurrCommand->wPrimitiveCount;
    dwDP2CommandLength += dwByteCount;
    // We have batched some stuff, so we could be within a primitive
    // Unless the higher functions clear this flag we need to assume
    // we are mid-primitive during our flushes.
    this->dwFlags |= D3DPV_WITHINPRIMITIVE;
    return ret;
}

// Map D3DPRIMITIVETYPE to D3DHAL_DP2OPERATION
const prim2cmdop[] = {
    0, // Invalid
    D3DDP2OP_POINTS,
    D3DDP2OP_LINELIST,
    D3DDP2OP_LINESTRIP,
    D3DDP2OP_TRIANGLELIST,
    D3DDP2OP_TRIANGLESTRIP,
    D3DDP2OP_TRIANGLEFAN
};
// Map D3DPRIMITIVETYPE to bytes needed in command stream
const prim2cmdsz[] = {
    0, // Invalid
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2POINTS),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2LINELIST),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2LINESTRIP),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLELIST),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLESTRIP),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLEFAN)
};

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::DrawPrim"

HRESULT CDirect3DDeviceIDP2::DrawPrim()
{
    HRESULT ret = D3D_OK;
    DWORD dwVertexPoolSize = this->dwNumVertices * this->dwOutputSize;
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        UpdateTextures();
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }
    // This primitive is generated by the clipper.
    // The vertices of this primitive are pointed to by the
    // lpvOut member, which need to be copied into the
    // command stream immediately after the command itself.
    if (this->dwFlags & D3DPV_CLIPPERPRIM)
    {
        DWORD dwExtra = 0;
        LPVOID lpvVerticesImm;  // Place for vertices
        if (this->primType == D3DPT_TRIANGLEFAN)
        {
            if (rstates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME &&
                this->dwFlags & D3DPV_NONCLIPPED)
            {
                // For unclipped (but pretended to be clipped) tri fans in
                // wireframe mode we generate 3-vertex tri fans to enable drawing of
                // interior edges
                BYTE vertices[__MAX_VERTEX_SIZE*3];
                BYTE *pV1 = vertices + this->dwOutputSize;
                BYTE *pV2 = pV1 + this->dwOutputSize;
                BYTE *pInput = (BYTE*)this->lpvOut;
                memcpy(vertices, pInput, this->dwOutputSize);
                pInput += this->dwOutputSize;
                const DWORD nTriangles = this->dwNumVertices - 2;
                this->dwNumVertices = 3;
                this->dwNumPrimitives = 1;
                this->lpvOut = vertices;
                this->dwFlags &= ~D3DPV_NONCLIPPED;  // Remove this flag for recursive call
                for (DWORD i = nTriangles; i; i--)
                {
                    memcpy(pV1, pInput, this->dwOutputSize);
                    memcpy(pV2, pInput+this->dwOutputSize, this->dwOutputSize);
                    pInput += this->dwOutputSize;
                    // To enable all edge flag we set the fill mode to SOLID.
                    // This will prevent checking the clip flags in the clipper state.
                    rstates[D3DRENDERSTATE_FILLMODE] = D3DFILL_SOLID;
                    ret = DrawPrim();
                    rstates[D3DRENDERSTATE_FILLMODE] = D3DFILL_WIREFRAME;
                    if (ret != D3D_OK)
                            return ret;
                }
                return D3D_OK;
            }
            dwExtra = sizeof(D3DHAL_DP2TRIANGLEFAN_IMM);
        }
        DWORD dwPad = (sizeof(D3DHAL_DP2COMMAND) + dwDP2CommandLength + dwExtra) & 3;
        DWORD dwByteCount = sizeof(D3DHAL_DP2COMMAND) + dwPad + dwExtra + dwVertexPoolSize;

        // Check for space in the command buffer for commands & vertices
        if (dwDP2CommandLength + dwByteCount > dwDP2CommandBufSize)
        {
            // Flush the current batch but hold on to the vertices
            ret = FlushStates();
            if (ret != D3D_OK)
                return ret;
            if (dwByteCount > dwDP2CommandBufSize)
            {
                ret = GrowCommandBuffer(this->lpDirect3DI, dwByteCount);
                if (ret != D3D_OK)
                {
                    D3D_ERR("Could not grow Command Buffer");
                    return ret;
                }
            }

            dwPad = (sizeof(D3DHAL_DP2COMMAND) + dwExtra) & 3;
            dwByteCount = sizeof(D3DHAL_DP2COMMAND) + dwExtra + dwPad + dwVertexPoolSize;
        }
        lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                            dwDP2CommandLength + dp2data.dwCommandOffset);
        lpDP2CurrCommand->wPrimitiveCount = (WORD)this->dwNumPrimitives;
        lpDP2CurrCommand->bReserved = 0;
        if (this->primType == D3DPT_TRIANGLEFAN)
        {
            // Insert inline instruction and vertices
            bDP2CurrCmdOP = D3DDP2OP_TRIANGLEFAN_IMM;
            lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
            D3D_INFO(6, "Write Ins :%08lx @ %08lx", *(LPDWORD)lpDP2CurrCommand,lpDP2CurrCommand);
            LPD3DHAL_DP2TRIANGLEFAN_IMM lpTriFanImm = (LPD3DHAL_DP2TRIANGLEFAN_IMM)(lpDP2CurrCommand + 1);
            if (rstates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME)
            {
                lpTriFanImm->dwEdgeFlags = 0;
                ClipVertex **clip = this->ClipperState.current_vbuf;
                // Look at the exterior edges and mark the visible ones
                for(DWORD i = 0; i < this->dwNumVertices; ++i)
                {
                    if (clip[i]->clip & CLIPPED_ENABLE)
                        lpTriFanImm->dwEdgeFlags |= (1 << i);
                }
            }
            else
            {
                // Mark all exterior edges visible
                lpTriFanImm->dwEdgeFlags = 0xFFFFFFFF;
            }
            lpvVerticesImm = (LPBYTE)(lpTriFanImm + 1) + dwPad;
        }
        else
        {
            // Insert inline instruction and vertices
            bDP2CurrCmdOP = D3DDP2OP_LINELIST_IMM;
            lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
            D3D_INFO(6, "Write Ins :%08lx @ %08lx", *(LPDWORD)lpDP2CurrCommand,lpDP2CurrCommand);
            lpvVerticesImm = (LPBYTE)(lpDP2CurrCommand + 1) + dwPad;
        }
        memcpy(lpvVerticesImm, this->lpvOut, dwVertexPoolSize);
        dwDP2CommandLength += dwByteCount;
    }
    else
    {
        // Check for space in the command buffer for new command.
        // The vertices are already in the vertex buffer.
        if (dwDP2CommandLength + prim2cmdsz[this->primType] > dwDP2CommandBufSize)
        {
            ret = FlushStates();
            if (ret != D3D_OK)
                return ret;
        }
        // Insert non indexed primitive instruction
        lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                            dwDP2CommandLength + dp2data.dwCommandOffset);
        bDP2CurrCmdOP = (BYTE)prim2cmdop[this->primType];
        lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
        lpDP2CurrCommand->bReserved = 0;
        switch(bDP2CurrCmdOP)
        {
        case D3DDP2OP_POINTS:
            {
                lpDP2CurrCommand->wPrimitiveCount = 1;
                LPD3DHAL_DP2POINTS lpPoints = (LPD3DHAL_DP2POINTS)(lpDP2CurrCommand + 1);
                lpPoints->wCount = (WORD)this->dwNumVertices;
                lpPoints->wVStart = (WORD)this->dwVertexBase;
                D3D_INFO(6, "Write Ins :%08lx @ %08lx", *(LPDWORD)lpDP2CurrCommand,lpDP2CurrCommand);
                D3D_INFO(6, "Write Data:%08lx", *(LPDWORD)lpPoints);
            }
            break;
        case D3DDP2OP_LINELIST:
        case D3DDP2OP_TRIANGLELIST:
            {
                lpDP2CurrCommand->wPrimitiveCount = (WORD)this->dwNumPrimitives;
                // Linelist and trianglelist are identical
                LPD3DHAL_DP2LINELIST lpLines = (LPD3DHAL_DP2LINELIST)(lpDP2CurrCommand + 1);
                lpLines->wVStart = (WORD)this->dwVertexBase;
                D3D_INFO(6, "Write Ins :%08lx @ %08lx", *(LPDWORD)lpDP2CurrCommand,lpDP2CurrCommand);
                D3D_INFO(6, "Write Data:%08lx", (DWORD)lpLines->wVStart);
            }
            break;
        default: // strips or fans
            {
                lpDP2CurrCommand->wPrimitiveCount = (WORD)this->dwNumPrimitives;
                // Linestrip, trianglestrip and trianglefan are identical
                LPD3DHAL_DP2LINESTRIP lpStrip = (LPD3DHAL_DP2LINESTRIP)(lpDP2CurrCommand + 1);
                lpStrip->wVStart = (WORD)this->dwVertexBase;
                D3D_INFO(6, "Write Ins :%08lx @ %08lx", *(LPDWORD)lpDP2CurrCommand,lpDP2CurrCommand);
                D3D_INFO(6, "Write Data:%08lx", (DWORD)lpStrip->wVStart);
            }
        }
        wDP2CurrCmdCnt = lpDP2CurrCommand->wPrimitiveCount;
        dwDP2CommandLength += prim2cmdsz[this->primType];
    }
    // We have batched some stuff, so we could be within a primitive
    // Unless the higher functions clear this flag we need to assume
    // we are mid-primitive during our flushes.
    this->dwFlags |= D3DPV_WITHINPRIMITIVE;
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::SetTextureStageState"

HRESULT D3DAPI
CDirect3DDeviceIDP2::SetTextureStageState(DWORD dwStage,
                                          D3DTEXTURESTAGESTATETYPE dwState,
                                          DWORD dwValue)
{
    // Holds D3D lock until exit.
    CLockD3DMT ldmLock(this, DPF_MODNAME, REMIND(""));

#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES ||
        dwState == 0 || dwState >= D3DTSS_MAX)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }
#endif //DBG

    HRESULT hr;

    if (this->tsstates[dwStage][dwState] == dwValue)
    {
        D3D_WARN(4,"Ignoring redundant SetTextureStageState");
        return D3D_OK;
    }

    // Update runtime copy of state.
    DWORD dwOldValue = tsstates[dwStage][dwState];
    tsstates[dwStage][dwState] = dwValue;

    if (dwState == D3DTSS_TEXCOORDINDEX && TextureStageEnabled(this, dwStage) ||
        dwState == D3DTSS_COLOROP &&
        ((dwValue == D3DTOP_DISABLE) == !(dwOldValue == D3DTOP_DISABLE)))
    {
        this->dwFVFLastIn = 0;  // Force to recompute output VID
        this->dwFEFlags |= D3DFE_TSSINDEX_DIRTY;
    }

    if (dwStage >= dwMaxTextureBlendStages) return  D3D_OK; // Ignore higher stage states

    hr = SetTSSI(dwStage, dwState, dwValue);

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::SetTSSI"

HRESULT CDirect3DDeviceIDP2::SetTSSI(DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, DWORD dwValue)
{
    HRESULT ret = D3D_OK;
    if (bDP2CurrCmdOP == D3DDP2OP_TEXTURESTAGESTATE)
    { // Last instruction is a texture stage state, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2TEXTURESTAGESTATE) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2TEXTURESTAGESTATE lpRState = (LPD3DHAL_DP2TEXTURESTAGESTATE)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpRState->wStage = (WORD)dwStage;
            lpRState->TSState = (WORD)dwState;
            lpRState->dwValue = dwValue;
            dwDP2CommandLength += sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
        D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
            return ret;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2TEXTURESTAGESTATE) > dwDP2CommandBufSize)
    {
            ret = FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in SetTSSI");
                return ret;
            }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_TEXTURESTAGESTATE;
    bDP2CurrCmdOP = D3DDP2OP_TEXTURESTAGESTATE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add renderstate data
    LPD3DHAL_DP2TEXTURESTAGESTATE lpRState = (LPD3DHAL_DP2TEXTURESTAGESTATE)(lpDP2CurrCommand + 1);
    lpRState->wStage = (WORD)dwStage;
    lpRState->TSState = (WORD)dwState;
    lpRState->dwValue = dwValue;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::ValidateDevice"

HRESULT D3DAPI
CDirect3DDeviceIDP2::ValidateDevice(LPDWORD lpdwNumPasses)
{
    // Holds D3D lock until exit.
    CLockD3DMT ldmLock(this, DPF_MODNAME, REMIND(""));
    HRESULT ret;
    D3DHAL_VALIDATETEXTURESTAGESTATEDATA vbod;

    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_PTR(lpdwNumPasses, sizeof(DWORD)))
        {
            D3D_ERR( "Invalid lpdwNumPasses pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    // First, Update textures since drivers pass /fail this call based
    // on the current texture handles
    ret = UpdateTextures();
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to update managed textures in ValidateDevice");
        return ret;
    }
    // Second, flush states, so we can validate the current state
    ret = FlushStates();
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to FlushStates in ValidateDevice");
        return ret;
    }

    // Now ask the driver!

    *lpdwNumPasses = 0;
    memset(&vbod, 0, sizeof(D3DHAL_VALIDATETEXTURESTAGESTATEDATA));
    vbod.dwhContext = this->dwhContext;
    if (this->lpD3DHALCallbacks3->ValidateTextureStageState)
    {
         CALL_HAL3ONLY(ret, this, ValidateTextureStageState, &vbod);
         if (ret != DDHAL_DRIVER_HANDLED)
             return DDERR_UNSUPPORTED;

         *lpdwNumPasses = vbod.dwNumPasses;
         return vbod.ddrval;
    }
    else
    {
        D3D_ERR("Error: ValidateTextureStageState not supported by the driver.");
    }

    return DDERR_UNSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::StartPrimVB"
//---------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called only if vertices from user memory are NOT used for rendering
//
HRESULT CDirect3DDeviceIDP2::StartPrimVB(LPDIRECT3DVERTEXBUFFERI lpVBI,
                                         DWORD dwStartVertex)
{
    HRESULT ret = D3D_OK;

    // If VID has been changed or new vertex buffer is used we flush the batch
    if (this->dwVIDOut != dp2data.dwVertexType ||
        lpDP2CurrBatchVBI != lpVBI ||
        dp2data.lpDDVertex != ((LPDDRAWI_DDRAWSURFACE_INT)(lpVBI->GetDDS()))->lpLcl)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
            return ret;
        dp2data.dwVertexType = this->dwVIDOut;
        dp2data.dwVertexSize = this->dwOutputSize;
        dp2data.lpDDVertex = ((LPDDRAWI_DDRAWSURFACE_INT)(lpVBI->GetDDS()))->lpLcl;
        // Release previously used vertex buffer (if any), because we do not
        // need it any more. We did AddRef() to TL buffer, so it is safe.
        if (lpDP2CurrBatchVBI)
            lpDP2CurrBatchVBI->Release();
        // If a vertex buffer is used for rendering, make sure that it is not
        // released by user. So do AddRef().
        lpDP2CurrBatchVBI = lpVBI;
        lpDP2CurrBatchVBI->AddRef();
    }
    if (this->TLVbuf.GetVBI() == lpVBI)
    {
        this->dwVertexBase = this->dp2data.dwVertexLength;
        DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
        dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER;
    }
    else
    {
        this->dwVertexBase = dwStartVertex;
        dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
    }
    this->dp2data.dwVertexLength = this->dwVertexBase + this->dwNumVertices;
    this->dwFlags |= D3DPV_WITHINPRIMITIVE;
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::StartPrimUserMem"
//---------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called if vertices from user memory is used for rendering
//
HRESULT CDirect3DDeviceIDP2::StartPrimUserMem(LPVOID lpMem)
{
    const DWORD vertexPoolSize = this->dwNumVertices * this->dwOutputSize;
    HRESULT ret = D3D_OK;

    // If the primitive is small, we copy vertices into the TL buffer
    if (this->dwNumVertices < LOWVERTICESNUMBER)
    {
        if (vertexPoolSize > this->TLVbuf.GetSize())
        {
            if (this->TLVbuf.Grow(this, vertexPoolSize) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                ret = DDERR_OUTOFMEMORY;
                goto l_exit;
            }
        }
        // So now user memory is not used any more.
        ret = StartPrimVB(this->TLVbuf.GetVBI(), 0);
        if (ret != D3D_OK)
            goto l_exit;
        LPVOID tmp = this->TLVbuf.GetAddress();
        memcpy(tmp, this->lpvOut, vertexPoolSize);
        // We have to update lpvOut, because it was set to user memory
        this->lpvOut = tmp;
    }
    else
    {
        // We can not mix user memory primitive with other primitives, so
        // flush the batch.
        // Do not forget to flush the batch after rendering this primitive
        ret = this->FlushStates();
        if (ret != D3D_OK)
            goto l_exit;
        // Release previously used vertex buffer (if any), because we do not
        // it any more
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->Release();
            lpDP2CurrBatchVBI = NULL;
        }
        dp2data.dwVertexType = this->dwVIDOut;
        dp2data.dwVertexSize = this->dwOutputSize;
        dp2data.lpVertices = lpMem;
        dp2data.dwFlags |= D3DHALDP2_USERMEMVERTICES;
        dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        dp2data.dwVertexLength = this->dwNumVertices;
        this->dwFlags |= D3DPV_USERMEMVERTICES;
    }
l_exit:
    this->dwFlags |= D3DPV_WITHINPRIMITIVE;
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::EndPrim"
//---------------------------------------------------------------------
// This function should not be called from DrawVertexBufferVB
//
HRESULT CDirect3DDeviceIDP2::EndPrim(DWORD dwVertexPoolSize)
{
    HRESULT ret = D3D_OK;
    if (this->dwFlags & D3DPV_USERMEMVERTICES)
        // We can not mix user memory primitive, so flush it.
        ret = this->FlushStates();
    else
    {
        // If TL buffer was used, we have to move its internal base pointer
        this->TLVbuf.Base() += dwVertexPoolSize;
    }

    this->dwFlags &= ~(D3DPV_USERMEMVERTICES | D3DPV_WITHINPRIMITIVE);
    return ret;
}

//---------------------------------------------------------------------
//
//
HRESULT CDirect3DDeviceIDP2::UpdateDrvViewInfo(LPD3DVIEWPORT2 lpVwpData)
{
    HRESULT ret = D3D_OK;

    // Check to see if there is space to add a new command for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2VIEWPORTINFO) > dwDP2CommandBufSize)
    {
            ret = FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in UpdateDrvViewInfo");
                return ret;
            }
    }
    // Add new ViewInfo instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_VIEWPORTINFO;
    bDP2CurrCmdOP = D3DDP2OP_VIEWPORTINFO;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);

    // Add ViewInfo data
    LPD3DHAL_DP2VIEWPORTINFO lpVpInfo = (LPD3DHAL_DP2VIEWPORTINFO)(lpDP2CurrCommand + 1);
    lpVpInfo->dwX = lpVwpData->dwX;
    lpVpInfo->dwY = lpVwpData->dwY;
    lpVpInfo->dwWidth = lpVwpData->dwWidth;
    lpVpInfo->dwHeight = lpVwpData->dwHeight;

    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2VIEWPORTINFO);
    return ret;
}

//---------------------------------------------------------------------
//
//
HRESULT CDirect3DDeviceIDP2::UpdateDrvWInfo()
{
    HRESULT ret = D3D_OK;

    // Check to see if there is space to add a new command for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2WINFO) > dwDP2CommandBufSize)
    {
            ret = FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in UpdateDrvViewInfo");
                return ret;
            }
    }
    // Add new WInfo instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_WINFO;
    bDP2CurrCmdOP = D3DDP2OP_WINFO;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);

    // Add WInfo data
    D3DMATRIXI &m = transform.proj;

    LPD3DHAL_DP2WINFO lpWInfo = (LPD3DHAL_DP2WINFO)(lpDP2CurrCommand + 1);
    if( (m._33 == m._34) || (m._33 == 0.0f) )
    {
        D3D_ERR( "Cannot compute WNear and WFar from the supplied projection matrix.\n Setting wNear to 0.0 and wFar to 1.0" );
        lpWInfo->dvWNear = 0.0f;
        lpWInfo->dvWFar  = 1.0f;
        dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2WINFO);
        return ret;
    }
    
    lpWInfo->dvWNear = m._44 - m._43/m._33*m._34;
    lpWInfo->dvWFar  = (m._44 - m._43)/(m._33 - m._34)*m._34 + m._44;

    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2WINFO);
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::UpdatePalette"
//---------------------------------------------------------------------
// This function should be called from PaletteUpdateNotify
//
HRESULT CDirect3DDeviceIDP2::UpdatePalette(
        DWORD dwPaletteHandle,
        DWORD dwStartIndex,
        DWORD dwNumberOfIndices,
        LPPALETTEENTRY pFirstIndex)
{
    HRESULT ret = D3D_OK;
    DWORD   dwSizeChange=sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2UPDATEPALETTE) + dwNumberOfIndices*sizeof(PALETTEENTRY);
    if (bDP2CurrCmdOP == D3DDP2OP_UPDATEPALETTE)
    { // Last instruction is a tex blt, append this one to it
    }
    // Check for space
    if (dwDP2CommandLength + dwSizeChange > dwDP2CommandBufSize)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in TexBltI");
            return ret;
        }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_UPDATEPALETTE;
    bDP2CurrCmdOP = D3DDP2OP_UPDATEPALETTE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add texture blt data
    LPD3DHAL_DP2UPDATEPALETTE lpUpdatePal = (LPD3DHAL_DP2UPDATEPALETTE)(lpDP2CurrCommand + 1);
    lpUpdatePal->dwPaletteHandle=dwPaletteHandle;
    lpUpdatePal->wStartIndex=(WORD)dwStartIndex; 
    lpUpdatePal->wNumEntries=(WORD)dwNumberOfIndices;
    memcpy((LPVOID)(lpUpdatePal+1),(LPVOID)pFirstIndex,
        dwNumberOfIndices*sizeof(PALETTEENTRY));
    dwDP2CommandLength += dwSizeChange;
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::SetPalette"
//---------------------------------------------------------------------
// This function should be called from PaletteAssociateNotify
//
HRESULT CDirect3DDeviceIDP2::SetPalette(DWORD dwPaletteHandle, DWORD dwPaletteFlags, DWORD dwSurfaceHandle )
{
    HRESULT ret = D3D_OK;
    DWORD   dwSizeChange;
    if (bDP2CurrCmdOP == D3DDP2OP_SETPALETTE)
    { // Last instruction is a tex blt, append this one to it
    }

    dwSizeChange=sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETPALETTE);
    // Check for space
    if (dwDP2CommandLength + dwSizeChange > dwDP2CommandBufSize)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in TexBltI");
            return ret;
        }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    bDP2CurrCmdOP = lpDP2CurrCommand->bCommand = D3DDP2OP_SETPALETTE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    LPD3DHAL_DP2SETPALETTE lpSetPal = (LPD3DHAL_DP2SETPALETTE)(lpDP2CurrCommand + 1);
    lpSetPal->dwPaletteHandle=dwPaletteHandle;
    lpSetPal->dwPaletteFlags=dwPaletteFlags;
    lpSetPal->dwSurfaceHandle=dwSurfaceHandle; 
    dwDP2CommandLength += dwSizeChange;
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::SetRenderTargetI"
void CDirect3DDeviceIDP2::SetRenderTargetI(LPDIRECTDRAWSURFACE pRenderTarget, LPDIRECTDRAWSURFACE pZBuffer)
{
    DWORD   dwSizeChange;
    dwSizeChange=sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETRENDERTARGET);
    // Check for space
    if (dwDP2CommandLength + dwSizeChange > dwDP2CommandBufSize)
    {
        if (FlushStates() != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in SetRenderTargetI");
            return;
        }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    bDP2CurrCmdOP = lpDP2CurrCommand->bCommand = D3DDP2OP_SETRENDERTARGET;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    LPD3DHAL_DP2SETRENDERTARGET pData = (LPD3DHAL_DP2SETRENDERTARGET)(lpDP2CurrCommand + 1);
    pData->hRenderTarget = ((LPDDRAWI_DDRAWSURFACE_INT)pRenderTarget)->lpLcl->lpSurfMore->dwSurfaceHandle;
    if (pZBuffer)
        pData->hZBuffer = ((LPDDRAWI_DDRAWSURFACE_INT)pZBuffer)->lpLcl->lpSurfMore->dwSurfaceHandle;
    else
        pData->hZBuffer = 0;
    dwDP2CommandLength += dwSizeChange;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::ClearI"

void CDirect3DDeviceIDP2::ClearI(DWORD dwFlags, DWORD clrCount, LPD3DRECT clrRects, D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil)
{
    DWORD dwCommandSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2CLEAR) + sizeof(RECT) * (clrCount - 1);

    // Check to see if there is space to add a new command for space
    if (dwCommandSize + dwDP2CommandLength > dwDP2CommandBufSize)
    {
        HRESULT ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands");
            throw ret;
        }
    }
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_CLEAR;
    bDP2CurrCmdOP = D3DDP2OP_CLEAR;
    lpDP2CurrCommand->bReserved = 0;
    wDP2CurrCmdCnt = (WORD)clrCount;
    lpDP2CurrCommand->wStateCount = wDP2CurrCmdCnt;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    dwDP2CommandLength += dwCommandSize;

    // Write data
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(lpDP2CurrCommand + 1);
    pData->dwFlags = dwFlags;
    pData->dwFillColor = dwColor;
    pData->dvFillDepth = dvZ;
    pData->dwFillStencil = dwStencil;
    memcpy(pData->Rects, clrRects, clrCount * sizeof(D3DRECT));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\dphal.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dphal.c
 *  Content:    DrawPrimitive implementation for DrawPrimitive HALs
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
#include "drawprim.hpp"
#include "clipfunc.h"
#include "d3dfei.h"

extern const DWORD LOWVERTICESNUMBER = 20;

#if DBG
extern DWORD FaceCount;
DWORD FaceCount = 0;
DWORD StartFace = 0;
DWORD EndFace = 10000;
#endif

extern void SetDebugRenderState(DWORD value);

#define ALIGN32(x) x = ((DWORD)(x + 31)) & (~31);
//---------------------------------------------------------------------
// Array to map D3DVERTEXTYPE to FVF vertex type
//
DWORD d3dVertexToFVF[4] =
{
    0,
    D3DFVF_VERTEX,
    D3DFVF_LVERTEX,
    D3DFVF_TLVERTEX
};
//---------------------------------------------------------------------
// Handles strides and FVF
//
#undef DPF_MODNAME
#define DPF_MODNAME "D3DFE_updateExtents"

void D3DFE_updateExtents(LPDIRECT3DDEVICEI lpDevI)
{
    int i;
    D3DVECTOR *v = (D3DVECTOR*)lpDevI->position.lpvData;
    DWORD stride = lpDevI->position.dwStride;
    for (i = lpDevI->dwNumVertices; i; i--)
    {
        if (v->x < lpDevI->rExtents.x1)
            lpDevI->rExtents.x1 = v->x;
        if (v->x > lpDevI->rExtents.x2)
            lpDevI->rExtents.x2 = v->x;
        if (v->y < lpDevI->rExtents.y1)
            lpDevI->rExtents.y1 = v->y;
        if (v->y > lpDevI->rExtents.y2)
            lpDevI->rExtents.y2 = v->y;
        v = (D3DVECTOR*)((char*)v + stride);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "MapFVFtoTLVertex1"

inline void MapFVFtoTLVertex1(LPDIRECT3DDEVICEI lpDevI, D3DTLVERTEX *pOut,
                              DWORD *pIn)
{
// Copy position
    pOut->sx  = *(D3DVALUE*)pIn++;
    pOut->sy  = *(D3DVALUE*)pIn++;
    pOut->sz  = *(D3DVALUE*)pIn++;
    pOut->rhw = *(D3DVALUE*)pIn++;
// Other fields: diffuse, specular, texture
    if (lpDevI->dwVIDOut & D3DFVF_DIFFUSE)
        pOut->color = *pIn++;
    else
    {
        pOut->color = __DEFAULT_DIFFUSE;
    }
    if (lpDevI->dwVIDOut & D3DFVF_SPECULAR)
        pOut->specular = *pIn++;
    else
    {
        pOut->specular= __DEFAULT_SPECULAR;
    }
    if (lpDevI->nTexCoord)
    {
        pIn = &pIn[lpDevI->dwTextureIndexToCopy << 1];
        pOut->tu = *(D3DVALUE*)&pIn[0];
        pOut->tv = *(D3DVALUE*)&pIn[1];
    }
    else
    {
        pOut->tu = 0;
        pOut->tv = 0;
    }
}
//---------------------------------------------------------------------
// All vertices from lpDevI->lpVout are copied to the output buffer, expanding
// to D3DTLVERTEX.
// The output buffer is lpAddress if it is not NULL, otherwise it is TLVbuf
//
#undef DPF_MODNAME
#define DPF_MODNAME "MapFVFtoTLVertex"

HRESULT MapFVFtoTLVertex(LPDIRECT3DDEVICEI lpDevI, LPVOID lpAddress)
{
    int i;
    DWORD size = lpDevI->dwNumVertices * sizeof(D3DTLVERTEX);
    D3DTLVERTEX *pOut;
    if (lpAddress)
        pOut = (D3DTLVERTEX*)lpAddress;
    else
    {
    // See if TL buffer has sufficient space
        if (size > lpDevI->TLVbuf.GetSize())
        {
            if (lpDevI->TLVbuf.Grow(lpDevI, size) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
        }
        pOut = (D3DTLVERTEX*)lpDevI->TLVbuf.GetAddress();
    }
// Map vertices
    DWORD *pIn = (DWORD*)lpDevI->lpvOut;
    for (i=lpDevI->dwNumVertices; i; i--)
    {
        MapFVFtoTLVertex1(lpDevI, pOut, pIn);
        pOut++;
        pIn = (DWORD*)((char*)pIn + lpDevI->dwOutputSize);
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CheckDrawPrimitive"

HRESULT CheckDrawPrimitive(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_PROCESSVERTICES* data = lpDevI;
    HRESULT ret = CheckDeviceSettings(lpDevI);
    if (ret != D3D_OK)
        return ret;
    if (!data->dwNumVertices)
    {
        D3D_ERR( "Invalid dwNumVertices in DrawPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    if(data->position.lpvData==NULL) {
        D3D_ERR( "Invalid lpvVertices param in DrawPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    switch (data->primType)
    {
    case D3DPT_POINTLIST:
                break;
    case D3DPT_LINELIST:
        if (data->dwNumVertices & 1)
        {
            D3D_ERR( "DrawPrimitive: bad vertex count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_LINESTRIP:
        if (data->dwNumVertices == 1)
        {
            D3D_ERR( "DrawPrimitive: bad vertex count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        if (data->dwNumVertices < 3)
        {
            D3D_ERR( "DrawPrimitive: bad vertex count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_TRIANGLELIST:
        if ( (data->dwNumVertices % 3) != 0 )
        {
            D3D_ERR( "DrawPrimitive: bad vertex count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    default:
        D3D_ERR( "Unknown or unsupported primitive type requested of DrawPrimitive" );
        return D3DERR_INVALIDPRIMITIVETYPE;
    }

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CheckDrawIndexedPrimitive"

HRESULT
CheckDrawIndexedPrimitive(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_PROCESSVERTICES *data = lpDevI;
    DWORD i;

    HRESULT ret = CheckDeviceSettings(lpDevI);
    if (ret != D3D_OK)
        return ret;
    if (data->dwNumVertices <= 0 || data->dwNumIndices <= 0)
    {
        D3D_ERR( "Invalid dwNumVertices or dwNumIndices in DrawIndexedPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    if (data->dwNumVertices > 65535ul )
    {
        D3D_ERR( "DrawIndexedPrimitive vertex array > 64K" );
        return DDERR_INVALIDPARAMS;
    }

    if((data->lpwIndices==NULL) || IsBadReadPtr(data->lpwIndices,data->dwNumIndices*sizeof(WORD))) {
        D3D_ERR( "Invalid lpwIndices param in DrawIndexedPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    if(data->position.lpvData==NULL) {
        D3D_ERR( "Invalid lpvVertices param in DrawIndexedPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    switch (data->primType)
    {
    case D3DPT_LINELIST:
        if (data->dwNumIndices & 1)
        {
            D3D_ERR( "DrawIndexedPrimitive: bad index count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_LINESTRIP:
        if (data->dwNumIndices == 1)
        {
            D3D_ERR( "DrawIndexedPrimitive: bad index count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        if (data->dwNumIndices < 3)
        {
            D3D_ERR( "DrawIndexedPrimitive: bad index count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_TRIANGLELIST:
        if ( (data->dwNumIndices % 3) != 0 )
        {
            D3D_ERR( "DrawIndexedPrimitive: bad index count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    default:
        D3D_ERR( "Unknown or unsupported primitive type requested of DrawIndexedPrimitive" );
        return D3DERR_INVALIDPRIMITIVETYPE;
    }
    for (i=0; i < data->dwNumIndices; i++)
    {
        if (data->lpwIndices[i] >= data->dwNumVertices)
        {
            D3D_ERR( "Invalid index value in DrawIndexedPrimitive" );
            return DDERR_INVALIDPARAMS;
        }
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// Draws non-indexed primitives which do not require clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrim"

#define __DRAWPRIMFUNC
#include "dpgen.h"
//---------------------------------------------------------------------
// Draws indexed primitives which do not require clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrim"

#define __DRAWPRIMFUNC
#define __DRAWPRIMINDEX
#include "dpgen.h"
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "FlushStatesDP"

HRESULT
CDirect3DDeviceIDP::FlushStates()
{
    HRESULT dwRet=D3D_OK;
    FlushTextureFromDevice( this ); // delink all texture surfaces
    if (this->dwDPOffset>sizeof(D3DHAL_DRAWPRIMCOUNTS))
    {
        if ((dwRet=CheckSurfaces()) != D3D_OK)
        {
            this->dwDPOffset = sizeof(D3DHAL_DRAWPRIMCOUNTS);
            this->lpDPPrimCounts = (LPD3DHAL_DRAWPRIMCOUNTS)this->lpwDPBuffer;
            memset( (char *)this->lpwDPBuffer,0,sizeof(D3DHAL_DRAWPRIMCOUNTS)); //Clear header also
            if (dwRet == DDERR_SURFACELOST)
            {
                this->dwFEFlags |= D3DFE_LOSTSURFACES;
                return D3D_OK;
            }
            return dwRet;
        }

        D3DHAL_DRAWPRIMITIVESDATA dpData;
        DWORD   dwDPOffset;
        if (this->lpDPPrimCounts->wNumVertices)    //this->lpDPPrimCounts->wNumVertices==0 means the end
        {                      //force it if not
            memset(((LPBYTE)this->lpwDPBuffer+this->dwDPOffset),0,sizeof(D3DHAL_DRAWPRIMCOUNTS));
        }
        dpData.dwhContext = this->dwhContext;
        dpData.dwFlags =  0;
        dpData.lpvData = this->lpwDPBuffer;
        if (FVF_DRIVERSUPPORTED(this))
            dpData.dwFVFControl = this->dwCurrentBatchVID;
        else
        {
            if (this->dwDebugFlags & D3DDEBUG_DISABLEFVF)
                dpData.dwFVFControl = D3DFVF_TLVERTEX;
            else
                dpData.dwFVFControl = 0;    //always zero for non-FVF drivers
        }
        dpData.ddrval = 0;
        dwDPOffset=this->dwDPOffset;  //save it in case Flush returns prematurely
#if 0
        if (D3DRENDERSTATE_TEXTUREHANDLE==*((DWORD*)this->lpwDPBuffer+2))
        DPF(0,"Flushing dwDPOffset=%08lx ddihandle=%08lx",dwDPOffset,*((DWORD*)this->lpwDPBuffer+3));
#endif  //0
        //we clear this to break re-entering as SW rasterizer needs to lock DDRAWSURFACE
        this->dwDPOffset = sizeof(D3DHAL_DRAWPRIMCOUNTS);

        // Spin waiting on the driver if wait requested
#if _D3D_FORCEDOUBLE
        CD3DForceFPUDouble  ForceFPUDouble(this);
#endif  //_D3D_FORCEDOUBLE
        do {
#ifndef WIN95
            if((dwRet = CheckContextSurface(this)) != D3D_OK)
            {
                this->dwDPOffset = dwDPOffset;
                return (dwRet);
            }
#endif //WIN95
            CALL_HAL2ONLY(dwRet, this, DrawPrimitives, &dpData);
            if (dwRet != DDHAL_DRIVER_HANDLED)
            {
                D3D_ERR ( "Driver call for DrawOnePrimitive failed" );
                // Need sensible return value in this case,
                // currently we return whatever the driver stuck in here.
            }
        } while (dpData.ddrval == DDERR_WASSTILLDRAWING);
        this->lpDPPrimCounts = (LPD3DHAL_DRAWPRIMCOUNTS)this->lpwDPBuffer;
        memset( (char *)this->lpwDPBuffer,0,sizeof(D3DHAL_DRAWPRIMCOUNTS));   //Clear header also
        dwRet= dpData.ddrval;
        this->dwCurrentBatchVID = this->dwVIDOut;
    }
    return dwRet;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DoDrawPrimitive"

HRESULT DoDrawPrimitive(LPD3DFE_PROCESSVERTICES pv)
{
    HRESULT ret;

    if (!CheckIfNeedClipping(pv))
        return pv->DrawPrim();

    // Preserve primitive type for large begin-end primitives
    // Primitive type could be changed by the clipper
    D3DPRIMITIVETYPE oldPrimType = pv->primType;
    switch (pv->primType)
    {
    case D3DPT_POINTLIST:
        ret = ProcessClippedPoints(pv);
        break;
    case D3DPT_LINELIST:
        ret = ProcessClippedLine(pv);
        break;
    case D3DPT_LINESTRIP:
        ret = ProcessClippedLine(pv);
        break;
    case D3DPT_TRIANGLELIST:
        ret = ProcessClippedTriangleList(pv);
        break;
    case D3DPT_TRIANGLESTRIP:
        ret = ProcessClippedTriangleStrip(pv);
        break;
    case D3DPT_TRIANGLEFAN:
        ret = ProcessClippedTriangleFan(pv);
        break;
    default:
        ret = DDERR_GENERIC;
        break;
    }
    ClampExtents(pv);
    pv->primType = oldPrimType;
    return ret;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DoDrawIndexedPrimitive"

HRESULT DoDrawIndexedPrimitive(LPD3DFE_PROCESSVERTICES pv)
{
    HRESULT ret;

    if (!CheckIfNeedClipping(pv))
        return pv->DrawIndexPrim();

    // Preserve primitive type for large begin-end primitives
    // Primitive type could be changed by the clipper
    D3DPRIMITIVETYPE oldPrimType = pv->primType;
    switch (pv->primType)
    {
    case D3DPT_LINELIST:
        ret = ProcessClippedIndexedLine(pv);
        break;
    case D3DPT_LINESTRIP:
        ret = ProcessClippedIndexedLine(pv);
        break;
    case D3DPT_TRIANGLELIST:
        ret = ProcessClippedIndexedTriangleList(pv);
            break;
    case D3DPT_TRIANGLEFAN:
        ret = ProcessClippedIndexedTriangleFan(pv);
        break;
    case D3DPT_TRIANGLESTRIP:
        ret = ProcessClippedIndexedTriangleStrip(pv);
        break;
    default:
        break;
    }
    ClampExtents(pv);
    pv->primType = oldPrimType;
    return ret;
}
//---------------------------------------------------------------------
// ProcessPrimitive processes indexed, non-indexed primitives or
// vertices only as defined by "op"
//
// op = __PROCPRIMOP_NONINDEXEDPRIM by default
//
HRESULT DIRECT3DDEVICEI::ProcessPrimitive(__PROCPRIMOP op)
{
    HRESULT ret=D3D_OK;
    DWORD vertexPoolSize;
    // Update vertex stats
    this->D3DStats.dwVerticesProcessed += this->dwNumVertices;
        DWORD dwCurrPrimVertices = this->dwNumVertices;

    // Need to call UpdateTextures()
    this->dwFEFlags |= D3DFE_NEED_TEXTURE_UPDATE;

    // Viewport ID could be different from Device->v_id, because during Execute call
    // Device->v_id is changed to whatever viewport is used as a parameter.
    // So we have to make sure that we use the right viewport.
    //
    LPDIRECT3DVIEWPORTI lpView = this->lpCurrentViewport;
    if (this->v_id != lpView->v_id)
    {
        HRESULT ret = downloadView(lpView);
        if (ret != D3D_OK)
            return ret;
    }

// We need to grow TL vertex buffer if
// 1. We have to transform vertices
// 2. We do not have to transform vertices and
//    2.1 Ramp mode is used, because we have to change vertex colors
//    2.2 DP2HAL is used and we have small number of vertices, so we need to
//        copy vertices into TL buffer
//
    vertexPoolSize = this->dwNumVertices * this->dwOutputSize;
    if ((!FVF_TRANSFORMED(this->dwVIDIn)) ||
        (this->dwDeviceFlags & D3DDEV_RAMP))
    {
        if (vertexPoolSize > this->TLVbuf.GetSize())
        {
            if (this->TLVbuf.Grow(this, vertexPoolSize) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                ret = DDERR_OUTOFMEMORY;
                return ret;
            }
        }
        if (IS_DP2HAL_DEVICE(this))
        {
            CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
            ret = dev->StartPrimVB(this->TLVbuf.GetVBI(), 0);
            if (ret != D3D_OK)
                return ret;
        }
        this->lpvOut = this->TLVbuf.GetAddress();
    }

// Grow clip flags buffer if we need clipping
//
    if (!(this->dwFlags & D3DDP_DONOTCLIP))
    {
        DWORD size = this->dwNumVertices * sizeof(D3DFE_CLIPCODE);
        if (size > this->HVbuf.GetSize())
        {
            if (this->HVbuf.Grow(size) != D3D_OK)
            {
                D3D_ERR( "Could not grow clip buffer" );
                ret = DDERR_OUTOFMEMORY;
                return ret;
            }
        }
        this->lpClipFlags = (D3DFE_CLIPCODE*)this->HVbuf.GetAddress();
    }

    if (FVF_TRANSFORMED(this->dwVIDIn))
    {
        if (this->dwDeviceFlags & D3DDEV_RAMP)
        {
            ConvertColorsToRamp(this,
                                (D3DTLVERTEX*)this->position.lpvData,
                                (D3DTLVERTEX*)(this->lpvOut),
                                this->dwNumVertices);
        }
        else
        {
            // Pass vertices directly from the user memory
            this->dwVIDOut = this->dwVIDIn;
            this->dwOutputSize = this->position.dwStride;
            this->lpvOut = this->position.lpvData;
            vertexPoolSize = this->dwNumVertices * this->dwOutputSize;

            if (IS_DP2HAL_DEVICE(this))
            {
                CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
                dev->StartPrimUserMem(this->position.lpvData);
                if (ret != D3D_OK)
                    return ret;
            }
        }
        if (this->dwFlags & D3DDP_DONOTCLIP)
        {
            if (!(this->dwFlags & D3DDP_DONOTUPDATEEXTENTS))
                D3DFE_updateExtents(this);

            if (op == __PROCPRIMOP_INDEXEDPRIM)
            {
                ret = this->DrawIndexPrim();
            }
            else if (op == __PROCPRIMOP_NONINDEXEDPRIM)
            {
                ret = this->DrawPrim();
            }
            goto l_exit;
        }
        else
        {
            // Clear clip union and intersection flags
            this->dwClipIntersection = 0;
            this->dwClipUnion = 0;
            DWORD clip_intersect;
            clip_intersect = this->pGeometryFuncs->GenClipFlags(this);
            D3DFE_UpdateClipStatus(this);
            if (!clip_intersect)
            {
                this->dwFlags |= D3DPV_TLVCLIP;
                if (op == __PROCPRIMOP_INDEXEDPRIM)
                {
                    ret = DoDrawIndexedPrimitive(this);
                }
                else if (op == __PROCPRIMOP_NONINDEXEDPRIM)
                {
                    ret = DoDrawPrimitive(this);
                }
                goto l_exit;
            }
        }
    }
    else
    {
        // Clear clip union and intersection flags
        this->dwClipIntersection = 0;
        this->dwClipUnion = 0;

        // Update Lighting and related flags
        if ((ret = DoUpdateState(this)) != D3D_OK)
            return ret;

        // Call PSGP or our implementation
        if (op == __PROCPRIMOP_INDEXEDPRIM)
            ret = this->pGeometryFuncs->ProcessIndexedPrimitive(this);
        else if (op == __PROCPRIMOP_NONINDEXEDPRIM)
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
        else
            ret = this->pGeometryFuncs->ProcessVertices(this);

        D3DFE_UpdateClipStatus(this);
    }
l_exit:
    if (IS_DP2HAL_DEVICE(this))
    {
        CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
        if (op != __PROCPRIMOP_PROCVERONLY)
            ret = dev->EndPrim(vertexPoolSize);
    }
    return ret;
}
//---------------------------------------------------------------------
// This function is called when a number of indices in an indexed primitive
// is much less than a number of vertices. In this case we build non-indexed
// primitives.
HRESULT DereferenceIndexedPrim(LPDIRECT3DDEVICEI lpDevI)
{
    HRESULT ret = CheckVertexBatch(lpDevI);
    if (ret != D3D_OK)
        return ret;

    // Save original vertice and number of primitives
    D3DVERTEX *lpvVertices = (D3DVERTEX*)lpDevI->position.lpvData;
    DWORD dwNumPrimitivesOrg = lpDevI->dwNumPrimitives;
    WORD *lpwIndices = lpDevI->lpwIndices;
    // We will dereference here
        D3DVERTEX *lpVertex = (D3DVERTEX*)lpDevI->lpvVertexBatch;
    lpDevI->position.lpvData = lpVertex;
    lpDevI->lpwIndices = NULL;

    switch (lpDevI->primType)
    {
        case D3DPT_LINELIST:
        {
            for (DWORD j=0; j < dwNumPrimitivesOrg; j += BEGIN_DATA_BLOCK_SIZE/2)
            {
                lpDevI->dwNumPrimitives = min(dwNumPrimitivesOrg - j,
                                              (BEGIN_DATA_BLOCK_SIZE/2));
                lpDevI->dwNumVertices = lpDevI->dwNumPrimitives << 1;
                D3DVERTEX *lpTmp = lpVertex;
                for (DWORD i=lpDevI->dwNumVertices; i; i--)
                {
                    *lpTmp++ = lpvVertices[*lpwIndices++];
                }
                ret = lpDevI->ProcessPrimitive();
                if (ret != D3D_OK)
                    return ret;
            }
            break;
        }
        case D3DPT_LINESTRIP:
        {
                        for (DWORD j=0; j < dwNumPrimitivesOrg; j+= BEGIN_DATA_BLOCK_SIZE-1)
            {
                                lpDevI->dwNumPrimitives = min(dwNumPrimitivesOrg-j,
                                              (BEGIN_DATA_BLOCK_SIZE-1));
                lpDevI->dwNumVertices = lpDevI->dwNumPrimitives + 1;
                D3DVERTEX *lpTmp = lpVertex;
                                for (DWORD i=lpDevI->dwNumVertices; i; i--)
                {
                                        *lpTmp++ = lpvVertices[*lpwIndices++];
                                }
                                lpwIndices--;   // back off one so the next batch is connected
                                ret = lpDevI->ProcessPrimitive();
                                if (ret != D3D_OK)
                                        return ret;
                        }
                        break;
        }
        case D3DPT_TRIANGLEFAN:
        {
                lpVertex[0] = lpvVertices[*lpwIndices++];
                        for (DWORD j=0; j < dwNumPrimitivesOrg; j+= BEGIN_DATA_BLOCK_SIZE-2)
            {
                                lpDevI->dwNumPrimitives = min(dwNumPrimitivesOrg - j,
                                              (BEGIN_DATA_BLOCK_SIZE-2));
                lpDevI->dwNumVertices = lpDevI->dwNumPrimitives + 2;
                D3DVERTEX *lpTmp = &lpVertex[1];
                                for (DWORD i=lpDevI->dwNumVertices-1; i; i--)
                {
                                        *lpTmp++ = lpvVertices[*lpwIndices++];
                                }
                                lpwIndices--;   // back off one so the next batch is connected
                                ret = lpDevI->ProcessPrimitive();
                                if (ret != D3D_OK)
                                        return ret;
                        }
                        break;
        }
        case D3DPT_TRIANGLESTRIP:
        {
            for (DWORD j=0; j < dwNumPrimitivesOrg; j+= BEGIN_DATA_BLOCK_SIZE-2)
            {
                lpDevI->dwNumPrimitives = min(dwNumPrimitivesOrg-j,
                                              (BEGIN_DATA_BLOCK_SIZE-2));
                lpDevI->dwNumVertices = lpDevI->dwNumPrimitives + 2;
                D3DVERTEX *lpTmp = lpVertex;
                for (DWORD i=lpDevI->dwNumVertices; i; i--)
                {
                    *lpTmp++ = lpvVertices[*lpwIndices++];
                }
                lpwIndices-= 2; // back off so the next batch is connected
                ret = lpDevI->ProcessPrimitive();
                if (ret != D3D_OK)
                    return ret;
            }
            break;
        }
        case D3DPT_TRIANGLELIST:
        {
            for (DWORD j=0; j < dwNumPrimitivesOrg; j+= BEGIN_DATA_BLOCK_SIZE/3)
            {
                lpDevI->dwNumPrimitives = min(dwNumPrimitivesOrg-j,
                                              (BEGIN_DATA_BLOCK_SIZE/3));
                lpDevI->dwNumVertices = lpDevI->dwNumPrimitives * 3;
                D3DVERTEX *lpTmp = lpVertex;
                for (DWORD i=lpDevI->dwNumVertices; i; i--)
                {
                        *lpTmp++ = lpvVertices[*lpwIndices++];
                }
                ret = lpDevI->ProcessPrimitive();
                if (ret != D3D_OK)
                        return ret;
            }
            break;
        }
        }
        return D3D_OK;
}
//---------------------------------------------------------------------
//                              API calls
//---------------------------------------------------------------------

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveStrided"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawPrimitiveStrided(
                             D3DPRIMITIVETYPE PrimitiveType,
                             DWORD dwVertexType,
                             LPD3DDRAWPRIMITIVESTRIDEDDATA lpDrawData,
                             DWORD dwNumVertices,
                             DWORD dwFlags)
{
    HRESULT        ret = D3D_OK;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
    if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
        return DDERR_INVALIDPARAMS;
    Profile(PROF_DRAWPRIMITIVESTRIDED,PrimitiveType,dwVertexType);
#endif
    //note: this check should be done in retail as well as dbg build
    if((dwVertexType & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
        return D3DERR_INVALIDVERTEXTYPE;
    this->primType = PrimitiveType;
    this->dwVIDIn  = dwVertexType;
    this->position = lpDrawData->position;
    this->normal = lpDrawData->normal;
    this->diffuse = lpDrawData->diffuse;
    this->specular = lpDrawData->specular;
    ComputeOutputFVF(this);
    for (DWORD i=0; i < this->nTexCoord; i++)
        this->textures[i] = lpDrawData->textureCoords[i];
    this->dwNumVertices = dwNumVertices;
    this->lpwIndices = NULL;
    this->dwNumIndices = 0;
    this->lpClipFlags = (D3DFE_CLIPCODE*)HVbuf.GetAddress();
    this->dwFlags = dwFlags | D3DPV_STRIDE;
    if (this->dwVIDIn & D3DFVF_NORMAL)
        this->dwFlags |= D3DPV_LIGHTING;

    GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives and update stats

#if DBG
    if (this->dwNumVertices > MAX_DX6_VERTICES)
    {
        D3D_ERR("D3D for DX6 cannot handle greater than 64K vertices");
        return D3DERR_TOOMANYVERTICES;
    }
    ret = CheckDrawPrimitive(this);

    if (ret != D3D_OK)
    {
        return ret;
    }
#endif
    return this->ProcessPrimitive();
}   // end of DrawPrimitiveStrided()
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrimitiveStrided"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawIndexedPrimitiveStrided(
                                 D3DPRIMITIVETYPE PrimitiveType,
                                 DWORD dwVertexType,
                                 LPD3DDRAWPRIMITIVESTRIDEDDATA lpDrawData,
                                 DWORD dwNumVertices,
                                 LPWORD lpwIndices,
                                 DWORD dwNumIndices,
                                 DWORD dwFlags)
{
    HRESULT        ret = D3D_OK;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
    if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
        return DDERR_INVALIDPARAMS;
    Profile(PROF_DRAWINDEXEDPRIMITIVESTRIDED,PrimitiveType,dwVertexType);
#endif
    //note: this check should be done in retail as well as dbg build
    if((dwVertexType & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
        return D3DERR_INVALIDVERTEXTYPE;
    this->primType = PrimitiveType;
    this->dwVIDIn  = dwVertexType;
    this->position = lpDrawData->position;
    this->normal = lpDrawData->normal;
    this->diffuse = lpDrawData->diffuse;
    this->specular = lpDrawData->specular;
    ComputeOutputFVF(this);
    for (DWORD i=0; i < this->nTexCoord; i++)
        this->textures[i] = lpDrawData->textureCoords[i];
    this->dwNumVertices = dwNumVertices;
    this->lpwIndices = lpwIndices;
    this->dwNumIndices = dwNumIndices;
    this->lpClipFlags = (D3DFE_CLIPCODE*)HVbuf.GetAddress();
    this->dwFlags = dwFlags | D3DPV_STRIDE;
    if (this->dwVIDIn & D3DFVF_NORMAL)
        this->dwFlags |= D3DPV_LIGHTING;
    GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives and update stats

#if DBG
    if (this->dwNumPrimitives > MAX_DX6_PRIMCOUNT)
    {
        D3D_ERR("D3D for DX6 cannot handle greater than 64K sized primitives");
        return D3DERR_TOOMANYPRIMITIVES;
    }
    ret = CheckDrawIndexedPrimitive(this);
    if (ret != D3D_OK)
    {
        return ret;
    }
    if (this->dwNumIndices * INDEX_BATCH_SCALE < this->dwNumVertices &&
        !FVF_TRANSFORMED(this->dwVIDIn))
    {
        D3D_WARN(1, "The number of indices is much less than the number of vertices.");
        D3D_WARN(1, "This will likely be inefficient. Consider using vertex buffers.");
    }
#endif
    return this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);
}   // end of DrawIndexedPrimitiveStrided()
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitive3"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType,
                               DWORD dwVertexType,
                               LPVOID lpvVertices,
                               DWORD dwNumVertices,
                               DWORD dwFlags)
{
    HRESULT        ret = D3D_OK;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
    if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
        return DDERR_INVALIDPARAMS;
    Profile(PROF_DRAWPRIMITIVEDEVICE3,PrimitiveType,dwVertexType);
#endif

    /* This stuff does not change from call to call */
    this->lpwIndices = NULL;
    this->dwNumIndices = 0;
    this->lpClipFlags = (D3DFE_CLIPCODE*)HVbuf.GetAddress();
    /* This stuff is mandatory for the call */
    this->primType = PrimitiveType;
    this->dwVIDIn  = dwVertexType;
    this->position.lpvData = lpvVertices;
    this->dwNumVertices = dwNumVertices;
    this->dwFlags = dwFlags;
    /* This stuff depends upon the vertex type */
    this->position.dwStride = GetVertexSizeFVF(this->dwVIDIn);
    if (this->dwVIDIn & D3DFVF_NORMAL)
        this->dwFlags |= D3DPV_LIGHTING;
    ComputeOutputFVF(this);
    GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives and update stats

#if DBG
    if (this->dwNumVertices > MAX_DX6_VERTICES)
    {
        D3D_ERR("D3D for DX6 cannot handle greater than 64K vertices");
        return D3DERR_TOOMANYVERTICES;
    }
    ret = CheckDrawPrimitive(this);
    if (ret != D3D_OK)
    {
        return ret;
    }
#endif
    return this->ProcessPrimitive();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::DrawIndexedPrimitive"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawIndexedPrimitive(D3DPRIMITIVETYPE PrimitiveType,
                                      DWORD  dwVertexType,
                                      LPVOID lpvVertices, DWORD dwNumVertices,
                                      LPWORD lpwIndices, DWORD dwNumIndices,
                                      DWORD dwFlags)
{
    HRESULT ret = D3D_OK;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
    if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
        return DDERR_INVALIDPARAMS;
    Profile(PROF_DRAWINDEXEDPRIMITIVEDEVICE3,PrimitiveType,dwVertexType);
#endif
    // Static part
    this->lpClipFlags = (D3DFE_CLIPCODE*)HVbuf.GetAddress();
    // Mandatory part
    this->primType = PrimitiveType;
    this->dwVIDIn = dwVertexType;
    this->dwNumVertices = dwNumVertices;
    this->lpwIndices = lpwIndices;
    this->dwNumIndices = dwNumIndices;
    this->dwFlags = dwFlags;
    this->position.lpvData = lpvVertices;
    // Stuff that depends upon dwVIDIn
    this->position.dwStride = GetVertexSizeFVF(this->dwVIDIn);
    if (this->dwVIDIn & D3DFVF_NORMAL)
        this->dwFlags |= D3DPV_LIGHTING;
    ComputeOutputFVF(this);
    GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives and update stats

#if DBG
    if (this->dwNumPrimitives > MAX_DX6_PRIMCOUNT)
    {
        D3D_ERR("D3D for DX6 cannot handle greater than 64K sized primitives");
        return D3DERR_TOOMANYPRIMITIVES;
    }
    ret = CheckDrawIndexedPrimitive(this);
    if (ret != D3D_OK)
    {
        return ret;
    }
    if (this->dwNumIndices * INDEX_BATCH_SCALE < this->dwNumVertices &&
        !FVF_TRANSFORMED(this->dwVIDIn))
    {
        D3D_WARN(1, "The number of indices is much less than the number of vertices.");
        D3D_WARN(1, "This will likely be inefficient. Consider using vertex buffers.");
    }
#endif
    return this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitive"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType,
                               D3DVERTEXTYPE VertexType,
                               LPVOID lpvVertices, DWORD dwNumVertices, DWORD dwFlags)
{
    HRESULT        ret = D3D_OK;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.
#if DBG
    if (!IsDPFlagsValid(dwFlags))
        return DDERR_INVALIDPARAMS;

    if((VertexType<=0) || (VertexType>D3DVT_TLVERTEX)) {
        D3D_ERR("Invalid VertexType");
        return D3DERR_INVALIDVERTEXTYPE;
    }
    Profile(PROF_DRAWPRIMITIVEDEVICE2,PrimitiveType,VertexType);
#endif
    /* Static assignments */
    this->position.dwStride = sizeof(D3DVERTEX);
    this->lpwIndices = NULL;
    this->dwNumIndices = 0;
    this->lpClipFlags = (D3DFE_CLIPCODE*)HVbuf.GetAddress();
    this->nTexCoord = 1;
    /* Necessary work */
    this->primType = PrimitiveType;
    this->dwNumVertices = dwNumVertices;
    this->dwFlags = dwFlags;
    this->position.lpvData = lpvVertices;
    this->dwVIDIn = d3dVertexToFVF[VertexType];
    DWORD dwVertexSize = sizeof(D3DVERTEX);
    ComputeOutputFVF(this);
    if (this->dwVIDIn & D3DFVF_NORMAL)
        this->dwFlags |= D3DPV_LIGHTING;

    // AnanKan (6/22/98)
    // !! This is a hack for the crippled DP2 driver model which cannot accept
    // !! more that 64K vertices. In DX6 interfaces we fail rendering if we
    // !! encounter such large primitives for all DDI.
    // !! In the legacy (DX5) interfaces,
    // !! If the primitive size is greater than MAX_DX6_PRIMCOUNT and
    // !! the DDI cannot handle it, then we to break up the primitive into
    // !! manageable chunks.

    if ((this->dwNumVertices > MAX_DX6_VERTICES) &&
        (IS_DP2HAL_DEVICE(this)))
    {
        DWORD dwOrigNumVerts = this->dwNumVertices;
        WORD wChunkSize = MAX_DX6_VERTICES - 3; // Even and a multiple of 3
        BYTE TmpVertex[32], FirstVertex[32];
        DWORD dwStepPerChunk;

        switch(this->primType)
        {
        case D3DPT_POINTLIST:
        case D3DPT_LINELIST:
        case D3DPT_TRIANGLELIST:
            dwStepPerChunk = dwVertexSize*wChunkSize;
            break;
        case D3DPT_LINESTRIP:
            dwStepPerChunk = dwVertexSize*(wChunkSize - 1);
            break;
        case D3DPT_TRIANGLEFAN:
            // Save the first index
            memcpy(FirstVertex, this->position.lpvData, dwVertexSize);
            // Fall through
        case D3DPT_TRIANGLESTRIP:
            dwStepPerChunk = dwVertexSize*(wChunkSize - 2);
            break;
        }

        int numChunks = (int)(dwOrigNumVerts/(DWORD)wChunkSize);
        WORD wRemainingVerts = (WORD)(dwOrigNumVerts - wChunkSize*numChunks);
        this->dwNumVertices = wChunkSize;
        // Calculate dwNumPrimitives and update stats
        GetNumPrim(this, this->dwNumVertices);

        // 0th iteration
#if DBG
        ret = CheckDrawPrimitive(this);
        if (ret != D3D_OK)
        {
            return ret;
        }
#endif
        ret = this->ProcessPrimitive();
        if (ret != D3D_OK)
        {
            return ret;
        }

        for (int i=1; i<numChunks; i++)
        {
            this->position.lpvData = (LPVOID)((LPBYTE)this->position.lpvData +
                                              dwStepPerChunk);
            if (this->primType == D3DPT_TRIANGLEFAN)
            {
                // Save the vertex
                memcpy(TmpVertex, this->position.lpvData, dwVertexSize);
                // Copy in the first vertex
                memcpy(this->position.lpvData, FirstVertex, dwVertexSize);
            }

#if DBG
            ret = CheckDrawPrimitive(this);
            if (ret != D3D_OK)
            {
                return ret;
            }
#endif
            ret = this->ProcessPrimitive();

            // Write back the proper vertex in case something has been
            // switched
            if(this->primType == D3DPT_TRIANGLEFAN)
                memcpy(this->position.lpvData, TmpVertex, dwVertexSize);

            if (ret != D3D_OK)
            {
                return ret;
            }
        }

        // The last time around
        if (wRemainingVerts)
        {
            this->dwNumVertices = wRemainingVerts;
            // Calculate dwNumPrimitives and update stats
            GetNumPrim(this, this->dwNumVertices);
            this->position.lpvData = (LPVOID)((LPBYTE)this->position.lpvData +
                                              dwStepPerChunk);
            if (this->primType == D3DPT_TRIANGLEFAN)
            {
                memcpy(TmpVertex, this->position.lpvData, dwVertexSize);
                memcpy(this->position.lpvData, FirstVertex, dwVertexSize);
            }
#if DBG
            ret = CheckDrawPrimitive(this);
            if (ret != D3D_OK)
            {
                return ret;
            }
#endif
            ret = this->ProcessPrimitive();

            // Write back the proper vertex in case something has been
            // switched
            if(this->primType == D3DPT_TRIANGLEFAN)
                memcpy(this->position.lpvData, TmpVertex, dwVertexSize);

            if (ret != D3D_OK)
            {
                return ret;
            }
        }
    }
    else
    {
        // Calculate dwNumPrimitives and update stats
        GetNumPrim(this, dwNumVertices);
#if DBG
        ret = CheckDrawPrimitive(this);
        if (ret != D3D_OK)
        {
            return ret;
        }
#endif
        return this->ProcessPrimitive();
    }

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrimitive"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawIndexedPrimitive(D3DPRIMITIVETYPE PrimitiveType,
                                      D3DVERTEXTYPE VertexType,
                                      LPVOID lpvVertices, DWORD dwNumVertices,
                                      LPWORD lpwIndices, DWORD dwNumIndices,
                                      DWORD dwFlags)
{
    HRESULT ret = D3D_OK;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
    if (!IsDPFlagsValid(dwFlags))
        return DDERR_INVALIDPARAMS;
    Profile(PROF_DRAWINDEXEDPRIMITIVEDEVICE2,PrimitiveType,VertexType);
#endif
    this->primType = PrimitiveType;
    this->dwVIDIn = d3dVertexToFVF[VertexType];
    this->position.dwStride =  sizeof(D3DVERTEX);
    this->dwNumVertices = dwNumVertices;
    this->lpwIndices = lpwIndices;
    this->dwNumIndices = dwNumIndices;
    this->lpClipFlags = (D3DFE_CLIPCODE*)HVbuf.GetAddress();
    this->dwFlags = dwFlags;
    this->position.lpvData = lpvVertices;
    this->nTexCoord = 1;
    ComputeOutputFVF(this);
    if (this->dwVIDIn & D3DFVF_NORMAL)
        this->dwFlags |= D3DPV_LIGHTING;
    GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives and update stats

    // AnanKan (6/22/98)
    // !! This is a hack for the crippled DP2 driver model which cannot accept
    // !! more that 64K primitives (primcount is a WORD). In DX6 interfaces
    // !! we fail rendering if we encounter such large primitives.
    // !! We do this for all DDI.
    // !! In the legacy (DX5) interfaces,
    // !! If the primitive size is greater than MAX_DX6_PRIMCOUNT and
    // !! the DDI cannot handle it, then we to break up the primitive into
    // !! manageable chunks.

    if ((this->dwNumPrimitives > MAX_DX6_PRIMCOUNT) &&
        (IS_DP2HAL_DEVICE(this)))
    {
        WORD wFirstIndex, wTmpIndex;
        WORD wChunkSize = MAX_DX6_PRIMCOUNT;
        int numPrimChunks;
        DWORD dwResidualPrim;
        DWORD dwResidualIndices;
        DWORD dwStepPerChunk;
        DWORD dwOrigNumPrim = this->dwNumPrimitives;
        this->dwNumPrimitives = wChunkSize;
        numPrimChunks = (int)(dwOrigNumPrim/(DWORD)wChunkSize);
        dwResidualPrim = dwOrigNumPrim - wChunkSize*numPrimChunks;

        switch(this->primType)
        {
        case D3DPT_POINTLIST:
            this->dwNumIndices = this->dwNumPrimitives;
            dwStepPerChunk = this->dwNumIndices;
            dwResidualIndices = dwResidualPrim;
            break;
        case D3DPT_LINELIST:
            this->dwNumIndices = this->dwNumPrimitives<<1;
            dwStepPerChunk = this->dwNumIndices;
            dwResidualIndices = dwResidualPrim << 1;
            break;
        case D3DPT_LINESTRIP:
            this->dwNumIndices = this->dwNumPrimitives + 1;
            dwStepPerChunk = this->dwNumIndices - 1;
            dwResidualIndices = dwResidualPrim + 1;
            break;
        case D3DPT_TRIANGLEFAN:
            this->dwNumIndices = this->dwNumPrimitives + 2;
            dwStepPerChunk = this->dwNumIndices - 2;
            dwResidualIndices = dwResidualPrim + 2;
            // Save the first index
            wTmpIndex = wFirstIndex = this->lpwIndices[0];
            break;
        case D3DPT_TRIANGLESTRIP:
            wChunkSize = (MAX_DX6_PRIMCOUNT-1);
            this->dwNumPrimitives = wChunkSize;
            this->dwNumIndices = this->dwNumPrimitives + 2;
            dwStepPerChunk = this->dwNumIndices - 2;
            numPrimChunks = (int)(dwOrigNumPrim/(DWORD)wChunkSize);
            dwResidualPrim = dwOrigNumPrim - wChunkSize*numPrimChunks;
            dwResidualIndices = dwResidualPrim + 2;
            break;
        case D3DPT_TRIANGLELIST:
            this->dwNumIndices = this->dwNumPrimitives * 3;
            dwStepPerChunk = this->dwNumIndices;
            dwResidualIndices = dwResidualPrim * 3;
            break;
        }

        // 0th iteration
#if DBG
        ret = CheckDrawIndexedPrimitive(this);
        if (ret != D3D_OK)
        {
            return ret;
        }
#endif
        ret = this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);
        if (ret != D3D_OK)
        {
            return ret;
        }

        // Remaining chunks
        for (int i=1; i<numPrimChunks; i++)
        {
            this->lpwIndices += dwStepPerChunk;

            if (this->primType == D3DPT_TRIANGLEFAN)
            {
                // Save the index
                wTmpIndex = this->lpwIndices[0];
                // Copy in the first vertex
                this->lpwIndices[0] = wFirstIndex;
            }

#if DBG
            ret = CheckDrawIndexedPrimitive(this);
            if (ret != D3D_OK)
            {
                return ret;
            }
#endif
            ret = this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);

            // Write back the proper index in case something has been
            // switched
            if(this->primType == D3DPT_TRIANGLEFAN)
                this->lpwIndices[0] = wTmpIndex;

            if (ret != D3D_OK)
            {
                return ret;
            }
        }

        // The last time around
        if (dwResidualPrim)
        {
            this->dwNumPrimitives = dwResidualPrim;
            this->dwNumIndices = dwResidualIndices;
            this->lpwIndices += dwStepPerChunk;
            if (this->primType == D3DPT_TRIANGLEFAN)
            {
                wTmpIndex = this->lpwIndices[0];
                this->lpwIndices[0] = wFirstIndex;
            }
#if DBG
            ret = CheckDrawIndexedPrimitive(this);
            if (ret != D3D_OK)
            {
                return ret;
            }
#endif
            ret = this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);
            // Write back the proper index in case something has been
            // switched
            if(this->primType == D3DPT_TRIANGLEFAN)
                this->lpwIndices[0] = wTmpIndex;
            if (ret != D3D_OK)
            {
                return ret;
            }
        }
    }
    else
    {

#if DBG
        ret = CheckDrawIndexedPrimitive(this);
        if (ret != D3D_OK)
        {
            return ret;
        }
#endif
        // For an untransformed primitive, if a number of indices is much less
        // than number of vertices we rebuild the primitive to reduce number
        // of vertices to process.
        if (this->dwNumIndices * INDEX_BATCH_SCALE < this->dwNumVertices &&
            !FVF_TRANSFORMED(this->dwVIDIn))
            return DereferenceIndexedPrim(this);
        else
            return this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP::SetRenderStateI"

HRESULT D3DAPI
CDirect3DDeviceIDP::SetRenderStateI(D3DRENDERSTATETYPE dwStateType,
                                    DWORD value)
{
    LPD3DHAL_DRAWPRIMCOUNTS lpPC;
    LPDWORD lpStateChange;
    HRESULT ret;
    if (dwStateType > D3DRENDERSTATE_STIPPLEPATTERN31)
    {
        D3D_WARN(4,"Trying to send invalid state %d to legacy driver",dwStateType);
        return D3D_OK;
    }
    if (dwStateType > D3DRENDERSTATE_FLUSHBATCH && dwStateType < D3DRENDERSTATE_STIPPLEPATTERN00)
    {
        D3D_WARN(4,"Trying to send invalid state %d to legacy driver",dwStateType);
        return D3D_OK;
    }

    if (D3DRENDERSTATE_FLUSHBATCH == dwStateType)
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in SetRenderStateI");
        }
        return ret;
    }

    lpPC = this->lpDPPrimCounts;
    if (lpPC->wNumVertices) //Do we already have Vertices filled in for this count ?
    {               //Yes, then Increment count
        lpPC=this->lpDPPrimCounts=(LPD3DHAL_DRAWPRIMCOUNTS)((LPBYTE)this->lpwDPBuffer+this->dwDPOffset);
        memset( (char *)lpPC,0,sizeof(D3DHAL_DRAWPRIMCOUNTS));
        this->dwDPOffset += sizeof(D3DHAL_DRAWPRIMCOUNTS);
    }
    if (this->dwDPOffset + 2*sizeof(DWORD)  > this->dwDPMaxOffset )
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in SetRenderStateI");
            return ret;
        }
    }
    lpStateChange=(LPDWORD)((char *)this->lpwDPBuffer + this->dwDPOffset);
    *lpStateChange=dwStateType;
    lpStateChange ++;
    *lpStateChange=value;
    this->lpDPPrimCounts->wNumStateChanges ++;
    this->dwDPOffset += 2*sizeof(DWORD);
#if 0
    if (dwStateType == D3DRENDERSTATE_TEXTUREHANDLE && this->dwDPOffset== 0x10){
    DPF(0,"SRdwDPOffset=%08lx, dwStateType=%08lx value=%08lx ddihandle=%08lx lpStateChange=%08lx lpDPPrimCounts=%08lx",
    this->dwDPOffset,dwStateType,value,*lpStateChange,lpStateChange,this->lpDPPrimCounts);
        _asm int 3
    }
#endif //0

    return D3D_OK;
}
//---------------------------------------------------------------------
DWORD visResults[6][2] =
{
    D3DVIS_INTERSECT_LEFT   ,
    D3DVIS_OUTSIDE_LEFT     ,
    D3DVIS_INTERSECT_RIGHT  ,
    D3DVIS_OUTSIDE_RIGHT    ,
    D3DVIS_INTERSECT_TOP    ,
    D3DVIS_OUTSIDE_TOP      ,
    D3DVIS_INTERSECT_BOTTOM ,
    D3DVIS_OUTSIDE_BOTTOM   ,
    D3DVIS_INTERSECT_NEAR   ,
    D3DVIS_OUTSIDE_NEAR     ,
    D3DVIS_INTERSECT_FAR    ,
    D3DVIS_OUTSIDE_FAR
};
//---------------------------------------------------------------------
DWORD CheckSphere(LPDIRECT3DDEVICEI lpDevI, LPD3DVECTOR center, D3DVALUE radius)
{
    DWORD result = 0;
    for (int i=0; i < 6; i++)
    {
        // Compute a distance from the center to the plane
        D3DVALUE d = lpDevI->transform.frustum[i].x*center->x +
                     lpDevI->transform.frustum[i].y*center->y +
                     lpDevI->transform.frustum[i].z*center->z +
                     lpDevI->transform.frustum[i].w;
        if (d + radius < 0)
            result |= visResults[i][1];  // Outside
        else
        if (d - radius < 0.5f)  // 0.5 is chosen to offset precision errors
            result |= visResults[i][0];  // Intersect
    }
    if (result & (D3DVIS_OUTSIDE_LEFT   |
                  D3DVIS_OUTSIDE_RIGHT  |
                  D3DVIS_OUTSIDE_TOP    |
                  D3DVIS_OUTSIDE_BOTTOM |
                  D3DVIS_OUTSIDE_NEAR   |
                  D3DVIS_OUTSIDE_FAR))
    {
        result |= D3DVIS_OUTSIDE_FRUSTUM;
    }
    else
    if (result)
        result |= D3DVIS_INTERSECT_FRUSTUM;

    return result;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::ComputeSphereVisibility"

HRESULT D3DAPI
DIRECT3DDEVICEI::ComputeSphereVisibility(LPD3DVECTOR lpCenters,
                                         LPD3DVALUE lpRadii,
                                         DWORD dwNumSpheres,
                                         DWORD dwFlags,
                                         LPDWORD lpdwReturnValues)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
    TRY
    {
        if (dwFlags != 0 || dwNumSpheres == 0 ||
            IsBadWritePtr(lpdwReturnValues, dwNumSpheres * sizeof(DWORD)) ||
            IsBadWritePtr(lpRadii, dwNumSpheres * sizeof(D3DVALUE)) ||
            IsBadWritePtr(lpCenters, dwNumSpheres * sizeof(LPD3DVECTOR)))
        {
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
#endif

    this->dwFlags = 0;
    if (dwFEFlags & D3DFE_TRANSFORM_DIRTY)
    {
        updateTransform(this);
    }
    if (this->dwFEFlags & D3DFE_FRUSTUMPLANES_DIRTY)
    {
        this->dwFlags |= D3DPV_FRUSTUMPLANES_DIRTY;
        this->dwFEFlags &= ~D3DFE_FRUSTUMPLANES_DIRTY;
    }

    return this->pGeometryFuncs->ComputeSphereVisibility(this,
                                                         lpCenters,
                                                         lpRadii,
                                                         dwNumSpheres,
                                                         dwFlags,
                                                         lpdwReturnValues);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ID3DFE_PVFUNCS::ComputeSphereVisibility"

HRESULT
D3DFE_PVFUNCS::ComputeSphereVisibility(LPD3DFE_PROCESSVERTICES pv,
                                       LPD3DVECTOR lpCenters,
                                       LPD3DVALUE lpRadii,
                                       DWORD dwNumSpheres,
                                       DWORD dwFlags,
                                       LPDWORD lpdwReturnValues)
{
    LPDIRECT3DDEVICEI lpDevI = static_cast<LPDIRECT3DDEVICEI>(pv);
    HRESULT ret = D3DERR_INVALIDMATRIX;

#define transform lpDevI->transform

    if (pv->dwFlags & D3DPV_FRUSTUMPLANES_DIRTY)
    {
        transform.dwFlags &= ~D3DTRANS_VALIDFRUSTUM;
        if (Inverse4x4((D3DMATRIX*)&lpDevI->mCTM,
                       (D3DMATRIX*)&transform.mCTMI))
        {
            D3D_ERR("Cannot invert current (World X View) matrix.");
            return ret;
        }
        // Transform the following clipping volume points to the model space by
        // multiplying by inverse CTM
        //
        // v1 = { 0, 0, 0, 1};
        // v2 = { 1, 0, 0, 1};
        // v3 = { 1, 1, 0, 1};
        // v4 = { 0, 1, 0, 1};
        // v5 = { 0, 0, 1, 1};
        // v6 = { 1, 0, 1, 1};
        // v7 = { 0, 1, 1, 1};
        //
        // We do it manually to speed up
        //
        D3DVECTORH v1 = {transform.mCTMI._41,
                         transform.mCTMI._42,
                         transform.mCTMI._43,
                         transform.mCTMI._44};
        D3DVECTORH v2 = {transform.mCTMI._11 + transform.mCTMI._41,
                         transform.mCTMI._12 + transform.mCTMI._42,
                         transform.mCTMI._13 + transform.mCTMI._43,
                         transform.mCTMI._14 + transform.mCTMI._44};
        D3DVECTORH v3 = {transform.mCTMI._11 + transform.mCTMI._21 + transform.mCTMI._41,
                         transform.mCTMI._12 + transform.mCTMI._22 + transform.mCTMI._42,
                         transform.mCTMI._13 + transform.mCTMI._23 + transform.mCTMI._43,
                         transform.mCTMI._14 + transform.mCTMI._24 + transform.mCTMI._44};
        D3DVECTORH v4 = {transform.mCTMI._21 + transform.mCTMI._41,
                         transform.mCTMI._22 + transform.mCTMI._42,
                         transform.mCTMI._23 + transform.mCTMI._43,
                         transform.mCTMI._24 + transform.mCTMI._44};
        D3DVECTORH v5 = {transform.mCTMI._31 + transform.mCTMI._41,
                         transform.mCTMI._32 + transform.mCTMI._42,
                         transform.mCTMI._33 + transform.mCTMI._43,
                         transform.mCTMI._34 + transform.mCTMI._44};
        D3DVECTORH v6 = {transform.mCTMI._11 + transform.mCTMI._31 + transform.mCTMI._41,
                         transform.mCTMI._12 + transform.mCTMI._32 + transform.mCTMI._42,
                         transform.mCTMI._13 + transform.mCTMI._33 + transform.mCTMI._43,
                         transform.mCTMI._14 + transform.mCTMI._34 + transform.mCTMI._44};
        D3DVECTORH v7 = {transform.mCTMI._21 + transform.mCTMI._31 + transform.mCTMI._41,
                         transform.mCTMI._22 + transform.mCTMI._32 + transform.mCTMI._42,
                         transform.mCTMI._23 + transform.mCTMI._33 + transform.mCTMI._43,
                         transform.mCTMI._24 + transform.mCTMI._34 + transform.mCTMI._44};

        // Convert vectors from homogeneous to 3D
        if (Vector4to3D(&v1))
            goto exit;
        if (Vector4to3D(&v2))
            goto exit;
        if (Vector4to3D(&v3))
            goto exit;
        if (Vector4to3D(&v4))
            goto exit;
        if (Vector4to3D(&v5))
            goto exit;
        if (Vector4to3D(&v6))
            goto exit;
        if (Vector4to3D(&v7))
            goto exit;
        // Build frustum planes
        // Left
        if (MakePlane((D3DVECTOR*)&v1, (D3DVECTOR*)&v4, (D3DVECTOR*)&v5, &transform.frustum[0]))
            goto exit;
        // Right
        if (MakePlane((D3DVECTOR*)&v2, (D3DVECTOR*)&v6, (D3DVECTOR*)&v3, &transform.frustum[1]))
            goto exit;
        // Top
        if (MakePlane((D3DVECTOR*)&v4, (D3DVECTOR*)&v3, (D3DVECTOR*)&v7, &transform.frustum[2]))
            goto exit;
        // Bottom
        if (MakePlane((D3DVECTOR*)&v1, (D3DVECTOR*)&v5, (D3DVECTOR*)&v2, &transform.frustum[3]))
            goto exit;
        // Near
        if (MakePlane((D3DVECTOR*)&v1, (D3DVECTOR*)&v2, (D3DVECTOR*)&v3, &transform.frustum[4]))
            goto exit;
        // Far
        if (MakePlane((D3DVECTOR*)&v6, (D3DVECTOR*)&v5, (D3DVECTOR*)&v7, &transform.frustum[5]))
            goto exit;

        transform.dwFlags |= D3DTRANS_VALIDFRUSTUM;
    }

    if (transform.dwFlags & D3DTRANS_VALIDFRUSTUM)
    {
        // Now we can check the spheres against the clipping planes

        for (DWORD i=0; i < dwNumSpheres; i++)
        {
            lpdwReturnValues[i] = CheckSphere(lpDevI, &lpCenters[i], lpRadii[i]);
        }
        return D3D_OK;
    }

exit:
    D3D_ERR("Non-orthogonal (world X view) matrix");
    return ret;
#undef transform
}
//---------------------------------------------------------------------
DWORD
D3DFE_PVFUNCS::GenClipFlags(D3DFE_PROCESSVERTICES *pv)
{
    return D3DFE_GenClipFlags(pv);
}
//---------------------------------------------------------------------
DWORD
D3DFE_PVFUNCS::TransformVertices(D3DFE_PROCESSVERTICES *pv, 
                                 DWORD vertexCount, 
                                 LPD3DTRANSFORMDATAI data)
{

    if (pv->dwFlags & D3DDP_DONOTCLIP) 
        return D3DFE_TransformUnclippedVp(pv, vertexCount, data);
    else 
        return D3DFE_TransformClippedVp(pv, vertexCount, data);
}
//---------------------------------------------------------------------
DWORD ID3DFE_PVFUNCS::GenClipFlags(D3DFE_PROCESSVERTICES *pv)
{   
    return GeometryFuncsGuaranteed.GenClipFlags(pv);
}
//---------------------------------------------------------------------
// Used to implement viewport->TransformVertices
// Returns clip intersection code
DWORD ID3DFE_PVFUNCS::TransformVertices(D3DFE_PROCESSVERTICES *pv, 
                                DWORD vertexCount, 
                                D3DTRANSFORMDATAI* data)
{
    return GeometryFuncsGuaranteed.TransformVertices(pv, vertexCount, data);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\dlld3d.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   dlld3d.cpp
 *  Content:    Direct3D startup
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *   21/11/95   colinmc Added Direct3D interface ID.
 *   07/12/95   stevela Merged Colin's changes.
 *   10/12/95   stevela Removed AGGREGATE_D3D.
 *   02/03/96   colinmc Minor build fix.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Define the Direct3D IIDs.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D Startup"

DPF_DECLARE(Direct3D);

#ifdef WIN95
LPVOID lpWin16Lock;
#endif

DWORD dwD3DTriBatchSize, dwTriBatchSize, dwLineBatchSize;
DWORD dwHWBufferSize, dwHWMaxTris, dwHWFewVertices;
HINSTANCE hGeometryDLL = NULL;
LPD3DFE_CONTEXTCREATE pfnFEContextCreate;
char szCPUString[13];

DWORD dwCPUFamily, dwCPUFeatures;

#ifdef _X86_
extern HRESULT D3DAPI pii_FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);
extern HRESULT D3DAPI katmai_FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);
extern LPD3DFE_CONTEXTCREATE px3DContextCreate;
#endif

void SetMostRecentApp(void);

#ifdef _X86_
// --------------------------------------------------------------------------
// Here's a routine helps us determine if we should try MMX or not
// --------------------------------------------------------------------------
BOOL _asm_isMMX()
{
    DWORD retval;
    _asm
        {
            xor         eax,eax         ; Clear out eax for return value
            pushad              ; CPUID trashes lots - save everything
            mov     eax,1           ; Check for MMX support

            ;;; We need to upgrade our compiler
            ;;; CPUID == 0f,a2
            _emit   0x0f
            _emit   0xa2

            test    edx,00800000h   ; Set flags before restoring registers

            popad               ; Restore everything

            setnz    al             ; Set return value
            mov     retval, eax
        };
    return retval;
}
#endif

static int isMMX = -1;

BOOL
isMMXprocessor(void)
{
    HKEY hKey;
    if ( RegOpenKey( HKEY_LOCAL_MACHINE,
                     RESPATH_D3D,
                     &hKey) == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = 4;
        if ( RegQueryValueEx( hKey, "DisableMMX", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) == ERROR_SUCCESS &&
             dwType == REG_DWORD &&
             dwValue != 0)
        {
            RegCloseKey( hKey );
            isMMX = 0;
            return FALSE;
        }
        RegCloseKey( hKey );
    }

    if (isMMX < 0)
    {
        isMMX = FALSE;
#ifdef _X86_
        D3D_WARN(1, "Executing processor detection code (benign first-chance exception possible)" );
#ifndef WIN95
        {
            // GetSystemInfo is not broken on WinNT.
            SYSTEM_INFO si;

            GetSystemInfo(&si);
            if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL &&
                si.wProcessorLevel >= 5)
            {
#endif
                __try
                    {
                        if( _asm_isMMX() )
                        {

                            // Emit an emms instruction.
                            // This file needs to compile for non-Pentium
                            // processors
                            // so we can't use use inline asm since we're in the
                            // wrong
                            // processor mode.
                            __asm __emit 0xf;
                            __asm __emit 0x77;
                            isMMX = TRUE;
                            D3D_INFO(1, "MMX detected");
                        }
                    }
                __except(GetExceptionCode() == STATUS_ILLEGAL_INSTRUCTION ?
                         EXCEPTION_EXECUTE_HANDLER :
                         EXCEPTION_CONTINUE_SEARCH)
                    {
                    }
#ifndef WIN95
            }

        }
#endif
#endif
    }
    return isMMX;
}

#ifdef _X86_

extern BOOL isX3Dprocessor(void);
//---------------------------------------------------------------------
// Detects PentiumII/Katmai processor
//
#pragma optimize("", off)
#define CPUID _asm _emit 0x0f _asm _emit 0xa2

BOOL IsPentiumIIProcessor(void)
{
    DWORD RegisterEAX;
        char VendorId[12];
        const char IntelId[13]="GenuineIntel";

        __try
        {
            _asm {
                xor         eax,eax
                CPUID
                mov             RegisterEAX, eax
                mov             dword ptr VendorId, ebx
                mov             dword ptr VendorId+4, edx
                mov             dword ptr VendorId+8, ecx
            }
        } __except (1)
        {
                return FALSE;
        }

        // make sure EAX is > 0 which means the chip
        // supports a value of 1 which is the chip info
        if (RegisterEAX == 0)
                return FALSE;

        // make sure chip is "GenuineIntel"
        for (int i=0; i<12; i++)
                if (VendorId[i] != IntelId[i])
                        return FALSE;

        __try
        {
            _asm {
                mov    eax, 1
                CPUID
                mov    RegisterEAX, eax
                }
        } __except (1)
        {
                return FALSE;
        }

        // EAX[3:0] = stepping id
        // EAX[7:4] = model = 0001 (Pentium Pro), 0011 and 0101 (Pentium II)
        // EAX[11:8] = family = 0110
        // EAX[13:12] = processor type = 00
        if ((RegisterEAX & 0x3F00) != 0x0600)   // test for processor type & family
                return FALSE;
        RegisterEAX = (RegisterEAX & 0xf0);     // test for model
        if (RegisterEAX >= 0x30)  // add RegisterEAX == 0x10 for Pentium Pro
                return TRUE;
        else
                return FALSE;
}

BOOL IsKatmaiProcessor(void)
{
        DWORD RegisterEAX;
        char VendorId[12];
        const char IntelId[13]="GenuineIntel";

        __try
        {
                _asm {
            xor         eax,eax
            CPUID
                mov             RegisterEAX, eax
                mov             dword ptr VendorId, ebx
                mov             dword ptr VendorId+4, edx
                mov             dword ptr VendorId+8, ecx
                }
        } __except (1)
        {
                return FALSE;
        }

        // make sure EAX is > 0 which means the chip
        // supports a value >=1. 1 = chip info
        if (RegisterEAX == 0)
                return FALSE;

        // make sure chip is "GenuineIntel"
        for (int i=0; i<12; i++)
                if (VendorId[i] != IntelId[i])
                        return FALSE;

        // this CPUID can't fail if the above test passed
        _asm {
            mov         eax, 1
            CPUID
                mov             RegisterEAX, eax
        }

        // EAX[3:0] = stepping id
        // EAX[7:4] = model = 0001 (Pentium Pro), 0011 and 0101 (Pentium II)
        // EAX[11:8] = family = 0110
        // EAX[13:12] = processor type = 00
        RegisterEAX = (RegisterEAX & 0x3FF0);   // test for model
        if (RegisterEAX >= 0x670)        // Katmai or newer
                return TRUE;
        else
                return FALSE;
}

#pragma optimize("", on)

#ifdef WIN95 // and Win98...
//---------------------------------------------------------------------
BOOL
IsWin95(void)
{
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (!GetVersionEx(&osvi))
    {
        D3D_INFO(1,"GetVersionEx failed - assuming Win95");
        return TRUE;
    }

    if ( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId )
    {

        if( ( osvi.dwMajorVersion > 4UL ) ||
            ( ( osvi.dwMajorVersion == 4UL ) &&
              ( osvi.dwMinorVersion >= 10UL ) &&
              ( LOWORD( osvi.dwBuildNumber ) >= 1373 ) ) )
        {
            // is Win98
            D3D_INFO(2,"Detected Win98");
            return FALSE;
        }
        else
        {
            // is Win95
            D3D_INFO(2,"Detected Win95");
            return TRUE;
        }
    }
    else if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        D3D_INFO(2,"Detected WinNT");
        return FALSE;
    }
    D3D_INFO(2,"OS Detection failed");
    return TRUE;
}
#endif  // WIN95

//---------------------------------------------------------------------
//
//  void GetProcessorFamily(LPDWORD lpdwFamily);
//
//      Passes back 3, 4, 5, 6 for 386, 486, Pentium, PPro class machines
//
#pragma optimize("", off)
void
GetProcessorFamily(LPDWORD lpdwFamily, LPDWORD lpdwCPUFeatures)
{
    SYSTEM_INFO si;
    __int64     start, end, freq;
    int         flags,family;
    int         time;
    int         clocks;
    DWORD       oldclass;
    HANDLE      hprocess;

    // guilty until proven otherwise
    *lpdwCPUFeatures = D3DCPU_BLOCKINGREAD;

    if ( isMMXprocessor() )
    {
        *lpdwCPUFeatures |= D3DCPU_MMX;
    }

    ZeroMemory(&si, sizeof(si));
    GetSystemInfo(&si);

    //Set the family. If wProcessorLevel is not specified, dig it out of dwProcessorType
    //Because wProcessor level is not implemented on Win95
    if (si.wProcessorLevel)
    {
        *lpdwFamily=si.wProcessorLevel;
    }
    else
    {
        //Ok, we're on Win95
        switch (si.dwProcessorType)
        {
            case PROCESSOR_INTEL_386:
                *lpdwFamily=3;
                break;

            case PROCESSOR_INTEL_486:
                *lpdwFamily=4;
                break;
            default:
                *lpdwFamily=0;
                break;
        }
    }

    //
    // make sure this is a INTEL Pentium (or clone) or higher.
    //
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL)
        return;

    if (si.dwProcessorType < PROCESSOR_INTEL_PENTIUM)
        return;

    //
    // see if this chip supports rdtsc before using it.
    //
    __try
    {
        _asm
        {
            xor     eax,eax
            _emit   00fh    ;; CPUID
            _emit   0a2h
            mov     dword ptr szCPUString,ebx
            mov     dword ptr szCPUString+8,ecx
            mov     dword ptr szCPUString+4,edx
            mov     byte ptr szCPUString+12,0
            mov     eax,1
            _emit   00Fh     ;; CPUID
            _emit   0A2h
            mov     flags,edx
            mov     family,eax
        }
    }
    __except(1)
    {
        flags = 0;
    }

    //check for support of CPUID and fail
    if (!(flags & 0x10))
        return;

    // fcomi and FPU features both set
    if ( (flags&(1<<15)) && (flags & (1<<0)) )
    {
        D3D_INFO(2, "Pentium Pro CPU features (fcomi, cmov) detected");
        *lpdwCPUFeatures |= D3DCPU_FCOMICMOV;
    }

    //If we don't have a family, set it now
    //Family is bits 11:8 of eax from CPU, with eax=1
    if (!(*lpdwFamily))
    {
       *lpdwFamily=(family& 0x0F00) >> 8;
    }
    // not aware of any non-Intel processors w/non blocking reads
    if ( (! strcmp(szCPUString, "GenuineIntel")) &&
         *lpdwFamily > 5)
    {
        *lpdwCPUFeatures &= ~D3DCPU_BLOCKINGREAD;
    }

    if ( isX3Dprocessor() )
    {
        D3D_INFO(2, "X3D Processor detected for PSGP");
        *lpdwCPUFeatures |= D3DCPU_X3D;
    }

    if ( IsPentiumIIProcessor() )
    {
        D3D_INFO(2, "PentiumII Processor detected for PSGP");
        *lpdwCPUFeatures |= D3DCPU_PII;
    }

    if ( IsKatmaiProcessor() )
    {
        D3D_INFO(2, "Katmai Processor detected for PSGP");
        *lpdwCPUFeatures |= D3DCPU_KATMAI;
    }
    return;
}
#pragma optimize("", on)

#endif // _X86_

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwType, dwSize = sizeof(dwHWFewVertices);
    char filename[_MAX_PATH];

    switch( ul_reason_for_call ) {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls( hModule );
        DPFINIT();
        MemInit();
#ifdef WIN95
        GetpWin16Lock(&lpWin16Lock);
#endif

#ifdef _X86_
        GetProcessorFamily(&dwCPUFamily, &dwCPUFeatures);
        D3D_INFO(3, "dwCPUFamily = %d, dwCPUFeatures = %d", dwCPUFamily, dwCPUFeatures);
        D3D_INFO(3, "szCPUString = %s", szCPUString);
#endif

#ifdef WIN95 // and Win98...
    // Katmai NI does not work on Win95, so see if we are on Win95 and disable
    //
    {
        BOOL bIsWin95 = IsWin95();
        if ((dwCPUFeatures & D3DCPU_KATMAI) && bIsWin95)
        {
            D3D_INFO(1,"Disabling KNI support on Win95");
            dwCPUFeatures &= ~D3DCPU_KATMAI;
        }
    }
#endif

#ifdef _X86_
    if ( dwCPUFeatures & D3DCPU_X3D )
       pfnFEContextCreate = px3DContextCreate;
    else if ( dwCPUFeatures & D3DCPU_KATMAI )
       pfnFEContextCreate = katmai_FEContextCreate;
    else if ( dwCPUFeatures & D3DCPU_PII )
       pfnFEContextCreate = pii_FEContextCreate;
#endif

        // Unfounded default value. 128*40 (vertex+D3DTRIANGLE struct)=5K
        // The assumption is that the primary cache hasn't got much better
        // to do than contain the vertex and index data.
        dwD3DTriBatchSize = 80;
        // Work item: do something more intelligent here than assume that
        // MMX-enabled processors have twice as much primary cache.
        if ( isMMXprocessor() )
            dwD3DTriBatchSize *= 2;
        dwTriBatchSize = (dwD3DTriBatchSize * 4) / 3;
        dwLineBatchSize = dwD3DTriBatchSize * 2;
        dwHWBufferSize = dwD3DTriBatchSize * (sizeof(D3DTLVERTEX) + sizeof(D3DTRIANGLE));
        dwHWMaxTris = dwD3DTriBatchSize;
        lRet = RegOpenKey( HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey );
        if ( lRet == ERROR_SUCCESS )
        {
            lRet = RegQueryValueEx(hKey,
                                   "FewVertices",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwHWFewVertices,
                                   &dwSize);
            if (lRet != ERROR_SUCCESS ||
                dwType != REG_DWORD ||
                dwHWFewVertices < 4 ||
                dwHWFewVertices > 128)

                dwHWFewVertices = 24;

// disabling 'GeometryDriver' DLL interface until it is less abusable...
#if 0
            dwSize = sizeof(filename);
            lRet = RegQueryValueEx(hKey,
                                   "GeometryDriver",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) filename,
                                   &dwSize);
            if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
            {
                hGeometryDLL = LoadLibrary(filename);
                if (hGeometryDLL)
                {
                    pfnFEContextCreate = (LPD3DFE_CONTEXTCREATE) GetProcAddress(hGeometryDLL, "FEContextCreate");
                }
            }
#endif
            RegCloseKey( hKey );
        }
        else
        {
            dwHWFewVertices = 24;
        }
        // Set the app name to reg.
        SetMostRecentApp();
        break;
    case DLL_PROCESS_DETACH:
        MemFini();
        if (NULL != hGeometryDLL)
            FreeLibrary(hGeometryDLL);
        break;
    default:
        ;
    }
    return TRUE;
}

// --------------------------------------------------------------------------
// This function is called at process attach time to put the name of current
// app to registry.
// --------------------------------------------------------------------------
void SetMostRecentApp(void)
{
    char    fname[_MAX_PATH];
    char    name[_MAX_PATH];
    int     i;
    HKEY    hKey;
    HANDLE  hFile;

    // Find out what process we are dealing with
    hFile =  GetModuleHandle( NULL );
    GetModuleFileName( (HINSTANCE)hFile, fname, sizeof( fname ) );
    DPF( 3, "full name  = %s", fname );
    i = strlen( fname )-1;
    while( i >=0 && fname[i] != '\\' )
    {
        i--;
    }
    i++;
    strcpy( name, &fname[i] );
    DPF( 3, "name       = %s", name );

    // Now write the name into some known place
        if( !RegCreateKey( HKEY_LOCAL_MACHINE,
             RESPATH_D3D "\\" REGSTR_KEY_LASTAPP, &hKey ) )
    {
        RegSetValueEx(hKey, REGSTR_VAL_DDRAW_NAME, 0, REG_SZ, (LPBYTE)name, strlen(name)+1);
        RegCloseKey(hKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\dpoldhal.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpoldhal.c
 *  Content:    DrawPrimitive implementation for legacy (DX2) HALs
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "drawprim.hpp"
#include "clipfunc.h"
#include "commdrv.hpp"

extern D3DLINE LineListPrecomp[];
extern D3DLINE LineStripPrecomp[];
extern D3DTRIANGLE TriangleListPrecomp[];
extern D3DTRIANGLE TriangleStripPrecomp[];
extern D3DTRIANGLE TriangleFanPrecomp[];

#define BFCULLTEST_TVertTri(TLV0,TLV1,TLV2) (((TLV1).sx-(TLV0).sx)*((TLV2).sy-(TLV0).sy) -  \
                                         ((TLV2).sx-(TLV0).sx)*((TLV1).sy-(TLV0).sy))

#define ISCULLED(lpDevI, CullTestRes) ((CullTestRes==0.0) ||   \
                                   ((lpDevI->rstates[D3DRENDERSTATE_CULLMODE]==D3DCULL_CW) ^ (CullTestRes < 0.0)))
//---------------------------------------------------------------------
void WaitForFlip( LPDIRECT3DDEVICEI lpDevI )
{
    if (! (lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwDevCaps  & D3DDEVCAPS_CANRENDERAFTERFLIP) )
    {
        LPDDRAWI_DDRAWSURFACE_LCL lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSTarget)->lpLcl;

        if (lpLcl->ddsCaps.dwCaps & DDSCAPS_FLIP) {
            HRESULT ret;
            D3D_INFO(5, "Waiting for flip");
            do {
                ret = lpDevI->lpDDSTarget->GetFlipStatus(DDGFS_ISFLIPDONE);
            } while (ret == DDERR_WASSTILLDRAWING);
        }
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "FlushStatesHW"

HRESULT CDirect3DDeviceIHW::FlushStates()
{
    DWORD i;

    LPDWORD lpScan = (LPDWORD) this->lpHWVertices;
    LPD3DTRIANGLE lpTriScan = (LPD3DTRIANGLE) this->lpHWTris;

    DWORD dwRet;
    D3DHAL_RENDERSTATEDATA StateData;
    D3DHAL_RENDERPRIMITIVEDATA PrimitiveData;
    CDDSurfaceFromMem TLBuffer(NULL);
    CDDSurfaceFromMem ExeBuffer(lpTriScan);

    FlushTextureFromDevice( this ); // delink all texture surfaces
    if (this->dwHWOffset == 0)    return D3D_OK;
    this->dwHWOffset = 0; //zeroed to prevent re-enter by drivers's locking surfaces

    // Legacy HAL, therefore we have to wait
    // until the render target has flipped.
    WaitForFlip(this);

    // Pick up Win16 lock
    LOCK_HAL( dwRet, this );
    LOCK_DIBENGINE(dwRet, this);
#if _D3D_FORCEDOUBLE
    CD3DForceFPUDouble  ForceFPUDouble(this);
#endif  //_D3D_FORCEDOUBLE

    memset(&StateData, 0, sizeof(StateData) );
    memset(&PrimitiveData, 0, sizeof(PrimitiveData) );

    // dwHWNumCounts is the number of recorded structs with
    // primitives attached.
    for (i = 0; i < this->dwHWNumCounts+1; i += 1)
    {


        if ( this->lpHWCounts[i].wNumStateChanges )
        {
            TLBuffer.SetBits(lpScan);

            StateData.dwhContext = this->dwhContext;
            StateData.dwOffset = 0;
            StateData.dwCount = this->lpHWCounts[i].wNumStateChanges;
            StateData.lpExeBuf = TLBuffer.GetSurface();
            dwRet = (*this->lpD3DHALCallbacks->RenderState)(&StateData);
            // No provision for NOT_HANDLED

            lpScan += 2*this->lpHWCounts[i].wNumStateChanges;
            lpScan = (LPDWORD) ( (((ULONG_PTR) lpScan) + 31) & ~31);
        }

        if ( this->lpHWCounts[i].wNumVertices )
        {

            TLBuffer.SetBits(this->lpHWVertices);
            ExeBuffer.SetBits(lpTriScan);

            PrimitiveData.dwhContext = this->dwhContext;
            PrimitiveData.dwOffset = 0;
            PrimitiveData.dwStatus = 0;
            PrimitiveData.lpExeBuf = ExeBuffer.GetSurface();
            PrimitiveData.dwTLOffset = 0;
            PrimitiveData.lpTLBuf = TLBuffer.GetSurface();
            PrimitiveData.diInstruction.bOpcode = D3DOP_TRIANGLE;
            PrimitiveData.diInstruction.bSize = sizeof(D3DTRIANGLE);
            PrimitiveData.diInstruction.wCount = (WORD) this->lpHWCounts[i].wNumTriangles;
            dwRet = (*this->lpD3DHALCallbacks->RenderPrimitive)(&PrimitiveData);
            // No provision for NOT_HANDLED
            lpScan = (LPDWORD)(((LPD3DTLVERTEX) lpScan) + this->lpHWCounts[i].wNumVertices);
            lpTriScan += this->lpHWCounts[i].wNumTriangles;
        }
    }
    UNLOCK_DIBENGINE( this );
    UNLOCK_HAL( this );
    this->dwHWTriIndex = 0;
    this->dwHWNumCounts = 0;
    memset(this->lpHWCounts, 0, sizeof(D3DI_HWCOUNTS) );
        return  D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveLegacyHalCall"

HRESULT
DrawPrimitiveLegacyHalCall(CDirect3DDeviceIHW * lpDevI,
                           LPD3DTLVERTEX lpVertices, LPVOID lpvData,
                           LPD3DINSTRUCTION ins, DWORD dwNumVertices, D3DVERTEXTYPE VtxType)
{
    DWORD dwRet;
    CDDSurfaceFromMem TLBuffer(lpVertices);
    CDDSurfaceFromMem ExeBuffer(lpvData);
    D3DHAL_RENDERPRIMITIVEDATA rdata;

    memset(&rdata, 0, sizeof(rdata) );

    rdata.dwhContext = lpDevI->dwhContext;
    rdata.dwOffset = 0;
    rdata.dwStatus = 0;
    rdata.lpExeBuf = ExeBuffer.GetSurface();
    rdata.dwTLOffset = 0;
    rdata.lpTLBuf = TLBuffer.GetSurface();
    rdata.diInstruction = *ins;
#ifndef WIN95
    if((dwRet = CheckContextSurface(lpDevI)) != D3D_OK)
    {
        return (dwRet);
    }
#endif //WIN95
#if _D3D_FORCEDOUBLE
    CD3DForceFPUDouble  ForceFPUDouble(lpDevI);
#endif  //_D3D_FORCEDOUBLE
    CALL_HALONLY(dwRet, lpDevI, RenderPrimitive, &rdata);
    if (dwRet != DDHAL_DRIVER_HANDLED)
    {
        D3D_ERR ( "Driver not handled in DrawPrimitive" );
        // Need sensible return value in this case,
        // currently we return whatever the driver stuck in here.
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FillLegacyHalIndices"

void
FillLegacyHalIndices(D3DPRIMITIVETYPE PrimitiveType, LPVOID lpOut,
                     LPWORD lpwIndices, DWORD dwNumPrimitives)
{
    LPD3DLINE lpTmpLines;
    LPD3DTRIANGLE lpTmpTris;
    DWORD i;
    WORD wIndex = 0;

    switch (PrimitiveType)
    {
    case D3DPT_LINELIST:
        lpTmpLines = (LPD3DLINE) lpOut;
        for (i = 0; i < dwNumPrimitives; i += 1)
        {
            lpTmpLines[i].v1 = lpwIndices[wIndex++];
            lpTmpLines[i].v2 = lpwIndices[wIndex++];
        }
        break;
    case D3DPT_LINESTRIP:
        lpTmpLines = (LPD3DLINE) lpOut;
        for (i = 0; i < dwNumPrimitives; i += 1)
        {
            lpTmpLines[i].v1 = lpwIndices[wIndex++];
            lpTmpLines[i].v2 = lpwIndices[wIndex];
        }
        break;
    case D3DPT_TRIANGLELIST:
        lpTmpTris = (LPD3DTRIANGLE) lpOut;
        for (i = 0; i < dwNumPrimitives; i += 1)
        {
            lpTmpTris[i].v1 = lpwIndices[wIndex++];
            lpTmpTris[i].v2 = lpwIndices[wIndex++];
            lpTmpTris[i].v3 = lpwIndices[wIndex++];
            lpTmpTris[i].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
        }

        break;
    case D3DPT_TRIANGLESTRIP:
        lpTmpTris = (LPD3DTRIANGLE) lpOut;
        for (i = 0; i < dwNumPrimitives; i += 1)
        {
            lpTmpTris[i].v1 = lpwIndices[wIndex++];
            lpTmpTris[i].v2 = lpwIndices[wIndex++];
            lpTmpTris[i].v3 = lpwIndices[wIndex++];
            lpTmpTris[i].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
            i++;
            if (i<dwNumPrimitives)
            {
                lpTmpTris[i].v1 = lpTmpTris[i-1].v2;
                lpTmpTris[i].v2 = lpwIndices[wIndex--];
                lpTmpTris[i].v3 = lpTmpTris[i-1].v3;
                lpTmpTris[i].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        lpTmpTris = (LPD3DTRIANGLE) lpOut;
        lpTmpTris[0].v3 = lpwIndices[wIndex++];
        lpTmpTris[0].v1 = lpwIndices[wIndex++];
        lpTmpTris[0].v2 = lpwIndices[wIndex++];
        lpTmpTris[0].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
        for (i = 1; i < dwNumPrimitives; i += 1)
        {
            lpTmpTris[i].v1 = lpTmpTris[i-1].v2;
            lpTmpTris[i].v2 = lpwIndices[wIndex++];
            lpTmpTris[i].v3 = lpTmpTris[i-1].v3;
            lpTmpTris[i].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
        }
        break;
    }
}


#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveInBatchesHW"

HRESULT
DrawPrimitiveInBatchesHW(CDirect3DDeviceIHW * lpDevI, D3DPRIMITIVETYPE PrimitiveType, D3DVERTEXTYPE VertexType, LPD3DTLVERTEX lpVertices, DWORD dwNumPrimitives)
{
    DWORD i;
    D3DTLVERTEX tmpV;
    LPD3DTLVERTEX lpFirstVertex;
    D3DINSTRUCTION ins;
    HRESULT ret;

    switch (PrimitiveType)
    {
    case D3DPT_LINELIST:
        ins.bOpcode = D3DOP_LINE;
        ins.bSize = sizeof(D3DLINE);
        for (i = 0; i < dwNumPrimitives; i += dwLineBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwLineBatchSize);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, LineListPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += ins.wCount*2;
        }
        break;
    case D3DPT_LINESTRIP:
        ins.bOpcode = D3DOP_LINE;
        ins.bSize = sizeof(D3DLINE);
        for (i = 0; i < dwNumPrimitives; i += dwLineBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwLineBatchSize);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, LineStripPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += ins.wCount;
        }
        break;
    case D3DPT_TRIANGLELIST:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, TriangleListPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += 3*ins.wCount;
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, TriangleStripPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += ins.wCount;
        }
        break;
    case D3DPT_TRIANGLEFAN:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        // Save the first vertex to spoof the driver
        lpFirstVertex = lpVertices;
        tmpV = lpVertices[0];
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            tmpV = *lpVertices;
            *lpVertices = *lpFirstVertex;
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, TriangleFanPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            *lpVertices = tmpV;
            lpVertices += ins.wCount;
        }
        break;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrimitiveInBatchesHW"

HRESULT
DrawIndexedPrimitiveInBatchesHW(CDirect3DDeviceIHW * lpDevI,
                                D3DPRIMITIVETYPE PrimitiveType,
                                D3DVERTEXTYPE VertexType,
                                LPD3DTLVERTEX lpVertices,
                                DWORD dwNumPrimitives,
                                LPWORD lpwIndices)
{
    DWORD i;
    WORD tmpW;
    LPWORD lpFirstIndex;
    D3DINSTRUCTION ins;
    HRESULT ret;

    switch (PrimitiveType)
    {
    case D3DPT_LINELIST:
        ins.bOpcode = D3DOP_LINE;
        ins.bSize = sizeof(D3DLINE);
        for (i = 0; i < dwNumPrimitives; i += dwLineBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwLineBatchSize);
            FillLegacyHalIndices(PrimitiveType, lpDevI->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, lpDevI->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpwIndices += ins.wCount*2;
        }
        break;
    case D3DPT_LINESTRIP:
        ins.bOpcode = D3DOP_LINE;
        ins.bSize = sizeof(D3DLINE);
        for (i = 0; i < dwNumPrimitives; i += dwLineBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwLineBatchSize);
            FillLegacyHalIndices(PrimitiveType, lpDevI->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, lpDevI->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += ins.wCount;
        }
        break;
    case D3DPT_TRIANGLELIST:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            FillLegacyHalIndices(PrimitiveType, lpDevI->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, lpDevI->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpwIndices += 3*ins.wCount;
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            FillLegacyHalIndices(PrimitiveType, lpDevI->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, lpDevI->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpwIndices += ins.wCount;
        }
        break;
    case D3DPT_TRIANGLEFAN:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        // Save the first index to spoof the driver
        lpFirstIndex = lpwIndices;
        tmpW = lpwIndices[0];
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            tmpW = *lpwIndices;
            *lpwIndices = *lpFirstIndex;
            FillLegacyHalIndices(PrimitiveType, lpDevI->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, lpDevI->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            *lpwIndices = tmpW;
            lpwIndices += ins.wCount;
        }
        break;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// This is a call for a clipped primitive
//
HRESULT CDirect3DDeviceIHW::DrawIndexPrim()
{
    LPD3DTLVERTEX lpVertices = (LPD3DTLVERTEX)this->lpvOut;
    DWORD dwNumVertices = this->dwNumVertices;
    DWORD dwNumPrimitives = this->dwNumPrimitives;
    WORD *lpwIndices = this->lpwIndices;
    HRESULT ret;

    // Do we need to map new texture stage operations to DX5 renderstates?
    if(this->dwFEFlags & D3DFE_MAP_TSS_TO_RS) {
        MapTSSToRS();
        this->dwFEFlags &= ~D3DFE_MAP_TSS_TO_RS; // Reset request bit
    }
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        UpdateTextures();
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }

    // If the number of vertices is small, then just batch them.
    if ( (this->primType == D3DPT_TRIANGLELIST ||
          this->primType == D3DPT_TRIANGLEFAN ||
          this->primType == D3DPT_TRIANGLESTRIP) &&
          this->dwNumVertices < dwHWFewVertices)
    {
        LPD3DTRIANGLE lpTriOut;
        DWORD i,dwTriOutCount,iV0,iV1,iV2;
        WORD wVertexOffset;
        float fCullTestResult;
        BOOL bDoBFCulling;

        // Pad the offset, if needed.  But first save the offset to restore for
        // case in which no vertices are added to the buffer.  This is necessary
        // when renderstates are buffered before and after a non-visible primitive.
        DWORD dwHWOffsetSave = this->dwHWOffset;
        this->dwHWOffset = (this->dwHWOffset + 31) & ~31;

        if (this->dwHWOffset + dwNumVertices*sizeof(D3DTLVERTEX) >= dwHWBufferSize ||
            this->dwHWTriIndex + dwNumPrimitives >= dwHWMaxTris )
        {
            CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                                      // Release in the destructor
            ret = FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in DrawIndexPrim");
                return ret;
            }
            dwHWOffsetSave = this->dwHWOffset;
        }

        LPVOID lpvBatchAddress = (char*)this->lpHWVertices + this->dwHWOffset;
        if (this->dwVIDOut == D3DFVF_TLVERTEX)
            memcpy(lpvBatchAddress, lpVertices,
                   this->dwNumVertices*sizeof(D3DTLVERTEX));
        else
        {
            // We have to map FVF vertices to the D3DTLVERTEX.
            // This is only the case when lpvOut points to the user input
            // buffer.
            HRESULT ret;
            // Output will be in the batch buffer
            if ((ret = MapFVFtoTLVertex(this, lpvBatchAddress)) != D3D_OK)
                return ret;
            lpVertices = (D3DTLVERTEX*)lpvBatchAddress;
        }
        lpTriOut = this->lpHWTris + this->dwHWTriIndex;
        wVertexOffset = (WORD) (this->dwHWOffset/sizeof(D3DTLVERTEX));

        dwTriOutCount=0;  bDoBFCulling=(this->rstates[D3DRENDERSTATE_CULLMODE]!=D3DCULL_NONE);

        switch (this->primType)
        {
        case D3DPT_TRIANGLELIST:
            iV0=0;  iV1=1;  iV2=2;
            for (i = 0; i < dwNumPrimitives; i++,iV0+=3,iV1+=3,iV2+=3)
            {
                if(bDoBFCulling)
                {
                    fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpwIndices[iV0]],lpVertices[lpwIndices[iV1]],lpVertices[lpwIndices[iV2]]);
                    if(ISCULLED(this, fCullTestResult))
                        continue;
                }

                lpTriOut->v1 = lpwIndices[iV0] + wVertexOffset;
                lpTriOut->v2 = lpwIndices[iV1] + wVertexOffset;
                lpTriOut->v3 = lpwIndices[iV2] + wVertexOffset;
                lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
                lpTriOut += 1;
                dwTriOutCount++;
            }
            break;

        case D3DPT_TRIANGLEFAN:
            iV0=1;  iV1=2; iV2=0;
            for (i = 0; i < dwNumPrimitives; i++,iV0++,iV1++)
            {
                if(bDoBFCulling)
                {
                    fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpwIndices[iV0]],lpVertices[lpwIndices[iV1]],lpVertices[lpwIndices[iV2]]);
                    if(ISCULLED(this, fCullTestResult))
                        continue;
                }

                lpTriOut->v1 = lpwIndices[iV0] + wVertexOffset;
                lpTriOut->v2 = lpwIndices[iV1] + wVertexOffset;
                lpTriOut->v3 = lpwIndices[iV2] + wVertexOffset;
                lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
                lpTriOut += 1;
                dwTriOutCount++;
            }
            break;

        case D3DPT_TRIANGLESTRIP:
            iV0=0;  iV1=1;  iV2=2;
            for (i = 0; i < dwNumPrimitives; i++,iV0++,iV1++,iV2++)
            {
                if(bDoBFCulling)
                {
                    fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpwIndices[iV0]],lpVertices[lpwIndices[iV1]],lpVertices[lpwIndices[iV2]]);
                    if(ISCULLED(this, fCullTestResult))
                        goto SecondTri;
                }

                lpTriOut->v1 = lpwIndices[iV0] + wVertexOffset;
                lpTriOut->v2 = lpwIndices[iV1] + wVertexOffset;
                lpTriOut->v3 = lpwIndices[iV2] + wVertexOffset;
                lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
                lpTriOut += 1;
                dwTriOutCount++;

            SecondTri:

                i++;
                if(i < dwNumPrimitives)
                {
                    iV0++,iV1++,iV2++;

                    // swap vtx order for every 2nd tri

                    if(bDoBFCulling)
                    {
                        fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpwIndices[iV0]],lpVertices[lpwIndices[iV2]],lpVertices[lpwIndices[iV1]]);
                        if(ISCULLED(this, fCullTestResult))
                            continue;
                    }

                    lpTriOut->v1 = lpwIndices[iV0] + wVertexOffset;
                    lpTriOut->v2 = lpwIndices[iV2] + wVertexOffset;
                    lpTriOut->v3 = lpwIndices[iV1] + wVertexOffset;
                    lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
                    lpTriOut += 1;
                    dwTriOutCount++;
                }
            }
            break;
        }

        if(dwTriOutCount==0)
        {
            this->dwHWOffset = dwHWOffsetSave;    //  restore unpadded offset
            return D3D_OK;  // avoid adding unused verts to output
        }

        this->lpHWCounts[this->dwHWNumCounts].wNumTriangles += (WORD) dwTriOutCount;
        this->lpHWCounts[this->dwHWNumCounts].wNumVertices += (WORD) dwNumVertices;

        this->dwHWOffset += dwNumVertices * sizeof(D3DTLVERTEX);
        this->dwHWTriIndex += dwTriOutCount;

        return D3D_OK;
    }
    else
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                                  // Release in the destructor
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in DrawIndexPrim");
            return ret;
        }
        // We have to map FVF vertices to the D3DTLVERTEX.
        // This is only the case when lpvOut points to the user input buffer.
        if (this->dwVIDOut != D3DFVF_TLVERTEX)
        {
            HRESULT ret;
            // Output will be in the TL buffer
            if ((ret = MapFVFtoTLVertex(this, NULL)) != D3D_OK)
                return ret;
            lpVertices = (D3DTLVERTEX*)this->TLVbuf.GetAddress();
        }
        ret = DrawIndexedPrimitiveInBatchesHW(this, this->primType,
                                              D3DVT_TLVERTEX, lpVertices,
                                              dwNumPrimitives, this->lpwIndices);
        return ret;
    }
}
//---------------------------------------------------------------------
// This is a call for a clipped primitive
//
HRESULT CDirect3DDeviceIHW::DrawPrim()
{
    D3DPOINT TmpPoint;
    D3DINSTRUCTION ins = {D3DOP_POINT, sizeof(D3DPOINT), 1};
    LPD3DTLVERTEX lpVertices = (LPD3DTLVERTEX)this->lpvOut;

    // Do we need to map new texture stage operations to DX5 renderstates?
    if(this->dwFEFlags & D3DFE_MAP_TSS_TO_RS) {
        MapTSSToRS();
        this->dwFEFlags &= ~D3DFE_MAP_TSS_TO_RS; // Reset request bit
    }
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        UpdateTextures();
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }

    // If the number of vertices is small, and none require
    // clipping, then just batch them.
    if ((this->primType == D3DPT_TRIANGLELIST ||
         this->primType == D3DPT_TRIANGLEFAN ||
         this->primType == D3DPT_TRIANGLESTRIP) &&
         this->dwNumVertices < dwHWFewVertices)
    {
        LPD3DTRIANGLE lpTriOut, lpTriPrim;
        DWORD i, dwTriOutCount;
        WORD wVertexOffset;
        float fCullTestResult;
        BOOL bDoBFCulling;

        // Pad the offset, if needed.  But first save the offset to restore for
        // case in which no vertices are added to the buffer.  This is necessary
        // when renderstates are buffered before and after a non-visible primitive.
        DWORD dwHWOffsetSave = this->dwHWOffset;
        this->dwHWOffset = (this->dwHWOffset + 31) & ~31;

        if (this->dwHWOffset +
            this->dwNumVertices * sizeof(D3DTLVERTEX) >= dwHWBufferSize ||
            this->dwHWTriIndex + this->dwNumPrimitives >= dwHWMaxTris )
        {
            // Takes D3D lock (ST only).
            CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));
            HRESULT ret = FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in DrawPrim");
                return ret;
            }
            dwHWOffsetSave = this->dwHWOffset;
        }

        LPVOID lpvBatchAddress = (char*)this->lpHWVertices + this->dwHWOffset;
        if (this->dwVIDOut == D3DFVF_TLVERTEX)
            memcpy(lpvBatchAddress, lpVertices,
                   this->dwNumVertices*sizeof(D3DTLVERTEX));
        else
        {
            // We have to map FVF vertices to the D3DTLVERTEX.
            // This is only the case when lpvOut points to the user input
            // buffer.
            HRESULT ret;
            // Output will be in the batch buffer
            if ((ret = MapFVFtoTLVertex(this, lpvBatchAddress)) != D3D_OK)
                return ret;
            lpVertices = (LPD3DTLVERTEX)lpvBatchAddress;
        }
        switch (this->primType)
        {
        case D3DPT_TRIANGLELIST:
            lpTriPrim = TriangleListPrecomp;
            break;
        case D3DPT_TRIANGLEFAN:
            lpTriPrim = TriangleFanPrecomp;
            break;
        case D3DPT_TRIANGLESTRIP:
            lpTriPrim = TriangleStripPrecomp;
            break;
        }
        wVertexOffset = (WORD) (this->dwHWOffset/sizeof(D3DTLVERTEX));
        lpTriOut = this->lpHWTris + this->dwHWTriIndex;

        bDoBFCulling = (this->rstates[D3DRENDERSTATE_CULLMODE]!=D3DCULL_NONE);

        for (dwTriOutCount=0, i = 0; i < this->dwNumPrimitives; i++, lpTriPrim += 1)
        {
            if(bDoBFCulling)
            {
                fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpTriPrim->v1],lpVertices[lpTriPrim->v2],lpVertices[lpTriPrim->v3]);
                if(ISCULLED(this, fCullTestResult))
                    continue;
            }

            lpTriOut->v1 = lpTriPrim->v1 + wVertexOffset;
            lpTriOut->v2 = lpTriPrim->v2 + wVertexOffset;
            lpTriOut->v3 = lpTriPrim->v3 + wVertexOffset;
            lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
            lpTriOut += 1;
            dwTriOutCount++;
        }

        if(dwTriOutCount==0)
        {
            this->dwHWOffset = dwHWOffsetSave;    //  restore unpadded offset
            return D3D_OK;  // avoid adding unused verts to output
        }

        this->lpHWCounts[this->dwHWNumCounts].wNumTriangles += (WORD) dwTriOutCount;
        this->lpHWCounts[this->dwHWNumCounts].wNumVertices += (WORD)this->dwNumVertices;

        this->dwHWOffset += this->dwNumVertices * sizeof(D3DTLVERTEX);
        this->dwHWTriIndex += dwTriOutCount;

        return D3D_OK;
    }
    else
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                                  // Release in the destructor
        HRESULT ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in DrawPrim");
            return ret;
        }
        // We have to map FVF vertices to the D3DTLVERTEX.
        // This is only the case when lpvOut points to the user input buffer.
        if (this->dwVIDOut != D3DFVF_TLVERTEX)
        {
            HRESULT ret;
            // Output will be in the TL buffer
            if ((ret = MapFVFtoTLVertex(this, NULL)) != D3D_OK)
                return ret;
            lpVertices = (D3DTLVERTEX*)this->TLVbuf.GetAddress();
        }
        if (this->primType == D3DPT_POINTLIST)
        {
            TmpPoint.wFirst = 0;
            TmpPoint.wCount = (WORD)this->dwNumPrimitives;
            return DrawPrimitiveLegacyHalCall(this, lpVertices, &TmpPoint,
                                              &ins, 0, D3DVT_TLVERTEX);
        }
        else
            return DrawPrimitiveInBatchesHW(this, this->primType,
                                            D3DVT_TLVERTEX, lpVertices,
                                            this->dwNumPrimitives);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIHW::SetTextureStageState"

HRESULT D3DAPI
CDirect3DDeviceIHW::SetTextureStageState(DWORD dwStage,
                                         D3DTEXTURESTAGESTATETYPE dwState,
                                         DWORD dwValue)
{
    // Holds D3D lock until exit.
    CLockD3DMT ldmLock(this, DPF_MODNAME, REMIND(""));

#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES ||
        dwState == 0 || dwState >= D3DTSS_MAX)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }
#endif //DBG

    // Update runtime copy of state.
    DWORD dwOldValue = tsstates[dwStage][dwState];
    tsstates[dwStage][dwState] = dwValue;
    if (dwStage > 0 ) return  D3D_OK;   // Ignore higher stage states

    if (dwState == D3DTSS_TEXCOORDINDEX && TextureStageEnabled(this, dwStage) ||
        dwState == D3DTSS_COLOROP &&
        ((dwValue == D3DTOP_DISABLE) == !(dwOldValue == D3DTOP_DISABLE)))
    {
        this->dwFVFLastIn = 0;  // Force to recompute outputVID
        this->dwFEFlags |= D3DFE_TSSINDEX_DIRTY;
    }

    switch(dwState) {
    case D3DTSS_ADDRESS:
        if(this->rstates[D3DRENDERSTATE_TEXTUREADDRESS] != dwValue) {
            SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREADDRESS, dwValue);
            return SetRenderStateI(D3DRENDERSTATE_TEXTUREADDRESS, dwValue);
        }
        else {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState");
            return D3D_OK;
        }
        break;
    case D3DTSS_ADDRESSU:
        if(this->rstates[D3DRENDERSTATE_TEXTUREADDRESSU] != dwValue) {
            SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREADDRESSU, dwValue);
            return SetRenderStateI(D3DRENDERSTATE_TEXTUREADDRESSU, dwValue);
        }
        else {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState");
            return D3D_OK;
        }
        break;
    case D3DTSS_ADDRESSV:
        if(this->rstates[D3DRENDERSTATE_TEXTUREADDRESSV] != dwValue) {
            SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREADDRESSV, dwValue);
            return SetRenderStateI(D3DRENDERSTATE_TEXTUREADDRESSV, dwValue);
        }
        else {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState");
            return D3D_OK;
        }
        break;
    case D3DTSS_BORDERCOLOR:
        if(this->rstates[D3DRENDERSTATE_BORDERCOLOR] != dwValue) {
            SetDeviceRenderState(this, D3DRENDERSTATE_BORDERCOLOR, dwValue);
            return SetRenderStateI(D3DRENDERSTATE_BORDERCOLOR, dwValue);
        }
        else {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState");
            return D3D_OK;
        }
        break;
    case D3DTSS_MIPMAPLODBIAS:
        if(this->rstates[D3DRENDERSTATE_MIPMAPLODBIAS] != dwValue) {
            SetDeviceRenderState(this, D3DRENDERSTATE_MIPMAPLODBIAS, dwValue);
            return SetRenderStateI(D3DRENDERSTATE_MIPMAPLODBIAS, dwValue);
        }
        else {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState");
            return D3D_OK;
        }
        break;
    case D3DTSS_MAXANISOTROPY:
        if(this->rstates[D3DRENDERSTATE_ANISOTROPY] != dwValue) {
            SetDeviceRenderState(this, D3DRENDERSTATE_ANISOTROPY, dwValue);
            return SetRenderStateI(D3DRENDERSTATE_ANISOTROPY, dwValue);
        }
        else {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState");
            return D3D_OK;
        }
        break;
    }

    // Set a bit requesting mapping to DX5 renderstates
    this->dwFEFlags |= D3DFE_MAP_TSS_TO_RS;

    return D3D_OK; // return Ok for the time being?
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIHW::MapTSSToRS"

HRESULT CDirect3DDeviceIHW::MapTSSToRS()
{
    DWORD mag = this->tsstates[0][D3DTSS_MAGFILTER];
    DWORD min = this->tsstates[0][D3DTSS_MINFILTER];
    DWORD mip = this->tsstates[0][D3DTSS_MIPFILTER];

    if(mip == D3DTFP_NONE) {
        if(min != D3DTFN_POINT && min != D3DTFN_LINEAR) {
            min = D3DTFN_LINEAR;
            D3D_WARN(2,"Unable to map D3DTSS_MINFILTER mode to driver. Rendering maybe incorrect");
        }
        if(this->rstates[D3DRENDERSTATE_TEXTUREMIN] != min) {
            (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMIN, min);
            (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMIN, min);
        }
        else {
            D3D_WARN(4,"Ignoring redundant renderstate");
        }
    }
    else if(mip == D3DTFP_POINT) {
        if(min == D3DTFN_POINT) {
            if(this->rstates[D3DRENDERSTATE_TEXTUREMIN] != D3DFILTER_MIPNEAREST) {
                (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPNEAREST);
                (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPNEAREST);
            }
            else {
                D3D_WARN(4,"Ignoring redundant renderstate");
            }
        }
        else if(min == D3DTFN_LINEAR) {
            if(this->rstates[D3DRENDERSTATE_TEXTUREMIN] != D3DFILTER_MIPLINEAR) {
                (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPLINEAR);
                (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPLINEAR);
            }
            else {
                D3D_WARN(4,"Ignoring redundant renderstate");
            }
        }
        else {
            if(this->rstates[D3DRENDERSTATE_TEXTUREMIN] != D3DFILTER_MIPLINEAR) {
                (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPLINEAR);
                (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPLINEAR);
            }
            else {
                D3D_WARN(4,"Ignoring redundant renderstate");
            }
            D3D_WARN(2,"Unable to map D3DTSS_MINFILTER mode to driver. Rendering maybe incorrect");
        }
    }
    else { // mip == D3DTFP_LINEAR
        if(min == D3DTFN_POINT) {
            if(this->rstates[D3DRENDERSTATE_TEXTUREMIN] != D3DFILTER_LINEARMIPNEAREST) {
                (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPNEAREST);
                (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPNEAREST);
            }
            else {
                D3D_WARN(4,"Ignoring redundant renderstate");
            }
        }
        else if(min == D3DTFN_LINEAR) {
            if(this->rstates[D3DRENDERSTATE_TEXTUREMIN] != D3DFILTER_LINEARMIPLINEAR) {
                (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPLINEAR);
                (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPLINEAR);
            }
            else {
                D3D_WARN(4,"Ignoring redundant renderstate");
            }
        }
        else {
            if(this->rstates[D3DRENDERSTATE_TEXTUREMIN] != D3DFILTER_LINEARMIPLINEAR) {
                (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPLINEAR);
                (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPLINEAR);
            }
            else {
                D3D_WARN(4,"Ignoring redundant renderstate");
            }
            D3D_WARN(2,"Unable to map D3DTSS_MINFILTER mode to driver. Rendering maybe incorrect");
        }
    }
    if(mag != D3DTFG_POINT && mag != D3DTFG_LINEAR) {
        mag = D3DTFG_LINEAR;
        D3D_WARN(2,"Unable to map D3DTSS_MAGFILTER mode to driver. Rendering maybe incorrect");
    }
    if(this->rstates[D3DRENDERSTATE_TEXTUREMAG] != mag) {
        (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMAG, mag);
        (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMAG, mag);
    }
    else {
        D3D_WARN(4,"Ignoring redundant renderstate");
    }

    DWORD cop = this->tsstates[0][D3DTSS_COLOROP];
    DWORD ca1 = this->tsstates[0][D3DTSS_COLORARG1];
    DWORD ca2 = this->tsstates[0][D3DTSS_COLORARG2];
    DWORD aop = this->tsstates[0][D3DTSS_ALPHAOP];
    DWORD aa1 = this->tsstates[0][D3DTSS_ALPHAARG1];
    DWORD aa2 = this->tsstates[0][D3DTSS_ALPHAARG2];

    // Current is the same as diffuse in stage 0
    if(ca2 == D3DTA_CURRENT)
        ca2 = D3DTA_DIFFUSE;
    if(aa2 == D3DTA_CURRENT)
        aa2 = D3DTA_DIFFUSE;

    // Check if we need to disable texturing
    if(cop == D3DTOP_DISABLE ||
        (cop == D3DTOP_SELECTARG2 && ca2 == D3DTA_DIFFUSE && ((aop == D3DTOP_SELECTARG2 && aa2 == D3DTA_DIFFUSE) || aop == D3DTOP_DISABLE))
        ) {
        if(this->rstates[D3DRENDERSTATE_TEXTUREHANDLE] != 0) {
            (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREHANDLE, 0);
            (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREHANDLE, 0);
        }
        else {
            D3D_WARN(4,"Ignoring redundant renderstate");
        }
        this->dwFEFlags |= D3DFE_DISABLE_TEXTURES;
    }
    else if ((LPD3DI_TEXTUREBLOCK)TRUE != lpD3DMappedBlock[0])
    {
        LPD3DI_TEXTUREBLOCK lpBlock = this->lpD3DMappedBlock[0];
        if (lpBlock) {
            if(this->rstates[D3DRENDERSTATE_TEXTUREHANDLE] != lpBlock->hTex) {
                (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREHANDLE, lpBlock->hTex);
                (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREHANDLE, lpBlock->hTex);
            }
            else {
                D3D_WARN(4,"Ignoring redundant renderstate");
            }
        }
        this->dwFEFlags &= ~D3DFE_DISABLE_TEXTURES;
    }
    else
        this->dwFEFlags &= ~D3DFE_DISABLE_TEXTURES;

    // Check if we need to decal
    if((ca1 == D3DTA_TEXTURE && cop == D3DTOP_SELECTARG1) &&
        (aa1 == D3DTA_TEXTURE && aop == D3DTOP_SELECTARG1)) {
        if(this->rstates[D3DRENDERSTATE_TEXTUREMAPBLEND] != D3DTBLEND_DECAL) {
            (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_DECAL);
            (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_DECAL);
        }
        else {
            D3D_WARN(4,"Ignoring redundant renderstate");
        }
    }
    // Check if we need to modulate
    else if((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) && cop == D3DTOP_MODULATE &&
        ((aa1 == D3DTA_TEXTURE && aop == D3DTOP_SELECTARG1) || (aa2 == D3DTA_DIFFUSE && aop == D3DTOP_SELECTARG2))) {
        if(this->rstates[D3DRENDERSTATE_TEXTUREMAPBLEND] != D3DTBLEND_MODULATE) {
            (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_MODULATE);
            (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_MODULATE);
        }
        else {
            D3D_WARN(4,"Ignoring redundant renderstate");
        }
    }
    // Check if we need to decal alpha
    else if((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) && cop == D3DTOP_BLENDTEXTUREALPHA &&
        (aa2 == D3DTA_DIFFUSE && aop == D3DTOP_SELECTARG2)) {
        if(this->rstates[D3DRENDERSTATE_TEXTUREMAPBLEND] != D3DTBLEND_DECALALPHA) {
            (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_DECALALPHA);
            (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_DECALALPHA);
        }
        else {
            D3D_WARN(4,"Ignoring redundant renderstate");
        }
    }
    // Check if we need to modulate alpha
    else if((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) && cop == D3DTOP_MODULATE &&
        (aa2 == D3DTA_DIFFUSE && aa1 == D3DTA_TEXTURE) && aop == D3DTOP_MODULATE) {
        if(this->rstates[D3DRENDERSTATE_TEXTUREMAPBLEND] != D3DTBLEND_MODULATEALPHA) {
            (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_MODULATEALPHA);
            (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_MODULATEALPHA);
        }
        else {
            D3D_WARN(4,"Ignoring redundant renderstate");
        }
    }
    // Check if we need to add
    else if((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) && cop == D3DTOP_ADD &&
        (aa2 == D3DTA_DIFFUSE && aop == D3DTOP_SELECTARG2)) {
        if(this->rstates[D3DRENDERSTATE_TEXTUREMAPBLEND] != D3DTBLEND_ADD) {
            (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_ADD);
            (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_ADD);
        }
        else {
            D3D_WARN(4,"Ignoring redundant renderstate");
        }
    }
    else {
        if(!(this->dwFEFlags & D3DFE_DISABLE_TEXTURES))
        {
            D3D_WARN(2,"Mapping textureblend stage states to renderstates failed. Rendering maybe incorrect.");
        }
    }

    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIHW::ValidateDevice"

HRESULT D3DAPI
CDirect3DDeviceIHW::ValidateDevice(LPDWORD lpdwNumPasses)
{
    // Holds D3D lock until exit.
    CLockD3DMT ldmLock(this, DPF_MODNAME, REMIND(""));
    HRESULT ret;
    D3DHAL_VALIDATETEXTURESTAGESTATEDATA vbod;

    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_PTR(lpdwNumPasses, sizeof(DWORD)))
        {
            D3D_ERR( "Invalid lpdwNumPasses pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    {
        DWORD mag = this->tsstates[0][D3DTSS_MAGFILTER];
        DWORD min = this->tsstates[0][D3DTSS_MINFILTER];
        DWORD mip = this->tsstates[0][D3DTSS_MIPFILTER];
        DWORD texcap;
        if (this->dwFEFlags &  D3DFE_REALHAL)
        {
            texcap = this->d3dHWDevDesc.dpcTriCaps.dwTextureFilterCaps;
        }
        else
        {
            texcap = this->d3dHELDevDesc.dpcTriCaps.dwTextureFilterCaps;
        }

        ret = D3DERR_UNSUPPORTEDTEXTUREFILTER;
        if(mip == D3DTFP_NONE) {
            if(min == D3DTFG_POINT) {
                if(!(texcap & D3DPTFILTERCAPS_NEAREST))
                    goto err;
            }
            else if(min == D3DTFG_LINEAR) {
                if(!(texcap & D3DPTFILTERCAPS_LINEAR))
                    goto err;
            }
            else
            {
                goto err;
            }
        }
        else if(mip == D3DTFP_POINT) {
            if(min == D3DTFG_POINT) {
                if(!(texcap & D3DPTFILTERCAPS_MIPNEAREST))
                    goto err;
            }
            else if(min == D3DTFG_LINEAR) {
                if(!(texcap & D3DPTFILTERCAPS_MIPLINEAR))
                    goto err;
            }
            else
            {
                ret = D3DERR_CONFLICTINGTEXTUREFILTER;
                goto err;
            }
        }
        else if(mip == D3DTFP_LINEAR) {
            if(min == D3DTFG_POINT) {
                if(!(texcap & D3DPTFILTERCAPS_LINEARMIPNEAREST))
                    goto err;
            }
            else if(min == D3DTFG_LINEAR) {
                if(!(texcap & D3DPTFILTERCAPS_LINEARMIPLINEAR))
                    goto err;
            }
            else
            {
                ret = D3DERR_CONFLICTINGTEXTUREFILTER;
                goto err;
            }
        }
        if(mag == D3DTFG_POINT) {
            if(!(texcap & D3DPTFILTERCAPS_NEAREST))
                goto err;
        }
        else if(mag == D3DTFG_LINEAR) {
            if(!(texcap & D3DPTFILTERCAPS_LINEAR))
                goto err;
        }
        else
        {
            goto err;
        }
    }

    {
        DWORD cop = this->tsstates[0][D3DTSS_COLOROP];
        DWORD ca1 = this->tsstates[0][D3DTSS_COLORARG1];
        DWORD ca2 = this->tsstates[0][D3DTSS_COLORARG2];
        DWORD aop = this->tsstates[0][D3DTSS_ALPHAOP];
        DWORD aa1 = this->tsstates[0][D3DTSS_ALPHAARG1];
        DWORD aa2 = this->tsstates[0][D3DTSS_ALPHAARG2];
        DWORD texcap;
        if (this->dwFEFlags &  D3DFE_REALHAL)
        {
            texcap = this->d3dHWDevDesc.dpcTriCaps.dwTextureBlendCaps;
        }
        else
        {
            texcap = this->d3dHELDevDesc.dpcTriCaps.dwTextureBlendCaps;
        }

        // Current is the same as diffuse in stage 0
        if(ca2 == D3DTA_CURRENT)
            ca2 = D3DTA_DIFFUSE;
        if(aa2 == D3DTA_CURRENT)
            aa2 = D3DTA_DIFFUSE;

        switch (cop)
        {
        // Check decal
        case D3DTOP_SELECTARG1:
            if(!(texcap & D3DPTBLENDCAPS_DECAL))
            {
                ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                goto err;
            }
            if (ca1 != D3DTA_TEXTURE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (aa1 != D3DTA_TEXTURE)
            {
                ret = D3DERR_UNSUPPORTEDALPHAARG;
                goto err;
            }
            if (aop != D3DTOP_SELECTARG1)
            {
                ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                goto err;
            }
            break;
        case D3DTOP_MODULATE:
            switch (aop)
            {
            // Check modulate
            case D3DTOP_SELECTARG1:
                if(!(texcap & D3DPTBLENDCAPS_MODULATE))
                {
                    ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                    goto err;
                }
                if (ca1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (ca2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (aa1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
                break;
            // Check modulate (second case)
            case D3DTOP_SELECTARG2:
                if(!(texcap & D3DPTBLENDCAPS_MODULATE))
                {
                    ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                    goto err;
                }
                if (ca1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (ca2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (aa2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
                break;
            // Check modulate alpha
            case D3DTOP_MODULATE:
                if(!(texcap & D3DPTBLENDCAPS_MODULATEALPHA))
                {
                    ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                    goto err;
                }
                if (ca1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (ca2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (aa1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
                if (aa2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
                break;
            default:
                ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                goto err;
            }
            break;
        // Check decal alpha
        case D3DTOP_BLENDTEXTUREALPHA:
            if(!(texcap & D3DPTBLENDCAPS_DECALALPHA))
            {
                ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                goto err;
            }
            if (ca1 != D3DTA_TEXTURE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (ca2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (aa2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDALPHAARG;
                goto err;
            }
            if (aop != D3DTOP_SELECTARG2)
            {
                ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                goto err;
            }
            break;
        case D3DTOP_ADD:
            if(!(texcap & D3DPTBLENDCAPS_ADD))
            {
                ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                goto err;
            }
            if (ca1 != D3DTA_TEXTURE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (ca2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (aa2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDALPHAARG;
                goto err;
            }
            if (aop != D3DTOP_SELECTARG2)
            {
                ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                goto err;
            }
            break;
        // Check disable
        case D3DTOP_SELECTARG2:
            if (ca2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (aop != D3DTOP_DISABLE)
            {
                if (aop != D3DTOP_SELECTARG2)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                    goto err;
                }
                if (aa2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
            }
            break;
        // Check disable
        case D3DTOP_DISABLE:
            break;
        default:
            ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
            goto err;
        }
    }

    *lpdwNumPasses = 1;
    return D3D_OK;

err:
    D3D_INFO(1,"Failed to validate texture stage state.");
    *lpdwNumPasses = 0;
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\halmat.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   halmat.c
 *  Content:    Direct3D HAL material handler
 *@@BEGIN_MSINTERNAL
 *
 *  $Id: halmat.c,v 1.1 1995/11/21 15:12:40 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   07/11/95   stevela Initial rev.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

extern HRESULT SetMaterial(LPDIRECT3DDEVICEI lpDevI, D3DMATERIALHANDLE hMat);

HRESULT
D3DHAL_MaterialCreate(LPDIRECT3DDEVICEI lpDevI,
                      LPD3DMATERIALHANDLE lphMat,
                      LPD3DMATERIAL lpMat)
{
    LPD3DFE_MATERIAL lpNewMat;

    D3DMalloc((void**)&lpNewMat, sizeof(D3DFE_MATERIAL));
    if (!lpNewMat)
        return D3DERR_MATERIAL_CREATE_FAILED;
    lpNewMat->mat = *lpMat;
    LIST_INSERT_ROOT(&lpDevI->materials, lpNewMat, link);
    *lphMat = (DWORD)((ULONG_PTR)lpNewMat);

    //  continue for ramp only - need to munge ramp handles and call ramp
    //  service with material info
    return CallRampService(lpDevI, RAMP_SERVICE_CREATEMAT,
                   (ULONG_PTR) lpNewMat, 0);
}

HRESULT
D3DHAL_MaterialDestroy(LPDIRECT3DDEVICEI lpDevI, D3DMATERIALHANDLE hMat)
{
    HRESULT hr;

    if(hMat==0)
    {
        return D3DERR_MATERIAL_DESTROY_FAILED;
    }

    if (lpDevI->lighting.hMat == hMat)
        lpDevI->lighting.hMat = 0;

    hr = CallRampService(lpDevI, RAMP_SERVICE_DESTORYMAT, (DWORD) hMat, 0);

    LPD3DFE_MATERIAL lpMat = (LPD3DFE_MATERIAL)ULongToPtr(hMat);
    LIST_DELETE(lpMat, link);
    D3DFree(lpMat);
    return (hr);
}

HRESULT
D3DHAL_MaterialSetData(LPDIRECT3DDEVICEI lpDevI,
                       D3DMATERIALHANDLE hMat,
                       LPD3DMATERIAL lpMat)
{
    if(hMat==0)
        return D3DERR_MATERIAL_SETDATA_FAILED;

    LPD3DFE_MATERIAL mat = (LPD3DFE_MATERIAL)ULongToPtr(hMat);
    mat->mat = *lpMat;
    if (hMat == lpDevI->lighting.hMat)
        SetMaterial(lpDevI, hMat);

    //  continue for ramp only - need to munge ramp handles and call ramp
    //  service with material info
    if(lpDevI->pfnRampService != NULL)
        return CallRampService(lpDevI, RAMP_SERVICE_SETMATDATA,
                                    (ULONG_PTR) hMat, 0, TRUE);
    else
        return D3D_OK;
}

HRESULT
D3DHAL_MaterialGetData(LPDIRECT3DDEVICEI lpDevI,
                       D3DMATERIALHANDLE hMat,
                       LPD3DMATERIAL lpMat)
{

    if(hMat==0)
    {
        memset(lpMat,0,sizeof(D3DMATERIAL));
        return D3DERR_MATERIAL_GETDATA_FAILED;
    }

    LPD3DFE_MATERIAL mat = (LPD3DFE_MATERIAL)ULongToPtr(hMat);
    *lpMat = mat->mat;
    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\halexe.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       halexe.c
 *  Content:    Direct3D HAL execute calles
 *@@BEGIN_MSINTERNAL
 *
 *  $Id: halexe.c,v 1.1 1995/11/21 15:12:37 sjl Exp $
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   07/11/95   stevela Initial rev.
 *   12/11/95   stevela Lock surface before calling HAL's execute.
 *   29/08/96   stevela Just bit test instead of calling IsLost()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
#include "commdrv.hpp"
#include "genpick.hpp"
#include "d3dfei.h"
#include "clipfunc.h"

//---------------------------------------------------------------------
#define CHECK(ddrval, str)      \
    if (ddrval != DD_OK)        \
    {                           \
    D3D_ERR(str);           \
    return (ddrval);        \
    }
//---------------------------------------------------------------------
__inline BOOL DDSurfaceLost(LPDIRECTDRAWSURFACE s)
{
    return ((LPDDRAWI_DDRAWSURFACE_INT)s)->lpLcl->dwFlags & DDRAWISURF_INVALID;
}

#ifdef USE_INTERNAL_LOCK
__inline HRESULT DDLockSurface(LPDIRECTDRAWSURFACE s)
{
    LPDDRAWI_DDRAWSURFACE_INT lpInt;
    lpInt = (LPDDRAWI_DDRAWSURFACE_INT)s;
    return DDInternalLock(lpInt->lpLcl);
}

__inline HRESULT DDUnockSurface(LPDIRECTDRAWSURFACE s)
{
    LPDDRAWI_DDRAWSURFACE_INT lpInt;
    lpInt = (LPDDRAWI_DDRAWSURFACE_INT)s;
    return DDInternalUnlock(lpInt->lpLcl);
}
#endif

__inline BOOL DDCheckSurfaceCaps(LPDIRECTDRAWSURFACE s, DWORD flag)
{
    LPDDRAWI_DDRAWSURFACE_INT lpInt = (LPDDRAWI_DDRAWSURFACE_INT)s;
    return lpInt->lpLcl->ddsCaps.dwCaps & flag;
}
//---------------------------------------------------------------------
#define CHECKLOST(lpDevI)                                              \
{                                                                      \
    if (DDSurfaceLost(lpDevI->lpDDSTarget) ||                          \
        (lpDevI->lpDDSZBuffer && DDSurfaceLost(lpDevI->lpDDSZBuffer))) \
    {                                                                  \
        D3D_WARN(0, "Render-target or ZBuffer surface lost");              \
        lpDevI->dwFEFlags |= D3DFE_LOSTSURFACES;                       \
        return DDERR_SURFACELOST;                                      \
    }                                                                  \
}

#define NEXTINSTRUCTION(ptr, type, num) \
    ptr = (LPD3DINSTRUCTION)((LPBYTE)ptr + sizeof(D3DINSTRUCTION) + \
    (num * sizeof(type)))

//---------------------------------------------------------------------
#ifdef DBG

int
validateTriangleFlags(LPD3DINSTRUCTION  ins,
                      LPD3DTRIANGLE     tri)
{
    int count = ins->wCount;
    int v1,v2,v3;
    int flat;
    int flat_count;
    unsigned flags;

    D3D_INFO(5, "Start %d triangle instruction", count);

    flat = 0;
    flat_count = 0;

    for (; count; count--)
    {
        flags = tri->wFlags;
        flags &= 0x1f;

        switch (flags)
        {
        case D3DTRIFLAG_START:
            v1 = tri->v1;
            v2 = tri->v2;
            v3 = tri->v3;
            D3D_INFO(9, "  triangle %d is START", ins->wCount - count);
            break;

        case D3DTRIFLAG_ODD:
            v1 = v3;
            v2 = v2;
            v3 = tri->v3;
            if ((v1 != tri->v1) || (v2 != tri->v2))
            {
                D3D_WARN(1, "    triangle %d is not an odd triangle",
                    ins->wCount - count);
                return FALSE;
            }
            break;

        case D3DTRIFLAG_EVEN:
            v1 = v1;
            v2 = v3;
            v3 = tri->v3;
            if ((v1 != tri->v1) || (v2 != tri->v2))
            {
                D3D_WARN(1, "    triangle %d is not an even triangle",
                    ins->wCount - count);
                return FALSE;
            }
            break;

        default:
            /* (flags > 0) && (flags < 30) */
            v1 = tri->v1;
            v2 = tri->v2;
            v3 = tri->v3;
            D3D_INFO(9, "  triangle %d is START FLAT of %d", ins->wCount - count, flags);

            flat_count = flags;

            break;
        }

        tri = (D3DTRIANGLE*) ((char*) tri + ins->bSize);
    }
    return TRUE;
}
//---------------------------------------------------------------------
D3DVERTEXTYPE GetVertexType(LPDIRECT3DDEVICEI lpDevI)
{
    if (lpDevI->dwFEFlags & D3DFE_TLVERTEX)
       return D3DVT_TLVERTEX;
    else
    if (lpDevI->dwFlags & D3DPV_LIGHTING)
       return D3DVT_VERTEX;
    else
       return D3DVT_LVERTEX;

}
#endif // DBG
//---------------------------------------------------------------------
// Returns TRUE, if driver should be notified about the state
BOOL
trackState(LPDIRECT3DDEVICEI lpDevI, LPD3DSTATE state)
{
    DWORD type = (DWORD) state->drstRenderStateType;

    D3D_INFO(9, "trackState: state = %d", state->drstRenderStateType);
    if (IS_OVERRIDE(type))
    {
        DWORD override = GET_OVERRIDE(type);
        if (state->dwArg[0])
        {
            D3D_INFO(9, "trackState: setting override for state %d", override);
            STATESET_SET(lpDevI->renderstate_overrides, override);
        }
        else
        {
            D3D_INFO(9, "trackState: clearing override for state %d", override);
            STATESET_CLEAR(lpDevI->renderstate_overrides, override);
        }
        return TRUE;
    }

    if (STATESET_ISSET(lpDevI->renderstate_overrides, type))
    {
        D3D_INFO(9, "trackState: state %d is overridden, ignoring", type);
        return FALSE;
    }

    /* Save latest state for GetRenderState(). This will break if
    someone actually implements the Execute in DDI i.e. when
    D3DHAL_Execute{Un}Clipped calls us. */

    SetDeviceRenderState(lpDevI, state->drstRenderStateType, state->dwArg[0]);
    return TRUE;
}
//----------------------------------------------------------------------
// This function does not copy the data if pIn = pOut
//
void ConvertColorsToRamp(LPDIRECT3DDEVICEI lpDevI, D3DTLVERTEX *pIn,
                         D3DTLVERTEX *pOut, DWORD count)
{
    RAMP_RANGE_INFO RampInfo;
    BOOL theSameInAndOut = pIn == pOut;
    CallRampService(lpDevI, RAMP_SERVICE_FIND_LIGHTINGRANGE,
                    (ULONG_PTR)&RampInfo, 0);
    D3DVALUE colorScale = D3DVAL(max(min((INT32)RampInfo.size - 1, 0x7fff), 0));
    for (DWORD i=count; i; i--)
    {
        const D3DVALUE B_SCALE = 1.000f / 255.0f;

        // Convert diffuse color to shade value
        D3DVALUE color = RGBA_GETBLUE (pIn->color)*B_SCALE;
        if (RampInfo.specular)
        {
            // Convert specular color to shade value
            D3DVALUE specular = RGBA_GETBLUE (pIn->specular)*B_SCALE;

            color = 0.75f*color*(1.0f - specular) + specular;
        }
        DWORD outColor = (DWORD)(color * colorScale) + RampInfo.base;
        if (theSameInAndOut)
        {
            pIn->color = CI_MAKE(RGBA_GETALPHA(pIn->color), outColor, 0);
            pIn->specular = PtrToUlong(RampInfo.pTexRampMap);
        }
        else
        {
            pOut->color = CI_MAKE(RGBA_GETALPHA(pIn->color), outColor, 0);
            pOut->specular = PtrToUlong(RampInfo.pTexRampMap);
            pOut->sx  = pIn->sx;
            pOut->sy  = pIn->sy;
            pOut->sz  = pIn->sz;
            pOut->rhw = pIn->rhw;
            pOut->tu  = pIn->tu;
            pOut->tv  = pIn->tv;
            pOut++;
        }
        pIn++;
    }
}
//---------------------------------------------------------------------
void WaitForFlip(LPDIRECTDRAWSURFACE lpDDS)
{
    if (DDCheckSurfaceCaps(lpDDS, DDSCAPS_FLIP))
    {
        HRESULT ret;
        D3D_WARN(4, "Waiting for flip");
        do
        {
            ret = lpDDS->GetFlipStatus(DDGFS_ISFLIPDONE);
        } while (ret == DDERR_WASSTILLDRAWING);
    }
}
//---------------------------------------------------------------------
// DrawPrim for execute buffers using RenderPrimitive
// This function is called by the clipper
//
HRESULT CDirect3DDeviceIHW::DrawExeBuf()
{
    D3DHAL_RENDERPRIMITIVEDATA data;
    LPDIRECTDRAWSURFACE lpDDS = this->lpDDSTarget;
    HRESULT ret;
    WORD wFirstPointIndex;

    memset(&data, 0, sizeof data);
    data.dwhContext = this->dwhContext;
    data.dwStatus = this->iClipStatus;
    data.dwTLOffset = 0;
    if (this->dwFlags & D3DPV_CLIPPERPRIM)
    {
    // For clipped primitive vertices are generated in ClipperState.clipBuf
        data.lpTLBuf = this->ClipperState.clipBuf.GetDDS();
        data.lpExeBuf = this->ClipperState.clipBufPrim.GetDDS();
        data.dwOffset = 0;
        wFirstPointIndex = 0;
    }
    else
    {
        data.lpTLBuf = this->TLVbuf.GetDDS();
        if (this->primType == D3DPT_POINTLIST)
        {
            data.lpExeBuf = this->ClipperState.clipBufPrim.GetDDS();
            data.dwOffset = 0;
            wFirstPointIndex = (WORD)(((BYTE*)this->lpvOut -
                               (BYTE*)this->TLVbuf.GetAddress()) >> 5);
        }
        else
        {
            data.lpExeBuf = this->ClipperState.lpDDExeBuf;
            data.dwOffset = (DWORD)
                ((BYTE*)this->lpwIndices - (BYTE*)this->ClipperState.lpvExeBufMem);
        }
    }
    switch (this->primType)
    {
        case D3DPT_POINTLIST:
        {
            D3DPOINT *pPoint = (D3DPOINT*)this->ClipperState.clipBufPrim.GetAddress();
            // Size of TLVERTEX is 32
            pPoint->wFirst = wFirstPointIndex;
            pPoint->wCount = (WORD)this->dwNumVertices;
            data.diInstruction.bOpcode = D3DOP_POINT;
            data.diInstruction.bSize = sizeof(D3DPOINT);
            data.diInstruction.wCount = 1;
            break;
        }
        case D3DPT_LINELIST:
        {
            data.diInstruction.bOpcode = D3DOP_LINE;
            data.diInstruction.bSize = sizeof(D3DLINE);
            D3DLINE *pLine= (D3DLINE*)this->ClipperState.clipBufPrim.GetAddress();
            if (this->dwFlags & D3DPV_CLIPPERPRIM)
            {
                // Clipped line is not indexed
                pLine->v1 = 0;
                pLine->v2 = 1;
                data.diInstruction.wCount = 1;
            }
            else
                data.diInstruction.wCount = (WORD)(this->dwNumIndices >> 1);
            break;
        }
        case D3DPT_TRIANGLEFAN:
        case D3DPT_TRIANGLELIST:
        {
            data.diInstruction.bOpcode = D3DOP_TRIANGLE;
            data.diInstruction.bSize = sizeof(D3DTRIANGLE);
            D3DTRIANGLE *pTri = (D3DTRIANGLE*)
                                this->ClipperState.clipBufPrim.GetAddress();
            if (this->dwFlags & D3DPV_CLIPPERPRIM)
            {
                // Clipped triangle is non-indexed triangle fan
                // We have to convert it to indexed triangle list and compute
                // edge flags
                ClipVertex **clip = this->ClipperState.current_vbuf;
                pTri->wFlags = D3DTRIFLAG_STARTFLAT((WORD)this->dwNumPrimitives);
                if (clip[0]->clip & CLIPPED_ENABLE)
                    pTri->wFlags |= D3DTRIFLAG_EDGEENABLE1;
                DWORD i;
                for (i=1; i <= this->dwNumPrimitives; i++)
                {
                    pTri->v1 = 0;
                    pTri->v2 = (WORD)i;
                    pTri->v3 = (WORD)(i+1);
                    if (clip[i]->clip & CLIPPED_ENABLE)
                        pTri->wFlags |= D3DTRIFLAG_EDGEENABLE2;
                    pTri++;
                    pTri->wFlags = D3DTRIFLAG_EVEN; // All except first are EVEN
                }
                pTri--;
                // Edge 3 is enabled only for the last triangle in the fan
                // Not that "i" points to the last clip vertex
                if (clip[i]->clip & CLIPPED_ENABLE)
                    pTri->wFlags |= D3DTRIFLAG_EDGEENABLE3;
                data.diInstruction.wCount = (WORD)this->dwNumPrimitives;
            }
            else
                data.diInstruction.wCount = (WORD)this->dwNumPrimitives;
            break;
        }
    }

#ifndef WIN95
    if((ret = CheckContextSurfaceNOLOCK(this)) != D3D_OK)
        return (D3DERR_EXECUTE_FAILED);
#endif //WIN95

#if _D3D_FORCEDOUBLE
    CD3DForceFPUDouble  ForceFPUDouble(this);
#endif  //_D3D_FORCEDOUBLE
    CALL_HALONLY_NOLOCK(ret, this, RenderPrimitive, &data);

    if (ret != DDHAL_DRIVER_HANDLED)
    {
        D3D_ERR("HAL failed to handle RenderPrimitive call from Execute API");
        return (D3DERR_EXECUTE_FAILED);
    }
    this->iClipStatus = data.dwStatus;

    if (data.ddrval != DD_OK)
    {
        D3D_ERR("HAL error in RenderPrimitive call from Execute API");
        return (data.ddrval);
    }
    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT DIRECT3DDEVICEI::PickExeBuf()
{
    LPD3DTRIANGLE tri;
    DWORD i;
    LPD3DRECT pick_region = &this->pick_data.pick;
    D3DVALUE result;
    LPD3DTLVERTEX lpTLV;
    HRESULT ret;

    if (this->dwFlags & D3DPV_CLIPPERPRIM)
    {
        // For clipped primitive vertices are generated in ClipperState.clipBuf
        lpTLV = (D3DTLVERTEX*)this->ClipperState.clipBuf.GetAddress();
        D3DTRIANGLE tri;
        tri.v1 = 0;
        for (i=1; i <= this->dwNumPrimitives; i++)
        {
            tri.v2 = (WORD)i;
            tri.v3 = (WORD)(i+1);
            tri.wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
            if (GenPickTriangle(this, lpTLV, &tri, pick_region, &result))
            {
                if ((ret = GenAddPickRecord(this,
                                            D3DOP_TRIANGLE,
                                            this->dwClipIns_offset,
                                            result)) != D3D_OK)
                    return ret;
            }
        }
    }
    else
    {
        lpTLV = (D3DTLVERTEX*)this->TLVbuf.GetAddress();
        tri = (LPD3DTRIANGLE)this->lpwIndices;
        for (i = this->dwNumPrimitives; i; i--, tri++)
        {
            if (GenPickTriangle(this, lpTLV, tri, pick_region, &result))
            {
                if ((ret = GenAddPickRecord(this,
                                           D3DOP_TRIANGLE,
                                           (DWORD)((BYTE*)tri - (BYTE*)this->lpbClipIns_base),
                                           result)) != D3D_OK)
                    return ret;
            }
        }
    }
    return D3D_OK;
}
/*************************************************************************/
/*                              Points                                   */
/*************************************************************************/
HRESULT D3DFEClipPointsHW(LPDIRECT3DDEVICEI lpDevI, D3DPOINT *point, DWORD dwCount)
{
    DWORD icount = dwCount;
    HRESULT ret;

    lpDevI->primType = D3DPT_LINELIST;
    lpDevI->lpwIndices = 0; // Points are not indexed

    for (; icount; icount--)
    {
        lpDevI->dwNumVertices = point->wCount;
        lpDevI->lpvOut = &((D3DTLVERTEX*)lpDevI->TLVbuf.GetAddress())[point->wFirst];
        WORD *lpClipFlagsOld = lpDevI->lpClipFlags;
        lpDevI->lpClipFlags = &lpDevI->lpClipFlags[point->wFirst];
        ret = ProcessClippedPoints(lpDevI);
        if (ret != D3D_OK)
        {
            D3D_ERR("ProcessClippedPoints failed!");
            return ret;
        }
        lpDevI->lpClipFlags = lpClipFlagsOld;
        point++;
    }
    return D3D_OK;
}
/*************************************************************************/
/*                              Lines                                    */
/*************************************************************************/
inline HRESULT D3DFEClipLinesHW(LPDIRECT3DDEVICEI lpDevI, D3DLINE *line,  DWORD dwCount)
{
    HRESULT ret;
    lpDevI->primType = D3DPT_LINELIST;
    lpDevI->dwNumIndices = dwCount << 1;
    lpDevI->dwNumPrimitives = dwCount;
    lpDevI->lpvOut = lpDevI->TLVbuf.GetAddress();
    lpDevI->lpwIndices = (WORD*)line;

    ret = ProcessClippedIndexedLine(lpDevI);

    return ret;
}
/*************************************************************************/
/*                           Triangles                                   */
/*************************************************************************/
inline HRESULT D3DFEClipTrianglesHW(LPDIRECT3DDEVICEI lpDevI, D3DTRIANGLE *tri,  DWORD dwCount)
{
    HRESULT ret;
    lpDevI->primType = D3DPT_TRIANGLELIST;
    lpDevI->dwNumPrimitives = dwCount;
    lpDevI->lpvOut = lpDevI->TLVbuf.GetAddress();
    lpDevI->dwNumIndices = dwCount * 3;
    lpDevI->lpwIndices = (WORD*)tri;

    ret = ProcessClippedIndexedTriangleList(lpDevI);

    return ret;
}
/*************************************************************************/
/*                           Pick triangles                              */
/*************************************************************************/
inline HRESULT GenPickTriangles(LPDIRECT3DDEVICEI lpDevI, D3DTRIANGLE *tri, DWORD dwCount)
{
    HRESULT ret;
    lpDevI->primType = D3DPT_TRIANGLELIST;
    lpDevI->dwNumIndices = dwCount * 3;
    lpDevI->dwNumPrimitives = dwCount;
    lpDevI->lpvOut = lpDevI->TLVbuf.GetAddress();
    lpDevI->lpwIndices = (WORD*)tri;

    ret = ProcessClippedIndexedTriangleList(lpDevI);

    return ret;
}/*----------------------------------------------------------------------------
 *
 * Instruction emulation.
 */
HRESULT D3DHELInst_D3DOP_MATRIXLOAD(LPDIRECT3DDEVICEI lpDevI,
                                    DWORD dwCount,
                                    LPD3DMATRIXLOAD lpMatLoad)
{
    LPD3DMATRIXI lpSrcMat;
    LPD3DMATRIXI lpDestMat;
    DWORD i;
    HRESULT ret;
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;

    for (i = 0; i < dwCount; i++)
    {
        D3DMATRIXHANDLE  hSrc = lpMatLoad[i].hSrcMatrix;
        D3DMATRIXHANDLE  hDst = lpMatLoad[i].hDestMatrix;
        lpSrcMat  = HANDLE_TO_MAT(lpDevI, hSrc);
        lpDestMat = HANDLE_TO_MAT(lpDevI, hDst);
        if (lpSrcMat == NULL || lpDestMat == NULL)
            return (DDERR_INVALIDPARAMS);

        memcpy (lpDestMat, lpSrcMat, offsetof(D3DMATRIXI, link));

        if (hDst == TRANSFORM.hWorld)
            ret = D3DFE_SetMatrixWorld(lpDevI, (D3DMATRIX*)lpSrcMat);
        else
            if (hDst == TRANSFORM.hView)
                ret = D3DFE_SetMatrixView(lpDevI, (D3DMATRIX*)lpSrcMat);
            else
                if (hDst == TRANSFORM.hProj)
                    ret = D3DFE_SetMatrixProj(lpDevI, (D3DMATRIX*)lpSrcMat);

        if (ret != D3D_OK)
            return (DDERR_GENERIC);
    }

    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT D3DHELInst_D3DOP_MATRIXMULTIPLY(LPDIRECT3DDEVICEI lpDevI,
                                        DWORD dwCount,
                                        LPD3DMATRIXMULTIPLY lpMmult)
{
    LPD3DMATRIXI lpMat1, lpMat2;
    LPD3DMATRIXI result;
    DWORD i;
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;

    for (i = 0; i < dwCount; i++)
    {
        D3DMATRIXHANDLE  hSrc1 = lpMmult[i].hSrcMatrix1;
        D3DMATRIXHANDLE  hSrc2 = lpMmult[i].hSrcMatrix2;
        D3DMATRIXHANDLE  hDst  = lpMmult[i].hDestMatrix;
        lpMat1 = HANDLE_TO_MAT(lpDevI, hSrc1);
        lpMat2 = HANDLE_TO_MAT(lpDevI, hSrc2);
        result = HANDLE_TO_MAT(lpDevI, hDst);
        if (!lpMat1 || !lpMat2)
        {
            return (DDERR_GENERIC);
        }
        MatrixProduct(result, lpMat1, lpMat2);
        if (hDst == TRANSFORM.hWorld)
        {
            D3DFE_SetMatrixWorld(lpDevI, (D3DMATRIX*)result);
        }
        else
            if (hDst == TRANSFORM.hView)
            {
                D3DFE_SetMatrixView(lpDevI, (D3DMATRIX*)result);
            }
            else
                if (hDst == TRANSFORM.hProj)
                {
                    D3DFE_SetMatrixProj(lpDevI, (D3DMATRIX*)result);
                }
    }

    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT D3DHELInst_D3DOP_STATETRANSFORM(LPDIRECT3DDEVICEI lpDevI,
                                        DWORD count,
                                        LPD3DSTATE lpMset)
{
    DWORD i;
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;

    for (i = 0; i < count; i++)
    {
        DWORD type = (DWORD) lpMset[i].dtstTransformStateType;

        D3D_INFO(9, "HEL D3DOP_STATETRANSFORM: state = %d", type);
        if (IS_OVERRIDE(type))
        {
            DWORD override = GET_OVERRIDE(type);
            if (lpMset[i].dwArg[0])
            {
                D3D_WARN(5, "HEL D3DOP_STATETRANSFORM: setting override for state %d", override);
                STATESET_SET(lpDevI->transformstate_overrides, override);
            } else
            {
                D3D_WARN(5, "HEL D3DOP_STATETRANSFORM: clearing override for state %d", override);
                STATESET_CLEAR(lpDevI->transformstate_overrides, override);
            }
            continue;
        }

        if (STATESET_ISSET(lpDevI->transformstate_overrides, type))
        {
            D3D_WARN(5, "HEL D3DOP_STATETRANSFORM: state %d is overridden, ignoring", type);
            continue;
        }

        D3DMATRIXHANDLE hSrc = lpMset[i].dwArg[0];
        D3DMATRIX *lpSrcMat = (D3DMATRIX*)HANDLE_TO_MAT(lpDevI, hSrc);
        if (lpSrcMat == NULL)
        {
            // In DX5 days, this error was not propagated back.
            if (lpDevI->dwVersion <= 2)
                return D3D_OK;
            else
            {
                D3D_ERR("NULL srcMat in D3DHELInst_D3DOP_STATETRANSFORM");
                return (DDERR_INVALIDPARAMS);
            }
        }

        switch (type)
        {
        case D3DTRANSFORMSTATE_WORLD:
            D3DFE_SetMatrixWorld(lpDevI, lpSrcMat);
            TRANSFORM.hWorld = hSrc;
            break;
        case D3DTRANSFORMSTATE_VIEW:
            D3DFE_SetMatrixView(lpDevI, lpSrcMat);
            TRANSFORM.hView = hSrc;
            break;
        case D3DTRANSFORMSTATE_PROJECTION:
            D3DFE_SetMatrixProj(lpDevI, lpSrcMat);
            TRANSFORM.hProj = hSrc;
            break;
        default:
            D3D_ERR("Bad State in D3DopStateTransform emulation.");
            return DDERR_GENERIC;
        }
    }
    return (D3D_OK);
}
//---------------------------------------------------------------------
#if DBG
HRESULT validateProcessVertices(LPDIRECT3DDEVICEI lpDevI,
                                LPD3DPROCESSVERTICES data)
{
    LPD3DHAL_GLOBALDRIVERDATA lpGlob = lpDevI->lpD3DHALGlobalDriverData;
    unsigned int vnum;

    vnum = (unsigned int)(lpGlob->dwNumVertices ? lpGlob->dwNumVertices :
                                                  D3DHAL_DEFAULT_TL_NUM);

    if (data->wDest >= vnum) {
        D3D_ERR("Dest index to large for Execute Buffer.");
        return DDERR_INVALIDPARAMS;
    } else if ((data->wDest + data->dwCount) > vnum) {
        D3D_ERR("Process vertices exceeds Execute Buffer size.");
        return DDERR_INVALIDPARAMS;
    }

    return D3D_OK;
}
#endif
//---------------------------------------------------------------------
HRESULT D3DHELInst_D3DOP_TRANSFORM(LPDIRECT3DDEVICEI lpDevI,
                                   DWORD count,
                                   LPD3DPROCESSVERTICES data,
                                   LPD3DEXECUTEBUFFERDESC eb)
{
    LPD3DTLVERTEX lpTlv;
    DWORD i;
    DWORD op;
    HRESULT ret = DD_OK;

    lpDevI->primType = D3DPT_TRIANGLELIST;
    lpDevI->dwOutputSize = sizeof(D3DVERTEX);
    lpDevI->position.dwStride =  sizeof(D3DVERTEX);
    lpDevI->nTexCoord = 1;

    for (i = 0; i < count; i++)
    {

#if DBG
        if ((ret = validateProcessVertices(lpDevI, data)))
            return ret;
#endif

        int nVertices = data->wDest+data->dwCount;

        lpTlv = (LPD3DTLVERTEX)lpDevI->TLVbuf.GetAddress();
        lpDevI->dwNumVertices = data->dwCount;
        lpDevI->position.lpvData = ((char*)eb->lpData) +
                                   data->wStart * sizeof(D3DVERTEX);
        lpDevI->lpvOut = lpTlv + data->wDest;
        /*
        * Transform the vertices
        */

        op = data->dwFlags & D3DPROCESSVERTICES_OPMASK;
        if (op == D3DPROCESSVERTICES_COPY)
        {
            lpDevI->dwVIDIn = d3dVertexToFVF[D3DVT_TLVERTEX];
            memcpy(lpDevI->lpvOut, lpDevI->position.lpvData,
                data->dwCount * sizeof(D3DVERTEX));
            D3DFE_updateExtents(lpDevI);
            D3D_INFO(4, "TLVERTEX encountered. Will not clip.");
            lpDevI->dwFEFlags |= D3DFE_TLVERTEX;
            // Apply ramp post-lighting stuff only for D3DTLVERTEX.
            // For other vertex types this is done in the transformation loop
            //
            if (lpDevI->pfnRampService != NULL)
            {
                ConvertColorsToRamp(lpDevI, (D3DTLVERTEX*)lpDevI->lpvOut,
                                    (D3DTLVERTEX*)lpDevI->lpvOut, data->dwCount);
            }
            lpDevI->iClipStatus &= ~D3DSTATUS_CLIPINTERSECTIONALL;
        }
        else
        {
            if (op == D3DPROCESSVERTICES_TRANSFORMLIGHT)
            {
                lpDevI->dwVIDIn = d3dVertexToFVF[D3DVT_VERTEX];
                lpDevI->dwFlags |= D3DPV_LIGHTING;
            }
            else
            {
                lpDevI->dwVIDIn = d3dVertexToFVF[D3DVT_LVERTEX];
            }

            if (lpDevI->dwFlags & D3DDP_DONOTCLIP)
            {
                D3DFE_ProcessVertices(lpDevI);
                lpDevI->iClipStatus &= ~D3DSTATUS_CLIPINTERSECTIONALL;
            }
            else
            {
                lpDevI->lpClipFlags = (D3DFE_CLIPCODE*)lpDevI->HVbuf.GetAddress() +
                                       data->wDest;

                D3DFE_ProcessVertices(lpDevI);
                D3DFE_UpdateClipStatus(lpDevI);

                D3D_INFO(4, "Status Change -> Clip flags. status = %08x", lpDevI->iClipStatus);
                // Restore initial value for lpClipFlags
                lpDevI->lpClipFlags = (D3DFE_CLIPCODE*)lpDevI->HVbuf.GetAddress();
            }
        }

        /* update stats
        */
        lpDevI->D3DStats.dwVerticesProcessed += data->dwCount;
        data++;
    }
    //out_of_here:
    return (ret);
}
//--------------------------------------------------------------------
inline HRESULT GrowTLandHbuffers(LPDIRECT3DDEVICEI lpDevI, DWORD dwUsedVertexCount)
{
    HRESULT ddrval;
    if (dwUsedVertexCount > 4096)
        dwUsedVertexCount = 4096;
    else
        if (dwUsedVertexCount < lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwMaxVertexCount)
            dwUsedVertexCount = lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwMaxVertexCount;

    ddrval = lpDevI->TLVbuf.CheckAndGrow(lpDevI, dwUsedVertexCount << 5);
    if (ddrval != D3D_OK)
    {
        D3D_ERR("Failed to check and grow TLVbuf in Execute");
        return ddrval;
    }
    ddrval = lpDevI->HVbuf.CheckAndGrow(dwUsedVertexCount*sizeof(D3DFE_CLIPCODE));
    if (ddrval != D3D_OK)
    {
        D3D_ERR("Failed to check and grow HVbuf in Execute");
        return ddrval;
    }
    return D3D_OK;
}
//--------------------------------------------------------------------
//
#define WAIT_FOR_FLIP()                 \
    if (!waitedForFlip)                 \
    {                                   \
        WaitForFlip(lpDDS);             \
        waitedForFlip = TRUE;           \
    }

HRESULT
CDirect3DDeviceIHW::ExecuteI(LPD3DI_EXECUTEDATA lpExData, DWORD mode)
{
    BOOL waitedForFlip = FALSE;
    D3DINSTRUCTION* lpIns;
    D3DHAL_RENDERSTATEDATA stateData;
    D3DHAL_RENDERPRIMITIVEDATA primitiveData;
    D3DEXECUTEBUFFERDESC debDesc;
    LPDIRECTDRAWSURFACE lpDDS = this->lpDDSTarget;
    LPBYTE prim;
    D3DFE_TRANSFORM *transform = &this->transform;
    LPDIRECTDRAWSURFACE lpDDExeBuf;
    HRESULT ddrval;

    CHECKLOST(this);

    // Do we need to map new texture stage operations to DX5 renderstates?
    if(this->dwFEFlags & D3DFE_MAP_TSS_TO_RS) {
        MapTSSToRS();
        this->dwFEFlags &= ~D3DFE_MAP_TSS_TO_RS; // Reset request bit
    }
    /* Update textures */
    UpdateTextures();

    if (mode == D3DEXECUTE_UNCLIPPED)
        this->dwFlags |= D3DDP_DONOTCLIP;
    else if (mode != D3DEXECUTE_CLIPPED)
        return DDERR_INVALIDPARAMS;
    /*
    * If the driver can process triangles while the hardware has a
    * pending page-flip such as the 3Dfx voodoo chipset, then we
    * don't need to call WaitForFlip.  We pretend that it has already
    * been called to keep the code simple.
    */
    if (this->lpD3DHALGlobalDriverData->hwCaps.dwDevCaps &
        D3DDEVCAPS_CANRENDERAFTERFLIP)
    {
        waitedForFlip = TRUE;
    }

    /*
    * Lock the HAL for the duration.
    */
    LOCK_HAL(ddrval, this);
    if (ddrval != DD_OK)
    {
        D3D_ERR("Failed to lock HAL in Execute");
        return (ddrval);
    }
#if _D3D_FORCEDOUBLE
    CD3DForceFPUDouble  ForceFPUDouble(this);
#endif  //_D3D_FORCEDOUBLE

    /*
    * Execute the buffer through the HAL
    */
    {
        LPD3DHAL_EXDATA hexData = (LPD3DHAL_EXDATA) lpExData->dwHandle;

        debDesc.lpData = SURFACE_MEMORY(hexData->lpDDS);
        lpDDExeBuf = hexData->lpDDS;
    }

    memset(&stateData, 0, sizeof(D3DHAL_RENDERSTATEDATA));
    stateData.dwhContext = this->dwhContext;
    stateData.lpExeBuf = lpDDExeBuf;

    memset(&primitiveData, 0, sizeof(D3DHAL_RENDERPRIMITIVEDATA));
    primitiveData.dwhContext = this->dwhContext;
    primitiveData.lpExeBuf = lpDDExeBuf;
    primitiveData.dwTLOffset = 0L;

    this->ClipperState.lpDDExeBuf = lpDDExeBuf;
    this->ClipperState.lpvExeBufMem = debDesc.lpData;

    // Modify driver funcs for EB case
    PFN_DRAWPRIM pfnOldDrawPrim = this->pfnDrawPrim;
    PFN_DRAWPRIM pfnOldDrawIndexedPrim = this->pfnDrawIndexedPrim;
    this->pfnDrawPrim = &DIRECT3DDEVICEI::DrawExeBuf;
    this->pfnDrawIndexedPrim = &DIRECT3DDEVICEI::DrawExeBuf;

    /*
     * The first instruction.
     */
    lpIns = (LPD3DINSTRUCTION)((LPBYTE)debDesc.lpData +
                   lpExData->dwInstructionOffset);

    ddrval = GrowTLandHbuffers(this, lpExData->dwVertexCount);
    if (ddrval != D3D_OK)
        goto execute_failed;

    // do this after CheckAndGrow, because TL buffer could be re-created
    primitiveData.lpTLBuf = this->TLVbuf.GetDDS();

    while (lpIns->bOpcode != D3DOP_EXIT)
    {
        prim = (LPBYTE)lpIns + sizeof(D3DINSTRUCTION);
        D3D_INFO(5, "HAL parsing instruction %d", lpIns->bOpcode);

        /*
        * Parse the instruction.
        */
        switch (lpIns->bOpcode)
        {
        case D3DOP_MATRIXLOAD:
            {
                D3D_INFO(5, "Emulating D3DOP_MATRIXLOAD for HAL");
                ddrval = D3DHELInst_D3DOP_MATRIXLOAD(this,
                    lpIns->wCount,
                    (LPD3DMATRIXLOAD)prim);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_MATRIXLOAD failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DMATRIXLOAD, lpIns->wCount);
                break;
            }

        case D3DOP_MATRIXMULTIPLY:
            {
                D3D_INFO(5, "Emulating D3DOP_MATRIXMULTIPLY for HAL");
                ddrval = D3DHELInst_D3DOP_MATRIXMULTIPLY(this,
                    lpIns->wCount,
                    (LPD3DMATRIXMULTIPLY)prim);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_MATRIXMULTIPLY failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DMATRIXMULTIPLY, lpIns->wCount);
                break;
            }

        case D3DOP_PROCESSVERTICES:
            {
                D3D_INFO(5, "Emulating D3DOP_PROCESSVERTICES for HAL");

                ddrval = D3DHELInst_D3DOP_TRANSFORM
                    (this, lpIns->wCount, (LPD3DPROCESSVERTICES)prim,
                     &debDesc);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_PROCESSVERTICES failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DPROCESSVERTICES, lpIns->wCount);
                break;
            }

        case D3DOP_STATETRANSFORM:
            {
                D3D_INFO(5, "Emulating D3DOP_STATETRANSFORM for HAL");
                ddrval = D3DHELInst_D3DOP_STATETRANSFORM(this,
                    lpIns->wCount,
                    (LPD3DSTATE)prim);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_STATETRANSFORM failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
                break;
            }

        case D3DOP_STATELIGHT:
            {
                D3D_INFO(5, "Emulating D3DOP_STATELIGHT for HAL");
                ddrval = D3DHELInst_D3DOP_STATELIGHT(this,
                    lpIns->wCount,
                    (LPD3DSTATE)prim);
                if (ddrval != D3D_OK) {
                    D3D_ERR("Emulated D3DOP_STATELIGHT failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
                break;
            }

        case D3DOP_BRANCHFORWARD:
            {
                D3DBRANCH* branch = (D3DBRANCH*)prim;
                LPBYTE target;
                BOOL isTaken = FALSE;

                D3D_INFO(5, "Emulating D3DOP_BRANCHFORWARD");
                if (branch->bNegate)
                {
                    if ((branch->dwMask & this->iClipStatus) != branch->dwValue)
                    {
                        D3D_INFO(4, "Taking forward branch");
                        if (branch->dwOffset)
                        {
                            isTaken = TRUE;
                            target = (LPBYTE)lpIns + branch->dwOffset;
                        }
                        else
                        {
                            D3D_INFO(4, "branch says to exit.");
                            goto execute_done;
                        }
                    }
                }
                else
                {
                    if ((branch->dwMask & this->iClipStatus) == branch->dwValue)
                    {
                        D3D_INFO(4, "Taking forward branch");
                        if (branch->dwOffset)
                        {
                            isTaken = TRUE;
                            target = (LPBYTE)lpIns + branch->dwOffset;
                        } else
                        {
                            D3D_INFO(2, "branch says to exit.");
                            goto execute_done;
                        }
                    }
                }
                if (isTaken)
                {
                    D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: branch taken");
                    lpIns = (LPD3DINSTRUCTION) target;
                }
                else
                {
                    D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: branch not taken");
                    NEXTINSTRUCTION(lpIns, D3DBRANCH, lpIns->wCount);
                }
                break;
            }

        case D3DOP_TEXTURELOAD:
            {
                D3D_INFO(5, "Emulating D3DOP_TEXTURELOAD for HAL");
                ddrval = D3DHELInst_D3DOP_TEXTURELOAD(this,
                    lpIns->wCount,
                    (LPD3DTEXTURELOAD)prim);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_TEXTURELOAD failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DTEXTURELOAD, lpIns->wCount);
                break;
            }

        case D3DOP_STATERENDER:
            {
                LPD3DSTATE lpState;
                DWORD i,j,statek,valuek;

                lpState = (LPD3DSTATE) (lpIns + 1);
                for (i = 0,j=0,statek=(DWORD)-1; i < lpIns->wCount; i++)
                {
                    trackState(this, &lpState[i]);
                }
                stateData.dwOffset = (DWORD)(prim - (LPBYTE) debDesc.lpData);
                stateData.dwCount =  lpIns->wCount;
                CALL_HALONLY_NOLOCK(ddrval, this, RenderState, &stateData);
                if (stateData.ddrval != DD_OK)
                {
                    D3D_ERR("HAL error in RenderState call from Execute API");
                    ddrval = stateData.ddrval;
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
                break;
            }

        case D3DOP_SETSTATUS:
            {
                LPD3DSTATUS status = (LPD3DSTATUS)prim;
                if (status->dwFlags & D3DSETSTATUS_STATUS)
                    this->iClipStatus = status->dwStatus;
                if (status->dwFlags & D3DSETSTATUS_EXTENTS)
                {
                    this->rExtents.x1 = D3DVAL(status->drExtent.x1);
                    this->rExtents.y1 = D3DVAL(status->drExtent.y1);
                    this->rExtents.x2 = D3DVAL(status->drExtent.x2);
                    this->rExtents.y2 = D3DVAL(status->drExtent.y2);
                }
                NEXTINSTRUCTION(lpIns, D3DSTATUS, lpIns->wCount);
                break;
            }

        default:
            if (mode == D3DEXECUTE_UNCLIPPED || this->dwFEFlags & D3DFE_TLVERTEX)
            {
                switch (lpIns->bOpcode)
                {
                case D3DOP_POINT:
                case D3DOP_LINE:
                case D3DOP_SPAN:
                case D3DOP_TRIANGLE:
                    {
                        if (lpIns->wCount == 0)
                            goto noprim;
#if DBG
                        switch (lpIns->bOpcode)
                        {
                        case D3DOP_POINT:
                            Profile(PROF_EXECUTE, D3DPT_POINTLIST, GetVertexType(this));
                            break;
                        case D3DOP_LINE:
                            Profile(PROF_EXECUTE, D3DPT_LINELIST, GetVertexType(this));
                            break;
                        case D3DOP_TRIANGLE:
                            Profile(PROF_EXECUTE, D3DPT_TRIANGLELIST, GetVertexType(this));
                            break;
                        }
#endif // DBG
                        if (!waitedForFlip)
                        {
                            WaitForFlip(lpDDS);
                            waitedForFlip = TRUE;
                        }

                        primitiveData.dwOffset = (DWORD)(prim - (LPBYTE) debDesc.lpData);
                        primitiveData.dwStatus = this->iClipStatus;
                        primitiveData.diInstruction = *lpIns;

#ifndef WIN95
                        if((ddrval = CheckContextSurfaceNOLOCK (this)) != D3D_OK)
                        {
                            goto execute_failed;
                        }
#endif //WIN95
                        CALL_HALONLY_NOLOCK(ddrval, this, RenderPrimitive,
                                &primitiveData);
                        if (primitiveData.ddrval != DD_OK)
                        {
                            D3D_ERR("HAL error in RenderPrimitive call from Execute API");
                            ddrval = primitiveData.ddrval;
                            goto execute_failed;
                        }
                        switch (lpIns->bOpcode)
                        {
                            int i;
                        case D3DOP_LINE:
                            this->D3DStats.dwLinesDrawn += lpIns->wCount;
                            break;
                        case D3DOP_TRIANGLE:
#if DBG
                            if (!validateTriangleFlags(lpIns, (LPD3DTRIANGLE) prim))
                            {
                                ddrval = DDERR_INVALIDPARAMS;
                                goto execute_failed;
                            }
#endif
                            this->D3DStats.dwTrianglesDrawn += lpIns->wCount;
                            break;
                        case D3DOP_POINT:
                            {
                                LPD3DPOINT point = (LPD3DPOINT)prim;
                                for (i = 0; i < lpIns->wCount; i++)
                                {
                                    this->D3DStats.dwPointsDrawn += point->wCount;
                                    point++;
                                }
                            }
                            break;
                        case D3DOP_SPAN:
                            {
                                LPD3DSPAN span = (LPD3DSPAN)prim;
                                for (i = 0; i < lpIns->wCount; i++)
                                {
                                    this->D3DStats.dwSpansDrawn += span->wCount;
                                    span++;
                                }
                            }
                            break;
                        }

                        this->iClipStatus = primitiveData.dwStatus;
                    noprim:
                        lpIns = (LPD3DINSTRUCTION)((LPBYTE)lpIns +
                            sizeof(D3DINSTRUCTION) +
                            (lpIns->bSize * lpIns->wCount));
                        break;
                    }
                default:
                    D3D_ERR("HAL detected invalid instruction opcode in Execute");
                    goto execute_failed;
                }
            }
            else
            {
                switch (lpIns->bOpcode)
                {
                case D3DOP_TRIANGLE:
                    if (lpIns->wCount == 0)
                    {
                        NEXTINSTRUCTION(lpIns, D3DTRIANGLE, lpIns->wCount);
                        break;
                    }
                    Profile(PROF_EXECUTE, D3DPT_TRIANGLELIST, GetVertexType(this));
                    WAIT_FOR_FLIP();
#if DBG
                    if (!validateTriangleFlags(lpIns, (LPD3DTRIANGLE) prim))
                    {
                        ddrval = DDERR_INVALIDPARAMS;
                        goto execute_failed;
                    }
#endif
                    this->D3DStats.dwTrianglesDrawn += lpIns->wCount;
                    D3D_INFO(5, "Emulating D3DOP_TRIANGLE for HAL and clipping");
                    ddrval = D3DFEClipTrianglesHW(this, (LPD3DTRIANGLE)prim, lpIns->wCount);
                    if (ddrval != D3D_OK)
                    {
                        D3D_ERR("D3DFEClipTrianglesHW failed");
                        goto execute_failed;
                    }
                    NEXTINSTRUCTION(lpIns, D3DTRIANGLE, lpIns->wCount);
                    break;

                case D3DOP_LINE:

                    if (lpIns->wCount == 0)
                    {
                        NEXTINSTRUCTION(lpIns, D3DLINE, lpIns->wCount);
                        break;
                    }
                    Profile(PROF_EXECUTE, D3DPT_LINELIST, GetVertexType(this));
                    WAIT_FOR_FLIP();

                    D3D_INFO(5, "Emulating D3DOP_LINE for HAL and clipping");
                    this->D3DStats.dwLinesDrawn += lpIns->wCount;

                    ddrval = D3DFEClipLinesHW(this, (LPD3DLINE)prim, lpIns->wCount);
                    if (ddrval != D3D_OK)
                    {
                        D3D_ERR("D3DFEClipLinesHW failed");
                        goto execute_failed;
                    }
                    NEXTINSTRUCTION(lpIns, D3DLINE, lpIns->wCount);
                    break;

                case D3DOP_POINT:
                    WAIT_FOR_FLIP();

                    Profile(PROF_EXECUTE, D3DPT_POINTLIST, GetVertexType(this));
                    D3D_INFO(5, "Emulating D3DOP_POINT for HAL and clipping");
                    {
                        LPD3DPOINT point = (LPD3DPOINT) prim;
                        int i;
                        for (i = 0; i < lpIns->wCount; i++)
                        {
                            this->D3DStats.dwPointsDrawn += point->wCount;
                            point++;
                        }
                    }
                    if ((ddrval = D3DFEClipPointsHW(this, (LPD3DPOINT)prim, lpIns->wCount)) != D3D_OK)
                    {
                        D3D_ERR("Failed D3DFEClipPointsHW");
                        goto execute_failed;
                    }
                    NEXTINSTRUCTION(lpIns, D3DPOINT, lpIns->wCount);
                    break;

                case D3DOP_SPAN:
                    {
                        LPD3DSPAN span = (LPD3DSPAN)prim;
                        D3DHAL_RENDERPRIMITIVEDATA primitiveData;
                        int i;

                        WAIT_FOR_FLIP();

                        memset(&primitiveData, 0, sizeof(D3DHAL_RENDERPRIMITIVEDATA));
                        primitiveData.dwhContext = this->dwhContext;
                        primitiveData.lpExeBuf = lpDDExeBuf;
                        primitiveData.dwTLOffset = 0L;
                        primitiveData.lpTLBuf = this->TLVbuf.GetDDS();
                        primitiveData.dwOffset = (DWORD)(prim - (LPBYTE) debDesc.lpData);
                        primitiveData.dwStatus = this->iClipStatus;
                        primitiveData.diInstruction = *lpIns;

#ifndef WIN95
                        if((ddrval = CheckContextSurfaceNOLOCK(this)) != D3D_OK)
                            goto execute_failed;
#endif //WIN95
                        CALL_HALONLY_NOLOCK(ddrval, this, RenderPrimitive,
                            &primitiveData);

                        if (primitiveData.ddrval != DD_OK)
                        {
                            D3D_ERR("HAL error in RenderPrimitive call from Execute API");
                            ddrval = primitiveData.ddrval;
                            goto execute_failed;
                        }
                        for (i = 0; i < lpIns->wCount; i++)
                        {
                            this->D3DStats.dwSpansDrawn += span->wCount;
                            span++;
                        }
                        this->iClipStatus = primitiveData.dwStatus;
                        lpIns = (LPD3DINSTRUCTION)((LPBYTE)lpIns
                            + sizeof(D3DINSTRUCTION)
                            + (lpIns->bSize * lpIns->wCount));
                        break;
                    }
                default:
                    D3D_ERR("HAL detected invalid instruction opcode in Execute");
                    goto execute_failed;
            }
            ClampExtents(this);
        }
    }
    }

execute_done:
    ddrval = D3D_OK;
    D3DFE_ConvertExtent(this, &this->rExtents, &lpExData->dsStatus.drExtent);
    lpExData->dsStatus.dwStatus = this->iClipStatus;
execute_failed:
    UNLOCK_HAL(this);
    // Restore driver funcs
    this->pfnDrawIndexedPrim = pfnOldDrawIndexedPrim;
    this->pfnDrawPrim = pfnOldDrawPrim;
    return ddrval;
}
//-------------------------------------------------------------------------------------------------
void TrackAllStates(LPDIRECT3DDEVICEI lpDevI, LPD3DINSTRUCTION lpIns, LPD3DINSTRUCTION lpEnd)
{
    while (lpIns->bOpcode != D3DOP_EXIT && (lpEnd == NULL || lpIns < lpEnd))
    {
        LPBYTE prim = (LPBYTE)lpIns + sizeof(D3DINSTRUCTION);
        switch (lpIns->bOpcode)
        {
        case D3DOP_MATRIXLOAD:
            {
                NEXTINSTRUCTION(lpIns, D3DMATRIXLOAD, lpIns->wCount);
                break;
            }

        case D3DOP_MATRIXMULTIPLY:
            {
                NEXTINSTRUCTION(lpIns, D3DMATRIXMULTIPLY, lpIns->wCount);
                break;
            }

        case D3DOP_PROCESSVERTICES:
            {
                NEXTINSTRUCTION(lpIns, D3DPROCESSVERTICES, lpIns->wCount);
                break;
            }

        case D3DOP_STATETRANSFORM:
            {
                NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
                break;
            }

        case D3DOP_STATELIGHT:
            {
                NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
                break;
            }

        case D3DOP_BRANCHFORWARD:
            {
                D3DBRANCH* branch = (D3DBRANCH*)prim;
                LPBYTE target;
                BOOL isTaken = FALSE;

                if (branch->bNegate)
                {
                    if ((branch->dwMask & lpDevI->iClipStatus) != branch->dwValue)
                    {
                        if (branch->dwOffset)
                        {
                            isTaken = TRUE;
                            target = (LPBYTE)lpIns + branch->dwOffset;
                        }
                        else
                        {
                            D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: branch says to exit.");
                            break;
                        }
                    }
                }
                else
                {
                    if ((branch->dwMask & lpDevI->iClipStatus) == branch->dwValue)
                    {
                        if (branch->dwOffset)
                        {
                            isTaken = TRUE;
                            target = (LPBYTE)lpIns + branch->dwOffset;
                        } else
                        {
                            break;
                        }
                    }
                }
                if (isTaken)
                {
                    lpIns = (LPD3DINSTRUCTION) target;
                }
                else
                {
                    NEXTINSTRUCTION(lpIns, D3DBRANCH, lpIns->wCount);
                }
                break;
            }

        case D3DOP_TEXTURELOAD:
            {
                NEXTINSTRUCTION(lpIns, D3DTEXTURELOAD, lpIns->wCount);
                break;
            }

        case D3DOP_SETSTATUS:
            {
                NEXTINSTRUCTION(lpIns, D3DSTATUS, lpIns->wCount);
                break;
            }
        case D3DOP_STATERENDER:
            {
                LPD3DSTATE lpState;
                DWORD i,j,statek,valuek;
                lpState = (LPD3DSTATE) (lpIns + 1);
                for (i = 0,j=0,statek=(DWORD)-1; i < lpIns->wCount; i++)
                {
                    trackState(lpDevI, &lpState[i]);
                }
                NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
            }
            break;
        case D3DOP_TRIANGLE:
            NEXTINSTRUCTION(lpIns, D3DTRIANGLE, lpIns->wCount);
            break;

        case D3DOP_LINE:
            NEXTINSTRUCTION(lpIns, D3DLINE, lpIns->wCount);
            break;

        case D3DOP_POINT:
            NEXTINSTRUCTION(lpIns, D3DPOINT, lpIns->wCount);
            break;

        case D3DOP_SPAN:
            // This case is NOOP since we do not implement spans in DP2 DDI
            {
                lpIns = (LPD3DINSTRUCTION)((LPBYTE)lpIns
                    + sizeof(D3DINSTRUCTION)
                    + (lpIns->bSize * lpIns->wCount));
                break;
            }
        default:
            D3D_ERR("Invalid instruction opcode in TrackAllStates");
            break;
        } // switch
    } // while
}
//-------------------------------------------------------------------------------------------------
// New execute for DP2 HAL
//
HRESULT
CDirect3DDeviceIDP2::ExecuteI(LPD3DI_EXECUTEDATA lpExData, DWORD mode)
{
    BOOL waitedForFlip = FALSE;
    D3DINSTRUCTION* lpIns;
    D3DEXECUTEBUFFERDESC debDesc;
    LPDIRECTDRAWSURFACE lpDDS = this->lpDDSTarget;
    LPBYTE prim;
    D3DFE_TRANSFORM *transform = &this->transform;
    LPDIRECTDRAWSURFACE lpDDExeBuf;
    HRESULT ddrval, dp2dataddrval;

    CHECKLOST(this);

    /* Update textures */
    UpdateTextures();

    if (mode == D3DEXECUTE_UNCLIPPED)
        this->dwFlags |= D3DDP_DONOTCLIP;
    else if (mode != D3DEXECUTE_CLIPPED)
        return DDERR_INVALIDPARAMS;
    /*
     * If the driver can process triangles while the hardware has a
     * pending page-flip such as the 3Dfx voodoo chipset, then we
     * don't need to call WaitForFlip.  We pretend that it has already
     * been called to keep the code simple.
     */
    if (this->lpD3DHALGlobalDriverData->hwCaps.dwDevCaps &
        D3DDEVCAPS_CANRENDERAFTERFLIP)
    {
        waitedForFlip = TRUE;
    }

    /*
     * Lock the HAL for the duration.
     */
    LOCK_HAL(ddrval, this);
    if (ddrval != DD_OK)
    {
        D3D_ERR("Failed to lock HAL in Execute");
        return (ddrval);
    }

    /*
     * Execute the buffer through the HAL
     */
    LPD3DHAL_EXDATA hexData = (LPD3DHAL_EXDATA) lpExData->dwHandle;

    debDesc.lpData = SURFACE_MEMORY(hexData->lpDDS);
    lpDDExeBuf = hexData->lpDDS;

    /*
     * The first instruction.
     */
    lpIns = (LPD3DINSTRUCTION)((LPBYTE)debDesc.lpData +
        lpExData->dwInstructionOffset);
    // Fill up common part of dp2Data
    this->dp2data.dwVertexType = D3DFVF_TLVERTEX;
    this->dp2data.dwVertexSize = sizeof(D3DTLVERTEX);
    this->dp2data.dwVertexOffset = 0;

    ddrval = GrowTLandHbuffers(this, lpExData->dwVertexCount);
    if (ddrval != D3D_OK)
        goto execute_failed;

    this->dwOutputSize = sizeof(D3DTLVERTEX);
    // Start new primitive batch
    ddrval= StartPrimVB(this->TLVbuf.GetVBI(), 0);
    if (ddrval != D3D_OK)
    {
        UNLOCK_HAL(this);
        D3D_ERR("Failed to start new primitve batch in Execute");
        return ddrval;
    }
    // Since many legacy apps do not bother to set the dwVertexLength correctly, we estimate
    // the vertex length here to be thse size of buffer allocated. This atleast guarantees
    // that the memory is valid. It may still contain garbage data which the driver needs
    // to protect itself from
    this->dp2data.dwVertexLength = this->TLVbuf.GetSize() >> 5; // divide by sizeof(D3DTLVERTEX)

    this->ClipperState.lpDDExeBuf = lpDDExeBuf;
    this->ClipperState.lpvExeBufMem = debDesc.lpData;

    while (lpIns->bOpcode != D3DOP_EXIT)
    {
        prim = (LPBYTE)lpIns + sizeof(D3DINSTRUCTION);
        D3D_INFO(5, "HAL parsing instruction %d", lpIns->bOpcode);

        /*
        * Parse the instruction.
        */
        switch (lpIns->bOpcode)
        {
        case D3DOP_MATRIXLOAD:
            {
                D3D_INFO(5, "Emulating D3DOP_MATRIXLOAD for HAL");
                ddrval = D3DHELInst_D3DOP_MATRIXLOAD(this,
                    lpIns->wCount,
                    (LPD3DMATRIXLOAD)prim);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_MATRIXLOAD failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DMATRIXLOAD, lpIns->wCount);
                break;
            }

        case D3DOP_MATRIXMULTIPLY:
            {
                D3D_INFO(5, "Emulating D3DOP_MATRIXMULTIPLY for HAL");
                ddrval = D3DHELInst_D3DOP_MATRIXMULTIPLY(this,
                    lpIns->wCount,
                    (LPD3DMATRIXMULTIPLY)prim);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_MATRIXMULTIPLY failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DMATRIXMULTIPLY, lpIns->wCount);
                break;
            }

        case D3DOP_PROCESSVERTICES:
            {
                D3D_INFO(5, "Emulating D3DOP_PROCESSVERTICES for HAL");

                ddrval = D3DHELInst_D3DOP_TRANSFORM
                    (this, lpIns->wCount, (LPD3DPROCESSVERTICES)prim,
                     &debDesc);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_PROCESSVERTICES failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DPROCESSVERTICES, lpIns->wCount);
                break;
            }

        case D3DOP_STATETRANSFORM:
            {
                D3D_INFO(5, "Emulating D3DOP_STATETRANSFORM for HAL");
                ddrval = D3DHELInst_D3DOP_STATETRANSFORM(this,
                    lpIns->wCount,
                    (LPD3DSTATE)prim);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_STATETRANSFORM failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
                break;
            }

        case D3DOP_STATELIGHT:
            {
                D3D_INFO(5, "Emulating D3DOP_STATELIGHT for HAL");
                ddrval = D3DHELInst_D3DOP_STATELIGHT(this,
                    lpIns->wCount,
                    (LPD3DSTATE)prim);
                if (ddrval != D3D_OK) {
                    D3D_ERR("Emulated D3DOP_STATELIGHT failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
                break;
            }

        case D3DOP_BRANCHFORWARD:
            {
                D3DBRANCH* branch = (D3DBRANCH*)prim;
                LPBYTE target;
                BOOL isTaken = FALSE;

                D3D_INFO(5, "Emulating D3DOP_BRANCHFORWARD");
                if (branch->bNegate)
                {
                    if ((branch->dwMask & this->iClipStatus) != branch->dwValue)
                    {
                        D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: Taking forward branch");
                        if (branch->dwOffset)
                        {
                            isTaken = TRUE;
                            target = (LPBYTE)lpIns + branch->dwOffset;
                        }
                        else
                        {
                            D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: branch says to exit.");
                            goto execute_done;
                        }
                    }
                }
                else
                {
            D3D_INFO(5, "dwMask = %lx, iClipStatus = %lx, dwValue = %lx", branch->dwMask, this->iClipStatus, branch->dwValue);
                    if ((branch->dwMask & this->iClipStatus) == branch->dwValue)
                    {
                        D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: Taking forward branch");
                        if (branch->dwOffset)
                        {
                            isTaken = TRUE;
                            target = (LPBYTE)lpIns + branch->dwOffset;
                        } else
                        {
                            D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: branch says to exit.");
                            goto execute_done;
                        }
                    }
                }
                if (isTaken)
                {
                    D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: branch taken");
                    lpIns = (LPD3DINSTRUCTION) target;
                }
                else
                {
                    D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: branch not taken");
                    NEXTINSTRUCTION(lpIns, D3DBRANCH, lpIns->wCount);
                }
                break;
            }

        case D3DOP_TEXTURELOAD:
            {
                D3D_INFO(5, "Emulating D3DOP_TEXTURELOAD for HAL");
                ddrval = D3DHELInst_D3DOP_TEXTURELOAD(this,
                    lpIns->wCount,
                    (LPD3DTEXTURELOAD)prim);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_TEXTURELOAD failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DTEXTURELOAD, lpIns->wCount);
                break;
            }

        case D3DOP_SETSTATUS:
            {
                LPD3DSTATUS status = (LPD3DSTATUS)prim;
                if (status->dwFlags & D3DSETSTATUS_STATUS)
                    this->iClipStatus = status->dwStatus;
                if (status->dwFlags & D3DSETSTATUS_EXTENTS)
                {
                    this->rExtents.x1 = D3DVAL(status->drExtent.x1);
                    this->rExtents.y1 = D3DVAL(status->drExtent.y1);
                    this->rExtents.x2 = D3DVAL(status->drExtent.x2);
                    this->rExtents.y2 = D3DVAL(status->drExtent.y2);
                }
                NEXTINSTRUCTION(lpIns, D3DSTATUS, lpIns->wCount);
                break;
            }

        default:
            if ((this->dwFEFlags & D3DFE_TLVERTEX) || (mode == D3DEXECUTE_UNCLIPPED))
            {
                switch (lpIns->bOpcode)
                {
                case D3DOP_STATERENDER:
                case D3DOP_POINT:
                case D3DOP_LINE:
                case D3DOP_SPAN:
                    // ATTENTION
                    // We need to disallow SPAN from going through since the new DDI spec
                    // does not account for spans. We probably want to deprecate spans in
                    // any case so them being slower might not be too bad. Right now, though
                    // we are passing them to the driver.
                case D3DOP_TRIANGLE:
#if DBG
                    switch (lpIns->bOpcode)
                    {
                    case D3DOP_POINT:
                        Profile(PROF_EXECUTE, D3DPT_POINTLIST, GetVertexType(this));
                        break;
                    case D3DOP_LINE:
                        Profile(PROF_EXECUTE, D3DPT_LINELIST, GetVertexType(this));
                        break;
                    case D3DOP_TRIANGLE:
                        Profile(PROF_EXECUTE, D3DPT_TRIANGLELIST, GetVertexType(this));
                        break;
                    }
#endif // DBG
                    if (lpIns->wCount == 0)
                    {
                        lpIns = (LPD3DINSTRUCTION)((LPBYTE)lpIns +
                            sizeof(D3DINSTRUCTION) +
                            (lpIns->bSize * lpIns->wCount));
                        break;
                    }
                    if (!waitedForFlip)
                    {
                        WaitForFlip(lpDDS);
                        waitedForFlip = TRUE;
                    }

                    this->dp2data.dwVertexType = D3DFVF_TLVERTEX;
                    this->dp2data.dwVertexSize = sizeof(D3DTLVERTEX);
                    this->dp2data.lpDDCommands = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDExeBuf)->lpLcl;
                    this->dp2data.dwCommandOffset = (DWORD)((LPBYTE)lpIns - (LPBYTE) debDesc.lpData);
                    this->dp2data.dwCommandLength = lpExData->dwInstructionOffset + lpExData->dwInstructionLength -
                                              this->dp2data.dwCommandOffset;
                    // Can't swap command buffer in this case
                    this->dp2data.dwFlags &= ~(D3DHALDP2_SWAPCOMMANDBUFFER | D3DHALDP2_SWAPVERTEXBUFFER);
                    this->dp2data.lpdwRStates = this->rstates;
#ifndef WIN95
                    if (!IS_DX7HAL_DEVICE(this))
                    {
                        if((ddrval = CheckContextSurfaceNOLOCK (this)) != D3D_OK)
                        {
                            goto execute_failed;
                        }
                    }
#endif //WIN95
                    // and tell driver to update lpdwRStates
                    this->dp2data.dwFlags |= D3DHALDP2_EXECUTEBUFFER;
                    // Spin waiting on the driver
                    do {
                        CALL_HAL3ONLY_NOLOCK(ddrval, this, DrawPrimitives2, &this->dp2data);
                        if (ddrval != DDHAL_DRIVER_HANDLED)
                        {
                            D3D_ERR ( "Driver not handled in DrawPrimitives2" );
                            // Need sensible return value in this case,
                            // currently we return whatever the driver stuck in here.
                            goto execute_failed;
                        }
                    } while (dp2data.ddrval == DDERR_WASSTILLDRAWING);

	            // restore right value of dwVertexSize as it is a union with ddrval
                    dp2dataddrval = this->dp2data.ddrval;
#if _WIN32_WINNT >= 0x0501
                    this->dp2data.dwVertexSize = sizeof(D3DTLVERTEX);
#endif

                    // clear this bit in case drawprimitive calls after this
                    this->dp2data.dwFlags &= ~D3DHALDP2_EXECUTEBUFFER;

                    if (dp2dataddrval != DD_OK)
                    {
                        if (dp2dataddrval == D3DERR_COMMAND_UNPARSED)
                        {
                            LPD3DINSTRUCTION lpStart = lpIns;
                            lpIns = (LPD3DINSTRUCTION)(this->dp2data.dwErrorOffset + (LPBYTE)debDesc.lpData);
                            TrackAllStates(this, lpStart, lpIns);
                            break; // Continue parsing
                        }
                        else
                        {
                            D3D_ERR("HAL error in DrawPrimitives2 call from Execute API");
                            ddrval = dp2dataddrval;
                            goto execute_failed;
                        }
                    }
                    else
                    {
                        TrackAllStates(this, lpIns, NULL);
                        goto execute_done;
                    }
                default:
                    D3D_ERR("HAL detected invalid instruction opcode in Execute");
                    goto execute_failed;
                } // switch
            } // if unclipped
            else
            { // Execute Clipped
                switch (lpIns->bOpcode)
                {
                case D3DOP_STATERENDER:
                    // We do not track state. This means GetRenderState needs a DDI to
                    // work. More importantly, state overrides will get ignored. To fix
                    // this, the ParseUnknownCommand function needs to be called by the
                    // driver if it cannot understand the state change value.
                    // This function should examine if the renderstate had an override,
                    // and if so, inform the driver to request the runtime to parse the EB
                    {
                        LPD3DSTATE lpState;
                        DWORD i,j,statek,valuek;
                        lpState = (LPD3DSTATE) (lpIns + 1);
                        for (i = 0,j=0,statek=(DWORD)-1; i < lpIns->wCount; i++)
                        {
                            // This call also calls SetDeviceRenderState which
                            // is not required. But this is an optimization which
                            // can wait till later (if required)
                            if (trackState(this, &lpState[i]))
                                this->SetRenderStateI(lpState[i].drstRenderStateType, lpState[i].dwArg[0]);
                        }
                        NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
                    }
                    break;
                case D3DOP_TRIANGLE:
                    if (lpIns->wCount == 0)
                    {
                        NEXTINSTRUCTION(lpIns, D3DTRIANGLE, lpIns->wCount);
                        break;
                    }
                    Profile(PROF_EXECUTE, D3DPT_TRIANGLELIST, GetVertexType(this));
                    WAIT_FOR_FLIP();
#if DBG
                    if (!validateTriangleFlags(lpIns, (LPD3DTRIANGLE) prim))
                    {
                        ddrval = DDERR_INVALIDPARAMS;
                        goto execute_failed;
                    }
#endif
                    this->D3DStats.dwTrianglesDrawn += lpIns->wCount;
                    D3D_INFO(5, "Emulating D3DOP_TRIANGLE for HAL and clipping");

                    if (this->rstates[D3DRENDERSTATE_ZVISIBLE])
                    {
                        this->iClipStatus &= ~D3DSTATUS_ZNOTVISIBLE;
                    }
                    else
                    {
                        ddrval = D3DFEClipTrianglesHW(this, (LPD3DTRIANGLE)prim, lpIns->wCount);
                        if (ddrval != D3D_OK)
                        {
                            D3D_ERR("D3DFEClipLinesHW failed");
                            goto execute_failed;
                        }
                    }
                    NEXTINSTRUCTION(lpIns, D3DTRIANGLE, lpIns->wCount);
                    break;

                case D3DOP_LINE:

                    if (lpIns->wCount == 0)
                    {
                        NEXTINSTRUCTION(lpIns, D3DLINE, lpIns->wCount);
                        break;
                    }
                    Profile(PROF_EXECUTE, D3DPT_LINELIST, GetVertexType(this));
                    WAIT_FOR_FLIP();

                    D3D_INFO(5, "Emulating D3DOP_LINE for HAL and clipping");
                    this->D3DStats.dwLinesDrawn += lpIns->wCount;

                    if (this->rstates[D3DRENDERSTATE_ZVISIBLE])
                    {
                        this->iClipStatus &= ~D3DSTATUS_ZNOTVISIBLE;
                    }
                    else
                    {
                        ddrval = D3DFEClipLinesHW(this, (LPD3DLINE)prim, lpIns->wCount);
                        if (ddrval != D3D_OK)
                        {
                            D3D_ERR("D3DFEClipLinesHW failed");
                            goto execute_failed;
                        }
                    }
                    NEXTINSTRUCTION(lpIns, D3DLINE, lpIns->wCount);
                    break;

                case D3DOP_POINT:
                    WAIT_FOR_FLIP();

                    Profile(PROF_EXECUTE, D3DPT_POINTLIST, GetVertexType(this));
                    D3D_INFO(5, "Emulating D3DOP_POINT for HAL and clipping");
                    {
                        LPD3DPOINT point = (LPD3DPOINT) prim;
                        int i;
                        for (i = 0; i < lpIns->wCount; i++)
                        {
                            this->D3DStats.dwPointsDrawn += point->wCount;
                            point++;
                        }
                    }
                    if (this->rstates[D3DRENDERSTATE_ZVISIBLE])
                    {
                        this->iClipStatus &= ~D3DSTATUS_ZNOTVISIBLE;
                    }
                    else
                    {
                        ddrval = D3DFEClipPointsHW(this, (LPD3DPOINT)prim, lpIns->wCount);
                        if (ddrval != D3D_OK)
                        {
                            D3D_ERR("D3DFEClipPointsHW failed");
                            goto execute_failed;
                        }
                    }
                    NEXTINSTRUCTION(lpIns, D3DPOINT, lpIns->wCount);
                    break;

                case D3DOP_SPAN:
                    // This case is NOOP since we do not implement spans in DP2 DDI
                    {
                        lpIns = (LPD3DINSTRUCTION)((LPBYTE)lpIns
                            + sizeof(D3DINSTRUCTION)
                            + (lpIns->bSize * lpIns->wCount));
                        break;
                    }
                default:
                    D3D_ERR("HAL detected invalid instruction opcode in Execute");
                    goto execute_failed;
                } // switch
                ClampExtents(this);
            } // Execute Clipped
        } // switch
    } // while

execute_done:

    D3DFE_ConvertExtent(this, &this->rExtents, &lpExData->dsStatus.drExtent);
    lpExData->dsStatus.dwStatus = this->iClipStatus;
    ddrval = D3D_OK;

execute_failed:
    // Restore Command Buffer in case of Unclipped EB
    if ((this->dwFEFlags & D3DFE_TLVERTEX) || (mode == D3DEXECUTE_UNCLIPPED))
    {
        this->dp2data.lpDDCommands = ((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSCB1)->lpLcl;
        this->dp2data.dwCommandOffset = 0;
        this->dp2data.dwCommandLength = 0;
            this->dp2data.dwFlags |= D3DHALDP2_SWAPCOMMANDBUFFER;
    }
    this->dwFlags &= ~D3DPV_WITHINPRIMITIVE;
    UNLOCK_HAL(this);
    return ddrval;
#undef WAIT_FOR_FLIP
}
//---------------------------------------------------------------------
HRESULT D3DHAL_ExecutePick(LPDIRECT3DDEVICEI lpDevI,
                           LPD3DI_PICKDATA      lpPickData)
{
    LPD3DI_EXECUTEDATA  lpExData = lpPickData->exe;
    D3DRECT*    pick_rect = &lpPickData->pick;
    D3DINSTRUCTION* lpIns;
    D3DEXECUTEBUFFERDESC debDesc;
    LPBYTE prim;
    LPD3DDEVICEDESC_V1 halCaps = &lpDevI->lpD3DHALGlobalDriverData->hwCaps;
    BOOL bMustDoTransform = halCaps->dwFlags & D3DDD_TRANSFORMCAPS;
    D3DI_PICKDATA* pdata = &lpDevI->pick_data;
    LPDIRECTDRAWSURFACE lpDDExeBuf;
    HRESULT ddrval;
    D3DFE_TRANSFORM *transform = &lpDevI->transform;
    DWORD i;
    LPD3DSTATE lpState;

    D3D_INFO(3, "ExecutePick called.%d");

    /*
    * Clear all the old pick records.
    */

    pdata->pick_count = 0;

    if (pdata->records)
        D3DFree(pdata->records);

    pdata->records = NULL;

    //Flush the cached states
    ddrval = lpDevI->FlushStates();
    if (ddrval != D3D_OK)
    {
        D3D_ERR("Error trying to render batched commands in D3DHAL_ExecutePick");
        return ddrval;
    }

    // Grow internal buffers to hold vertices
    ddrval = lpDevI->TLVbuf.CheckAndGrow
        (lpDevI, lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwMaxVertexCount << 5);
    if (ddrval != D3D_OK)
    {
        D3D_ERR("Failed to check and grow TLVbuf in ExecutePick");
        return ddrval;
    }
    ddrval = lpDevI->HVbuf.CheckAndGrow
        (lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwMaxVertexCount*sizeof(D3DFE_CLIPCODE));
    if (ddrval != D3D_OK)
    {
        D3D_ERR("Failed to check and grow HVbuf in ExecutePick");
        return ddrval;
    }
    /*
    * Execute the buffer through the HAL
    */
    D3D_INFO(4, "Locking execute buffer for execution");
    memset(&debDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
    debDesc.dwSize = sizeof(D3DEXECUTEBUFFERDESC);

    ddrval = D3DHAL_LockBuffer(lpDevI, lpExData->dwHandle, &debDesc, &lpDDExeBuf);
    CHECK(ddrval, "Lock of execute buffer for execution failed");

    // Modify driver funcs for EB pick case
    PFN_DRAWPRIM pfnOldDrawPrim = lpDevI->pfnDrawPrim;
    PFN_DRAWPRIM pfnOldDrawIndexedPrim = lpDevI->pfnDrawIndexedPrim;
    lpDevI->pfnDrawPrim = &DIRECT3DDEVICEI::PickExeBuf;
    lpDevI->pfnDrawIndexedPrim = &DIRECT3DDEVICEI::PickExeBuf;

    /*
    * Calculate the instruction that could not be handled.
    */
    lpIns = (LPD3DINSTRUCTION)((LPBYTE)debDesc.lpData + lpExData->dwInstructionOffset);

    lpDevI->lpbClipIns_base = (unsigned char*)lpIns;

    while (lpIns->bOpcode != D3DOP_EXIT)
    {
        prim = (LPBYTE)(lpIns + 1);

        /*
        * Parse the instruction, passing rasterisation calls to HAL.
        */
        switch (lpIns->bOpcode)
        {
        /*
        * Instructions that must be emulated.
            */
        case D3DOP_MATRIXLOAD:
            D3D_INFO(5, "Emulating D3DOP_MATRIXLOAD for HAL");
            ddrval = D3DHELInst_D3DOP_MATRIXLOAD(lpDevI,
                lpIns->wCount,
                (LPD3DMATRIXLOAD)prim);
            if (ddrval != D3D_OK)
            {
                D3D_ERR("Emulated D3DOP_MATRIXLOAD failed.");
                goto executePick_failed;
            }
            NEXTINSTRUCTION(lpIns, D3DMATRIXLOAD, lpIns->wCount);
            break;
        case D3DOP_MATRIXMULTIPLY:
            D3D_INFO(5, "Emulating D3DOP_MATRIXMULTIPLY for HAL");
            ddrval = D3DHELInst_D3DOP_MATRIXMULTIPLY(lpDevI,
                lpIns->wCount,
                (LPD3DMATRIXMULTIPLY)prim);
            if (ddrval != D3D_OK)
            {
                D3D_ERR("Emulated D3DOP_MATRIXMULTIPLY failed.");
                goto executePick_failed;
            }
            NEXTINSTRUCTION(lpIns, D3DMATRIXMULTIPLY, lpIns->wCount);
            break;
        case D3DOP_STATERENDER:
            lpState = (LPD3DSTATE) (lpIns + 1);
            {
                D3DHAL_RENDERSTATEDATA stateData;
                DWORD j,statek,valuek;
                stateData.dwhContext = lpDevI->dwhContext;
                stateData.lpExeBuf = lpDDExeBuf;
                stateData.dwOffset = (DWORD)((ULONG_PTR)lpIns - (ULONG_PTR)debDesc.lpData +
                    sizeof(D3DINSTRUCTION));
                stateData.dwCount = lpIns->wCount;
                CALL_HALONLY(ddrval, lpDevI, RenderState, &stateData);
                if (stateData.ddrval != DD_OK)
                {
                    D3D_ERR("HAL error in RenderState call from ExecutePick API");
                    ddrval = stateData.ddrval;
                    goto executePick_failed;
                }
            }
            for (i = 0; i < lpIns->wCount; i++)
            {
                trackState(lpDevI, &lpState[i]);
            }
            NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
            break;

        case D3DOP_STATETRANSFORM:
            D3D_INFO(5, "Emulating D3DOP_STATETRANSFORM for HAL");
            ddrval = D3DHELInst_D3DOP_STATETRANSFORM(lpDevI, lpIns->wCount,
                (LPD3DSTATE)prim);
            if (ddrval != D3D_OK)
            {
                D3D_ERR("Emulated D3DOP_STATETRANSFORM failed.");
                goto executePick_failed;
            }
            NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
            break;
            /*
            * Operations that require clipping.
            */
        case D3DOP_PROCESSVERTICES:
            D3D_INFO(5, "Emulating D3DOP_PROCESSVERTICES for HAL and clipping");
            ddrval = D3DHELInst_D3DOP_TRANSFORM
                (lpDevI, lpIns->wCount, (LPD3DPROCESSVERTICES)prim, &debDesc);
            if (ddrval != D3D_OK)
            {
                D3D_ERR("Emulated D3DOP_PROCESSVERTICES failed.");
                goto executePick_failed;
            }
            NEXTINSTRUCTION(lpIns, D3DPROCESSVERTICES, lpIns->wCount);
            break;
        case D3DOP_TRIANGLE:
            if (!lpDevI->rstates[D3DRENDERSTATE_ZVISIBLE])
            {
                D3D_INFO(5, "Picking D3DOP_TRIANGLE for HAL and clipping");
                lpDevI->pick_data.pick = *pick_rect;

                HRESULT ret;
                if (lpDevI->dwFEFlags & D3DFE_TLVERTEX)
                {
                    lpDevI->primType = D3DPT_TRIANGLELIST;
                    lpDevI->dwNumIndices = lpIns->wCount * 3;
                    lpDevI->dwNumPrimitives = lpIns->wCount;
                    lpDevI->lpvOut = lpDevI->TLVbuf.GetAddress();
                    lpDevI->lpwIndices = (WORD*)prim;
                    ret = lpDevI->PickExeBuf();
                }
                else
                    ret = GenPickTriangles(lpDevI, (LPD3DTRIANGLE)prim, lpIns->wCount);

                if (ret != D3D_OK)
                    goto executePick_failed;
            }
            NEXTINSTRUCTION(lpIns, D3DTRIANGLE, lpIns->wCount);
            break;
        case D3DOP_SETSTATUS:
            {
                LPD3DSTATUS status = (LPD3DSTATUS)prim;
                if (status->dwFlags & D3DSETSTATUS_STATUS)
                    lpDevI->iClipStatus = status->dwStatus;
                if (status->dwFlags & D3DSETSTATUS_EXTENTS)
                {
                    lpDevI->rExtents.x1 = D3DVAL(status->drExtent.x1);
                    lpDevI->rExtents.y1 = D3DVAL(status->drExtent.y1);
                    lpDevI->rExtents.x2 = D3DVAL(status->drExtent.x2);
                    lpDevI->rExtents.y2 = D3DVAL(status->drExtent.y2);
                }
            }
            NEXTINSTRUCTION(lpIns, D3DSTATUS, lpIns->wCount);
            break;
        case D3DOP_BRANCHFORWARD:
            {
                D3DBRANCH* branch = (D3DBRANCH*)prim;
                LPBYTE target;
                BOOL isTaken = FALSE;
                D3D_INFO(5, "Emulating D3DOP_BRANCHFORWARD for HAL.");
                if (branch->bNegate)
                {
                    if ((branch->dwMask & lpDevI->iClipStatus) != branch->dwValue)
                    {
                        D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: Taking forward branch");
                        if (branch->dwOffset)
                        {
                            isTaken = TRUE;
                            target = (LPBYTE)lpIns + branch->dwOffset;
                        } else
                            goto early_out;
                    }
                }
                else
                {
                    if ((branch->dwMask & lpDevI->iClipStatus) == branch->dwValue)
                    {
                        D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: Taking forward branch");
                        if (branch->dwOffset)
                        {
                            isTaken = TRUE;
                            target = (LPBYTE)lpIns + branch->dwOffset;
                        }
                        else
                            goto early_out;
                    }
                }
                if (isTaken)
                    lpIns = (LPD3DINSTRUCTION)target;
                else
                {
                    NEXTINSTRUCTION(lpIns, D3DBRANCH, lpIns->wCount);
                }
            }
            break;

        default:
            D3D_INFO(4, "Skipping instruction %d in ExecutePick",
                lpIns->bOpcode);
            lpIns = (LPD3DINSTRUCTION)((LPBYTE)lpIns +
                sizeof(D3DINSTRUCTION) +
                (lpIns->wCount * lpIns->bSize));
            break;
        }
    }
early_out:
    D3DHAL_UnlockBuffer(lpDevI, lpExData->dwHandle);
    D3DFE_ConvertExtent(lpDevI, &lpDevI->rExtents, &lpExData->dsStatus.drExtent);
    lpExData->dsStatus.dwStatus = lpDevI->iClipStatus;
    // Restore driver funcs
    lpDevI->pfnDrawIndexedPrim = pfnOldDrawIndexedPrim;
    lpDevI->pfnDrawPrim = pfnOldDrawPrim;

    return (D3D_OK);

executePick_failed:
    D3D_ERR("ExecutePick Failed.");
    D3DHAL_UnlockBuffer(lpDevI, lpExData->dwHandle);
    // Restore driver funcs
    lpDevI->pfnDrawIndexedPrim = pfnOldDrawIndexedPrim;
    lpDevI->pfnDrawPrim = pfnOldDrawPrim;
    return ddrval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\halbuf.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   halbuf.c
 *  Content:    Direct3D HAL buffer management
 *@@BEGIN_MSINTERNAL
 * 
 *  $Id: halbuf.c,v 1.1 1995/11/21 15:12:30 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   06/11/95   stevela Initial rev.
 *   07/11/95   stevela stuff.
 *   17/02/96   colinmc Fixed build problem.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#include "pch.cpp"
#pragma hdrstop

HRESULT D3DHAL_AllocateBuffer(LPDIRECT3DDEVICEI lpDevI,
                              LPD3DI_BUFFERHANDLE lphBuf,
                              LPD3DEXECUTEBUFFERDESC lpDebDesc,
                              LPDIRECTDRAWSURFACE* lplpBuf)
{
    DDSURFACEDESC ddsd;
    LPD3DHAL_EXDATA hexData;
    DWORD dwSize = lpDebDesc->dwBufferSize;
    HRESULT ddrval;

    D3D_INFO(6, "AllocateBuffer, dwhContext = %d, lpDebDesc = %08lx, size = %d",
        lpDevI->dwhContext, lpDebDesc, lpDebDesc->dwBufferSize);

    if (!lpDebDesc->dwFlags & D3DDEB_BUFSIZE) 
    {
        return (DDERR_INVALIDPARAMS);
    }

    D3DMalloc((void**)&hexData, sizeof(D3DHAL_EXDATA));
    if (!hexData) {
        D3D_ERR("Failed to create buffer internal data");
        return (D3DERR_EXECUTE_CREATE_FAILED);
    }
    memset(hexData, 0, sizeof(D3DHAL_EXDATA));

    hexData->debDesc = *lpDebDesc;

    /*
     * Create the buffer through DirectDraw
     */
    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    ddsd.dwFlags = DDSD_WIDTH | DDSD_CAPS;
    ddsd.dwWidth = hexData->debDesc.dwBufferSize;
    ddsd.ddsCaps.dwCaps = DDSCAPS_EXECUTEBUFFER;
// System memory exebufs only for now
//  if (hexData->debDesc.dwCaps & D3DDEBCAPS_VIDEOMEMORY) {
//      ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
//  } else {
    ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
//    }

    ddrval = lpDevI->lpDD->CreateSurface(&ddsd, &hexData->lpDDS, NULL);

    if (ddrval != DD_OK) {
        D3D_ERR("failed in AllocateBuffer");
        D3DFree(hexData);
        return (D3DERR_EXECUTE_CREATE_FAILED);
    }

    LIST_INSERT_ROOT(&lpDevI->bufferHandles, hexData, link);

    *lphBuf = (ULONG_PTR) hexData;
    *lplpBuf = hexData->lpDDS;

    memset(lpDebDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
    lpDebDesc->dwSize = sizeof(D3DEXECUTEBUFFERDESC);
    lpDebDesc->dwBufferSize = dwSize;
    if (hexData->debDesc.dwFlags & D3DDEB_CAPS)
    {
        lpDebDesc->dwCaps = hexData->debDesc.dwCaps;
        lpDebDesc->dwCaps &= ~DDSCAPS_VIDEOMEMORY;
        lpDebDesc->dwCaps |= DDSCAPS_SYSTEMMEMORY;
    }
    else
        lpDebDesc->dwCaps = DDSCAPS_SYSTEMMEMORY;
    lpDebDesc->dwFlags = D3DDEB_BUFSIZE | D3DDEB_CAPS;

    D3D_INFO(9, "AllocateBuffer, succeeded.");

    return (D3D_OK);
}

HRESULT D3DHAL_DeallocateBuffer(LPDIRECT3DDEVICEI lpDevI, D3DI_BUFFERHANDLE hBuf)
{
    LPD3DHAL_EXDATA hexData;
    HRESULT ddrval;

    D3D_INFO(6, "DeallocateBuffer, dwhContext = %d, hBuf = %08lx",
        lpDevI->dwhContext, hBuf);

    hexData = (LPD3DHAL_EXDATA) hBuf;

    TRY {
        ddrval = hexData->lpDDS->Release();
        if (ddrval != DD_OK) {
            D3D_ERR("did not free the memory");
            return (ddrval);
        }
    } EXCEPT (EXCEPTION_EXECUTE_HANDLER) {
        D3D_INFO(6, "Execute buffer surface was already freed by DirectDraw");
    }

    LIST_DELETE(hexData, link);
    D3DFree(hexData);

    return (D3D_OK);
}

HRESULT D3DHAL_DeallocateBuffers(LPDIRECT3DDEVICEI lpDevI)
{
    while (LIST_FIRST(&lpDevI->bufferHandles)) {
        D3DHAL_DeallocateBuffer(lpDevI,
                                (D3DI_BUFFERHANDLE)
                                LIST_FIRST(&lpDevI->bufferHandles));
    }
    return (D3D_OK);
}

HRESULT D3DHAL_LockBuffer(LPDIRECT3DDEVICEI lpDevI, D3DI_BUFFERHANDLE hBuf,
                          LPD3DEXECUTEBUFFERDESC lpUserDebDesc,
                          LPDIRECTDRAWSURFACE* lplpBuf)
{
    LPD3DHAL_EXDATA hexData;
    DDSURFACEDESC ddsd;
    HRESULT ddrval;

    D3D_INFO(6, "LockBuffer, dwhContext = %d, hBuf = %08lx",
        lpDevI->dwhContext, hBuf);

    hexData = (LPD3DHAL_EXDATA) hBuf;

#ifdef USE_INTERNAL_LOCK
    do {
        LPDDRAWI_DDRAWSURFACE_INT lpInt;
        lpInt = (LPDDRAWI_DDRAWSURFACE_INT) hexData->lpDDS;
        ddrval = DDInternalLock(lpInt->lpLcl, &ddsd.lpSurface);
    } while (ddrval == DDERR_WASSTILLDRAWING);
#else
    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    do {
        ddrval = hexData->lpDDS->Lock(NULL, &ddsd,
                                      DDLOCK_WAIT, NULL);
    } while (ddrval == DDERR_WASSTILLDRAWING);
#endif
    if (ddrval != DD_OK) {
        D3D_ERR("failed in LockBuffer");
        return (D3DERR_EXECUTE_LOCK_FAILED);
    }

    *lplpBuf = hexData->lpDDS;
    memset(lpUserDebDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
    lpUserDebDesc->dwSize = sizeof(D3DEXECUTEBUFFERDESC);
    lpUserDebDesc->dwBufferSize = hexData->debDesc.dwBufferSize;
    lpUserDebDesc->lpData = ddsd.lpSurface;
    lpUserDebDesc->dwFlags = D3DDEB_LPDATA;


    return (D3D_OK);
}

HRESULT D3DHAL_UnlockBuffer(LPDIRECT3DDEVICEI lpDevI, D3DI_BUFFERHANDLE hBuf)
{
    LPD3DHAL_EXDATA hexData;
    HRESULT ddrval;

    D3D_INFO(6, "UnlockBuffer, dwhContext = %d, hBuf = %08lx",
        lpDevI->dwhContext, hBuf);

    hexData = (LPD3DHAL_EXDATA) hBuf;

#ifdef USE_INTERNAL_LOCK
    {
        LPDDRAWI_DDRAWSURFACE_INT lpInt;
        lpInt = (LPDDRAWI_DDRAWSURFACE_INT) hexData->lpDDS;
        ddrval = DDInternalUnlock(lpInt->lpLcl);
    }
#else
    ddrval = hexData->lpDDS->Unlock(NULL);
#endif
    if (ddrval != DD_OK) {
        D3D_ERR("didn't handle handle UnlockBuffer");
        return (ddrval);
    }

    return (D3D_OK);
}

#ifndef USE_SURFACE_LOCK

HRESULT D3DHAL_LockDibEngine(LPDIRECT3DDEVICEI lpDevI)
{
#ifndef WIN95
    return D3D_OK;
#else
    HRESULT ret;
    LPDDRAWI_DIRECTDRAW_GBL pdrv = lpDevI->lpDDGbl;
    LPWORD pdflags;
    BOOL isbusy;

    pdflags = pdrv->lpwPDeviceFlags;
    isbusy = 0;

    _asm
    {
        mov eax, pdflags
        bts word ptr [eax], BUSY_BIT
        adc isbusy,0
    }

    if (isbusy) {
        D3D_WARN(2, "LOCK_DIBENGINE, dibengine is busy");
        ret = DDERR_SURFACEBUSY;
    } else
        ret = DD_OK;

    return ret;
#endif
}

void D3DHAL_UnlockDibEngine(LPDIRECT3DDEVICEI lpDevI)
{
#ifndef WIN95
    return;
#else
    LPDDRAWI_DIRECTDRAW_GBL pdrv = lpDevI->lpDDGbl;
    *pdrv->lpwPDeviceFlags &= ~BUSY;
#endif
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\halscene.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   halscene.c
 *  Content:    Direct3D HAL scene capture
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   07/12/95   stevela Initial rev.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

HRESULT D3DHAL_SceneCapture(LPDIRECT3DDEVICEI lpDevI,
                            BOOL bState)
{
    D3DHAL_SCENECAPTUREDATA data;
    HRESULT ret;
    
    if (IS_DX7HAL_DEVICE(lpDevI))
    {
        return lpDevI->SetRenderStateI((D3DRENDERSTATETYPE)D3DRENDERSTATE_SCENECAPTURE, bState);
    }

    ret = CallRampService(lpDevI, RAMP_SERVICE_SCENE_CAPTURE, bState, lpDevI);
    if (ret != DD_OK)
    {
        return ret;
    }

    if (!lpDevI->lpD3DHALCallbacks->SceneCapture) {
        return (D3D_OK);
    }

    D3D_INFO(6, "SceneCapture, setting %d dwhContext = %d",
             bState, lpDevI->dwhContext);

    memset(&data, 0, sizeof(D3DHAL_SCENECAPTUREDATA));
    data.dwhContext = lpDevI->dwhContext;
    data.dwFlag = bState ? D3DHAL_SCENE_CAPTURE_START : D3DHAL_SCENE_CAPTURE_END;

    CALL_HALONLY(ret, lpDevI, SceneCapture, &data);
    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
        D3D_ERR("HAL failed to handle SceneCapture");
        return (data.ddrval);
    }

    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\haldrv.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997, 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       haldrv.cpp
 *  Content:    Direct3D HAL Driver
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "commdrv.hpp"
#include "genpick.hpp"
#include "d3dfei.h"
#include "span.h"

#ifndef WIN95
#include <ntgdistr.h>
#endif

void Destroy(LPDIRECT3DDEVICEI lpDevI);
//---------------------------------------------------------------------
int
GenGetExtraVerticesNumber( LPDIRECT3DDEVICEI lpDevI )
{
    LPD3DHAL_GLOBALDRIVERDATA lpGlob = lpDevI->lpD3DHALGlobalDriverData;

    return (int)(lpGlob->dwNumVertices ?
        lpGlob->dwNumVertices : D3DHAL_DEFAULT_TL_NUM);

}
//---------------------------------------------------------------------
HRESULT CalcDDSurfInfo(LPDIRECT3DDEVICEI lpDevI, BOOL bUpdateZBufferFields)
{
    DDSURFACEDESC ddsd;
    HRESULT ddrval;
    DWORD dwWidth, dwHeight;
    unsigned long m;
    int s;

    // Get info from the surface

    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    ddrval = lpDevI->lpDDSTarget->GetSurfaceDesc(&ddsd);
    if (ddrval != DD_OK) {
        return ddrval;
    }

    dwWidth = ddsd.dwWidth;
    dwHeight = ddsd.dwHeight;
    if ((ddsd.ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8)) == 0) {
        // palettized pixfmts will not have valid RGB Bitmasks, so avoid computing this for them

        lpDevI->red_mask = ddsd.ddpfPixelFormat.dwRBitMask;
        lpDevI->green_mask = ddsd.ddpfPixelFormat.dwGBitMask;
        lpDevI->blue_mask = ddsd.ddpfPixelFormat.dwBBitMask;

        if ((lpDevI->red_mask == 0x0)  ||
            (lpDevI->green_mask == 0x0) ||
            (lpDevI->blue_mask == 0x0))
        {
            D3D_ERR("All the color masks in the Render target's pixel-format must be non-zero");
            return DDERR_INVALIDPIXELFORMAT;
        }

        // these are used by Clear
        for (s = 0, m = lpDevI->red_mask; !(m & 1); s++, m >>= 1) ;
        lpDevI->red_shift = s;
        lpDevI->red_scale = 255 / (lpDevI->red_mask >> s);
        for (s = 0, m = lpDevI->green_mask; !(m & 1); s++, m >>= 1) ;
        lpDevI->green_shift = s;
        lpDevI->green_scale = 255 / (lpDevI->green_mask >> s);
        for (s = 0, m = lpDevI->blue_mask; !(m & 1); s++, m >>= 1) ;
        lpDevI->blue_shift = s;
        lpDevI->blue_scale = 255 / (lpDevI->blue_mask >> s);

        DDASSERT(lpDevI->red_scale!=0);
        DDASSERT(lpDevI->green_scale!=0);
        DDASSERT(lpDevI->blue_scale!=0);
        lpDevI->bDDSTargetIsPalettized=FALSE;
    } else
        lpDevI->bDDSTargetIsPalettized=TRUE;

    if (lpDevI->lpDDSZBuffer_DDS4 && bUpdateZBufferFields) {
        // Get info from the surface

        DDSURFACEDESC2 ddsd2;

        memset(&ddsd2, 0, sizeof(ddsd2));
        ddsd2.dwSize = sizeof(ddsd2);
        ddrval = lpDevI->lpDDSZBuffer_DDS4->GetSurfaceDesc(&ddsd2);
        if (ddrval != DD_OK) {
            return ddrval;
        }

        if( ddsd2.ddpfPixelFormat.dwZBitMask!=0x0) {
            for (s = 0, m = ddsd2.ddpfPixelFormat.dwZBitMask; !(m & 0x1); s++, m >>= 1) ;
            lpDevI->zmask_shift=s;
        } else {
            lpDevI->zmask_shift=0;     // if ZBitMask isn't being set, then Clear2 will never be used,
                                      // so zbuf_shift/stencil_shift wont be needed anyway
        }

        if( ddsd2.ddpfPixelFormat.dwStencilBitMask!=0x0) {
            for (s = 0, m = ddsd2.ddpfPixelFormat.dwStencilBitMask; !(m & 0x1); s++, m >>= 1) ;
            lpDevI->stencilmask_shift=s;
        } else {
            lpDevI->stencilmask_shift=0;
        }
    }

    return D3D_OK;
}

// called by DDRAW
extern "C" HRESULT __stdcall Direct3D_HALCleanUp(LPD3DHAL_CALLBACKS lpD3DHALCallbacks, DWORD dwPID)
{
    D3DHAL_CONTEXTDESTROYALLDATA data;
    HRESULT ret;

    DDASSERT(lpD3DHALCallbacks!=NULL);
    if (lpD3DHALCallbacks->ContextDestroyAll==NULL) {
        // no cleanup necessary (running on d3d hel)
    return D3D_OK;
    }

    memset(&data, 0, sizeof(D3DHAL_CONTEXTDESTROYALLDATA));
    data.dwPID = dwPID;

    // I'd prefer to use CALL_HALONLY() to do the locking (to avoid doing it for the SW rasterizers),
    // but that requires a pDevI which I can't get to from the caller, which is a ddraw cleanup routine

#ifdef WIN95
    _EnterSysLevel(lpWin16Lock);
#endif

    ret = (*lpD3DHALCallbacks->ContextDestroyAll)(&data);

#ifdef WIN95
    _LeaveSysLevel(lpWin16Lock);
#endif

    return ret;
}


// ATTENTION - These two functions should be combined into one as soon
// as ContextCreate has the new private data mechanism built in.
#ifdef WIN95
HRESULT halCreateContext(LPDIRECT3DDEVICEI lpDevI)
{
    D3DHAL_CONTEXTCREATEDATA data;
    HRESULT ret;

    D3D_INFO(6, "in halCreateContext. Creating Context for driver = %08lx", lpDevI);

    LIST_INITIALIZE(&lpDevI->bufferHandles);

    memset(&data, 0, sizeof(D3DHAL_CONTEXTCREATEDATA));
    //
    // From DX7 onwards, drivers should be accepting
    // Surface Locals instead of the Surface interfaces
    // this future-proofs the drivers
    //
    if (IS_DX7HAL_DEVICE(lpDevI))
    {
        if (lpDevI->lpDD)
            data.lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)(lpDevI->lpDD))->lpLcl;
        else
            data.lpDDLcl = NULL;

        if (lpDevI->lpDDSTarget)
            data.lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl;
        else
            data.lpDDSLcl = NULL;

        if (lpDevI->lpDDSZBuffer)
            data.lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSZBuffer)->lpLcl;
        else
            data.lpDDSZLcl = NULL;

    }
    else
    {
        data.lpDDGbl = lpDevI->lpDDGbl;
        data.lpDDS = lpDevI->lpDDSTarget;
        data.lpDDSZ = lpDevI->lpDDSZBuffer;
    }
    data.dwPID = GetCurrentProcessId();

    if (lpDevI->d3dHWDevDesc.dwFlags == 0)
    {
        // The new software rasterizers want to share IM's state vector so
        // we need to pass them the rstates pointer.  They don't
        // care about dwPID so stick the pointer in there.
        data.dwPID = (DWORD)lpDevI->rstates;
    }

    /* 0 for pre-DX5 devices.
     * 1 for DX5 devices.
     * 2 for DX6 devices.
     */
    data.dwhContext = lpDevI->dwVersion - 1;

    CALL_HALONLY(ret, lpDevI, ContextCreate, &data);
    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
D3D_ERR("HAL context create failed");
        return (DDERR_GENERIC);
    }
    lpDevI->dwhContext = data.dwhContext;

    if (D3DMalloc ((void**)&lpDevI->lpwDPBufferAlloced,
                   max(dwD3DTriBatchSize*4*sizeof(WORD),
                       dwHWBufferSize) +32) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate" );
        return (DDERR_OUTOFMEMORY);
    }
    lpDevI->lpwDPBuffer =
        (LPWORD) (((DWORD) lpDevI->lpwDPBufferAlloced+31) & (~31));
    lpDevI->lpDPPrimCounts =
        (LPD3DHAL_DRAWPRIMCOUNTS) lpDevI->lpwDPBuffer;
    memset( (char *)lpDevI->lpwDPBuffer, 0,
            sizeof(D3DHAL_DRAWPRIMCOUNTS));     //Clear header also
    lpDevI->dwDPOffset = sizeof(D3DHAL_DRAWPRIMCOUNTS);
    lpDevI->dwDPMaxOffset = dwD3DTriBatchSize * sizeof(D3DTRIANGLE)-sizeof(D3DTLVERTEX);

    // save the surface handle for later checks
    lpDevI->hSurfaceTarget = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->lpSurfMore->dwSurfaceHandle;

    D3D_INFO(6, "in halCreateContext. Succeeded. dwhContext = %d", data.dwhContext);

    return (D3D_OK);
}
#else
    /*
     * On NT the kernel code creates the buffer to be used
     * for DrawPrim batching and returns it as extra data
     * in the ContextCreate request.
     */
HRESULT halCreateContext(LPDIRECT3DDEVICEI lpDevI)
{
    D3DNTHAL_CONTEXTCREATEI ntData;
    D3DHAL_CONTEXTCREATEDATA *lpData =
        (D3DHAL_CONTEXTCREATEDATA *)&ntData;
    HRESULT ret;

    D3D_INFO(6, "in halCreateContext. Creating Context for driver = %08lx", lpDevI);

    LIST_INITIALIZE(&lpDevI->bufferHandles);

    /*
     * AnanKan: Assert here that the D3DNTHAL_CONTEXTCREATEI structure is
     * 2 DWORDS bigger than D3DHAL_CONTEXTCREATEDATA. This will be a good
     * consistency check for NT kernel updates.
     */
    memset(&ntData, 0, sizeof(ntData));
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)
    {
        if (lpDevI->lpDD)
            lpData->lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)(lpDevI->lpDD))->lpLcl;
        else
            lpData->lpDDLcl = NULL;

        if (lpDevI->lpDDSTarget)
            lpData->lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl;
        else
            lpData->lpDDSLcl = NULL;

        if (lpDevI->lpDDSZBuffer)
            lpData->lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSZBuffer)->lpLcl;
        else
            lpData->lpDDSZLcl = NULL;
    }
    else
    {
        lpData->lpDDGbl = lpDevI->lpDDGbl;
        lpData->lpDDS = lpDevI->lpDDSTarget;
        lpData->lpDDSZ = lpDevI->lpDDSZBuffer;
    }
    lpData->dwPID = GetCurrentProcessId();

    if (lpDevI->d3dHWDevDesc.dwFlags == 0)
    {
        // The new software rasterizers want to share IM's state vector so
        // we need to pass them the rstates pointer.  They don't
        // care about dwPID so stick the pointer in there.
        // Sundown: was lpData->dwPID, but added a union in d3dhal.h
        lpData->dwrstates = (ULONG_PTR)lpDevI->rstates;
    }

    /* 0 for pre-DX5 devices.
     * 1 for DX5 devices.
     * 2 for DX6 devices.
     */
    lpData->dwhContext = lpDevI->dwVersion - 1;
    ntData.cjBuffer = lpDevI->dwDPBufferSize;
    ntData.pvBuffer = NULL;

    CALL_HALONLY(ret, lpDevI, ContextCreate, lpData);
    if (ret != DDHAL_DRIVER_HANDLED || lpData->ddrval != DD_OK) {

D3D_ERR("HAL context create failed");
        return (DDERR_GENERIC);
    }
    lpDevI->dwhContext = lpData->dwhContext;

    // If the lpDevI chose not to allocate a DrawPrim buffer do
    // it for them.
    if (ntData.pvBuffer == NULL)
    {
        lpDevI->dwDPBufferSize =
            dwD3DTriBatchSize * 4 * sizeof(WORD);
        if (lpDevI->dwDPBufferSize < dwHWBufferSize)
        {
            lpDevI->dwDPBufferSize = dwHWBufferSize;
        }

        ret = D3DMalloc((void**)&lpDevI->lpwDPBufferAlloced,
                        lpDevI->dwDPBufferSize + 32);
        if (ret != DD_OK)
        {
D3D_ERR("halCreateContext D3DMalloc");
            return ret;
        }

        ntData.pvBuffer = (LPVOID)
            (((ULONG_PTR)lpDevI->lpwDPBufferAlloced + 31) & ~31);
        ntData.cjBuffer = lpDevI->dwDPBufferSize + 32 -
             (DWORD)((ULONG_PTR)ntData.pvBuffer -
                     (ULONG_PTR)lpDevI->lpwDPBufferAlloced);
    }
    else if( (lpDevI->dwDPBufferSize &&
              ntData.cjBuffer < lpDevI->dwDPBufferSize) ||
             ntData.cjBuffer < sizeof(D3DHAL_DRAWPRIMCOUNTS) )
    {
D3D_ERR("halCreateContext buffer stuff");
        return (DDERR_GENERIC);
    }

    // Need to save the buffer space provided and its size
    lpDevI->lpwDPBuffer = (LPWORD)ntData.pvBuffer;
    lpDevI->lpDPPrimCounts =
        (LPD3DHAL_DRAWPRIMCOUNTS)ntData.pvBuffer;

    //Clear header also
    memset( (char *)ntData.pvBuffer, 0, sizeof(D3DHAL_DRAWPRIMCOUNTS));

    lpDevI->dwDPOffset = sizeof(D3DHAL_DRAWPRIMCOUNTS);
    lpDevI->dwDPMaxOffset = ntData.cjBuffer-sizeof(D3DTLVERTEX);

    // save the surface handle for later checks
    lpDevI->hSurfaceTarget = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface;

    D3D_INFO(6, "in halCreateContext. Succeeded. dwhContext = %d", lpData->dwhContext);

    return (D3D_OK);
}
#endif


void halDestroyContext(LPDIRECT3DDEVICEI lpDevI)
{
    D3DHAL_CONTEXTDESTROYDATA data;
    HRESULT ret;

    D3D_INFO(6, "in halCreateDestroy. Destroying Context for driver = %08lx", lpDevI);
    D3D_INFO(6, "                     dwhContext = %d", lpDevI->dwhContext);

    if(lpDevI->dwhContext!=NULL) {
        memset(&data, 0, sizeof(D3DHAL_CONTEXTDESTROYDATA));
        data.dwhContext = lpDevI->dwhContext;

        CALL_HALONLY(ret, lpDevI, ContextDestroy, &data);
        if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
            D3D_WARN(0,"Failed ContextDestroy HAL call in halDestroyContext");
            return;
        }
    }

    D3DHAL_DeallocateBuffers(lpDevI);
}
//---------------------------------------------------------------------
HRESULT D3DFE_Create(LPDIRECT3DDEVICEI lpDevI,
                     LPDIRECTDRAW lpDD,
                     LPDIRECTDRAWSURFACE lpDDS,
                     LPDIRECTDRAWSURFACE lpZ,
                     LPDIRECTDRAWPALETTE lpPal)
{
    DDSURFACEDESC ddsd;
    HRESULT hr;
    LPD3DHAL_GLOBALDRIVERDATA lpGlob;

    /*
     * Allocate and check validity of DirectDraw surfaces
     */

    lpDevI->lpDD = lpDD;
    lpDevI->lpDDGbl = ((LPDDRAWI_DIRECTDRAW_INT)lpDD)->lpLcl->lpGbl;
    lpDevI->lpDDSTarget = lpDDS;
    // For DX3 we do not keep references to Render target to avoid
    // circular references in the aggregation model. But for DX5 we
    // need to AddRef lpDDS. For DX6 we need to AddRef lpDDS4 which
    // is done later below
    if (lpDevI->dwVersion == 2) // DX5
        lpDDS->AddRef();

    // Get DDS4 Interfaces for RenderTarget/ZBuffer

    HRESULT ret = lpDDS->QueryInterface(IID_IDirectDrawSurface4, (LPVOID*)&lpDevI->lpDDSTarget_DDS4);

    if(FAILED(ret)) {
          D3D_ERR("QI for RenderTarget DDS4 Interface failed ");
          return ret;
    }
    // An implicit AddRef for lpDDSTarget_DDS4 in case of DX6
    if (lpDevI->dwVersion < 3) // DX3, DX5
        lpDevI->lpDDSTarget_DDS4->Release();

    if(lpZ!=NULL) {
        ret = lpZ->QueryInterface(IID_IDirectDrawSurface4, (LPVOID*)&lpDevI->lpDDSZBuffer_DDS4);

        if(FAILED(ret)) {
              D3D_ERR("QI for ZBuffer DDS4 Interface failed ");

              return ret;
        }
        lpDevI->lpDDSZBuffer_DDS4->Release();
    }

    LPD3DHAL_D3DEXTENDEDCAPS lpCaps = lpDevI->lpD3DExtendedCaps;
    if (NULL == lpCaps || 0.0f == lpCaps->dvExtentsAdjust)
    {
        lpDevI->dvExtentsAdjust = 1.0f;
    }
    else
    {
        lpDevI->dvExtentsAdjust = lpCaps->dvExtentsAdjust;
    }
    if (lpCaps != NULL)
        if (lpCaps->dvGuardBandLeft   != 0.0f ||
            lpCaps->dvGuardBandRight  != 0.0f ||
            lpCaps->dvGuardBandTop    != 0.0f ||
            lpCaps->dvGuardBandBottom != 0.0f)
        {
            lpDevI->dwDeviceFlags |= D3DDEV_GUARDBAND;
            DWORD v;
            if (GetD3DRegValue(REG_DWORD, "DisableGB", &v, 4) &&
                v != 0)
            {
                lpDevI->dwDeviceFlags &= ~D3DDEV_GUARDBAND;
            }
#if DBG
            // Try to get test values for the guard band
            char value[80];
            if (GetD3DRegValue(REG_SZ, "GuardBandLeft", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &lpCaps->dvGuardBandLeft);
            if (GetD3DRegValue(REG_SZ, "GuardBandRight", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &lpCaps->dvGuardBandRight);
            if (GetD3DRegValue(REG_SZ, "GuardBandTop", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &lpCaps->dvGuardBandTop);
            if (GetD3DRegValue(REG_SZ, "GuardBandBottom", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &lpCaps->dvGuardBandBottom);
#endif // DBG
        }

    if (lpDevI->dwVersion < 2)
        lpDevI->dwDeviceFlags |= D3DDEV_PREDX5DEVICE;

    if (lpDevI->dwVersion < 3)
        lpDevI->dwDeviceFlags |= D3DDEV_PREDX6DEVICE;

    if (!lpDevI->lpD3DHALCallbacks || ! lpDevI->lpD3DHALGlobalDriverData)
    {
D3D_ERR("CB NULL or GBD NULL %x %x",lpDevI->lpD3DHALGlobalDriverData,lpDevI->lpD3DHALCallbacks);
        return DDERR_INVALIDOBJECT;
    }

    // Helpful Note: for Device2 and Device3, lpDevI->guid is only guaranteed to be
    // the device type (HAL/RGB/etc) while init is happening.   At end of DX5/DX6 CreateDevice,
    // guid is reset to be IID_IDirect3DDevice2 or IID_IDirect3DDevice3, so don't try this sort
    // of device type determination outside of initialization.
    if (IsEqualIID((lpDevI->guid), IID_IDirect3DHALDevice))
    {
        lpDevI->dwFEFlags |=  D3DFE_REALHAL;

        // We do texture management (and hence clipped Blts) only for a real HAL.
        hr = lpDD->CreateClipper(0, &lpDevI->lpClipper, NULL);
        if(hr != DD_OK)
        {
            D3D_ERR("Failed to create a clipper");
            return hr;
        }
    }
    else
    {
        lpDevI->lpClipper = 0;
    }

    if (lpDevI->pfnRampService != NULL)
        lpDevI->dwDeviceFlags |=  D3DDEV_RAMP;

    lpGlob = lpDevI->lpD3DHALGlobalDriverData;

    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    if (lpZ)
    {
        if ((hr = lpZ->GetSurfaceDesc(&ddsd)) != DD_OK)
        {
            D3D_ERR("Failed to getsurfacedesc on z");
            return hr;
        }
        if (ddsd.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        {
            D3D_INFO(1, "Z buffer is in system memory.");
        }
        else if (ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        {
            D3D_INFO(1, "Z buffer is in video memory.");
        }
        else
        {
            D3D_ERR("Z buffer not in video or system?");
        }
    }
    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    if (lpDDS)
    {
        if ((hr = lpDDS->GetSurfaceDesc(&ddsd)) != DD_OK)
        {
            D3D_ERR("Failed to getsurfacedesc on back buffer");
            return hr;
        }
        if (ddsd.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        {
            D3D_INFO(1, "back buffer is in system memory.");
        }
        else if (ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        {
            D3D_INFO(1, "back buffer is in video memory.");
        }
        else
        {
            D3D_ERR("back buffer not in video or system?");
        }
        if (!(lpGlob->hwCaps.dwDeviceRenderBitDepth &
              BitDepthToDDBD(ddsd.ddpfPixelFormat.dwRGBBitCount)))
        {
            D3D_ERR("Rendering surface's RGB bit count not supported "
                    "by hardware device");
            return DDERR_INVALIDOBJECT;
        }
    }

    if (lpGlob->dwNumVertices &&
        (lpGlob->hwCaps.dwMaxVertexCount != lpGlob->dwNumVertices))
    {
        D3D_ERR("In global driver data, hwCaps.dwMaxVertexCount != "
                "dwNumVertices");
        lpGlob->hwCaps.dwMaxVertexCount = lpGlob->dwNumVertices;
    }
    if (lpGlob->dwNumVertices
        && lpGlob->dwNumClipVertices < D3DHAL_NUMCLIPVERTICES)
    {
        D3D_ERR("In global driver data, dwNumClipVertices "
                "< D3DHAL_NUMCLIPVERTICES");
        lpGlob->dwNumClipVertices = D3DHAL_NUMCLIPVERTICES;
    }

    if ((hr = CalcDDSurfInfo(lpDevI,TRUE)) != DD_OK)
    {
D3D_ERR("CalcDDSurfInfo failed");
        return hr;
    }

    RESET_HAL_CALLS(lpDevI);

    /*
     * Create our context in the HAL driver
     */
    if ((hr = halCreateContext(lpDevI)) != D3D_OK)
    {
D3D_ERR("halCreateContext failed");
        return hr;
    }

    STATESET_INIT(lpDevI->renderstate_overrides);

    if ((hr = D3DFE_InitTransform(lpDevI)) != D3D_OK)
    {
D3D_ERR("D3DFE_InitTransform failed");
        return hr;
    }
    if (hr = (D3DFE_InitRGBLighting(lpDevI)) != D3D_OK)
    {
D3D_ERR("D3DFE_InitRGBLighting failed");
        return hr;
    }

    lpDevI->dwFEFlags |= D3DFE_VALID;

    lpDevI->iClipStatus = D3DSTATUS_DEFAULT;
    lpDevI->rExtents.x1 = D3DVAL(2048);
    lpDevI->rExtents.x2 = D3DVAL(0);
    lpDevI->rExtents.y1 = D3DVAL(2048);
    lpDevI->rExtents.y2 = D3DVAL(0);

    return S_OK;
}

void D3DFE_Destroy(LPDIRECT3DDEVICEI lpDevI)
{
    if (lpDevI->dwFEFlags & D3DFE_VALID)
    {
        D3DFE_DestroyTransform(lpDevI);
        D3DFE_DestroyRGBLighting(lpDevI);
    }

    if(lpDevI->lpClipper)
    {
        lpDevI->lpClipper->Release();
    }

    if (lpDevI->lpD3DHALCallbacks) {
        halDestroyContext(lpDevI);
    }

#ifdef TRACK_HAL_CALLS
    D3D_INFO(0, "Made %d HAL calls", lpDevI->hal_calls);
#endif

    // If any picks were done the pick records need to be freed.
    // They are allocated in D3DHAL_AddPickRecord in halpick.c
    if (lpDevI->pick_data.records) {
        D3DFree(lpDevI->pick_data.records);
    }
}

void TriFillRectsTex(LPDIRECT3DDEVICEI lpDevI, DWORD count, LPD3DRECT rect,D3DTEXTUREHANDLE hTex)
{
    LPDIRECT3DDEVICE3 lpD3DDev = static_cast<LPDIRECT3DDEVICE3>(lpDevI);
    LPD3DVIEWPORT2 lpCurrentView = &((LPDIRECT3DVIEWPORTI)(lpDevI->lpCurrentViewport))->v_data;

    DWORD i;
    float width =   (float)lpCurrentView->dwWidth;
    float height =  (float)lpCurrentView->dwHeight;
    // ~.5 offset makes the result stable for even scales which are common.
    // since this offset is not scaled by texture size, need to make it a bit smaller
    float x =       (float)lpCurrentView->dwX - .41f;
    float y =       (float)lpCurrentView->dwY - .41f;

    DWORD dwZEnable;
    DWORD dwStencilEnable;
    DWORD dwZWriteEnable;
    DWORD dwZFunc;
    DWORD dwWrapU;
    DWORD dwWrapV;
    DWORD dwFillMode;
    DWORD dwFogEnable;
    DWORD dwFogMode;
    DWORD dwBlendEnable;
    DWORD dwColorKeyEnable;
    DWORD dwAlphaBlendEnable;
    DWORD dwTexture;
    DWORD dwTexturePers;
    DWORD dwDither;
    DWORD pdwWrap[D3DDP_MAXTEXCOORD];
    D3DTLVERTEX v[4];
    BOOL bWasInScene = FALSE;
    D3DMATERIALHANDLE hMat;

    if (!(lpDevI->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE))
    {
        lpDevI->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_INTERNAL_BEGIN_END;
        bWasInScene = TRUE;
        lpD3DDev->BeginScene();
    }

    // save current renderstate we need to reset to draw textured rect

    lpD3DDev->GetRenderState(D3DRENDERSTATE_ZENABLE, &dwZEnable);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_ZWRITEENABLE, &dwZWriteEnable);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_ZFUNC, &dwZFunc);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_WRAPU, &dwWrapU);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_WRAPV, &dwWrapV);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_FILLMODE, &dwFillMode);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_FOGENABLE, &dwFogEnable);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_FOGTABLEMODE, &dwFogMode);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_BLENDENABLE, &dwBlendEnable);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_COLORKEYENABLE, &dwColorKeyEnable);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, &dwAlphaBlendEnable);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_TEXTUREHANDLE, &dwTexture);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_STENCILENABLE, &dwStencilEnable);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, &dwTexturePers);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_DITHERENABLE, &dwDither);

    // Save WRAPi
    for (i = 0; i < D3DDP_MAXTEXCOORD; i++)
    {
        lpD3DDev->GetRenderState((D3DRENDERSTATETYPE)(D3DRENDERSTATE_WRAP0 + i),
                                 pdwWrap + i);
    }

    lpD3DDev->SetRenderState(D3DRENDERSTATE_ZENABLE, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_ZWRITEENABLE, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_ZFUNC, D3DCMP_ALWAYS);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_WRAPU, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_WRAPV, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_FILLMODE, D3DFILL_SOLID);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_FOGTABLEMODE, D3DFOG_NONE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_FOGENABLE, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_BLENDENABLE, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_COLORKEYENABLE, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_TEXTUREHANDLE, hTex);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_STENCILENABLE, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_DITHERENABLE, FALSE);

    // Disable WRAPi
    for (i = 0; i < D3DDP_MAXTEXCOORD; i++)
    {
        lpD3DDev->SetRenderState((D3DRENDERSTATETYPE)(D3DRENDERSTATE_WRAP0 + i),
                                 0);
    }

    BOOL bRampServiceClear = FALSE;

    if(lpDevI->pfnRampService!=NULL) {
        lpD3DDev->GetLightState(D3DLIGHTSTATE_MATERIAL, &hMat);
        lpD3DDev->SetLightState(D3DLIGHTSTATE_MATERIAL,
                            lpDevI->lpCurrentViewport->hBackgndMat);
        PD3DI_SPANTEX pTex = *(PD3DI_SPANTEX *)ULongToPtr(hTex);
        if (pTex->Format == D3DI_SPTFMT_PALETTE8)
        {
            // if it is Ramp, and if the texture is PALETTE8,
            // then we should use the new service that handles
            // non-power of 2 textures
            bRampServiceClear = TRUE;
        }
    }

    if (bRampServiceClear)
    {
        for (i = 0; i < count; i++, rect++) {
            CallRampService(lpDevI, RAMP_SERVICE_CLEAR_TEX_RECT,
                            lpDevI->lpCurrentViewport->hBackgndMat,rect);
        }
    }
    else
    {
        for (i = 0; i < count; i++, rect++) {
          D3DVALUE tu1, tv1, tu2, tv2;

            tu1 = ((D3DVALUE)(rect->x1 - x))/width;
            tv1 = ((D3DVALUE)(rect->y1 - y))/height;
            tu2 = ((D3DVALUE)(rect->x2 - x))/width;
            tv2 = ((D3DVALUE)(rect->y2 - y))/height;

            v[0].sx =   (D3DVALUE) rect->x1;
            v[0].sy =   (D3DVALUE) rect->y1;
            v[0].sz =   (D3DVALUE) 0;
            v[0].rhw =  (D3DVALUE) 1;
            v[0].color =    (D3DCOLOR) ~0UL;
            v[0].specular = (D3DCOLOR) 0;
            v[0].tu = tu1;
            v[0].tv = tv1;

            v[1].sx =   (D3DVALUE) rect->x2;
            v[1].sy =   (D3DVALUE) rect->y1;
            v[1].sz =   (D3DVALUE) 0;
            v[1].rhw =  (D3DVALUE) 1;
            v[1].color =    (D3DCOLOR) ~0UL;
            v[1].specular = (D3DCOLOR) 0;
            v[1].tu = tu2;
            v[1].tv = tv1;

            v[2].sx =   (D3DVALUE) rect->x2;
            v[2].sy =   (D3DVALUE) rect->y2;
            v[2].sz =   (D3DVALUE) 0;
            v[2].rhw =  (D3DVALUE) 1;
            v[2].color =    (D3DCOLOR) ~0UL;
            v[2].specular = (D3DCOLOR) 0;
            v[2].tu = tu2;
            v[2].tv = tv2;

            v[3].sx =   (D3DVALUE) rect->x1;
            v[3].sy =   (D3DVALUE) rect->y2;
            v[3].sz =   (D3DVALUE) 0;
            v[3].rhw =  (D3DVALUE) 1;
            v[3].color =    (D3DCOLOR) ~0UL;
            v[3].specular = (D3DCOLOR) 0;
            v[3].tu = tu1;
            v[3].tv = tv2;

            lpD3DDev->DrawPrimitive(D3DPT_TRIANGLEFAN,
                                    D3DFVF_TLVERTEX, v, 4,
                                    D3DDP_WAIT | D3DDP_DONOTCLIP);
        }
    }

    // restore saved renderstate
    lpD3DDev->SetRenderState(D3DRENDERSTATE_ZENABLE, dwZEnable);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_ZWRITEENABLE, dwZWriteEnable);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_ZFUNC, dwZFunc);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_WRAPU, dwWrapU);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_WRAPV, dwWrapV);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_FILLMODE, dwFillMode);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_FOGENABLE, dwFogEnable);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_FOGTABLEMODE, dwFogMode);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_BLENDENABLE, dwBlendEnable);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_COLORKEYENABLE, dwColorKeyEnable);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, dwAlphaBlendEnable);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_TEXTUREHANDLE, dwTexture);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_STENCILENABLE, dwStencilEnable);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, dwTexturePers);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_DITHERENABLE, dwDither);

    // Restore WRAPi
    for (i = 0; i < D3DDP_MAXTEXCOORD; i++)
    {
        lpD3DDev->SetRenderState((D3DRENDERSTATETYPE)(D3DRENDERSTATE_WRAP0 + i),
                                 pdwWrap[i]);
    }
    if(lpDevI->pfnRampService!=NULL) {
        lpD3DDev->SetLightState(D3DLIGHTSTATE_MATERIAL, hMat);
    }

    if (bWasInScene)
    {
        lpD3DDev->EndScene();
        lpDevI->dwHintFlags &= ~D3DDEVBOOL_HINTFLAGS_INTERNAL_BEGIN_END;
    }
}


void BltFillRects(LPDIRECT3DDEVICEI lpDevI, DWORD count, LPD3DRECT rect, D3DCOLORVALUE *pFillColor)
{
    LPDIRECTDRAWSURFACE lpDDS = lpDevI->lpDDSTarget;
    HRESULT ddrval;
    DDBLTFX bltfx;
    RECT tr;
    DWORD i;
    DWORD r, g, b;

    // Fill with background color

    memset(&bltfx, 0, sizeof(bltfx));
    bltfx.dwSize = sizeof(bltfx);

// unlike clear callback, which just takes pure 32-bit ARGB word and forces the driver to scale it for
// the pixelformat, here we need to compute the exact fill word, depending on surface's R,G,B bitmasks

    if(lpDevI->pfnRampService!=NULL) {
      // DX5 allowed the background material to be NULL.  For this case, will clear to index 0
      // which is usually black in ramp mode

      if(lpDevI->lpCurrentViewport->hBackgndMat!=0) {
          CallRampService(lpDevI, RAMP_SERVICE_MATERIAL_TO_PIXEL,lpDevI->lpCurrentViewport->hBackgndMat,&bltfx.dwFillColor);
      } else {
          bltfx.dwFillColor=0;   // index 0 is usually black in ramp mode.
      }
    } else {

     if(lpDevI->bDDSTargetIsPalettized) {
         // map 24-bit color to 8-bit index used by 8bit RGB rasterizer
         CallRastService(lpDevI, RAST_SERVICE_RGB8COLORTOPIXEL, CVAL_TO_RGBA(*pFillColor), &bltfx.dwFillColor);
     } else {

        if((lpDevI->red_scale == 0) || (lpDevI->green_scale == 0) ||
           (lpDevI->blue_scale == 0))
        {
            DPF(1, "(ERROR) BltFillRects Failed one of the scales is zero" );
            return;
        }

        r = (DWORD)(255.0 * pFillColor->r) / lpDevI->red_scale;
        g = (DWORD)(255.0 * pFillColor->g) / lpDevI->green_scale;
        b = (DWORD)(255.0 * pFillColor->b) / lpDevI->blue_scale;
        bltfx.dwFillColor = (r << lpDevI->red_shift) | (g << lpDevI->green_shift) | (b << lpDevI->blue_shift);
     }
    }

    for (i = 0; i < count; i++,rect++) {
        tr.left = rect->x1;
        tr.right = rect->x2;
        tr.top = rect->y1;
        tr.bottom = rect->y2;
        do {
            ddrval = lpDDS->Blt(&tr, NULL, NULL, DDBLT_COLORFILL, &bltfx);
        } while (ddrval == DDERR_WASSTILLDRAWING);
    }
}

void BltFillZRects(LPDIRECT3DDEVICEI lpDevI, unsigned long Zpixel,
                    DWORD count, LPD3DRECT rect, DWORD dwWriteMask)
{
    HRESULT ddrval;
    DDBLTFX bltfx;
    DWORD i;
    RECT tr;
    DWORD dwExtraFlags=0;

#if DBG
    if (lpDevI->lpDDSZBuffer == NULL)  // should be checked prior to call
        return;
#endif

    memset(&bltfx, 0, sizeof(DDBLTFX));
    bltfx.dwSize = sizeof(DDBLTFX);
    bltfx.dwFillDepth = Zpixel;

    // hack to pass DepthBlt WriteMask through ddraw/ddhel to blitlib
    if(dwWriteMask!=0) {
        bltfx.dwZDestConstBitDepth=dwWriteMask;
        dwExtraFlags = DDBLT_DEPTHFILLWRITEMASK;
    }

    for(i=0;i<count;i++,rect++) {
        D3D_INFO(4, "Z Clearing x1 = %d, y1 = %d, x2 = %d, y2 = %d, WriteMask %X", rect->x1, rect->y1, rect->x2, rect->y2, bltfx.dwReserved);
        tr.left = rect->x1;
        tr.right = rect->x2;
        tr.top = rect->y1;
        tr.bottom = rect->y2;
        do {
            ddrval = lpDevI->lpDDSZBuffer->Blt(&tr, NULL, NULL, DDBLT_DEPTHFILL | dwExtraFlags, &bltfx);
        } while (ddrval == DDERR_WASSTILLDRAWING);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DFE_Clear"

HRESULT D3DFE_Clear(LPDIRECT3DDEVICEI lpDevI, DWORD dwFlags,
                     DWORD numRect, LPD3DRECT lpRect,
                     D3DCOLORVALUE *pFillColor,
                     D3DTEXTUREHANDLE dwTexture)
{
    HRESULT ret;
    BOOL bDoRGBClear,bDoZClear,bDoHALRGBClear,bDoHALZClear;
    D3DHAL_CLEARDATA ClearData;
    LPDIRECTDRAWSURFACE lpDDSBackDepth;

    // Flush any outstanding geometry to put framebuffer/Zbuffer in a known state for Clears that
    // don't use tris (i.e. HAL Clears and Blts).  Note this doesn't work for tiled architectures
    // outside of Begin/EndScene, this will be fixed later

    ret = lpDevI->FlushStates();
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to render batched commands in D3DFE_Clear");
        return ret;
    }

    ClearData.ddrval=D3D_OK;

    bDoRGBClear=((dwFlags & D3DCLEAR_TARGET)!=0);  // must convert to pure bool so bDoHALRGBClear==bDoRGBClear works
    bDoZClear=((dwFlags & D3DCLEAR_ZBUFFER)!=0);

    lpDDSBackDepth=((LPDIRECT3DVIEWPORTI)(lpDevI->lpCurrentViewport))->lpDDSBackgndDepth;

   // note: textured clears and clears to background depth buffer must be handled explicitly
   // using Blt calls and not be passed to driver

    bDoHALRGBClear = bDoRGBClear && (dwTexture==0)  && (lpDevI->lpD3DHALCallbacks2->Clear!=NULL);
    bDoHALZClear = bDoZClear && (lpDDSBackDepth==NULL) && (lpDevI->lpD3DHALCallbacks2->Clear!=NULL);

    if(bDoHALRGBClear || bDoHALZClear) {
            ClearData.dwhContext = lpDevI->dwhContext;
            ClearData.dwFillColor = ClearData.dwFillDepth = 0;
            ClearData.dwFlags = 0x0;

            if(bDoHALRGBClear) {
                // original Clear DDI Spec had dwFillColor being dependent on the surface RGB bit depths
                // like the COLORFILL Blt in SetRectangles.  But the dx5 implementation always passed a
                // 32-bit ARGB to the driver for all surface depths.  So that's the way it stays.
                ClearData.dwFillColor =  CVAL_TO_RGBA(*pFillColor);
                ClearData.dwFlags = D3DCLEAR_TARGET;
            }

            if(bDoHALZClear) {
                // must clear to 0xffffffff because legacy drivers expect this
                // should be using (1<<lpDevI->lpDDSZBuffer->ddpfSurface.dwZBufferBitDepth)-1;
                ClearData.dwFillDepth = 0xffffffff;
                ClearData.dwFlags |= D3DCLEAR_ZBUFFER;
            }

            ClearData.lpRects = lpRect;
            ClearData.dwNumRects = numRect;
#ifndef WIN95
            if((ret = CheckContextSurface(lpDevI)) != D3D_OK)
                return ret;
#endif
            CALL_HAL2ONLY(ret, lpDevI, Clear, &ClearData);
            if (ret != DDHAL_DRIVER_HANDLED)
                return DDERR_UNSUPPORTED;

            // if all requested clears were done by HAL, can return now
            if((bDoRGBClear==bDoHALRGBClear) && (bDoZClear==bDoHALZClear))
              return ClearData.ddrval;
    }

    if((lpDevI->lpD3DHALCallbacks3->Clear2!=NULL) && (lpDevI->lpD3DHALCallbacks2->Clear==NULL)) {
      DWORD dwFlagsLeft=dwFlags;
      DWORD dwClear2Flags=0x0;

      // driver implemented Clear2 callback but not Clear
      // call Clear2 for as many items as we can, and leave the rest for SW

      if(bDoRGBClear && (dwTexture==0)) {
          dwClear2Flags |= D3DCLEAR_TARGET;
          dwFlagsLeft &= ~D3DCLEAR_TARGET;
          bDoRGBClear=FALSE;
      }

      if(bDoZClear && (lpDDSBackDepth==NULL)) {
          dwClear2Flags |= D3DCLEAR_ZBUFFER;
          dwFlagsLeft &= ~D3DCLEAR_ZBUFFER;
          bDoZClear=FALSE;
      }

      if(dwClear2Flags!=0x0) {
         ClearData.ddrval = D3DFE_Clear2(lpDevI,dwClear2Flags,numRect,lpRect,CVAL_TO_RGBA(*pFillColor),1.0,0);
      }

      if(dwFlagsLeft==0x0)
         return ClearData.ddrval;

      dwFlags=dwFlagsLeft;
    }

    // otherwise do clears using SW, since no HW method exists or using textured background for RGBclear
    // or background depth buffer for Zclear

    // clear RGB using Blt
    if (bDoRGBClear && (!bDoHALRGBClear)) {
        if(dwTexture == 0)
            BltFillRects(lpDevI, numRect, lpRect, pFillColor);
         else TriFillRectsTex(lpDevI, numRect, lpRect, dwTexture);
    }

    // clear Z using Blt
    if (bDoZClear && (!bDoHALZClear)) {
        if (lpDDSBackDepth!=NULL) {
            RECT src, dest;
            DDSURFACEDESC ddsd;
            HRESULT ret;

            D3D_INFO(2, "Z Clearing using depth background");
            ddsd.dwSize = sizeof ddsd;
            ddsd.dwFlags = 0;
            if (ret = lpDDSBackDepth->GetSurfaceDesc(&ddsd)) {
                D3D_ERR("GetSurfaceDesc failed trying to clear to depth background");
                return ret;
            }
            D3D_INFO(3, "Depth background width=%d, height=%d", ddsd.dwWidth, ddsd.dwHeight);

            SetRect(&src, 0, 0, ddsd.dwWidth, ddsd.dwHeight);

            LPD3DVIEWPORT2 lpCurrentView = &((LPDIRECT3DVIEWPORTI)(lpDevI->lpCurrentViewport))->v_data;

            SetRect(&dest,
                    lpCurrentView->dwX,
                    lpCurrentView->dwY,
                    lpCurrentView->dwX + lpCurrentView->dwWidth,
                    lpCurrentView->dwY + lpCurrentView->dwHeight );

            // copy from background depth buffer to zbuffer
            if (ret = lpDevI->lpDDSZBuffer->Blt(
                &dest, lpDDSBackDepth, &src, DDBLT_WAIT, NULL)) {
                    D3D_ERR("Blt failed clearing depth background");
                    return ret;
            }
        } else {

            // Clear to maximum Z value.  Presence of stencil buffer ignored, depthfill blt
            // can overwrite any existing stencil bits with 1's.  Clear2 should be used to
            // clear z while preserving stencil buffer

            BltFillZRects(lpDevI, 0xffffffff, numRect, lpRect, 0x0);
        }
    }

    if(ClearData.ddrval!=D3D_OK)
      return ClearData.ddrval;
    else
    {
        return CallRampService(lpDevI, RAMP_SERVICE_CLEAR, 0, 0);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DFE_Clear2"

HRESULT D3DFE_Clear2(LPDIRECT3DDEVICEI lpDevI, DWORD dwFlags,
                     DWORD numRect, LPD3DRECT lpRect,
                     D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil) {
    DWORD dwDepthClearVal,dwStencilClearVal;
    HRESULT ret;
    BOOL bDoRGBClear,bDoZClear,bDoStencilClear;
    BOOL bIsStencilSurface = FALSE;
    D3DHAL_CLEAR2DATA Clear2Data;
    DDPIXELFORMAT *pZPixFmt;
    D3DCOLORVALUE vFillColor;

    DDASSERT(lpDevI->pfnRampService==NULL);  // Device3 ramp not allowed, so dont have to handle this case

    // Flush any outstanding geometry to put framebuffer/Zbuffer in a known state for Clears that
    // don't use tris (i.e. HAL Clears and Blts).  Note this doesn't work for tiled architectures
    // outside of Begin/EndScene, this will be fixed later

    ret = lpDevI->FlushStates();
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to render batched commands in D3DFE_Clear2");
        return ret;
    }

    bDoRGBClear=((dwFlags & D3DCLEAR_TARGET)!=0);
    bDoZClear=((dwFlags & D3DCLEAR_ZBUFFER)!=0);              //make these true boolean so XOR below works
    bDoStencilClear=((dwFlags & D3DCLEAR_STENCIL)!=0);

    if (lpDevI->lpD3DHALCallbacks3->Clear2)
    {
        // Clear2 HAL Callback exists

         Clear2Data.dwhContext = lpDevI->dwhContext;
         Clear2Data.lpRects = lpRect;
         Clear2Data.dwNumRects = numRect;
         Clear2Data.dwFillColor = Clear2Data.dwFillStencil = 0;
         Clear2Data.dvFillDepth = 0.0f;
         Clear2Data.dwFlags = dwFlags;

         if(bDoRGBClear) {
             // Here I will follow the ClearData.dwFillColor convention that
             // color word is raw 32bit ARGB, unadjusted for surface bit depth
             Clear2Data.dwFillColor =  dwColor;
         }

         // depth/stencil values both passed straight from user args
         if(bDoZClear)
            Clear2Data.dvFillDepth = dvZ;
         if(bDoStencilClear)
            Clear2Data.dwFillStencil = dwStencil;

    #ifndef WIN95
         if((ret = CheckContextSurface(lpDevI)) != D3D_OK)
             return ret;
    #endif
         CALL_HAL3ONLY(ret, lpDevI, Clear2, &Clear2Data);
         if (ret != DDHAL_DRIVER_HANDLED)
             return DDERR_UNSUPPORTED;
         return Clear2Data.ddrval;
    }

    if(bDoRGBClear) {
      const float fScalor=(float)(1.0/255.0);

       vFillColor.a =  RGBA_GETALPHA(dwColor)*fScalor;
       vFillColor.r =  RGBA_GETRED(dwColor)*fScalor;
       vFillColor.g =  RGBA_GETGREEN(dwColor)*fScalor;
       vFillColor.b =  RGBA_GETBLUE(dwColor)*fScalor;
    }

    if((bDoZClear || bDoStencilClear) && (lpDevI->lpDDSZBuffer!=NULL)) {    //PowerVR need no Zbuffer
        pZPixFmt=&((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSZBuffer)->lpLcl->lpGbl->ddpfSurface;

        // if surface has stencil bits, must verify either Clear2 callback exists or
        // we're using SW rasterizers (which require the special WriteMask DDHEL blt)

        bIsStencilSurface=(pZPixFmt->dwFlags & DDPF_STENCILBUFFER);

    }

    if(bDoZClear || bDoStencilClear) {
        // if Clear2 callback doesnt exist and it's a z-only surface and not doing zclear to
        // non-max value then Clear2 is attempting to do no more than Clear could do, so it's
        // safe to call Clear() instead of Clear2(), which will take advantage of older
        // drivers that implement Clear but not Clear2

        if((!bIsStencilSurface) && (!(bDoZClear && (dvZ!=1.0)))) {
            return D3DFE_Clear(lpDevI,dwFlags,numRect,lpRect,&vFillColor,0);
        }

        if(bIsStencilSurface) {
            DDSCAPS *pDDSCaps;

            pDDSCaps=&((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSZBuffer)->lpLcl->ddsCaps;

            // This case should not be hit since we check right at the
            // driver initialization time if the driver doesnt report Clear2
            // yet it supports stencils
            if(!(pDDSCaps->dwCaps & DDSCAPS_SYSTEMMEMORY)) {
                D3D_ERR("Driver HAL doesn't provide Clear2 callback, cannot use Clear2 with HW stencil surfaces");
                return DDERR_INVALIDPIXELFORMAT;
            }
        }
    } else {
        // we're just clearing RGB, so since Clear2 callback doesn't exist, try calling Clear
        return D3DFE_Clear(lpDevI,dwFlags,numRect,lpRect,&vFillColor,0);
    }


    dwDepthClearVal=dwStencilClearVal=0;

    if(bDoZClear) {
         LPDDPIXELFORMAT pPixFmt=&((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSZBuffer)->lpLcl->lpGbl->ddpfSurface;

         DDASSERT(pPixFmt->dwZBufferBitDepth<=32);

         if((dvZ!=1.0)&&(lpDevI->lpD3DHALCallbacks3->Clear2==NULL)&&(pPixFmt->dwZBitMask==0x0)) {
             // I have no way to emulate ZClears to non-maxZ values without a ZBitMask, so must fail call
             D3D_ERR("cant ZClear to non-maxz value without Clear2 HAL callback or valid ZBuffer pixfmt ZBitMask");
             return DDERR_INVALIDPIXELFORMAT;
         }

         // special case the common cases
         if(dvZ==1.0) {
             dwDepthClearVal=pPixFmt->dwZBitMask;
         } else if(dvZ==0.0) {
             dwDepthClearVal=0;
         } else {
             dwDepthClearVal=((DWORD)((dvZ*(pPixFmt->dwZBitMask >> lpDevI->zmask_shift))+0.5)) << lpDevI->zmask_shift;
         }
    }

    if(bDoStencilClear) {
         LPDDPIXELFORMAT pPixFmt=&((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSZBuffer)->lpLcl->lpGbl->ddpfSurface;

         DDASSERT(pPixFmt->dwStencilBitDepth<32);
         DDASSERT(pPixFmt->dwStencilBitMask!=0x0);

         // special case the common case
         if(dwStencil==0) {
             dwStencilClearVal=0;
         } else {
             dwStencilClearVal=(dwStencil & ((1<<pPixFmt->dwStencilBitDepth)-1))
                                << lpDevI->stencilmask_shift;
         }
    }

    // Fall back to Emulation using Blt

    if(bDoRGBClear) {
        BltFillRects(lpDevI, numRect, lpRect, &vFillColor);     //ok to not return possible errors from Blt?
    }

    if(bDoZClear||bDoStencilClear) {
       if((bDoZClear!=bDoStencilClear) && bIsStencilSurface) {
          // have to worry about using writemask to screen out writing the stencil or z buffer

          if(bDoZClear) {
                // WriteMask enabled Z bits only
                DDASSERT(pZPixFmt->dwZBitMask!=0x0);
                BltFillZRects(lpDevI,dwDepthClearVal, numRect, lpRect, pZPixFmt->dwZBitMask);
          } else {
              DDASSERT(pZPixFmt->dwStencilBitMask!=0x0);
              BltFillZRects(lpDevI,dwStencilClearVal, numRect, lpRect, pZPixFmt->dwStencilBitMask);
          }
       } else {
            // do Stencil & Z Blt together, using regular DepthFill blt which will be faster
            // than the writemask blt because its write-only, instead of read-modify-write

            // Note we're passing non-0xffffffff values to DepthFill Blt here
            // not absolutely guaranteed to work on legacy drivers

            BltFillZRects(lpDevI,(dwDepthClearVal | dwStencilClearVal), numRect, lpRect, 0x0);
       }
    }

    return D3D_OK;
}
#undef DPF_MODNAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\halstate.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   halstate.c
 *  Content:    Direct3D HAL pipeline state management
 *@@BEGIN_MSINTERNAL
 * 
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   18/12/95   stevela Initial rev.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

HRESULT 
D3DHAL_GetState(LPDIRECT3DDEVICEI lpDevI, DWORD dwWhich, LPD3DSTATE lpState)
{
    LPD3DHAL_GLOBALDRIVERDATA gdd = lpDevI->lpD3DHALGlobalDriverData;
    D3DHAL_GETSTATEDATA data;
    HRESULT ret;

    D3D_INFO(6, "GetState, getting state dwhContext = %d", lpDevI->dwhContext);

    memset(&data, 0, sizeof(D3DHAL_GETSTATEDATA));
    data.dwhContext = lpDevI->dwhContext;
    data.dwWhich = dwWhich;
    data.ddState = *lpState;

    if (dwWhich == D3DHALSTATE_GET_RENDER ||
        (dwWhich == D3DHALSTATE_GET_TRANSFORM
         && (gdd->hwCaps.dwFlags & D3DDD_TRANSFORMCAPS)) ||
        (dwWhich == D3DHALSTATE_GET_LIGHT
         && (gdd->hwCaps.dwFlags & D3DDD_LIGHTINGCAPS))) 
    {
        CALL_HALONLY(ret, lpDevI, GetState, &data);
        if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) 
        {
            D3D_ERR("HAL failed to handle GetState");
            return (DDERR_GENERIC);
        }
    } 
    else 
    {
        switch (data.dwWhich) 
        {
        case D3DHALSTATE_GET_RENDER:
            D3D_ERR("HEL called for D3DHALSTATE_GET_RENDER");
            return (DDERR_INVALIDPARAMS);

        case D3DHALSTATE_GET_TRANSFORM:
            D3D_INFO(3, "GetState called for transform");
            switch (data.ddState.dtstTransformStateType) 
            {
            case D3DTRANSFORMSTATE_WORLD:
                data.ddState.dwArg[0] = lpDevI->transform.hWorld;
                break;
            case D3DTRANSFORMSTATE_VIEW:
                data.ddState.dwArg[0] = lpDevI->transform.hView;
                break;
            case D3DTRANSFORMSTATE_PROJECTION:
                data.ddState.dwArg[0] = lpDevI->transform.hProj;
                break;
            default:
                D3D_ERR("Unknown GetState found");
                return (DDERR_GENERIC);
            }
            break;
        case D3DHALSTATE_GET_LIGHT:
            D3D_INFO(3, "GetState called for lighting");
            switch (data.ddState.dlstLightStateType) 
            {
            case D3DLIGHTSTATE_MATERIAL:
                data.ddState.dwArg[0] = lpDevI->lighting.hMat;
                break;
            case D3DLIGHTSTATE_AMBIENT:
                data.ddState.dwArg[0] = 
                    RGB_MAKE((int)lpDevI->lighting.ambient_red, 
                             (int)lpDevI->lighting.ambient_green, 
                             (int)lpDevI->lighting.ambient_blue);
                break;
            case D3DLIGHTSTATE_COLORMODEL:
#pragma message("XXX - D3DLIGHTSTATE_COLORMODEL in HEL GetState not implemented.")
                break;
            default:
                D3D_ERR("Unknown GetState found");
                return (DDERR_GENERIC);
            }
        default:
            D3D_ERR("Unknown GetState found");
            return (DDERR_GENERIC);
        }
    }

    *lpState = data.ddState;
    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\haltex.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   haltex.c
 *  Content:    Direct3D HAL texture handling
 *@@BEGIN_MSINTERNAL
 *
 *  $Id: haltex.c,v 1.1 1995/11/21 15:12:43 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   07/11/95   stevela Initial rev.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Texture functionality is not emulated.
 */

HRESULT D3DHAL_TextureCreate(LPDIRECT3DDEVICEI lpDevI,
                             LPD3DTEXTUREHANDLE lphTex,
                             LPDIRECTDRAWSURFACE lpDDS)
{
    if (IS_DX7HAL_DEVICE(lpDevI))
    {
        *lphTex = 
            ((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl->lpSurfMore->dwSurfaceHandle;    
    }
    else
    {
        D3DHAL_TEXTURECREATEDATA data;
        HRESULT ret;

        if (!lpDevI->lpD3DHALCallbacks->TextureCreate) {
            D3D_ERR("TextureCreate called, but no texture support.");
            return (D3DERR_TEXTURE_NO_SUPPORT);
        }

        memset(&data, 0, sizeof(D3DHAL_TEXTURECREATEDATA));
        data.dwhContext = lpDevI->dwhContext;
        data.lpDDS = lpDDS;

        D3D_INFO(6, "TextureCreate, creating texture dwhContext = %08lx, lpDDS = %08lx",
            data.dwhContext, data.lpDDS);

        CALL_HALONLY(ret, lpDevI, TextureCreate, &data);
        if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
            D3D_ERR("HAL failed to handle TextureCreate");
            return (D3DERR_TEXTURE_CREATE_FAILED);
        }
        *lphTex = data.dwHandle;
    }

    D3D_INFO(6, "TextureCreate, created texture hTex = %08lx", *lphTex);
    return (D3D_OK);
}

HRESULT D3DHAL_TextureDestroy(LPD3DI_TEXTUREBLOCK lpBlock)
{
    LPDIRECT3DDEVICEI lpDevI=lpBlock->lpDevI;
    D3DTEXTUREHANDLE  hTex=lpBlock->hTex;
    D3DHAL_TEXTUREDESTROYDATA data;
    HRESULT ret;
    lpBlock->hTex=0;
    if (!IS_DX7HAL_DEVICE(lpDevI))
    {
        // on winnt we alway use the surfacehandle, so there is no need calling driver
        if (!lpDevI->lpD3DHALCallbacks->TextureDestroy) {
            D3D_ERR("TextureDestroy called, but no texture support.");
            return (D3DERR_TEXTURE_NO_SUPPORT);
        }
    }
    // The following code ensures that before we ask the driver to unmap
    // the texture, we set the stages to NULL if the texture is still present
    // in any stage. This is probably not necessary, but we are just trying
    // to be extra cautious here. The CAVEAT here is that it is possible that
    // D3DHAL_TextureDestroy() is being called from DestroyDevice() and hence
    // IT COULD BE REALLY BAD TO BATCH additional commands to the device at
    // this stage. (snene - 3/2/98)
    BOOL bNeedFlush = FALSE;
    if (IS_DP2HAL_DEVICE(lpDevI)) {
        int dwStage;
        CDirect3DDeviceIDP2 *dp2dev = static_cast<CDirect3DDeviceIDP2 *>(lpDevI);

        // Find out the first stage with hTex and NULL out
        for (dwStage=0;dwStage<(int)lpDevI->dwMaxTextureBlendStages; dwStage++)
        {
            if (hTex == lpDevI->tsstates[dwStage][D3DTSS_TEXTUREMAP])
            {
                dp2dev->SetTSSI(dwStage, (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP, 0);
                bNeedFlush = TRUE;
            }
        }
    }
    DWORD txh;
    if(lpDevI->GetRenderState(D3DRENDERSTATE_TEXTUREHANDLE, &txh) != D3D_OK)
    {
        D3D_WARN(0, "Error getting texture handle in D3DHAL_TextureDestroy");
    }
    else
    {
        if (txh == hTex)
        {
            lpDevI->rstates[D3DRENDERSTATE_TEXTUREHANDLE] = 0;
            lpDevI->SetRenderStateI(D3DRENDERSTATE_TEXTUREHANDLE, 0);
            bNeedFlush = TRUE;
        }
    }

    // Make sure that we send down the command immediately to guarantee
    // that the driver gets it before we call it with Destroy
    if(bNeedFlush)
    {
        if(lpDevI->FlushStates() != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in D3DHAL_TextureDestroy");
        }
    }
    else // Now we decide whether to flush due to a referenced texture in the batch or not
    {
        LPD3DBUCKET list;
        if(lpBlock->lpD3DTextureI->lpDDS != NULL)
        {
            list = reinterpret_cast<LPD3DBUCKET>(((LPDDRAWI_DDRAWSURFACE_INT)(lpBlock->lpD3DTextureI->lpDDS))->lpLcl->lpSurfMore->lpD3DDevIList);
        }
        else
        {
            list = reinterpret_cast<LPD3DBUCKET>(((LPDDRAWI_DDRAWSURFACE_INT)(lpBlock->lpD3DTextureI->lpDDSSys))->lpLcl->lpSurfMore->lpD3DDevIList);
        }
        while(list != NULL)
        {
            if(list->lpD3DDevI == lpDevI)
            {
                if(lpDevI->FlushStates() != D3D_OK)
                {
                    D3D_ERR("Error trying to render batched commands in D3DHAL_TextureDestroy");
                }
                break;
            }
            list = list->next;
        }
    }
    if (!IS_DX7HAL_DEVICE(lpDevI))
    {
        memset(&data, 0, sizeof(D3DHAL_TEXTUREDESTROYDATA));
        data.dwhContext = lpDevI->dwhContext;
        data.dwHandle = hTex;

        D3D_INFO(6, "TextureDestroy, destroying texture dwhContext = %08lx, hTex = %08lx",
            data.dwhContext, hTex);

        CALL_HALONLY(ret, lpDevI, TextureDestroy, &data);
        if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
            D3D_ERR("HAL failed to handle TextureDestroy");
            return (D3DERR_TEXTURE_DESTROY_FAILED);
        }
    }
    D3D_INFO(6, "TextureDestroy, destroyed texture hTex = %08lx", hTex);
    return (D3D_OK);
}

HRESULT D3DHAL_TextureSwap(LPDIRECT3DDEVICEI lpDevI,
                           D3DTEXTUREHANDLE hTex1,
                           D3DTEXTUREHANDLE hTex2)
{
    D3DHAL_TEXTURESWAPDATA data;
    HRESULT ret;

    if (!lpDevI->lpD3DHALCallbacks->TextureSwap) {
        D3D_ERR("TextureSwapcalled, but no texture support.");
        return (D3DERR_TEXTURE_NO_SUPPORT);
    }

    memset(&data, 0, sizeof(D3DHAL_TEXTURESWAPDATA));
    data.dwhContext = lpDevI->dwhContext;
    data.dwHandle1 = hTex1;
    data.dwHandle2 = hTex2;
    data.ddrval = D3D_OK; 
    D3D_INFO(6, "TextureSwap, dwhContext = %d. hTex1 = %d, hTex2 = %d",
        data.dwhContext, hTex1, hTex2);
    CALL_HALONLY(ret, lpDevI, TextureSwap, &data);
    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
        D3D_ERR("HAL failed to handle TextureSwap");
        return (D3DERR_TEXTURE_SWAP_FAILED);
    }
    return (D3D_OK);
}

__declspec (dllexport) HRESULT
D3DHAL_TextureGetSurf(LPDIRECT3DDEVICEI lpDevI,
                      D3DTEXTUREHANDLE hTex,
                      LPDIRECTDRAWSURFACE* lpDDS)
{
    if (IS_DX7HAL_DEVICE(lpDevI))
    {
        LPD3DI_TEXTUREBLOCK tBlock=LIST_FIRST(&lpDevI->texBlocks);
        while (tBlock)
        {
            if (tBlock->hTex == hTex)
            {
                *lpDDS = (LPDIRECTDRAWSURFACE)tBlock->lpD3DTextureI->lpDDS1Tex;
                return D3D_OK;
            }
            tBlock=LIST_NEXT(tBlock,devList);
        }
        return (D3DERR_TEXTURE_CREATE_FAILED);
    }
    else
    {
        D3DHAL_TEXTUREGETSURFDATA data;
        HRESULT ret;

        if (!lpDevI->lpD3DHALCallbacks->TextureGetSurf) {
            D3D_ERR("TextureGetSurf called, but no texture support.");
            return (D3DERR_TEXTURE_NO_SUPPORT);
        }

        memset(&data, 0, sizeof(D3DHAL_TEXTUREGETSURFDATA));
        data.dwhContext = lpDevI->dwhContext;
        data.dwHandle = hTex;

        D3D_INFO(6, "TextureGetSurf, getting texture for dwhContext = %d, hTex = %d",
            data.dwhContext, hTex);

        CALL_HALONLY(ret, lpDevI, TextureGetSurf, &data);
        if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
            D3D_ERR("HAL failed to handle TextureGetSurf");
            return (D3DERR_TEXTURE_CREATE_FAILED);
        }

        *lpDDS = (LPDIRECTDRAWSURFACE)data.lpDDS;

        return (D3D_OK);
    }
}

HRESULT D3DHELInst_D3DOP_TEXTURELOAD(LPDIRECT3DDEVICEI lpDevI,
                                     DWORD dwCount,
                                     LPD3DTEXTURELOAD load)
{
    HRESULT ddrval;
    DWORD i;
    LPDIRECTDRAWSURFACE lpDDSSrc;
    LPDIRECTDRAWSURFACE lpDDSDst;
    DDSURFACEDESC   ddsd;
    PALETTEENTRY    ppe[256];
    LPDIRECTDRAWPALETTE lpDDPalSrc, lpDDPalDst;
    int psize;

    for (i = 0; i < dwCount; i++) {
        if (D3DHAL_TextureGetSurf(lpDevI, load->hSrcTexture, &lpDDSSrc)) {
            D3D_ERR("HAL failed to get source surface in D3DHELInst_D3DOP_TEXTURELOAD");
            return (D3DERR_TEXTURE_LOAD_FAILED);
        }
        if (D3DHAL_TextureGetSurf(lpDevI, load->hDestTexture, &lpDDSDst)) {
            D3D_ERR("HAL failed to get destination surface in D3DHELInst_D3DOP_TEXTURELOAD");
            return (D3DERR_TEXTURE_LOAD_FAILED);
        }

        memset(&ddsd, 0, sizeof ddsd);
        ddsd.dwSize = sizeof(ddsd);
        ddrval = lpDDSDst->GetSurfaceDesc(&ddsd);
        if (ddrval != DD_OK) {
            D3D_ERR("Failed to get surface description of source texture surface in D3DHELInst_D3DOP_TEXTURELOAD");
            return (D3DERR_TEXTURE_LOAD_FAILED);
        }

        if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8) {
            psize = 256;
        } else if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED4) {
            psize = 16;
        } else {
            psize = 0;
        }

        if (psize) {
            ddrval = lpDDSSrc->GetPalette(&lpDDPalSrc);
            if (ddrval != DD_OK) {
                if (ddrval != DDERR_NOPALETTEATTACHED) {
                    D3D_ERR("Failed to get palette of source texture in D3DHELInst_D3DOP_TEXTURELOAD");
                    return (D3DERR_TEXTURE_LOAD_FAILED);
                }
            } else {
                ddrval = lpDDPalSrc->GetEntries(0, 0, psize, ppe);
                if (ddrval != DD_OK) {
                    D3D_ERR("Failed to get palette entries of source texture in D3DHELInst_D3DOP_TEXTURELOAD");
                    lpDDPalSrc->Release();
                    return (D3DERR_TEXTURE_LOAD_FAILED);
                }
                lpDDPalSrc->Release();
                ddrval = lpDDSDst->GetPalette(&lpDDPalDst);
                if (ddrval != DD_OK) {
                    D3D_ERR("Failed to get palette of destination texture in D3DHELInst_D3DOP_TEXTURELOAD");
                    return (D3DERR_TEXTURE_LOAD_FAILED);
                }
                ddrval = lpDDPalDst->SetEntries(0, 0, psize, ppe);
                if (ddrval != DD_OK) {
                    D3D_ERR("Failed to set palette entries of destination texture in D3DHELInst_D3DOP_TEXTURELOAD");
                    lpDDPalDst->Release();
                    return (D3DERR_TEXTURE_LOAD_FAILED);
                }
                lpDDPalDst->Release();
            }
        }

        lpDDSSrc->AddRef();
        lpDDSDst->AddRef();
        do {
            DDSCAPS ddscaps;
            LPDIRECTDRAWSURFACE lpDDSTmp;
            ddrval = lpDDSDst->Blt(NULL, lpDDSSrc,
                                   NULL, DDBLT_WAIT, NULL);

            if (ddrval == E_NOTIMPL && (psize == 16 || psize == 4 || psize == 2) ) {
                DDSURFACEDESC ddsd_s, ddsd_d;
                LPBYTE psrc, pdst;
                DWORD i;
                DWORD dwBytesPerLine;

                memset(&ddsd_s, 0, sizeof ddsd_s);
                memset(&ddsd_d, 0, sizeof ddsd_d);
                ddsd_s.dwSize = ddsd_d.dwSize = sizeof(DDSURFACEDESC);

                if ((ddrval = lpDDSSrc->Lock(NULL, &ddsd_s, DDLOCK_WAIT, NULL)) != DD_OK) {
                    lpDDSSrc->Release();
                    lpDDSDst->Release();
                    D3D_ERR("Failed to lock src surface");
                    return ddrval;
                }
                if ((ddrval = lpDDSDst->Lock(NULL, &ddsd_d, DDLOCK_WAIT, NULL)) != DD_OK) {
                    lpDDSSrc->Unlock(NULL);
                    lpDDSSrc->Release();
                    lpDDSDst->Release();
                    D3D_ERR("Failed to lock dst surface");
                    return ddrval;
                }

                switch (psize)
                {
                case 16: dwBytesPerLine = (ddsd.dwWidth + 1) / 2; break;
                case 4: dwBytesPerLine = (ddsd.dwWidth + 3) / 4; break;
                case 2: dwBytesPerLine = (ddsd.dwWidth + 7) / 8; break;
                }

                psrc = (LPBYTE)ddsd_s.lpSurface;
                pdst = (LPBYTE)ddsd_d.lpSurface;
                for (i = 0; i < ddsd_s.dwHeight; i++) {
                    memcpy( pdst, psrc, dwBytesPerLine );
                    psrc += ddsd_s.lPitch;
                    pdst += ddsd_d.lPitch;
                }

                lpDDSSrc->Unlock(NULL);
                lpDDSDst->Unlock(NULL);
                lpDDSSrc->Release();
                lpDDSDst->Release();
                return D3D_OK;

            }
            if (ddrval != DD_OK)
            {
                lpDDSSrc->Release();
                lpDDSDst->Release();
                return ddrval;
            }

            memset(&ddscaps, 0, sizeof(DDSCAPS));
            ddscaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
            ddrval = lpDDSSrc->GetAttachedSurface(&ddscaps, &lpDDSTmp);
            lpDDSSrc->Release();
            lpDDSSrc = lpDDSTmp;
            if (ddrval == DDERR_NOTFOUND) {
                // no more surfaces in the chain
                lpDDSDst->Release();
                break;
            } else if (ddrval != DD_OK) {
                lpDDSDst->Release();
                D3D_ERR("GetAttachedSurface of source failed in D3DHELInst_D3DOP_TEXTURELOAD");
                return (D3DERR_TEXTURE_LOAD_FAILED);
            }
            memset(&ddscaps, 0, sizeof(DDSCAPS));
            ddscaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
            ddrval = lpDDSDst->GetAttachedSurface(&ddscaps, &lpDDSTmp);
            lpDDSDst->Release();
            lpDDSDst = lpDDSTmp;
            if (ddrval == DDERR_NOTFOUND) {
                lpDDSSrc->Release();
                D3D_ERR("Destination texture has fewer attached mipmap surfaces than source in D3DHELInst_D3DOP_TEXTURELOAD");
                return (D3DERR_TEXTURE_LOAD_FAILED);
            } else if (ddrval != DD_OK) {
                lpDDSSrc->Release();
                D3D_ERR("GetAttachedSurface of destination failed in D3DHELInst_D3DOP_TEXTURELOAD");
                return (D3DERR_TEXTURE_LOAD_FAILED);
            }
        } while (1);
        load++;
    }
    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\hwprov.cpp ===
/*
 *
 * Copyright (c) Microsoft Corp. 1997
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#include "pch.cpp"
#pragma hdrstop
#include <hwprov.h>

#define nullPrimCaps {                          \
    sizeof(D3DPRIMCAPS), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0          \
}                                               \

#define nullLightCaps {                         \
    sizeof(D3DLIGHTINGCAPS), 0, 0, 0 \
}

#define transformCaps { sizeof(D3DTRANSFORMCAPS), D3DTRANSFORMCAPS_CLIP }

#define THIS_MODEL D3DLIGHTINGMODEL_RGB

#define lightingCaps {                                                  \
        sizeof(D3DLIGHTINGCAPS),                                        \
        (D3DLIGHTCAPS_POINT                                             \
         | D3DLIGHTCAPS_SPOT                                            \
         | D3DLIGHTCAPS_DIRECTIONAL                                     \
         | D3DLIGHTCAPS_PARALLELPOINT),                                 \
        THIS_MODEL,                     /* dwLightingModel */           \
        0,                              /* dwNumLights (infinite) */    \
}

/*
 * Software Driver caps
 */

static D3DDEVICEDESC devDesc =
{
    sizeof(D3DDEVICEDESC),      /* dwSize */
    D3DDD_COLORMODEL |          /* dwFlags */
    D3DDD_DEVCAPS |
    D3DDD_TRANSFORMCAPS |
    D3DDD_LIGHTINGCAPS |
    D3DDD_BCLIPPING,
    0,                          /* dcmColorModel */
    D3DDEVCAPS_FLOATTLVERTEX,   /* devCaps */
    transformCaps,              /* dtcTransformCaps */
    TRUE,                       /* bClipping */
    lightingCaps,               /* dlcLightingCaps */
    nullPrimCaps,               /* lineCaps */
    nullPrimCaps,               /* triCaps */
    0,                          /* dwDeviceRenderBitDepth */
    0,                          /* dwDeviceZBufferBitDepth */
    0,                          /* dwMaxBufferSize */
    0                           /* dwMaxVertexCount */
};

//----------------------------------------------------------------------------
//
// HwHalProvider::QueryInterface
//
// Internal interface, no need to implement.
//
//----------------------------------------------------------------------------

STDMETHODIMP HwHalProvider::QueryInterface(THIS_ REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//----------------------------------------------------------------------------
//
// HwHalProvider::AddRef
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) HwHalProvider::AddRef(THIS)
{
    return 1;
}

//----------------------------------------------------------------------------
//
// HwHalProvider::Release
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) HwHalProvider::Release(THIS)
{
    return 0;
}

//----------------------------------------------------------------------------
//
// HwHalProvider::GetCaps
//
// Returns the HAL caps.
//
//----------------------------------------------------------------------------

STDMETHODIMP
HwHalProvider::GetCaps(LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion)
{
    D3DDeviceDescConvert(pHwDesc,
                         &pDdGbl->lpD3DGlobalDriverData->hwCaps,
                         pDdGbl->lpD3DExtendedCaps);
    if (pHwDesc->dwMaxVertexCount == 0)
    {
        D3D_WARN(2, "Setting dwMaxVertexCount to %d", D3DHAL_DEFAULT_TL_NUM);
        pHwDesc->dwMaxVertexCount = D3DHAL_DEFAULT_TL_NUM;
    }
    else
    {
        D3D_INFO(2, "Hal driver has max vertices of %d", pHwDesc->dwMaxVertexCount);
    }

    *pHelDesc = devDesc;

    // Force HEL's vertex and buffer size to the HAL's.
    D3D_WARN(1, "Forcing HEL's vertex and buffer size to the HAL's v %d b %d",
        pHwDesc->dwMaxVertexCount, pHwDesc->dwMaxBufferSize);
    pHelDesc->dwMaxVertexCount = pHwDesc->dwMaxVertexCount;
    pHelDesc->dwMaxBufferSize = pHwDesc->dwMaxBufferSize;

    // Set D3DPRASTERCAPS_WFOG, texture op caps and texture stage caps
    // for legacy hal drivers off device3.
    LPD3DHAL_CALLBACKS3 lpD3DHALCallbacks3 =
        (LPD3DHAL_CALLBACKS3)pDdGbl->lpD3DHALCallbacks3;
    if (dwVersion >= 3 &&
        (lpD3DHALCallbacks3 == NULL || lpD3DHALCallbacks3->DrawPrimitives2 == NULL))
    {
        pHwDesc->dpcTriCaps.dwRasterCaps |= D3DPRASTERCAPS_WFOG;
        D3D_INFO(2, "Setting D3DPRASTERCAPS_WFOG for legacy HAL driver off Device3");

        pHwDesc->dwMaxAnisotropy = 1;
        pHwDesc->wMaxTextureBlendStages = 1;
        pHwDesc->wMaxSimultaneousTextures = 1;
        D3D_INFO(2, "Setting texture stage state info for legacy HAL driver off Device3");


        pHwDesc->dwTextureOpCaps = D3DTEXOPCAPS_DISABLE;
        if ((pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_DECAL) ||
            (pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_COPY))
        {
            pHwDesc->dwTextureOpCaps |= D3DTEXOPCAPS_SELECTARG1;
        }
        if ((pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_MODULATE) ||
            (pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_MODULATEALPHA))
        {
            pHwDesc->dwTextureOpCaps |= D3DTEXOPCAPS_MODULATE;
        }
        if (pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_ADD)
        {
            pHwDesc->dwTextureOpCaps |= D3DTEXOPCAPS_ADD;
        }
        if (pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_DECALALPHA)
        {
            pHwDesc->dwTextureOpCaps |= D3DTEXOPCAPS_BLENDTEXTUREALPHA;
        }
        D3D_INFO(2, "Setting textureop caps for legacy HAL driver off Device3");

        // map texture filter operations to DX6 set
        if ((pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_NEAREST) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MIPNEAREST) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPNEAREST))
        {
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MINFPOINT;
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MAGFPOINT;
        }
        if ((pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEAR) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MIPLINEAR) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPLINEAR))
        {
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MINFLINEAR;
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MAGFLINEAR;
        }
        if ((pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MIPNEAREST) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MIPLINEAR))
        {
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MIPFPOINT;
        }
        if ((pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPNEAREST) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPLINEAR))
        {
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MIPFLINEAR;
        }
        D3D_INFO(2, "Setting texturefilter caps for legacy HAL driver off Device3");
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// HwHalProvider::GetCallbacks
//
// Returns the HAL callbacks in the given DDraw global.
//
//----------------------------------------------------------------------------

STDMETHODIMP
HwHalProvider::GetInterface(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion)
{
    pInterfaceData->pGlobalData = pDdGbl->lpD3DGlobalDriverData;
    pInterfaceData->pExtCaps = pDdGbl->lpD3DExtendedCaps;
    pInterfaceData->pCallbacks  = pDdGbl->lpD3DHALCallbacks;
    pInterfaceData->pCallbacks2 = pDdGbl->lpD3DHALCallbacks2;

    pInterfaceData->pCallbacks3 = pDdGbl->lpD3DHALCallbacks3;
    pInterfaceData->pfnRampService = NULL;

    return S_OK;
}

//----------------------------------------------------------------------------
//
// GetHwHalProvider
//
// Returns the hardware HAL provider.
//
//----------------------------------------------------------------------------

static HwHalProvider g_HwHalProvider;

STDAPI
GetHwHalProvider(REFIID riid, IHalProvider **ppHalProvider, HINSTANCE *phDll,  LPDDRAWI_DIRECTDRAW_GBL pDdGbl)
{
    *phDll = NULL;
    if (IsEqualIID(riid, IID_IDirect3DHALDevice) && D3DI_isHALValid(pDdGbl->lpD3DHALCallbacks))
    {
        *ppHalProvider = &g_HwHalProvider;
    }
    else
    {
        *ppHalProvider = NULL;
        return E_NOINTERFACE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\init.c ===
#define INITGUID

#include <objbase.h>
#include <d3dp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\knibbt.cpp ===
#include "pch.cpp"
#pragma hdrstop

HRESULT D3DAPI katmai_FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs)
{
    LPD3DFE_CONTEXTCREATE pfnFEContextCreate = NULL;

    HKEY hKey;
    LONG lRet;
    lRet = RegOpenKey( HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey );
    if ( lRet == ERROR_SUCCESS )
    {
        char filename[_MAX_PATH];
        DWORD dwSize = sizeof(filename);
        DWORD dwType;
        lRet = RegQueryValueEx(hKey,
                               "GeometryDriver",
                               NULL,
                               &dwType,
                               (LPBYTE) filename,
                               &dwSize);
        if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
        {
            HINSTANCE hGeometryDLL;
            hGeometryDLL = LoadLibrary(filename);
            if (hGeometryDLL)
            {
                pfnFEContextCreate = (LPD3DFE_CONTEXTCREATE) GetProcAddress(hGeometryDLL, "FEContextCreate");
            }
            else
            {
                D3D_ERR("LoadLibrary failed on GeometryDriver");
                goto _error_exit;
            }
        }
        else
        {
            D3D_ERR("RegQueryValue failed on GeometryDriver");
            goto _error_exit;
        }
        RegCloseKey( hKey );
    }
    else
    {
        D3D_ERR("RegOpenKey failed on GeometryDriver");
        goto _error_exit;
    }

    // here if we think we have a valid pfnFEContextCreate
    return(pfnFEContextCreate(dwFlags, lpLeafFuncs));


_error_exit:
    return DDERR_GENERIC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\light.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   light.c
 *  Content:    Direct3D light management
 *@@BEGIN_MSINTERNAL
 * 
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   11/11/95   stevela Initial rev with this header.
 *          Light handling changed.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

/*
 * Create an api for the Direct3DLight object
 */

#include "pch.cpp"
#pragma hdrstop

HRESULT 
hookLightToD3D(LPDIRECT3DI lpD3DI,
               LPDIRECT3DLIGHTI lpD3DLight)
{

    LIST_INSERT_ROOT(&lpD3DI->lights, lpD3DLight, list);
    lpD3DLight->lpDirect3DI = lpD3DI;

    lpD3DI->numLights++;

    return (D3D_OK);
}

HRESULT D3DAPI DIRECT3DLIGHTI::Initialize(LPDIRECT3D lpD3D)
{
    return DDERR_ALREADYINITIALIZED;
}

void inverseRotateVector(D3DVECTOR* d, D3DVECTOR* v, D3DMATRIX* M)
{
    D3DVALUE vx = v->x;
    D3DVALUE vy = v->y;
    D3DVALUE vz = v->z;
    d->x = vx * M->_11 + vy * M->_12 + vz * M->_13;
    d->y = vx * M->_21 + vy * M->_22 + vz * M->_23;
    d->z = vx * M->_31 + vy * M->_32 + vz * M->_33;
}

void inverseTransformVector(D3DVECTOR* d, D3DVECTOR* v, D3DMATRIX* M)
{
    D3DVALUE vx = v->x;
    D3DVALUE vy = v->y;
    D3DVALUE vz = v->z;
    vx -= M->_41; vy -= M->_42; vz -= M->_43;
    d->x = vx * M->_11 + vy * M->_12 + vz * M->_13;
    d->y = vx * M->_21 + vy * M->_22 + vz * M->_23;
    d->z = vx * M->_31 + vy * M->_32 + vz * M->_33;
}

void D3DI_UpdateLightInternal(LPDIRECT3DLIGHTI lpLight)
{
    LPDIRECT3DVIEWPORTI lpViewI = lpLight->lpD3DViewportI;
    LPD3DLIGHT2 lpLight2 = (D3DLIGHT2 *)&lpLight->dlLight;
    
    if (sizeof(D3DLIGHT) == lpLight->dlLight.dwSize) 
    {
        lpLight->diLightData.version = 1;
        lpLight->diLightData.flags = D3DLIGHT_ACTIVE;
    } else {
        lpLight->diLightData.version = 2;
        lpLight->diLightData.flags = lpLight2->dwFlags;
    }
    lpLight->diLightData.valid  = TRUE;
    lpLight->diLightData.type   = lpLight->dlLight.dltType;
    lpLight->diLightData.red    = lpLight->dlLight.dcvColor.r;
    lpLight->diLightData.green  = lpLight->dlLight.dcvColor.g;
    lpLight->diLightData.blue   = lpLight->dlLight.dcvColor.b;
    lpLight->diLightData.position.x = lpLight->dlLight.dvPosition.x;
    lpLight->diLightData.position.y = lpLight->dlLight.dvPosition.y;
    lpLight->diLightData.position.z = lpLight->dlLight.dvPosition.z;
    lpLight->diLightData.direction.x = lpLight->dlLight.dvDirection.x;
    lpLight->diLightData.direction.y = lpLight->dlLight.dvDirection.y;
    lpLight->diLightData.direction.z = lpLight->dlLight.dvDirection.z;
    lpLight->diLightData.attenuation0 = lpLight->dlLight.dvAttenuation0;
    lpLight->diLightData.attenuation1 = lpLight->dlLight.dvAttenuation1;
    lpLight->diLightData.attenuation2 = lpLight->dlLight.dvAttenuation2;

    VecNormalize(lpLight->diLightData.direction);

    lpLight->diLightData.range = lpLight->dlLight.dvRange;
    lpLight->diLightData.range_squared = lpLight->dlLight.dvRange * lpLight->dlLight.dvRange;

    lpLight->diLightData.shade = lpLight->dlLight.dcvColor.r * 0.3f +
                                 lpLight->dlLight.dcvColor.g * 0.59f +
                                 lpLight->dlLight.dcvColor.b * 0.11f;

    if (lpLight->dlLight.dltType == D3DLIGHT_SPOT) 
    {
        lpLight->diLightData.cos_theta_by_2 = (float)cos(lpLight->dlLight.dvTheta / 2.0);
        lpLight->diLightData.cos_phi_by_2 = (float)cos(lpLight->dlLight.dvPhi / 2.0);

        if (lpLight->diLightData.version == 1) 
        {
            if (lpLight->diLightData.cos_phi_by_2 < lpLight->diLightData.cos_theta_by_2) 
            {
                lpLight->diLightData.falloff = 
                    1.0f / (lpLight->diLightData.cos_theta_by_2 -
                            lpLight->diLightData.cos_phi_by_2);
            } 
            else 
            {
                lpLight->diLightData.falloff = DTOVAL(0.0);
            }
        } 
        else 
        {
            lpLight->diLightData.falloff = lpLight->dlLight.dvFalloff;
            lpLight->diLightData.inv_theta_minus_phi = lpLight->diLightData.cos_theta_by_2 - 
                lpLight->diLightData.cos_phi_by_2;
            if (lpLight->diLightData.inv_theta_minus_phi != 0.0) 
            {
                lpLight->diLightData.inv_theta_minus_phi = 1.0f/lpLight->diLightData.inv_theta_minus_phi;
            } 
            else 
            {
                lpLight->diLightData.inv_theta_minus_phi = 1.0f;
            }
        }
    }

    /* set internal flags */
    if (lpLight->diLightData.version != 1) 
    {
        if (lpLight->diLightData.attenuation0 != 0.0) 
        {
            lpLight->diLightData.flags |= D3DLIGHTI_ATT0_IS_NONZERO;
        }
        if (lpLight->diLightData.attenuation1 != 0.0) 
        {
            lpLight->diLightData.flags |= D3DLIGHTI_ATT1_IS_NONZERO;
        }
        if (lpLight->diLightData.attenuation2 != 0.0) 
        {
            lpLight->diLightData.flags |= D3DLIGHTI_ATT2_IS_NONZERO;
        }
        if (lpLight->diLightData.falloff == 1.0) 
        {
            lpLight->diLightData.flags |= D3DLIGHTI_LINEAR_FALLOFF;
        }
    }
    if (lpViewI) 
    {
        lpViewI->bLightsChanged = TRUE;
    }
}

/*
 * Create the Light
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::CreateLight"

HRESULT D3DAPI 
DIRECT3DI::CreateLight(LPDIRECT3DLIGHT* lplpLight,
                       IUnknown* pUnkOuter)
{
    LPDIRECT3DLIGHTI    lpLight;
    HRESULT             ret;

    if(pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    if (!VALID_DIRECT3D3_PTR(this)) {
        D3D_ERR( "Invalid Direct3D pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_OUTPTR(lplpLight)) {
        D3D_ERR( "Invalid pointer to pointer" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpLight = NULL;

    /*
     * setup the object
     */

    lpLight = static_cast<LPDIRECT3DLIGHTI>(new DIRECT3DLIGHTI);
    if (!lpLight) {
        D3D_ERR("failed to allocate space for object");
        return DDERR_OUTOFMEMORY;
    }

    /*
     * Put this device in the list of those owned by the
     * Direct3Dobject
     */
    ret = hookLightToD3D(this, lpLight);
    if (ret != D3D_OK) {
        D3D_ERR("failed to associate light to Direct3D");
        D3DFree(lpLight);
        return ret;
    }

    *lplpLight = (LPDIRECT3DLIGHT)lpLight;

    return (D3D_OK);
}

DIRECT3DLIGHTI::DIRECT3DLIGHTI()
{
    lpD3DViewportI = NULL;
    memset(&dlLight, 0, sizeof(D3DLIGHT2));
    memset(&diLightData, 0, sizeof(D3DI_LIGHT));    // Internal representation of light
    refCnt = 1;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DLight::SetLight"

HRESULT D3DAPI 
DIRECT3DLIGHTI::SetLight(LPD3DLIGHT lpData)
{
    HRESULT             ret;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DLIGHT_PTR(this)) {
            D3D_ERR( "Invalid Direct3DLight pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DLIGHT_PTR(lpData) && !VALID_D3DLIGHT2_PTR(lpData)) {
            D3D_ERR( "Invalid D3DLIGHT pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (lpData->dwSize == sizeof(D3DLIGHT2)) {
            if (lpData->dltType != D3DLIGHT_POINT && 
                lpData->dltType != D3DLIGHT_SPOT &&
                lpData->dltType != D3DLIGHT_DIRECTIONAL && 
                lpData->dltType != D3DLIGHT_PARALLELPOINT) {
                D3D_ERR( "Invalid D3DLIGHT type" );
                return DDERR_INVALIDPARAMS;
            }
            if (lpData->dvRange < 0.0f || lpData->dvRange > D3DLIGHT_RANGE_MAX) {
                D3D_ERR( "Invalid D3DLIGHT range" );
                return DDERR_INVALIDPARAMS;
            }
            if (lpData->dltType == D3DLIGHT_SPOT || lpData->dltType == D3DLIGHT_DIRECTIONAL) { 
                float   magnitude;
                magnitude = lpData->dvDirection.x * lpData->dvDirection.x +
                    lpData->dvDirection.y * lpData->dvDirection.y +
                    lpData->dvDirection.z * lpData->dvDirection.z;
                if (magnitude < 0.00001f) {
                    D3D_ERR( "Invalid D3DLIGHT direction" );
                    return DDERR_INVALIDPARAMS;
                }
                if (lpData->dltType == D3DLIGHT_SPOT) {
                    if (lpData->dvPhi < 0.0f) {
                        D3D_ERR( "Invalid D3DLIGHT Phi angle, must be >= 0" );
                        return DDERR_INVALIDPARAMS;
                    }
                    if (lpData->dvPhi > 3.1415927f) {
                        D3D_ERR( "Invalid D3DLIGHT Phi angle, must be <= pi" );
                        return DDERR_INVALIDPARAMS;
                    }
                    if (lpData->dvTheta < 0.0f) {
                        D3D_ERR( "Invalid D3DLIGHT Theta angle, must be >= 0" );
                        return DDERR_INVALIDPARAMS;
                    }
                    if (lpData->dvTheta > lpData->dvPhi) {
                        D3D_ERR( "Invalid D3DLIGHT Theta angle, must be <= Phi" );
                        return DDERR_INVALIDPARAMS;
                    }
                }
            }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    /* use memcpy so this works with either D3DLIGHT or D3DLIGHT2 */
    memcpy(&this->dlLight, lpData, lpData->dwSize);
    
    D3DI_UpdateLightInternal(this);

    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DLight::GetLight"

HRESULT D3DAPI 
DIRECT3DLIGHTI::GetLight(LPD3DLIGHT lpData)
{
    HRESULT     ret;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DLIGHT_PTR(this)) {
            D3D_ERR( "Invalid Direct3DLight pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DLIGHT_PTR(lpData) && !VALID_D3DLIGHT2_PTR(lpData)) {
            D3D_ERR( "Invalid D3DLIGHT pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    /* use memcpy so this works with either D3DLIGHT or D3DLIGHT2 */
    memcpy(lpData, &this->dlLight, this->dlLight.dwSize);

    return (ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\material.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        material.c
 *  Content:        Direct3D material management
 *@@BEGIN_MSINTERNAL
 * 
 *  History:
 *   Date        By        Reason
 *   ====        ==        ======
 *   11/12/95   stevela        Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Create an api for the Direct3DMaterial object
 */

#undef  DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial"

HRESULT hookMaterialToD3D(LPDIRECT3DI lpD3DI,
                                 LPDIRECT3DMATERIALI lpD3DMatI)
{

    LIST_INSERT_ROOT(&lpD3DI->materials, lpD3DMatI, list);
    lpD3DMatI->lpDirect3DI = lpD3DI;

    lpD3DI->numMaterials++;

    return (D3D_OK);
}

HRESULT hookMaterialToDevice(LPDIRECT3DMATERIALI lpMatI,
                                    LPDIRECT3DDEVICEI lpDevI,
                                    D3DMATERIALHANDLE hMat,
                                    DWORD hMatDDI)
{
    LPD3DI_MATERIALBLOCK mBlock;

    if (D3DMalloc((void**)&mBlock, sizeof(D3DI_MATERIALBLOCK)) != D3D_OK) {
        D3D_ERR("failed to allocate space for material block");
        return (DDERR_OUTOFMEMORY);
    }
    mBlock->lpDevI = lpDevI;
    mBlock->lpD3DMaterialI = lpMatI;
    mBlock->hMat = hMat;
    mBlock->hMatDDI = hMatDDI;

    LIST_INSERT_ROOT(&lpMatI->blocks, mBlock, list);
    LIST_INSERT_ROOT(&lpDevI->matBlocks, mBlock, devList);

    return (D3D_OK);
}

void D3DI_RemoveMaterialBlock(LPD3DI_MATERIALBLOCK lpBlock)
{
    // Remove from device
    if ( lpBlock->lpDevI )
    {
        D3DHAL_MaterialDestroy(lpBlock->lpDevI, lpBlock->hMat);
    }

    LIST_DELETE(lpBlock, devList);

    // Remove from material
    LIST_DELETE(lpBlock, list);

    D3DFree(lpBlock);
}

D3DMATERIALHANDLE findMaterialHandle(LPDIRECT3DMATERIALI lpMat,
                                            LPDIRECT3DDEVICEI lpDev)
{
    LPD3DI_MATERIALBLOCK mBlock;
    D3DMATERIALHANDLE hMat = 0;

    mBlock = LIST_FIRST(&lpMat->blocks);
    while (mBlock) {
        if (!mBlock) {
            D3D_ERR("internal error - material list out of sync");
            return 0;
        }
        if (mBlock->lpDevI == lpDev) {
            hMat = mBlock->hMat;
            break;
        }
        mBlock = LIST_NEXT(mBlock,list);
    }
    return hMat;
}

HRESULT D3DAPI DIRECT3DMATERIALI::Initialize(LPDIRECT3D lpD3D)
{
    return DDERR_ALREADYINITIALIZED;
}

/*
 * Create the Material
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::CreateMaterial"

HRESULT D3DAPI DIRECT3DI::CreateMaterial(LPDIRECT3DMATERIAL* lplpD3DMat,
                                         IUnknown* pUnkOuter)
{
    LPDIRECT3DMATERIAL3 lpD3DMat3;
    HRESULT ret = CreateMaterial(&lpD3DMat3, pUnkOuter);
    if (ret == D3D_OK)
        *lplpD3DMat = static_cast<LPDIRECT3DMATERIAL>(static_cast<LPDIRECT3DMATERIALI>(lpD3DMat3));
    return ret;
}

HRESULT D3DAPI DIRECT3DI::CreateMaterial(LPDIRECT3DMATERIAL2* lplpD3DMat,
                                         IUnknown* pUnkOuter)
{
    LPDIRECT3DMATERIAL3 lpD3DMat3;
    HRESULT ret = CreateMaterial(&lpD3DMat3, pUnkOuter);
    if (ret == D3D_OK)
        *lplpD3DMat = static_cast<LPDIRECT3DMATERIAL2>(static_cast<LPDIRECT3DMATERIALI>(lpD3DMat3));
    return ret;
}

HRESULT D3DAPI DIRECT3DI::CreateMaterial(LPDIRECT3DMATERIAL3* lplpD3DMat,
                                         IUnknown* pUnkOuter)
{
    LPDIRECT3DMATERIALI        lpMat;
    HRESULT                ret;

    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 

    /*
     * validate parms
     */
    if (!VALID_DIRECT3D3_PTR(this)) {
        D3D_ERR( "Invalid Direct3D pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_OUTPTR(lplpD3DMat)) {
        D3D_ERR( "Invalid pointer to pointer" );
        return DDERR_INVALIDPARAMS;
    }
    *lplpD3DMat = NULL;

    lpMat = static_cast<LPDIRECT3DMATERIALI>(new DIRECT3DMATERIALI());
    if (!lpMat) {
        D3D_ERR("failed to allocate space for object");
        return (DDERR_OUTOFMEMORY);
    }

    /*
     * setup the object
     */
    /*
     * Put this device in the list of those owned by the
     * Direct3D object
     */
    ret = hookMaterialToD3D(this, lpMat);
    if (ret != D3D_OK) {
        D3D_ERR("failed to associate material with object");
        delete lpMat;
        return (ret);
    }

    *lplpD3DMat = (LPDIRECT3DMATERIAL3)lpMat;

    return (D3D_OK);
}

DIRECT3DMATERIALI::DIRECT3DMATERIALI()
{
    memset(&dmMaterial, 0, sizeof(D3DMATERIAL)); /* Data describing material */
    dmMaterial.dwSize = sizeof(D3DMATERIAL);
    bRes= false;    /* Is this material reserved in the driver */

    refCnt = 1;
    LIST_INITIALIZE(&blocks);

}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial::SetMaterial"

HRESULT D3DAPI DIRECT3DMATERIALI::SetMaterial(LPD3DMATERIAL lpData)
{
    HRESULT                ret;
    HRESULT                err;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DMATERIAL2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DMaterial pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DMATERIAL_PTR(lpData)) {
            D3D_ERR( "Invalid D3DMATERIAL pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (memcmp(&this->dmMaterial, lpData, sizeof(D3DMATERIAL))) {
        LPD3DI_MATERIALBLOCK mBlock = LIST_FIRST(&this->blocks);
        this->dmMaterial = *lpData;

        /*
         * Download material data
         */

        while (mBlock) {
            err = D3DHAL_MaterialSetData(mBlock->lpDevI, 
                                         mBlock->hMat,  &this->dmMaterial);
            if ( err != DD_OK ) {
                D3D_ERR("error ocurred whilst informing device about material change");
                return err;
            }
            mBlock = LIST_NEXT(mBlock,list);
        }

    }

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial::GetMaterial"

HRESULT D3DAPI DIRECT3DMATERIALI::GetMaterial(LPD3DMATERIAL lpData)
{
    HRESULT                ret;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DMATERIAL2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DMaterial pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DMATERIAL_PTR(lpData)) {
            D3D_ERR( "Invalid D3DMATERIAL pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    *lpData = this->dmMaterial;

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial::GetHandle"

HRESULT D3DAPI DIRECT3DMATERIALI::GetHandle(LPDIRECT3DDEVICE lpDev,
                                            LPD3DMATERIALHANDLE lphMat)
{
    LPDIRECT3DDEVICE3 lpDev3 = static_cast<LPDIRECT3DDEVICE3>(static_cast<LPDIRECT3DDEVICEI>(lpDev));
    return GetHandle(lpDev3, lphMat);
}

HRESULT D3DAPI DIRECT3DMATERIALI::GetHandle(LPDIRECT3DDEVICE2 lpDev,
                                            LPD3DMATERIALHANDLE lphMat)
{
    LPDIRECT3DDEVICE3 lpDev3 = static_cast<LPDIRECT3DDEVICE3>(static_cast<LPDIRECT3DDEVICEI>(lpDev));
    return GetHandle(lpDev3, lphMat);
}

HRESULT D3DAPI DIRECT3DMATERIALI::GetHandle(LPDIRECT3DDEVICE3 lpDev,
                                            LPD3DMATERIALHANDLE lphMat)
{
    LPDIRECT3DDEVICEI        lpD3DDevI;
    D3DMATERIALHANDLE        hMat;
    HRESULT                ret;
    HRESULT                err;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 

    /*
     * validate parms
     */
    TRY
    {
        lpD3DDevI = static_cast<LPDIRECT3DDEVICEI>(lpDev);
        if (!VALID_DIRECT3DMATERIAL2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DMaterial pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DDEVICE3_PTR(lpD3DDevI)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DMATERIALHANDLE_PTR(lphMat)) {
            D3D_ERR( "Invalid D3DMATERIALHANDLE pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    /*
     * If we're already on a device, return the right handle.
     */
    hMat = findMaterialHandle(this, lpD3DDevI);

    if (!hMat) {
        DWORD hMatDDI = 0x0;
        /*
         * Create the material handle through RLDDI
         */
        err = D3DHAL_MaterialCreate(lpD3DDevI, &hMat, &this->dmMaterial);
        if (err != DD_OK) {
            D3D_ERR("failed to allocate material through the device");
            return err;
        }

        err = hookMaterialToDevice(this, lpD3DDevI, hMat, hMatDDI);
        if (err != D3D_OK) {
            D3DHAL_MaterialDestroy(lpD3DDevI, hMat);
            D3D_ERR("failed to associated material to device");
            return err;
        }
    }

    *lphMat = hMat;

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial::Reserve"

HRESULT D3DAPI DIRECT3DMATERIALI::Reserve()
{
#ifdef SUPPORT_RESERVE
    LPD3DI_MATERIALBLOCK mBlock, nBlock;
#endif
    HRESULT                ret;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DMATERIAL2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DMaterial pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

#ifdef SUPPORT_RESERVE
    /*
     * Reserve the material through RLDDI
     */

    /*
     * Iterate over all devices we're associated with.
     */

    mBlock = LIST_FIRST(&this->blocks);
    while (mBlock) {
        if (RLDDIService(mBlock->lpDevI->stack, RLDDIMaterialReserve,
                         mBlock->hMat, NULL) != DD_OK) {
            D3D_ERR("failed to reserve material");
            goto free_and_exit;
        }
        mBlock = LIST_NEXT(mBlock,list);
    }
    this->bRes = 1;

    return (ret);

free_and_exit:
    nBlock = LIST_FIRST(&this->blocks);
    while (nBlock != mBlock) {
        if (!nBlock) {
            D3D_ERR("internal error - material blocks out of sync");
            return (DDERR_GENERIC);
        }
        ret = RLDDIService(nBlock->lpDevI->stack, RLDDIMaterialUnreserve,
                           (LONG)nBlock->hMat, NULL);
        if (ret != D3D_OK) {
            D3D_ERR("error occured whilst unreserving material after error");
        }
        nBlock = LIST_NEXT(nBlock,list);
    }
#else
    ret = DDERR_UNSUPPORTED;
#endif

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial::Unreserve"

HRESULT D3DAPI DIRECT3DMATERIALI::Unreserve()
{
#ifdef SUPPORT_RESERVE
    LPD3DI_MATERIALBLOCK mBlock;
#endif
    HRESULT                ret;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DMATERIAL2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DMaterial pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

#ifdef SUPPORT_RESERVE
    /*
     * Unreserve the material through RLDDI
     */
    if (this->bRes) {
        mBlock = LIST_FIRST(&this->blocks);
        while (mBlock) {
            if (RLDDIService(mBlock->lpDevI->stack, RLDDIMaterialUnreserve,
                             mBlock->hMat, NULL) != DD_OK) {
                D3D_ERR("failed to unreserve material");
            }
            mBlock = LIST_NEXT(mBlock,list);
        }
    }
#else
    ret = DDERR_UNSUPPORTED;
#endif

    return (ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\sources.inc ===
MAJORCOMP=d3dim
MINORCOMP=d3dim
TARGETNAME=d3dim
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES = ..;$(INCLUDES);$(D3DDX6)\pipeln\inc
C_DEFINES = -DBUILD_D3D_LAYER $(C_DEFINES)

SOURCES=\
    ..\beginend.cpp \
    ..\buffer.cpp   \
    ..\bufiunk.cpp  \
    ..\d3dcreat.cpp \
    ..\d3ddev.cpp   \
    ..\d3diunk.cpp  \
    ..\d3dmem.cpp   \
    ..\d3dtex.cpp   \
    ..\deviunk.cpp  \
    ..\devstate.cpp \
    ..\dlld3d.cpp   \
    ..\dp2hal.cpp   \
    ..\dphal.cpp    \
    ..\dpoldhal.cpp \
    ..\genpick.cpp  \
    ..\halbuf.cpp   \
    ..\haldrv.cpp   \
    ..\halexe.cpp   \
    ..\halmat.cpp   \
    ..\halscene.cpp \
    ..\halstate.cpp \
    ..\haltex.cpp   \
    ..\hwprov.cpp   \
    ..\init.c       \
    ..\light.cpp    \
    ..\liunk.cpp    \
    ..\material.cpp \
    ..\matiunk.cpp  \
    ..\table.cpp    \
    ..\texiunk.cpp  \
    ..\texman.cpp   \
    ..\vertbuf.cpp  \
    ..\vwiunk.cpp   \
    ..\testprov.cpp \
    ..\vwport.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp

!ifndef  MAKEDLL
!if "$(__PRODUCT)" == "DX7"
MISCFILES=$(TARGET)
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\liunk.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   liunk.c
 *  Content:    Direct3DLight IUnknown implementation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   10/12/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * D3DLight_QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DLight::QueryInterface"

HRESULT D3DAPI DIRECT3DLIGHTI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DLIGHT_PTR(this)) {
            D3D_ERR( "Invalid Direct3DLight pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(ppvObj)) {
            D3D_ERR( "Invalid pointer to pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (!VALID_OUTPTR(ppvObj)) {
        return (DDERR_INVALIDPARAMS);
    }

    *ppvObj = NULL;

    if(IsEqualIID(riid, IID_IUnknown) ||
       IsEqualIID(riid, IID_IDirect3DLight) )
    {
        AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3DLIGHT>(this));
        return (D3D_OK);
    }
    return (E_NOINTERFACE);

} /* D3DLight_QueryInterface */

/*
 * D3DLight_AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DLight::AddRef"

ULONG D3DAPI DIRECT3DLIGHTI::AddRef()
{
    DWORD       rcnt;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DLIGHT_PTR(this)) {
            D3D_ERR( "Invalid Direct3DLight pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }

    this->refCnt++;
    rcnt = this->refCnt;

    return (rcnt);
} /* D3DLight_AddRef */

/*
 * D3DLight_Release
 *
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DLight::Release"

ULONG D3DAPI DIRECT3DLIGHTI::Release()
{
    DWORD           lastrefcnt;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DLIGHT_PTR(this)) {
            D3D_ERR( "Invalid Direct3DLight pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }

    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    lastrefcnt = this->refCnt;

    if( lastrefcnt == 0 )
    {
        delete this;
        return 0;
    }
    return lastrefcnt;

} /* D3DLight_Release */

DIRECT3DLIGHTI::~DIRECT3DLIGHTI()
{
    /* remove us from our viewport's list of lights */
    if (this->lpD3DViewportI) {
        CIRCLE_QUEUE_DELETE(&this->lpD3DViewportI->lights, this, light_list);
        this->lpD3DViewportI->numLights--;
        this->lpD3DViewportI->bLightsChanged = TRUE;
    }

    /* remove us from the Direct3D object list of lights */
    LIST_DELETE(this, list);
    this->lpDirect3DI->numLights--;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\matiunk.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * 
 *  File:   matiunk.c
 *  Content:    Direct3DMaterial IUnknown implementation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   10/12/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * D3DMat_QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial::QueryInterface"

HRESULT D3DAPI DIRECT3DMATERIALI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{   
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DMATERIAL2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DMaterial pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(ppvObj)) {
            D3D_ERR( "Invalid pointer to pointer" );
            return DDERR_INVALIDPARAMS;
        }
        *ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    
    if(IsEqualIID(riid, IID_IUnknown) ||
       IsEqualIID(riid, IID_IDirect3DMaterial3) )
    {
        AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3DMATERIAL3>(this));
        return (D3D_OK);
    }
    else if (IsEqualIID(riid, IID_IDirect3DMaterial2))
    {
        AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3DMATERIAL2>(this));
        return D3D_OK;
    }
    else if (IsEqualIID(riid, IID_IDirect3DMaterial))
    {
        AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3DMATERIAL>(this));
        return D3D_OK;
    }
    else
    {
        D3D_ERR( "Don't know this riid" );
        return (E_NOINTERFACE);
    }
} /* D3DMat2_QueryInterface */

/*
 * D3DMat_AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial::AddRef"

ULONG D3DAPI DIRECT3DMATERIALI::AddRef()
{
    DWORD       rcnt;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DMATERIAL2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DMaterial pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    
    this->refCnt++;
    rcnt = this->refCnt;
    
    return (rcnt);
    
} /* D3DMat_AddRef */

/*
  * D3DMat_Release
  *
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial::Release"

ULONG D3DAPI DIRECT3DMATERIALI::Release()
{
    DWORD           lastrefcnt;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DMATERIAL2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DMaterial pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    
    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    lastrefcnt = this->refCnt;
    
    if( lastrefcnt == 0 )
    {
        delete this;
        return 0;
    }
    return lastrefcnt;
    
} /* D3DMat_Release */

DIRECT3DMATERIALI::~DIRECT3DMATERIALI()
{       
    /*
     * Remove ourselves from the devices
     */
    while (LIST_FIRST(&this->blocks)) {
        LPD3DI_MATERIALBLOCK mBlock = LIST_FIRST(&this->blocks);
        D3DI_RemoveMaterialBlock(mBlock);
    }
        
    /*
        * Remove ourselves from the Direct3D object
        */
    LIST_DELETE(this, list);
    this->lpDirect3DI->numMaterials--;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\pch.cpp ===
#include "ddrawpr.h"
#include <windows.h>
#include <assert.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include "dpf.h"
#include "d3di.hpp"
#include "d3dpr.hpp"
#include "ddrawp.h"
#include "haldrv.hpp"
#include "memalloc.h"
#include "fltval.h"
#include "texman.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\table.cpp ===
#include "pch.cpp"
#pragma hdrstop

D3DLINE LineListPrecomp[] = {
    { 0, 1 }, { 2, 3 }, { 4, 5 }, { 6, 7 }, 
    { 8, 9 }, { 10, 11 }, { 12, 13 }, { 14, 15 }, 
    { 16, 17 }, { 18, 19 }, { 20, 21 }, { 22, 23 }, 
    { 24, 25 }, { 26, 27 }, { 28, 29 }, { 30, 31 }, 
    { 32, 33 }, { 34, 35 }, { 36, 37 }, { 38, 39 }, 
    { 40, 41 }, { 42, 43 }, { 44, 45 }, { 46, 47 }, 
    { 48, 49 }, { 50, 51 }, { 52, 53 }, { 54, 55 }, 
    { 56, 57 }, { 58, 59 }, { 60, 61 }, { 62, 63 }, 
    { 64, 65 }, { 66, 67 }, { 68, 69 }, { 70, 71 }, 
    { 72, 73 }, { 74, 75 }, { 76, 77 }, { 78, 79 }, 
    { 80, 81 }, { 82, 83 }, { 84, 85 }, { 86, 87 }, 
    { 88, 89 }, { 90, 91 }, { 92, 93 }, { 94, 95 }, 
    { 96, 97 }, { 98, 99 }, { 100, 101 }, { 102, 103 }, 
    { 104, 105 }, { 106, 107 }, { 108, 109 }, { 110, 111 }, 
    { 112, 113 }, { 114, 115 }, { 116, 117 }, { 118, 119 }, 
    { 120, 121 }, { 122, 123 }, { 124, 125 }, { 126, 127 }, 
    { 128, 129 }, { 130, 131 }, { 132, 133 }, { 134, 135 }, 
    { 136, 137 }, { 138, 139 }, { 140, 141 }, { 142, 143 }, 
    { 144, 145 }, { 146, 147 }, { 148, 149 }, { 150, 151 }, 
    { 152, 153 }, { 154, 155 }, { 156, 157 }, { 158, 159 }, 
    { 160, 161 }, { 162, 163 }, { 164, 165 }, { 166, 167 }, 
    { 168, 169 }, { 170, 171 }, { 172, 173 }, { 174, 175 }, 
    { 176, 177 }, { 178, 179 }, { 180, 181 }, { 182, 183 }, 
    { 184, 185 }, { 186, 187 }, { 188, 189 }, { 190, 191 }, 
    { 192, 193 }, { 194, 195 }, { 196, 197 }, { 198, 199 }, 
    { 200, 201 }, { 202, 203 }, { 204, 205 }, { 206, 207 }, 
    { 208, 209 }, { 210, 211 }, { 212, 213 }, { 214, 215 }, 
    { 216, 217 }, { 218, 219 }, { 220, 221 }, { 222, 223 }, 
    { 224, 225 }, { 226, 227 }, { 228, 229 }, { 230, 231 }, 
    { 232, 233 }, { 234, 235 }, { 236, 237 }, { 238, 239 }, 
    { 240, 241 }, { 242, 243 }, { 244, 245 }, { 246, 247 }, 
    { 248, 249 }, { 250, 251 }, { 252, 253 }, { 254, 255 }, 
    { 256, 257 }, { 258, 259 }, { 260, 261 }, { 262, 263 }, 
    { 264, 265 }, { 266, 267 }, { 268, 269 }, { 270, 271 }, 
    { 272, 273 }, { 274, 275 }, { 276, 277 }, { 278, 279 }, 
    { 280, 281 }, { 282, 283 }, { 284, 285 }, { 286, 287 }, 
    { 288, 289 }, { 290, 291 }, { 292, 293 }, { 294, 295 }, 
    { 296, 297 }, { 298, 299 }, { 300, 301 }, { 302, 303 }, 
    { 304, 305 }, { 306, 307 }, { 308, 309 }, { 310, 311 }, 
    { 312, 313 }, { 314, 315 }, { 316, 317 }, { 318, 319 }, 
    { 320, 321 }, { 322, 323 }, { 324, 325 }, { 326, 327 }, 
    { 328, 329 }, { 330, 331 }, { 332, 333 }, { 334, 335 }, 
    { 336, 337 }, { 338, 339 }, { 340, 341 }, { 342, 343 }, 
    { 344, 345 }, { 346, 347 }, { 348, 349 }, { 350, 351 }, 
    { 352, 353 }, { 354, 355 }, { 356, 357 }, { 358, 359 }, 
    { 360, 361 }, { 362, 363 }, { 364, 365 }, { 366, 367 }, 
    { 368, 369 }, { 370, 371 }, { 372, 373 }, { 374, 375 }, 
    { 376, 377 }, { 378, 379 }, { 380, 381 }, { 382, 383 }, 
    { 384, 385 }, { 386, 387 }, { 388, 389 }, { 390, 391 }, 
    { 392, 393 }, { 394, 395 }, { 396, 397 }, { 398, 399 }, 
    { 400, 401 }, { 402, 403 }, { 404, 405 }, { 406, 407 }, 
    { 408, 409 }, { 410, 411 }, { 412, 413 }, { 414, 415 }, 
    { 416, 417 }, { 418, 419 }, { 420, 421 }, { 422, 423 }, 
    { 424, 425 }, { 426, 427 }, { 428, 429 }, { 430, 431 }, 
    { 432, 433 }, { 434, 435 }, { 436, 437 }, { 438, 439 }, 
    { 440, 441 }, { 442, 443 }, { 444, 445 }, { 446, 447 }, 
    { 448, 449 }, { 450, 451 }, { 452, 453 }, { 454, 455 }, 
    { 456, 457 }, { 458, 459 }, { 460, 461 }, { 462, 463 }, 
    { 464, 465 }, { 466, 467 }, { 468, 469 }, { 470, 471 }, 
    { 472, 473 }, { 474, 475 }, { 476, 477 }, { 478, 479 }, 
    { 480, 481 }, { 482, 483 }, { 484, 485 }, { 486, 487 }, 
    { 488, 489 }, { 490, 491 }, { 492, 493 }, { 494, 495 }, 
    { 496, 497 }, { 498, 499 }, { 500, 501 }, { 502, 503 }, 
    { 504, 505 }, { 506, 507 }, { 508, 509 }, { 510, 511 },
    { 512, 513 }, { 514, 515 }, { 516, 517 }, { 518, 519 },
    { 520, 521 }, { 522, 523 }, { 524, 525 }, { 526, 527 }, 
    { 528, 529 }, { 530, 531 }, { 532, 533 }, { 534, 535 }, 
    { 536, 537 }, { 538, 539 }, { 540, 541 }, { 542, 543 }, 
    { 544, 545 }, { 546, 547 }, { 548, 549 }, { 550, 551 }, 
    { 552, 553 }, { 554, 555 }, { 556, 557 }, { 558, 559 }, 
    { 560, 561 }, { 562, 563 }, { 564, 565 }, { 566, 567 }, 
    { 568, 569 }, { 570, 571 }, { 572, 573 }, { 574, 575 }, 
    { 576, 577 }, { 578, 579 }, { 580, 581 }, { 582, 583 }, 
    { 584, 585 }, { 586, 587 }, { 588, 589 }, { 590, 591 }, 
    { 592, 593 }, { 594, 595 }, { 596, 597 }, { 598, 599 }, 
    { 600, 601 }, { 602, 603 }, { 604, 605 }, { 606, 607 }, 
    { 608, 609 }, { 610, 611 }, { 612, 613 }, { 614, 615 }, 
    { 616, 617 }, { 618, 619 }, { 620, 621 }, { 622, 623 }, 
    { 624, 625 }, { 626, 627 }, { 628, 629 }, { 630, 631 }, 
    { 632, 633 }, { 634, 635 }, { 636, 637 }, { 638, 639 }, 
    { 640, 641 }, { 642, 643 }, { 644, 645 }, { 646, 647 }, 
    { 648, 649 }, { 650, 651 }, { 652, 653 }, { 654, 655 }, 
    { 656, 657 }, { 658, 659 }, { 660, 661 }, { 662, 663 }, 
    { 664, 665 }, { 666, 667 }, { 668, 669 }, { 670, 671 }, 
    { 672, 673 }, { 674, 675 }, { 676, 677 }, { 678, 679 }, 
    { 680, 681 }, { 682, 683 }, { 684, 685 }, { 686, 687 }, 
    { 688, 689 }, { 690, 691 }, { 692, 693 }, { 694, 695 }, 
    { 696, 697 }, { 698, 699 }, { 700, 701 }, { 702, 703 }, 
    { 704, 705 }, { 706, 707 }, { 708, 709 }, { 710, 711 }, 
    { 712, 713 }, { 714, 715 }, { 716, 717 }, { 718, 719 }, 
    { 720, 721 }, { 722, 723 }, { 724, 725 }, { 726, 727 }, 
    { 728, 729 }, { 730, 731 }, { 732, 733 }, { 734, 735 }, 
    { 736, 737 }, { 738, 739 }, { 740, 741 }, { 742, 743 }, 
    { 744, 745 }, { 746, 747 }, { 748, 749 }, { 750, 751 }, 
    { 752, 753 }, { 754, 755 }, { 756, 757 }, { 758, 759 }, 
    { 760, 761 }, { 762, 763 }, { 764, 765 }, { 766, 767 }, 
    { 768, 769 }, { 770, 771 }, { 772, 773 }, { 774, 775 }, 
    { 776, 777 }, { 778, 779 }, { 780, 781 }, { 782, 783 }, 
    { 784, 785 }, { 786, 787 }, { 788, 789 }, { 790, 791 }, 
    { 792, 793 }, { 794, 795 }, { 796, 797 }, { 798, 799 }, 
    { 800, 801 }, { 802, 803 }, { 804, 805 }, { 806, 807 }, 
    { 808, 809 }, { 810, 811 }, { 812, 813 }, { 814, 815 }, 
    { 816, 817 }, { 818, 819 }, { 